import {
  AJAXError,
  AsyncSeriesBailHook,
  AsyncWaterfallHook,
  AttributeType,
  BKDRHash,
  BaseMapService,
  BaseMapWrapper,
  BasePostProcessingPass,
  BlendType,
  CameraUniform,
  CoordinateSystem,
  CoordinateUniform,
  EarthWrapper,
  FrequencyController,
  GMapWrapper,
  GaodeMap,
  GaodeMapV1,
  GaodeMapV2,
  IDebugLog,
  ILayerStage,
  InteractionEvent,
  LRUCache,
  LoadTileDataStatus,
  MapServiceEvent,
  MapboxWrapper,
  MapboxWrapper2,
  MapboxWrapper3,
  MapboxWrapper4,
  MaskOperation,
  PassType,
  PositionType,
  RasterTileType,
  ScaleTypes,
  SceneConifg,
  SceneEventList,
  SourceTile,
  StencilType,
  StyleScaleType,
  SyncBailHook,
  SyncHook,
  TMapWrapper,
  TdtMapWrapper,
  TextureUsage,
  TilesetManager,
  UpdateTileStrategy,
  __commonJS,
  __toESM,
  _asyncToGenerator,
  _defineProperty,
  _objectSpread2,
  _objectWithoutProperties,
  aProjectFlat,
  amap2Project,
  amap2UnProject,
  anchorTranslate,
  anchorType,
  applyAnchorClass,
  bBoxToBounds,
  bindAll,
  boundsContains,
  calAngle,
  calDistance,
  calculateCentroid,
  calculatePointsCenterAndRadius,
  color,
  createLayerContainer,
  createSceneContainer,
  cubehelix,
  decodePickingColor,
  defaultValue,
  djb2hash,
  dom_exports,
  encodePickingColor,
  expandUrl,
  extent,
  flattenEach,
  flow,
  formatImage,
  fp64LowPart,
  generateCatRamp,
  generateColorRamp,
  generateCustomRamp,
  generateLinearRamp,
  generateQuantizeRamp,
  getAngle,
  getArrayBuffer,
  getBBoxFromPoints,
  getData,
  getDefaultDomain,
  getImage,
  getJSON,
  getProtocolAction,
  getReferrer,
  getTileIndices,
  getTileWarpXY,
  getURLFromTemplate,
  getWMTSURLFromTemplate,
  gl,
  globalConfigService,
  guid,
  hcl,
  hsl,
  isAndroid,
  isColor,
  isImageBitmap,
  isNumber,
  isPC,
  isURLTemplate,
  isWorker,
  isiOS,
  latitude,
  lineAtOffset,
  lineAtOffsetAsyc,
  lngLatInExtent,
  lngLatToMeters,
  lnglatDistance,
  lodashUtil,
  longitude,
  makeXMLHttpRequestPromise,
  mat4_exports,
  metersToLngLat,
  multiPolygon,
  normalize,
  osmLonLat2TileXY,
  osmTileXY2LonLat,
  packCircleVertex,
  padBounds,
  polygon,
  postData,
  project,
  removeDuplicateUniforms,
  require_eventemitter3,
  require_point_geometry,
  rgb,
  rgb2arr,
  sameOrigin,
  statistics_exports,
  tileToBounds,
  tranfrormCoord,
  unProjectFlat,
  validateLngLat,
  vec2_exports,
  vec3_exports,
  vec4_exports
} from "./chunk-YJ4H67WD.js";

// node_modules/@mapbox/geojson-rewind/index.js
var require_geojson_rewind = __commonJS({
  "node_modules/@mapbox/geojson-rewind/index.js"(exports, module) {
    module.exports = rewind3;
    function rewind3(gj, outer) {
      var type = gj && gj.type, i;
      if (type === "FeatureCollection") {
        for (i = 0; i < gj.features.length; i++)
          rewind3(gj.features[i], outer);
      } else if (type === "GeometryCollection") {
        for (i = 0; i < gj.geometries.length; i++)
          rewind3(gj.geometries[i], outer);
      } else if (type === "Feature") {
        rewind3(gj.geometry, outer);
      } else if (type === "Polygon") {
        rewindRings(gj.coordinates, outer);
      } else if (type === "MultiPolygon") {
        for (i = 0; i < gj.coordinates.length; i++)
          rewindRings(gj.coordinates[i], outer);
      }
      return gj;
    }
    function rewindRings(rings, outer) {
      if (rings.length === 0)
        return;
      rewindRing(rings[0], outer);
      for (var i = 1; i < rings.length; i++) {
        rewindRing(rings[i], !outer);
      }
    }
    function rewindRing(ring, dir) {
      var area = 0, err = 0;
      for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
        var k = (ring[i][0] - ring[j][0]) * (ring[j][1] + ring[i][1]);
        var m = area + k;
        err += Math.abs(area) >= Math.abs(k) ? area - m + k : k - m + area;
        area = m;
      }
      if (area + err >= 0 !== !!dir)
        ring.reverse();
    }
  }
});

// node_modules/@mapbox/vector-tile/lib/vectortilefeature.js
var require_vectortilefeature = __commonJS({
  "node_modules/@mapbox/vector-tile/lib/vectortilefeature.js"(exports, module) {
    "use strict";
    var Point = require_point_geometry();
    module.exports = VectorTileFeature;
    function VectorTileFeature(pbf, end, extent2, keys, values) {
      this.properties = {};
      this.extent = extent2;
      this.type = 0;
      this._pbf = pbf;
      this._geometry = -1;
      this._keys = keys;
      this._values = values;
      pbf.readFields(readFeature, this, end);
    }
    function readFeature(tag, feature, pbf) {
      if (tag == 1)
        feature.id = pbf.readVarint();
      else if (tag == 2)
        readTag(pbf, feature);
      else if (tag == 3)
        feature.type = pbf.readVarint();
      else if (tag == 4)
        feature._geometry = pbf.pos;
    }
    function readTag(pbf, feature) {
      var end = pbf.readVarint() + pbf.pos;
      while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()], value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
      }
    }
    VectorTileFeature.types = ["Unknown", "Point", "LineString", "Polygon"];
    VectorTileFeature.prototype.loadGeometry = function() {
      var pbf = this._pbf;
      pbf.pos = this._geometry;
      var end = pbf.readVarint() + pbf.pos, cmd = 1, length2 = 0, x = 0, y = 0, lines = [], line;
      while (pbf.pos < end) {
        if (length2 <= 0) {
          var cmdLen = pbf.readVarint();
          cmd = cmdLen & 7;
          length2 = cmdLen >> 3;
        }
        length2--;
        if (cmd === 1 || cmd === 2) {
          x += pbf.readSVarint();
          y += pbf.readSVarint();
          if (cmd === 1) {
            if (line)
              lines.push(line);
            line = [];
          }
          line.push(new Point(x, y));
        } else if (cmd === 7) {
          if (line) {
            line.push(line[0].clone());
          }
        } else {
          throw new Error("unknown command " + cmd);
        }
      }
      if (line)
        lines.push(line);
      return lines;
    };
    VectorTileFeature.prototype.bbox = function() {
      var pbf = this._pbf;
      pbf.pos = this._geometry;
      var end = pbf.readVarint() + pbf.pos, cmd = 1, length2 = 0, x = 0, y = 0, x1 = Infinity, x2 = -Infinity, y1 = Infinity, y2 = -Infinity;
      while (pbf.pos < end) {
        if (length2 <= 0) {
          var cmdLen = pbf.readVarint();
          cmd = cmdLen & 7;
          length2 = cmdLen >> 3;
        }
        length2--;
        if (cmd === 1 || cmd === 2) {
          x += pbf.readSVarint();
          y += pbf.readSVarint();
          if (x < x1)
            x1 = x;
          if (x > x2)
            x2 = x;
          if (y < y1)
            y1 = y;
          if (y > y2)
            y2 = y;
        } else if (cmd !== 7) {
          throw new Error("unknown command " + cmd);
        }
      }
      return [x1, y1, x2, y2];
    };
    VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
      var size2 = this.extent * Math.pow(2, z), x0 = this.extent * x, y0 = this.extent * y, coords = this.loadGeometry(), type = VectorTileFeature.types[this.type], i, j;
      function project2(line) {
        for (var j2 = 0; j2 < line.length; j2++) {
          var p = line[j2], y2 = 180 - (p.y + y0) * 360 / size2;
          line[j2] = [
            (p.x + x0) * 360 / size2 - 180,
            360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
          ];
        }
      }
      switch (this.type) {
        case 1:
          var points = [];
          for (i = 0; i < coords.length; i++) {
            points[i] = coords[i][0];
          }
          coords = points;
          project2(coords);
          break;
        case 2:
          for (i = 0; i < coords.length; i++) {
            project2(coords[i]);
          }
          break;
        case 3:
          coords = classifyRings2(coords);
          for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
              project2(coords[i][j]);
            }
          }
          break;
      }
      if (coords.length === 1) {
        coords = coords[0];
      } else {
        type = "Multi" + type;
      }
      var result = {
        type: "Feature",
        geometry: {
          type,
          coordinates: coords
        },
        properties: this.properties
      };
      if ("id" in this) {
        result.id = this.id;
      }
      return result;
    };
    function classifyRings2(rings) {
      var len = rings.length;
      if (len <= 1)
        return [rings];
      var polygons = [], polygon2, ccw;
      for (var i = 0; i < len; i++) {
        var area = signedArea2(rings[i]);
        if (area === 0)
          continue;
        if (ccw === void 0)
          ccw = area < 0;
        if (ccw === area < 0) {
          if (polygon2)
            polygons.push(polygon2);
          polygon2 = [rings[i]];
        } else {
          polygon2.push(rings[i]);
        }
      }
      if (polygon2)
        polygons.push(polygon2);
      return polygons;
    }
    function signedArea2(ring) {
      var sum4 = 0;
      for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum4 += (p2.x - p1.x) * (p1.y + p2.y);
      }
      return sum4;
    }
  }
});

// node_modules/@mapbox/vector-tile/lib/vectortilelayer.js
var require_vectortilelayer = __commonJS({
  "node_modules/@mapbox/vector-tile/lib/vectortilelayer.js"(exports, module) {
    "use strict";
    var VectorTileFeature = require_vectortilefeature();
    module.exports = VectorTileLayer;
    function VectorTileLayer(pbf, end) {
      this.version = 1;
      this.name = null;
      this.extent = 4096;
      this.length = 0;
      this._pbf = pbf;
      this._keys = [];
      this._values = [];
      this._features = [];
      pbf.readFields(readLayer, this, end);
      this.length = this._features.length;
    }
    function readLayer(tag, layer, pbf) {
      if (tag === 15)
        layer.version = pbf.readVarint();
      else if (tag === 1)
        layer.name = pbf.readString();
      else if (tag === 5)
        layer.extent = pbf.readVarint();
      else if (tag === 2)
        layer._features.push(pbf.pos);
      else if (tag === 3)
        layer._keys.push(pbf.readString());
      else if (tag === 4)
        layer._values.push(readValueMessage(pbf));
    }
    function readValueMessage(pbf) {
      var value = null, end = pbf.readVarint() + pbf.pos;
      while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;
        value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
      }
      return value;
    }
    VectorTileLayer.prototype.feature = function(i) {
      if (i < 0 || i >= this._features.length)
        throw new Error("feature index out of bounds");
      this._pbf.pos = this._features[i];
      var end = this._pbf.readVarint() + this._pbf.pos;
      return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
    };
  }
});

// node_modules/@mapbox/vector-tile/lib/vectortile.js
var require_vectortile = __commonJS({
  "node_modules/@mapbox/vector-tile/lib/vectortile.js"(exports, module) {
    "use strict";
    var VectorTileLayer = require_vectortilelayer();
    module.exports = VectorTile3;
    function VectorTile3(pbf, end) {
      this.layers = pbf.readFields(readTile, {}, end);
    }
    function readTile(tag, layers, pbf) {
      if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length)
          layers[layer.name] = layer;
      }
    }
  }
});

// node_modules/@mapbox/vector-tile/index.js
var require_vector_tile = __commonJS({
  "node_modules/@mapbox/vector-tile/index.js"(exports, module) {
    module.exports.VectorTile = require_vectortile();
    module.exports.VectorTileFeature = require_vectortilefeature();
    module.exports.VectorTileLayer = require_vectortilelayer();
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/pbf/index.js
var require_pbf = __commonJS({
  "node_modules/pbf/index.js"(exports, module) {
    "use strict";
    module.exports = Pbf;
    var ieee754 = require_ieee754();
    function Pbf(buf) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
      this.pos = 0;
      this.type = 0;
      this.length = this.buf.length;
    }
    Pbf.Varint = 0;
    Pbf.Fixed64 = 1;
    Pbf.Bytes = 2;
    Pbf.Fixed32 = 5;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var TEXT_DECODER_MIN_LENGTH = 12;
    var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
    Pbf.prototype = {
      destroy: function() {
        this.buf = null;
      },
      // === READING =================================================================
      readFields: function(readField, result, end) {
        end = end || this.length;
        while (this.pos < end) {
          var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
          this.type = val & 7;
          readField(tag, result, this);
          if (this.pos === startPos)
            this.skip(val);
        }
        return result;
      },
      readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
      },
      readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
      },
      readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
      },
      // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
      readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
      },
      readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
      },
      readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
      },
      readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
      },
      readVarint: function(isSigned) {
        var buf = this.buf, val, b;
        b = buf[this.pos++];
        val = b & 127;
        if (b < 128)
          return val;
        b = buf[this.pos++];
        val |= (b & 127) << 7;
        if (b < 128)
          return val;
        b = buf[this.pos++];
        val |= (b & 127) << 14;
        if (b < 128)
          return val;
        b = buf[this.pos++];
        val |= (b & 127) << 21;
        if (b < 128)
          return val;
        b = buf[this.pos];
        val |= (b & 15) << 28;
        return readVarintRemainder(val, isSigned, this);
      },
      readVarint64: function() {
        return this.readVarint(true);
      },
      readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      },
      readBoolean: function() {
        return Boolean(this.readVarint());
      },
      readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;
        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
          return readUtf8TextDecoder(this.buf, pos, end);
        }
        return readUtf8(this.buf, pos, end);
      },
      readBytes: function() {
        var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
      },
      // verbose for performance reasons; doesn't affect gzipped size
      readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readVarint(isSigned));
        return arr;
      },
      readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSVarint());
        return arr;
      },
      readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readBoolean());
        return arr;
      },
      readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFloat());
        return arr;
      },
      readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readDouble());
        return arr;
      },
      readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFixed32());
        return arr;
      },
      readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSFixed32());
        return arr;
      },
      readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFixed64());
        return arr;
      },
      readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSFixed64());
        return arr;
      },
      skip: function(val) {
        var type = val & 7;
        if (type === Pbf.Varint)
          while (this.buf[this.pos++] > 127) {
          }
        else if (type === Pbf.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32)
          this.pos += 4;
        else if (type === Pbf.Fixed64)
          this.pos += 8;
        else
          throw new Error("Unimplemented type: " + type);
      },
      // === WRITING =================================================================
      writeTag: function(tag, type) {
        this.writeVarint(tag << 3 | type);
      },
      realloc: function(min3) {
        var length2 = this.length || 16;
        while (length2 < this.pos + min3)
          length2 *= 2;
        if (length2 !== this.length) {
          var buf = new Uint8Array(length2);
          buf.set(this.buf);
          this.buf = buf;
          this.length = length2;
        }
      },
      finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
      },
      writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
      },
      writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
      },
      writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeVarint: function(val) {
        val = +val || 0;
        if (val > 268435455 || val < 0) {
          writeBigVarint(val, this);
          return;
        }
        this.realloc(4);
        this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
        if (val <= 127)
          return;
        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
        if (val <= 127)
          return;
        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
        if (val <= 127)
          return;
        this.buf[this.pos++] = val >>> 7 & 127;
      },
      writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
      },
      writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
      },
      writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);
        this.pos++;
        var startPos = this.pos;
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;
        if (len >= 128)
          makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
      },
      writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
      },
      writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++)
          this.buf[this.pos++] = buffer[i];
      },
      writeRawMessage: function(fn, obj) {
        this.pos++;
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;
        if (len >= 128)
          makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
      },
      writePackedVarint: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedVarint, arr);
      },
      writePackedSVarint: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSVarint, arr);
      },
      writePackedBoolean: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedBoolean, arr);
      },
      writePackedFloat: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFloat, arr);
      },
      writePackedDouble: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedDouble, arr);
      },
      writePackedFixed32: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFixed32, arr);
      },
      writePackedSFixed32: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSFixed32, arr);
      },
      writePackedFixed64: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFixed64, arr);
      },
      writePackedSFixed64: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSFixed64, arr);
      },
      writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
      },
      writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
      },
      writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
      },
      writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
      },
      writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
      },
      writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
      },
      writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
      },
      writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
      },
      writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
      },
      writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
      },
      writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
      }
    };
    function readVarintRemainder(l, s, p) {
      var buf = p.buf, h, b;
      b = buf[p.pos++];
      h = (b & 112) >> 4;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 3;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 10;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 17;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 127) << 24;
      if (b < 128)
        return toNum(l, h, s);
      b = buf[p.pos++];
      h |= (b & 1) << 31;
      if (b < 128)
        return toNum(l, h, s);
      throw new Error("Expected varint not more than 10 bytes");
    }
    function readPackedEnd(pbf) {
      return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    }
    function toNum(low, high, isSigned) {
      if (isSigned) {
        return high * 4294967296 + (low >>> 0);
      }
      return (high >>> 0) * 4294967296 + (low >>> 0);
    }
    function writeBigVarint(val, pbf) {
      var low, high;
      if (val >= 0) {
        low = val % 4294967296 | 0;
        high = val / 4294967296 | 0;
      } else {
        low = ~(-val % 4294967296);
        high = ~(-val / 4294967296);
        if (low ^ 4294967295) {
          low = low + 1 | 0;
        } else {
          low = 0;
          high = high + 1 | 0;
        }
      }
      if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
        throw new Error("Given varint doesn't fit into 10 bytes");
      }
      pbf.realloc(10);
      writeBigVarintLow(low, high, pbf);
      writeBigVarintHigh(high, pbf);
    }
    function writeBigVarintLow(low, high, pbf) {
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos] = low & 127;
    }
    function writeBigVarintHigh(high, pbf) {
      var lsb = (high & 7) << 4;
      pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127;
    }
    function makeRoomForExtraLength(startPos, len, pbf) {
      var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
      pbf.realloc(extraLen);
      for (var i = pbf.pos - 1; i >= startPos; i--)
        pbf.buf[i + extraLen] = pbf.buf[i];
    }
    function writePackedVarint(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeVarint(arr[i]);
    }
    function writePackedSVarint(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeSVarint(arr[i]);
    }
    function writePackedFloat(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeFloat(arr[i]);
    }
    function writePackedDouble(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeDouble(arr[i]);
    }
    function writePackedBoolean(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeBoolean(arr[i]);
    }
    function writePackedFixed32(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeFixed32(arr[i]);
    }
    function writePackedSFixed32(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeSFixed32(arr[i]);
    }
    function writePackedFixed64(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeFixed64(arr[i]);
    }
    function writePackedSFixed64(arr, pbf) {
      for (var i = 0; i < arr.length; i++)
        pbf.writeSFixed64(arr[i]);
    }
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    function writeInt32(buf, val, pos) {
      buf[pos] = val;
      buf[pos + 1] = val >>> 8;
      buf[pos + 2] = val >>> 16;
      buf[pos + 3] = val >>> 24;
    }
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    function readUtf8(buf, pos, end) {
      var str = "";
      var i = pos;
      while (i < end) {
        var b0 = buf[i];
        var c = null;
        var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
        if (i + bytesPerSequence > end)
          break;
        var b1, b2, b3;
        if (bytesPerSequence === 1) {
          if (b0 < 128) {
            c = b0;
          }
        } else if (bytesPerSequence === 2) {
          b1 = buf[i + 1];
          if ((b1 & 192) === 128) {
            c = (b0 & 31) << 6 | b1 & 63;
            if (c <= 127) {
              c = null;
            }
          }
        } else if (bytesPerSequence === 3) {
          b1 = buf[i + 1];
          b2 = buf[i + 2];
          if ((b1 & 192) === 128 && (b2 & 192) === 128) {
            c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
            if (c <= 2047 || c >= 55296 && c <= 57343) {
              c = null;
            }
          }
        } else if (bytesPerSequence === 4) {
          b1 = buf[i + 1];
          b2 = buf[i + 2];
          b3 = buf[i + 3];
          if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
            c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
            if (c <= 65535 || c >= 1114112) {
              c = null;
            }
          }
        }
        if (c === null) {
          c = 65533;
          bytesPerSequence = 1;
        } else if (c > 65535) {
          c -= 65536;
          str += String.fromCharCode(c >>> 10 & 1023 | 55296);
          c = 56320 | c & 1023;
        }
        str += String.fromCharCode(c);
        i += bytesPerSequence;
      }
      return str;
    }
    function readUtf8TextDecoder(buf, pos, end) {
      return utf8TextDecoder.decode(buf.subarray(pos, end));
    }
    function writeUtf8(buf, str, pos) {
      for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i);
        if (c > 55295 && c < 57344) {
          if (lead) {
            if (c < 56320) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
              lead = c;
              continue;
            } else {
              c = lead - 55296 << 10 | c - 56320 | 65536;
              lead = null;
            }
          } else {
            if (c > 56319 || i + 1 === str.length) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
            } else {
              lead = c;
            }
            continue;
          }
        } else if (lead) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
          lead = null;
        }
        if (c < 128) {
          buf[pos++] = c;
        } else {
          if (c < 2048) {
            buf[pos++] = c >> 6 | 192;
          } else {
            if (c < 65536) {
              buf[pos++] = c >> 12 | 224;
            } else {
              buf[pos++] = c >> 18 | 240;
              buf[pos++] = c >> 12 & 63 | 128;
            }
            buf[pos++] = c >> 6 & 63 | 128;
          }
          buf[pos++] = c & 63 | 128;
        }
      }
      return pos;
    }
  }
});

// node_modules/supercluster/dist/supercluster.js
var require_supercluster = __commonJS({
  "node_modules/supercluster/dist/supercluster.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.Supercluster = factory());
    })(exports, function() {
      "use strict";
      function sortKD(ids, coords, nodeSize, left, right, depth) {
        if (right - left <= nodeSize) {
          return;
        }
        var m = left + right >> 1;
        select(ids, coords, m, left, right, depth % 2);
        sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
        sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
      }
      function select(ids, coords, k, left, right, inc) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            select(ids, coords, k, newLeft, newRight, inc);
          }
          var t = coords[2 * k + inc];
          var i = left;
          var j = right;
          swapItem(ids, coords, left, k);
          if (coords[2 * right + inc] > t) {
            swapItem(ids, coords, left, right);
          }
          while (i < j) {
            swapItem(ids, coords, i, j);
            i++;
            j--;
            while (coords[2 * i + inc] < t) {
              i++;
            }
            while (coords[2 * j + inc] > t) {
              j--;
            }
          }
          if (coords[2 * left + inc] === t) {
            swapItem(ids, coords, left, j);
          } else {
            j++;
            swapItem(ids, coords, j, right);
          }
          if (j <= k) {
            left = j + 1;
          }
          if (k <= j) {
            right = j - 1;
          }
        }
      }
      function swapItem(ids, coords, i, j) {
        swap(ids, i, j);
        swap(coords, 2 * i, 2 * j);
        swap(coords, 2 * i + 1, 2 * j + 1);
      }
      function swap(arr, i, j) {
        var tmp2 = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp2;
      }
      function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {
        var stack = [0, ids.length - 1, 0];
        var result = [];
        var x, y;
        while (stack.length) {
          var axis = stack.pop();
          var right = stack.pop();
          var left = stack.pop();
          if (right - left <= nodeSize) {
            for (var i = left; i <= right; i++) {
              x = coords[2 * i];
              y = coords[2 * i + 1];
              if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                result.push(ids[i]);
              }
            }
            continue;
          }
          var m = Math.floor((left + right) / 2);
          x = coords[2 * m];
          y = coords[2 * m + 1];
          if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
            result.push(ids[m]);
          }
          var nextAxis = (axis + 1) % 2;
          if (axis === 0 ? minX <= x : minY <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
          }
          if (axis === 0 ? maxX >= x : maxY >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
          }
        }
        return result;
      }
      function within(ids, coords, qx, qy, r, nodeSize) {
        var stack = [0, ids.length - 1, 0];
        var result = [];
        var r2 = r * r;
        while (stack.length) {
          var axis = stack.pop();
          var right = stack.pop();
          var left = stack.pop();
          if (right - left <= nodeSize) {
            for (var i = left; i <= right; i++) {
              if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) {
                result.push(ids[i]);
              }
            }
            continue;
          }
          var m = Math.floor((left + right) / 2);
          var x = coords[2 * m];
          var y = coords[2 * m + 1];
          if (sqDist(x, y, qx, qy) <= r2) {
            result.push(ids[m]);
          }
          var nextAxis = (axis + 1) % 2;
          if (axis === 0 ? qx - r <= x : qy - r <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
          }
          if (axis === 0 ? qx + r >= x : qy + r >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
          }
        }
        return result;
      }
      function sqDist(ax, ay, bx, by) {
        var dx = ax - bx;
        var dy = ay - by;
        return dx * dx + dy * dy;
      }
      var defaultGetX = function(p) {
        return p[0];
      };
      var defaultGetY = function(p) {
        return p[1];
      };
      var KDBush = function KDBush2(points, getX2, getY2, nodeSize, ArrayType) {
        if (getX2 === void 0)
          getX2 = defaultGetX;
        if (getY2 === void 0)
          getY2 = defaultGetY;
        if (nodeSize === void 0)
          nodeSize = 64;
        if (ArrayType === void 0)
          ArrayType = Float64Array;
        this.nodeSize = nodeSize;
        this.points = points;
        var IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;
        var ids = this.ids = new IndexArrayType(points.length);
        var coords = this.coords = new ArrayType(points.length * 2);
        for (var i = 0; i < points.length; i++) {
          ids[i] = i;
          coords[2 * i] = getX2(points[i]);
          coords[2 * i + 1] = getY2(points[i]);
        }
        sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);
      };
      KDBush.prototype.range = function range$1(minX, minY, maxX, maxY) {
        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
      };
      KDBush.prototype.within = function within$1(x, y, r) {
        return within(this.ids, this.coords, x, y, r, this.nodeSize);
      };
      var defaultOptions = {
        minZoom: 0,
        // min zoom to generate clusters on
        maxZoom: 16,
        // max zoom level to cluster the points on
        minPoints: 2,
        // minimum points to form a cluster
        radius: 40,
        // cluster radius in pixels
        extent: 512,
        // tile extent (radius is calculated relative to it)
        nodeSize: 64,
        // size of the KD-tree leaf node, affects performance
        log: false,
        // whether to log timing info
        // whether to generate numeric ids for input features (in vector tiles)
        generateId: false,
        // a reduce function for calculating custom cluster properties
        reduce: null,
        // (accumulated, props) => { accumulated.sum += props.sum; }
        // properties to use for individual points when running the reducer
        map: function(props) {
          return props;
        }
        // props => ({sum: props.my_value})
      };
      var fround = Math.fround || function(tmp2) {
        return function(x) {
          tmp2[0] = +x;
          return tmp2[0];
        };
      }(new Float32Array(1));
      var Supercluster3 = function Supercluster4(options) {
        this.options = extend2(Object.create(defaultOptions), options);
        this.trees = new Array(this.options.maxZoom + 1);
      };
      Supercluster3.prototype.load = function load(points) {
        var ref = this.options;
        var log2 = ref.log;
        var minZoom = ref.minZoom;
        var maxZoom = ref.maxZoom;
        var nodeSize = ref.nodeSize;
        if (log2) {
          console.time("total time");
        }
        var timerId = "prepare " + points.length + " points";
        if (log2) {
          console.time(timerId);
        }
        this.points = points;
        var clusters = [];
        for (var i = 0; i < points.length; i++) {
          if (!points[i].geometry) {
            continue;
          }
          clusters.push(createPointCluster(points[i], i));
        }
        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);
        if (log2) {
          console.timeEnd(timerId);
        }
        for (var z = maxZoom; z >= minZoom; z--) {
          var now = +Date.now();
          clusters = this._cluster(clusters, z);
          this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);
          if (log2) {
            console.log("z%d: %d clusters in %dms", z, clusters.length, +Date.now() - now);
          }
        }
        if (log2) {
          console.timeEnd("total time");
        }
        return this;
      };
      Supercluster3.prototype.getClusters = function getClusters(bbox, zoom) {
        var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;
        var minLat = Math.max(-90, Math.min(90, bbox[1]));
        var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;
        var maxLat = Math.max(-90, Math.min(90, bbox[3]));
        if (bbox[2] - bbox[0] >= 360) {
          minLng = -180;
          maxLng = 180;
        } else if (minLng > maxLng) {
          var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);
          var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);
          return easternHem.concat(westernHem);
        }
        var tree = this.trees[this._limitZoom(zoom)];
        var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));
        var clusters = [];
        for (var i = 0, list = ids; i < list.length; i += 1) {
          var id = list[i];
          var c = tree.points[id];
          clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
        }
        return clusters;
      };
      Supercluster3.prototype.getChildren = function getChildren(clusterId) {
        var originId = this._getOriginId(clusterId);
        var originZoom = this._getOriginZoom(clusterId);
        var errorMsg = "No cluster with the specified id.";
        var index3 = this.trees[originZoom];
        if (!index3) {
          throw new Error(errorMsg);
        }
        var origin = index3.points[originId];
        if (!origin) {
          throw new Error(errorMsg);
        }
        var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));
        var ids = index3.within(origin.x, origin.y, r);
        var children = [];
        for (var i = 0, list = ids; i < list.length; i += 1) {
          var id = list[i];
          var c = index3.points[id];
          if (c.parentId === clusterId) {
            children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);
          }
        }
        if (children.length === 0) {
          throw new Error(errorMsg);
        }
        return children;
      };
      Supercluster3.prototype.getLeaves = function getLeaves(clusterId, limit, offset) {
        limit = limit || 10;
        offset = offset || 0;
        var leaves = [];
        this._appendLeaves(leaves, clusterId, limit, offset, 0);
        return leaves;
      };
      Supercluster3.prototype.getTile = function getTile(z, x, y) {
        var tree = this.trees[this._limitZoom(z)];
        var z2 = Math.pow(2, z);
        var ref = this.options;
        var extent2 = ref.extent;
        var radius = ref.radius;
        var p = radius / extent2;
        var top = (y - p) / z2;
        var bottom = (y + 1 + p) / z2;
        var tile = {
          features: []
        };
        this._addTileFeatures(
          tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),
          tree.points,
          x,
          y,
          z2,
          tile
        );
        if (x === 0) {
          this._addTileFeatures(
            tree.range(1 - p / z2, top, 1, bottom),
            tree.points,
            z2,
            y,
            z2,
            tile
          );
        }
        if (x === z2 - 1) {
          this._addTileFeatures(
            tree.range(0, top, p / z2, bottom),
            tree.points,
            -1,
            y,
            z2,
            tile
          );
        }
        return tile.features.length ? tile : null;
      };
      Supercluster3.prototype.getClusterExpansionZoom = function getClusterExpansionZoom(clusterId) {
        var expansionZoom = this._getOriginZoom(clusterId) - 1;
        while (expansionZoom <= this.options.maxZoom) {
          var children = this.getChildren(clusterId);
          expansionZoom++;
          if (children.length !== 1) {
            break;
          }
          clusterId = children[0].properties.cluster_id;
        }
        return expansionZoom;
      };
      Supercluster3.prototype._appendLeaves = function _appendLeaves(result, clusterId, limit, offset, skipped) {
        var children = this.getChildren(clusterId);
        for (var i = 0, list = children; i < list.length; i += 1) {
          var child = list[i];
          var props = child.properties;
          if (props && props.cluster) {
            if (skipped + props.point_count <= offset) {
              skipped += props.point_count;
            } else {
              skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);
            }
          } else if (skipped < offset) {
            skipped++;
          } else {
            result.push(child);
          }
          if (result.length === limit) {
            break;
          }
        }
        return skipped;
      };
      Supercluster3.prototype._addTileFeatures = function _addTileFeatures(ids, points, x, y, z2, tile) {
        for (var i$1 = 0, list = ids; i$1 < list.length; i$1 += 1) {
          var i = list[i$1];
          var c = points[i];
          var isCluster = c.numPoints;
          var tags = void 0, px = void 0, py = void 0;
          if (isCluster) {
            tags = getClusterProperties(c);
            px = c.x;
            py = c.y;
          } else {
            var p = this.points[c.index];
            tags = p.properties;
            px = lngX(p.geometry.coordinates[0]);
            py = latY(p.geometry.coordinates[1]);
          }
          var f = {
            type: 1,
            geometry: [[
              Math.round(this.options.extent * (px * z2 - x)),
              Math.round(this.options.extent * (py * z2 - y))
            ]],
            tags
          };
          var id = void 0;
          if (isCluster) {
            id = c.id;
          } else if (this.options.generateId) {
            id = c.index;
          } else if (this.points[c.index].id) {
            id = this.points[c.index].id;
          }
          if (id !== void 0) {
            f.id = id;
          }
          tile.features.push(f);
        }
      };
      Supercluster3.prototype._limitZoom = function _limitZoom(z) {
        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));
      };
      Supercluster3.prototype._cluster = function _cluster(points, zoom) {
        var clusters = [];
        var ref = this.options;
        var radius = ref.radius;
        var extent2 = ref.extent;
        var reduce2 = ref.reduce;
        var minPoints = ref.minPoints;
        var r = radius / (extent2 * Math.pow(2, zoom));
        for (var i = 0; i < points.length; i++) {
          var p = points[i];
          if (p.zoom <= zoom) {
            continue;
          }
          p.zoom = zoom;
          var tree = this.trees[zoom + 1];
          var neighborIds = tree.within(p.x, p.y, r);
          var numPointsOrigin = p.numPoints || 1;
          var numPoints = numPointsOrigin;
          for (var i$1 = 0, list = neighborIds; i$1 < list.length; i$1 += 1) {
            var neighborId = list[i$1];
            var b = tree.points[neighborId];
            if (b.zoom > zoom) {
              numPoints += b.numPoints || 1;
            }
          }
          if (numPoints > numPointsOrigin && numPoints >= minPoints) {
            var wx2 = p.x * numPointsOrigin;
            var wy = p.y * numPointsOrigin;
            var clusterProperties = reduce2 && numPointsOrigin > 1 ? this._map(p, true) : null;
            var id = (i << 5) + (zoom + 1) + this.points.length;
            for (var i$2 = 0, list$1 = neighborIds; i$2 < list$1.length; i$2 += 1) {
              var neighborId$1 = list$1[i$2];
              var b$1 = tree.points[neighborId$1];
              if (b$1.zoom <= zoom) {
                continue;
              }
              b$1.zoom = zoom;
              var numPoints2 = b$1.numPoints || 1;
              wx2 += b$1.x * numPoints2;
              wy += b$1.y * numPoints2;
              b$1.parentId = id;
              if (reduce2) {
                if (!clusterProperties) {
                  clusterProperties = this._map(p, true);
                }
                reduce2(clusterProperties, this._map(b$1));
              }
            }
            p.parentId = id;
            clusters.push(createCluster(wx2 / numPoints, wy / numPoints, id, numPoints, clusterProperties));
          } else {
            clusters.push(p);
            if (numPoints > 1) {
              for (var i$3 = 0, list$2 = neighborIds; i$3 < list$2.length; i$3 += 1) {
                var neighborId$2 = list$2[i$3];
                var b$2 = tree.points[neighborId$2];
                if (b$2.zoom <= zoom) {
                  continue;
                }
                b$2.zoom = zoom;
                clusters.push(b$2);
              }
            }
          }
        }
        return clusters;
      };
      Supercluster3.prototype._getOriginId = function _getOriginId(clusterId) {
        return clusterId - this.points.length >> 5;
      };
      Supercluster3.prototype._getOriginZoom = function _getOriginZoom(clusterId) {
        return (clusterId - this.points.length) % 32;
      };
      Supercluster3.prototype._map = function _map(point2, clone) {
        if (point2.numPoints) {
          return clone ? extend2({}, point2.properties) : point2.properties;
        }
        var original = this.points[point2.index].properties;
        var result = this.options.map(original);
        return clone && result === original ? extend2({}, result) : result;
      };
      function createCluster(x, y, id, numPoints, properties) {
        return {
          x: fround(x),
          // weighted cluster center; round for consistency with Float32Array index
          y: fround(y),
          zoom: Infinity,
          // the last zoom the cluster was processed at
          id,
          // encodes index of the first child of the cluster and its zoom level
          parentId: -1,
          // parent cluster id
          numPoints,
          properties
        };
      }
      function createPointCluster(p, id) {
        var ref = p.geometry.coordinates;
        var x = ref[0];
        var y = ref[1];
        return {
          x: fround(lngX(x)),
          // projected point coordinates
          y: fround(latY(y)),
          zoom: Infinity,
          // the last zoom the point was processed at
          index: id,
          // index of the source feature in the original input array,
          parentId: -1
          // parent cluster id
        };
      }
      function getClusterJSON(cluster2) {
        return {
          type: "Feature",
          id: cluster2.id,
          properties: getClusterProperties(cluster2),
          geometry: {
            type: "Point",
            coordinates: [xLng(cluster2.x), yLat(cluster2.y)]
          }
        };
      }
      function getClusterProperties(cluster2) {
        var count2 = cluster2.numPoints;
        var abbrev = count2 >= 1e4 ? Math.round(count2 / 1e3) + "k" : count2 >= 1e3 ? Math.round(count2 / 100) / 10 + "k" : count2;
        return extend2(extend2({}, cluster2.properties), {
          cluster: true,
          cluster_id: cluster2.id,
          point_count: count2,
          point_count_abbreviated: abbrev
        });
      }
      function lngX(lng) {
        return lng / 360 + 0.5;
      }
      function latY(lat) {
        var sin = Math.sin(lat * Math.PI / 180);
        var y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
        return y < 0 ? 0 : y > 1 ? 1 : y;
      }
      function xLng(x) {
        return (x - 0.5) * 360;
      }
      function yLat(y) {
        var y2 = (180 - y * 360) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;
      }
      function extend2(dest, src) {
        for (var id in src) {
          dest[id] = src[id];
        }
        return dest;
      }
      function getX(p) {
        return p.x;
      }
      function getY(p) {
        return p.y;
      }
      return Supercluster3;
    });
  }
});

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut5;
    module.exports.default = earcut5;
    function earcut5(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last2;
      if (clockwise === signedArea2(data, start, end, dim) > 0) {
        for (i = start; i < end; i += dim)
          last2 = insertNode(i, data[i], data[i + 1], last2);
      } else {
        for (i = end - dim; i >= start; i -= dim)
          last2 = insertNode(i, data[i], data[i + 1], last2);
      }
      if (last2 && equals(last2, last2.next)) {
        removeNode(last2);
        last2 = last2.next;
      }
      return last2;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next)
            break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p = c.next;
      while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim | 0);
          triangles.push(p.i / dim | 0);
          triangles.push(b.i / dim | 0);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints(p);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len, start, end, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            m = p.x < p.next.x ? p : p.next;
            if (x === hx)
              return m;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m)
        return null;
      var stop = m, mx = m.x, my2 = m.y, tanMin = Infinity, tan;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my2 ? hx : qx, hy, mx, my2, hy < my2 ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    }
    function sectorContainsSector(m, p) {
      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === 0)
          p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, invSize) {
      x = (x - minX) * invSize | 0;
      y = (y - minY) * invSize | 0;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
          leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
      (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
      (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
      equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
          return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node2(a.i, a.x, a.y), b2 = new Node2(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x, y, last2) {
      var p = new Node2(i, x, y);
      if (!last2) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last2.next;
        p.prev = last2;
        last2.next.prev = p;
        last2.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
      if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
    }
    function Node2(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut5.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea2(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
          var start = holeIndices[i] * dim;
          var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea2(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea2(data, start, end, dim) {
      var sum4 = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
        sum4 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum4;
    }
    earcut5.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d = 0; d < dim; d++)
            result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/@antv/g-device-api/node_modules/eventemitter3/index.js
var require_eventemitter32 = __commonJS({
  "node_modules/@antv/g-device-api/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix2 = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter11() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter11.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter11.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter11.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter11.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j;
        for (i = 0; i < length2; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter11.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter11.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter11.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length2 = listeners.length; i < length2; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter11.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter11.prototype.off = EventEmitter11.prototype.removeListener;
    EventEmitter11.prototype.addListener = EventEmitter11.prototype.on;
    EventEmitter11.prefixed = prefix2;
    EventEmitter11.EventEmitter = EventEmitter11;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter11;
    }
  }
});

// node_modules/regl/dist/regl.js
var require_regl = __commonJS({
  "node_modules/regl/dist/regl.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.createREGL = factory();
    })(exports, function() {
      "use strict";
      var isTypedArray5 = function(x) {
        return x instanceof Uint8Array || x instanceof Uint16Array || x instanceof Uint32Array || x instanceof Int8Array || x instanceof Int16Array || x instanceof Int32Array || x instanceof Float32Array || x instanceof Float64Array || x instanceof Uint8ClampedArray;
      };
      var extend2 = function(base, opts) {
        var keys = Object.keys(opts);
        for (var i = 0; i < keys.length; ++i) {
          base[keys[i]] = opts[keys[i]];
        }
        return base;
      };
      var endl = "\n";
      function decodeB64(str) {
        if (typeof atob !== "undefined") {
          return atob(str);
        }
        return "base64:" + str;
      }
      function raise(message) {
        var error = new Error("(regl) " + message);
        console.error(error);
        throw error;
      }
      function check(pred, message) {
        if (!pred) {
          raise(message);
        }
      }
      function encolon(message) {
        if (message) {
          return ": " + message;
        }
        return "";
      }
      function checkParameter(param, possibilities, message) {
        if (!(param in possibilities)) {
          raise("unknown parameter (" + param + ")" + encolon(message) + ". possible values: " + Object.keys(possibilities).join());
        }
      }
      function checkIsTypedArray(data, message) {
        if (!isTypedArray5(data)) {
          raise(
            "invalid parameter type" + encolon(message) + ". must be a typed array"
          );
        }
      }
      function standardTypeEh(value, type) {
        switch (type) {
          case "number":
            return typeof value === "number";
          case "object":
            return typeof value === "object";
          case "string":
            return typeof value === "string";
          case "boolean":
            return typeof value === "boolean";
          case "function":
            return typeof value === "function";
          case "undefined":
            return typeof value === "undefined";
          case "symbol":
            return typeof value === "symbol";
        }
      }
      function checkTypeOf(value, type, message) {
        if (!standardTypeEh(value, type)) {
          raise(
            "invalid parameter type" + encolon(message) + ". expected " + type + ", got " + typeof value
          );
        }
      }
      function checkNonNegativeInt(value, message) {
        if (!(value >= 0 && (value | 0) === value)) {
          raise("invalid parameter type, (" + value + ")" + encolon(message) + ". must be a nonnegative integer");
        }
      }
      function checkOneOf(value, list, message) {
        if (list.indexOf(value) < 0) {
          raise("invalid value" + encolon(message) + ". must be one of: " + list);
        }
      }
      var constructorKeys = [
        "gl",
        "canvas",
        "container",
        "attributes",
        "pixelRatio",
        "extensions",
        "optionalExtensions",
        "profile",
        "onDone"
      ];
      function checkConstructor(obj) {
        Object.keys(obj).forEach(function(key) {
          if (constructorKeys.indexOf(key) < 0) {
            raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys);
          }
        });
      }
      function leftPad2(str, n) {
        str = str + "";
        while (str.length < n) {
          str = " " + str;
        }
        return str;
      }
      function ShaderFile() {
        this.name = "unknown";
        this.lines = [];
        this.index = {};
        this.hasErrors = false;
      }
      function ShaderLine(number2, line2) {
        this.number = number2;
        this.line = line2;
        this.errors = [];
      }
      function ShaderError(fileNumber, lineNumber, message) {
        this.file = fileNumber;
        this.line = lineNumber;
        this.message = message;
      }
      function guessCommand() {
        var error = new Error();
        var stack = (error.stack || error).toString();
        var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack);
        if (pat) {
          return pat[1];
        }
        var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack);
        if (pat2) {
          return pat2[1];
        }
        return "unknown";
      }
      function guessCallSite() {
        var error = new Error();
        var stack = (error.stack || error).toString();
        var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack);
        if (pat) {
          return pat[1];
        }
        var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack);
        if (pat2) {
          return pat2[1];
        }
        return "unknown";
      }
      function parseSource(source, command) {
        var lines2 = source.split("\n");
        var lineNumber = 1;
        var fileNumber = 0;
        var files = {
          unknown: new ShaderFile(),
          0: new ShaderFile()
        };
        files.unknown.name = files[0].name = command || guessCommand();
        files.unknown.lines.push(new ShaderLine(0, ""));
        for (var i = 0; i < lines2.length; ++i) {
          var line2 = lines2[i];
          var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line2);
          if (parts) {
            switch (parts[1]) {
              case "line":
                var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2]);
                if (lineNumberInfo) {
                  lineNumber = lineNumberInfo[1] | 0;
                  if (lineNumberInfo[2]) {
                    fileNumber = lineNumberInfo[2] | 0;
                    if (!(fileNumber in files)) {
                      files[fileNumber] = new ShaderFile();
                    }
                  }
                }
                break;
              case "define":
                var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2]);
                if (nameInfo) {
                  files[fileNumber].name = nameInfo[1] ? decodeB64(nameInfo[2]) : nameInfo[2];
                }
                break;
            }
          }
          files[fileNumber].lines.push(new ShaderLine(lineNumber++, line2));
        }
        Object.keys(files).forEach(function(fileNumber2) {
          var file = files[fileNumber2];
          file.lines.forEach(function(line3) {
            file.index[line3.number] = line3;
          });
        });
        return files;
      }
      function parseErrorLog(errLog) {
        var result = [];
        errLog.split("\n").forEach(function(errMsg) {
          if (errMsg.length < 5) {
            return;
          }
          var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg);
          if (parts) {
            result.push(new ShaderError(
              parts[1] | 0,
              parts[2] | 0,
              parts[3].trim()
            ));
          } else if (errMsg.length > 0) {
            result.push(new ShaderError("unknown", 0, errMsg));
          }
        });
        return result;
      }
      function annotateFiles(files, errors) {
        errors.forEach(function(error) {
          var file = files[error.file];
          if (file) {
            var line2 = file.index[error.line];
            if (line2) {
              line2.errors.push(error);
              file.hasErrors = true;
              return;
            }
          }
          files.unknown.hasErrors = true;
          files.unknown.lines[0].errors.push(error);
        });
      }
      function checkShaderError(gl2, shader, source, type, command) {
        if (!gl2.getShaderParameter(shader, gl2.COMPILE_STATUS)) {
          var errLog = gl2.getShaderInfoLog(shader);
          var typeName = type === gl2.FRAGMENT_SHADER ? "fragment" : "vertex";
          checkCommandType(source, "string", typeName + " shader source must be a string", command);
          var files = parseSource(source, command);
          var errors = parseErrorLog(errLog);
          annotateFiles(files, errors);
          Object.keys(files).forEach(function(fileNumber) {
            var file = files[fileNumber];
            if (!file.hasErrors) {
              return;
            }
            var strings = [""];
            var styles = [""];
            function push(str, style) {
              strings.push(str);
              styles.push(style || "");
            }
            push("file number " + fileNumber + ": " + file.name + "\n", "color:red;text-decoration:underline;font-weight:bold");
            file.lines.forEach(function(line2) {
              if (line2.errors.length > 0) {
                push(leftPad2(line2.number, 4) + "|  ", "background-color:yellow; font-weight:bold");
                push(line2.line + endl, "color:red; background-color:yellow; font-weight:bold");
                var offset = 0;
                line2.errors.forEach(function(error) {
                  var message = error.message;
                  var token = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message);
                  if (token) {
                    var tokenPat = token[1];
                    message = token[2];
                    switch (tokenPat) {
                      case "assign":
                        tokenPat = "=";
                        break;
                    }
                    offset = Math.max(line2.line.indexOf(tokenPat, offset), 0);
                  } else {
                    offset = 0;
                  }
                  push(leftPad2("| ", 6));
                  push(leftPad2("^^^", offset + 3) + endl, "font-weight:bold");
                  push(leftPad2("| ", 6));
                  push(message + endl, "font-weight:bold");
                });
                push(leftPad2("| ", 6) + endl);
              } else {
                push(leftPad2(line2.number, 4) + "|  ");
                push(line2.line + endl, "color:red");
              }
            });
            if (typeof document !== "undefined" && !window.chrome) {
              styles[0] = strings.join("%c");
              console.log.apply(console, styles);
            } else {
              console.log(strings.join(""));
            }
          });
          check.raise("Error compiling " + typeName + " shader, " + files[0].name);
        }
      }
      function checkLinkError(gl2, program, fragShader, vertShader, command) {
        if (!gl2.getProgramParameter(program, gl2.LINK_STATUS)) {
          var errLog = gl2.getProgramInfoLog(program);
          var fragParse = parseSource(fragShader, command);
          var vertParse = parseSource(vertShader, command);
          var header = 'Error linking program with vertex shader, "' + vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"';
          if (typeof document !== "undefined") {
            console.log(
              "%c" + header + endl + "%c" + errLog,
              "color:red;text-decoration:underline;font-weight:bold",
              "color:red"
            );
          } else {
            console.log(header + endl + errLog);
          }
          check.raise(header);
        }
      }
      function saveCommandRef(object) {
        object._commandRef = guessCommand();
      }
      function saveDrawCommandInfo(opts, uniforms, attributes, stringStore) {
        saveCommandRef(opts);
        function id(str) {
          if (str) {
            return stringStore.id(str);
          }
          return 0;
        }
        opts._fragId = id(opts.static.frag);
        opts._vertId = id(opts.static.vert);
        function addProps(dict, set3) {
          Object.keys(set3).forEach(function(u4) {
            dict[stringStore.id(u4)] = true;
          });
        }
        var uniformSet = opts._uniformSet = {};
        addProps(uniformSet, uniforms.static);
        addProps(uniformSet, uniforms.dynamic);
        var attributeSet = opts._attributeSet = {};
        addProps(attributeSet, attributes.static);
        addProps(attributeSet, attributes.dynamic);
        opts._hasCount = "count" in opts.static || "count" in opts.dynamic || "elements" in opts.static || "elements" in opts.dynamic;
      }
      function commandRaise(message, command) {
        var callSite = guessCallSite();
        raise(message + " in command " + (command || guessCommand()) + (callSite === "unknown" ? "" : " called from " + callSite));
      }
      function checkCommand(pred, message, command) {
        if (!pred) {
          commandRaise(message, command || guessCommand());
        }
      }
      function checkParameterCommand(param, possibilities, message, command) {
        if (!(param in possibilities)) {
          commandRaise(
            "unknown parameter (" + param + ")" + encolon(message) + ". possible values: " + Object.keys(possibilities).join(),
            command || guessCommand()
          );
        }
      }
      function checkCommandType(value, type, message, command) {
        if (!standardTypeEh(value, type)) {
          commandRaise(
            "invalid parameter type" + encolon(message) + ". expected " + type + ", got " + typeof value,
            command || guessCommand()
          );
        }
      }
      function checkOptional(block) {
        block();
      }
      function checkFramebufferFormat(attachment, texFormats, rbFormats) {
        if (attachment.texture) {
          checkOneOf(
            attachment.texture._texture.internalformat,
            texFormats,
            "unsupported texture format for attachment"
          );
        } else {
          checkOneOf(
            attachment.renderbuffer._renderbuffer.format,
            rbFormats,
            "unsupported renderbuffer format for attachment"
          );
        }
      }
      var GL_CLAMP_TO_EDGE = 33071;
      var GL_NEAREST = 9728;
      var GL_NEAREST_MIPMAP_NEAREST = 9984;
      var GL_LINEAR_MIPMAP_NEAREST = 9985;
      var GL_NEAREST_MIPMAP_LINEAR = 9986;
      var GL_LINEAR_MIPMAP_LINEAR = 9987;
      var GL_BYTE = 5120;
      var GL_UNSIGNED_BYTE = 5121;
      var GL_SHORT = 5122;
      var GL_UNSIGNED_SHORT = 5123;
      var GL_INT = 5124;
      var GL_UNSIGNED_INT = 5125;
      var GL_FLOAT = 5126;
      var GL_UNSIGNED_SHORT_4_4_4_4 = 32819;
      var GL_UNSIGNED_SHORT_5_5_5_1 = 32820;
      var GL_UNSIGNED_SHORT_5_6_5 = 33635;
      var GL_UNSIGNED_INT_24_8_WEBGL = 34042;
      var GL_HALF_FLOAT_OES = 36193;
      var TYPE_SIZE = {};
      TYPE_SIZE[GL_BYTE] = TYPE_SIZE[GL_UNSIGNED_BYTE] = 1;
      TYPE_SIZE[GL_SHORT] = TYPE_SIZE[GL_UNSIGNED_SHORT] = TYPE_SIZE[GL_HALF_FLOAT_OES] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] = TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2;
      TYPE_SIZE[GL_INT] = TYPE_SIZE[GL_UNSIGNED_INT] = TYPE_SIZE[GL_FLOAT] = TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4;
      function pixelSize(type, channels) {
        if (type === GL_UNSIGNED_SHORT_5_5_5_1 || type === GL_UNSIGNED_SHORT_4_4_4_4 || type === GL_UNSIGNED_SHORT_5_6_5) {
          return 2;
        } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
          return 4;
        } else {
          return TYPE_SIZE[type] * channels;
        }
      }
      function isPow2(v2) {
        return !(v2 & v2 - 1) && !!v2;
      }
      function checkTexture2D(info, mipData, limits) {
        var i;
        var w = mipData.width;
        var h = mipData.height;
        var c = mipData.channels;
        check(
          w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize,
          "invalid texture shape"
        );
        if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
          check(
            isPow2(w) && isPow2(h),
            "incompatible wrap mode for texture, both width and height must be power of 2"
          );
        }
        if (mipData.mipmask === 1) {
          if (w !== 1 && h !== 1) {
            check(
              info.minFilter !== GL_NEAREST_MIPMAP_NEAREST && info.minFilter !== GL_NEAREST_MIPMAP_LINEAR && info.minFilter !== GL_LINEAR_MIPMAP_NEAREST && info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
              "min filter requires mipmap"
            );
          }
        } else {
          check(
            isPow2(w) && isPow2(h),
            "texture must be a square power of 2 to support mipmapping"
          );
          check(
            mipData.mipmask === (w << 1) - 1,
            "missing or incomplete mipmap data"
          );
        }
        if (mipData.type === GL_FLOAT) {
          if (limits.extensions.indexOf("oes_texture_float_linear") < 0) {
            check(
              info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST,
              "filter not supported, must enable oes_texture_float_linear"
            );
          }
          check(
            !info.genMipmaps,
            "mipmap generation not supported with float textures"
          );
        }
        var mipimages = mipData.images;
        for (i = 0; i < 16; ++i) {
          if (mipimages[i]) {
            var mw = w >> i;
            var mh = h >> i;
            check(mipData.mipmask & 1 << i, "missing mipmap data");
            var img = mipimages[i];
            check(
              img.width === mw && img.height === mh,
              "invalid shape for mip images"
            );
            check(
              img.format === mipData.format && img.internalformat === mipData.internalformat && img.type === mipData.type,
              "incompatible type for mip image"
            );
            if (img.compressed) {
            } else if (img.data) {
              var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment;
              check(
                img.data.byteLength === rowSize * mh,
                "invalid data for image, buffer size is inconsistent with image format"
              );
            } else if (img.element) {
            } else if (img.copy) {
            }
          } else if (!info.genMipmaps) {
            check((mipData.mipmask & 1 << i) === 0, "extra mipmap data");
          }
        }
        if (mipData.compressed) {
          check(
            !info.genMipmaps,
            "mipmap generation for compressed images not supported"
          );
        }
      }
      function checkTextureCube(texture, info, faces, limits) {
        var w = texture.width;
        var h = texture.height;
        var c = texture.channels;
        check(
          w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize,
          "invalid texture shape"
        );
        check(
          w === h,
          "cube map must be square"
        );
        check(
          info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE,
          "wrap mode not supported by cube map"
        );
        for (var i = 0; i < faces.length; ++i) {
          var face = faces[i];
          check(
            face.width === w && face.height === h,
            "inconsistent cube map face shape"
          );
          if (info.genMipmaps) {
            check(
              !face.compressed,
              "can not generate mipmap for compressed textures"
            );
            check(
              face.mipmask === 1,
              "can not specify mipmaps and generate mipmaps"
            );
          } else {
          }
          var mipmaps = face.images;
          for (var j = 0; j < 16; ++j) {
            var img = mipmaps[j];
            if (img) {
              var mw = w >> j;
              var mh = h >> j;
              check(face.mipmask & 1 << j, "missing mipmap data");
              check(
                img.width === mw && img.height === mh,
                "invalid shape for mip images"
              );
              check(
                img.format === texture.format && img.internalformat === texture.internalformat && img.type === texture.type,
                "incompatible type for mip image"
              );
              if (img.compressed) {
              } else if (img.data) {
                check(
                  img.data.byteLength === mw * mh * Math.max(pixelSize(img.type, c), img.unpackAlignment),
                  "invalid data for image, buffer size is inconsistent with image format"
                );
              } else if (img.element) {
              } else if (img.copy) {
              }
            }
          }
        }
      }
      var check$1 = extend2(check, {
        optional: checkOptional,
        raise,
        commandRaise,
        command: checkCommand,
        parameter: checkParameter,
        commandParameter: checkParameterCommand,
        constructor: checkConstructor,
        type: checkTypeOf,
        commandType: checkCommandType,
        isTypedArray: checkIsTypedArray,
        nni: checkNonNegativeInt,
        oneOf: checkOneOf,
        shaderError: checkShaderError,
        linkError: checkLinkError,
        callSite: guessCallSite,
        saveCommandRef,
        saveDrawInfo: saveDrawCommandInfo,
        framebufferFormat: checkFramebufferFormat,
        guessCommand,
        texture2D: checkTexture2D,
        textureCube: checkTextureCube
      });
      var VARIABLE_COUNTER = 0;
      var DYN_FUNC = 0;
      function DynamicVariable(type, data) {
        this.id = VARIABLE_COUNTER++;
        this.type = type;
        this.data = data;
      }
      function escapeStr(str) {
        return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      }
      function splitParts(str) {
        if (str.length === 0) {
          return [];
        }
        var firstChar = str.charAt(0);
        var lastChar = str.charAt(str.length - 1);
        if (str.length > 1 && firstChar === lastChar && (firstChar === '"' || firstChar === "'")) {
          return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"'];
        }
        var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str);
        if (parts) {
          return splitParts(str.substr(0, parts.index)).concat(splitParts(parts[1])).concat(splitParts(str.substr(parts.index + parts[0].length)));
        }
        var subparts = str.split(".");
        if (subparts.length === 1) {
          return ['"' + escapeStr(str) + '"'];
        }
        var result = [];
        for (var i = 0; i < subparts.length; ++i) {
          result = result.concat(splitParts(subparts[i]));
        }
        return result;
      }
      function toAccessorString(str) {
        return "[" + splitParts(str).join("][") + "]";
      }
      function defineDynamic(type, data) {
        return new DynamicVariable(type, toAccessorString(data + ""));
      }
      function isDynamic(x) {
        return typeof x === "function" && !x._reglType || x instanceof DynamicVariable;
      }
      function unbox(x, path) {
        if (typeof x === "function") {
          return new DynamicVariable(DYN_FUNC, x);
        }
        return x;
      }
      var dynamic = {
        DynamicVariable,
        define: defineDynamic,
        isDynamic,
        unbox,
        accessor: toAccessorString
      };
      var raf = {
        next: typeof requestAnimationFrame === "function" ? function(cb) {
          return requestAnimationFrame(cb);
        } : function(cb) {
          return setTimeout(cb, 16);
        },
        cancel: typeof cancelAnimationFrame === "function" ? function(raf2) {
          return cancelAnimationFrame(raf2);
        } : clearTimeout
      };
      var clock = typeof performance !== "undefined" && performance.now ? function() {
        return performance.now();
      } : function() {
        return +/* @__PURE__ */ new Date();
      };
      function createStringStore() {
        var stringIds = { "": 0 };
        var stringValues = [""];
        return {
          id: function(str) {
            var result = stringIds[str];
            if (result) {
              return result;
            }
            result = stringIds[str] = stringValues.length;
            stringValues.push(str);
            return result;
          },
          str: function(id) {
            return stringValues[id];
          }
        };
      }
      function createCanvas(element, onDone, pixelRatio) {
        var canvas = document.createElement("canvas");
        extend2(canvas.style, {
          border: 0,
          margin: 0,
          padding: 0,
          top: 0,
          left: 0
        });
        element.appendChild(canvas);
        if (element === document.body) {
          canvas.style.position = "absolute";
          extend2(element.style, {
            margin: 0,
            padding: 0
          });
        }
        function resize() {
          var w = window.innerWidth;
          var h = window.innerHeight;
          if (element !== document.body) {
            var bounds = element.getBoundingClientRect();
            w = bounds.right - bounds.left;
            h = bounds.bottom - bounds.top;
          }
          canvas.width = pixelRatio * w;
          canvas.height = pixelRatio * h;
          extend2(canvas.style, {
            width: w + "px",
            height: h + "px"
          });
        }
        var resizeObserver;
        if (element !== document.body && typeof ResizeObserver === "function") {
          resizeObserver = new ResizeObserver(function() {
            setTimeout(resize);
          });
          resizeObserver.observe(element);
        } else {
          window.addEventListener("resize", resize, false);
        }
        function onDestroy() {
          if (resizeObserver) {
            resizeObserver.disconnect();
          } else {
            window.removeEventListener("resize", resize);
          }
          element.removeChild(canvas);
        }
        resize();
        return {
          canvas,
          onDestroy
        };
      }
      function createContext(canvas, contextAttributes) {
        function get2(name) {
          try {
            return canvas.getContext(name, contextAttributes);
          } catch (e) {
            return null;
          }
        }
        return get2("webgl") || get2("experimental-webgl") || get2("webgl-experimental");
      }
      function isHTMLElement(obj) {
        return typeof obj.nodeName === "string" && typeof obj.appendChild === "function" && typeof obj.getBoundingClientRect === "function";
      }
      function isWebGLContext(obj) {
        return typeof obj.drawArrays === "function" || typeof obj.drawElements === "function";
      }
      function parseExtensions(input) {
        if (typeof input === "string") {
          return input.split();
        }
        check$1(Array.isArray(input), "invalid extension array");
        return input;
      }
      function getElement(desc) {
        if (typeof desc === "string") {
          check$1(typeof document !== "undefined", "not supported outside of DOM");
          return document.querySelector(desc);
        }
        return desc;
      }
      function parseArgs(args_) {
        var args = args_ || {};
        var element, container, canvas, gl2;
        var contextAttributes = {};
        var extensions = [];
        var optionalExtensions = [];
        var pixelRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio;
        var profile = false;
        var onDone = function(err) {
          if (err) {
            check$1.raise(err);
          }
        };
        var onDestroy = function() {
        };
        if (typeof args === "string") {
          check$1(
            typeof document !== "undefined",
            "selector queries only supported in DOM enviroments"
          );
          element = document.querySelector(args);
          check$1(element, "invalid query string for element");
        } else if (typeof args === "object") {
          if (isHTMLElement(args)) {
            element = args;
          } else if (isWebGLContext(args)) {
            gl2 = args;
            canvas = gl2.canvas;
          } else {
            check$1.constructor(args);
            if ("gl" in args) {
              gl2 = args.gl;
            } else if ("canvas" in args) {
              canvas = getElement(args.canvas);
            } else if ("container" in args) {
              container = getElement(args.container);
            }
            if ("attributes" in args) {
              contextAttributes = args.attributes;
              check$1.type(contextAttributes, "object", "invalid context attributes");
            }
            if ("extensions" in args) {
              extensions = parseExtensions(args.extensions);
            }
            if ("optionalExtensions" in args) {
              optionalExtensions = parseExtensions(args.optionalExtensions);
            }
            if ("onDone" in args) {
              check$1.type(
                args.onDone,
                "function",
                "invalid or missing onDone callback"
              );
              onDone = args.onDone;
            }
            if ("profile" in args) {
              profile = !!args.profile;
            }
            if ("pixelRatio" in args) {
              pixelRatio = +args.pixelRatio;
              check$1(pixelRatio > 0, "invalid pixel ratio");
            }
          }
        } else {
          check$1.raise("invalid arguments to regl");
        }
        if (element) {
          if (element.nodeName.toLowerCase() === "canvas") {
            canvas = element;
          } else {
            container = element;
          }
        }
        if (!gl2) {
          if (!canvas) {
            check$1(
              typeof document !== "undefined",
              "must manually specify webgl context outside of DOM environments"
            );
            var result = createCanvas(container || document.body, onDone, pixelRatio);
            if (!result) {
              return null;
            }
            canvas = result.canvas;
            onDestroy = result.onDestroy;
          }
          if (contextAttributes.premultipliedAlpha === void 0)
            contextAttributes.premultipliedAlpha = true;
          gl2 = createContext(canvas, contextAttributes);
        }
        if (!gl2) {
          onDestroy();
          onDone("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org");
          return null;
        }
        return {
          gl: gl2,
          canvas,
          container,
          extensions,
          optionalExtensions,
          pixelRatio,
          profile,
          onDone,
          onDestroy
        };
      }
      function createExtensionCache(gl2, config) {
        var extensions = {};
        function tryLoadExtension(name_) {
          check$1.type(name_, "string", "extension name must be string");
          var name2 = name_.toLowerCase();
          var ext;
          try {
            ext = extensions[name2] = gl2.getExtension(name2);
          } catch (e) {
          }
          return !!ext;
        }
        for (var i = 0; i < config.extensions.length; ++i) {
          var name = config.extensions[i];
          if (!tryLoadExtension(name)) {
            config.onDestroy();
            config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser');
            return null;
          }
        }
        config.optionalExtensions.forEach(tryLoadExtension);
        return {
          extensions,
          restore: function() {
            Object.keys(extensions).forEach(function(name2) {
              if (extensions[name2] && !tryLoadExtension(name2)) {
                throw new Error("(regl): error restoring extension " + name2);
              }
            });
          }
        };
      }
      function loop(n, f) {
        var result = Array(n);
        for (var i = 0; i < n; ++i) {
          result[i] = f(i);
        }
        return result;
      }
      var GL_BYTE$1 = 5120;
      var GL_UNSIGNED_BYTE$2 = 5121;
      var GL_SHORT$1 = 5122;
      var GL_UNSIGNED_SHORT$1 = 5123;
      var GL_INT$1 = 5124;
      var GL_UNSIGNED_INT$1 = 5125;
      var GL_FLOAT$2 = 5126;
      function nextPow16(v2) {
        for (var i = 16; i <= 1 << 28; i *= 16) {
          if (v2 <= i) {
            return i;
          }
        }
        return 0;
      }
      function log2(v2) {
        var r, shift;
        r = (v2 > 65535) << 4;
        v2 >>>= r;
        shift = (v2 > 255) << 3;
        v2 >>>= shift;
        r |= shift;
        shift = (v2 > 15) << 2;
        v2 >>>= shift;
        r |= shift;
        shift = (v2 > 3) << 1;
        v2 >>>= shift;
        r |= shift;
        return r | v2 >> 1;
      }
      function createPool() {
        var bufferPool = loop(8, function() {
          return [];
        });
        function alloc(n) {
          var sz = nextPow16(n);
          var bin = bufferPool[log2(sz) >> 2];
          if (bin.length > 0) {
            return bin.pop();
          }
          return new ArrayBuffer(sz);
        }
        function free(buf) {
          bufferPool[log2(buf.byteLength) >> 2].push(buf);
        }
        function allocType(type, n) {
          var result = null;
          switch (type) {
            case GL_BYTE$1:
              result = new Int8Array(alloc(n), 0, n);
              break;
            case GL_UNSIGNED_BYTE$2:
              result = new Uint8Array(alloc(n), 0, n);
              break;
            case GL_SHORT$1:
              result = new Int16Array(alloc(2 * n), 0, n);
              break;
            case GL_UNSIGNED_SHORT$1:
              result = new Uint16Array(alloc(2 * n), 0, n);
              break;
            case GL_INT$1:
              result = new Int32Array(alloc(4 * n), 0, n);
              break;
            case GL_UNSIGNED_INT$1:
              result = new Uint32Array(alloc(4 * n), 0, n);
              break;
            case GL_FLOAT$2:
              result = new Float32Array(alloc(4 * n), 0, n);
              break;
            default:
              return null;
          }
          if (result.length !== n) {
            return result.subarray(0, n);
          }
          return result;
        }
        function freeType(array4) {
          free(array4.buffer);
        }
        return {
          alloc,
          free,
          allocType,
          freeType
        };
      }
      var pool = createPool();
      pool.zero = createPool();
      var GL_SUBPIXEL_BITS = 3408;
      var GL_RED_BITS = 3410;
      var GL_GREEN_BITS = 3411;
      var GL_BLUE_BITS = 3412;
      var GL_ALPHA_BITS = 3413;
      var GL_DEPTH_BITS = 3414;
      var GL_STENCIL_BITS = 3415;
      var GL_ALIASED_POINT_SIZE_RANGE = 33901;
      var GL_ALIASED_LINE_WIDTH_RANGE = 33902;
      var GL_MAX_TEXTURE_SIZE = 3379;
      var GL_MAX_VIEWPORT_DIMS = 3386;
      var GL_MAX_VERTEX_ATTRIBS = 34921;
      var GL_MAX_VERTEX_UNIFORM_VECTORS = 36347;
      var GL_MAX_VARYING_VECTORS = 36348;
      var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
      var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
      var GL_MAX_TEXTURE_IMAGE_UNITS = 34930;
      var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 36349;
      var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 34076;
      var GL_MAX_RENDERBUFFER_SIZE = 34024;
      var GL_VENDOR = 7936;
      var GL_RENDERER = 7937;
      var GL_VERSION = 7938;
      var GL_SHADING_LANGUAGE_VERSION = 35724;
      var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
      var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 36063;
      var GL_MAX_DRAW_BUFFERS_WEBGL = 34852;
      var GL_TEXTURE_2D = 3553;
      var GL_TEXTURE_CUBE_MAP = 34067;
      var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
      var GL_TEXTURE0 = 33984;
      var GL_RGBA = 6408;
      var GL_FLOAT$1 = 5126;
      var GL_UNSIGNED_BYTE$1 = 5121;
      var GL_FRAMEBUFFER = 36160;
      var GL_FRAMEBUFFER_COMPLETE = 36053;
      var GL_COLOR_ATTACHMENT0 = 36064;
      var GL_COLOR_BUFFER_BIT$1 = 16384;
      var wrapLimits = function(gl2, extensions) {
        var maxAnisotropic = 1;
        if (extensions.ext_texture_filter_anisotropic) {
          maxAnisotropic = gl2.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        }
        var maxDrawbuffers = 1;
        var maxColorAttachments = 1;
        if (extensions.webgl_draw_buffers) {
          maxDrawbuffers = gl2.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL);
          maxColorAttachments = gl2.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL);
        }
        var readFloat = !!extensions.oes_texture_float;
        if (readFloat) {
          var readFloatTexture = gl2.createTexture();
          gl2.bindTexture(GL_TEXTURE_2D, readFloatTexture);
          gl2.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null);
          var fbo = gl2.createFramebuffer();
          gl2.bindFramebuffer(GL_FRAMEBUFFER, fbo);
          gl2.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0);
          gl2.bindTexture(GL_TEXTURE_2D, null);
          if (gl2.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE)
            readFloat = false;
          else {
            gl2.viewport(0, 0, 1, 1);
            gl2.clearColor(1, 0, 0, 1);
            gl2.clear(GL_COLOR_BUFFER_BIT$1);
            var pixels = pool.allocType(GL_FLOAT$1, 4);
            gl2.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels);
            if (gl2.getError())
              readFloat = false;
            else {
              gl2.deleteFramebuffer(fbo);
              gl2.deleteTexture(readFloatTexture);
              readFloat = pixels[0] === 1;
            }
            pool.freeType(pixels);
          }
        }
        var isIE = typeof navigator !== "undefined" && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent));
        var npotTextureCube = true;
        if (!isIE) {
          var cubeTexture = gl2.createTexture();
          var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36);
          gl2.activeTexture(GL_TEXTURE0);
          gl2.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture);
          gl2.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data);
          pool.freeType(data);
          gl2.bindTexture(GL_TEXTURE_CUBE_MAP, null);
          gl2.deleteTexture(cubeTexture);
          npotTextureCube = !gl2.getError();
        }
        return {
          // drawing buffer bit depth
          colorBits: [
            gl2.getParameter(GL_RED_BITS),
            gl2.getParameter(GL_GREEN_BITS),
            gl2.getParameter(GL_BLUE_BITS),
            gl2.getParameter(GL_ALPHA_BITS)
          ],
          depthBits: gl2.getParameter(GL_DEPTH_BITS),
          stencilBits: gl2.getParameter(GL_STENCIL_BITS),
          subpixelBits: gl2.getParameter(GL_SUBPIXEL_BITS),
          // supported extensions
          extensions: Object.keys(extensions).filter(function(ext) {
            return !!extensions[ext];
          }),
          // max aniso samples
          maxAnisotropic,
          // max draw buffers
          maxDrawbuffers,
          maxColorAttachments,
          // point and line size ranges
          pointSizeDims: gl2.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
          lineWidthDims: gl2.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
          maxViewportDims: gl2.getParameter(GL_MAX_VIEWPORT_DIMS),
          maxCombinedTextureUnits: gl2.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
          maxCubeMapSize: gl2.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
          maxRenderbufferSize: gl2.getParameter(GL_MAX_RENDERBUFFER_SIZE),
          maxTextureUnits: gl2.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
          maxTextureSize: gl2.getParameter(GL_MAX_TEXTURE_SIZE),
          maxAttributes: gl2.getParameter(GL_MAX_VERTEX_ATTRIBS),
          maxVertexUniforms: gl2.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
          maxVertexTextureUnits: gl2.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
          maxVaryingVectors: gl2.getParameter(GL_MAX_VARYING_VECTORS),
          maxFragmentUniforms: gl2.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),
          // vendor info
          glsl: gl2.getParameter(GL_SHADING_LANGUAGE_VERSION),
          renderer: gl2.getParameter(GL_RENDERER),
          vendor: gl2.getParameter(GL_VENDOR),
          version: gl2.getParameter(GL_VERSION),
          // quirks
          readFloat,
          npotTextureCube
        };
      };
      function isNDArrayLike(obj) {
        return !!obj && typeof obj === "object" && Array.isArray(obj.shape) && Array.isArray(obj.stride) && typeof obj.offset === "number" && obj.shape.length === obj.stride.length && (Array.isArray(obj.data) || isTypedArray5(obj.data));
      }
      var values = function(obj) {
        return Object.keys(obj).map(function(key) {
          return obj[key];
        });
      };
      var flattenUtils = {
        shape: arrayShape$1,
        flatten: flattenArray
      };
      function flatten1D(array4, nx, out) {
        for (var i = 0; i < nx; ++i) {
          out[i] = array4[i];
        }
      }
      function flatten2D(array4, nx, ny, out) {
        var ptr = 0;
        for (var i = 0; i < nx; ++i) {
          var row = array4[i];
          for (var j = 0; j < ny; ++j) {
            out[ptr++] = row[j];
          }
        }
      }
      function flatten3D(array4, nx, ny, nz, out, ptr_) {
        var ptr = ptr_;
        for (var i = 0; i < nx; ++i) {
          var row = array4[i];
          for (var j = 0; j < ny; ++j) {
            var col = row[j];
            for (var k = 0; k < nz; ++k) {
              out[ptr++] = col[k];
            }
          }
        }
      }
      function flattenRec(array4, shape, level, out, ptr) {
        var stride = 1;
        for (var i = level + 1; i < shape.length; ++i) {
          stride *= shape[i];
        }
        var n = shape[level];
        if (shape.length - level === 4) {
          var nx = shape[level + 1];
          var ny = shape[level + 2];
          var nz = shape[level + 3];
          for (i = 0; i < n; ++i) {
            flatten3D(array4[i], nx, ny, nz, out, ptr);
            ptr += stride;
          }
        } else {
          for (i = 0; i < n; ++i) {
            flattenRec(array4[i], shape, level + 1, out, ptr);
            ptr += stride;
          }
        }
      }
      function flattenArray(array4, shape, type, out_) {
        var sz = 1;
        if (shape.length) {
          for (var i = 0; i < shape.length; ++i) {
            sz *= shape[i];
          }
        } else {
          sz = 0;
        }
        var out = out_ || pool.allocType(type, sz);
        switch (shape.length) {
          case 0:
            break;
          case 1:
            flatten1D(array4, shape[0], out);
            break;
          case 2:
            flatten2D(array4, shape[0], shape[1], out);
            break;
          case 3:
            flatten3D(array4, shape[0], shape[1], shape[2], out, 0);
            break;
          default:
            flattenRec(array4, shape, 0, out, 0);
        }
        return out;
      }
      function arrayShape$1(array_) {
        var shape = [];
        for (var array4 = array_; array4.length; array4 = array4[0]) {
          shape.push(array4.length);
        }
        return shape;
      }
      var arrayTypes = {
        "[object Int8Array]": 5120,
        "[object Int16Array]": 5122,
        "[object Int32Array]": 5124,
        "[object Uint8Array]": 5121,
        "[object Uint8ClampedArray]": 5121,
        "[object Uint16Array]": 5123,
        "[object Uint32Array]": 5125,
        "[object Float32Array]": 5126,
        "[object Float64Array]": 5121,
        "[object ArrayBuffer]": 5121
      };
      var int8 = 5120;
      var int16 = 5122;
      var int32 = 5124;
      var uint8 = 5121;
      var uint16 = 5123;
      var uint32 = 5125;
      var float = 5126;
      var float32 = 5126;
      var glTypes = {
        int8,
        int16,
        int32,
        uint8,
        uint16,
        uint32,
        float,
        float32
      };
      var dynamic$1 = 35048;
      var stream = 35040;
      var usageTypes = {
        dynamic: dynamic$1,
        stream,
        "static": 35044
      };
      var arrayFlatten = flattenUtils.flatten;
      var arrayShape = flattenUtils.shape;
      var GL_STATIC_DRAW = 35044;
      var GL_STREAM_DRAW = 35040;
      var GL_UNSIGNED_BYTE$3 = 5121;
      var GL_FLOAT$3 = 5126;
      var DTYPES_SIZES = [];
      DTYPES_SIZES[5120] = 1;
      DTYPES_SIZES[5122] = 2;
      DTYPES_SIZES[5124] = 4;
      DTYPES_SIZES[5121] = 1;
      DTYPES_SIZES[5123] = 2;
      DTYPES_SIZES[5125] = 4;
      DTYPES_SIZES[5126] = 4;
      function typedArrayCode(data) {
        return arrayTypes[Object.prototype.toString.call(data)] | 0;
      }
      function copyArray(out, inp) {
        for (var i = 0; i < inp.length; ++i) {
          out[i] = inp[i];
        }
      }
      function transpose(result, data, shapeX, shapeY, strideX, strideY, offset) {
        var ptr = 0;
        for (var i = 0; i < shapeX; ++i) {
          for (var j = 0; j < shapeY; ++j) {
            result[ptr++] = data[strideX * i + strideY * j + offset];
          }
        }
      }
      function wrapBufferState(gl2, stats2, config, destroyBuffer) {
        var bufferCount = 0;
        var bufferSet = {};
        function REGLBuffer(type) {
          this.id = bufferCount++;
          this.buffer = gl2.createBuffer();
          this.type = type;
          this.usage = GL_STATIC_DRAW;
          this.byteLength = 0;
          this.dimension = 1;
          this.dtype = GL_UNSIGNED_BYTE$3;
          this.persistentData = null;
          if (config.profile) {
            this.stats = { size: 0 };
          }
        }
        REGLBuffer.prototype.bind = function() {
          gl2.bindBuffer(this.type, this.buffer);
        };
        REGLBuffer.prototype.destroy = function() {
          destroy(this);
        };
        var streamPool = [];
        function createStream(type, data) {
          var buffer = streamPool.pop();
          if (!buffer) {
            buffer = new REGLBuffer(type);
          }
          buffer.bind();
          initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false);
          return buffer;
        }
        function destroyStream(stream$$1) {
          streamPool.push(stream$$1);
        }
        function initBufferFromTypedArray(buffer, data, usage) {
          buffer.byteLength = data.byteLength;
          gl2.bufferData(buffer.type, data, usage);
        }
        function initBufferFromData(buffer, data, usage, dtype, dimension, persist) {
          var shape;
          buffer.usage = usage;
          if (Array.isArray(data)) {
            buffer.dtype = dtype || GL_FLOAT$3;
            if (data.length > 0) {
              var flatData;
              if (Array.isArray(data[0])) {
                shape = arrayShape(data);
                var dim = 1;
                for (var i = 1; i < shape.length; ++i) {
                  dim *= shape[i];
                }
                buffer.dimension = dim;
                flatData = arrayFlatten(data, shape, buffer.dtype);
                initBufferFromTypedArray(buffer, flatData, usage);
                if (persist) {
                  buffer.persistentData = flatData;
                } else {
                  pool.freeType(flatData);
                }
              } else if (typeof data[0] === "number") {
                buffer.dimension = dimension;
                var typedData = pool.allocType(buffer.dtype, data.length);
                copyArray(typedData, data);
                initBufferFromTypedArray(buffer, typedData, usage);
                if (persist) {
                  buffer.persistentData = typedData;
                } else {
                  pool.freeType(typedData);
                }
              } else if (isTypedArray5(data[0])) {
                buffer.dimension = data[0].length;
                buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3;
                flatData = arrayFlatten(
                  data,
                  [data.length, data[0].length],
                  buffer.dtype
                );
                initBufferFromTypedArray(buffer, flatData, usage);
                if (persist) {
                  buffer.persistentData = flatData;
                } else {
                  pool.freeType(flatData);
                }
              } else {
                check$1.raise("invalid buffer data");
              }
            }
          } else if (isTypedArray5(data)) {
            buffer.dtype = dtype || typedArrayCode(data);
            buffer.dimension = dimension;
            initBufferFromTypedArray(buffer, data, usage);
            if (persist) {
              buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer));
            }
          } else if (isNDArrayLike(data)) {
            shape = data.shape;
            var stride = data.stride;
            var offset = data.offset;
            var shapeX = 0;
            var shapeY = 0;
            var strideX = 0;
            var strideY = 0;
            if (shape.length === 1) {
              shapeX = shape[0];
              shapeY = 1;
              strideX = stride[0];
              strideY = 0;
            } else if (shape.length === 2) {
              shapeX = shape[0];
              shapeY = shape[1];
              strideX = stride[0];
              strideY = stride[1];
            } else {
              check$1.raise("invalid shape");
            }
            buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3;
            buffer.dimension = shapeY;
            var transposeData2 = pool.allocType(buffer.dtype, shapeX * shapeY);
            transpose(
              transposeData2,
              data.data,
              shapeX,
              shapeY,
              strideX,
              strideY,
              offset
            );
            initBufferFromTypedArray(buffer, transposeData2, usage);
            if (persist) {
              buffer.persistentData = transposeData2;
            } else {
              pool.freeType(transposeData2);
            }
          } else if (data instanceof ArrayBuffer) {
            buffer.dtype = GL_UNSIGNED_BYTE$3;
            buffer.dimension = dimension;
            initBufferFromTypedArray(buffer, data, usage);
            if (persist) {
              buffer.persistentData = new Uint8Array(new Uint8Array(data));
            }
          } else {
            check$1.raise("invalid buffer data");
          }
        }
        function destroy(buffer) {
          stats2.bufferCount--;
          destroyBuffer(buffer);
          var handle = buffer.buffer;
          check$1(handle, "buffer must not be deleted already");
          gl2.deleteBuffer(handle);
          buffer.buffer = null;
          delete bufferSet[buffer.id];
        }
        function createBuffer2(options, type, deferInit, persistent) {
          stats2.bufferCount++;
          var buffer = new REGLBuffer(type);
          bufferSet[buffer.id] = buffer;
          function reglBuffer(options2) {
            var usage = GL_STATIC_DRAW;
            var data = null;
            var byteLength = 0;
            var dtype = 0;
            var dimension = 1;
            if (Array.isArray(options2) || isTypedArray5(options2) || isNDArrayLike(options2) || options2 instanceof ArrayBuffer) {
              data = options2;
            } else if (typeof options2 === "number") {
              byteLength = options2 | 0;
            } else if (options2) {
              check$1.type(
                options2,
                "object",
                "buffer arguments must be an object, a number or an array"
              );
              if ("data" in options2) {
                check$1(
                  data === null || Array.isArray(data) || isTypedArray5(data) || isNDArrayLike(data),
                  "invalid data for buffer"
                );
                data = options2.data;
              }
              if ("usage" in options2) {
                check$1.parameter(options2.usage, usageTypes, "invalid buffer usage");
                usage = usageTypes[options2.usage];
              }
              if ("type" in options2) {
                check$1.parameter(options2.type, glTypes, "invalid buffer type");
                dtype = glTypes[options2.type];
              }
              if ("dimension" in options2) {
                check$1.type(options2.dimension, "number", "invalid dimension");
                dimension = options2.dimension | 0;
              }
              if ("length" in options2) {
                check$1.nni(byteLength, "buffer length must be a nonnegative integer");
                byteLength = options2.length | 0;
              }
            }
            buffer.bind();
            if (!data) {
              if (byteLength)
                gl2.bufferData(buffer.type, byteLength, usage);
              buffer.dtype = dtype || GL_UNSIGNED_BYTE$3;
              buffer.usage = usage;
              buffer.dimension = dimension;
              buffer.byteLength = byteLength;
            } else {
              initBufferFromData(buffer, data, usage, dtype, dimension, persistent);
            }
            if (config.profile) {
              buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype];
            }
            return reglBuffer;
          }
          function setSubData(data, offset) {
            check$1(
              offset + data.byteLength <= buffer.byteLength,
              "invalid buffer subdata call, buffer is too small.  Can't write data of size " + data.byteLength + " starting from offset " + offset + " to a buffer of size " + buffer.byteLength
            );
            gl2.bufferSubData(buffer.type, offset, data);
          }
          function subdata(data, offset_) {
            var offset = (offset_ || 0) | 0;
            var shape;
            buffer.bind();
            if (isTypedArray5(data) || data instanceof ArrayBuffer) {
              setSubData(data, offset);
            } else if (Array.isArray(data)) {
              if (data.length > 0) {
                if (typeof data[0] === "number") {
                  var converted = pool.allocType(buffer.dtype, data.length);
                  copyArray(converted, data);
                  setSubData(converted, offset);
                  pool.freeType(converted);
                } else if (Array.isArray(data[0]) || isTypedArray5(data[0])) {
                  shape = arrayShape(data);
                  var flatData = arrayFlatten(data, shape, buffer.dtype);
                  setSubData(flatData, offset);
                  pool.freeType(flatData);
                } else {
                  check$1.raise("invalid buffer data");
                }
              }
            } else if (isNDArrayLike(data)) {
              shape = data.shape;
              var stride = data.stride;
              var shapeX = 0;
              var shapeY = 0;
              var strideX = 0;
              var strideY = 0;
              if (shape.length === 1) {
                shapeX = shape[0];
                shapeY = 1;
                strideX = stride[0];
                strideY = 0;
              } else if (shape.length === 2) {
                shapeX = shape[0];
                shapeY = shape[1];
                strideX = stride[0];
                strideY = stride[1];
              } else {
                check$1.raise("invalid shape");
              }
              var dtype = Array.isArray(data.data) ? buffer.dtype : typedArrayCode(data.data);
              var transposeData2 = pool.allocType(dtype, shapeX * shapeY);
              transpose(
                transposeData2,
                data.data,
                shapeX,
                shapeY,
                strideX,
                strideY,
                data.offset
              );
              setSubData(transposeData2, offset);
              pool.freeType(transposeData2);
            } else {
              check$1.raise("invalid data for buffer subdata");
            }
            return reglBuffer;
          }
          if (!deferInit) {
            reglBuffer(options);
          }
          reglBuffer._reglType = "buffer";
          reglBuffer._buffer = buffer;
          reglBuffer.subdata = subdata;
          if (config.profile) {
            reglBuffer.stats = buffer.stats;
          }
          reglBuffer.destroy = function() {
            destroy(buffer);
          };
          return reglBuffer;
        }
        function restoreBuffers() {
          values(bufferSet).forEach(function(buffer) {
            buffer.buffer = gl2.createBuffer();
            gl2.bindBuffer(buffer.type, buffer.buffer);
            gl2.bufferData(
              buffer.type,
              buffer.persistentData || buffer.byteLength,
              buffer.usage
            );
          });
        }
        if (config.profile) {
          stats2.getTotalBufferSize = function() {
            var total = 0;
            Object.keys(bufferSet).forEach(function(key) {
              total += bufferSet[key].stats.size;
            });
            return total;
          };
        }
        return {
          create: createBuffer2,
          createStream,
          destroyStream,
          clear: function() {
            values(bufferSet).forEach(destroy);
            streamPool.forEach(destroy);
          },
          getBuffer: function(wrapper) {
            if (wrapper && wrapper._buffer instanceof REGLBuffer) {
              return wrapper._buffer;
            }
            return null;
          },
          restore: restoreBuffers,
          _initBuffer: initBufferFromData
        };
      }
      var points = 0;
      var point2 = 0;
      var lines = 1;
      var line = 1;
      var triangles = 4;
      var triangle2 = 4;
      var primTypes = {
        points,
        point: point2,
        lines,
        line,
        triangles,
        triangle: triangle2,
        "line loop": 2,
        "line strip": 3,
        "triangle strip": 5,
        "triangle fan": 6
      };
      var GL_POINTS = 0;
      var GL_LINES = 1;
      var GL_TRIANGLES = 4;
      var GL_BYTE$2 = 5120;
      var GL_UNSIGNED_BYTE$4 = 5121;
      var GL_SHORT$2 = 5122;
      var GL_UNSIGNED_SHORT$2 = 5123;
      var GL_INT$2 = 5124;
      var GL_UNSIGNED_INT$2 = 5125;
      var GL_ELEMENT_ARRAY_BUFFER = 34963;
      var GL_STREAM_DRAW$1 = 35040;
      var GL_STATIC_DRAW$1 = 35044;
      function wrapElementsState(gl2, extensions, bufferState, stats2) {
        var elementSet = {};
        var elementCount = 0;
        var elementTypes = {
          "uint8": GL_UNSIGNED_BYTE$4,
          "uint16": GL_UNSIGNED_SHORT$2
        };
        if (extensions.oes_element_index_uint) {
          elementTypes.uint32 = GL_UNSIGNED_INT$2;
        }
        function REGLElementBuffer(buffer) {
          this.id = elementCount++;
          elementSet[this.id] = this;
          this.buffer = buffer;
          this.primType = GL_TRIANGLES;
          this.vertCount = 0;
          this.type = 0;
        }
        REGLElementBuffer.prototype.bind = function() {
          this.buffer.bind();
        };
        var bufferPool = [];
        function createElementStream(data) {
          var result = bufferPool.pop();
          if (!result) {
            result = new REGLElementBuffer(bufferState.create(
              null,
              GL_ELEMENT_ARRAY_BUFFER,
              true,
              false
            )._buffer);
          }
          initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0);
          return result;
        }
        function destroyElementStream(elements) {
          bufferPool.push(elements);
        }
        function initElements(elements, data, usage, prim, count2, byteLength, type) {
          elements.buffer.bind();
          var dtype;
          if (data) {
            var predictedType = type;
            if (!type && (!isTypedArray5(data) || isNDArrayLike(data) && !isTypedArray5(data.data))) {
              predictedType = extensions.oes_element_index_uint ? GL_UNSIGNED_INT$2 : GL_UNSIGNED_SHORT$2;
            }
            bufferState._initBuffer(
              elements.buffer,
              data,
              usage,
              predictedType,
              3
            );
          } else {
            gl2.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage);
            elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4;
            elements.buffer.usage = usage;
            elements.buffer.dimension = 3;
            elements.buffer.byteLength = byteLength;
          }
          dtype = type;
          if (!type) {
            switch (elements.buffer.dtype) {
              case GL_UNSIGNED_BYTE$4:
              case GL_BYTE$2:
                dtype = GL_UNSIGNED_BYTE$4;
                break;
              case GL_UNSIGNED_SHORT$2:
              case GL_SHORT$2:
                dtype = GL_UNSIGNED_SHORT$2;
                break;
              case GL_UNSIGNED_INT$2:
              case GL_INT$2:
                dtype = GL_UNSIGNED_INT$2;
                break;
              default:
                check$1.raise("unsupported type for element array");
            }
            elements.buffer.dtype = dtype;
          }
          elements.type = dtype;
          check$1(
            dtype !== GL_UNSIGNED_INT$2 || !!extensions.oes_element_index_uint,
            "32 bit element buffers not supported, enable oes_element_index_uint first"
          );
          var vertCount = count2;
          if (vertCount < 0) {
            vertCount = elements.buffer.byteLength;
            if (dtype === GL_UNSIGNED_SHORT$2) {
              vertCount >>= 1;
            } else if (dtype === GL_UNSIGNED_INT$2) {
              vertCount >>= 2;
            }
          }
          elements.vertCount = vertCount;
          var primType = prim;
          if (prim < 0) {
            primType = GL_TRIANGLES;
            var dimension = elements.buffer.dimension;
            if (dimension === 1)
              primType = GL_POINTS;
            if (dimension === 2)
              primType = GL_LINES;
            if (dimension === 3)
              primType = GL_TRIANGLES;
          }
          elements.primType = primType;
        }
        function destroyElements(elements) {
          stats2.elementsCount--;
          check$1(elements.buffer !== null, "must not double destroy elements");
          delete elementSet[elements.id];
          elements.buffer.destroy();
          elements.buffer = null;
        }
        function createElements(options, persistent) {
          var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true);
          var elements = new REGLElementBuffer(buffer._buffer);
          stats2.elementsCount++;
          function reglElements(options2) {
            if (!options2) {
              buffer();
              elements.primType = GL_TRIANGLES;
              elements.vertCount = 0;
              elements.type = GL_UNSIGNED_BYTE$4;
            } else if (typeof options2 === "number") {
              buffer(options2);
              elements.primType = GL_TRIANGLES;
              elements.vertCount = options2 | 0;
              elements.type = GL_UNSIGNED_BYTE$4;
            } else {
              var data = null;
              var usage = GL_STATIC_DRAW$1;
              var primType = -1;
              var vertCount = -1;
              var byteLength = 0;
              var dtype = 0;
              if (Array.isArray(options2) || isTypedArray5(options2) || isNDArrayLike(options2)) {
                data = options2;
              } else {
                check$1.type(options2, "object", "invalid arguments for elements");
                if ("data" in options2) {
                  data = options2.data;
                  check$1(
                    Array.isArray(data) || isTypedArray5(data) || isNDArrayLike(data),
                    "invalid data for element buffer"
                  );
                }
                if ("usage" in options2) {
                  check$1.parameter(
                    options2.usage,
                    usageTypes,
                    "invalid element buffer usage"
                  );
                  usage = usageTypes[options2.usage];
                }
                if ("primitive" in options2) {
                  check$1.parameter(
                    options2.primitive,
                    primTypes,
                    "invalid element buffer primitive"
                  );
                  primType = primTypes[options2.primitive];
                }
                if ("count" in options2) {
                  check$1(
                    typeof options2.count === "number" && options2.count >= 0,
                    "invalid vertex count for elements"
                  );
                  vertCount = options2.count | 0;
                }
                if ("type" in options2) {
                  check$1.parameter(
                    options2.type,
                    elementTypes,
                    "invalid buffer type"
                  );
                  dtype = elementTypes[options2.type];
                }
                if ("length" in options2) {
                  byteLength = options2.length | 0;
                } else {
                  byteLength = vertCount;
                  if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
                    byteLength *= 2;
                  } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
                    byteLength *= 4;
                  }
                }
              }
              initElements(
                elements,
                data,
                usage,
                primType,
                vertCount,
                byteLength,
                dtype
              );
            }
            return reglElements;
          }
          reglElements(options);
          reglElements._reglType = "elements";
          reglElements._elements = elements;
          reglElements.subdata = function(data, offset) {
            buffer.subdata(data, offset);
            return reglElements;
          };
          reglElements.destroy = function() {
            destroyElements(elements);
          };
          return reglElements;
        }
        return {
          create: createElements,
          createStream: createElementStream,
          destroyStream: destroyElementStream,
          getElements: function(elements) {
            if (typeof elements === "function" && elements._elements instanceof REGLElementBuffer) {
              return elements._elements;
            }
            return null;
          },
          clear: function() {
            values(elementSet).forEach(destroyElements);
          }
        };
      }
      var FLOAT = new Float32Array(1);
      var INT = new Uint32Array(FLOAT.buffer);
      var GL_UNSIGNED_SHORT$4 = 5123;
      function convertToHalfFloat(array4) {
        var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array4.length);
        for (var i = 0; i < array4.length; ++i) {
          if (isNaN(array4[i])) {
            ushorts[i] = 65535;
          } else if (array4[i] === Infinity) {
            ushorts[i] = 31744;
          } else if (array4[i] === -Infinity) {
            ushorts[i] = 64512;
          } else {
            FLOAT[0] = array4[i];
            var x = INT[0];
            var sgn = x >>> 31 << 15;
            var exp = (x << 1 >>> 24) - 127;
            var frac = x >> 13 & (1 << 10) - 1;
            if (exp < -24) {
              ushorts[i] = sgn;
            } else if (exp < -14) {
              var s = -14 - exp;
              ushorts[i] = sgn + (frac + (1 << 10) >> s);
            } else if (exp > 15) {
              ushorts[i] = sgn + 31744;
            } else {
              ushorts[i] = sgn + (exp + 15 << 10) + frac;
            }
          }
        }
        return ushorts;
      }
      function isArrayLike(s) {
        return Array.isArray(s) || isTypedArray5(s);
      }
      var isPow2$1 = function(v2) {
        return !(v2 & v2 - 1) && !!v2;
      };
      var GL_COMPRESSED_TEXTURE_FORMATS = 34467;
      var GL_TEXTURE_2D$1 = 3553;
      var GL_TEXTURE_CUBE_MAP$1 = 34067;
      var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 34069;
      var GL_RGBA$1 = 6408;
      var GL_ALPHA = 6406;
      var GL_RGB = 6407;
      var GL_LUMINANCE = 6409;
      var GL_LUMINANCE_ALPHA = 6410;
      var GL_RGBA4 = 32854;
      var GL_RGB5_A1 = 32855;
      var GL_RGB565 = 36194;
      var GL_UNSIGNED_SHORT_4_4_4_4$1 = 32819;
      var GL_UNSIGNED_SHORT_5_5_5_1$1 = 32820;
      var GL_UNSIGNED_SHORT_5_6_5$1 = 33635;
      var GL_UNSIGNED_INT_24_8_WEBGL$1 = 34042;
      var GL_DEPTH_COMPONENT = 6402;
      var GL_DEPTH_STENCIL = 34041;
      var GL_SRGB_EXT = 35904;
      var GL_SRGB_ALPHA_EXT = 35906;
      var GL_HALF_FLOAT_OES$1 = 36193;
      var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
      var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
      var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
      var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
      var GL_COMPRESSED_RGB_ATC_WEBGL = 35986;
      var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987;
      var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798;
      var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840;
      var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841;
      var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842;
      var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843;
      var GL_COMPRESSED_RGB_ETC1_WEBGL = 36196;
      var GL_UNSIGNED_BYTE$5 = 5121;
      var GL_UNSIGNED_SHORT$3 = 5123;
      var GL_UNSIGNED_INT$3 = 5125;
      var GL_FLOAT$4 = 5126;
      var GL_TEXTURE_WRAP_S = 10242;
      var GL_TEXTURE_WRAP_T = 10243;
      var GL_REPEAT = 10497;
      var GL_CLAMP_TO_EDGE$1 = 33071;
      var GL_MIRRORED_REPEAT = 33648;
      var GL_TEXTURE_MAG_FILTER = 10240;
      var GL_TEXTURE_MIN_FILTER = 10241;
      var GL_NEAREST$1 = 9728;
      var GL_LINEAR = 9729;
      var GL_NEAREST_MIPMAP_NEAREST$1 = 9984;
      var GL_LINEAR_MIPMAP_NEAREST$1 = 9985;
      var GL_NEAREST_MIPMAP_LINEAR$1 = 9986;
      var GL_LINEAR_MIPMAP_LINEAR$1 = 9987;
      var GL_GENERATE_MIPMAP_HINT = 33170;
      var GL_DONT_CARE = 4352;
      var GL_FASTEST = 4353;
      var GL_NICEST = 4354;
      var GL_TEXTURE_MAX_ANISOTROPY_EXT = 34046;
      var GL_UNPACK_ALIGNMENT = 3317;
      var GL_UNPACK_FLIP_Y_WEBGL = 37440;
      var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441;
      var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443;
      var GL_BROWSER_DEFAULT_WEBGL = 37444;
      var GL_TEXTURE0$1 = 33984;
      var MIPMAP_FILTERS = [
        GL_NEAREST_MIPMAP_NEAREST$1,
        GL_NEAREST_MIPMAP_LINEAR$1,
        GL_LINEAR_MIPMAP_NEAREST$1,
        GL_LINEAR_MIPMAP_LINEAR$1
      ];
      var CHANNELS_FORMAT = [
        0,
        GL_LUMINANCE,
        GL_LUMINANCE_ALPHA,
        GL_RGB,
        GL_RGBA$1
      ];
      var FORMAT_CHANNELS = {};
      FORMAT_CHANNELS[GL_LUMINANCE] = FORMAT_CHANNELS[GL_ALPHA] = FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1;
      FORMAT_CHANNELS[GL_DEPTH_STENCIL] = FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2;
      FORMAT_CHANNELS[GL_RGB] = FORMAT_CHANNELS[GL_SRGB_EXT] = 3;
      FORMAT_CHANNELS[GL_RGBA$1] = FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4;
      function objectName(str) {
        return "[object " + str + "]";
      }
      var CANVAS_CLASS = objectName("HTMLCanvasElement");
      var OFFSCREENCANVAS_CLASS = objectName("OffscreenCanvas");
      var CONTEXT2D_CLASS = objectName("CanvasRenderingContext2D");
      var BITMAP_CLASS = objectName("ImageBitmap");
      var IMAGE_CLASS = objectName("HTMLImageElement");
      var VIDEO_CLASS = objectName("HTMLVideoElement");
      var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
        CANVAS_CLASS,
        OFFSCREENCANVAS_CLASS,
        CONTEXT2D_CLASS,
        BITMAP_CLASS,
        IMAGE_CLASS,
        VIDEO_CLASS
      ]);
      var TYPE_SIZES = [];
      TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1;
      TYPE_SIZES[GL_FLOAT$4] = 4;
      TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2;
      TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2;
      TYPE_SIZES[GL_UNSIGNED_INT$3] = 4;
      var FORMAT_SIZES_SPECIAL = [];
      FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2;
      FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2;
      FORMAT_SIZES_SPECIAL[GL_RGB565] = 2;
      FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5;
      function isNumericArray(arr) {
        return Array.isArray(arr) && (arr.length === 0 || typeof arr[0] === "number");
      }
      function isRectArray(arr) {
        if (!Array.isArray(arr)) {
          return false;
        }
        var width = arr.length;
        if (width === 0 || !isArrayLike(arr[0])) {
          return false;
        }
        return true;
      }
      function classString(x) {
        return Object.prototype.toString.call(x);
      }
      function isCanvasElement(object) {
        return classString(object) === CANVAS_CLASS;
      }
      function isOffscreenCanvas(object) {
        return classString(object) === OFFSCREENCANVAS_CLASS;
      }
      function isContext2D(object) {
        return classString(object) === CONTEXT2D_CLASS;
      }
      function isBitmap(object) {
        return classString(object) === BITMAP_CLASS;
      }
      function isImageElement(object) {
        return classString(object) === IMAGE_CLASS;
      }
      function isVideoElement(object) {
        return classString(object) === VIDEO_CLASS;
      }
      function isPixelData(object) {
        if (!object) {
          return false;
        }
        var className = classString(object);
        if (PIXEL_CLASSES.indexOf(className) >= 0) {
          return true;
        }
        return isNumericArray(object) || isRectArray(object) || isNDArrayLike(object);
      }
      function typedArrayCode$1(data) {
        return arrayTypes[Object.prototype.toString.call(data)] | 0;
      }
      function convertData(result, data) {
        var n = data.length;
        switch (result.type) {
          case GL_UNSIGNED_BYTE$5:
          case GL_UNSIGNED_SHORT$3:
          case GL_UNSIGNED_INT$3:
          case GL_FLOAT$4:
            var converted = pool.allocType(result.type, n);
            converted.set(data);
            result.data = converted;
            break;
          case GL_HALF_FLOAT_OES$1:
            result.data = convertToHalfFloat(data);
            break;
          default:
            check$1.raise("unsupported texture type, must specify a typed array");
        }
      }
      function preConvert(image2, n) {
        return pool.allocType(
          image2.type === GL_HALF_FLOAT_OES$1 ? GL_FLOAT$4 : image2.type,
          n
        );
      }
      function postConvert(image2, data) {
        if (image2.type === GL_HALF_FLOAT_OES$1) {
          image2.data = convertToHalfFloat(data);
          pool.freeType(data);
        } else {
          image2.data = data;
        }
      }
      function transposeData(image2, array4, strideX, strideY, strideC, offset) {
        var w = image2.width;
        var h = image2.height;
        var c = image2.channels;
        var n = w * h * c;
        var data = preConvert(image2, n);
        var p = 0;
        for (var i = 0; i < h; ++i) {
          for (var j = 0; j < w; ++j) {
            for (var k = 0; k < c; ++k) {
              data[p++] = array4[strideX * j + strideY * i + strideC * k + offset];
            }
          }
        }
        postConvert(image2, data);
      }
      function getTextureSize(format2, type, width, height, isMipmap, isCube) {
        var s;
        if (typeof FORMAT_SIZES_SPECIAL[format2] !== "undefined") {
          s = FORMAT_SIZES_SPECIAL[format2];
        } else {
          s = FORMAT_CHANNELS[format2] * TYPE_SIZES[type];
        }
        if (isCube) {
          s *= 6;
        }
        if (isMipmap) {
          var total = 0;
          var w = width;
          while (w >= 1) {
            total += s * w * w;
            w /= 2;
          }
          return total;
        } else {
          return s * width * height;
        }
      }
      function createTextureSet(gl2, extensions, limits, reglPoll, contextState, stats2, config) {
        var mipmapHint = {
          "don't care": GL_DONT_CARE,
          "dont care": GL_DONT_CARE,
          "nice": GL_NICEST,
          "fast": GL_FASTEST
        };
        var wrapModes = {
          "repeat": GL_REPEAT,
          "clamp": GL_CLAMP_TO_EDGE$1,
          "mirror": GL_MIRRORED_REPEAT
        };
        var magFilters = {
          "nearest": GL_NEAREST$1,
          "linear": GL_LINEAR
        };
        var minFilters = extend2({
          "mipmap": GL_LINEAR_MIPMAP_LINEAR$1,
          "nearest mipmap nearest": GL_NEAREST_MIPMAP_NEAREST$1,
          "linear mipmap nearest": GL_LINEAR_MIPMAP_NEAREST$1,
          "nearest mipmap linear": GL_NEAREST_MIPMAP_LINEAR$1,
          "linear mipmap linear": GL_LINEAR_MIPMAP_LINEAR$1
        }, magFilters);
        var colorSpace = {
          "none": 0,
          "browser": GL_BROWSER_DEFAULT_WEBGL
        };
        var textureTypes = {
          "uint8": GL_UNSIGNED_BYTE$5,
          "rgba4": GL_UNSIGNED_SHORT_4_4_4_4$1,
          "rgb565": GL_UNSIGNED_SHORT_5_6_5$1,
          "rgb5 a1": GL_UNSIGNED_SHORT_5_5_5_1$1
        };
        var textureFormats = {
          "alpha": GL_ALPHA,
          "luminance": GL_LUMINANCE,
          "luminance alpha": GL_LUMINANCE_ALPHA,
          "rgb": GL_RGB,
          "rgba": GL_RGBA$1,
          "rgba4": GL_RGBA4,
          "rgb5 a1": GL_RGB5_A1,
          "rgb565": GL_RGB565
        };
        var compressedTextureFormats = {};
        if (extensions.ext_srgb) {
          textureFormats.srgb = GL_SRGB_EXT;
          textureFormats.srgba = GL_SRGB_ALPHA_EXT;
        }
        if (extensions.oes_texture_float) {
          textureTypes.float32 = textureTypes.float = GL_FLOAT$4;
        }
        if (extensions.oes_texture_half_float) {
          textureTypes["float16"] = textureTypes["half float"] = GL_HALF_FLOAT_OES$1;
        }
        if (extensions.webgl_depth_texture) {
          extend2(textureFormats, {
            "depth": GL_DEPTH_COMPONENT,
            "depth stencil": GL_DEPTH_STENCIL
          });
          extend2(textureTypes, {
            "uint16": GL_UNSIGNED_SHORT$3,
            "uint32": GL_UNSIGNED_INT$3,
            "depth stencil": GL_UNSIGNED_INT_24_8_WEBGL$1
          });
        }
        if (extensions.webgl_compressed_texture_s3tc) {
          extend2(compressedTextureFormats, {
            "rgb s3tc dxt1": GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
            "rgba s3tc dxt1": GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
            "rgba s3tc dxt3": GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
            "rgba s3tc dxt5": GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
          });
        }
        if (extensions.webgl_compressed_texture_atc) {
          extend2(compressedTextureFormats, {
            "rgb atc": GL_COMPRESSED_RGB_ATC_WEBGL,
            "rgba atc explicit alpha": GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
            "rgba atc interpolated alpha": GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
          });
        }
        if (extensions.webgl_compressed_texture_pvrtc) {
          extend2(compressedTextureFormats, {
            "rgb pvrtc 4bppv1": GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
            "rgb pvrtc 2bppv1": GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
            "rgba pvrtc 4bppv1": GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
            "rgba pvrtc 2bppv1": GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
          });
        }
        if (extensions.webgl_compressed_texture_etc1) {
          compressedTextureFormats["rgb etc1"] = GL_COMPRESSED_RGB_ETC1_WEBGL;
        }
        var supportedCompressedFormats = Array.prototype.slice.call(
          gl2.getParameter(GL_COMPRESSED_TEXTURE_FORMATS)
        );
        Object.keys(compressedTextureFormats).forEach(function(name) {
          var format2 = compressedTextureFormats[name];
          if (supportedCompressedFormats.indexOf(format2) >= 0) {
            textureFormats[name] = format2;
          }
        });
        var supportedFormats = Object.keys(textureFormats);
        limits.textureFormats = supportedFormats;
        var textureFormatsInvert = [];
        Object.keys(textureFormats).forEach(function(key) {
          var val = textureFormats[key];
          textureFormatsInvert[val] = key;
        });
        var textureTypesInvert = [];
        Object.keys(textureTypes).forEach(function(key) {
          var val = textureTypes[key];
          textureTypesInvert[val] = key;
        });
        var magFiltersInvert = [];
        Object.keys(magFilters).forEach(function(key) {
          var val = magFilters[key];
          magFiltersInvert[val] = key;
        });
        var minFiltersInvert = [];
        Object.keys(minFilters).forEach(function(key) {
          var val = minFilters[key];
          minFiltersInvert[val] = key;
        });
        var wrapModesInvert = [];
        Object.keys(wrapModes).forEach(function(key) {
          var val = wrapModes[key];
          wrapModesInvert[val] = key;
        });
        var colorFormats = supportedFormats.reduce(function(color2, key) {
          var glenum = textureFormats[key];
          if (glenum === GL_LUMINANCE || glenum === GL_ALPHA || glenum === GL_LUMINANCE || glenum === GL_LUMINANCE_ALPHA || glenum === GL_DEPTH_COMPONENT || glenum === GL_DEPTH_STENCIL || extensions.ext_srgb && (glenum === GL_SRGB_EXT || glenum === GL_SRGB_ALPHA_EXT)) {
            color2[glenum] = glenum;
          } else if (glenum === GL_RGB5_A1 || key.indexOf("rgba") >= 0) {
            color2[glenum] = GL_RGBA$1;
          } else {
            color2[glenum] = GL_RGB;
          }
          return color2;
        }, {});
        function TexFlags() {
          this.internalformat = GL_RGBA$1;
          this.format = GL_RGBA$1;
          this.type = GL_UNSIGNED_BYTE$5;
          this.compressed = false;
          this.premultiplyAlpha = false;
          this.flipY = false;
          this.unpackAlignment = 1;
          this.colorSpace = GL_BROWSER_DEFAULT_WEBGL;
          this.width = 0;
          this.height = 0;
          this.channels = 0;
        }
        function copyFlags(result, other) {
          result.internalformat = other.internalformat;
          result.format = other.format;
          result.type = other.type;
          result.compressed = other.compressed;
          result.premultiplyAlpha = other.premultiplyAlpha;
          result.flipY = other.flipY;
          result.unpackAlignment = other.unpackAlignment;
          result.colorSpace = other.colorSpace;
          result.width = other.width;
          result.height = other.height;
          result.channels = other.channels;
        }
        function parseFlags(flags, options) {
          if (typeof options !== "object" || !options) {
            return;
          }
          if ("premultiplyAlpha" in options) {
            check$1.type(
              options.premultiplyAlpha,
              "boolean",
              "invalid premultiplyAlpha"
            );
            flags.premultiplyAlpha = options.premultiplyAlpha;
          }
          if ("flipY" in options) {
            check$1.type(
              options.flipY,
              "boolean",
              "invalid texture flip"
            );
            flags.flipY = options.flipY;
          }
          if ("alignment" in options) {
            check$1.oneOf(
              options.alignment,
              [1, 2, 4, 8],
              "invalid texture unpack alignment"
            );
            flags.unpackAlignment = options.alignment;
          }
          if ("colorSpace" in options) {
            check$1.parameter(
              options.colorSpace,
              colorSpace,
              "invalid colorSpace"
            );
            flags.colorSpace = colorSpace[options.colorSpace];
          }
          if ("type" in options) {
            var type = options.type;
            check$1(
              extensions.oes_texture_float || !(type === "float" || type === "float32"),
              "you must enable the OES_texture_float extension in order to use floating point textures."
            );
            check$1(
              extensions.oes_texture_half_float || !(type === "half float" || type === "float16"),
              "you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures."
            );
            check$1(
              extensions.webgl_depth_texture || !(type === "uint16" || type === "uint32" || type === "depth stencil"),
              "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
            );
            check$1.parameter(
              type,
              textureTypes,
              "invalid texture type"
            );
            flags.type = textureTypes[type];
          }
          var w = flags.width;
          var h = flags.height;
          var c = flags.channels;
          var hasChannels = false;
          if ("shape" in options) {
            check$1(
              Array.isArray(options.shape) && options.shape.length >= 2,
              "shape must be an array"
            );
            w = options.shape[0];
            h = options.shape[1];
            if (options.shape.length === 3) {
              c = options.shape[2];
              check$1(c > 0 && c <= 4, "invalid number of channels");
              hasChannels = true;
            }
            check$1(w >= 0 && w <= limits.maxTextureSize, "invalid width");
            check$1(h >= 0 && h <= limits.maxTextureSize, "invalid height");
          } else {
            if ("radius" in options) {
              w = h = options.radius;
              check$1(w >= 0 && w <= limits.maxTextureSize, "invalid radius");
            }
            if ("width" in options) {
              w = options.width;
              check$1(w >= 0 && w <= limits.maxTextureSize, "invalid width");
            }
            if ("height" in options) {
              h = options.height;
              check$1(h >= 0 && h <= limits.maxTextureSize, "invalid height");
            }
            if ("channels" in options) {
              c = options.channels;
              check$1(c > 0 && c <= 4, "invalid number of channels");
              hasChannels = true;
            }
          }
          flags.width = w | 0;
          flags.height = h | 0;
          flags.channels = c | 0;
          var hasFormat = false;
          if ("format" in options) {
            var formatStr = options.format;
            check$1(
              extensions.webgl_depth_texture || !(formatStr === "depth" || formatStr === "depth stencil"),
              "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
            );
            check$1.parameter(
              formatStr,
              textureFormats,
              "invalid texture format"
            );
            var internalformat = flags.internalformat = textureFormats[formatStr];
            flags.format = colorFormats[internalformat];
            if (formatStr in textureTypes) {
              if (!("type" in options)) {
                flags.type = textureTypes[formatStr];
              }
            }
            if (formatStr in compressedTextureFormats) {
              flags.compressed = true;
            }
            hasFormat = true;
          }
          if (!hasChannels && hasFormat) {
            flags.channels = FORMAT_CHANNELS[flags.format];
          } else if (hasChannels && !hasFormat) {
            if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
              flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels];
            }
          } else if (hasFormat && hasChannels) {
            check$1(
              flags.channels === FORMAT_CHANNELS[flags.format],
              "number of channels inconsistent with specified format"
            );
          }
        }
        function setFlags(flags) {
          gl2.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY);
          gl2.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha);
          gl2.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace);
          gl2.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment);
        }
        function TexImage() {
          TexFlags.call(this);
          this.xOffset = 0;
          this.yOffset = 0;
          this.data = null;
          this.needsFree = false;
          this.element = null;
          this.needsCopy = false;
        }
        function parseImage(image2, options) {
          var data = null;
          if (isPixelData(options)) {
            data = options;
          } else if (options) {
            check$1.type(options, "object", "invalid pixel data type");
            parseFlags(image2, options);
            if ("x" in options) {
              image2.xOffset = options.x | 0;
            }
            if ("y" in options) {
              image2.yOffset = options.y | 0;
            }
            if (isPixelData(options.data)) {
              data = options.data;
            }
          }
          check$1(
            !image2.compressed || data instanceof Uint8Array,
            "compressed texture data must be stored in a uint8array"
          );
          if (options.copy) {
            check$1(!data, "can not specify copy and data field for the same texture");
            var viewW = contextState.viewportWidth;
            var viewH = contextState.viewportHeight;
            image2.width = image2.width || viewW - image2.xOffset;
            image2.height = image2.height || viewH - image2.yOffset;
            image2.needsCopy = true;
            check$1(
              image2.xOffset >= 0 && image2.xOffset < viewW && image2.yOffset >= 0 && image2.yOffset < viewH && image2.width > 0 && image2.width <= viewW && image2.height > 0 && image2.height <= viewH,
              "copy texture read out of bounds"
            );
          } else if (!data) {
            image2.width = image2.width || 1;
            image2.height = image2.height || 1;
            image2.channels = image2.channels || 4;
          } else if (isTypedArray5(data)) {
            image2.channels = image2.channels || 4;
            image2.data = data;
            if (!("type" in options) && image2.type === GL_UNSIGNED_BYTE$5) {
              image2.type = typedArrayCode$1(data);
            }
          } else if (isNumericArray(data)) {
            image2.channels = image2.channels || 4;
            convertData(image2, data);
            image2.alignment = 1;
            image2.needsFree = true;
          } else if (isNDArrayLike(data)) {
            var array4 = data.data;
            if (!Array.isArray(array4) && image2.type === GL_UNSIGNED_BYTE$5) {
              image2.type = typedArrayCode$1(array4);
            }
            var shape = data.shape;
            var stride = data.stride;
            var shapeX, shapeY, shapeC, strideX, strideY, strideC;
            if (shape.length === 3) {
              shapeC = shape[2];
              strideC = stride[2];
            } else {
              check$1(shape.length === 2, "invalid ndarray pixel data, must be 2 or 3D");
              shapeC = 1;
              strideC = 1;
            }
            shapeX = shape[0];
            shapeY = shape[1];
            strideX = stride[0];
            strideY = stride[1];
            image2.alignment = 1;
            image2.width = shapeX;
            image2.height = shapeY;
            image2.channels = shapeC;
            image2.format = image2.internalformat = CHANNELS_FORMAT[shapeC];
            image2.needsFree = true;
            transposeData(image2, array4, strideX, strideY, strideC, data.offset);
          } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
            if (isCanvasElement(data) || isOffscreenCanvas(data)) {
              image2.element = data;
            } else {
              image2.element = data.canvas;
            }
            image2.width = image2.element.width;
            image2.height = image2.element.height;
            image2.channels = 4;
          } else if (isBitmap(data)) {
            image2.element = data;
            image2.width = data.width;
            image2.height = data.height;
            image2.channels = 4;
          } else if (isImageElement(data)) {
            image2.element = data;
            image2.width = data.naturalWidth;
            image2.height = data.naturalHeight;
            image2.channels = 4;
          } else if (isVideoElement(data)) {
            image2.element = data;
            image2.width = data.videoWidth;
            image2.height = data.videoHeight;
            image2.channels = 4;
          } else if (isRectArray(data)) {
            var w = image2.width || data[0].length;
            var h = image2.height || data.length;
            var c = image2.channels;
            if (isArrayLike(data[0][0])) {
              c = c || data[0][0].length;
            } else {
              c = c || 1;
            }
            var arrayShape2 = flattenUtils.shape(data);
            var n = 1;
            for (var dd = 0; dd < arrayShape2.length; ++dd) {
              n *= arrayShape2[dd];
            }
            var allocData = preConvert(image2, n);
            flattenUtils.flatten(data, arrayShape2, "", allocData);
            postConvert(image2, allocData);
            image2.alignment = 1;
            image2.width = w;
            image2.height = h;
            image2.channels = c;
            image2.format = image2.internalformat = CHANNELS_FORMAT[c];
            image2.needsFree = true;
          }
          if (image2.type === GL_FLOAT$4) {
            check$1(
              limits.extensions.indexOf("oes_texture_float") >= 0,
              "oes_texture_float extension not enabled"
            );
          } else if (image2.type === GL_HALF_FLOAT_OES$1) {
            check$1(
              limits.extensions.indexOf("oes_texture_half_float") >= 0,
              "oes_texture_half_float extension not enabled"
            );
          }
        }
        function setImage(info, target, miplevel) {
          var element = info.element;
          var data = info.data;
          var internalformat = info.internalformat;
          var format2 = info.format;
          var type = info.type;
          var width = info.width;
          var height = info.height;
          setFlags(info);
          if (element) {
            gl2.texImage2D(target, miplevel, format2, format2, type, element);
          } else if (info.compressed) {
            gl2.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data);
          } else if (info.needsCopy) {
            reglPoll();
            gl2.copyTexImage2D(
              target,
              miplevel,
              format2,
              info.xOffset,
              info.yOffset,
              width,
              height,
              0
            );
          } else {
            gl2.texImage2D(target, miplevel, format2, width, height, 0, format2, type, data || null);
          }
        }
        function setSubImage(info, target, x, y, miplevel) {
          var element = info.element;
          var data = info.data;
          var internalformat = info.internalformat;
          var format2 = info.format;
          var type = info.type;
          var width = info.width;
          var height = info.height;
          setFlags(info);
          if (element) {
            gl2.texSubImage2D(
              target,
              miplevel,
              x,
              y,
              format2,
              type,
              element
            );
          } else if (info.compressed) {
            gl2.compressedTexSubImage2D(
              target,
              miplevel,
              x,
              y,
              internalformat,
              width,
              height,
              data
            );
          } else if (info.needsCopy) {
            reglPoll();
            gl2.copyTexSubImage2D(
              target,
              miplevel,
              x,
              y,
              info.xOffset,
              info.yOffset,
              width,
              height
            );
          } else {
            gl2.texSubImage2D(
              target,
              miplevel,
              x,
              y,
              width,
              height,
              format2,
              type,
              data
            );
          }
        }
        var imagePool = [];
        function allocImage() {
          return imagePool.pop() || new TexImage();
        }
        function freeImage(image2) {
          if (image2.needsFree) {
            pool.freeType(image2.data);
          }
          TexImage.call(image2);
          imagePool.push(image2);
        }
        function MipMap() {
          TexFlags.call(this);
          this.genMipmaps = false;
          this.mipmapHint = GL_DONT_CARE;
          this.mipmask = 0;
          this.images = Array(16);
        }
        function parseMipMapFromShape(mipmap, width, height) {
          var img = mipmap.images[0] = allocImage();
          mipmap.mipmask = 1;
          img.width = mipmap.width = width;
          img.height = mipmap.height = height;
          img.channels = mipmap.channels = 4;
        }
        function parseMipMapFromObject(mipmap, options) {
          var imgData = null;
          if (isPixelData(options)) {
            imgData = mipmap.images[0] = allocImage();
            copyFlags(imgData, mipmap);
            parseImage(imgData, options);
            mipmap.mipmask = 1;
          } else {
            parseFlags(mipmap, options);
            if (Array.isArray(options.mipmap)) {
              var mipData = options.mipmap;
              for (var i = 0; i < mipData.length; ++i) {
                imgData = mipmap.images[i] = allocImage();
                copyFlags(imgData, mipmap);
                imgData.width >>= i;
                imgData.height >>= i;
                parseImage(imgData, mipData[i]);
                mipmap.mipmask |= 1 << i;
              }
            } else {
              imgData = mipmap.images[0] = allocImage();
              copyFlags(imgData, mipmap);
              parseImage(imgData, options);
              mipmap.mipmask = 1;
            }
          }
          copyFlags(mipmap, mipmap.images[0]);
          if (mipmap.compressed && (mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT)) {
            check$1(
              mipmap.width % 4 === 0 && mipmap.height % 4 === 0,
              "for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4"
            );
          }
        }
        function setMipMap(mipmap, target) {
          var images = mipmap.images;
          for (var i = 0; i < images.length; ++i) {
            if (!images[i]) {
              return;
            }
            setImage(images[i], target, i);
          }
        }
        var mipPool = [];
        function allocMipMap() {
          var result = mipPool.pop() || new MipMap();
          TexFlags.call(result);
          result.mipmask = 0;
          for (var i = 0; i < 16; ++i) {
            result.images[i] = null;
          }
          return result;
        }
        function freeMipMap(mipmap) {
          var images = mipmap.images;
          for (var i = 0; i < images.length; ++i) {
            if (images[i]) {
              freeImage(images[i]);
            }
            images[i] = null;
          }
          mipPool.push(mipmap);
        }
        function TexInfo() {
          this.minFilter = GL_NEAREST$1;
          this.magFilter = GL_NEAREST$1;
          this.wrapS = GL_CLAMP_TO_EDGE$1;
          this.wrapT = GL_CLAMP_TO_EDGE$1;
          this.anisotropic = 1;
          this.genMipmaps = false;
          this.mipmapHint = GL_DONT_CARE;
        }
        function parseTexInfo(info, options) {
          if ("min" in options) {
            var minFilter = options.min;
            check$1.parameter(minFilter, minFilters);
            info.minFilter = minFilters[minFilter];
            if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !("faces" in options)) {
              info.genMipmaps = true;
            }
          }
          if ("mag" in options) {
            var magFilter = options.mag;
            check$1.parameter(magFilter, magFilters);
            info.magFilter = magFilters[magFilter];
          }
          var wrapS = info.wrapS;
          var wrapT = info.wrapT;
          if ("wrap" in options) {
            var wrap2 = options.wrap;
            if (typeof wrap2 === "string") {
              check$1.parameter(wrap2, wrapModes);
              wrapS = wrapT = wrapModes[wrap2];
            } else if (Array.isArray(wrap2)) {
              check$1.parameter(wrap2[0], wrapModes);
              check$1.parameter(wrap2[1], wrapModes);
              wrapS = wrapModes[wrap2[0]];
              wrapT = wrapModes[wrap2[1]];
            }
          } else {
            if ("wrapS" in options) {
              var optWrapS = options.wrapS;
              check$1.parameter(optWrapS, wrapModes);
              wrapS = wrapModes[optWrapS];
            }
            if ("wrapT" in options) {
              var optWrapT = options.wrapT;
              check$1.parameter(optWrapT, wrapModes);
              wrapT = wrapModes[optWrapT];
            }
          }
          info.wrapS = wrapS;
          info.wrapT = wrapT;
          if ("anisotropic" in options) {
            var anisotropic = options.anisotropic;
            check$1(
              typeof anisotropic === "number" && anisotropic >= 1 && anisotropic <= limits.maxAnisotropic,
              "aniso samples must be between 1 and "
            );
            info.anisotropic = options.anisotropic;
          }
          if ("mipmap" in options) {
            var hasMipMap = false;
            switch (typeof options.mipmap) {
              case "string":
                check$1.parameter(
                  options.mipmap,
                  mipmapHint,
                  "invalid mipmap hint"
                );
                info.mipmapHint = mipmapHint[options.mipmap];
                info.genMipmaps = true;
                hasMipMap = true;
                break;
              case "boolean":
                hasMipMap = info.genMipmaps = options.mipmap;
                break;
              case "object":
                check$1(Array.isArray(options.mipmap), "invalid mipmap type");
                info.genMipmaps = false;
                hasMipMap = true;
                break;
              default:
                check$1.raise("invalid mipmap type");
            }
            if (hasMipMap && !("min" in options)) {
              info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1;
            }
          }
        }
        function setTexInfo(info, target) {
          gl2.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter);
          gl2.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter);
          gl2.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS);
          gl2.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT);
          if (extensions.ext_texture_filter_anisotropic) {
            gl2.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic);
          }
          if (info.genMipmaps) {
            gl2.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint);
            gl2.generateMipmap(target);
          }
        }
        var textureCount = 0;
        var textureSet = {};
        var numTexUnits = limits.maxTextureUnits;
        var textureUnits = Array(numTexUnits).map(function() {
          return null;
        });
        function REGLTexture(target) {
          TexFlags.call(this);
          this.mipmask = 0;
          this.internalformat = GL_RGBA$1;
          this.id = textureCount++;
          this.refCount = 1;
          this.target = target;
          this.texture = gl2.createTexture();
          this.unit = -1;
          this.bindCount = 0;
          this.texInfo = new TexInfo();
          if (config.profile) {
            this.stats = { size: 0 };
          }
        }
        function tempBind(texture) {
          gl2.activeTexture(GL_TEXTURE0$1);
          gl2.bindTexture(texture.target, texture.texture);
        }
        function tempRestore() {
          var prev = textureUnits[0];
          if (prev) {
            gl2.bindTexture(prev.target, prev.texture);
          } else {
            gl2.bindTexture(GL_TEXTURE_2D$1, null);
          }
        }
        function destroy(texture) {
          var handle = texture.texture;
          check$1(handle, "must not double destroy texture");
          var unit2 = texture.unit;
          var target = texture.target;
          if (unit2 >= 0) {
            gl2.activeTexture(GL_TEXTURE0$1 + unit2);
            gl2.bindTexture(target, null);
            textureUnits[unit2] = null;
          }
          gl2.deleteTexture(handle);
          texture.texture = null;
          texture.params = null;
          texture.pixels = null;
          texture.refCount = 0;
          delete textureSet[texture.id];
          stats2.textureCount--;
        }
        extend2(REGLTexture.prototype, {
          bind: function() {
            var texture = this;
            texture.bindCount += 1;
            var unit2 = texture.unit;
            if (unit2 < 0) {
              for (var i = 0; i < numTexUnits; ++i) {
                var other = textureUnits[i];
                if (other) {
                  if (other.bindCount > 0) {
                    continue;
                  }
                  other.unit = -1;
                }
                textureUnits[i] = texture;
                unit2 = i;
                break;
              }
              if (unit2 >= numTexUnits) {
                check$1.raise("insufficient number of texture units");
              }
              if (config.profile && stats2.maxTextureUnits < unit2 + 1) {
                stats2.maxTextureUnits = unit2 + 1;
              }
              texture.unit = unit2;
              gl2.activeTexture(GL_TEXTURE0$1 + unit2);
              gl2.bindTexture(texture.target, texture.texture);
            }
            return unit2;
          },
          unbind: function() {
            this.bindCount -= 1;
          },
          decRef: function() {
            if (--this.refCount <= 0) {
              destroy(this);
            }
          }
        });
        function createTexture2D(a, b) {
          var texture = new REGLTexture(GL_TEXTURE_2D$1);
          textureSet[texture.id] = texture;
          stats2.textureCount++;
          function reglTexture2D(a2, b2) {
            var texInfo = texture.texInfo;
            TexInfo.call(texInfo);
            var mipData = allocMipMap();
            if (typeof a2 === "number") {
              if (typeof b2 === "number") {
                parseMipMapFromShape(mipData, a2 | 0, b2 | 0);
              } else {
                parseMipMapFromShape(mipData, a2 | 0, a2 | 0);
              }
            } else if (a2) {
              check$1.type(a2, "object", "invalid arguments to regl.texture");
              parseTexInfo(texInfo, a2);
              parseMipMapFromObject(mipData, a2);
            } else {
              parseMipMapFromShape(mipData, 1, 1);
            }
            if (texInfo.genMipmaps) {
              mipData.mipmask = (mipData.width << 1) - 1;
            }
            texture.mipmask = mipData.mipmask;
            copyFlags(texture, mipData);
            check$1.texture2D(texInfo, mipData, limits);
            texture.internalformat = mipData.internalformat;
            reglTexture2D.width = mipData.width;
            reglTexture2D.height = mipData.height;
            tempBind(texture);
            setMipMap(mipData, GL_TEXTURE_2D$1);
            setTexInfo(texInfo, GL_TEXTURE_2D$1);
            tempRestore();
            freeMipMap(mipData);
            if (config.profile) {
              texture.stats.size = getTextureSize(
                texture.internalformat,
                texture.type,
                mipData.width,
                mipData.height,
                texInfo.genMipmaps,
                false
              );
            }
            reglTexture2D.format = textureFormatsInvert[texture.internalformat];
            reglTexture2D.type = textureTypesInvert[texture.type];
            reglTexture2D.mag = magFiltersInvert[texInfo.magFilter];
            reglTexture2D.min = minFiltersInvert[texInfo.minFilter];
            reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS];
            reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT];
            return reglTexture2D;
          }
          function subimage(image2, x_, y_, level_) {
            check$1(!!image2, "must specify image data");
            var x = x_ | 0;
            var y = y_ | 0;
            var level = level_ | 0;
            var imageData = allocImage();
            copyFlags(imageData, texture);
            imageData.width = 0;
            imageData.height = 0;
            parseImage(imageData, image2);
            imageData.width = imageData.width || (texture.width >> level) - x;
            imageData.height = imageData.height || (texture.height >> level) - y;
            check$1(
              texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat,
              "incompatible format for texture.subimage"
            );
            check$1(
              x >= 0 && y >= 0 && x + imageData.width <= texture.width && y + imageData.height <= texture.height,
              "texture.subimage write out of bounds"
            );
            check$1(
              texture.mipmask & 1 << level,
              "missing mipmap data"
            );
            check$1(
              imageData.data || imageData.element || imageData.needsCopy,
              "missing image data"
            );
            tempBind(texture);
            setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level);
            tempRestore();
            freeImage(imageData);
            return reglTexture2D;
          }
          function resize(w_, h_) {
            var w = w_ | 0;
            var h = h_ | 0 || w;
            if (w === texture.width && h === texture.height) {
              return reglTexture2D;
            }
            reglTexture2D.width = texture.width = w;
            reglTexture2D.height = texture.height = h;
            tempBind(texture);
            for (var i = 0; texture.mipmask >> i; ++i) {
              var _w = w >> i;
              var _h = h >> i;
              if (!_w || !_h)
                break;
              gl2.texImage2D(
                GL_TEXTURE_2D$1,
                i,
                texture.format,
                _w,
                _h,
                0,
                texture.format,
                texture.type,
                null
              );
            }
            tempRestore();
            if (config.profile) {
              texture.stats.size = getTextureSize(
                texture.internalformat,
                texture.type,
                w,
                h,
                false,
                false
              );
            }
            return reglTexture2D;
          }
          reglTexture2D(a, b);
          reglTexture2D.subimage = subimage;
          reglTexture2D.resize = resize;
          reglTexture2D._reglType = "texture2d";
          reglTexture2D._texture = texture;
          if (config.profile) {
            reglTexture2D.stats = texture.stats;
          }
          reglTexture2D.destroy = function() {
            texture.decRef();
          };
          return reglTexture2D;
        }
        function createTextureCube(a0, a1, a2, a3, a4, a5) {
          var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1);
          textureSet[texture.id] = texture;
          stats2.cubeCount++;
          var faces = new Array(6);
          function reglTextureCube(a02, a12, a22, a32, a42, a52) {
            var i;
            var texInfo = texture.texInfo;
            TexInfo.call(texInfo);
            for (i = 0; i < 6; ++i) {
              faces[i] = allocMipMap();
            }
            if (typeof a02 === "number" || !a02) {
              var s = a02 | 0 || 1;
              for (i = 0; i < 6; ++i) {
                parseMipMapFromShape(faces[i], s, s);
              }
            } else if (typeof a02 === "object") {
              if (a12) {
                parseMipMapFromObject(faces[0], a02);
                parseMipMapFromObject(faces[1], a12);
                parseMipMapFromObject(faces[2], a22);
                parseMipMapFromObject(faces[3], a32);
                parseMipMapFromObject(faces[4], a42);
                parseMipMapFromObject(faces[5], a52);
              } else {
                parseTexInfo(texInfo, a02);
                parseFlags(texture, a02);
                if ("faces" in a02) {
                  var faceInput = a02.faces;
                  check$1(
                    Array.isArray(faceInput) && faceInput.length === 6,
                    "cube faces must be a length 6 array"
                  );
                  for (i = 0; i < 6; ++i) {
                    check$1(
                      typeof faceInput[i] === "object" && !!faceInput[i],
                      "invalid input for cube map face"
                    );
                    copyFlags(faces[i], texture);
                    parseMipMapFromObject(faces[i], faceInput[i]);
                  }
                } else {
                  for (i = 0; i < 6; ++i) {
                    parseMipMapFromObject(faces[i], a02);
                  }
                }
              }
            } else {
              check$1.raise("invalid arguments to cube map");
            }
            copyFlags(texture, faces[0]);
            if (!limits.npotTextureCube) {
              check$1(isPow2$1(texture.width) && isPow2$1(texture.height), "your browser does not support non power or two texture dimensions");
            }
            if (texInfo.genMipmaps) {
              texture.mipmask = (faces[0].width << 1) - 1;
            } else {
              texture.mipmask = faces[0].mipmask;
            }
            check$1.textureCube(texture, texInfo, faces, limits);
            texture.internalformat = faces[0].internalformat;
            reglTextureCube.width = faces[0].width;
            reglTextureCube.height = faces[0].height;
            tempBind(texture);
            for (i = 0; i < 6; ++i) {
              setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i);
            }
            setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1);
            tempRestore();
            if (config.profile) {
              texture.stats.size = getTextureSize(
                texture.internalformat,
                texture.type,
                reglTextureCube.width,
                reglTextureCube.height,
                texInfo.genMipmaps,
                true
              );
            }
            reglTextureCube.format = textureFormatsInvert[texture.internalformat];
            reglTextureCube.type = textureTypesInvert[texture.type];
            reglTextureCube.mag = magFiltersInvert[texInfo.magFilter];
            reglTextureCube.min = minFiltersInvert[texInfo.minFilter];
            reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS];
            reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT];
            for (i = 0; i < 6; ++i) {
              freeMipMap(faces[i]);
            }
            return reglTextureCube;
          }
          function subimage(face, image2, x_, y_, level_) {
            check$1(!!image2, "must specify image data");
            check$1(typeof face === "number" && face === (face | 0) && face >= 0 && face < 6, "invalid face");
            var x = x_ | 0;
            var y = y_ | 0;
            var level = level_ | 0;
            var imageData = allocImage();
            copyFlags(imageData, texture);
            imageData.width = 0;
            imageData.height = 0;
            parseImage(imageData, image2);
            imageData.width = imageData.width || (texture.width >> level) - x;
            imageData.height = imageData.height || (texture.height >> level) - y;
            check$1(
              texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat,
              "incompatible format for texture.subimage"
            );
            check$1(
              x >= 0 && y >= 0 && x + imageData.width <= texture.width && y + imageData.height <= texture.height,
              "texture.subimage write out of bounds"
            );
            check$1(
              texture.mipmask & 1 << level,
              "missing mipmap data"
            );
            check$1(
              imageData.data || imageData.element || imageData.needsCopy,
              "missing image data"
            );
            tempBind(texture);
            setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level);
            tempRestore();
            freeImage(imageData);
            return reglTextureCube;
          }
          function resize(radius_) {
            var radius = radius_ | 0;
            if (radius === texture.width) {
              return;
            }
            reglTextureCube.width = texture.width = radius;
            reglTextureCube.height = texture.height = radius;
            tempBind(texture);
            for (var i = 0; i < 6; ++i) {
              for (var j = 0; texture.mipmask >> j; ++j) {
                gl2.texImage2D(
                  GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i,
                  j,
                  texture.format,
                  radius >> j,
                  radius >> j,
                  0,
                  texture.format,
                  texture.type,
                  null
                );
              }
            }
            tempRestore();
            if (config.profile) {
              texture.stats.size = getTextureSize(
                texture.internalformat,
                texture.type,
                reglTextureCube.width,
                reglTextureCube.height,
                false,
                true
              );
            }
            return reglTextureCube;
          }
          reglTextureCube(a0, a1, a2, a3, a4, a5);
          reglTextureCube.subimage = subimage;
          reglTextureCube.resize = resize;
          reglTextureCube._reglType = "textureCube";
          reglTextureCube._texture = texture;
          if (config.profile) {
            reglTextureCube.stats = texture.stats;
          }
          reglTextureCube.destroy = function() {
            texture.decRef();
          };
          return reglTextureCube;
        }
        function destroyTextures() {
          for (var i = 0; i < numTexUnits; ++i) {
            gl2.activeTexture(GL_TEXTURE0$1 + i);
            gl2.bindTexture(GL_TEXTURE_2D$1, null);
            textureUnits[i] = null;
          }
          values(textureSet).forEach(destroy);
          stats2.cubeCount = 0;
          stats2.textureCount = 0;
        }
        if (config.profile) {
          stats2.getTotalTextureSize = function() {
            var total = 0;
            Object.keys(textureSet).forEach(function(key) {
              total += textureSet[key].stats.size;
            });
            return total;
          };
        }
        function restoreTextures() {
          for (var i = 0; i < numTexUnits; ++i) {
            var tex = textureUnits[i];
            if (tex) {
              tex.bindCount = 0;
              tex.unit = -1;
              textureUnits[i] = null;
            }
          }
          values(textureSet).forEach(function(texture) {
            texture.texture = gl2.createTexture();
            gl2.bindTexture(texture.target, texture.texture);
            for (var i2 = 0; i2 < 32; ++i2) {
              if ((texture.mipmask & 1 << i2) === 0) {
                continue;
              }
              if (texture.target === GL_TEXTURE_2D$1) {
                gl2.texImage2D(
                  GL_TEXTURE_2D$1,
                  i2,
                  texture.internalformat,
                  texture.width >> i2,
                  texture.height >> i2,
                  0,
                  texture.internalformat,
                  texture.type,
                  null
                );
              } else {
                for (var j = 0; j < 6; ++j) {
                  gl2.texImage2D(
                    GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j,
                    i2,
                    texture.internalformat,
                    texture.width >> i2,
                    texture.height >> i2,
                    0,
                    texture.internalformat,
                    texture.type,
                    null
                  );
                }
              }
            }
            setTexInfo(texture.texInfo, texture.target);
          });
        }
        return {
          create2D: createTexture2D,
          createCube: createTextureCube,
          clear: destroyTextures,
          getTexture: function(wrapper) {
            return null;
          },
          restore: restoreTextures
        };
      }
      var GL_RENDERBUFFER = 36161;
      var GL_RGBA4$1 = 32854;
      var GL_RGB5_A1$1 = 32855;
      var GL_RGB565$1 = 36194;
      var GL_DEPTH_COMPONENT16 = 33189;
      var GL_STENCIL_INDEX8 = 36168;
      var GL_DEPTH_STENCIL$1 = 34041;
      var GL_SRGB8_ALPHA8_EXT = 35907;
      var GL_RGBA32F_EXT = 34836;
      var GL_RGBA16F_EXT = 34842;
      var GL_RGB16F_EXT = 34843;
      var FORMAT_SIZES = [];
      FORMAT_SIZES[GL_RGBA4$1] = 2;
      FORMAT_SIZES[GL_RGB5_A1$1] = 2;
      FORMAT_SIZES[GL_RGB565$1] = 2;
      FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2;
      FORMAT_SIZES[GL_STENCIL_INDEX8] = 1;
      FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4;
      FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4;
      FORMAT_SIZES[GL_RGBA32F_EXT] = 16;
      FORMAT_SIZES[GL_RGBA16F_EXT] = 8;
      FORMAT_SIZES[GL_RGB16F_EXT] = 6;
      function getRenderbufferSize(format2, width, height) {
        return FORMAT_SIZES[format2] * width * height;
      }
      var wrapRenderbuffers = function(gl2, extensions, limits, stats2, config) {
        var formatTypes = {
          "rgba4": GL_RGBA4$1,
          "rgb565": GL_RGB565$1,
          "rgb5 a1": GL_RGB5_A1$1,
          "depth": GL_DEPTH_COMPONENT16,
          "stencil": GL_STENCIL_INDEX8,
          "depth stencil": GL_DEPTH_STENCIL$1
        };
        if (extensions.ext_srgb) {
          formatTypes["srgba"] = GL_SRGB8_ALPHA8_EXT;
        }
        if (extensions.ext_color_buffer_half_float) {
          formatTypes["rgba16f"] = GL_RGBA16F_EXT;
          formatTypes["rgb16f"] = GL_RGB16F_EXT;
        }
        if (extensions.webgl_color_buffer_float) {
          formatTypes["rgba32f"] = GL_RGBA32F_EXT;
        }
        var formatTypesInvert = [];
        Object.keys(formatTypes).forEach(function(key) {
          var val = formatTypes[key];
          formatTypesInvert[val] = key;
        });
        var renderbufferCount = 0;
        var renderbufferSet = {};
        function REGLRenderbuffer(renderbuffer) {
          this.id = renderbufferCount++;
          this.refCount = 1;
          this.renderbuffer = renderbuffer;
          this.format = GL_RGBA4$1;
          this.width = 0;
          this.height = 0;
          if (config.profile) {
            this.stats = { size: 0 };
          }
        }
        REGLRenderbuffer.prototype.decRef = function() {
          if (--this.refCount <= 0) {
            destroy(this);
          }
        };
        function destroy(rb) {
          var handle = rb.renderbuffer;
          check$1(handle, "must not double destroy renderbuffer");
          gl2.bindRenderbuffer(GL_RENDERBUFFER, null);
          gl2.deleteRenderbuffer(handle);
          rb.renderbuffer = null;
          rb.refCount = 0;
          delete renderbufferSet[rb.id];
          stats2.renderbufferCount--;
        }
        function createRenderbuffer(a, b) {
          var renderbuffer = new REGLRenderbuffer(gl2.createRenderbuffer());
          renderbufferSet[renderbuffer.id] = renderbuffer;
          stats2.renderbufferCount++;
          function reglRenderbuffer(a2, b2) {
            var w = 0;
            var h = 0;
            var format2 = GL_RGBA4$1;
            if (typeof a2 === "object" && a2) {
              var options = a2;
              if ("shape" in options) {
                var shape = options.shape;
                check$1(
                  Array.isArray(shape) && shape.length >= 2,
                  "invalid renderbuffer shape"
                );
                w = shape[0] | 0;
                h = shape[1] | 0;
              } else {
                if ("radius" in options) {
                  w = h = options.radius | 0;
                }
                if ("width" in options) {
                  w = options.width | 0;
                }
                if ("height" in options) {
                  h = options.height | 0;
                }
              }
              if ("format" in options) {
                check$1.parameter(
                  options.format,
                  formatTypes,
                  "invalid renderbuffer format"
                );
                format2 = formatTypes[options.format];
              }
            } else if (typeof a2 === "number") {
              w = a2 | 0;
              if (typeof b2 === "number") {
                h = b2 | 0;
              } else {
                h = w;
              }
            } else if (!a2) {
              w = h = 1;
            } else {
              check$1.raise("invalid arguments to renderbuffer constructor");
            }
            check$1(
              w > 0 && h > 0 && w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
              "invalid renderbuffer size"
            );
            if (w === renderbuffer.width && h === renderbuffer.height && format2 === renderbuffer.format) {
              return;
            }
            reglRenderbuffer.width = renderbuffer.width = w;
            reglRenderbuffer.height = renderbuffer.height = h;
            renderbuffer.format = format2;
            gl2.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
            gl2.renderbufferStorage(GL_RENDERBUFFER, format2, w, h);
            check$1(
              gl2.getError() === 0,
              "invalid render buffer format"
            );
            if (config.profile) {
              renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);
            }
            reglRenderbuffer.format = formatTypesInvert[renderbuffer.format];
            return reglRenderbuffer;
          }
          function resize(w_, h_) {
            var w = w_ | 0;
            var h = h_ | 0 || w;
            if (w === renderbuffer.width && h === renderbuffer.height) {
              return reglRenderbuffer;
            }
            check$1(
              w > 0 && h > 0 && w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
              "invalid renderbuffer size"
            );
            reglRenderbuffer.width = renderbuffer.width = w;
            reglRenderbuffer.height = renderbuffer.height = h;
            gl2.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
            gl2.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h);
            check$1(
              gl2.getError() === 0,
              "invalid render buffer format"
            );
            if (config.profile) {
              renderbuffer.stats.size = getRenderbufferSize(
                renderbuffer.format,
                renderbuffer.width,
                renderbuffer.height
              );
            }
            return reglRenderbuffer;
          }
          reglRenderbuffer(a, b);
          reglRenderbuffer.resize = resize;
          reglRenderbuffer._reglType = "renderbuffer";
          reglRenderbuffer._renderbuffer = renderbuffer;
          if (config.profile) {
            reglRenderbuffer.stats = renderbuffer.stats;
          }
          reglRenderbuffer.destroy = function() {
            renderbuffer.decRef();
          };
          return reglRenderbuffer;
        }
        if (config.profile) {
          stats2.getTotalRenderbufferSize = function() {
            var total = 0;
            Object.keys(renderbufferSet).forEach(function(key) {
              total += renderbufferSet[key].stats.size;
            });
            return total;
          };
        }
        function restoreRenderbuffers() {
          values(renderbufferSet).forEach(function(rb) {
            rb.renderbuffer = gl2.createRenderbuffer();
            gl2.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer);
            gl2.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height);
          });
          gl2.bindRenderbuffer(GL_RENDERBUFFER, null);
        }
        return {
          create: createRenderbuffer,
          clear: function() {
            values(renderbufferSet).forEach(destroy);
          },
          restore: restoreRenderbuffers
        };
      };
      var GL_FRAMEBUFFER$1 = 36160;
      var GL_RENDERBUFFER$1 = 36161;
      var GL_TEXTURE_2D$2 = 3553;
      var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 34069;
      var GL_COLOR_ATTACHMENT0$1 = 36064;
      var GL_DEPTH_ATTACHMENT = 36096;
      var GL_STENCIL_ATTACHMENT = 36128;
      var GL_DEPTH_STENCIL_ATTACHMENT = 33306;
      var GL_FRAMEBUFFER_COMPLETE$1 = 36053;
      var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054;
      var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055;
      var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057;
      var GL_FRAMEBUFFER_UNSUPPORTED = 36061;
      var GL_HALF_FLOAT_OES$2 = 36193;
      var GL_UNSIGNED_BYTE$6 = 5121;
      var GL_FLOAT$5 = 5126;
      var GL_RGB$1 = 6407;
      var GL_RGBA$2 = 6408;
      var GL_DEPTH_COMPONENT$1 = 6402;
      var colorTextureFormatEnums = [
        GL_RGB$1,
        GL_RGBA$2
      ];
      var textureFormatChannels = [];
      textureFormatChannels[GL_RGBA$2] = 4;
      textureFormatChannels[GL_RGB$1] = 3;
      var textureTypeSizes = [];
      textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1;
      textureTypeSizes[GL_FLOAT$5] = 4;
      textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2;
      var GL_RGBA4$2 = 32854;
      var GL_RGB5_A1$2 = 32855;
      var GL_RGB565$2 = 36194;
      var GL_DEPTH_COMPONENT16$1 = 33189;
      var GL_STENCIL_INDEX8$1 = 36168;
      var GL_DEPTH_STENCIL$2 = 34041;
      var GL_SRGB8_ALPHA8_EXT$1 = 35907;
      var GL_RGBA32F_EXT$1 = 34836;
      var GL_RGBA16F_EXT$1 = 34842;
      var GL_RGB16F_EXT$1 = 34843;
      var colorRenderbufferFormatEnums = [
        GL_RGBA4$2,
        GL_RGB5_A1$2,
        GL_RGB565$2,
        GL_SRGB8_ALPHA8_EXT$1,
        GL_RGBA16F_EXT$1,
        GL_RGB16F_EXT$1,
        GL_RGBA32F_EXT$1
      ];
      var statusCode = {};
      statusCode[GL_FRAMEBUFFER_COMPLETE$1] = "complete";
      statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = "incomplete attachment";
      statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = "incomplete dimensions";
      statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = "incomplete, missing attachment";
      statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = "unsupported";
      function wrapFBOState(gl2, extensions, limits, textureState, renderbufferState, stats2) {
        var framebufferState = {
          cur: null,
          next: null,
          dirty: false,
          setFBO: null
        };
        var colorTextureFormats = ["rgba"];
        var colorRenderbufferFormats = ["rgba4", "rgb565", "rgb5 a1"];
        if (extensions.ext_srgb) {
          colorRenderbufferFormats.push("srgba");
        }
        if (extensions.ext_color_buffer_half_float) {
          colorRenderbufferFormats.push("rgba16f", "rgb16f");
        }
        if (extensions.webgl_color_buffer_float) {
          colorRenderbufferFormats.push("rgba32f");
        }
        var colorTypes = ["uint8"];
        if (extensions.oes_texture_half_float) {
          colorTypes.push("half float", "float16");
        }
        if (extensions.oes_texture_float) {
          colorTypes.push("float", "float32");
        }
        function FramebufferAttachment(target, texture, renderbuffer) {
          this.target = target;
          this.texture = texture;
          this.renderbuffer = renderbuffer;
          var w = 0;
          var h = 0;
          if (texture) {
            w = texture.width;
            h = texture.height;
          } else if (renderbuffer) {
            w = renderbuffer.width;
            h = renderbuffer.height;
          }
          this.width = w;
          this.height = h;
        }
        function decRef(attachment) {
          if (attachment) {
            if (attachment.texture) {
              attachment.texture._texture.decRef();
            }
            if (attachment.renderbuffer) {
              attachment.renderbuffer._renderbuffer.decRef();
            }
          }
        }
        function incRefAndCheckShape(attachment, width, height) {
          if (!attachment) {
            return;
          }
          if (attachment.texture) {
            var texture = attachment.texture._texture;
            var tw = Math.max(1, texture.width);
            var th = Math.max(1, texture.height);
            check$1(
              tw === width && th === height,
              "inconsistent width/height for supplied texture"
            );
            texture.refCount += 1;
          } else {
            var renderbuffer = attachment.renderbuffer._renderbuffer;
            check$1(
              renderbuffer.width === width && renderbuffer.height === height,
              "inconsistent width/height for renderbuffer"
            );
            renderbuffer.refCount += 1;
          }
        }
        function attach(location, attachment) {
          if (attachment) {
            if (attachment.texture) {
              gl2.framebufferTexture2D(
                GL_FRAMEBUFFER$1,
                location,
                attachment.target,
                attachment.texture._texture.texture,
                0
              );
            } else {
              gl2.framebufferRenderbuffer(
                GL_FRAMEBUFFER$1,
                location,
                GL_RENDERBUFFER$1,
                attachment.renderbuffer._renderbuffer.renderbuffer
              );
            }
          }
        }
        function parseAttachment(attachment) {
          var target = GL_TEXTURE_2D$2;
          var texture = null;
          var renderbuffer = null;
          var data = attachment;
          if (typeof attachment === "object") {
            data = attachment.data;
            if ("target" in attachment) {
              target = attachment.target | 0;
            }
          }
          check$1.type(data, "function", "invalid attachment data");
          var type = data._reglType;
          if (type === "texture2d") {
            texture = data;
            check$1(target === GL_TEXTURE_2D$2);
          } else if (type === "textureCube") {
            texture = data;
            check$1(
              target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 && target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6,
              "invalid cube map target"
            );
          } else if (type === "renderbuffer") {
            renderbuffer = data;
            target = GL_RENDERBUFFER$1;
          } else {
            check$1.raise("invalid regl object for attachment");
          }
          return new FramebufferAttachment(target, texture, renderbuffer);
        }
        function allocAttachment(width, height, isTexture, format2, type) {
          if (isTexture) {
            var texture = textureState.create2D({
              width,
              height,
              format: format2,
              type
            });
            texture._texture.refCount = 0;
            return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null);
          } else {
            var rb = renderbufferState.create({
              width,
              height,
              format: format2
            });
            rb._renderbuffer.refCount = 0;
            return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb);
          }
        }
        function unwrapAttachment(attachment) {
          return attachment && (attachment.texture || attachment.renderbuffer);
        }
        function resizeAttachment(attachment, w, h) {
          if (attachment) {
            if (attachment.texture) {
              attachment.texture.resize(w, h);
            } else if (attachment.renderbuffer) {
              attachment.renderbuffer.resize(w, h);
            }
            attachment.width = w;
            attachment.height = h;
          }
        }
        var framebufferCount = 0;
        var framebufferSet = {};
        function REGLFramebuffer() {
          this.id = framebufferCount++;
          framebufferSet[this.id] = this;
          this.framebuffer = gl2.createFramebuffer();
          this.width = 0;
          this.height = 0;
          this.colorAttachments = [];
          this.depthAttachment = null;
          this.stencilAttachment = null;
          this.depthStencilAttachment = null;
        }
        function decFBORefs(framebuffer) {
          framebuffer.colorAttachments.forEach(decRef);
          decRef(framebuffer.depthAttachment);
          decRef(framebuffer.stencilAttachment);
          decRef(framebuffer.depthStencilAttachment);
        }
        function destroy(framebuffer) {
          var handle = framebuffer.framebuffer;
          check$1(handle, "must not double destroy framebuffer");
          gl2.deleteFramebuffer(handle);
          framebuffer.framebuffer = null;
          stats2.framebufferCount--;
          delete framebufferSet[framebuffer.id];
        }
        function updateFramebuffer(framebuffer) {
          var i;
          gl2.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer);
          var colorAttachments = framebuffer.colorAttachments;
          for (i = 0; i < colorAttachments.length; ++i) {
            attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i]);
          }
          for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
            gl2.framebufferTexture2D(
              GL_FRAMEBUFFER$1,
              GL_COLOR_ATTACHMENT0$1 + i,
              GL_TEXTURE_2D$2,
              null,
              0
            );
          }
          gl2.framebufferTexture2D(
            GL_FRAMEBUFFER$1,
            GL_DEPTH_STENCIL_ATTACHMENT,
            GL_TEXTURE_2D$2,
            null,
            0
          );
          gl2.framebufferTexture2D(
            GL_FRAMEBUFFER$1,
            GL_DEPTH_ATTACHMENT,
            GL_TEXTURE_2D$2,
            null,
            0
          );
          gl2.framebufferTexture2D(
            GL_FRAMEBUFFER$1,
            GL_STENCIL_ATTACHMENT,
            GL_TEXTURE_2D$2,
            null,
            0
          );
          attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment);
          attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment);
          attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment);
          var status = gl2.checkFramebufferStatus(GL_FRAMEBUFFER$1);
          if (!gl2.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
            check$1.raise("framebuffer configuration not supported, status = " + statusCode[status]);
          }
          gl2.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null);
          framebufferState.cur = framebufferState.next;
          gl2.getError();
        }
        function createFBO(a0, a1) {
          var framebuffer = new REGLFramebuffer();
          stats2.framebufferCount++;
          function reglFramebuffer(a, b) {
            var i;
            check$1(
              framebufferState.next !== framebuffer,
              "can not update framebuffer which is currently in use"
            );
            var width = 0;
            var height = 0;
            var needsDepth = true;
            var needsStencil = true;
            var colorBuffer = null;
            var colorTexture = true;
            var colorFormat = "rgba";
            var colorType = "uint8";
            var colorCount = 1;
            var depthBuffer = null;
            var stencilBuffer = null;
            var depthStencilBuffer = null;
            var depthStencilTexture = false;
            if (typeof a === "number") {
              width = a | 0;
              height = b | 0 || width;
            } else if (!a) {
              width = height = 1;
            } else {
              check$1.type(a, "object", "invalid arguments for framebuffer");
              var options = a;
              if ("shape" in options) {
                var shape = options.shape;
                check$1(
                  Array.isArray(shape) && shape.length >= 2,
                  "invalid shape for framebuffer"
                );
                width = shape[0];
                height = shape[1];
              } else {
                if ("radius" in options) {
                  width = height = options.radius;
                }
                if ("width" in options) {
                  width = options.width;
                }
                if ("height" in options) {
                  height = options.height;
                }
              }
              if ("color" in options || "colors" in options) {
                colorBuffer = options.color || options.colors;
                if (Array.isArray(colorBuffer)) {
                  check$1(
                    colorBuffer.length === 1 || extensions.webgl_draw_buffers,
                    "multiple render targets not supported"
                  );
                }
              }
              if (!colorBuffer) {
                if ("colorCount" in options) {
                  colorCount = options.colorCount | 0;
                  check$1(colorCount > 0, "invalid color buffer count");
                }
                if ("colorTexture" in options) {
                  colorTexture = !!options.colorTexture;
                  colorFormat = "rgba4";
                }
                if ("colorType" in options) {
                  colorType = options.colorType;
                  if (!colorTexture) {
                    if (colorType === "half float" || colorType === "float16") {
                      check$1(
                        extensions.ext_color_buffer_half_float,
                        "you must enable EXT_color_buffer_half_float to use 16-bit render buffers"
                      );
                      colorFormat = "rgba16f";
                    } else if (colorType === "float" || colorType === "float32") {
                      check$1(
                        extensions.webgl_color_buffer_float,
                        "you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers"
                      );
                      colorFormat = "rgba32f";
                    }
                  } else {
                    check$1(
                      extensions.oes_texture_float || !(colorType === "float" || colorType === "float32"),
                      "you must enable OES_texture_float in order to use floating point framebuffer objects"
                    );
                    check$1(
                      extensions.oes_texture_half_float || !(colorType === "half float" || colorType === "float16"),
                      "you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects"
                    );
                  }
                  check$1.oneOf(colorType, colorTypes, "invalid color type");
                }
                if ("colorFormat" in options) {
                  colorFormat = options.colorFormat;
                  if (colorTextureFormats.indexOf(colorFormat) >= 0) {
                    colorTexture = true;
                  } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
                    colorTexture = false;
                  } else {
                    if (colorTexture) {
                      check$1.oneOf(
                        options.colorFormat,
                        colorTextureFormats,
                        "invalid color format for texture"
                      );
                    } else {
                      check$1.oneOf(
                        options.colorFormat,
                        colorRenderbufferFormats,
                        "invalid color format for renderbuffer"
                      );
                    }
                  }
                }
              }
              if ("depthTexture" in options || "depthStencilTexture" in options) {
                depthStencilTexture = !!(options.depthTexture || options.depthStencilTexture);
                check$1(
                  !depthStencilTexture || extensions.webgl_depth_texture,
                  "webgl_depth_texture extension not supported"
                );
              }
              if ("depth" in options) {
                if (typeof options.depth === "boolean") {
                  needsDepth = options.depth;
                } else {
                  depthBuffer = options.depth;
                  needsStencil = false;
                }
              }
              if ("stencil" in options) {
                if (typeof options.stencil === "boolean") {
                  needsStencil = options.stencil;
                } else {
                  stencilBuffer = options.stencil;
                  needsDepth = false;
                }
              }
              if ("depthStencil" in options) {
                if (typeof options.depthStencil === "boolean") {
                  needsDepth = needsStencil = options.depthStencil;
                } else {
                  depthStencilBuffer = options.depthStencil;
                  needsDepth = false;
                  needsStencil = false;
                }
              }
            }
            var colorAttachments = null;
            var depthAttachment = null;
            var stencilAttachment = null;
            var depthStencilAttachment = null;
            if (Array.isArray(colorBuffer)) {
              colorAttachments = colorBuffer.map(parseAttachment);
            } else if (colorBuffer) {
              colorAttachments = [parseAttachment(colorBuffer)];
            } else {
              colorAttachments = new Array(colorCount);
              for (i = 0; i < colorCount; ++i) {
                colorAttachments[i] = allocAttachment(
                  width,
                  height,
                  colorTexture,
                  colorFormat,
                  colorType
                );
              }
            }
            check$1(
              extensions.webgl_draw_buffers || colorAttachments.length <= 1,
              "you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers."
            );
            check$1(
              colorAttachments.length <= limits.maxColorAttachments,
              "too many color attachments, not supported"
            );
            width = width || colorAttachments[0].width;
            height = height || colorAttachments[0].height;
            if (depthBuffer) {
              depthAttachment = parseAttachment(depthBuffer);
            } else if (needsDepth && !needsStencil) {
              depthAttachment = allocAttachment(
                width,
                height,
                depthStencilTexture,
                "depth",
                "uint32"
              );
            }
            if (stencilBuffer) {
              stencilAttachment = parseAttachment(stencilBuffer);
            } else if (needsStencil && !needsDepth) {
              stencilAttachment = allocAttachment(
                width,
                height,
                false,
                "stencil",
                "uint8"
              );
            }
            if (depthStencilBuffer) {
              depthStencilAttachment = parseAttachment(depthStencilBuffer);
            } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
              depthStencilAttachment = allocAttachment(
                width,
                height,
                depthStencilTexture,
                "depth stencil",
                "depth stencil"
              );
            }
            check$1(
              !!depthBuffer + !!stencilBuffer + !!depthStencilBuffer <= 1,
              "invalid framebuffer configuration, can specify exactly one depth/stencil attachment"
            );
            var commonColorAttachmentSize = null;
            for (i = 0; i < colorAttachments.length; ++i) {
              incRefAndCheckShape(colorAttachments[i], width, height);
              check$1(
                !colorAttachments[i] || colorAttachments[i].texture && colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0 || colorAttachments[i].renderbuffer && colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0,
                "framebuffer color attachment " + i + " is invalid"
              );
              if (colorAttachments[i] && colorAttachments[i].texture) {
                var colorAttachmentSize = textureFormatChannels[colorAttachments[i].texture._texture.format] * textureTypeSizes[colorAttachments[i].texture._texture.type];
                if (commonColorAttachmentSize === null) {
                  commonColorAttachmentSize = colorAttachmentSize;
                } else {
                  check$1(
                    commonColorAttachmentSize === colorAttachmentSize,
                    "all color attachments much have the same number of bits per pixel."
                  );
                }
              }
            }
            incRefAndCheckShape(depthAttachment, width, height);
            check$1(
              !depthAttachment || depthAttachment.texture && depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1 || depthAttachment.renderbuffer && depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1,
              "invalid depth attachment for framebuffer object"
            );
            incRefAndCheckShape(stencilAttachment, width, height);
            check$1(
              !stencilAttachment || stencilAttachment.renderbuffer && stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1,
              "invalid stencil attachment for framebuffer object"
            );
            incRefAndCheckShape(depthStencilAttachment, width, height);
            check$1(
              !depthStencilAttachment || depthStencilAttachment.texture && depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2 || depthStencilAttachment.renderbuffer && depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2,
              "invalid depth-stencil attachment for framebuffer object"
            );
            decFBORefs(framebuffer);
            framebuffer.width = width;
            framebuffer.height = height;
            framebuffer.colorAttachments = colorAttachments;
            framebuffer.depthAttachment = depthAttachment;
            framebuffer.stencilAttachment = stencilAttachment;
            framebuffer.depthStencilAttachment = depthStencilAttachment;
            reglFramebuffer.color = colorAttachments.map(unwrapAttachment);
            reglFramebuffer.depth = unwrapAttachment(depthAttachment);
            reglFramebuffer.stencil = unwrapAttachment(stencilAttachment);
            reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment);
            reglFramebuffer.width = framebuffer.width;
            reglFramebuffer.height = framebuffer.height;
            updateFramebuffer(framebuffer);
            return reglFramebuffer;
          }
          function resize(w_, h_) {
            check$1(
              framebufferState.next !== framebuffer,
              "can not resize a framebuffer which is currently in use"
            );
            var w = Math.max(w_ | 0, 1);
            var h = Math.max(h_ | 0 || w, 1);
            if (w === framebuffer.width && h === framebuffer.height) {
              return reglFramebuffer;
            }
            var colorAttachments = framebuffer.colorAttachments;
            for (var i = 0; i < colorAttachments.length; ++i) {
              resizeAttachment(colorAttachments[i], w, h);
            }
            resizeAttachment(framebuffer.depthAttachment, w, h);
            resizeAttachment(framebuffer.stencilAttachment, w, h);
            resizeAttachment(framebuffer.depthStencilAttachment, w, h);
            framebuffer.width = reglFramebuffer.width = w;
            framebuffer.height = reglFramebuffer.height = h;
            updateFramebuffer(framebuffer);
            return reglFramebuffer;
          }
          reglFramebuffer(a0, a1);
          return extend2(reglFramebuffer, {
            resize,
            _reglType: "framebuffer",
            _framebuffer: framebuffer,
            destroy: function() {
              destroy(framebuffer);
              decFBORefs(framebuffer);
            },
            use: function(block) {
              framebufferState.setFBO({
                framebuffer: reglFramebuffer
              }, block);
            }
          });
        }
        function createCubeFBO(options) {
          var faces = Array(6);
          function reglFramebufferCube(a) {
            var i;
            check$1(
              faces.indexOf(framebufferState.next) < 0,
              "can not update framebuffer which is currently in use"
            );
            var params = {
              color: null
            };
            var radius = 0;
            var colorBuffer = null;
            var colorFormat = "rgba";
            var colorType = "uint8";
            var colorCount = 1;
            if (typeof a === "number") {
              radius = a | 0;
            } else if (!a) {
              radius = 1;
            } else {
              check$1.type(a, "object", "invalid arguments for framebuffer");
              var options2 = a;
              if ("shape" in options2) {
                var shape = options2.shape;
                check$1(
                  Array.isArray(shape) && shape.length >= 2,
                  "invalid shape for framebuffer"
                );
                check$1(
                  shape[0] === shape[1],
                  "cube framebuffer must be square"
                );
                radius = shape[0];
              } else {
                if ("radius" in options2) {
                  radius = options2.radius | 0;
                }
                if ("width" in options2) {
                  radius = options2.width | 0;
                  if ("height" in options2) {
                    check$1(options2.height === radius, "must be square");
                  }
                } else if ("height" in options2) {
                  radius = options2.height | 0;
                }
              }
              if ("color" in options2 || "colors" in options2) {
                colorBuffer = options2.color || options2.colors;
                if (Array.isArray(colorBuffer)) {
                  check$1(
                    colorBuffer.length === 1 || extensions.webgl_draw_buffers,
                    "multiple render targets not supported"
                  );
                }
              }
              if (!colorBuffer) {
                if ("colorCount" in options2) {
                  colorCount = options2.colorCount | 0;
                  check$1(colorCount > 0, "invalid color buffer count");
                }
                if ("colorType" in options2) {
                  check$1.oneOf(
                    options2.colorType,
                    colorTypes,
                    "invalid color type"
                  );
                  colorType = options2.colorType;
                }
                if ("colorFormat" in options2) {
                  colorFormat = options2.colorFormat;
                  check$1.oneOf(
                    options2.colorFormat,
                    colorTextureFormats,
                    "invalid color format for texture"
                  );
                }
              }
              if ("depth" in options2) {
                params.depth = options2.depth;
              }
              if ("stencil" in options2) {
                params.stencil = options2.stencil;
              }
              if ("depthStencil" in options2) {
                params.depthStencil = options2.depthStencil;
              }
            }
            var colorCubes;
            if (colorBuffer) {
              if (Array.isArray(colorBuffer)) {
                colorCubes = [];
                for (i = 0; i < colorBuffer.length; ++i) {
                  colorCubes[i] = colorBuffer[i];
                }
              } else {
                colorCubes = [colorBuffer];
              }
            } else {
              colorCubes = Array(colorCount);
              var cubeMapParams = {
                radius,
                format: colorFormat,
                type: colorType
              };
              for (i = 0; i < colorCount; ++i) {
                colorCubes[i] = textureState.createCube(cubeMapParams);
              }
            }
            params.color = Array(colorCubes.length);
            for (i = 0; i < colorCubes.length; ++i) {
              var cube = colorCubes[i];
              check$1(
                typeof cube === "function" && cube._reglType === "textureCube",
                "invalid cube map"
              );
              radius = radius || cube.width;
              check$1(
                cube.width === radius && cube.height === radius,
                "invalid cube map shape"
              );
              params.color[i] = {
                target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
                data: colorCubes[i]
              };
            }
            for (i = 0; i < 6; ++i) {
              for (var j = 0; j < colorCubes.length; ++j) {
                params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i;
              }
              if (i > 0) {
                params.depth = faces[0].depth;
                params.stencil = faces[0].stencil;
                params.depthStencil = faces[0].depthStencil;
              }
              if (faces[i]) {
                faces[i](params);
              } else {
                faces[i] = createFBO(params);
              }
            }
            return extend2(reglFramebufferCube, {
              width: radius,
              height: radius,
              color: colorCubes
            });
          }
          function resize(radius_) {
            var i;
            var radius = radius_ | 0;
            check$1(
              radius > 0 && radius <= limits.maxCubeMapSize,
              "invalid radius for cube fbo"
            );
            if (radius === reglFramebufferCube.width) {
              return reglFramebufferCube;
            }
            var colors = reglFramebufferCube.color;
            for (i = 0; i < colors.length; ++i) {
              colors[i].resize(radius);
            }
            for (i = 0; i < 6; ++i) {
              faces[i].resize(radius);
            }
            reglFramebufferCube.width = reglFramebufferCube.height = radius;
            return reglFramebufferCube;
          }
          reglFramebufferCube(options);
          return extend2(reglFramebufferCube, {
            faces,
            resize,
            _reglType: "framebufferCube",
            destroy: function() {
              faces.forEach(function(f) {
                f.destroy();
              });
            }
          });
        }
        function restoreFramebuffers() {
          framebufferState.cur = null;
          framebufferState.next = null;
          framebufferState.dirty = true;
          values(framebufferSet).forEach(function(fb) {
            fb.framebuffer = gl2.createFramebuffer();
            updateFramebuffer(fb);
          });
        }
        return extend2(framebufferState, {
          getFramebuffer: function(object) {
            if (typeof object === "function" && object._reglType === "framebuffer") {
              var fbo = object._framebuffer;
              if (fbo instanceof REGLFramebuffer) {
                return fbo;
              }
            }
            return null;
          },
          create: createFBO,
          createCube: createCubeFBO,
          clear: function() {
            values(framebufferSet).forEach(destroy);
          },
          restore: restoreFramebuffers
        });
      }
      var GL_FLOAT$6 = 5126;
      var GL_ARRAY_BUFFER$1 = 34962;
      function AttributeRecord() {
        this.state = 0;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
        this.buffer = null;
        this.size = 0;
        this.normalized = false;
        this.type = GL_FLOAT$6;
        this.offset = 0;
        this.stride = 0;
        this.divisor = 0;
      }
      function wrapAttributeState(gl2, extensions, limits, stats2, bufferState) {
        var NUM_ATTRIBUTES = limits.maxAttributes;
        var attributeBindings = new Array(NUM_ATTRIBUTES);
        for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
          attributeBindings[i] = new AttributeRecord();
        }
        var vaoCount = 0;
        var vaoSet = {};
        var state = {
          Record: AttributeRecord,
          scope: {},
          state: attributeBindings,
          currentVAO: null,
          targetVAO: null,
          restore: extVAO() ? restoreVAO : function() {
          },
          createVAO,
          getVAO,
          destroyBuffer,
          setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
          clear: extVAO() ? destroyVAOEXT : function() {
          }
        };
        function destroyBuffer(buffer) {
          for (var i2 = 0; i2 < attributeBindings.length; ++i2) {
            var record = attributeBindings[i2];
            if (record.buffer === buffer) {
              gl2.disableVertexAttribArray(i2);
              record.buffer = null;
            }
          }
        }
        function extVAO() {
          return extensions.oes_vertex_array_object;
        }
        function extInstanced() {
          return extensions.angle_instanced_arrays;
        }
        function getVAO(vao) {
          if (typeof vao === "function" && vao._vao) {
            return vao._vao;
          }
          return null;
        }
        function setVAOEXT(vao) {
          if (vao === state.currentVAO) {
            return;
          }
          var ext = extVAO();
          if (vao) {
            ext.bindVertexArrayOES(vao.vao);
          } else {
            ext.bindVertexArrayOES(null);
          }
          state.currentVAO = vao;
        }
        function setVAOEmulated(vao) {
          if (vao === state.currentVAO) {
            return;
          }
          if (vao) {
            vao.bindAttrs();
          } else {
            var exti = extInstanced();
            for (var i2 = 0; i2 < attributeBindings.length; ++i2) {
              var binding = attributeBindings[i2];
              if (binding.buffer) {
                gl2.enableVertexAttribArray(i2);
                gl2.vertexAttribPointer(i2, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset);
                if (exti) {
                  exti.vertexAttribDivisorANGLE(i2, binding.divisor);
                }
              } else {
                gl2.disableVertexAttribArray(i2);
                gl2.vertexAttrib4f(i2, binding.x, binding.y, binding.z, binding.w);
              }
            }
          }
          state.currentVAO = vao;
        }
        function destroyVAOEXT() {
          values(vaoSet).forEach(function(vao) {
            vao.destroy();
          });
        }
        function REGLVAO() {
          this.id = ++vaoCount;
          this.attributes = [];
          var extension = extVAO();
          if (extension) {
            this.vao = extension.createVertexArrayOES();
          } else {
            this.vao = null;
          }
          vaoSet[this.id] = this;
          this.buffers = [];
        }
        REGLVAO.prototype.bindAttrs = function() {
          var exti = extInstanced();
          var attributes = this.attributes;
          for (var i2 = 0; i2 < attributes.length; ++i2) {
            var attr = attributes[i2];
            if (attr.buffer) {
              gl2.enableVertexAttribArray(i2);
              gl2.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer);
              gl2.vertexAttribPointer(i2, attr.size, attr.type, attr.normalized, attr.stride, attr.offset);
              if (exti) {
                exti.vertexAttribDivisorANGLE(i2, attr.divisor);
              }
            } else {
              gl2.disableVertexAttribArray(i2);
              gl2.vertexAttrib4f(i2, attr.x, attr.y, attr.z, attr.w);
            }
          }
          for (var j = attributes.length; j < NUM_ATTRIBUTES; ++j) {
            gl2.disableVertexAttribArray(j);
          }
        };
        REGLVAO.prototype.refresh = function() {
          var ext = extVAO();
          if (ext) {
            ext.bindVertexArrayOES(this.vao);
            this.bindAttrs();
            state.currentVAO = this;
          }
        };
        REGLVAO.prototype.destroy = function() {
          if (this.vao) {
            var extension = extVAO();
            if (this === state.currentVAO) {
              state.currentVAO = null;
              extension.bindVertexArrayOES(null);
            }
            extension.deleteVertexArrayOES(this.vao);
            this.vao = null;
          }
          if (vaoSet[this.id]) {
            delete vaoSet[this.id];
            stats2.vaoCount -= 1;
          }
        };
        function restoreVAO() {
          var ext = extVAO();
          if (ext) {
            values(vaoSet).forEach(function(vao) {
              vao.refresh();
            });
          }
        }
        function createVAO(_attr) {
          var vao = new REGLVAO();
          stats2.vaoCount += 1;
          function updateVAO(attributes) {
            check$1(Array.isArray(attributes), "arguments to vertex array constructor must be an array");
            check$1(attributes.length < NUM_ATTRIBUTES, "too many attributes");
            check$1(attributes.length > 0, "must specify at least one attribute");
            for (var j = 0; j < vao.buffers.length; ++j) {
              vao.buffers[j].destroy();
            }
            vao.buffers.length = 0;
            var nattributes = vao.attributes;
            nattributes.length = attributes.length;
            for (var i2 = 0; i2 < attributes.length; ++i2) {
              var spec = attributes[i2];
              var rec = nattributes[i2] = new AttributeRecord();
              if (Array.isArray(spec) || isTypedArray5(spec) || isNDArrayLike(spec)) {
                var buf = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true);
                rec.buffer = bufferState.getBuffer(buf);
                rec.size = rec.buffer.dimension | 0;
                rec.normalized = false;
                rec.type = rec.buffer.dtype;
                rec.offset = 0;
                rec.stride = 0;
                rec.divisor = 0;
                rec.state = 1;
                vao.buffers.push(buf);
              } else if (bufferState.getBuffer(spec)) {
                rec.buffer = bufferState.getBuffer(spec);
                rec.size = rec.buffer.dimension | 0;
                rec.normalized = false;
                rec.type = rec.buffer.dtype;
                rec.offset = 0;
                rec.stride = 0;
                rec.divisor = 0;
                rec.state = 1;
              } else if (bufferState.getBuffer(spec.buffer)) {
                rec.buffer = bufferState.getBuffer(spec.buffer);
                rec.size = (+spec.size || rec.buffer.dimension) | 0;
                rec.normalized = !!spec.normalized || false;
                if ("type" in spec) {
                  check$1.parameter(spec.type, glTypes, "invalid buffer type");
                  rec.type = glTypes[spec.type];
                } else {
                  rec.type = rec.buffer.dtype;
                }
                rec.offset = (spec.offset || 0) | 0;
                rec.stride = (spec.stride || 0) | 0;
                rec.divisor = (spec.divisor || 0) | 0;
                rec.state = 1;
                check$1(rec.size >= 1 && rec.size <= 4, "size must be between 1 and 4");
                check$1(rec.offset >= 0, "invalid offset");
                check$1(rec.stride >= 0 && rec.stride <= 255, "stride must be between 0 and 255");
                check$1(rec.divisor >= 0, "divisor must be positive");
                check$1(!rec.divisor || !!extensions.angle_instanced_arrays, "ANGLE_instanced_arrays must be enabled to use divisor");
              } else if ("x" in spec) {
                check$1(i2 > 0, "first attribute must not be a constant");
                rec.x = +spec.x || 0;
                rec.y = +spec.y || 0;
                rec.z = +spec.z || 0;
                rec.w = +spec.w || 0;
                rec.state = 2;
              } else {
                check$1(false, "invalid attribute spec for location " + i2);
              }
            }
            vao.refresh();
            return updateVAO;
          }
          updateVAO.destroy = function() {
            vao.destroy();
          };
          updateVAO._vao = vao;
          updateVAO._reglType = "vao";
          return updateVAO(_attr);
        }
        return state;
      }
      var GL_FRAGMENT_SHADER = 35632;
      var GL_VERTEX_SHADER = 35633;
      var GL_ACTIVE_UNIFORMS = 35718;
      var GL_ACTIVE_ATTRIBUTES = 35721;
      function wrapShaderState(gl2, stringStore, stats2, config) {
        var fragShaders = {};
        var vertShaders = {};
        function ActiveInfo(name, id, location, info) {
          this.name = name;
          this.id = id;
          this.location = location;
          this.info = info;
        }
        function insertActiveInfo(list, info) {
          for (var i = 0; i < list.length; ++i) {
            if (list[i].id === info.id) {
              list[i].location = info.location;
              return;
            }
          }
          list.push(info);
        }
        function getShader(type, id, command) {
          var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders;
          var shader = cache[id];
          if (!shader) {
            var source = stringStore.str(id);
            shader = gl2.createShader(type);
            gl2.shaderSource(shader, source);
            gl2.compileShader(shader);
            check$1.shaderError(gl2, shader, source, type, command);
            cache[id] = shader;
          }
          return shader;
        }
        var programCache = {};
        var programList = [];
        var PROGRAM_COUNTER = 0;
        function REGLProgram(fragId, vertId) {
          this.id = PROGRAM_COUNTER++;
          this.fragId = fragId;
          this.vertId = vertId;
          this.program = null;
          this.uniforms = [];
          this.attributes = [];
          if (config.profile) {
            this.stats = {
              uniformsCount: 0,
              attributesCount: 0
            };
          }
        }
        function linkProgram(desc, command, attributeLocations) {
          var i, info;
          var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId);
          var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId);
          var program = desc.program = gl2.createProgram();
          gl2.attachShader(program, fragShader);
          gl2.attachShader(program, vertShader);
          if (attributeLocations) {
            for (i = 0; i < attributeLocations.length; ++i) {
              var binding = attributeLocations[i];
              gl2.bindAttribLocation(program, binding[0], binding[1]);
            }
          }
          gl2.linkProgram(program);
          check$1.linkError(
            gl2,
            program,
            stringStore.str(desc.fragId),
            stringStore.str(desc.vertId),
            command
          );
          var numUniforms = gl2.getProgramParameter(program, GL_ACTIVE_UNIFORMS);
          if (config.profile) {
            desc.stats.uniformsCount = numUniforms;
          }
          var uniforms = desc.uniforms;
          for (i = 0; i < numUniforms; ++i) {
            info = gl2.getActiveUniform(program, i);
            if (info) {
              if (info.size > 1) {
                for (var j = 0; j < info.size; ++j) {
                  var name = info.name.replace("[0]", "[" + j + "]");
                  insertActiveInfo(uniforms, new ActiveInfo(
                    name,
                    stringStore.id(name),
                    gl2.getUniformLocation(program, name),
                    info
                  ));
                }
              } else {
                insertActiveInfo(uniforms, new ActiveInfo(
                  info.name,
                  stringStore.id(info.name),
                  gl2.getUniformLocation(program, info.name),
                  info
                ));
              }
            }
          }
          var numAttributes = gl2.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES);
          if (config.profile) {
            desc.stats.attributesCount = numAttributes;
          }
          var attributes = desc.attributes;
          for (i = 0; i < numAttributes; ++i) {
            info = gl2.getActiveAttrib(program, i);
            if (info) {
              insertActiveInfo(attributes, new ActiveInfo(
                info.name,
                stringStore.id(info.name),
                gl2.getAttribLocation(program, info.name),
                info
              ));
            }
          }
        }
        if (config.profile) {
          stats2.getMaxUniformsCount = function() {
            var m = 0;
            programList.forEach(function(desc) {
              if (desc.stats.uniformsCount > m) {
                m = desc.stats.uniformsCount;
              }
            });
            return m;
          };
          stats2.getMaxAttributesCount = function() {
            var m = 0;
            programList.forEach(function(desc) {
              if (desc.stats.attributesCount > m) {
                m = desc.stats.attributesCount;
              }
            });
            return m;
          };
        }
        function restoreShaders() {
          fragShaders = {};
          vertShaders = {};
          for (var i = 0; i < programList.length; ++i) {
            linkProgram(programList[i], null, programList[i].attributes.map(function(info) {
              return [info.location, info.name];
            }));
          }
        }
        return {
          clear: function() {
            var deleteShader = gl2.deleteShader.bind(gl2);
            values(fragShaders).forEach(deleteShader);
            fragShaders = {};
            values(vertShaders).forEach(deleteShader);
            vertShaders = {};
            programList.forEach(function(desc) {
              gl2.deleteProgram(desc.program);
            });
            programList.length = 0;
            programCache = {};
            stats2.shaderCount = 0;
          },
          program: function(vertId, fragId, command, attribLocations) {
            check$1.command(vertId >= 0, "missing vertex shader", command);
            check$1.command(fragId >= 0, "missing fragment shader", command);
            var cache = programCache[fragId];
            if (!cache) {
              cache = programCache[fragId] = {};
            }
            var prevProgram = cache[vertId];
            if (prevProgram && !attribLocations) {
              return prevProgram;
            }
            var program = new REGLProgram(fragId, vertId);
            stats2.shaderCount++;
            linkProgram(program, command, attribLocations);
            if (!prevProgram) {
              cache[vertId] = program;
            }
            programList.push(program);
            return program;
          },
          restore: restoreShaders,
          shader: getShader,
          frag: -1,
          vert: -1
        };
      }
      var GL_RGBA$3 = 6408;
      var GL_UNSIGNED_BYTE$7 = 5121;
      var GL_PACK_ALIGNMENT = 3333;
      var GL_FLOAT$7 = 5126;
      function wrapReadPixels(gl2, framebufferState, reglPoll, context, glAttributes, extensions, limits) {
        function readPixelsImpl(input) {
          var type;
          if (framebufferState.next === null) {
            check$1(
              glAttributes.preserveDrawingBuffer,
              'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer'
            );
            type = GL_UNSIGNED_BYTE$7;
          } else {
            check$1(
              framebufferState.next.colorAttachments[0].texture !== null,
              "You cannot read from a renderbuffer"
            );
            type = framebufferState.next.colorAttachments[0].texture._texture.type;
            if (extensions.oes_texture_float) {
              check$1(
                type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7,
                "Reading from a framebuffer is only allowed for the types 'uint8' and 'float'"
              );
              if (type === GL_FLOAT$7) {
                check$1(limits.readFloat, "Reading 'float' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float");
              }
            } else {
              check$1(
                type === GL_UNSIGNED_BYTE$7,
                "Reading from a framebuffer is only allowed for the type 'uint8'"
              );
            }
          }
          var x = 0;
          var y = 0;
          var width = context.framebufferWidth;
          var height = context.framebufferHeight;
          var data = null;
          if (isTypedArray5(input)) {
            data = input;
          } else if (input) {
            check$1.type(input, "object", "invalid arguments to regl.read()");
            x = input.x | 0;
            y = input.y | 0;
            check$1(
              x >= 0 && x < context.framebufferWidth,
              "invalid x offset for regl.read"
            );
            check$1(
              y >= 0 && y < context.framebufferHeight,
              "invalid y offset for regl.read"
            );
            width = (input.width || context.framebufferWidth - x) | 0;
            height = (input.height || context.framebufferHeight - y) | 0;
            data = input.data || null;
          }
          if (data) {
            if (type === GL_UNSIGNED_BYTE$7) {
              check$1(
                data instanceof Uint8Array,
                "buffer must be 'Uint8Array' when reading from a framebuffer of type 'uint8'"
              );
            } else if (type === GL_FLOAT$7) {
              check$1(
                data instanceof Float32Array,
                "buffer must be 'Float32Array' when reading from a framebuffer of type 'float'"
              );
            }
          }
          check$1(
            width > 0 && width + x <= context.framebufferWidth,
            "invalid width for read pixels"
          );
          check$1(
            height > 0 && height + y <= context.framebufferHeight,
            "invalid height for read pixels"
          );
          reglPoll();
          var size2 = width * height * 4;
          if (!data) {
            if (type === GL_UNSIGNED_BYTE$7) {
              data = new Uint8Array(size2);
            } else if (type === GL_FLOAT$7) {
              data = data || new Float32Array(size2);
            }
          }
          check$1.isTypedArray(data, "data buffer for regl.read() must be a typedarray");
          check$1(data.byteLength >= size2, "data buffer for regl.read() too small");
          gl2.pixelStorei(GL_PACK_ALIGNMENT, 4);
          gl2.readPixels(
            x,
            y,
            width,
            height,
            GL_RGBA$3,
            type,
            data
          );
          return data;
        }
        function readPixelsFBO(options) {
          var result;
          framebufferState.setFBO({
            framebuffer: options.framebuffer
          }, function() {
            result = readPixelsImpl(options);
          });
          return result;
        }
        function readPixels(options) {
          if (!options || !("framebuffer" in options)) {
            return readPixelsImpl(options);
          } else {
            return readPixelsFBO(options);
          }
        }
        return readPixels;
      }
      function slice4(x) {
        return Array.prototype.slice.call(x);
      }
      function join2(x) {
        return slice4(x).join("");
      }
      function createEnvironment() {
        var varCounter = 0;
        var linkedNames = [];
        var linkedValues = [];
        function link(value) {
          for (var i = 0; i < linkedValues.length; ++i) {
            if (linkedValues[i] === value) {
              return linkedNames[i];
            }
          }
          var name = "g" + varCounter++;
          linkedNames.push(name);
          linkedValues.push(value);
          return name;
        }
        function block() {
          var code = [];
          function push() {
            code.push.apply(code, slice4(arguments));
          }
          var vars = [];
          function def() {
            var name = "v" + varCounter++;
            vars.push(name);
            if (arguments.length > 0) {
              code.push(name, "=");
              code.push.apply(code, slice4(arguments));
              code.push(";");
            }
            return name;
          }
          return extend2(push, {
            def,
            toString: function() {
              return join2([
                vars.length > 0 ? "var " + vars.join(",") + ";" : "",
                join2(code)
              ]);
            }
          });
        }
        function scope() {
          var entry = block();
          var exit = block();
          var entryToString = entry.toString;
          var exitToString = exit.toString;
          function save(object, prop) {
            exit(object, prop, "=", entry.def(object, prop), ";");
          }
          return extend2(function() {
            entry.apply(entry, slice4(arguments));
          }, {
            def: entry.def,
            entry,
            exit,
            save,
            set: function(object, prop, value) {
              save(object, prop);
              entry(object, prop, "=", value, ";");
            },
            toString: function() {
              return entryToString() + exitToString();
            }
          });
        }
        function conditional() {
          var pred = join2(arguments);
          var thenBlock = scope();
          var elseBlock = scope();
          var thenToString = thenBlock.toString;
          var elseToString = elseBlock.toString;
          return extend2(thenBlock, {
            then: function() {
              thenBlock.apply(thenBlock, slice4(arguments));
              return this;
            },
            else: function() {
              elseBlock.apply(elseBlock, slice4(arguments));
              return this;
            },
            toString: function() {
              var elseClause = elseToString();
              if (elseClause) {
                elseClause = "else{" + elseClause + "}";
              }
              return join2([
                "if(",
                pred,
                "){",
                thenToString(),
                "}",
                elseClause
              ]);
            }
          });
        }
        var globalBlock = block();
        var procedures = {};
        function proc(name, count2) {
          var args = [];
          function arg() {
            var name2 = "a" + args.length;
            args.push(name2);
            return name2;
          }
          count2 = count2 || 0;
          for (var i = 0; i < count2; ++i) {
            arg();
          }
          var body = scope();
          var bodyToString = body.toString;
          var result = procedures[name] = extend2(body, {
            arg,
            toString: function() {
              return join2([
                "function(",
                args.join(),
                "){",
                bodyToString(),
                "}"
              ]);
            }
          });
          return result;
        }
        function compile() {
          var code = [
            '"use strict";',
            globalBlock,
            "return {"
          ];
          Object.keys(procedures).forEach(function(name) {
            code.push('"', name, '":', procedures[name].toString(), ",");
          });
          code.push("}");
          var src = join2(code).replace(/;/g, ";\n").replace(/}/g, "}\n").replace(/{/g, "{\n");
          var proc2 = Function.apply(null, linkedNames.concat(src));
          return proc2.apply(null, linkedValues);
        }
        return {
          global: globalBlock,
          link,
          block,
          proc,
          scope,
          cond: conditional,
          compile
        };
      }
      var CUTE_COMPONENTS = "xyzw".split("");
      var GL_UNSIGNED_BYTE$8 = 5121;
      var ATTRIB_STATE_POINTER = 1;
      var ATTRIB_STATE_CONSTANT = 2;
      var DYN_FUNC$1 = 0;
      var DYN_PROP$1 = 1;
      var DYN_CONTEXT$1 = 2;
      var DYN_STATE$1 = 3;
      var DYN_THUNK = 4;
      var S_DITHER = "dither";
      var S_BLEND_ENABLE = "blend.enable";
      var S_BLEND_COLOR = "blend.color";
      var S_BLEND_EQUATION = "blend.equation";
      var S_BLEND_FUNC = "blend.func";
      var S_DEPTH_ENABLE = "depth.enable";
      var S_DEPTH_FUNC = "depth.func";
      var S_DEPTH_RANGE = "depth.range";
      var S_DEPTH_MASK = "depth.mask";
      var S_COLOR_MASK = "colorMask";
      var S_CULL_ENABLE = "cull.enable";
      var S_CULL_FACE = "cull.face";
      var S_FRONT_FACE = "frontFace";
      var S_LINE_WIDTH = "lineWidth";
      var S_POLYGON_OFFSET_ENABLE = "polygonOffset.enable";
      var S_POLYGON_OFFSET_OFFSET = "polygonOffset.offset";
      var S_SAMPLE_ALPHA = "sample.alpha";
      var S_SAMPLE_ENABLE = "sample.enable";
      var S_SAMPLE_COVERAGE = "sample.coverage";
      var S_STENCIL_ENABLE = "stencil.enable";
      var S_STENCIL_MASK = "stencil.mask";
      var S_STENCIL_FUNC = "stencil.func";
      var S_STENCIL_OPFRONT = "stencil.opFront";
      var S_STENCIL_OPBACK = "stencil.opBack";
      var S_SCISSOR_ENABLE = "scissor.enable";
      var S_SCISSOR_BOX = "scissor.box";
      var S_VIEWPORT = "viewport";
      var S_PROFILE = "profile";
      var S_FRAMEBUFFER = "framebuffer";
      var S_VERT = "vert";
      var S_FRAG = "frag";
      var S_ELEMENTS = "elements";
      var S_PRIMITIVE = "primitive";
      var S_COUNT = "count";
      var S_OFFSET = "offset";
      var S_INSTANCES = "instances";
      var S_VAO = "vao";
      var SUFFIX_WIDTH = "Width";
      var SUFFIX_HEIGHT = "Height";
      var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH;
      var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT;
      var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH;
      var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT;
      var S_DRAWINGBUFFER = "drawingBuffer";
      var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH;
      var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT;
      var NESTED_OPTIONS = [
        S_BLEND_FUNC,
        S_BLEND_EQUATION,
        S_STENCIL_FUNC,
        S_STENCIL_OPFRONT,
        S_STENCIL_OPBACK,
        S_SAMPLE_COVERAGE,
        S_VIEWPORT,
        S_SCISSOR_BOX,
        S_POLYGON_OFFSET_OFFSET
      ];
      var GL_ARRAY_BUFFER$2 = 34962;
      var GL_ELEMENT_ARRAY_BUFFER$1 = 34963;
      var GL_FRAGMENT_SHADER$1 = 35632;
      var GL_VERTEX_SHADER$1 = 35633;
      var GL_TEXTURE_2D$3 = 3553;
      var GL_TEXTURE_CUBE_MAP$2 = 34067;
      var GL_CULL_FACE = 2884;
      var GL_BLEND = 3042;
      var GL_DITHER = 3024;
      var GL_STENCIL_TEST = 2960;
      var GL_DEPTH_TEST = 2929;
      var GL_SCISSOR_TEST = 3089;
      var GL_POLYGON_OFFSET_FILL = 32823;
      var GL_SAMPLE_ALPHA_TO_COVERAGE = 32926;
      var GL_SAMPLE_COVERAGE = 32928;
      var GL_FLOAT$8 = 5126;
      var GL_FLOAT_VEC2 = 35664;
      var GL_FLOAT_VEC3 = 35665;
      var GL_FLOAT_VEC4 = 35666;
      var GL_INT$3 = 5124;
      var GL_INT_VEC2 = 35667;
      var GL_INT_VEC3 = 35668;
      var GL_INT_VEC4 = 35669;
      var GL_BOOL = 35670;
      var GL_BOOL_VEC2 = 35671;
      var GL_BOOL_VEC3 = 35672;
      var GL_BOOL_VEC4 = 35673;
      var GL_FLOAT_MAT2 = 35674;
      var GL_FLOAT_MAT3 = 35675;
      var GL_FLOAT_MAT4 = 35676;
      var GL_SAMPLER_2D = 35678;
      var GL_SAMPLER_CUBE = 35680;
      var GL_TRIANGLES$1 = 4;
      var GL_FRONT = 1028;
      var GL_BACK = 1029;
      var GL_CW = 2304;
      var GL_CCW = 2305;
      var GL_MIN_EXT = 32775;
      var GL_MAX_EXT = 32776;
      var GL_ALWAYS = 519;
      var GL_KEEP = 7680;
      var GL_ZERO = 0;
      var GL_ONE = 1;
      var GL_FUNC_ADD = 32774;
      var GL_LESS = 513;
      var GL_FRAMEBUFFER$2 = 36160;
      var GL_COLOR_ATTACHMENT0$2 = 36064;
      var blendFuncs = {
        "0": 0,
        "1": 1,
        "zero": 0,
        "one": 1,
        "src color": 768,
        "one minus src color": 769,
        "src alpha": 770,
        "one minus src alpha": 771,
        "dst color": 774,
        "one minus dst color": 775,
        "dst alpha": 772,
        "one minus dst alpha": 773,
        "constant color": 32769,
        "one minus constant color": 32770,
        "constant alpha": 32771,
        "one minus constant alpha": 32772,
        "src alpha saturate": 776
      };
      var invalidBlendCombinations = [
        "constant color, constant alpha",
        "one minus constant color, constant alpha",
        "constant color, one minus constant alpha",
        "one minus constant color, one minus constant alpha",
        "constant alpha, constant color",
        "constant alpha, one minus constant color",
        "one minus constant alpha, constant color",
        "one minus constant alpha, one minus constant color"
      ];
      var compareFuncs = {
        "never": 512,
        "less": 513,
        "<": 513,
        "equal": 514,
        "=": 514,
        "==": 514,
        "===": 514,
        "lequal": 515,
        "<=": 515,
        "greater": 516,
        ">": 516,
        "notequal": 517,
        "!=": 517,
        "!==": 517,
        "gequal": 518,
        ">=": 518,
        "always": 519
      };
      var stencilOps = {
        "0": 0,
        "zero": 0,
        "keep": 7680,
        "replace": 7681,
        "increment": 7682,
        "decrement": 7683,
        "increment wrap": 34055,
        "decrement wrap": 34056,
        "invert": 5386
      };
      var shaderType = {
        "frag": GL_FRAGMENT_SHADER$1,
        "vert": GL_VERTEX_SHADER$1
      };
      var orientationType = {
        "cw": GL_CW,
        "ccw": GL_CCW
      };
      function isBufferArgs(x) {
        return Array.isArray(x) || isTypedArray5(x) || isNDArrayLike(x);
      }
      function sortState(state) {
        return state.sort(function(a, b) {
          if (a === S_VIEWPORT) {
            return -1;
          } else if (b === S_VIEWPORT) {
            return 1;
          }
          return a < b ? -1 : 1;
        });
      }
      function Declaration(thisDep, contextDep, propDep, append) {
        this.thisDep = thisDep;
        this.contextDep = contextDep;
        this.propDep = propDep;
        this.append = append;
      }
      function isStatic(decl) {
        return decl && !(decl.thisDep || decl.contextDep || decl.propDep);
      }
      function createStaticDecl(append) {
        return new Declaration(false, false, false, append);
      }
      function createDynamicDecl(dyn, append) {
        var type = dyn.type;
        if (type === DYN_FUNC$1) {
          var numArgs = dyn.data.length;
          return new Declaration(
            true,
            numArgs >= 1,
            numArgs >= 2,
            append
          );
        } else if (type === DYN_THUNK) {
          var data = dyn.data;
          return new Declaration(
            data.thisDep,
            data.contextDep,
            data.propDep,
            append
          );
        } else {
          return new Declaration(
            type === DYN_STATE$1,
            type === DYN_CONTEXT$1,
            type === DYN_PROP$1,
            append
          );
        }
      }
      var SCOPE_DECL = new Declaration(false, false, false, function() {
      });
      function reglCore(gl2, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer, config) {
        var AttributeRecord2 = attributeState.Record;
        var blendEquations = {
          "add": 32774,
          "subtract": 32778,
          "reverse subtract": 32779
        };
        if (extensions.ext_blend_minmax) {
          blendEquations.min = GL_MIN_EXT;
          blendEquations.max = GL_MAX_EXT;
        }
        var extInstancing = extensions.angle_instanced_arrays;
        var extDrawBuffers = extensions.webgl_draw_buffers;
        var currentState = {
          dirty: true,
          profile: config.profile
        };
        var nextState = {};
        var GL_STATE_NAMES = [];
        var GL_FLAGS = {};
        var GL_VARIABLES = {};
        function propName(name) {
          return name.replace(".", "_");
        }
        function stateFlag(sname, cap, init) {
          var name = propName(sname);
          GL_STATE_NAMES.push(sname);
          nextState[name] = currentState[name] = !!init;
          GL_FLAGS[name] = cap;
        }
        function stateVariable(sname, func, init) {
          var name = propName(sname);
          GL_STATE_NAMES.push(sname);
          if (Array.isArray(init)) {
            currentState[name] = init.slice();
            nextState[name] = init.slice();
          } else {
            currentState[name] = nextState[name] = init;
          }
          GL_VARIABLES[name] = func;
        }
        stateFlag(S_DITHER, GL_DITHER);
        stateFlag(S_BLEND_ENABLE, GL_BLEND);
        stateVariable(S_BLEND_COLOR, "blendColor", [0, 0, 0, 0]);
        stateVariable(
          S_BLEND_EQUATION,
          "blendEquationSeparate",
          [GL_FUNC_ADD, GL_FUNC_ADD]
        );
        stateVariable(
          S_BLEND_FUNC,
          "blendFuncSeparate",
          [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO]
        );
        stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true);
        stateVariable(S_DEPTH_FUNC, "depthFunc", GL_LESS);
        stateVariable(S_DEPTH_RANGE, "depthRange", [0, 1]);
        stateVariable(S_DEPTH_MASK, "depthMask", true);
        stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true]);
        stateFlag(S_CULL_ENABLE, GL_CULL_FACE);
        stateVariable(S_CULL_FACE, "cullFace", GL_BACK);
        stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW);
        stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1);
        stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL);
        stateVariable(S_POLYGON_OFFSET_OFFSET, "polygonOffset", [0, 0]);
        stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE);
        stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE);
        stateVariable(S_SAMPLE_COVERAGE, "sampleCoverage", [1, false]);
        stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST);
        stateVariable(S_STENCIL_MASK, "stencilMask", -1);
        stateVariable(S_STENCIL_FUNC, "stencilFunc", [GL_ALWAYS, 0, -1]);
        stateVariable(
          S_STENCIL_OPFRONT,
          "stencilOpSeparate",
          [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP]
        );
        stateVariable(
          S_STENCIL_OPBACK,
          "stencilOpSeparate",
          [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP]
        );
        stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST);
        stateVariable(
          S_SCISSOR_BOX,
          "scissor",
          [0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight]
        );
        stateVariable(
          S_VIEWPORT,
          S_VIEWPORT,
          [0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight]
        );
        var sharedState = {
          gl: gl2,
          context: contextState,
          strings: stringStore,
          next: nextState,
          current: currentState,
          draw: drawState,
          elements: elementState,
          buffer: bufferState,
          shader: shaderState,
          attributes: attributeState.state,
          vao: attributeState,
          uniforms: uniformState,
          framebuffer: framebufferState,
          extensions,
          timer,
          isBufferArgs
        };
        var sharedConstants = {
          primTypes,
          compareFuncs,
          blendFuncs,
          blendEquations,
          stencilOps,
          glTypes,
          orientationType
        };
        check$1.optional(function() {
          sharedState.isArrayLike = isArrayLike;
        });
        if (extDrawBuffers) {
          sharedConstants.backBuffer = [GL_BACK];
          sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function(i) {
            if (i === 0) {
              return [0];
            }
            return loop(i, function(j) {
              return GL_COLOR_ATTACHMENT0$2 + j;
            });
          });
        }
        var drawCallCounter = 0;
        function createREGLEnvironment() {
          var env = createEnvironment();
          var link = env.link;
          var global = env.global;
          env.id = drawCallCounter++;
          env.batchId = "0";
          var SHARED = link(sharedState);
          var shared = env.shared = {
            props: "a0"
          };
          Object.keys(sharedState).forEach(function(prop) {
            shared[prop] = global.def(SHARED, ".", prop);
          });
          check$1.optional(function() {
            env.CHECK = link(check$1);
            env.commandStr = check$1.guessCommand();
            env.command = link(env.commandStr);
            env.assert = function(block, pred, message) {
              block(
                "if(!(",
                pred,
                "))",
                this.CHECK,
                ".commandRaise(",
                link(message),
                ",",
                this.command,
                ");"
              );
            };
            sharedConstants.invalidBlendCombinations = invalidBlendCombinations;
          });
          var nextVars = env.next = {};
          var currentVars = env.current = {};
          Object.keys(GL_VARIABLES).forEach(function(variable) {
            if (Array.isArray(currentState[variable])) {
              nextVars[variable] = global.def(shared.next, ".", variable);
              currentVars[variable] = global.def(shared.current, ".", variable);
            }
          });
          var constants = env.constants = {};
          Object.keys(sharedConstants).forEach(function(name) {
            constants[name] = global.def(JSON.stringify(sharedConstants[name]));
          });
          env.invoke = function(block, x) {
            switch (x.type) {
              case DYN_FUNC$1:
                var argList = [
                  "this",
                  shared.context,
                  shared.props,
                  env.batchId
                ];
                return block.def(
                  link(x.data),
                  ".call(",
                  argList.slice(0, Math.max(x.data.length + 1, 4)),
                  ")"
                );
              case DYN_PROP$1:
                return block.def(shared.props, x.data);
              case DYN_CONTEXT$1:
                return block.def(shared.context, x.data);
              case DYN_STATE$1:
                return block.def("this", x.data);
              case DYN_THUNK:
                x.data.append(env, block);
                return x.data.ref;
            }
          };
          env.attribCache = {};
          var scopeAttribs = {};
          env.scopeAttrib = function(name) {
            var id = stringStore.id(name);
            if (id in scopeAttribs) {
              return scopeAttribs[id];
            }
            var binding = attributeState.scope[id];
            if (!binding) {
              binding = attributeState.scope[id] = new AttributeRecord2();
            }
            var result = scopeAttribs[id] = link(binding);
            return result;
          };
          return env;
        }
        function parseProfile(options) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          var profileEnable;
          if (S_PROFILE in staticOptions) {
            var value = !!staticOptions[S_PROFILE];
            profileEnable = createStaticDecl(function(env, scope) {
              return value;
            });
            profileEnable.enable = value;
          } else if (S_PROFILE in dynamicOptions) {
            var dyn = dynamicOptions[S_PROFILE];
            profileEnable = createDynamicDecl(dyn, function(env, scope) {
              return env.invoke(scope, dyn);
            });
          }
          return profileEnable;
        }
        function parseFramebuffer(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          if (S_FRAMEBUFFER in staticOptions) {
            var framebuffer = staticOptions[S_FRAMEBUFFER];
            if (framebuffer) {
              framebuffer = framebufferState.getFramebuffer(framebuffer);
              check$1.command(framebuffer, "invalid framebuffer object");
              return createStaticDecl(function(env2, block) {
                var FRAMEBUFFER = env2.link(framebuffer);
                var shared = env2.shared;
                block.set(
                  shared.framebuffer,
                  ".next",
                  FRAMEBUFFER
                );
                var CONTEXT = shared.context;
                block.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_WIDTH,
                  FRAMEBUFFER + ".width"
                );
                block.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_HEIGHT,
                  FRAMEBUFFER + ".height"
                );
                return FRAMEBUFFER;
              });
            } else {
              return createStaticDecl(function(env2, scope) {
                var shared = env2.shared;
                scope.set(
                  shared.framebuffer,
                  ".next",
                  "null"
                );
                var CONTEXT = shared.context;
                scope.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_WIDTH,
                  CONTEXT + "." + S_DRAWINGBUFFER_WIDTH
                );
                scope.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_HEIGHT,
                  CONTEXT + "." + S_DRAWINGBUFFER_HEIGHT
                );
                return "null";
              });
            }
          } else if (S_FRAMEBUFFER in dynamicOptions) {
            var dyn = dynamicOptions[S_FRAMEBUFFER];
            return createDynamicDecl(dyn, function(env2, scope) {
              var FRAMEBUFFER_FUNC = env2.invoke(scope, dyn);
              var shared = env2.shared;
              var FRAMEBUFFER_STATE = shared.framebuffer;
              var FRAMEBUFFER = scope.def(
                FRAMEBUFFER_STATE,
                ".getFramebuffer(",
                FRAMEBUFFER_FUNC,
                ")"
              );
              check$1.optional(function() {
                env2.assert(
                  scope,
                  "!" + FRAMEBUFFER_FUNC + "||" + FRAMEBUFFER,
                  "invalid framebuffer object"
                );
              });
              scope.set(
                FRAMEBUFFER_STATE,
                ".next",
                FRAMEBUFFER
              );
              var CONTEXT = shared.context;
              scope.set(
                CONTEXT,
                "." + S_FRAMEBUFFER_WIDTH,
                FRAMEBUFFER + "?" + FRAMEBUFFER + ".width:" + CONTEXT + "." + S_DRAWINGBUFFER_WIDTH
              );
              scope.set(
                CONTEXT,
                "." + S_FRAMEBUFFER_HEIGHT,
                FRAMEBUFFER + "?" + FRAMEBUFFER + ".height:" + CONTEXT + "." + S_DRAWINGBUFFER_HEIGHT
              );
              return FRAMEBUFFER;
            });
          } else {
            return null;
          }
        }
        function parseViewportScissor(options, framebuffer, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          function parseBox(param) {
            if (param in staticOptions) {
              var box = staticOptions[param];
              check$1.commandType(box, "object", "invalid " + param, env.commandStr);
              var isStatic2 = true;
              var x = box.x | 0;
              var y = box.y | 0;
              var w, h;
              if ("width" in box) {
                w = box.width | 0;
                check$1.command(w >= 0, "invalid " + param, env.commandStr);
              } else {
                isStatic2 = false;
              }
              if ("height" in box) {
                h = box.height | 0;
                check$1.command(h >= 0, "invalid " + param, env.commandStr);
              } else {
                isStatic2 = false;
              }
              return new Declaration(
                !isStatic2 && framebuffer && framebuffer.thisDep,
                !isStatic2 && framebuffer && framebuffer.contextDep,
                !isStatic2 && framebuffer && framebuffer.propDep,
                function(env2, scope) {
                  var CONTEXT = env2.shared.context;
                  var BOX_W = w;
                  if (!("width" in box)) {
                    BOX_W = scope.def(CONTEXT, ".", S_FRAMEBUFFER_WIDTH, "-", x);
                  }
                  var BOX_H = h;
                  if (!("height" in box)) {
                    BOX_H = scope.def(CONTEXT, ".", S_FRAMEBUFFER_HEIGHT, "-", y);
                  }
                  return [x, y, BOX_W, BOX_H];
                }
              );
            } else if (param in dynamicOptions) {
              var dynBox = dynamicOptions[param];
              var result = createDynamicDecl(dynBox, function(env2, scope) {
                var BOX = env2.invoke(scope, dynBox);
                check$1.optional(function() {
                  env2.assert(
                    scope,
                    BOX + "&&typeof " + BOX + '==="object"',
                    "invalid " + param
                  );
                });
                var CONTEXT = env2.shared.context;
                var BOX_X = scope.def(BOX, ".x|0");
                var BOX_Y = scope.def(BOX, ".y|0");
                var BOX_W = scope.def(
                  '"width" in ',
                  BOX,
                  "?",
                  BOX,
                  ".width|0:",
                  "(",
                  CONTEXT,
                  ".",
                  S_FRAMEBUFFER_WIDTH,
                  "-",
                  BOX_X,
                  ")"
                );
                var BOX_H = scope.def(
                  '"height" in ',
                  BOX,
                  "?",
                  BOX,
                  ".height|0:",
                  "(",
                  CONTEXT,
                  ".",
                  S_FRAMEBUFFER_HEIGHT,
                  "-",
                  BOX_Y,
                  ")"
                );
                check$1.optional(function() {
                  env2.assert(
                    scope,
                    BOX_W + ">=0&&" + BOX_H + ">=0",
                    "invalid " + param
                  );
                });
                return [BOX_X, BOX_Y, BOX_W, BOX_H];
              });
              if (framebuffer) {
                result.thisDep = result.thisDep || framebuffer.thisDep;
                result.contextDep = result.contextDep || framebuffer.contextDep;
                result.propDep = result.propDep || framebuffer.propDep;
              }
              return result;
            } else if (framebuffer) {
              return new Declaration(
                framebuffer.thisDep,
                framebuffer.contextDep,
                framebuffer.propDep,
                function(env2, scope) {
                  var CONTEXT = env2.shared.context;
                  return [
                    0,
                    0,
                    scope.def(CONTEXT, ".", S_FRAMEBUFFER_WIDTH),
                    scope.def(CONTEXT, ".", S_FRAMEBUFFER_HEIGHT)
                  ];
                }
              );
            } else {
              return null;
            }
          }
          var viewport = parseBox(S_VIEWPORT);
          if (viewport) {
            var prevViewport = viewport;
            viewport = new Declaration(
              viewport.thisDep,
              viewport.contextDep,
              viewport.propDep,
              function(env2, scope) {
                var VIEWPORT = prevViewport.append(env2, scope);
                var CONTEXT = env2.shared.context;
                scope.set(
                  CONTEXT,
                  "." + S_VIEWPORT_WIDTH,
                  VIEWPORT[2]
                );
                scope.set(
                  CONTEXT,
                  "." + S_VIEWPORT_HEIGHT,
                  VIEWPORT[3]
                );
                return VIEWPORT;
              }
            );
          }
          return {
            viewport,
            scissor_box: parseBox(S_SCISSOR_BOX)
          };
        }
        function parseAttribLocations(options, attributes) {
          var staticOptions = options.static;
          var staticProgram = typeof staticOptions[S_FRAG] === "string" && typeof staticOptions[S_VERT] === "string";
          if (staticProgram) {
            if (Object.keys(attributes.dynamic).length > 0) {
              return null;
            }
            var staticAttributes = attributes.static;
            var sAttributes = Object.keys(staticAttributes);
            if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === "number") {
              var bindings = [];
              for (var i = 0; i < sAttributes.length; ++i) {
                check$1(typeof staticAttributes[sAttributes[i]] === "number", "must specify all vertex attribute locations when using vaos");
                bindings.push([staticAttributes[sAttributes[i]] | 0, sAttributes[i]]);
              }
              return bindings;
            }
          }
          return null;
        }
        function parseProgram(options, env, attribLocations) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          function parseShader(name) {
            if (name in staticOptions) {
              var id = stringStore.id(staticOptions[name]);
              check$1.optional(function() {
                shaderState.shader(shaderType[name], id, check$1.guessCommand());
              });
              var result = createStaticDecl(function() {
                return id;
              });
              result.id = id;
              return result;
            } else if (name in dynamicOptions) {
              var dyn = dynamicOptions[name];
              return createDynamicDecl(dyn, function(env2, scope) {
                var str = env2.invoke(scope, dyn);
                var id2 = scope.def(env2.shared.strings, ".id(", str, ")");
                check$1.optional(function() {
                  scope(
                    env2.shared.shader,
                    ".shader(",
                    shaderType[name],
                    ",",
                    id2,
                    ",",
                    env2.command,
                    ");"
                  );
                });
                return id2;
              });
            }
            return null;
          }
          var frag = parseShader(S_FRAG);
          var vert = parseShader(S_VERT);
          var program = null;
          var progVar;
          if (isStatic(frag) && isStatic(vert)) {
            program = shaderState.program(vert.id, frag.id, null, attribLocations);
            progVar = createStaticDecl(function(env2, scope) {
              return env2.link(program);
            });
          } else {
            progVar = new Declaration(
              frag && frag.thisDep || vert && vert.thisDep,
              frag && frag.contextDep || vert && vert.contextDep,
              frag && frag.propDep || vert && vert.propDep,
              function(env2, scope) {
                var SHADER_STATE = env2.shared.shader;
                var fragId;
                if (frag) {
                  fragId = frag.append(env2, scope);
                } else {
                  fragId = scope.def(SHADER_STATE, ".", S_FRAG);
                }
                var vertId;
                if (vert) {
                  vertId = vert.append(env2, scope);
                } else {
                  vertId = scope.def(SHADER_STATE, ".", S_VERT);
                }
                var progDef = SHADER_STATE + ".program(" + vertId + "," + fragId;
                check$1.optional(function() {
                  progDef += "," + env2.command;
                });
                return scope.def(progDef + ")");
              }
            );
          }
          return {
            frag,
            vert,
            progVar,
            program
          };
        }
        function parseDraw(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          function parseElements() {
            if (S_ELEMENTS in staticOptions) {
              var elements2 = staticOptions[S_ELEMENTS];
              if (isBufferArgs(elements2)) {
                elements2 = elementState.getElements(elementState.create(elements2, true));
              } else if (elements2) {
                elements2 = elementState.getElements(elements2);
                check$1.command(elements2, "invalid elements", env.commandStr);
              }
              var result = createStaticDecl(function(env2, scope) {
                if (elements2) {
                  var result2 = env2.link(elements2);
                  env2.ELEMENTS = result2;
                  return result2;
                }
                env2.ELEMENTS = null;
                return null;
              });
              result.value = elements2;
              return result;
            } else if (S_ELEMENTS in dynamicOptions) {
              var dyn = dynamicOptions[S_ELEMENTS];
              return createDynamicDecl(dyn, function(env2, scope) {
                var shared = env2.shared;
                var IS_BUFFER_ARGS = shared.isBufferArgs;
                var ELEMENT_STATE = shared.elements;
                var elementDefn = env2.invoke(scope, dyn);
                var elements3 = scope.def("null");
                var elementStream = scope.def(IS_BUFFER_ARGS, "(", elementDefn, ")");
                var ifte = env2.cond(elementStream).then(elements3, "=", ELEMENT_STATE, ".createStream(", elementDefn, ");").else(elements3, "=", ELEMENT_STATE, ".getElements(", elementDefn, ");");
                check$1.optional(function() {
                  env2.assert(
                    ifte.else,
                    "!" + elementDefn + "||" + elements3,
                    "invalid elements"
                  );
                });
                scope.entry(ifte);
                scope.exit(
                  env2.cond(elementStream).then(ELEMENT_STATE, ".destroyStream(", elements3, ");")
                );
                env2.ELEMENTS = elements3;
                return elements3;
              });
            }
            return null;
          }
          var elements = parseElements();
          function parsePrimitive() {
            if (S_PRIMITIVE in staticOptions) {
              var primitive = staticOptions[S_PRIMITIVE];
              check$1.commandParameter(primitive, primTypes, "invalid primitve", env.commandStr);
              return createStaticDecl(function(env2, scope) {
                return primTypes[primitive];
              });
            } else if (S_PRIMITIVE in dynamicOptions) {
              var dynPrimitive = dynamicOptions[S_PRIMITIVE];
              return createDynamicDecl(dynPrimitive, function(env2, scope) {
                var PRIM_TYPES = env2.constants.primTypes;
                var prim = env2.invoke(scope, dynPrimitive);
                check$1.optional(function() {
                  env2.assert(
                    scope,
                    prim + " in " + PRIM_TYPES,
                    "invalid primitive, must be one of " + Object.keys(primTypes)
                  );
                });
                return scope.def(PRIM_TYPES, "[", prim, "]");
              });
            } else if (elements) {
              if (isStatic(elements)) {
                if (elements.value) {
                  return createStaticDecl(function(env2, scope) {
                    return scope.def(env2.ELEMENTS, ".primType");
                  });
                } else {
                  return createStaticDecl(function() {
                    return GL_TRIANGLES$1;
                  });
                }
              } else {
                return new Declaration(
                  elements.thisDep,
                  elements.contextDep,
                  elements.propDep,
                  function(env2, scope) {
                    var elements2 = env2.ELEMENTS;
                    return scope.def(elements2, "?", elements2, ".primType:", GL_TRIANGLES$1);
                  }
                );
              }
            }
            return null;
          }
          function parseParam(param, isOffset) {
            if (param in staticOptions) {
              var value = staticOptions[param] | 0;
              check$1.command(!isOffset || value >= 0, "invalid " + param, env.commandStr);
              return createStaticDecl(function(env2, scope) {
                if (isOffset) {
                  env2.OFFSET = value;
                }
                return value;
              });
            } else if (param in dynamicOptions) {
              var dynValue = dynamicOptions[param];
              return createDynamicDecl(dynValue, function(env2, scope) {
                var result = env2.invoke(scope, dynValue);
                if (isOffset) {
                  env2.OFFSET = result;
                  check$1.optional(function() {
                    env2.assert(
                      scope,
                      result + ">=0",
                      "invalid " + param
                    );
                  });
                }
                return result;
              });
            } else if (isOffset && elements) {
              return createStaticDecl(function(env2, scope) {
                env2.OFFSET = "0";
                return 0;
              });
            }
            return null;
          }
          var OFFSET = parseParam(S_OFFSET, true);
          function parseVertCount() {
            if (S_COUNT in staticOptions) {
              var count2 = staticOptions[S_COUNT] | 0;
              check$1.command(
                typeof count2 === "number" && count2 >= 0,
                "invalid vertex count",
                env.commandStr
              );
              return createStaticDecl(function() {
                return count2;
              });
            } else if (S_COUNT in dynamicOptions) {
              var dynCount = dynamicOptions[S_COUNT];
              return createDynamicDecl(dynCount, function(env2, scope) {
                var result2 = env2.invoke(scope, dynCount);
                check$1.optional(function() {
                  env2.assert(
                    scope,
                    "typeof " + result2 + '==="number"&&' + result2 + ">=0&&" + result2 + "===(" + result2 + "|0)",
                    "invalid vertex count"
                  );
                });
                return result2;
              });
            } else if (elements) {
              if (isStatic(elements)) {
                if (elements) {
                  if (OFFSET) {
                    return new Declaration(
                      OFFSET.thisDep,
                      OFFSET.contextDep,
                      OFFSET.propDep,
                      function(env2, scope) {
                        var result2 = scope.def(
                          env2.ELEMENTS,
                          ".vertCount-",
                          env2.OFFSET
                        );
                        check$1.optional(function() {
                          env2.assert(
                            scope,
                            result2 + ">=0",
                            "invalid vertex offset/element buffer too small"
                          );
                        });
                        return result2;
                      }
                    );
                  } else {
                    return createStaticDecl(function(env2, scope) {
                      return scope.def(env2.ELEMENTS, ".vertCount");
                    });
                  }
                } else {
                  var result = createStaticDecl(function() {
                    return -1;
                  });
                  check$1.optional(function() {
                    result.MISSING = true;
                  });
                  return result;
                }
              } else {
                var variable = new Declaration(
                  elements.thisDep || OFFSET.thisDep,
                  elements.contextDep || OFFSET.contextDep,
                  elements.propDep || OFFSET.propDep,
                  function(env2, scope) {
                    var elements2 = env2.ELEMENTS;
                    if (env2.OFFSET) {
                      return scope.def(
                        elements2,
                        "?",
                        elements2,
                        ".vertCount-",
                        env2.OFFSET,
                        ":-1"
                      );
                    }
                    return scope.def(elements2, "?", elements2, ".vertCount:-1");
                  }
                );
                check$1.optional(function() {
                  variable.DYNAMIC = true;
                });
                return variable;
              }
            }
            return null;
          }
          return {
            elements,
            primitive: parsePrimitive(),
            count: parseVertCount(),
            instances: parseParam(S_INSTANCES, false),
            offset: OFFSET
          };
        }
        function parseGLState(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          var STATE = {};
          GL_STATE_NAMES.forEach(function(prop) {
            var param = propName(prop);
            function parseParam(parseStatic, parseDynamic) {
              if (prop in staticOptions) {
                var value = parseStatic(staticOptions[prop]);
                STATE[param] = createStaticDecl(function() {
                  return value;
                });
              } else if (prop in dynamicOptions) {
                var dyn = dynamicOptions[prop];
                STATE[param] = createDynamicDecl(dyn, function(env2, scope) {
                  return parseDynamic(env2, scope, env2.invoke(scope, dyn));
                });
              }
            }
            switch (prop) {
              case S_CULL_ENABLE:
              case S_BLEND_ENABLE:
              case S_DITHER:
              case S_STENCIL_ENABLE:
              case S_DEPTH_ENABLE:
              case S_SCISSOR_ENABLE:
              case S_POLYGON_OFFSET_ENABLE:
              case S_SAMPLE_ALPHA:
              case S_SAMPLE_ENABLE:
              case S_DEPTH_MASK:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "boolean", prop, env.commandStr);
                    return value;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        "typeof " + value + '==="boolean"',
                        "invalid flag " + prop,
                        env2.commandStr
                      );
                    });
                    return value;
                  }
                );
              case S_DEPTH_FUNC:
                return parseParam(
                  function(value) {
                    check$1.commandParameter(value, compareFuncs, "invalid " + prop, env.commandStr);
                    return compareFuncs[value];
                  },
                  function(env2, scope, value) {
                    var COMPARE_FUNCS = env2.constants.compareFuncs;
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + " in " + COMPARE_FUNCS,
                        "invalid " + prop + ", must be one of " + Object.keys(compareFuncs)
                      );
                    });
                    return scope.def(COMPARE_FUNCS, "[", value, "]");
                  }
                );
              case S_DEPTH_RANGE:
                return parseParam(
                  function(value) {
                    check$1.command(
                      isArrayLike(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number" && value[0] <= value[1],
                      "depth range is 2d array",
                      env.commandStr
                    );
                    return value;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        env2.shared.isArrayLike + "(" + value + ")&&" + value + ".length===2&&typeof " + value + '[0]==="number"&&typeof ' + value + '[1]==="number"&&' + value + "[0]<=" + value + "[1]",
                        "depth range must be a 2d array"
                      );
                    });
                    var Z_NEAR = scope.def("+", value, "[0]");
                    var Z_FAR = scope.def("+", value, "[1]");
                    return [Z_NEAR, Z_FAR];
                  }
                );
              case S_BLEND_FUNC:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "object", "blend.func", env.commandStr);
                    var srcRGB = "srcRGB" in value ? value.srcRGB : value.src;
                    var srcAlpha = "srcAlpha" in value ? value.srcAlpha : value.src;
                    var dstRGB = "dstRGB" in value ? value.dstRGB : value.dst;
                    var dstAlpha = "dstAlpha" in value ? value.dstAlpha : value.dst;
                    check$1.commandParameter(srcRGB, blendFuncs, param + ".srcRGB", env.commandStr);
                    check$1.commandParameter(srcAlpha, blendFuncs, param + ".srcAlpha", env.commandStr);
                    check$1.commandParameter(dstRGB, blendFuncs, param + ".dstRGB", env.commandStr);
                    check$1.commandParameter(dstAlpha, blendFuncs, param + ".dstAlpha", env.commandStr);
                    check$1.command(
                      invalidBlendCombinations.indexOf(srcRGB + ", " + dstRGB) === -1,
                      "unallowed blending combination (srcRGB, dstRGB) = (" + srcRGB + ", " + dstRGB + ")",
                      env.commandStr
                    );
                    return [
                      blendFuncs[srcRGB],
                      blendFuncs[dstRGB],
                      blendFuncs[srcAlpha],
                      blendFuncs[dstAlpha]
                    ];
                  },
                  function(env2, scope, value) {
                    var BLEND_FUNCS = env2.constants.blendFuncs;
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + "&&typeof " + value + '==="object"',
                        "invalid blend func, must be an object"
                      );
                    });
                    function read(prefix2, suffix) {
                      var func = scope.def(
                        '"',
                        prefix2,
                        suffix,
                        '" in ',
                        value,
                        "?",
                        value,
                        ".",
                        prefix2,
                        suffix,
                        ":",
                        value,
                        ".",
                        prefix2
                      );
                      check$1.optional(function() {
                        env2.assert(
                          scope,
                          func + " in " + BLEND_FUNCS,
                          "invalid " + prop + "." + prefix2 + suffix + ", must be one of " + Object.keys(blendFuncs)
                        );
                      });
                      return func;
                    }
                    var srcRGB = read("src", "RGB");
                    var dstRGB = read("dst", "RGB");
                    check$1.optional(function() {
                      var INVALID_BLEND_COMBINATIONS = env2.constants.invalidBlendCombinations;
                      env2.assert(
                        scope,
                        INVALID_BLEND_COMBINATIONS + ".indexOf(" + srcRGB + '+", "+' + dstRGB + ") === -1 ",
                        "unallowed blending combination for (srcRGB, dstRGB)"
                      );
                    });
                    var SRC_RGB = scope.def(BLEND_FUNCS, "[", srcRGB, "]");
                    var SRC_ALPHA = scope.def(BLEND_FUNCS, "[", read("src", "Alpha"), "]");
                    var DST_RGB = scope.def(BLEND_FUNCS, "[", dstRGB, "]");
                    var DST_ALPHA = scope.def(BLEND_FUNCS, "[", read("dst", "Alpha"), "]");
                    return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA];
                  }
                );
              case S_BLEND_EQUATION:
                return parseParam(
                  function(value) {
                    if (typeof value === "string") {
                      check$1.commandParameter(value, blendEquations, "invalid " + prop, env.commandStr);
                      return [
                        blendEquations[value],
                        blendEquations[value]
                      ];
                    } else if (typeof value === "object") {
                      check$1.commandParameter(
                        value.rgb,
                        blendEquations,
                        prop + ".rgb",
                        env.commandStr
                      );
                      check$1.commandParameter(
                        value.alpha,
                        blendEquations,
                        prop + ".alpha",
                        env.commandStr
                      );
                      return [
                        blendEquations[value.rgb],
                        blendEquations[value.alpha]
                      ];
                    } else {
                      check$1.commandRaise("invalid blend.equation", env.commandStr);
                    }
                  },
                  function(env2, scope, value) {
                    var BLEND_EQUATIONS = env2.constants.blendEquations;
                    var RGB = scope.def();
                    var ALPHA = scope.def();
                    var ifte = env2.cond("typeof ", value, '==="string"');
                    check$1.optional(function() {
                      function checkProp(block, name, value2) {
                        env2.assert(
                          block,
                          value2 + " in " + BLEND_EQUATIONS,
                          "invalid " + name + ", must be one of " + Object.keys(blendEquations)
                        );
                      }
                      checkProp(ifte.then, prop, value);
                      env2.assert(
                        ifte.else,
                        value + "&&typeof " + value + '==="object"',
                        "invalid " + prop
                      );
                      checkProp(ifte.else, prop + ".rgb", value + ".rgb");
                      checkProp(ifte.else, prop + ".alpha", value + ".alpha");
                    });
                    ifte.then(
                      RGB,
                      "=",
                      ALPHA,
                      "=",
                      BLEND_EQUATIONS,
                      "[",
                      value,
                      "];"
                    );
                    ifte.else(
                      RGB,
                      "=",
                      BLEND_EQUATIONS,
                      "[",
                      value,
                      ".rgb];",
                      ALPHA,
                      "=",
                      BLEND_EQUATIONS,
                      "[",
                      value,
                      ".alpha];"
                    );
                    scope(ifte);
                    return [RGB, ALPHA];
                  }
                );
              case S_BLEND_COLOR:
                return parseParam(
                  function(value) {
                    check$1.command(
                      isArrayLike(value) && value.length === 4,
                      "blend.color must be a 4d array",
                      env.commandStr
                    );
                    return loop(4, function(i) {
                      return +value[i];
                    });
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        env2.shared.isArrayLike + "(" + value + ")&&" + value + ".length===4",
                        "blend.color must be a 4d array"
                      );
                    });
                    return loop(4, function(i) {
                      return scope.def("+", value, "[", i, "]");
                    });
                  }
                );
              case S_STENCIL_MASK:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "number", param, env.commandStr);
                    return value | 0;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        "typeof " + value + '==="number"',
                        "invalid stencil.mask"
                      );
                    });
                    return scope.def(value, "|0");
                  }
                );
              case S_STENCIL_FUNC:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "object", param, env.commandStr);
                    var cmp2 = value.cmp || "keep";
                    var ref = value.ref || 0;
                    var mask = "mask" in value ? value.mask : -1;
                    check$1.commandParameter(cmp2, compareFuncs, prop + ".cmp", env.commandStr);
                    check$1.commandType(ref, "number", prop + ".ref", env.commandStr);
                    check$1.commandType(mask, "number", prop + ".mask", env.commandStr);
                    return [
                      compareFuncs[cmp2],
                      ref,
                      mask
                    ];
                  },
                  function(env2, scope, value) {
                    var COMPARE_FUNCS = env2.constants.compareFuncs;
                    check$1.optional(function() {
                      function assert2() {
                        env2.assert(
                          scope,
                          Array.prototype.join.call(arguments, ""),
                          "invalid stencil.func"
                        );
                      }
                      assert2(value + "&&typeof ", value, '==="object"');
                      assert2(
                        '!("cmp" in ',
                        value,
                        ")||(",
                        value,
                        ".cmp in ",
                        COMPARE_FUNCS,
                        ")"
                      );
                    });
                    var cmp2 = scope.def(
                      '"cmp" in ',
                      value,
                      "?",
                      COMPARE_FUNCS,
                      "[",
                      value,
                      ".cmp]",
                      ":",
                      GL_KEEP
                    );
                    var ref = scope.def(value, ".ref|0");
                    var mask = scope.def(
                      '"mask" in ',
                      value,
                      "?",
                      value,
                      ".mask|0:-1"
                    );
                    return [cmp2, ref, mask];
                  }
                );
              case S_STENCIL_OPFRONT:
              case S_STENCIL_OPBACK:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "object", param, env.commandStr);
                    var fail = value.fail || "keep";
                    var zfail = value.zfail || "keep";
                    var zpass = value.zpass || "keep";
                    check$1.commandParameter(fail, stencilOps, prop + ".fail", env.commandStr);
                    check$1.commandParameter(zfail, stencilOps, prop + ".zfail", env.commandStr);
                    check$1.commandParameter(zpass, stencilOps, prop + ".zpass", env.commandStr);
                    return [
                      prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                      stencilOps[fail],
                      stencilOps[zfail],
                      stencilOps[zpass]
                    ];
                  },
                  function(env2, scope, value) {
                    var STENCIL_OPS = env2.constants.stencilOps;
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + "&&typeof " + value + '==="object"',
                        "invalid " + prop
                      );
                    });
                    function read(name) {
                      check$1.optional(function() {
                        env2.assert(
                          scope,
                          '!("' + name + '" in ' + value + ")||(" + value + "." + name + " in " + STENCIL_OPS + ")",
                          "invalid " + prop + "." + name + ", must be one of " + Object.keys(stencilOps)
                        );
                      });
                      return scope.def(
                        '"',
                        name,
                        '" in ',
                        value,
                        "?",
                        STENCIL_OPS,
                        "[",
                        value,
                        ".",
                        name,
                        "]:",
                        GL_KEEP
                      );
                    }
                    return [
                      prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                      read("fail"),
                      read("zfail"),
                      read("zpass")
                    ];
                  }
                );
              case S_POLYGON_OFFSET_OFFSET:
                return parseParam(
                  function(value) {
                    check$1.commandType(value, "object", param, env.commandStr);
                    var factor = value.factor | 0;
                    var units = value.units | 0;
                    check$1.commandType(factor, "number", param + ".factor", env.commandStr);
                    check$1.commandType(units, "number", param + ".units", env.commandStr);
                    return [factor, units];
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + "&&typeof " + value + '==="object"',
                        "invalid " + prop
                      );
                    });
                    var FACTOR = scope.def(value, ".factor|0");
                    var UNITS = scope.def(value, ".units|0");
                    return [FACTOR, UNITS];
                  }
                );
              case S_CULL_FACE:
                return parseParam(
                  function(value) {
                    var face = 0;
                    if (value === "front") {
                      face = GL_FRONT;
                    } else if (value === "back") {
                      face = GL_BACK;
                    }
                    check$1.command(!!face, param, env.commandStr);
                    return face;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + '==="front"||' + value + '==="back"',
                        "invalid cull.face"
                      );
                    });
                    return scope.def(value, '==="front"?', GL_FRONT, ":", GL_BACK);
                  }
                );
              case S_LINE_WIDTH:
                return parseParam(
                  function(value) {
                    check$1.command(
                      typeof value === "number" && value >= limits.lineWidthDims[0] && value <= limits.lineWidthDims[1],
                      "invalid line width, must be a positive number between " + limits.lineWidthDims[0] + " and " + limits.lineWidthDims[1],
                      env.commandStr
                    );
                    return value;
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        "typeof " + value + '==="number"&&' + value + ">=" + limits.lineWidthDims[0] + "&&" + value + "<=" + limits.lineWidthDims[1],
                        "invalid line width"
                      );
                    });
                    return value;
                  }
                );
              case S_FRONT_FACE:
                return parseParam(
                  function(value) {
                    check$1.commandParameter(value, orientationType, param, env.commandStr);
                    return orientationType[value];
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + '==="cw"||' + value + '==="ccw"',
                        "invalid frontFace, must be one of cw,ccw"
                      );
                    });
                    return scope.def(value + '==="cw"?' + GL_CW + ":" + GL_CCW);
                  }
                );
              case S_COLOR_MASK:
                return parseParam(
                  function(value) {
                    check$1.command(
                      isArrayLike(value) && value.length === 4,
                      "color.mask must be length 4 array",
                      env.commandStr
                    );
                    return value.map(function(v2) {
                      return !!v2;
                    });
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        env2.shared.isArrayLike + "(" + value + ")&&" + value + ".length===4",
                        "invalid color.mask"
                      );
                    });
                    return loop(4, function(i) {
                      return "!!" + value + "[" + i + "]";
                    });
                  }
                );
              case S_SAMPLE_COVERAGE:
                return parseParam(
                  function(value) {
                    check$1.command(typeof value === "object" && value, param, env.commandStr);
                    var sampleValue = "value" in value ? value.value : 1;
                    var sampleInvert = !!value.invert;
                    check$1.command(
                      typeof sampleValue === "number" && sampleValue >= 0 && sampleValue <= 1,
                      "sample.coverage.value must be a number between 0 and 1",
                      env.commandStr
                    );
                    return [sampleValue, sampleInvert];
                  },
                  function(env2, scope, value) {
                    check$1.optional(function() {
                      env2.assert(
                        scope,
                        value + "&&typeof " + value + '==="object"',
                        "invalid sample.coverage"
                      );
                    });
                    var VALUE = scope.def(
                      '"value" in ',
                      value,
                      "?+",
                      value,
                      ".value:1"
                    );
                    var INVERT = scope.def("!!", value, ".invert");
                    return [VALUE, INVERT];
                  }
                );
            }
          });
          return STATE;
        }
        function parseUniforms(uniforms, env) {
          var staticUniforms = uniforms.static;
          var dynamicUniforms = uniforms.dynamic;
          var UNIFORMS = {};
          Object.keys(staticUniforms).forEach(function(name) {
            var value = staticUniforms[name];
            var result;
            if (typeof value === "number" || typeof value === "boolean") {
              result = createStaticDecl(function() {
                return value;
              });
            } else if (typeof value === "function") {
              var reglType = value._reglType;
              if (reglType === "texture2d" || reglType === "textureCube") {
                result = createStaticDecl(function(env2) {
                  return env2.link(value);
                });
              } else if (reglType === "framebuffer" || reglType === "framebufferCube") {
                check$1.command(
                  value.color.length > 0,
                  'missing color attachment for framebuffer sent to uniform "' + name + '"',
                  env.commandStr
                );
                result = createStaticDecl(function(env2) {
                  return env2.link(value.color[0]);
                });
              } else {
                check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr);
              }
            } else if (isArrayLike(value)) {
              result = createStaticDecl(function(env2) {
                var ITEM = env2.global.def(
                  "[",
                  loop(value.length, function(i) {
                    check$1.command(
                      typeof value[i] === "number" || typeof value[i] === "boolean",
                      "invalid uniform " + name,
                      env2.commandStr
                    );
                    return value[i];
                  }),
                  "]"
                );
                return ITEM;
              });
            } else {
              check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr);
            }
            result.value = value;
            UNIFORMS[name] = result;
          });
          Object.keys(dynamicUniforms).forEach(function(key) {
            var dyn = dynamicUniforms[key];
            UNIFORMS[key] = createDynamicDecl(dyn, function(env2, scope) {
              return env2.invoke(scope, dyn);
            });
          });
          return UNIFORMS;
        }
        function parseAttributes(attributes, env) {
          var staticAttributes = attributes.static;
          var dynamicAttributes = attributes.dynamic;
          var attributeDefs = {};
          Object.keys(staticAttributes).forEach(function(attribute) {
            var value = staticAttributes[attribute];
            var id = stringStore.id(attribute);
            var record = new AttributeRecord2();
            if (isBufferArgs(value)) {
              record.state = ATTRIB_STATE_POINTER;
              record.buffer = bufferState.getBuffer(
                bufferState.create(value, GL_ARRAY_BUFFER$2, false, true)
              );
              record.type = 0;
            } else {
              var buffer = bufferState.getBuffer(value);
              if (buffer) {
                record.state = ATTRIB_STATE_POINTER;
                record.buffer = buffer;
                record.type = 0;
              } else {
                check$1.command(
                  typeof value === "object" && value,
                  "invalid data for attribute " + attribute,
                  env.commandStr
                );
                if ("constant" in value) {
                  var constant = value.constant;
                  record.buffer = "null";
                  record.state = ATTRIB_STATE_CONSTANT;
                  if (typeof constant === "number") {
                    record.x = constant;
                  } else {
                    check$1.command(
                      isArrayLike(constant) && constant.length > 0 && constant.length <= 4,
                      "invalid constant for attribute " + attribute,
                      env.commandStr
                    );
                    CUTE_COMPONENTS.forEach(function(c, i) {
                      if (i < constant.length) {
                        record[c] = constant[i];
                      }
                    });
                  }
                } else {
                  if (isBufferArgs(value.buffer)) {
                    buffer = bufferState.getBuffer(
                      bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true)
                    );
                  } else {
                    buffer = bufferState.getBuffer(value.buffer);
                  }
                  check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr);
                  var offset = value.offset | 0;
                  check$1.command(
                    offset >= 0,
                    'invalid offset for attribute "' + attribute + '"',
                    env.commandStr
                  );
                  var stride = value.stride | 0;
                  check$1.command(
                    stride >= 0 && stride < 256,
                    'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]',
                    env.commandStr
                  );
                  var size2 = value.size | 0;
                  check$1.command(
                    !("size" in value) || size2 > 0 && size2 <= 4,
                    'invalid size for attribute "' + attribute + '", must be 1,2,3,4',
                    env.commandStr
                  );
                  var normalized = !!value.normalized;
                  var type = 0;
                  if ("type" in value) {
                    check$1.commandParameter(
                      value.type,
                      glTypes,
                      "invalid type for attribute " + attribute,
                      env.commandStr
                    );
                    type = glTypes[value.type];
                  }
                  var divisor = value.divisor | 0;
                  if ("divisor" in value) {
                    check$1.command(
                      divisor === 0 || extInstancing,
                      'cannot specify divisor for attribute "' + attribute + '", instancing not supported',
                      env.commandStr
                    );
                    check$1.command(
                      divisor >= 0,
                      'invalid divisor for attribute "' + attribute + '"',
                      env.commandStr
                    );
                  }
                  check$1.optional(function() {
                    var command = env.commandStr;
                    var VALID_KEYS = [
                      "buffer",
                      "offset",
                      "divisor",
                      "normalized",
                      "type",
                      "size",
                      "stride"
                    ];
                    Object.keys(value).forEach(function(prop) {
                      check$1.command(
                        VALID_KEYS.indexOf(prop) >= 0,
                        'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ")",
                        command
                      );
                    });
                  });
                  record.buffer = buffer;
                  record.state = ATTRIB_STATE_POINTER;
                  record.size = size2;
                  record.normalized = normalized;
                  record.type = type || buffer.dtype;
                  record.offset = offset;
                  record.stride = stride;
                  record.divisor = divisor;
                }
              }
            }
            attributeDefs[attribute] = createStaticDecl(function(env2, scope) {
              var cache = env2.attribCache;
              if (id in cache) {
                return cache[id];
              }
              var result = {
                isStream: false
              };
              Object.keys(record).forEach(function(key) {
                result[key] = record[key];
              });
              if (record.buffer) {
                result.buffer = env2.link(record.buffer);
                result.type = result.type || result.buffer + ".dtype";
              }
              cache[id] = result;
              return result;
            });
          });
          Object.keys(dynamicAttributes).forEach(function(attribute) {
            var dyn = dynamicAttributes[attribute];
            function appendAttributeCode(env2, block) {
              var VALUE = env2.invoke(block, dyn);
              var shared = env2.shared;
              var constants = env2.constants;
              var IS_BUFFER_ARGS = shared.isBufferArgs;
              var BUFFER_STATE = shared.buffer;
              check$1.optional(function() {
                env2.assert(
                  block,
                  VALUE + "&&(typeof " + VALUE + '==="object"||typeof ' + VALUE + '==="function")&&(' + IS_BUFFER_ARGS + "(" + VALUE + ")||" + BUFFER_STATE + ".getBuffer(" + VALUE + ")||" + BUFFER_STATE + ".getBuffer(" + VALUE + ".buffer)||" + IS_BUFFER_ARGS + "(" + VALUE + '.buffer)||("constant" in ' + VALUE + "&&(typeof " + VALUE + '.constant==="number"||' + shared.isArrayLike + "(" + VALUE + ".constant))))",
                  'invalid dynamic attribute "' + attribute + '"'
                );
              });
              var result = {
                isStream: block.def(false)
              };
              var defaultRecord = new AttributeRecord2();
              defaultRecord.state = ATTRIB_STATE_POINTER;
              Object.keys(defaultRecord).forEach(function(key) {
                result[key] = block.def("" + defaultRecord[key]);
              });
              var BUFFER = result.buffer;
              var TYPE = result.type;
              block(
                "if(",
                IS_BUFFER_ARGS,
                "(",
                VALUE,
                ")){",
                result.isStream,
                "=true;",
                BUFFER,
                "=",
                BUFFER_STATE,
                ".createStream(",
                GL_ARRAY_BUFFER$2,
                ",",
                VALUE,
                ");",
                TYPE,
                "=",
                BUFFER,
                ".dtype;",
                "}else{",
                BUFFER,
                "=",
                BUFFER_STATE,
                ".getBuffer(",
                VALUE,
                ");",
                "if(",
                BUFFER,
                "){",
                TYPE,
                "=",
                BUFFER,
                ".dtype;",
                '}else if("constant" in ',
                VALUE,
                "){",
                result.state,
                "=",
                ATTRIB_STATE_CONSTANT,
                ";",
                "if(typeof " + VALUE + '.constant === "number"){',
                result[CUTE_COMPONENTS[0]],
                "=",
                VALUE,
                ".constant;",
                CUTE_COMPONENTS.slice(1).map(function(n) {
                  return result[n];
                }).join("="),
                "=0;",
                "}else{",
                CUTE_COMPONENTS.map(function(name, i) {
                  return result[name] + "=" + VALUE + ".constant.length>" + i + "?" + VALUE + ".constant[" + i + "]:0;";
                }).join(""),
                "}}else{",
                "if(",
                IS_BUFFER_ARGS,
                "(",
                VALUE,
                ".buffer)){",
                BUFFER,
                "=",
                BUFFER_STATE,
                ".createStream(",
                GL_ARRAY_BUFFER$2,
                ",",
                VALUE,
                ".buffer);",
                "}else{",
                BUFFER,
                "=",
                BUFFER_STATE,
                ".getBuffer(",
                VALUE,
                ".buffer);",
                "}",
                TYPE,
                '="type" in ',
                VALUE,
                "?",
                constants.glTypes,
                "[",
                VALUE,
                ".type]:",
                BUFFER,
                ".dtype;",
                result.normalized,
                "=!!",
                VALUE,
                ".normalized;"
              );
              function emitReadRecord(name) {
                block(result[name], "=", VALUE, ".", name, "|0;");
              }
              emitReadRecord("size");
              emitReadRecord("offset");
              emitReadRecord("stride");
              emitReadRecord("divisor");
              block("}}");
              block.exit(
                "if(",
                result.isStream,
                "){",
                BUFFER_STATE,
                ".destroyStream(",
                BUFFER,
                ");",
                "}"
              );
              return result;
            }
            attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode);
          });
          return attributeDefs;
        }
        function parseVAO(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          if (S_VAO in staticOptions) {
            var vao = staticOptions[S_VAO];
            if (vao !== null && attributeState.getVAO(vao) === null) {
              vao = attributeState.createVAO(vao);
            }
            return createStaticDecl(function(env2) {
              return env2.link(attributeState.getVAO(vao));
            });
          } else if (S_VAO in dynamicOptions) {
            var dyn = dynamicOptions[S_VAO];
            return createDynamicDecl(dyn, function(env2, scope) {
              var vaoRef = env2.invoke(scope, dyn);
              return scope.def(env2.shared.vao + ".getVAO(" + vaoRef + ")");
            });
          }
          return null;
        }
        function parseContext(context) {
          var staticContext = context.static;
          var dynamicContext = context.dynamic;
          var result = {};
          Object.keys(staticContext).forEach(function(name) {
            var value = staticContext[name];
            result[name] = createStaticDecl(function(env, scope) {
              if (typeof value === "number" || typeof value === "boolean") {
                return "" + value;
              } else {
                return env.link(value);
              }
            });
          });
          Object.keys(dynamicContext).forEach(function(name) {
            var dyn = dynamicContext[name];
            result[name] = createDynamicDecl(dyn, function(env, scope) {
              return env.invoke(scope, dyn);
            });
          });
          return result;
        }
        function parseArguments(options, attributes, uniforms, context, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          check$1.optional(function() {
            var KEY_NAMES = [
              S_FRAMEBUFFER,
              S_VERT,
              S_FRAG,
              S_ELEMENTS,
              S_PRIMITIVE,
              S_OFFSET,
              S_COUNT,
              S_INSTANCES,
              S_PROFILE,
              S_VAO
            ].concat(GL_STATE_NAMES);
            function checkKeys(dict) {
              Object.keys(dict).forEach(function(key) {
                check$1.command(
                  KEY_NAMES.indexOf(key) >= 0,
                  'unknown parameter "' + key + '"',
                  env.commandStr
                );
              });
            }
            checkKeys(staticOptions);
            checkKeys(dynamicOptions);
          });
          var attribLocations = parseAttribLocations(options, attributes);
          var framebuffer = parseFramebuffer(options, env);
          var viewportAndScissor = parseViewportScissor(options, framebuffer, env);
          var draw = parseDraw(options, env);
          var state = parseGLState(options, env);
          var shader = parseProgram(options, env, attribLocations);
          function copyBox(name) {
            var defn = viewportAndScissor[name];
            if (defn) {
              state[name] = defn;
            }
          }
          copyBox(S_VIEWPORT);
          copyBox(propName(S_SCISSOR_BOX));
          var dirty = Object.keys(state).length > 0;
          var result = {
            framebuffer,
            draw,
            shader,
            state,
            dirty,
            scopeVAO: null,
            drawVAO: null,
            useVAO: false,
            attributes: {}
          };
          result.profile = parseProfile(options, env);
          result.uniforms = parseUniforms(uniforms, env);
          result.drawVAO = result.scopeVAO = parseVAO(options, env);
          if (!result.drawVAO && shader.program && !attribLocations && extensions.angle_instanced_arrays) {
            var useVAO = true;
            var staticBindings = shader.program.attributes.map(function(attr) {
              var binding = attributes.static[attr];
              useVAO = useVAO && !!binding;
              return binding;
            });
            if (useVAO && staticBindings.length > 0) {
              var vao = attributeState.getVAO(attributeState.createVAO(staticBindings));
              result.drawVAO = new Declaration(null, null, null, function(env2, scope) {
                return env2.link(vao);
              });
              result.useVAO = true;
            }
          }
          if (attribLocations) {
            result.useVAO = true;
          } else {
            result.attributes = parseAttributes(attributes, env);
          }
          result.context = parseContext(context, env);
          return result;
        }
        function emitContext(env, scope, context) {
          var shared = env.shared;
          var CONTEXT = shared.context;
          var contextEnter = env.scope();
          Object.keys(context).forEach(function(name) {
            scope.save(CONTEXT, "." + name);
            var defn = context[name];
            contextEnter(CONTEXT, ".", name, "=", defn.append(env, scope), ";");
          });
          scope(contextEnter);
        }
        function emitPollFramebuffer(env, scope, framebuffer, skipCheck) {
          var shared = env.shared;
          var GL2 = shared.gl;
          var FRAMEBUFFER_STATE = shared.framebuffer;
          var EXT_DRAW_BUFFERS;
          if (extDrawBuffers) {
            EXT_DRAW_BUFFERS = scope.def(shared.extensions, ".webgl_draw_buffers");
          }
          var constants = env.constants;
          var DRAW_BUFFERS = constants.drawBuffer;
          var BACK_BUFFER = constants.backBuffer;
          var NEXT;
          if (framebuffer) {
            NEXT = framebuffer.append(env, scope);
          } else {
            NEXT = scope.def(FRAMEBUFFER_STATE, ".next");
          }
          if (!skipCheck) {
            scope("if(", NEXT, "!==", FRAMEBUFFER_STATE, ".cur){");
          }
          scope(
            "if(",
            NEXT,
            "){",
            GL2,
            ".bindFramebuffer(",
            GL_FRAMEBUFFER$2,
            ",",
            NEXT,
            ".framebuffer);"
          );
          if (extDrawBuffers) {
            scope(
              EXT_DRAW_BUFFERS,
              ".drawBuffersWEBGL(",
              DRAW_BUFFERS,
              "[",
              NEXT,
              ".colorAttachments.length]);"
            );
          }
          scope(
            "}else{",
            GL2,
            ".bindFramebuffer(",
            GL_FRAMEBUFFER$2,
            ",null);"
          );
          if (extDrawBuffers) {
            scope(EXT_DRAW_BUFFERS, ".drawBuffersWEBGL(", BACK_BUFFER, ");");
          }
          scope(
            "}",
            FRAMEBUFFER_STATE,
            ".cur=",
            NEXT,
            ";"
          );
          if (!skipCheck) {
            scope("}");
          }
        }
        function emitPollState(env, scope, args) {
          var shared = env.shared;
          var GL2 = shared.gl;
          var CURRENT_VARS = env.current;
          var NEXT_VARS = env.next;
          var CURRENT_STATE = shared.current;
          var NEXT_STATE = shared.next;
          var block = env.cond(CURRENT_STATE, ".dirty");
          GL_STATE_NAMES.forEach(function(prop) {
            var param = propName(prop);
            if (param in args.state) {
              return;
            }
            var NEXT, CURRENT;
            if (param in NEXT_VARS) {
              NEXT = NEXT_VARS[param];
              CURRENT = CURRENT_VARS[param];
              var parts = loop(currentState[param].length, function(i) {
                return block.def(NEXT, "[", i, "]");
              });
              block(env.cond(parts.map(function(p, i) {
                return p + "!==" + CURRENT + "[" + i + "]";
              }).join("||")).then(
                GL2,
                ".",
                GL_VARIABLES[param],
                "(",
                parts,
                ");",
                parts.map(function(p, i) {
                  return CURRENT + "[" + i + "]=" + p;
                }).join(";"),
                ";"
              ));
            } else {
              NEXT = block.def(NEXT_STATE, ".", param);
              var ifte = env.cond(NEXT, "!==", CURRENT_STATE, ".", param);
              block(ifte);
              if (param in GL_FLAGS) {
                ifte(
                  env.cond(NEXT).then(GL2, ".enable(", GL_FLAGS[param], ");").else(GL2, ".disable(", GL_FLAGS[param], ");"),
                  CURRENT_STATE,
                  ".",
                  param,
                  "=",
                  NEXT,
                  ";"
                );
              } else {
                ifte(
                  GL2,
                  ".",
                  GL_VARIABLES[param],
                  "(",
                  NEXT,
                  ");",
                  CURRENT_STATE,
                  ".",
                  param,
                  "=",
                  NEXT,
                  ";"
                );
              }
            }
          });
          if (Object.keys(args.state).length === 0) {
            block(CURRENT_STATE, ".dirty=false;");
          }
          scope(block);
        }
        function emitSetOptions(env, scope, options, filter3) {
          var shared = env.shared;
          var CURRENT_VARS = env.current;
          var CURRENT_STATE = shared.current;
          var GL2 = shared.gl;
          sortState(Object.keys(options)).forEach(function(param) {
            var defn = options[param];
            if (filter3 && !filter3(defn)) {
              return;
            }
            var variable = defn.append(env, scope);
            if (GL_FLAGS[param]) {
              var flag = GL_FLAGS[param];
              if (isStatic(defn)) {
                if (variable) {
                  scope(GL2, ".enable(", flag, ");");
                } else {
                  scope(GL2, ".disable(", flag, ");");
                }
              } else {
                scope(env.cond(variable).then(GL2, ".enable(", flag, ");").else(GL2, ".disable(", flag, ");"));
              }
              scope(CURRENT_STATE, ".", param, "=", variable, ";");
            } else if (isArrayLike(variable)) {
              var CURRENT = CURRENT_VARS[param];
              scope(
                GL2,
                ".",
                GL_VARIABLES[param],
                "(",
                variable,
                ");",
                variable.map(function(v2, i) {
                  return CURRENT + "[" + i + "]=" + v2;
                }).join(";"),
                ";"
              );
            } else {
              scope(
                GL2,
                ".",
                GL_VARIABLES[param],
                "(",
                variable,
                ");",
                CURRENT_STATE,
                ".",
                param,
                "=",
                variable,
                ";"
              );
            }
          });
        }
        function injectExtensions(env, scope) {
          if (extInstancing) {
            env.instancing = scope.def(
              env.shared.extensions,
              ".angle_instanced_arrays"
            );
          }
        }
        function emitProfile(env, scope, args, useScope, incrementCounter) {
          var shared = env.shared;
          var STATS = env.stats;
          var CURRENT_STATE = shared.current;
          var TIMER = shared.timer;
          var profileArg = args.profile;
          function perfCounter() {
            if (typeof performance === "undefined") {
              return "Date.now()";
            } else {
              return "performance.now()";
            }
          }
          var CPU_START, QUERY_COUNTER;
          function emitProfileStart(block) {
            CPU_START = scope.def();
            block(CPU_START, "=", perfCounter(), ";");
            if (typeof incrementCounter === "string") {
              block(STATS, ".count+=", incrementCounter, ";");
            } else {
              block(STATS, ".count++;");
            }
            if (timer) {
              if (useScope) {
                QUERY_COUNTER = scope.def();
                block(QUERY_COUNTER, "=", TIMER, ".getNumPendingQueries();");
              } else {
                block(TIMER, ".beginQuery(", STATS, ");");
              }
            }
          }
          function emitProfileEnd(block) {
            block(STATS, ".cpuTime+=", perfCounter(), "-", CPU_START, ";");
            if (timer) {
              if (useScope) {
                block(
                  TIMER,
                  ".pushScopeStats(",
                  QUERY_COUNTER,
                  ",",
                  TIMER,
                  ".getNumPendingQueries(),",
                  STATS,
                  ");"
                );
              } else {
                block(TIMER, ".endQuery();");
              }
            }
          }
          function scopeProfile(value) {
            var prev = scope.def(CURRENT_STATE, ".profile");
            scope(CURRENT_STATE, ".profile=", value, ";");
            scope.exit(CURRENT_STATE, ".profile=", prev, ";");
          }
          var USE_PROFILE;
          if (profileArg) {
            if (isStatic(profileArg)) {
              if (profileArg.enable) {
                emitProfileStart(scope);
                emitProfileEnd(scope.exit);
                scopeProfile("true");
              } else {
                scopeProfile("false");
              }
              return;
            }
            USE_PROFILE = profileArg.append(env, scope);
            scopeProfile(USE_PROFILE);
          } else {
            USE_PROFILE = scope.def(CURRENT_STATE, ".profile");
          }
          var start = env.block();
          emitProfileStart(start);
          scope("if(", USE_PROFILE, "){", start, "}");
          var end = env.block();
          emitProfileEnd(end);
          scope.exit("if(", USE_PROFILE, "){", end, "}");
        }
        function emitAttributes(env, scope, args, attributes, filter3) {
          var shared = env.shared;
          function typeLength(x) {
            switch (x) {
              case GL_FLOAT_VEC2:
              case GL_INT_VEC2:
              case GL_BOOL_VEC2:
                return 2;
              case GL_FLOAT_VEC3:
              case GL_INT_VEC3:
              case GL_BOOL_VEC3:
                return 3;
              case GL_FLOAT_VEC4:
              case GL_INT_VEC4:
              case GL_BOOL_VEC4:
                return 4;
              default:
                return 1;
            }
          }
          function emitBindAttribute(ATTRIBUTE, size2, record) {
            var GL2 = shared.gl;
            var LOCATION = scope.def(ATTRIBUTE, ".location");
            var BINDING = scope.def(shared.attributes, "[", LOCATION, "]");
            var STATE = record.state;
            var BUFFER = record.buffer;
            var CONST_COMPONENTS = [
              record.x,
              record.y,
              record.z,
              record.w
            ];
            var COMMON_KEYS = [
              "buffer",
              "normalized",
              "offset",
              "stride"
            ];
            function emitBuffer() {
              scope(
                "if(!",
                BINDING,
                ".buffer){",
                GL2,
                ".enableVertexAttribArray(",
                LOCATION,
                ");}"
              );
              var TYPE = record.type;
              var SIZE;
              if (!record.size) {
                SIZE = size2;
              } else {
                SIZE = scope.def(record.size, "||", size2);
              }
              scope(
                "if(",
                BINDING,
                ".type!==",
                TYPE,
                "||",
                BINDING,
                ".size!==",
                SIZE,
                "||",
                COMMON_KEYS.map(function(key) {
                  return BINDING + "." + key + "!==" + record[key];
                }).join("||"),
                "){",
                GL2,
                ".bindBuffer(",
                GL_ARRAY_BUFFER$2,
                ",",
                BUFFER,
                ".buffer);",
                GL2,
                ".vertexAttribPointer(",
                [
                  LOCATION,
                  SIZE,
                  TYPE,
                  record.normalized,
                  record.stride,
                  record.offset
                ],
                ");",
                BINDING,
                ".type=",
                TYPE,
                ";",
                BINDING,
                ".size=",
                SIZE,
                ";",
                COMMON_KEYS.map(function(key) {
                  return BINDING + "." + key + "=" + record[key] + ";";
                }).join(""),
                "}"
              );
              if (extInstancing) {
                var DIVISOR = record.divisor;
                scope(
                  "if(",
                  BINDING,
                  ".divisor!==",
                  DIVISOR,
                  "){",
                  env.instancing,
                  ".vertexAttribDivisorANGLE(",
                  [LOCATION, DIVISOR],
                  ");",
                  BINDING,
                  ".divisor=",
                  DIVISOR,
                  ";}"
                );
              }
            }
            function emitConstant() {
              scope(
                "if(",
                BINDING,
                ".buffer){",
                GL2,
                ".disableVertexAttribArray(",
                LOCATION,
                ");",
                BINDING,
                ".buffer=null;",
                "}if(",
                CUTE_COMPONENTS.map(function(c, i) {
                  return BINDING + "." + c + "!==" + CONST_COMPONENTS[i];
                }).join("||"),
                "){",
                GL2,
                ".vertexAttrib4f(",
                LOCATION,
                ",",
                CONST_COMPONENTS,
                ");",
                CUTE_COMPONENTS.map(function(c, i) {
                  return BINDING + "." + c + "=" + CONST_COMPONENTS[i] + ";";
                }).join(""),
                "}"
              );
            }
            if (STATE === ATTRIB_STATE_POINTER) {
              emitBuffer();
            } else if (STATE === ATTRIB_STATE_CONSTANT) {
              emitConstant();
            } else {
              scope("if(", STATE, "===", ATTRIB_STATE_POINTER, "){");
              emitBuffer();
              scope("}else{");
              emitConstant();
              scope("}");
            }
          }
          attributes.forEach(function(attribute) {
            var name = attribute.name;
            var arg = args.attributes[name];
            var record;
            if (arg) {
              if (!filter3(arg)) {
                return;
              }
              record = arg.append(env, scope);
            } else {
              if (!filter3(SCOPE_DECL)) {
                return;
              }
              var scopeAttrib = env.scopeAttrib(name);
              check$1.optional(function() {
                env.assert(
                  scope,
                  scopeAttrib + ".state",
                  "missing attribute " + name
                );
              });
              record = {};
              Object.keys(new AttributeRecord2()).forEach(function(key) {
                record[key] = scope.def(scopeAttrib, ".", key);
              });
            }
            emitBindAttribute(
              env.link(attribute),
              typeLength(attribute.info.type),
              record
            );
          });
        }
        function emitUniforms(env, scope, args, uniforms, filter3) {
          var shared = env.shared;
          var GL2 = shared.gl;
          var infix;
          for (var i = 0; i < uniforms.length; ++i) {
            var uniform = uniforms[i];
            var name = uniform.name;
            var type = uniform.info.type;
            var arg = args.uniforms[name];
            var UNIFORM = env.link(uniform);
            var LOCATION = UNIFORM + ".location";
            var VALUE;
            if (arg) {
              if (!filter3(arg)) {
                continue;
              }
              if (isStatic(arg)) {
                var value = arg.value;
                check$1.command(
                  value !== null && typeof value !== "undefined",
                  'missing uniform "' + name + '"',
                  env.commandStr
                );
                if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
                  check$1.command(
                    typeof value === "function" && (type === GL_SAMPLER_2D && (value._reglType === "texture2d" || value._reglType === "framebuffer") || type === GL_SAMPLER_CUBE && (value._reglType === "textureCube" || value._reglType === "framebufferCube")),
                    "invalid texture for uniform " + name,
                    env.commandStr
                  );
                  var TEX_VALUE = env.link(value._texture || value.color[0]._texture);
                  scope(GL2, ".uniform1i(", LOCATION, ",", TEX_VALUE + ".bind());");
                  scope.exit(TEX_VALUE, ".unbind();");
                } else if (type === GL_FLOAT_MAT2 || type === GL_FLOAT_MAT3 || type === GL_FLOAT_MAT4) {
                  check$1.optional(function() {
                    check$1.command(
                      isArrayLike(value),
                      "invalid matrix for uniform " + name,
                      env.commandStr
                    );
                    check$1.command(
                      type === GL_FLOAT_MAT2 && value.length === 4 || type === GL_FLOAT_MAT3 && value.length === 9 || type === GL_FLOAT_MAT4 && value.length === 16,
                      "invalid length for matrix uniform " + name,
                      env.commandStr
                    );
                  });
                  var MAT_VALUE = env.global.def("new Float32Array([" + Array.prototype.slice.call(value) + "])");
                  var dim = 2;
                  if (type === GL_FLOAT_MAT3) {
                    dim = 3;
                  } else if (type === GL_FLOAT_MAT4) {
                    dim = 4;
                  }
                  scope(
                    GL2,
                    ".uniformMatrix",
                    dim,
                    "fv(",
                    LOCATION,
                    ",false,",
                    MAT_VALUE,
                    ");"
                  );
                } else {
                  switch (type) {
                    case GL_FLOAT$8:
                      check$1.commandType(value, "number", "uniform " + name, env.commandStr);
                      infix = "1f";
                      break;
                    case GL_FLOAT_VEC2:
                      check$1.command(
                        isArrayLike(value) && value.length === 2,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "2f";
                      break;
                    case GL_FLOAT_VEC3:
                      check$1.command(
                        isArrayLike(value) && value.length === 3,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "3f";
                      break;
                    case GL_FLOAT_VEC4:
                      check$1.command(
                        isArrayLike(value) && value.length === 4,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "4f";
                      break;
                    case GL_BOOL:
                      check$1.commandType(value, "boolean", "uniform " + name, env.commandStr);
                      infix = "1i";
                      break;
                    case GL_INT$3:
                      check$1.commandType(value, "number", "uniform " + name, env.commandStr);
                      infix = "1i";
                      break;
                    case GL_BOOL_VEC2:
                      check$1.command(
                        isArrayLike(value) && value.length === 2,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "2i";
                      break;
                    case GL_INT_VEC2:
                      check$1.command(
                        isArrayLike(value) && value.length === 2,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "2i";
                      break;
                    case GL_BOOL_VEC3:
                      check$1.command(
                        isArrayLike(value) && value.length === 3,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "3i";
                      break;
                    case GL_INT_VEC3:
                      check$1.command(
                        isArrayLike(value) && value.length === 3,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "3i";
                      break;
                    case GL_BOOL_VEC4:
                      check$1.command(
                        isArrayLike(value) && value.length === 4,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "4i";
                      break;
                    case GL_INT_VEC4:
                      check$1.command(
                        isArrayLike(value) && value.length === 4,
                        "uniform " + name,
                        env.commandStr
                      );
                      infix = "4i";
                      break;
                  }
                  scope(
                    GL2,
                    ".uniform",
                    infix,
                    "(",
                    LOCATION,
                    ",",
                    isArrayLike(value) ? Array.prototype.slice.call(value) : value,
                    ");"
                  );
                }
                continue;
              } else {
                VALUE = arg.append(env, scope);
              }
            } else {
              if (!filter3(SCOPE_DECL)) {
                continue;
              }
              VALUE = scope.def(shared.uniforms, "[", stringStore.id(name), "]");
            }
            if (type === GL_SAMPLER_2D) {
              scope(
                "if(",
                VALUE,
                "&&",
                VALUE,
                '._reglType==="framebuffer"){',
                VALUE,
                "=",
                VALUE,
                ".color[0];",
                "}"
              );
            } else if (type === GL_SAMPLER_CUBE) {
              scope(
                "if(",
                VALUE,
                "&&",
                VALUE,
                '._reglType==="framebufferCube"){',
                VALUE,
                "=",
                VALUE,
                ".color[0];",
                "}"
              );
            }
            check$1.optional(function() {
              function check2(pred, message) {
                env.assert(
                  scope,
                  pred,
                  'bad data or missing for uniform "' + name + '".  ' + message
                );
              }
              function checkType(type2) {
                check2(
                  "typeof " + VALUE + '==="' + type2 + '"',
                  "invalid type, expected " + type2
                );
              }
              function checkVector(n, type2) {
                check2(
                  shared.isArrayLike + "(" + VALUE + ")&&" + VALUE + ".length===" + n,
                  "invalid vector, should have length " + n,
                  env.commandStr
                );
              }
              function checkTexture(target) {
                check2(
                  "typeof " + VALUE + '==="function"&&' + VALUE + '._reglType==="texture' + (target === GL_TEXTURE_2D$3 ? "2d" : "Cube") + '"',
                  "invalid texture type",
                  env.commandStr
                );
              }
              switch (type) {
                case GL_INT$3:
                  checkType("number");
                  break;
                case GL_INT_VEC2:
                  checkVector(2, "number");
                  break;
                case GL_INT_VEC3:
                  checkVector(3, "number");
                  break;
                case GL_INT_VEC4:
                  checkVector(4, "number");
                  break;
                case GL_FLOAT$8:
                  checkType("number");
                  break;
                case GL_FLOAT_VEC2:
                  checkVector(2, "number");
                  break;
                case GL_FLOAT_VEC3:
                  checkVector(3, "number");
                  break;
                case GL_FLOAT_VEC4:
                  checkVector(4, "number");
                  break;
                case GL_BOOL:
                  checkType("boolean");
                  break;
                case GL_BOOL_VEC2:
                  checkVector(2, "boolean");
                  break;
                case GL_BOOL_VEC3:
                  checkVector(3, "boolean");
                  break;
                case GL_BOOL_VEC4:
                  checkVector(4, "boolean");
                  break;
                case GL_FLOAT_MAT2:
                  checkVector(4, "number");
                  break;
                case GL_FLOAT_MAT3:
                  checkVector(9, "number");
                  break;
                case GL_FLOAT_MAT4:
                  checkVector(16, "number");
                  break;
                case GL_SAMPLER_2D:
                  checkTexture(GL_TEXTURE_2D$3);
                  break;
                case GL_SAMPLER_CUBE:
                  checkTexture(GL_TEXTURE_CUBE_MAP$2);
                  break;
              }
            });
            var unroll = 1;
            switch (type) {
              case GL_SAMPLER_2D:
              case GL_SAMPLER_CUBE:
                var TEX = scope.def(VALUE, "._texture");
                scope(GL2, ".uniform1i(", LOCATION, ",", TEX, ".bind());");
                scope.exit(TEX, ".unbind();");
                continue;
              case GL_INT$3:
              case GL_BOOL:
                infix = "1i";
                break;
              case GL_INT_VEC2:
              case GL_BOOL_VEC2:
                infix = "2i";
                unroll = 2;
                break;
              case GL_INT_VEC3:
              case GL_BOOL_VEC3:
                infix = "3i";
                unroll = 3;
                break;
              case GL_INT_VEC4:
              case GL_BOOL_VEC4:
                infix = "4i";
                unroll = 4;
                break;
              case GL_FLOAT$8:
                infix = "1f";
                break;
              case GL_FLOAT_VEC2:
                infix = "2f";
                unroll = 2;
                break;
              case GL_FLOAT_VEC3:
                infix = "3f";
                unroll = 3;
                break;
              case GL_FLOAT_VEC4:
                infix = "4f";
                unroll = 4;
                break;
              case GL_FLOAT_MAT2:
                infix = "Matrix2fv";
                break;
              case GL_FLOAT_MAT3:
                infix = "Matrix3fv";
                break;
              case GL_FLOAT_MAT4:
                infix = "Matrix4fv";
                break;
            }
            scope(GL2, ".uniform", infix, "(", LOCATION, ",");
            if (infix.charAt(0) === "M") {
              var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2);
              var STORAGE = env.global.def("new Float32Array(", matSize, ")");
              scope(
                "false,(Array.isArray(",
                VALUE,
                ")||",
                VALUE,
                " instanceof Float32Array)?",
                VALUE,
                ":(",
                loop(matSize, function(i2) {
                  return STORAGE + "[" + i2 + "]=" + VALUE + "[" + i2 + "]";
                }),
                ",",
                STORAGE,
                ")"
              );
            } else if (unroll > 1) {
              scope(loop(unroll, function(i2) {
                return VALUE + "[" + i2 + "]";
              }));
            } else {
              scope(VALUE);
            }
            scope(");");
          }
        }
        function emitDraw(env, outer, inner, args) {
          var shared = env.shared;
          var GL2 = shared.gl;
          var DRAW_STATE = shared.draw;
          var drawOptions = args.draw;
          function emitElements() {
            var defn = drawOptions.elements;
            var ELEMENTS2;
            var scope = outer;
            if (defn) {
              if (defn.contextDep && args.contextDynamic || defn.propDep) {
                scope = inner;
              }
              ELEMENTS2 = defn.append(env, scope);
            } else {
              ELEMENTS2 = scope.def(DRAW_STATE, ".", S_ELEMENTS);
            }
            if (ELEMENTS2) {
              scope(
                "if(" + ELEMENTS2 + ")" + GL2 + ".bindBuffer(" + GL_ELEMENT_ARRAY_BUFFER$1 + "," + ELEMENTS2 + ".buffer.buffer);"
              );
            }
            return ELEMENTS2;
          }
          function emitCount() {
            var defn = drawOptions.count;
            var COUNT2;
            var scope = outer;
            if (defn) {
              if (defn.contextDep && args.contextDynamic || defn.propDep) {
                scope = inner;
              }
              COUNT2 = defn.append(env, scope);
              check$1.optional(function() {
                if (defn.MISSING) {
                  env.assert(outer, "false", "missing vertex count");
                }
                if (defn.DYNAMIC) {
                  env.assert(scope, COUNT2 + ">=0", "missing vertex count");
                }
              });
            } else {
              COUNT2 = scope.def(DRAW_STATE, ".", S_COUNT);
              check$1.optional(function() {
                env.assert(scope, COUNT2 + ">=0", "missing vertex count");
              });
            }
            return COUNT2;
          }
          var ELEMENTS = emitElements();
          function emitValue(name) {
            var defn = drawOptions[name];
            if (defn) {
              if (defn.contextDep && args.contextDynamic || defn.propDep) {
                return defn.append(env, inner);
              } else {
                return defn.append(env, outer);
              }
            } else {
              return outer.def(DRAW_STATE, ".", name);
            }
          }
          var PRIMITIVE = emitValue(S_PRIMITIVE);
          var OFFSET = emitValue(S_OFFSET);
          var COUNT = emitCount();
          if (typeof COUNT === "number") {
            if (COUNT === 0) {
              return;
            }
          } else {
            inner("if(", COUNT, "){");
            inner.exit("}");
          }
          var INSTANCES, EXT_INSTANCING;
          if (extInstancing) {
            INSTANCES = emitValue(S_INSTANCES);
            EXT_INSTANCING = env.instancing;
          }
          var ELEMENT_TYPE = ELEMENTS + ".type";
          var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements);
          function emitInstancing() {
            function drawElements() {
              inner(EXT_INSTANCING, ".drawElementsInstancedANGLE(", [
                PRIMITIVE,
                COUNT,
                ELEMENT_TYPE,
                OFFSET + "<<((" + ELEMENT_TYPE + "-" + GL_UNSIGNED_BYTE$8 + ")>>1)",
                INSTANCES
              ], ");");
            }
            function drawArrays() {
              inner(
                EXT_INSTANCING,
                ".drawArraysInstancedANGLE(",
                [PRIMITIVE, OFFSET, COUNT, INSTANCES],
                ");"
              );
            }
            if (ELEMENTS) {
              if (!elementsStatic) {
                inner("if(", ELEMENTS, "){");
                drawElements();
                inner("}else{");
                drawArrays();
                inner("}");
              } else {
                drawElements();
              }
            } else {
              drawArrays();
            }
          }
          function emitRegular() {
            function drawElements() {
              inner(GL2 + ".drawElements(" + [
                PRIMITIVE,
                COUNT,
                ELEMENT_TYPE,
                OFFSET + "<<((" + ELEMENT_TYPE + "-" + GL_UNSIGNED_BYTE$8 + ")>>1)"
              ] + ");");
            }
            function drawArrays() {
              inner(GL2 + ".drawArrays(" + [PRIMITIVE, OFFSET, COUNT] + ");");
            }
            if (ELEMENTS) {
              if (!elementsStatic) {
                inner("if(", ELEMENTS, "){");
                drawElements();
                inner("}else{");
                drawArrays();
                inner("}");
              } else {
                drawElements();
              }
            } else {
              drawArrays();
            }
          }
          if (extInstancing && (typeof INSTANCES !== "number" || INSTANCES >= 0)) {
            if (typeof INSTANCES === "string") {
              inner("if(", INSTANCES, ">0){");
              emitInstancing();
              inner("}else if(", INSTANCES, "<0){");
              emitRegular();
              inner("}");
            } else {
              emitInstancing();
            }
          } else {
            emitRegular();
          }
        }
        function createBody(emitBody, parentEnv, args, program, count2) {
          var env = createREGLEnvironment();
          var scope = env.proc("body", count2);
          check$1.optional(function() {
            env.commandStr = parentEnv.commandStr;
            env.command = env.link(parentEnv.commandStr);
          });
          if (extInstancing) {
            env.instancing = scope.def(
              env.shared.extensions,
              ".angle_instanced_arrays"
            );
          }
          emitBody(env, scope, args, program);
          return env.compile().body;
        }
        function emitDrawBody(env, draw, args, program) {
          injectExtensions(env, draw);
          if (args.useVAO) {
            if (args.drawVAO) {
              draw(env.shared.vao, ".setVAO(", args.drawVAO.append(env, draw), ");");
            } else {
              draw(env.shared.vao, ".setVAO(", env.shared.vao, ".targetVAO);");
            }
          } else {
            draw(env.shared.vao, ".setVAO(null);");
            emitAttributes(env, draw, args, program.attributes, function() {
              return true;
            });
          }
          emitUniforms(env, draw, args, program.uniforms, function() {
            return true;
          });
          emitDraw(env, draw, draw, args);
        }
        function emitDrawProc(env, args) {
          var draw = env.proc("draw", 1);
          injectExtensions(env, draw);
          emitContext(env, draw, args.context);
          emitPollFramebuffer(env, draw, args.framebuffer);
          emitPollState(env, draw, args);
          emitSetOptions(env, draw, args.state);
          emitProfile(env, draw, args, false, true);
          var program = args.shader.progVar.append(env, draw);
          draw(env.shared.gl, ".useProgram(", program, ".program);");
          if (args.shader.program) {
            emitDrawBody(env, draw, args, args.shader.program);
          } else {
            draw(env.shared.vao, ".setVAO(null);");
            var drawCache = env.global.def("{}");
            var PROG_ID = draw.def(program, ".id");
            var CACHED_PROC = draw.def(drawCache, "[", PROG_ID, "]");
            draw(
              env.cond(CACHED_PROC).then(CACHED_PROC, ".call(this,a0);").else(
                CACHED_PROC,
                "=",
                drawCache,
                "[",
                PROG_ID,
                "]=",
                env.link(function(program2) {
                  return createBody(emitDrawBody, env, args, program2, 1);
                }),
                "(",
                program,
                ");",
                CACHED_PROC,
                ".call(this,a0);"
              )
            );
          }
          if (Object.keys(args.state).length > 0) {
            draw(env.shared.current, ".dirty=true;");
          }
        }
        function emitBatchDynamicShaderBody(env, scope, args, program) {
          env.batchId = "a1";
          injectExtensions(env, scope);
          function all() {
            return true;
          }
          emitAttributes(env, scope, args, program.attributes, all);
          emitUniforms(env, scope, args, program.uniforms, all);
          emitDraw(env, scope, scope, args);
        }
        function emitBatchBody(env, scope, args, program) {
          injectExtensions(env, scope);
          var contextDynamic = args.contextDep;
          var BATCH_ID = scope.def();
          var PROP_LIST = "a0";
          var NUM_PROPS = "a1";
          var PROPS = scope.def();
          env.shared.props = PROPS;
          env.batchId = BATCH_ID;
          var outer = env.scope();
          var inner = env.scope();
          scope(
            outer.entry,
            "for(",
            BATCH_ID,
            "=0;",
            BATCH_ID,
            "<",
            NUM_PROPS,
            ";++",
            BATCH_ID,
            "){",
            PROPS,
            "=",
            PROP_LIST,
            "[",
            BATCH_ID,
            "];",
            inner,
            "}",
            outer.exit
          );
          function isInnerDefn(defn) {
            return defn.contextDep && contextDynamic || defn.propDep;
          }
          function isOuterDefn(defn) {
            return !isInnerDefn(defn);
          }
          if (args.needsContext) {
            emitContext(env, inner, args.context);
          }
          if (args.needsFramebuffer) {
            emitPollFramebuffer(env, inner, args.framebuffer);
          }
          emitSetOptions(env, inner, args.state, isInnerDefn);
          if (args.profile && isInnerDefn(args.profile)) {
            emitProfile(env, inner, args, false, true);
          }
          if (!program) {
            var progCache = env.global.def("{}");
            var PROGRAM = args.shader.progVar.append(env, inner);
            var PROG_ID = inner.def(PROGRAM, ".id");
            var CACHED_PROC = inner.def(progCache, "[", PROG_ID, "]");
            inner(
              env.shared.gl,
              ".useProgram(",
              PROGRAM,
              ".program);",
              "if(!",
              CACHED_PROC,
              "){",
              CACHED_PROC,
              "=",
              progCache,
              "[",
              PROG_ID,
              "]=",
              env.link(function(program2) {
                return createBody(
                  emitBatchDynamicShaderBody,
                  env,
                  args,
                  program2,
                  2
                );
              }),
              "(",
              PROGRAM,
              ");}",
              CACHED_PROC,
              ".call(this,a0[",
              BATCH_ID,
              "],",
              BATCH_ID,
              ");"
            );
          } else {
            if (args.useVAO) {
              if (args.drawVAO) {
                if (isInnerDefn(args.drawVAO)) {
                  inner(env.shared.vao, ".setVAO(", args.drawVAO.append(env, inner), ");");
                } else {
                  outer(env.shared.vao, ".setVAO(", args.drawVAO.append(env, outer), ");");
                }
              } else {
                outer(env.shared.vao, ".setVAO(", env.shared.vao, ".targetVAO);");
              }
            } else {
              outer(env.shared.vao, ".setVAO(null);");
              emitAttributes(env, outer, args, program.attributes, isOuterDefn);
              emitAttributes(env, inner, args, program.attributes, isInnerDefn);
            }
            emitUniforms(env, outer, args, program.uniforms, isOuterDefn);
            emitUniforms(env, inner, args, program.uniforms, isInnerDefn);
            emitDraw(env, outer, inner, args);
          }
        }
        function emitBatchProc(env, args) {
          var batch = env.proc("batch", 2);
          env.batchId = "0";
          injectExtensions(env, batch);
          var contextDynamic = false;
          var needsContext = true;
          Object.keys(args.context).forEach(function(name) {
            contextDynamic = contextDynamic || args.context[name].propDep;
          });
          if (!contextDynamic) {
            emitContext(env, batch, args.context);
            needsContext = false;
          }
          var framebuffer = args.framebuffer;
          var needsFramebuffer = false;
          if (framebuffer) {
            if (framebuffer.propDep) {
              contextDynamic = needsFramebuffer = true;
            } else if (framebuffer.contextDep && contextDynamic) {
              needsFramebuffer = true;
            }
            if (!needsFramebuffer) {
              emitPollFramebuffer(env, batch, framebuffer);
            }
          } else {
            emitPollFramebuffer(env, batch, null);
          }
          if (args.state.viewport && args.state.viewport.propDep) {
            contextDynamic = true;
          }
          function isInnerDefn(defn) {
            return defn.contextDep && contextDynamic || defn.propDep;
          }
          emitPollState(env, batch, args);
          emitSetOptions(env, batch, args.state, function(defn) {
            return !isInnerDefn(defn);
          });
          if (!args.profile || !isInnerDefn(args.profile)) {
            emitProfile(env, batch, args, false, "a1");
          }
          args.contextDep = contextDynamic;
          args.needsContext = needsContext;
          args.needsFramebuffer = needsFramebuffer;
          var progDefn = args.shader.progVar;
          if (progDefn.contextDep && contextDynamic || progDefn.propDep) {
            emitBatchBody(
              env,
              batch,
              args,
              null
            );
          } else {
            var PROGRAM = progDefn.append(env, batch);
            batch(env.shared.gl, ".useProgram(", PROGRAM, ".program);");
            if (args.shader.program) {
              emitBatchBody(
                env,
                batch,
                args,
                args.shader.program
              );
            } else {
              batch(env.shared.vao, ".setVAO(null);");
              var batchCache = env.global.def("{}");
              var PROG_ID = batch.def(PROGRAM, ".id");
              var CACHED_PROC = batch.def(batchCache, "[", PROG_ID, "]");
              batch(
                env.cond(CACHED_PROC).then(CACHED_PROC, ".call(this,a0,a1);").else(
                  CACHED_PROC,
                  "=",
                  batchCache,
                  "[",
                  PROG_ID,
                  "]=",
                  env.link(function(program) {
                    return createBody(emitBatchBody, env, args, program, 2);
                  }),
                  "(",
                  PROGRAM,
                  ");",
                  CACHED_PROC,
                  ".call(this,a0,a1);"
                )
              );
            }
          }
          if (Object.keys(args.state).length > 0) {
            batch(env.shared.current, ".dirty=true;");
          }
        }
        function emitScopeProc(env, args) {
          var scope = env.proc("scope", 3);
          env.batchId = "a2";
          var shared = env.shared;
          var CURRENT_STATE = shared.current;
          emitContext(env, scope, args.context);
          if (args.framebuffer) {
            args.framebuffer.append(env, scope);
          }
          sortState(Object.keys(args.state)).forEach(function(name) {
            var defn = args.state[name];
            var value = defn.append(env, scope);
            if (isArrayLike(value)) {
              value.forEach(function(v2, i) {
                scope.set(env.next[name], "[" + i + "]", v2);
              });
            } else {
              scope.set(shared.next, "." + name, value);
            }
          });
          emitProfile(env, scope, args, true, true);
          [S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
            function(opt) {
              var variable = args.draw[opt];
              if (!variable) {
                return;
              }
              scope.set(shared.draw, "." + opt, "" + variable.append(env, scope));
            }
          );
          Object.keys(args.uniforms).forEach(function(opt) {
            scope.set(
              shared.uniforms,
              "[" + stringStore.id(opt) + "]",
              args.uniforms[opt].append(env, scope)
            );
          });
          Object.keys(args.attributes).forEach(function(name) {
            var record = args.attributes[name].append(env, scope);
            var scopeAttrib = env.scopeAttrib(name);
            Object.keys(new AttributeRecord2()).forEach(function(prop) {
              scope.set(scopeAttrib, "." + prop, record[prop]);
            });
          });
          if (args.scopeVAO) {
            scope.set(shared.vao, ".targetVAO", args.scopeVAO.append(env, scope));
          }
          function saveShader(name) {
            var shader = args.shader[name];
            if (shader) {
              scope.set(shared.shader, "." + name, shader.append(env, scope));
            }
          }
          saveShader(S_VERT);
          saveShader(S_FRAG);
          if (Object.keys(args.state).length > 0) {
            scope(CURRENT_STATE, ".dirty=true;");
            scope.exit(CURRENT_STATE, ".dirty=true;");
          }
          scope("a1(", env.shared.context, ",a0,", env.batchId, ");");
        }
        function isDynamicObject(object) {
          if (typeof object !== "object" || isArrayLike(object)) {
            return;
          }
          var props = Object.keys(object);
          for (var i = 0; i < props.length; ++i) {
            if (dynamic.isDynamic(object[props[i]])) {
              return true;
            }
          }
          return false;
        }
        function splatObject(env, options, name) {
          var object = options.static[name];
          if (!object || !isDynamicObject(object)) {
            return;
          }
          var globals = env.global;
          var keys = Object.keys(object);
          var thisDep = false;
          var contextDep = false;
          var propDep = false;
          var objectRef = env.global.def("{}");
          keys.forEach(function(key) {
            var value = object[key];
            if (dynamic.isDynamic(value)) {
              if (typeof value === "function") {
                value = object[key] = dynamic.unbox(value);
              }
              var deps = createDynamicDecl(value, null);
              thisDep = thisDep || deps.thisDep;
              propDep = propDep || deps.propDep;
              contextDep = contextDep || deps.contextDep;
            } else {
              globals(objectRef, ".", key, "=");
              switch (typeof value) {
                case "number":
                  globals(value);
                  break;
                case "string":
                  globals('"', value, '"');
                  break;
                case "object":
                  if (Array.isArray(value)) {
                    globals("[", value.join(), "]");
                  }
                  break;
                default:
                  globals(env.link(value));
                  break;
              }
              globals(";");
            }
          });
          function appendBlock(env2, block) {
            keys.forEach(function(key) {
              var value = object[key];
              if (!dynamic.isDynamic(value)) {
                return;
              }
              var ref = env2.invoke(block, value);
              block(objectRef, ".", key, "=", ref, ";");
            });
          }
          options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
            thisDep,
            contextDep,
            propDep,
            ref: objectRef,
            append: appendBlock
          });
          delete options.static[name];
        }
        function compileCommand(options, attributes, uniforms, context, stats2) {
          var env = createREGLEnvironment();
          env.stats = env.link(stats2);
          Object.keys(attributes.static).forEach(function(key) {
            splatObject(env, attributes, key);
          });
          NESTED_OPTIONS.forEach(function(name) {
            splatObject(env, options, name);
          });
          var args = parseArguments(options, attributes, uniforms, context, env);
          emitDrawProc(env, args);
          emitScopeProc(env, args);
          emitBatchProc(env, args);
          return env.compile();
        }
        return {
          next: nextState,
          current: currentState,
          procs: function() {
            var env = createREGLEnvironment();
            var poll = env.proc("poll");
            var refresh = env.proc("refresh");
            var common = env.block();
            poll(common);
            refresh(common);
            var shared = env.shared;
            var GL2 = shared.gl;
            var NEXT_STATE = shared.next;
            var CURRENT_STATE = shared.current;
            common(CURRENT_STATE, ".dirty=false;");
            emitPollFramebuffer(env, poll);
            emitPollFramebuffer(env, refresh, null, true);
            var INSTANCING;
            if (extInstancing) {
              INSTANCING = env.link(extInstancing);
            }
            if (extensions.oes_vertex_array_object) {
              refresh(env.link(extensions.oes_vertex_array_object), ".bindVertexArrayOES(null);");
            }
            for (var i = 0; i < limits.maxAttributes; ++i) {
              var BINDING = refresh.def(shared.attributes, "[", i, "]");
              var ifte = env.cond(BINDING, ".buffer");
              ifte.then(
                GL2,
                ".enableVertexAttribArray(",
                i,
                ");",
                GL2,
                ".bindBuffer(",
                GL_ARRAY_BUFFER$2,
                ",",
                BINDING,
                ".buffer.buffer);",
                GL2,
                ".vertexAttribPointer(",
                i,
                ",",
                BINDING,
                ".size,",
                BINDING,
                ".type,",
                BINDING,
                ".normalized,",
                BINDING,
                ".stride,",
                BINDING,
                ".offset);"
              ).else(
                GL2,
                ".disableVertexAttribArray(",
                i,
                ");",
                GL2,
                ".vertexAttrib4f(",
                i,
                ",",
                BINDING,
                ".x,",
                BINDING,
                ".y,",
                BINDING,
                ".z,",
                BINDING,
                ".w);",
                BINDING,
                ".buffer=null;"
              );
              refresh(ifte);
              if (extInstancing) {
                refresh(
                  INSTANCING,
                  ".vertexAttribDivisorANGLE(",
                  i,
                  ",",
                  BINDING,
                  ".divisor);"
                );
              }
            }
            refresh(
              env.shared.vao,
              ".currentVAO=null;",
              env.shared.vao,
              ".setVAO(",
              env.shared.vao,
              ".targetVAO);"
            );
            Object.keys(GL_FLAGS).forEach(function(flag) {
              var cap = GL_FLAGS[flag];
              var NEXT = common.def(NEXT_STATE, ".", flag);
              var block = env.block();
              block(
                "if(",
                NEXT,
                "){",
                GL2,
                ".enable(",
                cap,
                ")}else{",
                GL2,
                ".disable(",
                cap,
                ")}",
                CURRENT_STATE,
                ".",
                flag,
                "=",
                NEXT,
                ";"
              );
              refresh(block);
              poll(
                "if(",
                NEXT,
                "!==",
                CURRENT_STATE,
                ".",
                flag,
                "){",
                block,
                "}"
              );
            });
            Object.keys(GL_VARIABLES).forEach(function(name) {
              var func = GL_VARIABLES[name];
              var init = currentState[name];
              var NEXT, CURRENT;
              var block = env.block();
              block(GL2, ".", func, "(");
              if (isArrayLike(init)) {
                var n = init.length;
                NEXT = env.global.def(NEXT_STATE, ".", name);
                CURRENT = env.global.def(CURRENT_STATE, ".", name);
                block(
                  loop(n, function(i2) {
                    return NEXT + "[" + i2 + "]";
                  }),
                  ");",
                  loop(n, function(i2) {
                    return CURRENT + "[" + i2 + "]=" + NEXT + "[" + i2 + "];";
                  }).join("")
                );
                poll(
                  "if(",
                  loop(n, function(i2) {
                    return NEXT + "[" + i2 + "]!==" + CURRENT + "[" + i2 + "]";
                  }).join("||"),
                  "){",
                  block,
                  "}"
                );
              } else {
                NEXT = common.def(NEXT_STATE, ".", name);
                CURRENT = common.def(CURRENT_STATE, ".", name);
                block(
                  NEXT,
                  ");",
                  CURRENT_STATE,
                  ".",
                  name,
                  "=",
                  NEXT,
                  ";"
                );
                poll(
                  "if(",
                  NEXT,
                  "!==",
                  CURRENT,
                  "){",
                  block,
                  "}"
                );
              }
              refresh(block);
            });
            return env.compile();
          }(),
          compile: compileCommand
        };
      }
      function stats() {
        return {
          vaoCount: 0,
          bufferCount: 0,
          elementsCount: 0,
          framebufferCount: 0,
          shaderCount: 0,
          textureCount: 0,
          cubeCount: 0,
          renderbufferCount: 0,
          maxTextureUnits: 0
        };
      }
      var GL_QUERY_RESULT_EXT = 34918;
      var GL_QUERY_RESULT_AVAILABLE_EXT = 34919;
      var GL_TIME_ELAPSED_EXT = 35007;
      var createTimer = function(gl2, extensions) {
        if (!extensions.ext_disjoint_timer_query) {
          return null;
        }
        var queryPool = [];
        function allocQuery() {
          return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT();
        }
        function freeQuery(query) {
          queryPool.push(query);
        }
        var pendingQueries = [];
        function beginQuery(stats2) {
          var query = allocQuery();
          extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query);
          pendingQueries.push(query);
          pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats2);
        }
        function endQuery() {
          extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT);
        }
        function PendingStats() {
          this.startQueryIndex = -1;
          this.endQueryIndex = -1;
          this.sum = 0;
          this.stats = null;
        }
        var pendingStatsPool = [];
        function allocPendingStats() {
          return pendingStatsPool.pop() || new PendingStats();
        }
        function freePendingStats(pendingStats2) {
          pendingStatsPool.push(pendingStats2);
        }
        var pendingStats = [];
        function pushScopeStats(start, end, stats2) {
          var ps = allocPendingStats();
          ps.startQueryIndex = start;
          ps.endQueryIndex = end;
          ps.sum = 0;
          ps.stats = stats2;
          pendingStats.push(ps);
        }
        var timeSum = [];
        var queryPtr = [];
        function update() {
          var ptr, i;
          var n = pendingQueries.length;
          if (n === 0) {
            return;
          }
          queryPtr.length = Math.max(queryPtr.length, n + 1);
          timeSum.length = Math.max(timeSum.length, n + 1);
          timeSum[0] = 0;
          queryPtr[0] = 0;
          var queryTime = 0;
          ptr = 0;
          for (i = 0; i < pendingQueries.length; ++i) {
            var query = pendingQueries[i];
            if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
              queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT);
              freeQuery(query);
            } else {
              pendingQueries[ptr++] = query;
            }
            timeSum[i + 1] = queryTime;
            queryPtr[i + 1] = ptr;
          }
          pendingQueries.length = ptr;
          ptr = 0;
          for (i = 0; i < pendingStats.length; ++i) {
            var stats2 = pendingStats[i];
            var start = stats2.startQueryIndex;
            var end = stats2.endQueryIndex;
            stats2.sum += timeSum[end] - timeSum[start];
            var startPtr = queryPtr[start];
            var endPtr = queryPtr[end];
            if (endPtr === startPtr) {
              stats2.stats.gpuTime += stats2.sum / 1e6;
              freePendingStats(stats2);
            } else {
              stats2.startQueryIndex = startPtr;
              stats2.endQueryIndex = endPtr;
              pendingStats[ptr++] = stats2;
            }
          }
          pendingStats.length = ptr;
        }
        return {
          beginQuery,
          endQuery,
          pushScopeStats,
          update,
          getNumPendingQueries: function() {
            return pendingQueries.length;
          },
          clear: function() {
            queryPool.push.apply(queryPool, pendingQueries);
            for (var i = 0; i < queryPool.length; i++) {
              extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i]);
            }
            pendingQueries.length = 0;
            queryPool.length = 0;
          },
          restore: function() {
            pendingQueries.length = 0;
            queryPool.length = 0;
          }
        };
      };
      var GL_COLOR_BUFFER_BIT = 16384;
      var GL_DEPTH_BUFFER_BIT = 256;
      var GL_STENCIL_BUFFER_BIT = 1024;
      var GL_ARRAY_BUFFER = 34962;
      var CONTEXT_LOST_EVENT = "webglcontextlost";
      var CONTEXT_RESTORED_EVENT = "webglcontextrestored";
      var DYN_PROP = 1;
      var DYN_CONTEXT = 2;
      var DYN_STATE = 3;
      function find(haystack, needle) {
        for (var i = 0; i < haystack.length; ++i) {
          if (haystack[i] === needle) {
            return i;
          }
        }
        return -1;
      }
      function wrapREGL(args) {
        var config = parseArgs(args);
        if (!config) {
          return null;
        }
        var gl2 = config.gl;
        var glAttributes = gl2.getContextAttributes();
        var contextLost = gl2.isContextLost();
        var extensionState = createExtensionCache(gl2, config);
        if (!extensionState) {
          return null;
        }
        var stringStore = createStringStore();
        var stats$$1 = stats();
        var extensions = extensionState.extensions;
        var timer = createTimer(gl2, extensions);
        var START_TIME = clock();
        var WIDTH = gl2.drawingBufferWidth;
        var HEIGHT = gl2.drawingBufferHeight;
        var contextState = {
          tick: 0,
          time: 0,
          viewportWidth: WIDTH,
          viewportHeight: HEIGHT,
          framebufferWidth: WIDTH,
          framebufferHeight: HEIGHT,
          drawingBufferWidth: WIDTH,
          drawingBufferHeight: HEIGHT,
          pixelRatio: config.pixelRatio
        };
        var uniformState = {};
        var drawState = {
          elements: null,
          primitive: 4,
          // GL_TRIANGLES
          count: -1,
          offset: 0,
          instances: -1
        };
        var limits = wrapLimits(gl2, extensions);
        var bufferState = wrapBufferState(
          gl2,
          stats$$1,
          config,
          destroyBuffer
        );
        var attributeState = wrapAttributeState(
          gl2,
          extensions,
          limits,
          stats$$1,
          bufferState
        );
        function destroyBuffer(buffer) {
          return attributeState.destroyBuffer(buffer);
        }
        var elementState = wrapElementsState(gl2, extensions, bufferState, stats$$1);
        var shaderState = wrapShaderState(gl2, stringStore, stats$$1, config);
        var textureState = createTextureSet(
          gl2,
          extensions,
          limits,
          function() {
            core.procs.poll();
          },
          contextState,
          stats$$1,
          config
        );
        var renderbufferState = wrapRenderbuffers(gl2, extensions, limits, stats$$1, config);
        var framebufferState = wrapFBOState(
          gl2,
          extensions,
          limits,
          textureState,
          renderbufferState,
          stats$$1
        );
        var core = reglCore(
          gl2,
          stringStore,
          extensions,
          limits,
          bufferState,
          elementState,
          textureState,
          framebufferState,
          uniformState,
          attributeState,
          shaderState,
          drawState,
          contextState,
          timer,
          config
        );
        var readPixels = wrapReadPixels(
          gl2,
          framebufferState,
          core.procs.poll,
          contextState,
          glAttributes,
          extensions,
          limits
        );
        var nextState = core.next;
        var canvas = gl2.canvas;
        var rafCallbacks = [];
        var lossCallbacks = [];
        var restoreCallbacks = [];
        var destroyCallbacks = [config.onDestroy];
        var activeRAF = null;
        function handleRAF() {
          if (rafCallbacks.length === 0) {
            if (timer) {
              timer.update();
            }
            activeRAF = null;
            return;
          }
          activeRAF = raf.next(handleRAF);
          poll();
          for (var i = rafCallbacks.length - 1; i >= 0; --i) {
            var cb = rafCallbacks[i];
            if (cb) {
              cb(contextState, null, 0);
            }
          }
          gl2.flush();
          if (timer) {
            timer.update();
          }
        }
        function startRAF() {
          if (!activeRAF && rafCallbacks.length > 0) {
            activeRAF = raf.next(handleRAF);
          }
        }
        function stopRAF() {
          if (activeRAF) {
            raf.cancel(handleRAF);
            activeRAF = null;
          }
        }
        function handleContextLoss(event) {
          event.preventDefault();
          contextLost = true;
          stopRAF();
          lossCallbacks.forEach(function(cb) {
            cb();
          });
        }
        function handleContextRestored(event) {
          gl2.getError();
          contextLost = false;
          extensionState.restore();
          shaderState.restore();
          bufferState.restore();
          textureState.restore();
          renderbufferState.restore();
          framebufferState.restore();
          attributeState.restore();
          if (timer) {
            timer.restore();
          }
          core.procs.refresh();
          startRAF();
          restoreCallbacks.forEach(function(cb) {
            cb();
          });
        }
        if (canvas) {
          canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false);
          canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false);
        }
        function destroy() {
          rafCallbacks.length = 0;
          stopRAF();
          if (canvas) {
            canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss);
            canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored);
          }
          shaderState.clear();
          framebufferState.clear();
          renderbufferState.clear();
          textureState.clear();
          elementState.clear();
          bufferState.clear();
          attributeState.clear();
          if (timer) {
            timer.clear();
          }
          destroyCallbacks.forEach(function(cb) {
            cb();
          });
        }
        function compileProcedure(options) {
          check$1(!!options, "invalid args to regl({...})");
          check$1.type(options, "object", "invalid args to regl({...})");
          function flattenNestedOptions(options2) {
            var result = extend2({}, options2);
            delete result.uniforms;
            delete result.attributes;
            delete result.context;
            delete result.vao;
            if ("stencil" in result && result.stencil.op) {
              result.stencil.opBack = result.stencil.opFront = result.stencil.op;
              delete result.stencil.op;
            }
            function merge4(name) {
              if (name in result) {
                var child = result[name];
                delete result[name];
                Object.keys(child).forEach(function(prop) {
                  result[name + "." + prop] = child[prop];
                });
              }
            }
            merge4("blend");
            merge4("depth");
            merge4("cull");
            merge4("stencil");
            merge4("polygonOffset");
            merge4("scissor");
            merge4("sample");
            if ("vao" in options2) {
              result.vao = options2.vao;
            }
            return result;
          }
          function separateDynamic(object) {
            var staticItems = {};
            var dynamicItems = {};
            Object.keys(object).forEach(function(option) {
              var value = object[option];
              if (dynamic.isDynamic(value)) {
                dynamicItems[option] = dynamic.unbox(value, option);
              } else {
                staticItems[option] = value;
              }
            });
            return {
              dynamic: dynamicItems,
              static: staticItems
            };
          }
          var context = separateDynamic(options.context || {});
          var uniforms = separateDynamic(options.uniforms || {});
          var attributes = separateDynamic(options.attributes || {});
          var opts = separateDynamic(flattenNestedOptions(options));
          var stats$$12 = {
            gpuTime: 0,
            cpuTime: 0,
            count: 0
          };
          var compiled = core.compile(opts, attributes, uniforms, context, stats$$12);
          var draw = compiled.draw;
          var batch = compiled.batch;
          var scope = compiled.scope;
          var EMPTY_ARRAY = [];
          function reserve(count2) {
            while (EMPTY_ARRAY.length < count2) {
              EMPTY_ARRAY.push(null);
            }
            return EMPTY_ARRAY;
          }
          function REGLCommand(args2, body) {
            var i;
            if (contextLost) {
              check$1.raise("context lost");
            }
            if (typeof args2 === "function") {
              return scope.call(this, null, args2, 0);
            } else if (typeof body === "function") {
              if (typeof args2 === "number") {
                for (i = 0; i < args2; ++i) {
                  scope.call(this, null, body, i);
                }
              } else if (Array.isArray(args2)) {
                for (i = 0; i < args2.length; ++i) {
                  scope.call(this, args2[i], body, i);
                }
              } else {
                return scope.call(this, args2, body, 0);
              }
            } else if (typeof args2 === "number") {
              if (args2 > 0) {
                return batch.call(this, reserve(args2 | 0), args2 | 0);
              }
            } else if (Array.isArray(args2)) {
              if (args2.length) {
                return batch.call(this, args2, args2.length);
              }
            } else {
              return draw.call(this, args2);
            }
          }
          return extend2(REGLCommand, {
            stats: stats$$12
          });
        }
        var setFBO = framebufferState.setFBO = compileProcedure({
          framebuffer: dynamic.define.call(null, DYN_PROP, "framebuffer")
        });
        function clearImpl(_, options) {
          var clearFlags = 0;
          core.procs.poll();
          var c = options.color;
          if (c) {
            gl2.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0);
            clearFlags |= GL_COLOR_BUFFER_BIT;
          }
          if ("depth" in options) {
            gl2.clearDepth(+options.depth);
            clearFlags |= GL_DEPTH_BUFFER_BIT;
          }
          if ("stencil" in options) {
            gl2.clearStencil(options.stencil | 0);
            clearFlags |= GL_STENCIL_BUFFER_BIT;
          }
          check$1(!!clearFlags, "called regl.clear with no buffer specified");
          gl2.clear(clearFlags);
        }
        function clear(options) {
          check$1(
            typeof options === "object" && options,
            "regl.clear() takes an object as input"
          );
          if ("framebuffer" in options) {
            if (options.framebuffer && options.framebuffer_reglType === "framebufferCube") {
              for (var i = 0; i < 6; ++i) {
                setFBO(extend2({
                  framebuffer: options.framebuffer.faces[i]
                }, options), clearImpl);
              }
            } else {
              setFBO(options, clearImpl);
            }
          } else {
            clearImpl(null, options);
          }
        }
        function frame(cb) {
          check$1.type(cb, "function", "regl.frame() callback must be a function");
          rafCallbacks.push(cb);
          function cancel() {
            var i = find(rafCallbacks, cb);
            check$1(i >= 0, "cannot cancel a frame twice");
            function pendingCancel() {
              var index3 = find(rafCallbacks, pendingCancel);
              rafCallbacks[index3] = rafCallbacks[rafCallbacks.length - 1];
              rafCallbacks.length -= 1;
              if (rafCallbacks.length <= 0) {
                stopRAF();
              }
            }
            rafCallbacks[i] = pendingCancel;
          }
          startRAF();
          return {
            cancel
          };
        }
        function pollViewport() {
          var viewport = nextState.viewport;
          var scissorBox = nextState.scissor_box;
          viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0;
          contextState.viewportWidth = contextState.framebufferWidth = contextState.drawingBufferWidth = viewport[2] = scissorBox[2] = gl2.drawingBufferWidth;
          contextState.viewportHeight = contextState.framebufferHeight = contextState.drawingBufferHeight = viewport[3] = scissorBox[3] = gl2.drawingBufferHeight;
        }
        function poll() {
          contextState.tick += 1;
          contextState.time = now();
          pollViewport();
          core.procs.poll();
        }
        function refresh() {
          pollViewport();
          core.procs.refresh();
          if (timer) {
            timer.update();
          }
        }
        function now() {
          return (clock() - START_TIME) / 1e3;
        }
        refresh();
        function addListener(event, callback) {
          check$1.type(callback, "function", "listener callback must be a function");
          var callbacks;
          switch (event) {
            case "frame":
              return frame(callback);
            case "lost":
              callbacks = lossCallbacks;
              break;
            case "restore":
              callbacks = restoreCallbacks;
              break;
            case "destroy":
              callbacks = destroyCallbacks;
              break;
            default:
              check$1.raise("invalid event, must be one of frame,lost,restore,destroy");
          }
          callbacks.push(callback);
          return {
            cancel: function() {
              for (var i = 0; i < callbacks.length; ++i) {
                if (callbacks[i] === callback) {
                  callbacks[i] = callbacks[callbacks.length - 1];
                  callbacks.pop();
                  return;
                }
              }
            }
          };
        }
        var regl2 = extend2(compileProcedure, {
          // Clear current FBO
          clear,
          // Short cuts for dynamic variables
          prop: dynamic.define.bind(null, DYN_PROP),
          context: dynamic.define.bind(null, DYN_CONTEXT),
          this: dynamic.define.bind(null, DYN_STATE),
          // executes an empty draw command
          draw: compileProcedure({}),
          // Resources
          buffer: function(options) {
            return bufferState.create(options, GL_ARRAY_BUFFER, false, false);
          },
          elements: function(options) {
            return elementState.create(options, false);
          },
          texture: textureState.create2D,
          cube: textureState.createCube,
          renderbuffer: renderbufferState.create,
          framebuffer: framebufferState.create,
          framebufferCube: framebufferState.createCube,
          vao: attributeState.createVAO,
          // Expose context attributes
          attributes: glAttributes,
          // Frame rendering
          frame,
          on: addListener,
          // System limits
          limits,
          hasExtension: function(name) {
            return limits.extensions.indexOf(name.toLowerCase()) >= 0;
          },
          // Read pixels
          read: readPixels,
          // Destroy regl and all associated resources
          destroy,
          // Direct GL state manipulation
          _gl: gl2,
          _refresh: refresh,
          poll: function() {
            poll();
            if (timer) {
              timer.update();
            }
          },
          // Current time
          now,
          // regl Statistics Information
          stats: stats$$1
        });
        config.onDone(null, regl2);
        return regl2;
      }
      return wrapREGL;
    });
  }
});

// node_modules/@antv/l7-source/es/factory.js
var TRANSFORMS = {};
var PARSERS = {};
var getParser = (type) => PARSERS[type];
var registerParser = (type, parserFunction) => {
  PARSERS[type] = parserFunction;
};
var getTransform = (type) => TRANSFORMS[type];
var registerTransform = (type, transFunction) => {
  TRANSFORMS[type] = transFunction;
};

// node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad(value, width) {
  var s = value + "", length2 = s.length;
  return length2 < width ? new Array(width - length2 + 1).join(0) + s : s;
}
function formatYear(year2) {
  return year2 < 0 ? "-" + pad(-year2, 6) : year2 > 9999 ? "+" + pad(year2, 6) : pad(year2, 4);
}
function formatDate(date2) {
  var hours2 = date2.getUTCHours(), minutes2 = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();
  return isNaN(date2) ? "Invalid Date" : formatYear(date2.getUTCFullYear(), 4) + "-" + pad(date2.getUTCMonth() + 1, 2) + "-" + pad(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad(hours2, 2) + ":" + pad(minutes2, 2) + ":" + pad(seconds2, 2) + "." + pad(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad(hours2, 2) + ":" + pad(minutes2, 2) + ":" + pad(seconds2, 2) + "Z" : minutes2 || hours2 ? "T" + pad(hours2, 2) + ":" + pad(minutes2, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse(text, f) {
    var convert2, columns, rows = parseRows(text, function(row, i) {
      if (convert2)
        return convert2(row, i - 1);
      columns = row, convert2 = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text, f) {
    var rows = [], N = text.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text.charCodeAt(N - 1) === NEWLINE)
      --N;
    if (text.charCodeAt(N - 1) === RETURN)
      --N;
    function token() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE)
          ;
        if ((i = I) >= N)
          eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE)
          eol = true;
        else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c !== DELIMITER)
          continue;
        return text.slice(j, i);
      }
      return eof = true, text.slice(j, N);
    }
    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF)
        row.push(t), t = token();
      if (f && (row = f(row, n++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }
  function format2(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(value) {
    return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
  }
  return {
    parse,
    parseRows,
    format: format2,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// node_modules/d3-dsv/src/autoType.js
var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

// node_modules/@turf/invariant/dist/es/index.js
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }
  return geojson;
}

// node_modules/@antv/l7-source/es/utils/util.js
var import_geojson_rewind = __toESM(require_geojson_rewind());
function getColumn(data, columnName) {
  return data.map((item) => {
    return item[columnName] * 1;
  });
}
function isNumberArray(data) {
  if (Array.isArray(data)) {
    if (data.length === 0) {
      return true;
    }
    if (typeof data[0] === "number") {
      return true;
    } else {
      return false;
    }
  }
  return false;
}
function geojsonRewind(geojson) {
  const data = Object.isFrozen(geojson) ? lodashUtil.cloneDeep(geojson) : geojson;
  (0, import_geojson_rewind.default)(data, true);
  return data;
}
function extentToCoord(coord, extent2) {
  return coord ? coord : [
    [extent2[0], extent2[3]],
    [extent2[2], extent2[3]],
    [extent2[2], extent2[1]],
    [extent2[0], extent2[1]]
  ];
}

// node_modules/@antv/l7-source/es/parser/json.js
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function json(data, cfg) {
  const { x, y, x1, y1, coordinates, geometry } = cfg;
  const resultData = [];
  if (!Array.isArray(data)) {
    return {
      dataArray: []
    };
  }
  if (geometry) {
    data.filter((item) => {
      return item[geometry] && item[geometry].type && item[geometry].coordinates && item[geometry].coordinates.length > 0;
    }).forEach((col, index3) => {
      const rewindGeometry = geojsonRewind(col[geometry]);
      flattenEach(rewindGeometry, (currentFeature) => {
        const coord = getCoords(currentFeature);
        const dataItem = __spreadProps(__spreadValues({}, col), {
          _id: index3,
          coordinates: coord
        });
        resultData.push(dataItem);
      });
    });
    return {
      dataArray: resultData
    };
  }
  for (let featureIndex = 0; featureIndex < data.length; featureIndex++) {
    const col = data[featureIndex];
    let coords = [];
    if (coordinates) {
      let type = "Polygon";
      if (!Array.isArray(coordinates[0])) {
        type = "Point";
      }
      if (Array.isArray(coordinates[0]) && !Array.isArray(coordinates[0][0])) {
        type = "LineString";
      }
      const rewindGeometry = geojsonRewind({
        type,
        coordinates: col[coordinates]
      });
      coords = rewindGeometry.coordinates;
    } else if (x && y && x1 && y1) {
      const from = [parseFloat(col[x]), parseFloat(col[y])];
      const to = [parseFloat(col[x1]), parseFloat(col[y1])];
      coords = [from, to];
    } else if (x && y) {
      coords = [parseFloat(col[x]), parseFloat(col[y])];
    }
    const dataItem = __spreadProps(__spreadValues({}, col), {
      _id: featureIndex,
      coordinates: coords
    });
    resultData.push(dataItem);
  }
  return {
    dataArray: resultData
  };
}

// node_modules/@antv/l7-source/es/parser/csv.js
function csv2(data, cfg) {
  const csvData = csvParse(data);
  return json(csvData, cfg);
}

// node_modules/@antv/l7-source/es/parser/geojson.js
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
function djb2hash2(field) {
  const str = field.toString();
  let hash = 5381;
  let i = str.length;
  while (i) {
    hash = hash * 33 ^ str.charCodeAt(--i);
  }
  return hash >>> 0;
}
function getFeatureID(feature, key) {
  if (key === void 0) {
    return null;
  }
  if (!isNaN(feature.properties[key] * 1)) {
    return feature.properties[key] * 1;
  }
  if (feature.properties && feature.properties[key]) {
    return djb2hash2(feature.properties[key] + "") % 1000019;
  }
  return null;
}
function geoJSON(data, cfg) {
  const resultData = [];
  const featureKeys = {};
  if (!data.features) {
    data.features = [];
    return {
      dataArray: []
    };
  }
  data.features = data.features.filter((item) => {
    const geometry = item.geometry;
    return item != null && geometry && geometry.type && geometry.coordinates && geometry.coordinates.length > 0;
  });
  data = geojsonRewind(data);
  if (data.features.length === 0) {
    return {
      dataArray: [],
      featureKeys
    };
  }
  flattenEach(data, (currentFeature, featureIndex) => {
    let featureId = getFeatureID(currentFeature, cfg == null ? void 0 : cfg.featureId);
    if (featureId === null) {
      featureId = featureIndex;
    }
    const sortedID = featureId;
    const coord = getCoords(currentFeature);
    const dataItem = __spreadProps2(__spreadValues2({}, currentFeature.properties), {
      coordinates: coord,
      _id: sortedID
    });
    resultData.push(dataItem);
  });
  return {
    dataArray: resultData,
    featureKeys
  };
}

// node_modules/geojson-vt/src/simplify.js
function simplify(coords, first, last2, sqTolerance) {
  var maxSqDist = sqTolerance;
  var mid = last2 - first >> 1;
  var minPosToMid = last2 - first;
  var index3;
  var ax = coords[first];
  var ay = coords[first + 1];
  var bx = coords[last2];
  var by = coords[last2 + 1];
  for (var i = first + 3; i < last2; i += 3) {
    var d = getSqSegDist(coords[i], coords[i + 1], ax, ay, bx, by);
    if (d > maxSqDist) {
      index3 = i;
      maxSqDist = d;
    } else if (d === maxSqDist) {
      var posToMid = Math.abs(i - mid);
      if (posToMid < minPosToMid) {
        index3 = i;
        minPosToMid = posToMid;
      }
    }
  }
  if (maxSqDist > sqTolerance) {
    if (index3 - first > 3)
      simplify(coords, first, index3, sqTolerance);
    coords[index3 + 2] = maxSqDist;
    if (last2 - index3 > 3)
      simplify(coords, index3, last2, sqTolerance);
  }
}
function getSqSegDist(px, py, x, y, bx, by) {
  var dx = bx - x;
  var dy = by - y;
  if (dx !== 0 || dy !== 0) {
    var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x = bx;
      y = by;
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }
  dx = px - x;
  dy = py - y;
  return dx * dx + dy * dy;
}

// node_modules/geojson-vt/src/feature.js
function createFeature(id, type, geom, tags) {
  var feature = {
    id: typeof id === "undefined" ? null : id,
    type,
    geometry: geom,
    tags,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
  calcBBox(feature);
  return feature;
}
function calcBBox(feature) {
  var geom = feature.geometry;
  var type = feature.type;
  if (type === "Point" || type === "MultiPoint" || type === "LineString") {
    calcLineBBox(feature, geom);
  } else if (type === "Polygon" || type === "MultiLineString") {
    for (var i = 0; i < geom.length; i++) {
      calcLineBBox(feature, geom[i]);
    }
  } else if (type === "MultiPolygon") {
    for (i = 0; i < geom.length; i++) {
      for (var j = 0; j < geom[i].length; j++) {
        calcLineBBox(feature, geom[i][j]);
      }
    }
  }
}
function calcLineBBox(feature, geom) {
  for (var i = 0; i < geom.length; i += 3) {
    feature.minX = Math.min(feature.minX, geom[i]);
    feature.minY = Math.min(feature.minY, geom[i + 1]);
    feature.maxX = Math.max(feature.maxX, geom[i]);
    feature.maxY = Math.max(feature.maxY, geom[i + 1]);
  }
}

// node_modules/geojson-vt/src/convert.js
function convert(data, options) {
  var features = [];
  if (data.type === "FeatureCollection") {
    for (var i = 0; i < data.features.length; i++) {
      convertFeature(features, data.features[i], options, i);
    }
  } else if (data.type === "Feature") {
    convertFeature(features, data, options);
  } else {
    convertFeature(features, { geometry: data }, options);
  }
  return features;
}
function convertFeature(features, geojson, options, index3) {
  if (!geojson.geometry)
    return;
  var coords = geojson.geometry.coordinates;
  var type = geojson.geometry.type;
  var tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);
  var geometry = [];
  var id = geojson.id;
  if (options.promoteId) {
    id = geojson.properties[options.promoteId];
  } else if (options.generateId) {
    id = index3 || 0;
  }
  if (type === "Point") {
    convertPoint(coords, geometry);
  } else if (type === "MultiPoint") {
    for (var i = 0; i < coords.length; i++) {
      convertPoint(coords[i], geometry);
    }
  } else if (type === "LineString") {
    convertLine(coords, geometry, tolerance, false);
  } else if (type === "MultiLineString") {
    if (options.lineMetrics) {
      for (i = 0; i < coords.length; i++) {
        geometry = [];
        convertLine(coords[i], geometry, tolerance, false);
        features.push(createFeature(id, "LineString", geometry, geojson.properties));
      }
      return;
    } else {
      convertLines(coords, geometry, tolerance, false);
    }
  } else if (type === "Polygon") {
    convertLines(coords, geometry, tolerance, true);
  } else if (type === "MultiPolygon") {
    for (i = 0; i < coords.length; i++) {
      var polygon2 = [];
      convertLines(coords[i], polygon2, tolerance, true);
      geometry.push(polygon2);
    }
  } else if (type === "GeometryCollection") {
    for (i = 0; i < geojson.geometry.geometries.length; i++) {
      convertFeature(features, {
        id,
        geometry: geojson.geometry.geometries[i],
        properties: geojson.properties
      }, options, index3);
    }
    return;
  } else {
    throw new Error("Input data is not a valid GeoJSON object.");
  }
  features.push(createFeature(id, type, geometry, geojson.properties));
}
function convertPoint(coords, out) {
  out.push(projectX(coords[0]));
  out.push(projectY(coords[1]));
  out.push(0);
}
function convertLine(ring, out, tolerance, isPolygon) {
  var x0, y0;
  var size2 = 0;
  for (var j = 0; j < ring.length; j++) {
    var x = projectX(ring[j][0]);
    var y = projectY(ring[j][1]);
    out.push(x);
    out.push(y);
    out.push(0);
    if (j > 0) {
      if (isPolygon) {
        size2 += (x0 * y - x * y0) / 2;
      } else {
        size2 += Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2));
      }
    }
    x0 = x;
    y0 = y;
  }
  var last2 = out.length - 3;
  out[2] = 1;
  simplify(out, 0, last2, tolerance);
  out[last2 + 2] = 1;
  out.size = Math.abs(size2);
  out.start = 0;
  out.end = out.size;
}
function convertLines(rings, out, tolerance, isPolygon) {
  for (var i = 0; i < rings.length; i++) {
    var geom = [];
    convertLine(rings[i], geom, tolerance, isPolygon);
    out.push(geom);
  }
}
function projectX(x) {
  return x / 360 + 0.5;
}
function projectY(y) {
  var sin = Math.sin(y * Math.PI / 180);
  var y2 = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
  return y2 < 0 ? 0 : y2 > 1 ? 1 : y2;
}

// node_modules/geojson-vt/src/clip.js
function clip(features, scale2, k1, k2, axis, minAll, maxAll, options) {
  k1 /= scale2;
  k2 /= scale2;
  if (minAll >= k1 && maxAll < k2)
    return features;
  else if (maxAll < k1 || minAll >= k2)
    return null;
  var clipped = [];
  for (var i = 0; i < features.length; i++) {
    var feature = features[i];
    var geometry = feature.geometry;
    var type = feature.type;
    var min3 = axis === 0 ? feature.minX : feature.minY;
    var max4 = axis === 0 ? feature.maxX : feature.maxY;
    if (min3 >= k1 && max4 < k2) {
      clipped.push(feature);
      continue;
    } else if (max4 < k1 || min3 >= k2) {
      continue;
    }
    var newGeometry = [];
    if (type === "Point" || type === "MultiPoint") {
      clipPoints(geometry, newGeometry, k1, k2, axis);
    } else if (type === "LineString") {
      clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);
    } else if (type === "MultiLineString") {
      clipLines(geometry, newGeometry, k1, k2, axis, false);
    } else if (type === "Polygon") {
      clipLines(geometry, newGeometry, k1, k2, axis, true);
    } else if (type === "MultiPolygon") {
      for (var j = 0; j < geometry.length; j++) {
        var polygon2 = [];
        clipLines(geometry[j], polygon2, k1, k2, axis, true);
        if (polygon2.length) {
          newGeometry.push(polygon2);
        }
      }
    }
    if (newGeometry.length) {
      if (options.lineMetrics && type === "LineString") {
        for (j = 0; j < newGeometry.length; j++) {
          clipped.push(createFeature(feature.id, type, newGeometry[j], feature.tags));
        }
        continue;
      }
      if (type === "LineString" || type === "MultiLineString") {
        if (newGeometry.length === 1) {
          type = "LineString";
          newGeometry = newGeometry[0];
        } else {
          type = "MultiLineString";
        }
      }
      if (type === "Point" || type === "MultiPoint") {
        type = newGeometry.length === 3 ? "Point" : "MultiPoint";
      }
      clipped.push(createFeature(feature.id, type, newGeometry, feature.tags));
    }
  }
  return clipped.length ? clipped : null;
}
function clipPoints(geom, newGeom, k1, k2, axis) {
  for (var i = 0; i < geom.length; i += 3) {
    var a = geom[i + axis];
    if (a >= k1 && a <= k2) {
      newGeom.push(geom[i]);
      newGeom.push(geom[i + 1]);
      newGeom.push(geom[i + 2]);
    }
  }
}
function clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {
  var slice4 = newSlice(geom);
  var intersect = axis === 0 ? intersectX : intersectY;
  var len = geom.start;
  var segLen, t;
  for (var i = 0; i < geom.length - 3; i += 3) {
    var ax = geom[i];
    var ay = geom[i + 1];
    var az = geom[i + 2];
    var bx = geom[i + 3];
    var by = geom[i + 4];
    var a = axis === 0 ? ax : ay;
    var b = axis === 0 ? bx : by;
    var exited = false;
    if (trackMetrics)
      segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));
    if (a < k1) {
      if (b > k1) {
        t = intersect(slice4, ax, ay, bx, by, k1);
        if (trackMetrics)
          slice4.start = len + segLen * t;
      }
    } else if (a > k2) {
      if (b < k2) {
        t = intersect(slice4, ax, ay, bx, by, k2);
        if (trackMetrics)
          slice4.start = len + segLen * t;
      }
    } else {
      addPoint(slice4, ax, ay, az);
    }
    if (b < k1 && a >= k1) {
      t = intersect(slice4, ax, ay, bx, by, k1);
      exited = true;
    }
    if (b > k2 && a <= k2) {
      t = intersect(slice4, ax, ay, bx, by, k2);
      exited = true;
    }
    if (!isPolygon && exited) {
      if (trackMetrics)
        slice4.end = len + segLen * t;
      newGeom.push(slice4);
      slice4 = newSlice(geom);
    }
    if (trackMetrics)
      len += segLen;
  }
  var last2 = geom.length - 3;
  ax = geom[last2];
  ay = geom[last2 + 1];
  az = geom[last2 + 2];
  a = axis === 0 ? ax : ay;
  if (a >= k1 && a <= k2)
    addPoint(slice4, ax, ay, az);
  last2 = slice4.length - 3;
  if (isPolygon && last2 >= 3 && (slice4[last2] !== slice4[0] || slice4[last2 + 1] !== slice4[1])) {
    addPoint(slice4, slice4[0], slice4[1], slice4[2]);
  }
  if (slice4.length) {
    newGeom.push(slice4);
  }
}
function newSlice(line) {
  var slice4 = [];
  slice4.size = line.size;
  slice4.start = line.start;
  slice4.end = line.end;
  return slice4;
}
function clipLines(geom, newGeom, k1, k2, axis, isPolygon) {
  for (var i = 0; i < geom.length; i++) {
    clipLine(geom[i], newGeom, k1, k2, axis, isPolygon, false);
  }
}
function addPoint(out, x, y, z) {
  out.push(x);
  out.push(y);
  out.push(z);
}
function intersectX(out, ax, ay, bx, by, x) {
  var t = (x - ax) / (bx - ax);
  out.push(x);
  out.push(ay + (by - ay) * t);
  out.push(1);
  return t;
}
function intersectY(out, ax, ay, bx, by, y) {
  var t = (y - ay) / (by - ay);
  out.push(ax + (bx - ax) * t);
  out.push(y);
  out.push(1);
  return t;
}

// node_modules/geojson-vt/src/wrap.js
function wrap(features, options) {
  var buffer = options.buffer / options.extent;
  var merged = features;
  var left = clip(features, 1, -1 - buffer, buffer, 0, -1, 2, options);
  var right = clip(features, 1, 1 - buffer, 2 + buffer, 0, -1, 2, options);
  if (left || right) {
    merged = clip(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || [];
    if (left)
      merged = shiftFeatureCoords(left, 1).concat(merged);
    if (right)
      merged = merged.concat(shiftFeatureCoords(right, -1));
  }
  return merged;
}
function shiftFeatureCoords(features, offset) {
  var newFeatures = [];
  for (var i = 0; i < features.length; i++) {
    var feature = features[i], type = feature.type;
    var newGeometry;
    if (type === "Point" || type === "MultiPoint" || type === "LineString") {
      newGeometry = shiftCoords(feature.geometry, offset);
    } else if (type === "MultiLineString" || type === "Polygon") {
      newGeometry = [];
      for (var j = 0; j < feature.geometry.length; j++) {
        newGeometry.push(shiftCoords(feature.geometry[j], offset));
      }
    } else if (type === "MultiPolygon") {
      newGeometry = [];
      for (j = 0; j < feature.geometry.length; j++) {
        var newPolygon = [];
        for (var k = 0; k < feature.geometry[j].length; k++) {
          newPolygon.push(shiftCoords(feature.geometry[j][k], offset));
        }
        newGeometry.push(newPolygon);
      }
    }
    newFeatures.push(createFeature(feature.id, type, newGeometry, feature.tags));
  }
  return newFeatures;
}
function shiftCoords(points, offset) {
  var newPoints = [];
  newPoints.size = points.size;
  if (points.start !== void 0) {
    newPoints.start = points.start;
    newPoints.end = points.end;
  }
  for (var i = 0; i < points.length; i += 3) {
    newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);
  }
  return newPoints;
}

// node_modules/geojson-vt/src/transform.js
function transformTile(tile, extent2) {
  if (tile.transformed)
    return tile;
  var z2 = 1 << tile.z, tx = tile.x, ty = tile.y, i, j, k;
  for (i = 0; i < tile.features.length; i++) {
    var feature = tile.features[i], geom = feature.geometry, type = feature.type;
    feature.geometry = [];
    if (type === 1) {
      for (j = 0; j < geom.length; j += 2) {
        feature.geometry.push(transformPoint(geom[j], geom[j + 1], extent2, z2, tx, ty));
      }
    } else {
      for (j = 0; j < geom.length; j++) {
        var ring = [];
        for (k = 0; k < geom[j].length; k += 2) {
          ring.push(transformPoint(geom[j][k], geom[j][k + 1], extent2, z2, tx, ty));
        }
        feature.geometry.push(ring);
      }
    }
  }
  tile.transformed = true;
  return tile;
}
function transformPoint(x, y, extent2, z2, tx, ty) {
  return [
    Math.round(extent2 * (x * z2 - tx)),
    Math.round(extent2 * (y * z2 - ty))
  ];
}

// node_modules/geojson-vt/src/tile.js
function createTile(features, z, tx, ty, options) {
  var tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);
  var tile = {
    features: [],
    numPoints: 0,
    numSimplified: 0,
    numFeatures: 0,
    source: null,
    x: tx,
    y: ty,
    z,
    transformed: false,
    minX: 2,
    minY: 1,
    maxX: -1,
    maxY: 0
  };
  for (var i = 0; i < features.length; i++) {
    tile.numFeatures++;
    addFeature(tile, features[i], tolerance, options);
    var minX = features[i].minX;
    var minY = features[i].minY;
    var maxX = features[i].maxX;
    var maxY = features[i].maxY;
    if (minX < tile.minX)
      tile.minX = minX;
    if (minY < tile.minY)
      tile.minY = minY;
    if (maxX > tile.maxX)
      tile.maxX = maxX;
    if (maxY > tile.maxY)
      tile.maxY = maxY;
  }
  return tile;
}
function addFeature(tile, feature, tolerance, options) {
  var geom = feature.geometry, type = feature.type, simplified = [];
  if (type === "Point" || type === "MultiPoint") {
    for (var i = 0; i < geom.length; i += 3) {
      simplified.push(geom[i]);
      simplified.push(geom[i + 1]);
      tile.numPoints++;
      tile.numSimplified++;
    }
  } else if (type === "LineString") {
    addLine(simplified, geom, tile, tolerance, false, false);
  } else if (type === "MultiLineString" || type === "Polygon") {
    for (i = 0; i < geom.length; i++) {
      addLine(simplified, geom[i], tile, tolerance, type === "Polygon", i === 0);
    }
  } else if (type === "MultiPolygon") {
    for (var k = 0; k < geom.length; k++) {
      var polygon2 = geom[k];
      for (i = 0; i < polygon2.length; i++) {
        addLine(simplified, polygon2[i], tile, tolerance, true, i === 0);
      }
    }
  }
  if (simplified.length) {
    var tags = feature.tags || null;
    if (type === "LineString" && options.lineMetrics) {
      tags = {};
      for (var key in feature.tags)
        tags[key] = feature.tags[key];
      tags["mapbox_clip_start"] = geom.start / geom.size;
      tags["mapbox_clip_end"] = geom.end / geom.size;
    }
    var tileFeature = {
      geometry: simplified,
      type: type === "Polygon" || type === "MultiPolygon" ? 3 : type === "LineString" || type === "MultiLineString" ? 2 : 1,
      tags
    };
    if (feature.id !== null) {
      tileFeature.id = feature.id;
    }
    tile.features.push(tileFeature);
  }
}
function addLine(result, geom, tile, tolerance, isPolygon, isOuter) {
  var sqTolerance = tolerance * tolerance;
  if (tolerance > 0 && geom.size < (isPolygon ? sqTolerance : tolerance)) {
    tile.numPoints += geom.length / 3;
    return;
  }
  var ring = [];
  for (var i = 0; i < geom.length; i += 3) {
    if (tolerance === 0 || geom[i + 2] > sqTolerance) {
      tile.numSimplified++;
      ring.push(geom[i]);
      ring.push(geom[i + 1]);
    }
    tile.numPoints++;
  }
  if (isPolygon)
    rewind2(ring, isOuter);
  result.push(ring);
}
function rewind2(ring, clockwise) {
  var area = 0;
  for (var i = 0, len = ring.length, j = len - 2; i < len; j = i, i += 2) {
    area += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);
  }
  if (area > 0 === clockwise) {
    for (i = 0, len = ring.length; i < len / 2; i += 2) {
      var x = ring[i];
      var y = ring[i + 1];
      ring[i] = ring[len - 2 - i];
      ring[i + 1] = ring[len - 1 - i];
      ring[len - 2 - i] = x;
      ring[len - 1 - i] = y;
    }
  }
}

// node_modules/geojson-vt/src/index.js
function geojsonvt(data, options) {
  return new GeoJSONVT(data, options);
}
function GeoJSONVT(data, options) {
  options = this.options = extend(Object.create(this.options), options);
  var debug = options.debug;
  if (debug)
    console.time("preprocess data");
  if (options.maxZoom < 0 || options.maxZoom > 24)
    throw new Error("maxZoom should be in the 0-24 range");
  if (options.promoteId && options.generateId)
    throw new Error("promoteId and generateId cannot be used together.");
  var features = convert(data, options);
  this.tiles = {};
  this.tileCoords = [];
  if (debug) {
    console.timeEnd("preprocess data");
    console.log("index: maxZoom: %d, maxPoints: %d", options.indexMaxZoom, options.indexMaxPoints);
    console.time("generate tiles");
    this.stats = {};
    this.total = 0;
  }
  features = wrap(features, options);
  if (features.length)
    this.splitTile(features, 0, 0, 0);
  if (debug) {
    if (features.length)
      console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints);
    console.timeEnd("generate tiles");
    console.log("tiles generated:", this.total, JSON.stringify(this.stats));
  }
}
GeoJSONVT.prototype.options = {
  maxZoom: 14,
  // max zoom to preserve detail on
  indexMaxZoom: 5,
  // max zoom in the tile index
  indexMaxPoints: 1e5,
  // max number of points per tile in the tile index
  tolerance: 3,
  // simplification tolerance (higher means simpler)
  extent: 4096,
  // tile extent
  buffer: 64,
  // tile buffer on each side
  lineMetrics: false,
  // whether to calculate line metrics
  promoteId: null,
  // name of a feature property to be promoted to feature.id
  generateId: false,
  // whether to generate feature ids. Cannot be used with promoteId
  debug: 0
  // logging level (0, 1 or 2)
};
GeoJSONVT.prototype.splitTile = function(features, z, x, y, cz, cx, cy) {
  var stack = [features, z, x, y], options = this.options, debug = options.debug;
  while (stack.length) {
    y = stack.pop();
    x = stack.pop();
    z = stack.pop();
    features = stack.pop();
    var z2 = 1 << z, id = toID(z, x, y), tile = this.tiles[id];
    if (!tile) {
      if (debug > 1)
        console.time("creation");
      tile = this.tiles[id] = createTile(features, z, x, y, options);
      this.tileCoords.push({ z, x, y });
      if (debug) {
        if (debug > 1) {
          console.log(
            "tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",
            z,
            x,
            y,
            tile.numFeatures,
            tile.numPoints,
            tile.numSimplified
          );
          console.timeEnd("creation");
        }
        var key = "z" + z;
        this.stats[key] = (this.stats[key] || 0) + 1;
        this.total++;
      }
    }
    tile.source = features;
    if (!cz) {
      if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints)
        continue;
    } else {
      if (z === options.maxZoom || z === cz)
        continue;
      var m = 1 << cz - z;
      if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m))
        continue;
    }
    tile.source = null;
    if (features.length === 0)
      continue;
    if (debug > 1)
      console.time("clipping");
    var k1 = 0.5 * options.buffer / options.extent, k2 = 0.5 - k1, k3 = 0.5 + k1, k4 = 1 + k1, tl, bl, tr, br, left, right;
    tl = bl = tr = br = null;
    left = clip(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, options);
    right = clip(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, options);
    features = null;
    if (left) {
      tl = clip(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);
      bl = clip(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);
      left = null;
    }
    if (right) {
      tr = clip(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);
      br = clip(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);
      right = null;
    }
    if (debug > 1)
      console.timeEnd("clipping");
    stack.push(tl || [], z + 1, x * 2, y * 2);
    stack.push(bl || [], z + 1, x * 2, y * 2 + 1);
    stack.push(tr || [], z + 1, x * 2 + 1, y * 2);
    stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);
  }
};
GeoJSONVT.prototype.getTile = function(z, x, y) {
  var options = this.options, extent2 = options.extent, debug = options.debug;
  if (z < 0 || z > 24)
    return null;
  var z2 = 1 << z;
  x = (x % z2 + z2) % z2;
  var id = toID(z, x, y);
  if (this.tiles[id])
    return transformTile(this.tiles[id], extent2);
  if (debug > 1)
    console.log("drilling down to z%d-%d-%d", z, x, y);
  var z0 = z, x0 = x, y0 = y, parent;
  while (!parent && z0 > 0) {
    z0--;
    x0 = Math.floor(x0 / 2);
    y0 = Math.floor(y0 / 2);
    parent = this.tiles[toID(z0, x0, y0)];
  }
  if (!parent || !parent.source)
    return null;
  if (debug > 1)
    console.log("found parent tile z%d-%d-%d", z0, x0, y0);
  if (debug > 1)
    console.time("drilling down");
  this.splitTile(parent.source, z0, x0, y0, z, x, y);
  if (debug > 1)
    console.timeEnd("drilling down");
  return this.tiles[id] ? transformTile(this.tiles[id], extent2) : null;
};
function toID(z, x, y) {
  return ((1 << z) * y + x) * 32 + z;
}
function extend(dest, src) {
  for (var i in src)
    dest[i] = src[i];
  return dest;
}

// node_modules/@antv/l7-source/es/source/geojsonvt.js
var VectorSource = class {
  constructor(vector, x, y, z) {
    this.vectorLayerCache = {};
    this.x = x;
    this.y = y;
    this.z = z;
    this.vectorTile = vector;
  }
  getTileData(sourceLayer) {
    if (!sourceLayer || !this.vectorTile.layers[sourceLayer]) {
      return [];
    }
    if (this.vectorLayerCache[sourceLayer]) {
      return this.vectorLayerCache[sourceLayer];
    }
    const vectorTile = this.vectorTile.layers[sourceLayer];
    return vectorTile.features;
  }
  getFeatureById() {
    throw new Error("Method not implemented.");
  }
};

// node_modules/@antv/l7-source/es/parser/geojsonvt.js
var __defProp3 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp3.call(b, prop))
      __defNormalProp3(a, prop, b[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b)) {
      if (__propIsEnum3.call(b, prop))
        __defNormalProp3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps3 = (a, b) => __defProps3(a, __getOwnPropDescs3(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var DEFAULT_CONFIG = {
  tileSize: 256,
  minZoom: 0,
  maxZoom: Infinity,
  zoomOffset: 0
};
function signedArea(ring) {
  let sum4 = 0;
  for (let i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
    p1 = ring[i];
    p2 = ring[j];
    sum4 += (p2.x - p1.x) * (p1.y + p2.y);
  }
  return sum4;
}
function classifyRings(rings) {
  const len = rings.length;
  if (len <= 1) {
    return [rings];
  }
  const polygons = [];
  let polygon2;
  let ccw;
  for (let i = 0; i < len; i++) {
    const area = signedArea(rings[i]);
    if (area === 0) {
      continue;
    }
    if (ccw === void 0) {
      ccw = area < 0;
    }
    if (ccw === area < 0) {
      if (polygon2) {
        polygons.push(polygon2);
      }
      polygon2 = [rings[i]];
    } else {
      polygon2.push(rings[i]);
    }
  }
  if (polygon2) {
    polygons.push(polygon2);
  }
  return polygons;
}
var VectorTileFeatureTypes = ["Unknown", "Point", "LineString", "Polygon"];
function GetGeoJSON(extent2, x, y, z, vectorTileFeature) {
  let coords = vectorTileFeature.geometry;
  const currenType = vectorTileFeature.type;
  const currentProperties = vectorTileFeature.tags;
  const currentId = vectorTileFeature.id;
  const size2 = extent2 * Math.pow(2, z);
  const x0 = extent2 * x;
  const y0 = extent2 * y;
  let type = VectorTileFeatureTypes[currenType];
  let i;
  let j;
  function project2(line) {
    for (let index3 = 0; index3 < line.length; index3++) {
      const p = line[index3];
      if (p[3]) {
        break;
      }
      const y2 = 180 - (p[1] + y0) * 360 / size2;
      const lng = (p[0] + x0) * 360 / size2 - 180;
      const lat = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
      line[index3] = [lng, lat, 0, 1];
    }
  }
  switch (currenType) {
    case 1:
      const points = [];
      for (i = 0; i < coords.length; i++) {
        points[i] = coords[i][0];
      }
      coords = points;
      project2(coords);
      break;
    case 2:
      for (i = 0; i < coords.length; i++) {
        project2(coords[i]);
      }
      break;
    case 3:
      coords = classifyRings(coords);
      for (i = 0; i < coords.length; i++) {
        for (j = 0; j < coords[i].length; j++) {
          project2(coords[i][j]);
        }
      }
      break;
  }
  if (coords.length === 1) {
    coords = coords[0];
  } else {
    type = "Multi" + type;
  }
  const result = {
    type: "Feature",
    geometry: {
      type,
      coordinates: coords
    },
    properties: currentProperties,
    id: currentId,
    tileOrigin: [0, 0],
    coord: ""
  };
  return result;
}
var getVectorTile = (tile, tileIndex, tileParams, extent2) => __async(void 0, null, function* () {
  return new Promise((resolve) => {
    const tileData = tileIndex.getTile(tile.z, tile.x, tile.y);
    const features = tileData ? tileData.features.map((vectorTileFeature) => {
      return GetGeoJSON(extent2, tileParams.x, tileParams.y, tileParams.z, vectorTileFeature);
    }) : [];
    const vectorTile = {
      layers: {
        defaultLayer: {
          // @ts-ignore
          features
        }
      }
    };
    const vectorSource = new VectorSource(vectorTile, tile.x, tile.y, tile.z);
    resolve(vectorSource);
  });
});
function getOption(cfg) {
  const defaultOptions = {
    // geojson-vt default options
    maxZoom: 14,
    // max zoom to preserve detail on
    indexMaxZoom: 5,
    // max zoom in the tile index
    indexMaxPoints: 1e5,
    // max number of points per tile in the tile index
    tolerance: 3,
    // simplification tolerance (higher means simpler)
    extent: 4096,
    // tile extent
    buffer: 64,
    // tile buffer on each side
    lineMetrics: false,
    // whether to calculate line metrics
    promoteId: null,
    // name of a feature property to be promoted to feature.id
    generateId: true,
    // whether to generate feature ids. Cannot be used with promoteId
    debug: 0
    // logging level (0, 1 or 2)
  };
  if (cfg === void 0 || typeof cfg.geojsonvtOptions === "undefined") {
    return defaultOptions;
  } else {
    return __spreadValues3(__spreadValues3({}, defaultOptions), cfg.geojsonvtOptions);
  }
}
function geojsonVTTile(data, cfg) {
  const geojsonOptions = getOption(cfg);
  const extent2 = geojsonOptions.extent || 4096;
  const tileIndex = geojsonvt(data, geojsonOptions);
  const getTileData = (tileParams, tile) => {
    return getVectorTile(tile, tileIndex, tileParams, extent2);
  };
  const tilesetOptions = __spreadProps3(__spreadValues3(__spreadValues3({}, DEFAULT_CONFIG), cfg), {
    getTileData
  });
  return {
    data,
    dataArray: [],
    tilesetOptions,
    isTile: true
  };
}

// node_modules/@antv/l7-source/es/parser/image.js
var __defProp4 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp4.call(b, prop))
      __defNormalProp4(a, prop, b[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b)) {
      if (__propIsEnum4.call(b, prop))
        __defNormalProp4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps4 = (a, b) => __defProps4(a, __getOwnPropDescs4(b));
function image(data, cfg) {
  const {
    extent: extent2 = [121.168, 30.2828, 121.384, 30.4219],
    coordinates,
    requestParameters = {}
  } = cfg;
  const images = new Promise((resolve) => {
    if (data instanceof HTMLImageElement || isImageBitmap(data)) {
      resolve([data]);
    } else {
      loadData(data, requestParameters, (res) => {
        resolve(res);
      });
    }
  });
  const imageCoord = extentToCoord(coordinates, extent2);
  const resultData = {
    originData: data,
    images,
    _id: 1,
    dataArray: [
      {
        _id: 0,
        coordinates: imageCoord
      }
    ]
  };
  return resultData;
}
function loadData(url, requestParameters, done) {
  const imageDatas = [];
  if (typeof url === "string") {
    getImage(__spreadProps4(__spreadValues4({}, requestParameters), { url }), (err, img) => {
      if (img) {
        imageDatas.push(img);
        done(imageDatas);
      }
    });
  } else {
    const imageCount = url.length;
    let imageindex = 0;
    url.forEach((item) => {
      getImage(__spreadProps4(__spreadValues4({}, requestParameters), { url: item }), (err, img) => {
        imageindex++;
        if (img) {
          imageDatas.push(img);
        }
        if (imageindex === imageCount) {
          done(imageDatas);
        }
      });
    });
  }
  return image;
}

// node_modules/@antv/l7-source/es/parser/jsonTile.js
var __defProp5 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp5.call(b, prop))
      __defNormalProp5(a, prop, b[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b)) {
      if (__propIsEnum5.call(b, prop))
        __defNormalProp5(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps5 = (a, b) => __defProps5(a, __getOwnPropDescs5(b));
var __async2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var getVectorTile2 = (url, tile, requestParameters, getCustomData2) => __async2(void 0, null, function* () {
  const params = { x: tile.x, y: tile.y, z: tile.z };
  const tileUrl = getURLFromTemplate(url, params);
  return new Promise((resolve) => {
    if (getCustomData2) {
      getCustomData2(params, (err, data) => {
        if (err || !data) {
          const vectorTile = {
            layers: { defaultLayer: { features: [] } }
          };
          const vectorSource = new VectorSource(vectorTile, tile.x, tile.y, tile.z);
          resolve(vectorSource);
        } else {
          const vectorTile = {
            layers: { defaultLayer: { features: data.features } }
          };
          const vectorSource = new VectorSource(vectorTile, tile.x, tile.y, tile.z);
          resolve(vectorSource);
        }
      });
    } else {
      getData(
        __spreadProps5(__spreadValues5({}, requestParameters), {
          url: tileUrl
        }),
        (err, data) => {
          if (err || !data) {
            const vectorTile = {
              layers: {
                defaultLayer: {
                  features: []
                }
              }
            };
            const vectorSource = new VectorSource(vectorTile, tile.x, tile.y, tile.z);
            resolve(vectorSource);
          } else {
            const json2 = JSON.parse(data);
            const vectorTile = {
              layers: {
                defaultLayer: {
                  features: json2
                }
              }
            };
            const vectorSource = new VectorSource(vectorTile, tile.x, tile.y, tile.z);
            resolve(vectorSource);
          }
        }
      );
    }
  });
});
function jsonTile(url, cfg) {
  const getTileData = (_, tile) => {
    return getVectorTile2(url, tile, cfg == null ? void 0 : cfg.requestParameters, cfg.getCustomData);
  };
  const tilesetOptions = __spreadProps5(__spreadValues5({}, cfg), {
    getTileData
  });
  return {
    dataArray: [],
    tilesetOptions,
    isTile: true
  };
}

// node_modules/@antv/l7-source/es/source/vector.js
var import_vector_tile = __toESM(require_vector_tile());
var import_pbf = __toESM(require_pbf());
var __defProp6 = Object.defineProperty;
var __defProps6 = Object.defineProperties;
var __getOwnPropDescs6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols6 = Object.getOwnPropertySymbols;
var __hasOwnProp6 = Object.prototype.hasOwnProperty;
var __propIsEnum6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp6.call(b, prop))
      __defNormalProp6(a, prop, b[prop]);
  if (__getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(b)) {
      if (__propIsEnum6.call(b, prop))
        __defNormalProp6(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps6 = (a, b) => __defProps6(a, __getOwnPropDescs6(b));
var VectorSource2 = class {
  constructor(data, x, y, z) {
    this.vectorLayerCache = {};
    this.x = x;
    this.y = y;
    this.z = z;
    this.vectorTile = new import_vector_tile.VectorTile(new import_pbf.default(data));
  }
  getTileData(sourceLayer) {
    if (!sourceLayer || !this.vectorTile.layers[sourceLayer]) {
      return [];
    }
    if (this.vectorLayerCache[sourceLayer]) {
      return this.vectorLayerCache[sourceLayer];
    }
    const vectorTile = this.vectorTile.layers[sourceLayer];
    if (Array.isArray(vectorTile.features)) {
      this.vectorLayerCache[sourceLayer] = vectorTile.features;
      return vectorTile.features;
    }
    const features = [];
    for (let i = 0; i < vectorTile.length; i++) {
      const vectorTileFeature = vectorTile.feature(i);
      const feature = vectorTileFeature.toGeoJSON(this.x, this.y, this.z);
      features.push(__spreadProps6(__spreadValues6({}, feature), {
        properties: __spreadValues6({
          id: feature.id
        }, feature.properties)
      }));
    }
    this.vectorLayerCache[sourceLayer] = features;
    return features;
  }
  getFeatureById() {
    throw new Error("Method not implemented.");
  }
};

// node_modules/@antv/l7-source/es/parser/mvt.js
var __defProp7 = Object.defineProperty;
var __defProps7 = Object.defineProperties;
var __getOwnPropDescs7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols7 = Object.getOwnPropertySymbols;
var __hasOwnProp7 = Object.prototype.hasOwnProperty;
var __propIsEnum7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp7.call(b, prop))
      __defNormalProp7(a, prop, b[prop]);
  if (__getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(b)) {
      if (__propIsEnum7.call(b, prop))
        __defNormalProp7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps7 = (a, b) => __defProps7(a, __getOwnPropDescs7(b));
var __async3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var DEFAULT_CONFIG2 = {
  tileSize: 256,
  minZoom: 0,
  maxZoom: Infinity,
  zoomOffset: 0,
  warp: true
};
var getVectorTile3 = (url, tileParams, tile, requestParameters, getCustomData2) => __async3(void 0, null, function* () {
  const tileUrl = getURLFromTemplate(url, tileParams);
  return new Promise((resolve) => {
    if (getCustomData2) {
      getCustomData2(
        {
          x: tile.x,
          y: tile.y,
          z: tile.z
        },
        (err, data) => {
          if (err || !data) {
            resolve(void 0);
          } else {
            const vectorSource = new VectorSource2(data, tile.x, tile.y, tile.z);
            resolve(vectorSource);
          }
        }
      );
    } else {
      const xhr = getArrayBuffer(
        __spreadProps7(__spreadValues7({}, requestParameters), {
          url: tileUrl
        }),
        (err, data) => {
          if (err || !data) {
            resolve(void 0);
          } else {
            const vectorSource = new VectorSource2(data, tile.x, tile.y, tile.z);
            resolve(vectorSource);
          }
        }
      );
      tile.xhrCancel = () => xhr.cancel();
    }
  });
});
function mapboxVectorTile(data, cfg) {
  const url = Array.isArray(data) ? data[0] : data;
  const getTileData = (tileParams, tile) => getVectorTile3(url, tileParams, tile, cfg == null ? void 0 : cfg.requestParameters, cfg == null ? void 0 : cfg.getCustomData);
  const tilesetOptions = __spreadProps7(__spreadValues7(__spreadValues7({}, DEFAULT_CONFIG2), cfg), {
    getTileData
  });
  return {
    data: url,
    dataArray: [],
    tilesetOptions,
    isTile: true
  };
}

// node_modules/@antv/l7-source/es/utils/bandOperation/math.js
function mathematical(symbol, n1, n2) {
  switch (symbol) {
    case "+":
      return n1 + n2;
    case "-":
      return n1 - n2;
    case "*":
      return n1 * n2;
    case "/":
      return n1 / n2;
    case "%":
      return n1 % n2;
    case "^":
      return Math.pow(n1, n2);
    case "abs":
      return Math.abs(n1);
    case "floor":
      return Math.floor(n1);
    case "round":
      return Math.round(n1);
    case "ceil":
      return Math.ceil(n1);
    case "sin":
      return Math.sin(n1);
    case "cos":
      return Math.cos(n1);
    case "atan":
      return n2 === -1 ? Math.atan(n1) : Math.atan2(n1, n2);
    case "min":
      return Math.min(n1, n2);
    case "max":
      return Math.max(n1, n2);
    case "log10":
      return Math.log(n1);
    case "log2":
      return Math.log2(n1);
    default:
      console.warn("Calculate symbol err! Return default 0");
      return 0;
  }
}
function calculate(express, bandsData) {
  const { width, height } = bandsData[0];
  const dataArray = bandsData.map((band2) => band2.rasterData);
  const length2 = width * height;
  const rasterData = [];
  const originExp = JSON.stringify(express);
  for (let i = 0; i < length2; i++) {
    const exp = JSON.parse(originExp);
    const expResult = spellExpress(exp, dataArray, i);
    if (typeof expResult === "number") {
      rasterData.push(expResult);
    } else {
      const result = calculateExpress(exp);
      rasterData.push(result);
    }
  }
  return rasterData;
}
function spellExpress(express, dataArray, index3) {
  if (express.length === 2 && express[0] === "band" && typeof express[1] === "number") {
    try {
      return dataArray[express[1]][index3];
    } catch (err) {
      console.warn("Raster Data err!");
      return 0;
    }
  }
  express.map((e, i) => {
    if (Array.isArray(e) && e.length > 0) {
      switch (e[0]) {
        case "band":
          try {
            express[i] = dataArray[e[1]][index3];
          } catch (err) {
            console.warn("Raster Data err!");
            express[i] = 0;
          }
          break;
        default:
          spellExpress(e, dataArray, index3);
      }
    }
  });
}
function formatExpress(express) {
  const [symbol1, symbol2 = -1, symbol3 = -1] = express;
  if (symbol1 === void 0) {
    console.warn("Express err!");
    return ["+", 0, 0];
  }
  const symbol = symbol1.replace(/\s+/g, "");
  return [symbol, symbol2, symbol3];
}
function calculateExpress(express) {
  const formatExp = formatExpress(express);
  const str = formatExp[0];
  let left = formatExp[1];
  let right = formatExp[2];
  if (Array.isArray(left)) {
    left = calculateExpress(express[1]);
  }
  if (Array.isArray(right)) {
    right = calculateExpress(express[2]);
  }
  return mathematical(str, left, right);
}

// node_modules/@antv/l7-source/es/utils/bandOperation/operationSchema.js
var operationsSchema = {
  nd: {
    type: "operation",
    expression: [
      "/",
      ["-", ["band", 1], ["band", 0]],
      // R > NIR
      ["+", ["band", 1], ["band", 0]]
    ]
  },
  rgb: {
    type: "function",
    method: strethRgb2minMax
  }
};
function strethRgb2minMax(bandsData, options) {
  const channelR = bandsData[0].rasterData;
  const channelG = bandsData[1].rasterData;
  const channelB = bandsData[2].rasterData;
  const data = [];
  const [low, high] = (options == null ? void 0 : options.countCut) || [2, 98];
  const minMaxR = (options == null ? void 0 : options.RMinMax) || percentile(channelR, low, high);
  const minMaxG = (options == null ? void 0 : options.GMinMax) || percentile(channelG, low, high);
  const minMaxB = (options == null ? void 0 : options.BMinMax) || percentile(channelB, low, high);
  for (let i = 0; i < channelR.length; i++) {
    data.push(Math.max(0, channelR[i] - minMaxR[0]));
    data.push(Math.max(0, channelG[i] - minMaxG[0]));
    data.push(Math.max(0, channelB[i] - minMaxB[0]));
  }
  return {
    rasterData: data,
    rMinMax: minMaxR,
    gMinMax: minMaxG,
    bMinMax: minMaxB
  };
}
function percentile(data, minPercent, maxPercent) {
  const sortData = data.slice().sort((a, b) => a - b);
  const dataLength = sortData.length;
  const min3 = sortData[Math.ceil(dataLength * minPercent / 100)];
  const max4 = sortData[Math.ceil(dataLength * maxPercent / 100)];
  return [min3, max4];
}

// node_modules/@antv/l7-source/es/utils/bandOperation/bands.js
var __defProp8 = Object.defineProperty;
var __defProps8 = Object.defineProperties;
var __getOwnPropDescs8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols8 = Object.getOwnPropertySymbols;
var __hasOwnProp8 = Object.prototype.hasOwnProperty;
var __propIsEnum8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp8.call(b, prop))
      __defNormalProp8(a, prop, b[prop]);
  if (__getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(b)) {
      if (__propIsEnum8.call(b, prop))
        __defNormalProp8(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps8 = (a, b) => __defProps8(a, __getOwnPropDescs8(b));
var __async4 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function bandsOperation(imageDataList, rasterFormat, operation2) {
  return __async4(this, null, function* () {
    if (imageDataList.length === 0) {
      return {
        rasterData: [0],
        width: 1,
        heigh: 1
      };
    }
    const formatData2 = yield Promise.all(
      imageDataList.map(({ data, bands = [0] }) => rasterFormat(data, bands))
    );
    const bandsData = [];
    formatData2.forEach((d) => {
      Array.isArray(d) ? bandsData.push(...d) : bandsData.push(d);
    });
    const { width, height } = bandsData[0];
    let rasterData;
    switch (typeof operation2) {
      case "function":
        rasterData = operation2(bandsData);
        break;
      case "object":
        if (!Array.isArray(operation2)) {
          rasterData = processSchemaOperation(operation2, bandsData);
        } else {
          rasterData = { rasterData: calculate(operation2, bandsData) };
        }
        break;
      default:
        rasterData = { rasterData: bandsData[0].rasterData };
    }
    return __spreadProps8(__spreadValues8({}, rasterData), {
      width,
      height
    });
  });
}
function processSchemaOperation(operation2, bandsData) {
  const schema = operationsSchema[operation2.type];
  if (schema.type === "function") {
    return schema.method(bandsData, operation2 == null ? void 0 : operation2.options);
  } else if (schema.type === "operation") {
    if (operation2.type === "rgb") {
      return getRgbBands(schema.expression, bandsData);
    } else {
      return { rasterData: calculate(schema.expression, bandsData) };
    }
  }
}
function getRgbBands(operation2, bandsData) {
  if (operation2.r === void 0) {
    console.warn("Channel R lost in Operation! Use band[0] to fill!");
  }
  if (operation2.g === void 0) {
    console.warn("Channel G lost in Operation! Use band[0] to fill!");
  }
  if (operation2.b === void 0) {
    console.warn("Channel B lost in Operation! Use band[0] to fill!");
  }
  const r = calculate(operation2.r || ["band", 0], bandsData);
  const g = calculate(operation2.g || ["band", 0], bandsData);
  const b = calculate(operation2.b || ["band", 0], bandsData);
  return [r, g, b];
}
function processRasterData(rasterFiles, rasterFormat, operation2, callback) {
  return __async4(this, null, function* () {
    const rasterData = yield bandsOperation(rasterFiles, rasterFormat, operation2);
    callback(null, { data: rasterData });
  });
}

// node_modules/@antv/l7-source/es/parser/raster.js
function raster(data, cfg) {
  const {
    extent: extent2 = [121.168, 30.2828, 121.384, 30.4219],
    coordinates,
    width,
    height,
    min: min3,
    max: max4,
    format: format2,
    operation: operation2
  } = cfg;
  let bandData;
  let rasterWidth;
  let rasterHeight;
  if (format2 === void 0 || isNumberArray(data)) {
    bandData = Array.from(data);
    rasterWidth = width;
    rasterHeight = height;
  } else {
    const imageDataList = Array.isArray(data) ? data : [data];
    bandData = bandsOperation(imageDataList, format2, operation2);
  }
  const imageCoord = extentToCoord(coordinates, extent2);
  const resultData = {
    _id: 1,
    dataArray: [
      {
        _id: 1,
        data: bandData,
        width: rasterWidth,
        height: rasterHeight,
        min: min3,
        max: max4,
        coordinates: imageCoord
      }
    ]
  };
  return resultData;
}

// node_modules/@antv/l7-source/es/utils/tile/getCustomData.js
var __async5 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var getCustomData = (tile, getCustomDataFunc, rasterFormat, operation2) => __async5(void 0, null, function* () {
  return new Promise((resolve, reject) => {
    getCustomDataFunc(
      {
        x: tile.x,
        y: tile.y,
        z: tile.z
      },
      (err, data) => {
        if (err || data.length === 0) {
          reject(err);
          return;
        }
        if (data) {
          processRasterData(
            [{ data, bands: [0] }],
            rasterFormat,
            operation2,
            (error, img) => {
              if (error) {
                reject(error);
              } else if (img) {
                resolve(img);
              }
            }
          );
        }
      }
    );
  });
});
var getCustomImageData = (tile, getCustomDataFunc) => __async5(void 0, null, function* () {
  return new Promise((resolve, reject) => {
    getCustomDataFunc(
      {
        x: tile.x,
        y: tile.y,
        z: tile.z
      },
      (err, data) => {
        if (err || !data) {
          reject(err);
          return;
        }
        if (data instanceof ArrayBuffer) {
          formatImage(data, (error, image2) => {
            if (error) {
              reject(error);
            }
            resolve(image2);
          });
        } else if (data instanceof HTMLImageElement) {
          resolve(data);
        } else {
          reject(err);
        }
      }
    );
  });
});

// node_modules/@antv/l7-source/es/utils/tile/request.js
function getTileUrl(url, tileParams) {
  if (Array.isArray(url)) {
    if (typeof url[0] === "string") {
      return url.map((src) => getURLFromTemplate(src, tileParams));
    } else {
      return url.map((o) => {
        return {
          url: getURLFromTemplate(o.url, tileParams),
          bands: o.bands || [0]
        };
      });
    }
  } else {
    return getURLFromTemplate(url, tileParams);
  }
}
function getTileBandParams(urlBandParam) {
  if (typeof urlBandParam === "string") {
    return [
      {
        url: urlBandParam,
        bands: [0]
      }
    ];
  } else if (typeof urlBandParam[0] === "string") {
    return urlBandParam.map((param) => {
      return {
        url: param,
        bands: [0]
      };
    });
  } else {
    return urlBandParam;
  }
}
function bindCancel(tile, xhrList) {
  tile.xhrCancel = () => {
    xhrList.map((xhr) => {
      xhr.abort();
    });
  };
}

// node_modules/@antv/l7-source/es/utils/tile/getRasterData.js
var __defProp9 = Object.defineProperty;
var __defProps9 = Object.defineProperties;
var __getOwnPropDescs9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols9 = Object.getOwnPropertySymbols;
var __hasOwnProp9 = Object.prototype.hasOwnProperty;
var __propIsEnum9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp9 = (obj, key, value) => key in obj ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp9.call(b, prop))
      __defNormalProp9(a, prop, b[prop]);
  if (__getOwnPropSymbols9)
    for (var prop of __getOwnPropSymbols9(b)) {
      if (__propIsEnum9.call(b, prop))
        __defNormalProp9(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps9 = (a, b) => __defProps9(a, __getOwnPropDescs9(b));
var __async6 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var getRasterFile = (tile, requestParameters, callback, rasterFormat, operation2) => __async6(void 0, null, function* () {
  const tileBandParams = getTileBandParams(requestParameters.url);
  if (tileBandParams.length > 1) {
    const { rasterFiles, xhrList, errList } = yield getMultiArrayBuffer(
      tileBandParams,
      requestParameters
    );
    bindCancel(tile, xhrList);
    if (errList.length > 0) {
      callback(errList, null);
      return;
    }
    processRasterData(rasterFiles, rasterFormat, operation2, callback);
  } else {
    const xhr = getArrayBuffer(requestParameters, (err, imgData) => {
      if (err) {
        callback(err);
      } else if (imgData) {
        const rasterFiles = [
          {
            data: imgData,
            bands: tileBandParams[0].bands
          }
        ];
        processRasterData(rasterFiles, rasterFormat, operation2, callback);
      }
    });
    bindCancel(tile, [xhr]);
  }
});
function getMultiArrayBuffer(tileBandParams, requestParameters) {
  return __async6(this, null, function* () {
    const rasterFiles = [];
    const xhrList = [];
    const errList = [];
    for (let i = 0; i < tileBandParams.length; i++) {
      const tileBandParam = tileBandParams[i];
      const params = __spreadProps9(__spreadValues9({}, requestParameters), {
        url: tileBandParam.url
      });
      const bands = tileBandParam.bands;
      const { err, data, xhr } = yield makeXMLHttpRequestPromise(__spreadProps9(__spreadValues9({}, params), {
        type: "arrayBuffer"
      }));
      if (err) {
        errList.push(err);
      }
      xhrList.push(xhr);
      rasterFiles.push({
        data,
        bands
      });
    }
    return { rasterFiles, xhrList, errList };
  });
}

// node_modules/@antv/l7-source/es/utils/tile/getRasterTile.js
var __defProp10 = Object.defineProperty;
var __defProps10 = Object.defineProperties;
var __getOwnPropDescs10 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols10 = Object.getOwnPropertySymbols;
var __hasOwnProp10 = Object.prototype.hasOwnProperty;
var __propIsEnum10 = Object.prototype.propertyIsEnumerable;
var __defNormalProp10 = (obj, key, value) => key in obj ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues10 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp10.call(b, prop))
      __defNormalProp10(a, prop, b[prop]);
  if (__getOwnPropSymbols10)
    for (var prop of __getOwnPropSymbols10(b)) {
      if (__propIsEnum10.call(b, prop))
        __defNormalProp10(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps10 = (a, b) => __defProps10(a, __getOwnPropDescs10(b));
var __async7 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var getTileBuffer = (url, tileParams, tile, cfg) => __async7(void 0, null, function* () {
  const { format: format2 = defaultFormat, operation: operation2, requestParameters = {} } = cfg;
  const reqParams = __spreadProps10(__spreadValues10({}, requestParameters), {
    url: getTileUrl(url, tileParams)
    // getTileUrl 将原始的 url 路径进行转化（多服务器）
  });
  return new Promise((resolve, reject) => {
    getRasterFile(
      tile,
      reqParams,
      (err, img) => {
        if (err) {
          reject(err);
        } else if (img) {
          resolve(img);
        }
      },
      format2,
      operation2
    );
  });
});
var getTileImage = (url, tileParams, tile, cfg) => __async7(void 0, null, function* () {
  let imageUrl;
  const templateUrl = Array.isArray(url) ? url[0] : url;
  if (cfg.wmtsOptions) {
    const getWMTSURLFromTemplateNew = (cfg == null ? void 0 : cfg.getURLFromTemplate) || getWMTSURLFromTemplate;
    imageUrl = getWMTSURLFromTemplateNew(templateUrl, __spreadValues10(__spreadValues10({}, tileParams), cfg.wmtsOptions));
  } else {
    const getURLFromTemplateNew = (cfg == null ? void 0 : cfg.getURLFromTemplate) || getURLFromTemplate;
    imageUrl = getURLFromTemplateNew(templateUrl, tileParams);
  }
  return new Promise((resolve, reject) => {
    var _a2;
    const xhr = getImage(
      __spreadProps10(__spreadValues10({}, cfg == null ? void 0 : cfg.requestParameters), {
        url: imageUrl,
        type: ((_a2 = cfg == null ? void 0 : cfg.requestParameters) == null ? void 0 : _a2.type) || "arrayBuffer"
      }),
      (err, img) => {
        if (err) {
          reject(err);
        } else if (img) {
          resolve(img);
        }
      },
      cfg.transformResponse
    );
    tile.xhrCancel = () => xhr.cancel();
  });
});
var defaultFormat = () => {
  return {
    rasterData: new Uint8Array([0]),
    width: 1,
    height: 1
  };
};

// node_modules/@antv/l7-source/es/parser/raster-tile.js
var __defProp11 = Object.defineProperty;
var __defProps11 = Object.defineProperties;
var __getOwnPropDescs11 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols11 = Object.getOwnPropertySymbols;
var __hasOwnProp11 = Object.prototype.hasOwnProperty;
var __propIsEnum11 = Object.prototype.propertyIsEnumerable;
var __defNormalProp11 = (obj, key, value) => key in obj ? __defProp11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues11 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp11.call(b, prop))
      __defNormalProp11(a, prop, b[prop]);
  if (__getOwnPropSymbols11)
    for (var prop of __getOwnPropSymbols11(b)) {
      if (__propIsEnum11.call(b, prop))
        __defNormalProp11(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps11 = (a, b) => __defProps11(a, __getOwnPropDescs11(b));
var DEFAULT_CONFIG3 = {
  tileSize: 256,
  minZoom: 0,
  maxZoom: Infinity,
  zoomOffset: 0,
  warp: true
};
var rasterDataTypes = [RasterTileType.ARRAYBUFFER, RasterTileType.RGB];
function isUrlError(url) {
  if (Array.isArray(url) && url.length === 0) {
    return true;
  }
  if (!Array.isArray(url) && typeof url !== "string") {
    return true;
  }
  return false;
}
function rasterTile(data, cfg = {}) {
  if (isUrlError(data)) {
    throw new Error("tile server url is error");
  }
  const { extent: extent2 = [Infinity, Infinity, -Infinity, -Infinity], coordinates } = cfg;
  let tileDataType = (cfg == null ? void 0 : cfg.dataType) || RasterTileType.IMAGE;
  if (tileDataType === RasterTileType.RGB) {
    tileDataType = RasterTileType.ARRAYBUFFER;
  }
  const getTileData = (tileParams, tile) => {
    switch (tileDataType) {
      case RasterTileType.IMAGE:
        return getTileImage(data, tileParams, tile, cfg);
      case RasterTileType.CUSTOMIMAGE:
      case RasterTileType.CUSTOMTERRAINRGB:
        return getCustomImageData(
          // 自定义地形请求方式数据
          tile,
          // @ts-ignore
          cfg == null ? void 0 : cfg.getCustomData
        );
      case RasterTileType.ARRAYBUFFER:
        return getTileBuffer(data, tileParams, tile, cfg);
      case RasterTileType.CUSTOMARRAYBUFFER:
      case RasterTileType.CUSTOMRGB:
        return getCustomData(
          tile,
          // @ts-ignore
          cfg == null ? void 0 : cfg.getCustomData,
          (cfg == null ? void 0 : cfg.format) || defaultFormat,
          cfg == null ? void 0 : cfg.operation
        );
      default:
        return getTileImage(data, tileParams, tile, cfg);
    }
  };
  const tilesetOptions = __spreadProps11(__spreadValues11(__spreadValues11({}, DEFAULT_CONFIG3), cfg), { getTileData });
  const rasterTileCoord = extentToCoord(coordinates, extent2);
  return {
    data,
    dataArray: [
      {
        _id: 1,
        coordinates: rasterTileCoord
      }
    ],
    tilesetOptions,
    isTile: true
  };
}

// node_modules/@antv/l7-source/es/parser/raster/ndi.js
var __defProp12 = Object.defineProperty;
var __defProps12 = Object.defineProperties;
var __getOwnPropDescs12 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols12 = Object.getOwnPropertySymbols;
var __hasOwnProp12 = Object.prototype.hasOwnProperty;
var __propIsEnum12 = Object.prototype.propertyIsEnumerable;
var __defNormalProp12 = (obj, key, value) => key in obj ? __defProp12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues12 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp12.call(b, prop))
      __defNormalProp12(a, prop, b[prop]);
  if (__getOwnPropSymbols12)
    for (var prop of __getOwnPropSymbols12(b)) {
      if (__propIsEnum12.call(b, prop))
        __defNormalProp12(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps12 = (a, b) => __defProps12(a, __getOwnPropDescs12(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp12.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols12)
    for (var prop of __getOwnPropSymbols12(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum12.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function rasterRgb(data, cfg) {
  const _a2 = cfg, {
    extent: extent2 = [121.168, 30.2828, 121.384, 30.4219],
    coordinates,
    width,
    height
  } = _a2, options = __objRest(_a2, [
    "extent",
    "coordinates",
    "width",
    "height"
  ]);
  if (data.length < 2) {
    console.warn("RGB解析需要2个波段的数据");
  }
  const [n, d] = options.bands || [0, 1];
  const bandsData = [data[n], data[d]];
  const ndidata = [];
  for (let i = 0; i < bandsData[0].length; i++) {
    ndidata.push((bandsData[1][i] - bandsData[0][i]) / (bandsData[1][i] + bandsData[0][i]));
  }
  const imageCoord = extentToCoord(coordinates, extent2);
  const resultData = {
    _id: 1,
    dataArray: [
      __spreadProps12(__spreadValues12({
        _id: 1,
        data: ndidata,
        width,
        height
      }, options), {
        coordinates: imageCoord
      })
    ]
  };
  return resultData;
}

// node_modules/@antv/l7-source/es/parser/raster/rgb.js
var __defProp13 = Object.defineProperty;
var __defProps13 = Object.defineProperties;
var __getOwnPropDescs13 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols13 = Object.getOwnPropertySymbols;
var __hasOwnProp13 = Object.prototype.hasOwnProperty;
var __propIsEnum13 = Object.prototype.propertyIsEnumerable;
var __defNormalProp13 = (obj, key, value) => key in obj ? __defProp13(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues13 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp13.call(b, prop))
      __defNormalProp13(a, prop, b[prop]);
  if (__getOwnPropSymbols13)
    for (var prop of __getOwnPropSymbols13(b)) {
      if (__propIsEnum13.call(b, prop))
        __defNormalProp13(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps13 = (a, b) => __defProps13(a, __getOwnPropDescs13(b));
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp13.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols13)
    for (var prop of __getOwnPropSymbols13(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum13.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function rasterRgb2(data, cfg) {
  const _a2 = cfg, { extent: extent2, coordinates, width, height } = _a2, options = __objRest2(_a2, ["extent", "coordinates", "width", "height"]);
  if (data.length < 3) {
    console.warn("RGB解析需要三个波段的数据");
  }
  const [r, g, b] = options.bands || [0, 1, 2];
  const bandsData = [data[r], data[g], data[b]];
  const rgbdata = [];
  const [low, high] = (options == null ? void 0 : options.countCut) || [2, 98];
  const minMaxR = (options == null ? void 0 : options.RMinMax) || percentile(bandsData[0], low, high);
  const minMaxG = (options == null ? void 0 : options.GMinMax) || percentile(bandsData[1], low, high);
  const minMaxB = (options == null ? void 0 : options.BMinMax) || percentile(bandsData[2], low, high);
  for (let i = 0; i < bandsData[0].length; i++) {
    rgbdata.push(Math.max(0, bandsData[0][i] - minMaxR[0]));
    rgbdata.push(Math.max(0, bandsData[1][i] - minMaxG[0]));
    rgbdata.push(Math.max(0, bandsData[2][i] - minMaxB[0]));
  }
  const imageCoord = extentToCoord(coordinates, extent2);
  const resultData = {
    _id: 1,
    dataArray: [
      __spreadProps13(__spreadValues13({
        _id: 1,
        data: rgbdata,
        width,
        height,
        rMinMax: minMaxR,
        gMinMax: minMaxG,
        bMinMax: minMaxB
      }, options), {
        coordinates: imageCoord
      })
    ]
  };
  return resultData;
}

// node_modules/@antv/l7-source/es/parser/rasterRgb.js
var __defProp14 = Object.defineProperty;
var __defProps14 = Object.defineProperties;
var __getOwnPropDescs14 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols14 = Object.getOwnPropertySymbols;
var __hasOwnProp14 = Object.prototype.hasOwnProperty;
var __propIsEnum14 = Object.prototype.propertyIsEnumerable;
var __defNormalProp14 = (obj, key, value) => key in obj ? __defProp14(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues14 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp14.call(b, prop))
      __defNormalProp14(a, prop, b[prop]);
  if (__getOwnPropSymbols14)
    for (var prop of __getOwnPropSymbols14(b)) {
      if (__propIsEnum14.call(b, prop))
        __defNormalProp14(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps14 = (a, b) => __defProps14(a, __getOwnPropDescs14(b));
var __objRest3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp14.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols14)
    for (var prop of __getOwnPropSymbols14(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum14.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function rasterRgb3(data, cfg) {
  const _a2 = cfg, { extent: extent2, coordinates, min: min3, max: max4, width, height, format: format2, operation: operation2 } = _a2, rest = __objRest3(_a2, ["extent", "coordinates", "min", "max", "width", "height", "format", "operation"]);
  let bandData;
  if (format2 === void 0 || isNumberArray(data)) {
    bandData = Array.from(data);
  } else {
    const imageDataList = Array.isArray(data) ? data : [data];
    bandData = bandsOperation(imageDataList, format2, operation2);
  }
  const imageCoord = extentToCoord(coordinates, extent2);
  const resultData = {
    _id: 1,
    dataArray: [
      __spreadProps14(__spreadValues14({
        _id: 1,
        data: bandData,
        width,
        height
      }, rest), {
        min: min3,
        max: max4,
        coordinates: imageCoord
      })
    ]
  };
  return resultData;
}

// node_modules/@antv/l7-source/es/parser/testTile.js
var __defProp15 = Object.defineProperty;
var __defProps15 = Object.defineProperties;
var __getOwnPropDescs15 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols15 = Object.getOwnPropertySymbols;
var __hasOwnProp15 = Object.prototype.hasOwnProperty;
var __propIsEnum15 = Object.prototype.propertyIsEnumerable;
var __defNormalProp15 = (obj, key, value) => key in obj ? __defProp15(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues15 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp15.call(b, prop))
      __defNormalProp15(a, prop, b[prop]);
  if (__getOwnPropSymbols15)
    for (var prop of __getOwnPropSymbols15(b)) {
      if (__propIsEnum15.call(b, prop))
        __defNormalProp15(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps15 = (a, b) => __defProps15(a, __getOwnPropDescs15(b));
var __async8 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var DEFAULT_CONFIG4 = {
  tileSize: 256,
  minZoom: 0,
  maxZoom: Infinity,
  zoomOffset: 0
};
var getVectorTile4 = (tile) => __async8(void 0, null, function* () {
  return new Promise((resolve) => {
    const [minLng, minLat, maxLng, maxLat] = tile.bounds;
    const vectorTile = {
      layers: {
        // Tip: fixed SourceLayer Name
        testTile: {
          features: [
            {
              type: "Feature",
              properties: {
                key: tile.x + "/" + tile.y + "/" + tile.z,
                x: (minLng + maxLng) / 2,
                y: (minLat + maxLat) / 2
              },
              geometry: {
                type: "LineString",
                coordinates: [
                  [maxLng, maxLat],
                  [maxLng, minLat],
                  [minLng, minLat],
                  [minLng, minLat]
                ]
              }
            }
          ]
        }
      }
    };
    resolve(vectorTile);
  });
});
function mapboxVectorTile2(data, cfg) {
  const getTileData = (tile) => getVectorTile4(tile);
  const tilesetOptions = __spreadProps15(__spreadValues15(__spreadValues15({}, DEFAULT_CONFIG4), cfg), {
    getTileData
  });
  return {
    data,
    dataArray: [],
    tilesetOptions,
    isTile: true
  };
}

// node_modules/@antv/l7-source/es/source.js
var import_eventemitter3 = __toESM(require_eventemitter3());

// node_modules/@antv/l7-source/es/transform/cluster.js
var import_supercluster = __toESM(require_supercluster());
var __defProp16 = Object.defineProperty;
var __getOwnPropSymbols16 = Object.getOwnPropertySymbols;
var __hasOwnProp16 = Object.prototype.hasOwnProperty;
var __propIsEnum16 = Object.prototype.propertyIsEnumerable;
var __defNormalProp16 = (obj, key, value) => key in obj ? __defProp16(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues16 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp16.call(b, prop))
      __defNormalProp16(a, prop, b[prop]);
  if (__getOwnPropSymbols16)
    for (var prop of __getOwnPropSymbols16(b)) {
      if (__propIsEnum16.call(b, prop))
        __defNormalProp16(a, prop, b[prop]);
    }
  return a;
};
function cluster(data, option) {
  const { radius = 40, maxZoom = 18, minZoom = 0, zoom = 2 } = option;
  if (data.pointIndex) {
    const clusterData = data.pointIndex.getClusters(data.extent, Math.floor(zoom));
    data.dataArray = formatData(clusterData);
    return data;
  }
  const pointIndex = new import_supercluster.default({
    radius,
    minZoom,
    maxZoom
  });
  const geojson = {
    type: "FeatureCollection",
    features: []
  };
  geojson.features = data.dataArray.map((item) => {
    return {
      type: "Feature",
      geometry: {
        type: "Point",
        coordinates: item.coordinates
      },
      properties: __spreadValues16({}, item)
    };
  });
  pointIndex.load(geojson.features);
  return pointIndex;
}
function formatData(clusterPoint) {
  return clusterPoint.map((point2, index3) => {
    return __spreadValues16({
      coordinates: point2.geometry.coordinates,
      _id: index3 + 1
    }, point2.properties);
  });
}

// node_modules/@antv/l7-source/es/utils/statistics.js
function max(x) {
  if (x.length === 0) {
    throw new Error("max requires at least one data point");
  }
  let value = x[0];
  for (let i = 1; i < x.length; i++) {
    if (x[i] > value) {
      value = x[i];
    }
  }
  return value;
}
function min(x) {
  if (x.length === 0) {
    throw new Error("min requires at least one data point");
  }
  let value = x[0];
  for (let i = 1; i < x.length; i++) {
    if (x[i] < value) {
      value = x[i];
    }
  }
  return value;
}
function sum(x) {
  if (x.length === 0) {
    return 0;
  }
  let sumNum = x[0];
  let correction = 0;
  let transition;
  for (let i = 1; i < x.length; i++) {
    transition = sumNum + x[i] * 1;
    if (Math.abs(sumNum) >= Math.abs(x[i])) {
      correction += sumNum - transition + x[i];
    } else {
      correction += x[i] - transition + sumNum;
    }
    sumNum = transition;
  }
  return sumNum + correction * 1;
}
function mean(x) {
  if (x.length === 0) {
    throw new Error("mean requires at least one data point");
  }
  return sum(x) / x.length;
}
var statMap = {
  min,
  max,
  mean,
  sum
};

// node_modules/@antv/l7-source/es/source.js
var __defProp17 = Object.defineProperty;
var __getOwnPropSymbols17 = Object.getOwnPropertySymbols;
var __hasOwnProp17 = Object.prototype.hasOwnProperty;
var __propIsEnum17 = Object.prototype.propertyIsEnumerable;
var __defNormalProp17 = (obj, key, value) => key in obj ? __defProp17(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues17 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp17.call(b, prop))
      __defNormalProp17(a, prop, b[prop]);
  if (__getOwnPropSymbols17)
    for (var prop of __getOwnPropSymbols17(b)) {
      if (__propIsEnum17.call(b, prop))
        __defNormalProp17(a, prop, b[prop]);
    }
  return a;
};
var __async9 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var { cloneDeep, isFunction, isString, mergeWith } = lodashUtil;
function mergeCustomizer(objValue, srcValue) {
  if (Array.isArray(srcValue)) {
    return srcValue;
  }
}
var Source = class extends import_eventemitter3.EventEmitter {
  constructor(data, cfg) {
    super();
    this.type = "source";
    this.isTile = false;
    this.inited = false;
    this.hooks = {
      init: new SyncHook()
    };
    this.parser = { type: "geojson" };
    this.transforms = [];
    this.cluster = false;
    this.clusterOptions = {
      enable: false,
      radius: 40,
      maxZoom: 20,
      zoom: -99,
      method: "count"
    };
    this.invalidExtent = false;
    this.dataArrayChanged = false;
    this.cfg = {
      autoRender: true
    };
    this.originData = data;
    this.initCfg(cfg);
    this.init().then(() => {
      this.inited = true;
      this.emit("update", {
        type: "inited"
      });
    });
  }
  getSourceCfg() {
    return this.cfg;
  }
  getClusters(zoom) {
    return this.clusterIndex.getClusters(this.caculClusterExtent(2), zoom);
  }
  getClustersLeaves(id) {
    return this.clusterIndex.getLeaves(id, Infinity);
  }
  getParserType() {
    return this.parser.type;
  }
  updateClusterData(zoom) {
    const { method = "sum", field } = this.clusterOptions;
    let data = this.clusterIndex.getClusters(this.caculClusterExtent(2), Math.floor(zoom));
    this.clusterOptions.zoom = zoom;
    data.forEach((p) => {
      if (!p.id) {
        p.properties.point_count = 1;
      }
    });
    if (field || isFunction(method)) {
      data = data.map((item) => {
        const id = item.id;
        if (id) {
          const points = this.clusterIndex.getLeaves(id, Infinity);
          const properties = points.map((d) => d.properties);
          let statNum;
          if (isString(method) && field) {
            const column = getColumn(properties, field);
            statNum = statMap[method](column);
          }
          if (isFunction(method)) {
            statNum = method(properties);
          }
          item.properties.stat = statNum;
        } else {
          item.properties.point_count = 1;
        }
        return item;
      });
    }
    this.data = getParser("geojson")({
      type: "FeatureCollection",
      features: data
    });
    this.executeTrans();
  }
  getFeatureById(id) {
    const { type = "geojson", geometry } = this.parser;
    if (type === "geojson" && !this.cluster) {
      const feature = id < this.originData.features.length ? this.originData.features[id] : "null";
      const newFeature = cloneDeep(feature);
      if ((newFeature == null ? void 0 : newFeature.properties) && (this.transforms.length !== 0 || this.dataArrayChanged)) {
        const item = this.data.dataArray.find((dataItem) => {
          return dataItem._id === id;
        });
        newFeature.properties = item;
      }
      return newFeature;
    } else if (type === "json" && geometry) {
      return this.data.dataArray.find((dataItem) => dataItem._id === id);
    } else {
      return id < this.data.dataArray.length ? this.data.dataArray[id] : "null";
    }
  }
  updateFeaturePropertiesById(id, properties) {
    this.data.dataArray = this.data.dataArray.map((dataItem) => {
      if (dataItem._id === id) {
        return __spreadValues17(__spreadValues17({}, dataItem), properties);
      }
      return dataItem;
    });
    this.dataArrayChanged = true;
    this.emit("update", {
      type: "update"
    });
  }
  getFeatureId(field, value) {
    const feature = this.data.dataArray.find((dataItem) => {
      return dataItem[field] === value;
    });
    return feature == null ? void 0 : feature._id;
  }
  setData(data, options) {
    this.originData = data;
    this.dataArrayChanged = false;
    this.initCfg(options);
    this.init().then(() => {
      this.emit("update", {
        type: "update"
      });
    });
  }
  reloadAllTile() {
    var _a2;
    (_a2 = this.tileset) == null ? void 0 : _a2.reloadAll();
  }
  reloadTilebyId(z, x, y) {
    var _a2;
    (_a2 = this.tileset) == null ? void 0 : _a2.reloadTileById(z, x, y);
  }
  reloadTileByLnglat(lng, lat, z) {
    var _a2;
    (_a2 = this.tileset) == null ? void 0 : _a2.reloadTileByLnglat(lng, lat, z);
  }
  getTileExtent(e, zoom) {
    var _a2;
    return (_a2 = this.tileset) == null ? void 0 : _a2.getTileExtent(e, zoom);
  }
  getTileByZXY(z, x, y) {
    var _a2;
    return (_a2 = this.tileset) == null ? void 0 : _a2.getTileByZXY(z, x, y);
  }
  reloadTileByExtent(bounds, z) {
    var _a2;
    (_a2 = this.tileset) == null ? void 0 : _a2.reloadTileByExtent(bounds, z);
  }
  destroy() {
    var _a2;
    this.removeAllListeners();
    this.originData = null;
    this.clusterIndex = null;
    this.data = null;
    (_a2 = this.tileset) == null ? void 0 : _a2.destroy();
  }
  processData() {
    return __async9(this, null, function* () {
      return new Promise((resolve, reject) => {
        try {
          this.excuteParser();
          this.initCluster();
          this.executeTrans();
          resolve({});
        } catch (err) {
          reject(err);
        }
      });
    });
  }
  initCfg(option) {
    this.cfg = mergeWith(this.cfg, option, mergeCustomizer);
    const cfg = this.cfg;
    if (cfg) {
      if (cfg.parser) {
        this.parser = cfg.parser;
      }
      if (cfg.transforms) {
        this.transforms = cfg.transforms;
      }
      this.cluster = cfg.cluster || false;
      if (cfg.clusterOptions) {
        this.cluster = true;
        this.clusterOptions = __spreadValues17(__spreadValues17({}, this.clusterOptions), cfg.clusterOptions);
      }
    }
  }
  init() {
    return __async9(this, null, function* () {
      this.inited = false;
      yield this.processData();
      this.inited = true;
    });
  }
  /**
   * 数据解析
   */
  excuteParser() {
    const parser = this.parser;
    const type = parser.type || "geojson";
    const sourceParser = getParser(type);
    this.data = sourceParser(this.originData, parser);
    this.tileset = this.initTileset();
    if (parser.cancelExtent) {
      return;
    }
    this.extent = extent(this.data.dataArray);
    this.setCenter(this.extent);
    this.invalidExtent = this.extent[0] === this.extent[2] || this.extent[1] === this.extent[3];
  }
  setCenter(bbox) {
    this.center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];
    if (isNaN(this.center[0]) || isNaN(this.center[1])) {
      this.center = [108.92361111111111, 34.54083333333333];
    }
  }
  /**
   * 瓦片数据管理器
   */
  initTileset() {
    const { tilesetOptions } = this.data;
    if (!tilesetOptions) {
      return;
    }
    this.isTile = true;
    if (this.tileset) {
      this.tileset.updateOptions(tilesetOptions);
      return this.tileset;
    }
    const tileset = new TilesetManager(__spreadValues17({}, tilesetOptions));
    return tileset;
  }
  /**
   * 数据统计
   */
  executeTrans() {
    const trans = this.transforms;
    trans.forEach((tran) => {
      const { type } = tran;
      const data = getTransform(type)(this.data, tran);
      Object.assign(this.data, data);
    });
  }
  /**
   * 数据聚合
   */
  initCluster() {
    if (!this.cluster) {
      return;
    }
    const clusterOptions = this.clusterOptions || {};
    this.clusterIndex = cluster(this.data, clusterOptions);
  }
  caculClusterExtent(bufferRatio) {
    let newBounds = [
      [-Infinity, -Infinity],
      [Infinity, Infinity]
    ];
    if (!this.invalidExtent) {
      newBounds = padBounds(bBoxToBounds(this.extent), bufferRatio);
    }
    return newBounds[0].concat(newBounds[1]);
  }
};

// node_modules/@antv/l7-source/es/transform/filter.js
function filter(data, options) {
  const { callback } = options;
  if (callback) {
    data.dataArray = data.dataArray.filter(callback);
  }
  return data;
}

// node_modules/@antv/l7-source/es/transform/grid.js
var R_EARTH = 6378e3;
function aggregatorToGrid(data, option) {
  const dataArray = data.dataArray;
  const { size: size2 = 10 } = option;
  const pixlSize = size2 / (2 * Math.PI * R_EARTH) * (256 << 20) / 2;
  const { gridHash, gridOffset } = _pointsGridHash(dataArray, size2);
  const layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset, option);
  return {
    yOffset: pixlSize,
    xOffset: pixlSize,
    radius: pixlSize,
    type: "grid",
    dataArray: layerData
  };
}
function _pointsGridHash(dataArray, size2) {
  let latMin = Infinity;
  let latMax = -Infinity;
  let pLat;
  for (const point2 of dataArray) {
    pLat = point2.coordinates[1];
    if (Number.isFinite(pLat)) {
      latMin = pLat < latMin ? pLat : latMin;
      latMax = pLat > latMax ? pLat : latMax;
    }
  }
  const centerLat = (latMin + latMax) / 2;
  const gridOffset = _calculateGridLatLonOffset(size2, centerLat);
  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
    return { gridHash: {}, gridOffset };
  }
  const gridHash = {};
  for (const point2 of dataArray) {
    const lat = point2.coordinates[1];
    const lng = point2.coordinates[0];
    if (Number.isFinite(lat) && Number.isFinite(lng)) {
      const latIdx = Math.floor((lat + 90) / gridOffset.yOffset);
      const lonIdx = Math.floor((lng + 180) / gridOffset.xOffset);
      const key = `${latIdx}-${lonIdx}`;
      gridHash[key] = gridHash[key] || { count: 0, points: [] };
      gridHash[key].count += 1;
      gridHash[key].points.push(point2);
    }
  }
  return { gridHash, gridOffset };
}
function _calculateGridLatLonOffset(cellSize, latitude2) {
  const yOffset = _calculateLatOffset(cellSize);
  const xOffset = _calculateLonOffset(latitude2, cellSize);
  return { yOffset, xOffset };
}
function _calculateLatOffset(dy) {
  return dy / R_EARTH * (180 / Math.PI);
}
function _calculateLonOffset(lat, dx) {
  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
}
function _getGridLayerDataFromGridHash(gridHash, gridOffset, option) {
  return Object.keys(gridHash).reduce((accu, key, i) => {
    const idxs = key.split("-");
    const latIdx = parseInt(idxs[0], 10);
    const lonIdx = parseInt(idxs[1], 10);
    const item = {};
    if (option.field && option.method) {
      const columns = statistics_exports.getColumn(gridHash[key].points, option.field);
      item[option.method] = statistics_exports.statMap[option.method](columns);
    }
    Object.assign(item, {
      _id: i,
      coordinates: aProjectFlat([
        -180 + gridOffset.xOffset * (lonIdx + 0.5),
        -90 + gridOffset.yOffset * (latIdx + 0.5)
      ]),
      rawData: gridHash[key].points,
      count: gridHash[key].count
    });
    accu.push(item);
    return accu;
  }, []);
}

// node_modules/d3-hexbin/src/hexbin.js
var thirdPi = Math.PI / 3;
var angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];
function pointX(d) {
  return d[0];
}
function pointY(d) {
  return d[1];
}
function hexbin_default() {
  var x0 = 0, y0 = 0, x1 = 1, y1 = 1, x = pointX, y = pointY, r, dx, dy;
  function hexbin(points) {
    var binsById = {}, bins = [], i, n = points.length;
    for (i = 0; i < n; ++i) {
      if (isNaN(px = +x.call(null, point2 = points[i], i, points)) || isNaN(py = +y.call(null, point2, i, points)))
        continue;
      var point2, px, py, pj = Math.round(py = py / dy), pi = Math.round(px = px / dx - (pj & 1) / 2), py1 = py - pj;
      if (Math.abs(py1) * 3 > 1) {
        var px1 = px - pi, pi2 = pi + (px < pi ? -1 : 1) / 2, pj2 = pj + (py < pj ? -1 : 1), px2 = px - pi2, py2 = py - pj2;
        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2)
          pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
      }
      var id = pi + "-" + pj, bin = binsById[id];
      if (bin)
        bin.push(point2);
      else {
        bins.push(bin = binsById[id] = [point2]);
        bin.x = (pi + (pj & 1) / 2) * dx;
        bin.y = pj * dy;
      }
    }
    return bins;
  }
  function hexagon2(radius) {
    var x02 = 0, y02 = 0;
    return angles.map(function(angle) {
      var x12 = Math.sin(angle) * radius, y12 = -Math.cos(angle) * radius, dx2 = x12 - x02, dy2 = y12 - y02;
      x02 = x12, y02 = y12;
      return [dx2, dy2];
    });
  }
  hexbin.hexagon = function(radius) {
    return "m" + hexagon2(radius == null ? r : +radius).join("l") + "z";
  };
  hexbin.centers = function() {
    var centers = [], j = Math.round(y0 / dy), i = Math.round(x0 / dx);
    for (var y2 = j * dy; y2 < y1 + r; y2 += dy, ++j) {
      for (var x2 = i * dx + (j & 1) * dx / 2; x2 < x1 + dx / 2; x2 += dx) {
        centers.push([x2, y2]);
      }
    }
    return centers;
  };
  hexbin.mesh = function() {
    var fragment = hexagon2(r).slice(0, 4).join("l");
    return hexbin.centers().map(function(p) {
      return "M" + p + "m" + fragment;
    }).join("");
  };
  hexbin.x = function(_) {
    return arguments.length ? (x = _, hexbin) : x;
  };
  hexbin.y = function(_) {
    return arguments.length ? (y = _, hexbin) : y;
  };
  hexbin.radius = function(_) {
    return arguments.length ? (r = +_, dx = r * 2 * Math.sin(thirdPi), dy = r * 1.5, hexbin) : r;
  };
  hexbin.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];
  };
  hexbin.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];
  };
  return hexbin.radius(1);
}

// node_modules/@antv/l7-source/es/transform/hexagon.js
var __defProp18 = Object.defineProperty;
var __defProps16 = Object.defineProperties;
var __getOwnPropDescs16 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols18 = Object.getOwnPropertySymbols;
var __hasOwnProp18 = Object.prototype.hasOwnProperty;
var __propIsEnum18 = Object.prototype.propertyIsEnumerable;
var __defNormalProp18 = (obj, key, value) => key in obj ? __defProp18(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues18 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp18.call(b, prop))
      __defNormalProp18(a, prop, b[prop]);
  if (__getOwnPropSymbols18)
    for (var prop of __getOwnPropSymbols18(b)) {
      if (__propIsEnum18.call(b, prop))
        __defNormalProp18(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps16 = (a, b) => __defProps16(a, __getOwnPropDescs16(b));
var R_EARTH2 = 6378e3;
function pointToHexbin(data, option) {
  const dataArray = data.dataArray;
  const { size: size2 = 10, method = "sum" } = option;
  const pixlSize = size2 / (2 * Math.PI * R_EARTH2) * (256 << 20) / 2;
  const screenPoints = dataArray.map((point2) => {
    const [x, y] = aProjectFlat(point2.coordinates);
    return __spreadProps16(__spreadValues18({}, point2), {
      coordinates: [x, y]
    });
  });
  const newHexbin = hexbin_default().radius(pixlSize).x((d) => d.coordinates[0]).y((d) => d.coordinates[1]);
  const hexbinBins = newHexbin(screenPoints);
  const result = {
    dataArray: hexbinBins.map((hex, index3) => {
      if (option.field && method) {
        const columns = statistics_exports.getColumn(hex, option.field);
        hex[method] = statistics_exports.statMap[method](columns);
      }
      return {
        [option.method]: hex[method],
        count: hex.length,
        rawData: hex,
        coordinates: [hex.x, hex.y],
        _id: index3
      };
    }),
    radius: pixlSize,
    xOffset: pixlSize,
    yOffset: pixlSize,
    type: "hexagon"
  };
  return result;
}

// node_modules/@antv/l7-source/es/transform/join.js
var __defProp19 = Object.defineProperty;
var __getOwnPropSymbols19 = Object.getOwnPropertySymbols;
var __hasOwnProp19 = Object.prototype.hasOwnProperty;
var __propIsEnum19 = Object.prototype.propertyIsEnumerable;
var __defNormalProp19 = (obj, key, value) => key in obj ? __defProp19(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues19 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp19.call(b, prop))
      __defNormalProp19(a, prop, b[prop]);
  if (__getOwnPropSymbols19)
    for (var prop of __getOwnPropSymbols19(b)) {
      if (__propIsEnum19.call(b, prop))
        __defNormalProp19(a, prop, b[prop]);
    }
  return a;
};
function join(geoData, options) {
  const { sourceField, targetField, data } = options;
  const dataObj = {};
  data.forEach((element) => {
    dataObj[element[sourceField]] = element;
  });
  geoData.dataArray = geoData.dataArray.map((item) => {
    const joinName = item[targetField];
    return __spreadValues19(__spreadValues19({}, item), dataObj[joinName]);
  });
  return geoData;
}

// node_modules/@antv/l7-source/es/transform/map.js
function map(data, options) {
  const { callback } = options;
  if (callback) {
    data.dataArray = data.dataArray.map(callback);
  }
  return data;
}

// node_modules/@antv/l7-source/es/index.js
registerParser("rasterTile", rasterTile);
registerParser("mvt", mapboxVectorTile);
registerParser("geojsonvt", geojsonVTTile);
registerParser("testTile", mapboxVectorTile2);
registerParser("geojson", geoJSON);
registerParser("jsonTile", jsonTile);
registerParser("image", image);
registerParser("csv", csv2);
registerParser("json", json);
registerParser("raster", raster);
registerParser("rasterRgb", rasterRgb3);
registerParser("rgb", rasterRgb2);
registerParser("ndi", rasterRgb);
registerTransform("cluster", cluster);
registerTransform("filter", filter);
registerTransform("join", join);
registerTransform("map", map);
registerTransform("grid", aggregatorToGrid);
registerTransform("hexagon", pointToHexbin);
var src_default = Source;

// node_modules/@antv/l7-component/es/marker.js
var import_eventemitter32 = __toESM(require_eventemitter3());
var Marker = class extends import_eventemitter32.EventEmitter {
  // tslint:disable-next-line: no-empty
  getMarkerLayerContainerSize() {
  }
  constructor(option) {
    super();
    _defineProperty(this, "markerOption", void 0);
    _defineProperty(this, "popup", void 0);
    _defineProperty(this, "mapsService", void 0);
    _defineProperty(this, "lngLat", void 0);
    _defineProperty(this, "scene", void 0);
    _defineProperty(this, "added", false);
    _defineProperty(this, "preLngLat", {
      lng: 0,
      lat: 0
    });
    _defineProperty(this, "onMarkerDragStart", (e) => {
      const mapContainer = this.mapsService.getContainer();
      if (!mapContainer) {
        return;
      }
      this.mapsService.setMapStatus({
        dragEnable: false,
        zoomEnable: false
      });
      const {
        left: containerX,
        top: containerY
      } = mapContainer.getClientRects()[0];
      const {
        x: clickX,
        y: clickY
      } = e;
      this.preLngLat = this.mapsService.containerToLngLat([clickX - containerX, clickY - containerY]);
      this.mapsService.on("mousemove", this.onMarkerDragMove);
      document.addEventListener("mouseup", this.onMarkerDragEnd);
      this.emit("dragstart", this.lngLat);
    });
    _defineProperty(this, "onMarkerDragMove", (e) => {
      const lngLat = e.lngLat || e.lnglat;
      const {
        lng: preLng,
        lat: preLat
      } = this.preLngLat;
      const {
        lng: curLng,
        lat: curLat
      } = lngLat;
      const newLngLat = {
        lng: this.lngLat.lng + curLng - preLng,
        lat: this.lngLat.lat + curLat - preLat
      };
      this.setLnglat(newLngLat);
      this.preLngLat = lngLat;
      this.emit("dragging", newLngLat);
    });
    _defineProperty(this, "onMarkerDragEnd", () => {
      this.mapsService.setMapStatus({
        dragEnable: true,
        zoomEnable: true
      });
      this.mapsService.off("mousemove", this.onMarkerDragMove);
      document.removeEventListener("mouseup", this.onMarkerDragEnd);
      this.emit("dragend", this.lngLat);
    });
    _defineProperty(this, "eventHandle", (e) => {
      this.polyfillEvent(e);
      this.emit(e.type, {
        target: e,
        data: this.markerOption.extData,
        lngLat: this.lngLat
      });
    });
    _defineProperty(this, "touchStartTime", void 0);
    this.markerOption = _objectSpread2(_objectSpread2({}, this.getDefault()), option);
    bindAll(["update", "onMove", "onMapClick", "updatePositionWhenZoom"], this);
    this.init();
  }
  getDefault() {
    return {
      element: void 0,
      // DOM element
      anchor: anchorType.BOTTOM,
      offsets: [0, 0],
      color: "#5B8FF9",
      draggable: false,
      overflowHide: true
    };
  }
  addTo(scene) {
    this.scene = scene;
    this.mapsService = scene.mapService;
    const {
      element
    } = this.markerOption;
    this.mapsService.getMarkerContainer().appendChild(element);
    this.registerMarkerEvent(element);
    this.mapsService.on("camerachange", this.update);
    this.update();
    this.updateDraggable();
    this.added = true;
    this.emit("added");
    return this;
  }
  remove() {
    if (this.mapsService) {
      this.mapsService.off("click", this.onMapClick);
      this.mapsService.off("move", this.update);
      this.mapsService.off("moveend", this.update);
      this.mapsService.off("camerachange", this.update);
    }
    this.unRegisterMarkerEvent();
    this.removeAllListeners();
    const {
      element
    } = this.markerOption;
    if (element) {
      dom_exports.remove(element);
    }
    if (this.popup) {
      this.popup.remove();
    }
    return this;
  }
  setLnglat(lngLat) {
    this.lngLat = lngLat;
    if (Array.isArray(lngLat)) {
      this.lngLat = {
        lng: lngLat[0],
        lat: lngLat[1]
      };
    }
    if (this.popup) {
      this.popup.setLnglat(this.lngLat);
    }
    this.update();
    return this;
  }
  getLnglat() {
    return this.lngLat;
  }
  getElement() {
    return this.markerOption.element;
  }
  setElement(el) {
    if (!this.added) {
      this.once("added", () => {
        this.setElement(el);
      });
      return this;
    }
    const {
      element
    } = this.markerOption;
    if (element) {
      dom_exports.remove(element);
    }
    this.markerOption.element = el;
    this.init();
    this.mapsService.getMarkerContainer().appendChild(el);
    this.registerMarkerEvent(el);
    this.updateDraggable();
    this.update();
    return this;
  }
  openPopup() {
    if (!this.added) {
      this.once("added", () => {
        this.openPopup();
      });
      return this;
    }
    const popup = this.popup;
    if (!popup) {
      return this;
    }
    if (!popup.isOpen()) {
      popup.addTo(this.scene);
    }
    return this;
  }
  closePopup() {
    if (!this.added) {
      this.once("added", () => {
        this.closePopup();
      });
    }
    const popup = this.popup;
    if (popup) {
      popup.remove();
    }
    return this;
  }
  setPopup(popup) {
    this.popup = popup;
    if (this.lngLat) {
      this.popup.setLnglat(this.lngLat);
    }
    return this;
  }
  togglePopup() {
    const popup = this.popup;
    if (!popup) {
      return this;
    } else if (popup.isOpen()) {
      popup.remove();
    } else {
      popup.addTo(this.scene);
    }
    return this;
  }
  getPopup() {
    return this.popup;
  }
  getOffset() {
    return this.markerOption.offsets;
  }
  setDraggable(draggable) {
    this.markerOption.draggable = draggable;
    this.updateDraggable();
  }
  getDraggable() {
    return this.markerOption.draggable;
  }
  getExtData() {
    return this.markerOption.extData;
  }
  setExtData(data) {
    this.markerOption.extData = data;
  }
  update() {
    if (!this.mapsService) {
      return;
    }
    const {
      element,
      anchor
    } = this.markerOption;
    this.updatePosition();
    dom_exports.setTransform(element, `${anchorTranslate[anchor]}`);
  }
  //天地图在开始缩放时触发 更新目标位置时添加过渡效果
  updatePositionWhenZoom(ev) {
    if (!this.mapsService) {
      return;
    }
    const {
      element,
      offsets
    } = this.markerOption;
    const {
      lng,
      lat
    } = this.lngLat;
    if (element) {
      element.style.display = "block";
      element.style.whiteSpace = "nowrap";
      const {
        containerHeight,
        containerWidth,
        bounds
      } = this.getMarkerLayerContainerSize() || this.getCurrentContainerSize();
      if (!bounds) {
        return;
      }
      const map8 = ev.map;
      const center = ev.center;
      const zoom = ev.zoom;
      const projectedCenter = map8.DE(this.lngLat, zoom, center);
      projectedCenter.x = Math.round(projectedCenter.x + offsets[0]);
      projectedCenter.y = Math.round(projectedCenter.y - offsets[1]);
      if (Math.abs(bounds[0][0]) > 180 || Math.abs(bounds[1][0]) > 180) {
        if (projectedCenter.x > containerWidth) {
          const newPos = this.mapsService.lngLatToContainer([lng - 360, lat]);
          projectedCenter.x = newPos.x;
        }
        if (projectedCenter.x < 0) {
          const newPos = this.mapsService.lngLatToContainer([lng + 360, lat]);
          projectedCenter.x = newPos.x;
        }
      }
      if (projectedCenter.x > containerWidth || projectedCenter.x < 0 || projectedCenter.y > containerHeight || projectedCenter.y < 0) {
        element.style.display = "none";
      }
      element.style.left = projectedCenter.x + "px";
      element.style.top = projectedCenter.y + "px";
      element.style.transition = "left 0.25s cubic-bezier(0,0,0.25,1), top 0.25s cubic-bezier(0,0,0.25,1)";
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMapClick(e) {
    const {
      element
    } = this.markerOption;
    if (this.popup && element) {
      this.togglePopup();
    }
  }
  getCurrentContainerSize() {
    const container = this.mapsService.getContainer();
    return {
      containerHeight: (container === null || container === void 0 ? void 0 : container.scrollHeight) || 0,
      containerWidth: (container === null || container === void 0 ? void 0 : container.scrollWidth) || 0,
      bounds: this.mapsService.getBounds()
    };
  }
  updateDraggable() {
    const {
      element
    } = this.markerOption;
    element === null || element === void 0 || element.removeEventListener("mousedown", this.onMarkerDragStart);
    this.mapsService.off("mousemove", this.onMarkerDragMove);
    document.removeEventListener("mouseup", this.onMarkerDragEnd);
    if (this.markerOption.draggable) {
      element === null || element === void 0 || element.addEventListener("mousedown", this.onMarkerDragStart);
    }
  }
  updatePosition() {
    if (!this.mapsService) {
      return;
    }
    const {
      element,
      offsets
    } = this.markerOption;
    const {
      lng,
      lat
    } = this.lngLat;
    const pos = this.mapsService.lngLatToContainer([lng, lat]);
    if (element) {
      element.style.display = "block";
      element.style.whiteSpace = "nowrap";
      const {
        containerHeight,
        containerWidth,
        bounds
      } = this.getMarkerLayerContainerSize() || this.getCurrentContainerSize();
      if (!bounds) {
        return;
      }
      if (Math.abs(bounds[0][0]) > 180 || Math.abs(bounds[1][0]) > 180) {
        if (pos.x > containerWidth) {
          const newPos = this.mapsService.lngLatToContainer([lng - 360, lat]);
          pos.x = newPos.x;
        }
        if (pos.x < 0) {
          const newPos = this.mapsService.lngLatToContainer([lng + 360, lat]);
          pos.x = newPos.x;
        }
      }
      if (this.markerOption.overflowHide) {
        if (pos.x > containerWidth || pos.x < 0 || pos.y > containerHeight || pos.y < 0) {
          element.style.display = "none";
        }
      }
      element.style.left = pos.x + offsets[0] + "px";
      element.style.top = pos.y - offsets[1] + "px";
    }
  }
  init() {
    let {
      element
    } = this.markerOption;
    const {
      color: color2,
      anchor
    } = this.markerOption;
    if (!element) {
      element = dom_exports.create("div");
      this.markerOption.element = element;
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttributeNS(null, "display", "block");
      svg.setAttributeNS(null, "height", "48px");
      svg.setAttributeNS(null, "width", "48px");
      svg.setAttributeNS(null, "viewBox", "0 0 1024 1024");
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttributeNS(null, "d", "M512 490.666667C453.12 490.666667 405.333333 442.88 405.333333 384 405.333333 325.12 453.12 277.333333 512 277.333333 570.88 277.333333 618.666667 325.12 618.666667 384 618.666667 442.88 570.88 490.666667 512 490.666667M512 85.333333C346.88 85.333333 213.333333 218.88 213.333333 384 213.333333 608 512 938.666667 512 938.666667 512 938.666667 810.666667 608 810.666667 384 810.666667 218.88 677.12 85.333333 512 85.333333Z");
      path.setAttributeNS(null, "fill", color2);
      svg.appendChild(path);
      element.appendChild(svg);
    }
    dom_exports.addClass(element, "l7-marker");
    Object.keys(this.markerOption.style || {}).forEach(
      // @ts-ignore
      (key) => {
        var _this$markerOption, _this$markerOption2;
        const value = ((_this$markerOption = this.markerOption) === null || _this$markerOption === void 0 ? void 0 : _this$markerOption.style) && ((_this$markerOption2 = this.markerOption) === null || _this$markerOption2 === void 0 ? void 0 : _this$markerOption2.style[key]);
        if (element) {
          element.style[key] = value;
        }
      }
    );
    applyAnchorClass(element, anchor, "marker");
  }
  registerMarkerEvent(element) {
    element.addEventListener("click", this.onMapClick);
    element.addEventListener("mousemove", this.eventHandle);
    element.addEventListener("click", this.eventHandle);
    element.addEventListener("mousedown", this.eventHandle);
    element.addEventListener("mouseup", this.eventHandle);
    element.addEventListener("dblclick", this.eventHandle);
    element.addEventListener("contextmenu", this.eventHandle);
    element.addEventListener("mouseover", this.eventHandle);
    element.addEventListener("mouseout", this.eventHandle);
    element.addEventListener("touchstart", this.eventHandle);
    element.addEventListener("touchend", this.eventHandle);
  }
  unRegisterMarkerEvent() {
    const element = this.getElement();
    element.removeEventListener("click", this.onMapClick);
    element.removeEventListener("mousemove", this.eventHandle);
    element.removeEventListener("click", this.eventHandle);
    element.removeEventListener("mousedown", this.eventHandle);
    element.removeEventListener("mouseup", this.eventHandle);
    element.removeEventListener("dblclick", this.eventHandle);
    element.removeEventListener("contextmenu", this.eventHandle);
    element.removeEventListener("mouseover", this.eventHandle);
    element.removeEventListener("mouseout", this.eventHandle);
    element.removeEventListener("touchstart", this.eventHandle);
    element.removeEventListener("touchend", this.eventHandle);
  }
  polyfillEvent(e) {
    if (!this.mapsService || this.mapsService.getType() !== "amap") {
      return;
    }
    if (!isPC()) {
      if (e.type === "touchstart") {
        this.touchStartTime = Date.now();
      }
      if (e.type === "touchend" && Date.now() - this.touchStartTime < 300) {
        this.emit("click", {
          target: e,
          data: this.markerOption.extData,
          lngLat: this.lngLat
        });
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  addDragHandler(e) {
    return null;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onUp(e) {
    throw new Error("Method not implemented.");
  }
};

// node_modules/@antv/l7-component/es/marker-layer.js
var import_eventemitter33 = __toESM(require_eventemitter3());
var import_supercluster2 = __toESM(require_supercluster());
var {
  merge
} = lodashUtil;
var MarkerLayer = class extends import_eventemitter33.EventEmitter {
  constructor(option) {
    var _this$markerLayerOpti;
    super();
    _defineProperty(this, "markers", []);
    _defineProperty(this, "markerLayerOption", void 0);
    _defineProperty(this, "clusterIndex", void 0);
    _defineProperty(this, "points", []);
    _defineProperty(this, "clusterMarkers", []);
    _defineProperty(this, "mapsService", void 0);
    _defineProperty(this, "scene", void 0);
    _defineProperty(this, "zoom", void 0);
    _defineProperty(this, "bbox", void 0);
    _defineProperty(this, "inited", void 0);
    _defineProperty(this, "containerSize", void 0);
    this.markerLayerOption = merge(this.getDefault(), option);
    bindAll(["update"], this);
    this.zoom = ((_this$markerLayerOpti = this.markerLayerOption.clusterOption) === null || _this$markerLayerOpti === void 0 ? void 0 : _this$markerLayerOpti.zoom) || -99;
  }
  getDefault() {
    return {
      cluster: false,
      clusterOption: {
        radius: 80,
        maxZoom: 20,
        minZoom: 0,
        zoom: -99,
        style: {},
        className: ""
      }
    };
  }
  // 执行scene.addMarkerLayer时调用
  addTo(scene) {
    this.scene = scene;
    this.mapsService = scene.mapService;
    if (this.markerLayerOption.cluster) {
      this.initCluster();
      this.update();
      this.mapsService.on("camerachange", this.update);
      this.mapsService.on("viewchange", this.update);
    }
    this.mapsService.on("camerachange", this.setContainerSize.bind(this));
    this.mapsService.on("viewchange", this.setContainerSize.bind(this));
    this.addMarkers();
    this.inited = true;
    return this;
  }
  // 设置容器大小
  setContainerSize() {
    if (!this.mapsService) {
      return;
    }
    const container = this.mapsService.getContainer();
    this.containerSize = {
      containerWidth: (container === null || container === void 0 ? void 0 : container.scrollWidth) || 0,
      containerHeight: (container === null || container === void 0 ? void 0 : container.scrollHeight) || 0,
      bounds: this.mapsService.getBounds()
    };
  }
  // 获取容器尺寸
  getContainerSize() {
    return this.containerSize;
  }
  // 在图层添加单个marker
  addMarker(marker) {
    const cluster2 = this.markerLayerOption.cluster;
    marker.getMarkerLayerContainerSize = this.getContainerSize.bind(this);
    if (cluster2) {
      this.addPoint(marker, this.markers.length);
      if (this.mapsService) {
        const zoom = this.mapsService.getZoom();
        const bbox = this.mapsService.getBounds();
        this.bbox = padBounds(bbox, 0.5);
        this.zoom = Math.floor(zoom);
        this.getClusterMarker(this.bbox, this.zoom);
      }
    }
    this.markers.push(marker);
  }
  removeMarker(marker) {
    this.markers.indexOf(marker);
    const markerIndex = this.markers.indexOf(marker);
    if (markerIndex > -1) {
      this.markers.splice(markerIndex, 1);
      if (this.markerLayerOption.cluster) {
        this.removePoint(markerIndex);
        if (this.mapsService) {
          this.getClusterMarker(this.bbox, this.zoom);
        }
      }
    }
  }
  /**
   * 隐藏 marker 在每个 marker 上单独修改属性而不是在 markerContainer 上修改（在 markerContainer 修改会有用户在场景加载完之前调用失败的问题）
   */
  hide() {
    this.markers.map((m) => {
      m.getElement().style.opacity = "0";
    });
    this.clusterMarkers.map((m) => {
      m.getElement().style.opacity = "0";
    });
  }
  /**
   * 显示 marker
   */
  show() {
    this.markers.map((m) => {
      m.getElement().style.opacity = "1";
    });
    this.clusterMarkers.map((m) => {
      m.getElement().style.opacity = "1";
    });
  }
  // 返回当下的markers数据，有聚合图时返回聚合的marker列表，否则返回原始maerker列表
  getMarkers() {
    const cluster2 = this.markerLayerOption.cluster;
    return cluster2 ? this.clusterMarkers : this.markers;
  }
  getOriginMarkers() {
    return this.markers;
  }
  // 批量添加marker到scene
  addMarkers() {
    this.getMarkers().forEach((marker) => {
      marker.addTo(this.scene);
    });
  }
  // 清除图层里的marker
  clear() {
    this.markers.forEach((marker) => {
      marker.remove();
    });
    this.clusterMarkers.forEach((clusterMarker) => {
      clusterMarker.remove();
    });
    this.markers = [];
    this.points = [];
    this.clusterMarkers = [];
  }
  destroy() {
    this.clear();
    this.removeAllListeners();
    this.mapsService.off("camerachange", this.update);
    this.mapsService.off("viewchange", this.update);
    this.mapsService.off("camerachange", this.setContainerSize.bind(this));
    this.mapsService.off("viewchange", this.setContainerSize.bind(this));
  }
  // 将marker数据保存在point中
  addPoint(marker, id) {
    const {
      lng,
      lat
    } = marker.getLnglat();
    const feature = {
      geometry: {
        type: "Point",
        coordinates: [lng, lat]
      },
      properties: _objectSpread2(_objectSpread2({}, marker.getExtData()), {}, {
        marker_id: id
      })
    };
    this.points.push(feature);
    if (this.clusterIndex) {
      this.clusterIndex.load(this.points);
    }
  }
  removePoint(id) {
    const targetIndex = this.points.findIndex((point2) => point2.properties.marker_id === id);
    if (targetIndex > -1) {
      this.points.splice(targetIndex, 1);
    }
    if (this.clusterIndex) {
      this.clusterIndex.load(this.points);
    }
  }
  initCluster() {
    if (!this.markerLayerOption.cluster) {
      return;
    }
    const {
      radius,
      minZoom = 0,
      maxZoom
    } = this.markerLayerOption.clusterOption;
    this.clusterIndex = new import_supercluster2.default({
      radius,
      minZoom,
      maxZoom
    });
    this.clusterIndex.load(this.points);
  }
  getClusterMarker(viewBounds, zoom) {
    const viewBBox = viewBounds[0].concat(viewBounds[1]);
    const clusterPoint = this.clusterIndex.getClusters(viewBBox, zoom);
    this.clusterMarkers.forEach((marker) => {
      marker.remove();
    });
    this.clusterMarkers = [];
    clusterPoint.forEach((feature) => {
      var _feature$properties;
      const {
        field,
        method
      } = this.markerLayerOption.clusterOption;
      if ((_feature$properties = feature.properties) !== null && _feature$properties !== void 0 && _feature$properties.cluster_id) {
        var _feature$properties2;
        const clusterData = this.getLeaves((_feature$properties2 = feature.properties) === null || _feature$properties2 === void 0 ? void 0 : _feature$properties2.cluster_id);
        feature.properties.clusterData = clusterData;
        if (field && method) {
          const columnData = clusterData === null || clusterData === void 0 ? void 0 : clusterData.map((item) => {
            const data = {
              [field]: item.properties[field]
            };
            return data;
          });
          const column = statistics_exports.getColumn(columnData, field);
          const stat = statistics_exports.getSatByColumn(method, column);
          const fieldName = "point_" + method;
          feature.properties[fieldName] = stat.toFixed(2);
        }
      }
      const marker = this.clusterMarker(feature);
      this.clusterMarkers.push(marker);
      marker.addTo(this.scene);
    });
  }
  getLeaves(clusterId, limit = Infinity, offset = 0) {
    if (!clusterId) {
      return null;
    }
    return this.clusterIndex.getLeaves(clusterId, limit, offset);
  }
  clusterMarker(feature) {
    const clusterOption = this.markerLayerOption.clusterOption;
    const {
      element = this.generateElement.bind(this)
    } = clusterOption;
    const marker = new Marker({
      element: element(feature)
    }).setLnglat({
      lng: feature.geometry.coordinates[0],
      lat: feature.geometry.coordinates[1]
    });
    return marker;
  }
  normalMarker(feature) {
    const marker_id = feature.properties.marker_id;
    return this.markers[marker_id];
  }
  update() {
    if (!this.mapsService) {
      return;
    }
    if (this.markers.length === 0) {
      return;
    }
    const zoom = this.mapsService.getZoom();
    const bbox = this.mapsService.getBounds();
    if (!this.bbox || Math.abs(zoom - this.zoom) >= 1 || !boundsContains(this.bbox, bbox)) {
      this.bbox = padBounds(bbox, 0.5);
      this.zoom = Math.floor(zoom);
      this.getClusterMarker(this.bbox, this.zoom);
    }
  }
  generateElement(feature) {
    const el = dom_exports.create("div", "l7-marker-cluster");
    const label = dom_exports.create("div", "", el);
    const span = dom_exports.create("span", "", label);
    const {
      field,
      method
    } = this.markerLayerOption.clusterOption;
    feature.properties.point_count = feature.properties.point_count || 1;
    const text = field && method ? feature.properties["point_" + method] || feature.properties[field] : feature.properties.point_count;
    span.textContent = text;
    return el;
  }
};

// node_modules/@antv/l7-component/es/assets/iconfont/iconfont.js
window._iconfont_svg_string_3580659 = '<svg><symbol id="l7-icon-area1" viewBox="0 0 1024 1024"><path d="M796.444444 56.888889a113.777778 113.777778 0 0 1 43.064889 219.136l38.798223 466.261333a113.777778 113.777778 0 1 1-133.518223 145.237334H279.210667a113.777778 113.777778 0 1 1-60.302223-137.272889L697.856 227.555556A113.777778 113.777778 0 0 1 796.444444 56.888889z m56.888889 750.933333a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222z m-682.666666 0a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222z m577.592889-534.072889L269.198222 796.444444c4.152889 7.168 7.509333 14.791111 10.012445 22.812445h465.578666a114.119111 114.119111 0 0 1 65.479111-71.224889l-38.798222-466.261333a112.924444 112.924444 0 0 1-23.210666-7.964445zM796.444444 125.155556a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222z"  ></path></symbol><symbol id="l7-icon-area" viewBox="0 0 1024 1024"><path d="M796.444444 56.888889a113.777778 113.777778 0 0 1 43.008 219.136l38.855112 466.261333a113.777778 113.777778 0 0 1-16.497778 224.540445L853.333333 967.111111a113.777778 113.777778 0 0 1-108.544-79.644444H279.210667a113.834667 113.834667 0 0 1-100.067556 79.36L170.666667 967.111111a113.777778 113.777778 0 0 1-17.066667-226.304l30.492444-351.175111a113.777778 113.777778 0 0 1 34.986667-218.680889L227.555556 170.666667a113.777778 113.777778 0 0 1 99.896888 59.221333l355.84-71.395556a113.777778 113.777778 0 0 1 104.675556-101.262222L796.444444 56.888889z m56.888889 750.933333a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222z m-682.666666 0a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222z m526.051555-582.314666L340.650667 296.903111a113.891556 113.891556 0 0 1-88.462223 98.645333l-30.947555 355.84c27.477333 13.653333 48.64 38.115556 58.026667 67.754667h465.521777a114.119111 114.119111 0 0 1 65.536-71.168l-38.855111-466.261333a113.948444 113.948444 0 0 1-74.752-56.206222zM227.555556 238.933333a45.511111 45.511111 0 1 0 0 91.022223 45.511111 45.511111 0 0 0 0-91.022223z m568.888888-113.777777a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222z"  ></path></symbol><symbol id="l7-icon-delete" viewBox="0 0 1024 1024"><path d="M705.422222 85.333333a34.133333 34.133333 0 0 1 34.133334 34.133334V227.555556h136.533333a34.133333 34.133333 0 0 1 0 68.266666h-25.543111l-24.348445 610.076445a34.133333 34.133333 0 0 1-34.133333 32.768H231.936a34.133333 34.133333 0 0 1-34.076444-32.768L173.340444 295.822222H147.911111a34.133333 34.133333 0 1 1 0-68.266666H284.444444V119.466667a34.133333 34.133333 0 0 1 34.133334-34.133334h386.844444zM241.720889 295.822222l22.983111 574.577778h494.535111l23.04-574.577778H241.720889zM671.288889 153.6H352.711111V227.555556h318.577778V153.6z"  ></path></symbol><symbol id="l7-icon-color" viewBox="0 0 1024 1024"><path d="M512 56.888889c9.841778 0 19.626667 0.341333 29.354667 0.910222 69.176889 4.437333 119.068444 62.577778 124.302222 131.072l0.455111 9.386667c0.739556 44.600889 15.303111 84.935111 44.999111 114.631111 27.022222 27.022222 62.805333 41.528889 102.570667 44.430222l12.060444 0.568889c72.476444 1.194667 135.793778 52.451556 140.458667 124.757333 1.137778 18.261333 1.251556 36.807111 0.170667 55.637334-13.198222 233.585778-211.399111 424.220444-445.326223 428.714666L512 967.111111a455.111111 455.111111 0 0 1-455.054222-464.156444c4.551111-233.927111 195.185778-432.128 428.771555-445.326223C494.535111 57.116444 503.296 56.888889 512 56.888889z m0 68.266667a385.706667 385.706667 0 0 0-22.414222 0.625777C291.726222 136.988444 129.080889 305.948444 125.155556 504.263111c-4.152889 212.366222 163.100444 387.185778 372.508444 394.353778l13.425778 0.227555 8.533333-0.113777c198.371556-3.811556 367.331556-166.456889 378.538667-364.373334a396.174222 396.174222 0 0 0-0.170667-47.331555c-1.991111-31.232-29.127111-56.604444-67.128889-60.472889l-8.248889-0.455111-14.051555-0.682667c-56.547556-4.209778-107.406222-25.884444-145.806222-64.284444-38.855111-38.798222-60.416-90.225778-64.284445-145.749334l-0.910222-21.333333c-2.901333-38.001778-28.785778-66.048-60.302222-68.096A433.891556 433.891556 0 0 0 512 125.155556zM438.044444 682.666667a68.266667 68.266667 0 1 1 0 136.533333 68.266667 68.266667 0 0 1 0-136.533333z m-170.666666-227.555556a68.266667 68.266667 0 1 1 0 136.533333 68.266667 68.266667 0 0 1 0-136.533333z m142.222222-227.555555a68.266667 68.266667 0 1 1 0 136.533333 68.266667 68.266667 0 0 1 0-136.533333z"  ></path></symbol><symbol id="l7-icon-base-map" viewBox="0 0 1024 1024"><path d="M923.761778 115.029333A34.133333 34.133333 0 0 1 967.111111 147.911111v624.128a34.133333 34.133333 0 0 1-22.186667 32.028445l-278.755555 103.992888a34.133333 34.133333 0 0 1-23.665778 0.056889L381.724444 812.714667a34.133333 34.133333 0 0 0-23.665777 0.113777L102.968889 908.060444a34.133333 34.133333 0 0 1-45.738667-26.965333L56.888889 876.088889V251.960889a34.133333 34.133333 0 0 1 22.186667-32.028445l278.755555-103.992888a34.133333 34.133333 0 0 1 20.992-0.967112l266.183111 72.988445a34.133333 34.133333 0 0 0 18.204445 0zM403.911111 192.625778v555.576889l216.177778 79.075555V251.960889l-216.177778-59.335111z m-68.266667 4.380444L125.155556 275.569778v551.310222l210.432-78.506667V197.006222zM898.844444 192.853333l-210.545777 58.936889v575.089778l210.545777-78.563556V192.853333z"  ></path></symbol><symbol id="l7-icon-dot" viewBox="0 0 1024 1024"><path d="M341.333333 739.555556a113.777778 113.777778 0 0 1 8.533334 227.271111L341.333333 967.111111a113.777778 113.777778 0 0 1-8.533333-227.271111L341.333333 739.555556z m0 68.266666a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222zM910.222222 341.333333a113.777778 113.777778 0 0 1 8.533334 227.271111L910.222222 568.888889a113.777778 113.777778 0 0 1-8.533333-227.271111L910.222222 341.333333z m0 68.266667a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222zM227.555556 56.888889a113.777778 113.777778 0 0 1 8.533333 227.271111L227.555556 284.444444a113.777778 113.777778 0 0 1-8.533334-227.271111L227.555556 56.888889z m0 68.266667a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222z"  ></path></symbol><symbol id="l7-icon-display" viewBox="0 0 1024 1024"><path d="M512 170.666667c284.444444 0 455.111111 227.555556 455.111111 341.333333s-170.666667 341.333333-455.111111 341.333333-455.111111-227.555556-455.111111-341.333333 170.666667-341.333333 455.111111-341.333333z m0 68.266666C303.729778 238.933333 125.155556 401.237333 125.155556 512c0 110.762667 178.574222 273.066667 386.844444 273.066667s386.844444-162.304 386.844444-273.066667c0-110.762667-178.574222-273.066667-386.844444-273.066667zM512 341.333333a170.666667 170.666667 0 1 1 0 341.333334 170.666667 170.666667 0 0 1 0-341.333334z m0 68.266667a102.4 102.4 0 1 0 0 204.8 102.4 102.4 0 0 0 0-204.8z"  ></path></symbol><symbol id="l7-icon-enlarge" viewBox="0 0 1024 1024"><path d="M546.133333 147.911111l-0.056889 329.955556H876.088889a34.133333 34.133333 0 0 1 0 68.266666H546.076444v329.955556a34.133333 34.133333 0 0 1-68.266666 0V546.133333H147.911111a34.133333 34.133333 0 1 1 0-68.266666h329.898667V147.911111a34.133333 34.133333 0 0 1 68.266666 0z"  ></path></symbol><symbol id="l7-icon-export-picture" viewBox="0 0 1024 1024"><path d="M883.873684 161.684211a32.336842 32.336842 0 0 1 32.336842 32.336842v582.063158a32.336842 32.336842 0 0 1-32.336842 32.336842H86.231579a32.336842 32.336842 0 0 1-32.336842-32.336842V194.021053a32.336842 32.336842 0 0 1 32.336842-32.336842h797.642105z m-32.336842 64.673684H118.568421v517.389473h170.792421a32.175158 32.175158 0 0 1 0.431158-0.646736l3.772632-4.473264 330.320842-330.374736a32.336842 32.336842 0 0 1 38.588631-5.389474l4.473263 3.018105 184.589474 147.725474V226.357895z m-202.428631 248.131368L379.850105 743.747368H851.536842v-107.304421l-202.428631-161.953684zM323.368421 323.368421a107.789474 107.789474 0 1 1 0 215.578947 107.789474 107.789474 0 0 1 0-215.578947z m0 64.673684a43.115789 43.115789 0 1 0 0 86.231579 43.115789 43.115789 0 0 0 0-86.231579z"  ></path></symbol><symbol id="l7-icon-exit-fullscreen" viewBox="0 0 1024 1024"><path d="M841.955556 591.644444a34.133333 34.133333 0 0 1 5.518222 67.811556l-5.518222 0.455111h-133.745778l192 192.056889a34.133333 34.133333 0 0 1-38.343111 55.182222l-5.176889-2.958222-4.721778-3.982222L659.911111 708.266667V841.955556a34.133333 34.133333 0 0 1-28.615111 33.678222L625.777778 876.088889a34.133333 34.133333 0 0 1-33.678222-28.615111L591.644444 841.955556V625.777778a34.133333 34.133333 0 0 1 28.615112-33.678222L625.777778 591.644444h216.177778z m-443.733334 0a34.133333 34.133333 0 0 1 33.678222 28.615112L432.355556 625.777778v216.177778a34.133333 34.133333 0 0 1-67.811556 5.518222L364.088889 841.955556v-133.745778l-192.056889 192a34.133333 34.133333 0 0 1-52.224-43.52l3.982222-4.721778L315.847111 659.911111H182.044444a34.133333 34.133333 0 0 1-33.678222-28.615111L147.911111 625.777778a34.133333 34.133333 0 0 1 28.615111-33.678222L182.044444 591.644444H398.222222zM167.310222 119.808l4.721778 3.982222L364.088889 315.847111V182.044444a34.133333 34.133333 0 0 1 28.615111-33.678222L398.222222 147.911111a34.133333 34.133333 0 0 1 33.678222 28.615111L432.355556 182.044444V398.222222a34.133333 34.133333 0 0 1-28.615112 33.678222L398.222222 432.355556H182.044444a34.133333 34.133333 0 0 1-5.518222-67.811556L182.044444 364.088889h133.802667L123.790222 172.032a34.133333 34.133333 0 0 1 43.52-52.224z m732.899556 3.982222a34.133333 34.133333 0 0 1 3.982222 43.52l-3.982222 4.721778L708.266667 364.088889H841.955556a34.133333 34.133333 0 0 1 33.678222 28.615111L876.088889 398.222222a34.133333 34.133333 0 0 1-28.615111 33.678222L841.955556 432.355556H625.777778a34.133333 34.133333 0 0 1-33.678222-28.615112L591.644444 398.222222V182.044444a34.133333 34.133333 0 0 1 67.811556-5.518222l0.455111 5.518222v133.802667l192.056889-192.056889a34.133333 34.133333 0 0 1 48.241778 0z"  ></path></symbol><symbol id="l7-icon-line" viewBox="0 0 1024 1024"><path d="M853.333333 56.888889a113.777778 113.777778 0 0 1 8.533334 227.271111L853.333333 284.444444c-19.000889 0-36.864-4.664889-52.622222-12.856888l-529.123555 529.066666a113.777778 113.777778 0 0 1-92.387556 166.115556L170.666667 967.111111a113.777778 113.777778 0 0 1-8.533334-227.271111L170.666667 739.555556c19.000889 0 36.864 4.664889 52.622222 12.856888l529.123555-529.066666a113.777778 113.777778 0 0 1 92.387556-166.115556L853.333333 56.888889zM170.666667 807.822222a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222z m682.666666-682.666666a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222z"  ></path></symbol><symbol id="l7-icon-layer" viewBox="0 0 1024 1024"><path d="M767.089778 625.777778l180.167111 82.773333a34.133333 34.133333 0 0 1 4.892444 59.278222l-4.892444 2.730667-420.977778 193.422222a34.133333 34.133333 0 0 1-22.983111 1.991111l-5.575111-1.991111-420.977778-193.422222a34.133333 34.133333 0 0 1-4.892444-59.278222l4.892444-2.730667L256.853333 625.777778l81.749334 37.546666L172.771556 739.555556 512 895.374222 851.171556 739.555556l-165.831112-76.231112 81.749334-37.546666z m0-227.555556l180.167111 82.773334a34.133333 34.133333 0 0 1 4.892444 59.278222l-4.892444 2.730666-420.977778 193.422223a34.133333 34.133333 0 0 1-22.983111 1.991111l-5.575111-1.991111-420.977778-193.422223a34.133333 34.133333 0 0 1-4.892444-59.278222l4.892444-2.730666L256.853333 398.222222l81.749334 37.546667-165.831111 76.174222L512 667.818667l339.171556-155.875556-165.831112-76.174222L767.089778 398.222222zM497.720889 60.017778a34.133333 34.133333 0 0 1 28.558222 0l420.977778 193.422222a34.133333 34.133333 0 0 1 0 62.008889l-420.977778 193.422222a34.133333 34.133333 0 0 1-28.558222 0l-420.977778-193.422222a34.133333 34.133333 0 0 1 0-62.008889zM512 128.568889L172.771556 284.387556 512 440.263111l339.171556-155.875555L512 128.568889z"  ></path></symbol><symbol id="l7-icon-narrow" viewBox="0 0 1024 1024"><path d="M910.222222 512a34.133333 34.133333 0 0 1-34.133333 34.133333H147.911111a34.133333 34.133333 0 1 1 0-68.266666h728.177778a34.133333 34.133333 0 0 1 34.133333 34.133333z"  ></path></symbol><symbol id="l7-icon-fullscreen" viewBox="0 0 1024 1024"><path d="M645.176889 597.674667l4.721778 3.982222L841.955556 793.6l0.056888-133.688889a34.133333 34.133333 0 0 1 28.615112-33.678222L876.088889 625.777778a34.133333 34.133333 0 0 1 33.678222 28.615111L910.222222 659.911111v216.177778a34.133333 34.133333 0 0 1-28.615111 33.678222L876.088889 910.222222h-216.177778a34.133333 34.133333 0 0 1-5.518222-67.811555l5.518222-0.455111h133.745778l-192-192.056889a34.133333 34.133333 0 0 1 43.52-52.224z m-222.833778 3.982222a34.133333 34.133333 0 0 1 3.982222 43.52l-3.982222 4.721778L230.286222 841.955556H364.088889a34.133333 34.133333 0 0 1 33.678222 28.615111L398.222222 876.088889a34.133333 34.133333 0 0 1-28.615111 33.678222L364.088889 910.222222H147.911111a34.133333 34.133333 0 0 1-33.678222-28.615111L113.777778 876.088889v-216.177778a34.133333 34.133333 0 0 1 67.811555-5.518222l0.455111 5.518222-0.056888 133.745778 192.113777-192a34.133333 34.133333 0 0 1 48.241778 0zM364.088889 113.777778a34.133333 34.133333 0 0 1 5.518222 67.811555L364.088889 182.044444H230.343111l192 192.056889a34.133333 34.133333 0 0 1-43.52 52.224l-4.721778-3.982222-192.113777-192.056889L182.044444 364.088889a34.133333 34.133333 0 0 1-28.615111 33.678222L147.911111 398.222222a34.133333 34.133333 0 0 1-33.678222-28.615111L113.777778 364.088889V147.911111a34.133333 34.133333 0 0 1 28.615111-33.678222L147.911111 113.777778h216.177778z m512 0a34.133333 34.133333 0 0 1 33.678222 28.615111L910.222222 147.911111v216.177778a34.133333 34.133333 0 0 1-67.811555 5.518222L841.955556 364.088889l-0.056889-133.745778-192 192a34.133333 34.133333 0 0 1-52.224-43.52l3.982222-4.721778L793.6 182.044444H659.911111a34.133333 34.133333 0 0 1-33.678222-28.615111L625.777778 147.911111a34.133333 34.133333 0 0 1 28.615111-33.678222L659.911111 113.777778h216.177778z"  ></path></symbol><symbol id="l7-icon-hide" viewBox="0 0 1024 1024"><path d="M875.52 87.836444a34.133333 34.133333 0 0 1 7.281778 43.121778l-3.527111 5.006222-682.666667 796.444445a34.133333 34.133333 0 0 1-55.409778-39.367111l3.527111-5.006222 97.166223-113.379556C123.164444 697.969778 56.888889 582.940444 56.888889 512c0-113.777778 170.666667-341.333333 455.111111-341.333333a496.64 496.64 0 0 1 208.952889 45.112889l106.439111-124.188445a34.133333 34.133333 0 0 1 48.128-3.754667z m-38.684444 202.524445C921.031111 362.951111 967.111111 452.835556 967.111111 512c0 113.777778-170.666667 341.333333-455.111111 341.333333-50.631111 0-97.678222-7.224889-140.8-19.740444l50.232889-58.595556A417.393778 417.393778 0 0 0 512 785.066667c208.270222 0 386.844444-162.304 386.844444-273.066667 0-52.849778-40.675556-117.418667-105.813333-170.496l43.804445-51.2zM512 238.933333C303.729778 238.933333 125.155556 401.237333 125.155556 512c0 66.787556 64.853333 152.291556 162.133333 209.692444L377.173333 616.675556a170.666667 170.666667 0 0 1 217.713778-253.895112l78.620445-91.704888A432.924444 432.924444 0 0 0 512 238.933333z m166.684444 236.088889a170.666667 170.666667 0 0 1-177.664 207.303111l177.607112-207.303111zM512 409.6a102.4 102.4 0 0 0-88.746667 153.486222L548.864 416.426667A102.172444 102.172444 0 0 0 512 409.6z"  ></path></symbol><symbol id="l7-icon-rectangle" viewBox="0 0 1024 1024"><path d="M170.666667 56.888889a113.777778 113.777778 0 0 1 108.544 79.644444H853.333333a34.133333 34.133333 0 0 1 33.678223 28.615111L887.466667 170.666667v574.122666a113.777778 113.777778 0 1 1-142.677334 142.734223L170.666667 887.466667a34.133333 34.133333 0 0 1-33.678223-28.615111L136.533333 853.333333V279.210667A113.777778 113.777778 0 0 1 170.666667 56.888889z m682.666666 750.933333a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222z m-34.133333-603.022222H279.210667a114.062222 114.062222 0 0 1-74.353778 74.410667L204.8 819.2h539.989333a114.062222 114.062222 0 0 1 74.410667-74.410667V204.8zM170.666667 125.155556a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222z"  ></path></symbol><symbol id="l7-icon-ranging" viewBox="0 0 1024 1024"><path d="M723.171556 50.403556l250.424888 250.424888a31.061333 31.061333 0 0 1 0 43.918223L344.746667 973.596444a31.061333 31.061333 0 0 1-43.918223 0L50.403556 723.171556a31.061333 31.061333 0 0 1 0-43.918223L679.253333 50.403556a31.061333 31.061333 0 0 1 43.918223 0z m-21.959112 74.524444l-39.765333 39.822222 98.986667 98.872889a34.133333 34.133333 0 0 1-44.088889 51.882667l-4.209778-3.640889-98.929778-98.929778-63.886222 63.886222 62.179556 62.122667a34.133333 34.133333 0 0 1-44.088889 51.882667L563.2 387.242667 501.077333 325.063111 437.191111 388.949333l98.986667 98.929778a34.133333 34.133333 0 0 1-44.088889 51.882667l-4.209778-3.640889-98.929778-98.929778-63.886222 63.886222L387.242667 563.2a34.133333 34.133333 0 0 1-44.088889 51.882667l-4.209778-3.584-62.122667-62.179556-63.886222 63.886222 98.986667 98.929778a34.133333 34.133333 0 0 1-44.088889 51.882667l-4.209778-3.640889-98.929778-98.929778-39.765333 39.822222 197.802667 197.745778 576.284444-576.284444-197.802667-197.745778z"  ></path></symbol><symbol id="l7-icon-reposition" viewBox="0 0 1024 1024"><path d="M512 56.888889a34.133333 34.133333 0 0 1 34.133333 34.133333v24.177778A398.336 398.336 0 0 1 908.856889 477.866667h24.177778a34.133333 34.133333 0 0 1 0 68.266666h-24.177778A398.336 398.336 0 0 1 546.133333 908.856889L546.133333 932.977778a34.133333 34.133333 0 0 1-68.266666 0v-24.177778A398.336 398.336 0 0 1 115.2 546.133333L91.022222 546.133333a34.133333 34.133333 0 1 1 0-68.266666h24.177778A398.336 398.336 0 0 1 477.866667 115.2V91.022222A34.133333 34.133333 0 0 1 512 56.888889z m34.190222 126.862222L546.133333 193.422222a34.133333 34.133333 0 1 1-68.266666 0v-9.671111A330.069333 330.069333 0 0 0 183.751111 477.866667h9.671111a34.133333 34.133333 0 1 1 0 68.266666l-9.671111 0.056889A330.069333 330.069333 0 0 0 477.866667 840.248889V830.577778a34.133333 34.133333 0 0 1 68.266666 0l0.056889 9.671111A330.069333 330.069333 0 0 0 840.248889 546.133333L830.577778 546.133333a34.133333 34.133333 0 0 1 0-68.266666h9.671111A330.069333 330.069333 0 0 0 546.133333 183.751111zM512 341.333333a170.666667 170.666667 0 1 1 0 341.333334 170.666667 170.666667 0 0 1 0-341.333334z m0 68.266667a102.4 102.4 0 1 0 0 204.8 102.4 102.4 0 0 0 0-204.8z"  ></path></symbol><symbol id="l7-icon-round" viewBox="0 0 1024 1024"><path d="M512 56.888889a455.111111 455.111111 0 0 1 391.395556 687.502222 113.777778 113.777778 0 0 1-159.061334 158.890667A455.111111 455.111111 0 0 1 120.604444 279.608889 113.777778 113.777778 0 0 1 279.608889 120.604444 452.835556 452.835556 0 0 1 512 56.888889z m0 68.266667a384.910222 384.910222 0 0 0-191.715556 50.744888A113.777778 113.777778 0 0 1 175.957333 320.284444a386.844444 386.844444 0 0 0 527.815111 527.758223 113.777778 113.777778 0 0 1 144.270223-144.440889A386.844444 386.844444 0 0 0 512 125.155556z m299.406222 640.739555a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222zM212.593778 167.082667a45.511111 45.511111 0 1 0 0 91.022222 45.511111 45.511111 0 0 0 0-91.022222z"  ></path></symbol><symbol id="l7-icon-guanbi" viewBox="0 0 1024 1024"><path d="M576 512l277.333333 277.333333-64 64-277.333333-277.333333L234.666667 853.333333 170.666667 789.333333l277.333333-277.333333L170.666667 234.666667 234.666667 170.666667l277.333333 277.333333L789.333333 170.666667 853.333333 234.666667 576 512z"  ></path></symbol></svg>', function(t) {
  try {
    let d2 = function() {
      m || (m = true, i());
    }, L2 = function() {
      try {
        n.documentElement.doScroll("left");
      } catch (a2) {
        return void setTimeout(L2, 50);
      }
      d2();
    };
    var d = d2, L = L2;
    var a = (a = document.getElementsByTagName("script"))[a.length - 1], l = a.getAttribute("data-injectcss"), a = a.getAttribute("data-disable-injectsvg");
    if (!a) {
      var o, e, i, n, m, c = function(a2, l2) {
        l2.parentNode.insertBefore(a2, l2);
      };
      if (l && !t.__iconfont__svg__cssinject__) {
        t.__iconfont__svg__cssinject__ = true;
        try {
          document.write("<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>");
        } catch (a2) {
          console && console.log(a2);
        }
      }
      o = function() {
        var a2, l2 = document.createElement("div");
        l2.innerHTML = t._iconfont_svg_string_3580659, (l2 = l2.getElementsByTagName("svg")[0]) && (l2.setAttribute("aria-hidden", "true"), l2.style.position = "absolute", l2.style.width = 0, l2.style.height = 0, l2.style.overflow = "hidden", l2 = l2, (a2 = document.body).firstChild ? c(l2, a2.firstChild) : a2.appendChild(l2));
      }, document.addEventListener ? ~["complete", "loaded", "interactive"].indexOf(document.readyState) ? setTimeout(o, 0) : (e = function() {
        document.removeEventListener("DOMContentLoaded", e, false), o();
      }, document.addEventListener("DOMContentLoaded", e, false)) : document.attachEvent && (i = o, n = t.document, m = false, L2(), n.onreadystatechange = function() {
        "complete" == n.readyState && (n.onreadystatechange = null, d2());
      });
    }
  } catch (e3) {
  }
}(window);

// node_modules/@antv/l7-component/es/control/baseControl/control.js
var import_eventemitter34 = __toESM(require_eventemitter3());
var Control = class _Control extends import_eventemitter34.default {
  constructor(option) {
    super();
    _defineProperty(this, "controlOption", void 0);
    _defineProperty(this, "container", void 0);
    _defineProperty(this, "isShow", void 0);
    _defineProperty(this, "sceneContainer", void 0);
    _defineProperty(this, "scene", void 0);
    _defineProperty(this, "mapsService", void 0);
    _defineProperty(this, "renderService", void 0);
    _defineProperty(this, "layerService", void 0);
    _defineProperty(this, "controlService", void 0);
    _defineProperty(this, "configService", void 0);
    _Control.controlCount++;
    this.controlOption = _objectSpread2(_objectSpread2({}, this.getDefault(option)), option || {});
  }
  getOptions() {
    return this.controlOption;
  }
  /**
   * 更新配置的方法，子类如果有自己的配置，也需要重写该方法
   * @param newOptions
   */
  setOptions(newOptions) {
    const defaultOptions = this.getDefault(newOptions);
    Object.entries(newOptions).forEach(([key, value]) => {
      if (value === void 0) {
        newOptions[key] = defaultOptions[key];
      }
    });
    if ("position" in newOptions) {
      this.setPosition(newOptions.position);
    }
    if ("className" in newOptions) {
      this.setClassName(newOptions.className);
    }
    if ("style" in newOptions) {
      this.setStyle(newOptions.style);
    }
    this.controlOption = _objectSpread2(_objectSpread2({}, this.controlOption), newOptions);
  }
  /**
   * 当 Control 被添加至 Scene 中，被 controlService 调用的方法
   * @param sceneContainer
   */
  addTo(sceneContainer) {
    this.mapsService = sceneContainer.mapService;
    this.renderService = sceneContainer.rendererService;
    this.layerService = sceneContainer.layerService;
    this.controlService = sceneContainer.controlService;
    this.configService = sceneContainer.globalConfigService;
    this.scene = sceneContainer.sceneService;
    this.sceneContainer = sceneContainer;
    this.isShow = true;
    this.container = this.onAdd();
    dom_exports.addClass(this.container, "l7-control");
    const {
      className,
      style
    } = this.controlOption;
    if (className) {
      this.setClassName(className);
    }
    if (style) {
      this.setStyle(style);
    }
    this.insertContainer();
    this.emit("add", this);
    return this;
  }
  /**
   * 将控件移除时触发
   */
  remove() {
    if (!this.mapsService) {
      return this;
    }
    dom_exports.remove(this.container);
    this.onRemove();
    this.emit("remove", this);
  }
  /**
   * Control 被添加的时候被调用，返回 Control 对应的 DOM 容器
   */
  onAdd() {
    return dom_exports.create("div");
  }
  /**
   * Control 被移除时调用
   */
  // tslint:disable-next-line:no-empty
  onRemove() {
  }
  /**
   * 显示控件时触发
   */
  show() {
    const container = this.container;
    dom_exports.removeClass(container, "l7-control--hide");
    this.isShow = true;
    this.emit("show", this);
  }
  /**
   * 隐藏控件时触发
   */
  hide() {
    const container = this.container;
    dom_exports.addClass(container, "l7-control--hide");
    this.isShow = false;
    this.emit("hide", this);
  }
  /**
   * 获取默认构造器参数
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getDefault(option) {
    return {
      position: PositionType.TOPRIGHT,
      name: `${_Control.controlCount}`
    };
  }
  /**
   * 获取当前控件对应的 DOM 容器
   */
  getContainer() {
    return this.container;
  }
  /**
   * 获取当前 Control 是否展示
   */
  getIsShow() {
    return this.isShow;
  }
  _refocusOnMap(e) {
    if (this.mapsService && e && e.screenX > 0 && e.screenY > 0) {
      const container = this.mapsService.getContainer();
      if (container !== null) {
        container.focus();
      }
    }
  }
  /**
   * 设置当前控件位置
   * @param position
   */
  setPosition(position = PositionType.TOPLEFT) {
    const controlService = this.controlService;
    if (controlService) {
      controlService.removeControl(this);
    }
    this.controlOption.position = position;
    if (controlService) {
      controlService.addControl(this, this.sceneContainer);
    }
    return this;
  }
  /**
   * 设置容器 container 的样式相关位置，包含 className
   * @param className
   */
  setClassName(className) {
    const container = this.container;
    const {
      className: oldClassName
    } = this.controlOption;
    if (oldClassName) {
      dom_exports.removeClass(container, oldClassName);
    }
    if (className) {
      dom_exports.addClass(container, className);
    }
  }
  /**
   * 设置容器 container 的样式相关位置，包含 style
   * @param style
   */
  setStyle(style) {
    const container = this.container;
    if (style) {
      container.setAttribute("style", style);
    } else {
      container.removeAttribute("style");
    }
  }
  /**
   * 将控件 DOM 插入到对应 position 的容器中
   * @protected
   */
  insertContainer() {
    const position = this.controlOption.position;
    const container = this.container;
    if (position instanceof Element) {
      position.appendChild(container);
    } else {
      const corner = this.controlService.controlCorners[position];
      if (["bottomleft", "bottomright", "righttop", "rightbottom"].includes(position)) {
        corner.insertBefore(container, corner.firstChild);
      } else {
        corner.appendChild(container);
      }
    }
  }
  /**
   * 检查当前传入 option 是否包含 keys 字段
   * @param option
   * @param keys
   * @protected
   */
  checkUpdateOption(option, keys) {
    return keys.some((key) => key in option);
  }
};
_defineProperty(Control, "controlCount", 0);

// node_modules/@antv/l7-component/es/control/baseControl/buttonControl.js
var ButtonControl = class extends Control {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "isDisable", false);
    _defineProperty(this, "button", void 0);
    _defineProperty(this, "buttonText", void 0);
    _defineProperty(this, "buttonIcon", void 0);
  }
  /**
   * 设置当前按钮
   * @param newIsDisable
   */
  setIsDisable(newIsDisable) {
    this.isDisable = newIsDisable;
    if (newIsDisable) {
      var _this$button;
      (_this$button = this.button) === null || _this$button === void 0 || _this$button.setAttribute("disabled", "true");
    } else {
      var _this$button2;
      (_this$button2 = this.button) === null || _this$button2 === void 0 || _this$button2.removeAttribute("disabled");
    }
  }
  createButton(className = "") {
    return dom_exports.create("button", `l7-button-control ${className}`);
  }
  onAdd() {
    this.button = this.createButton();
    this.isDisable = false;
    const {
      title,
      btnText,
      btnIcon
    } = this.controlOption;
    this.setBtnTitle(title);
    this.setBtnText(btnText);
    this.setBtnIcon(btnIcon);
    return this.button;
  }
  onRemove() {
    this.button = this.buttonIcon = this.buttonText = void 0;
    this.isDisable = false;
  }
  /**
   * 更新配置方法
   * @param newOptions
   */
  setOptions(newOptions) {
    const {
      title,
      btnText,
      btnIcon
    } = newOptions;
    if (this.checkUpdateOption(newOptions, ["title"])) {
      this.setBtnTitle(title);
    }
    if (this.checkUpdateOption(newOptions, ["btnIcon"])) {
      this.setBtnIcon(btnIcon);
    }
    if (this.checkUpdateOption(newOptions, ["btnText"])) {
      this.setBtnText(btnText);
    }
    super.setOptions(newOptions);
  }
  /**
   * 设置按钮 title
   * @param title
   */
  setBtnTitle(title) {
    var _this$button3;
    (_this$button3 = this.button) === null || _this$button3 === void 0 || _this$button3.setAttribute("title", title !== null && title !== void 0 ? title : "");
  }
  /**
   * 设置按钮 Icon
   * @param newIcon
   */
  setBtnIcon(newIcon) {
    if (this.buttonIcon) {
      dom_exports.remove(this.buttonIcon);
    }
    if (newIcon) {
      var _this$button4;
      const firstChild = (_this$button4 = this.button) === null || _this$button4 === void 0 ? void 0 : _this$button4.firstChild;
      if (firstChild) {
        var _this$button5;
        (_this$button5 = this.button) === null || _this$button5 === void 0 || _this$button5.insertBefore(newIcon, firstChild);
      } else {
        var _this$button6;
        (_this$button6 = this.button) === null || _this$button6 === void 0 || _this$button6.appendChild(newIcon);
      }
      this.buttonIcon = newIcon;
    }
  }
  /**
   * 设置按钮文本
   * @param newText
   */
  setBtnText(newText) {
    if (!this.button) {
      return;
    }
    dom_exports.removeClass(this.button, "l7-button-control--row");
    dom_exports.removeClass(this.button, "l7-button-control--column");
    if (newText) {
      let btnText = this.buttonText;
      if (!btnText) {
        var _this$button7;
        btnText = dom_exports.create("div", "l7-button-control__text");
        (_this$button7 = this.button) === null || _this$button7 === void 0 || _this$button7.appendChild(btnText);
        this.buttonText = btnText;
      }
      btnText.innerText = newText;
      dom_exports.addClass(this.button, this.controlOption.vertical ? "l7-button-control--column" : "l7-button-control--row");
    } else if (!newText && this.buttonText) {
      dom_exports.remove(this.buttonText);
      this.buttonText = void 0;
    }
  }
};

// node_modules/@antv/l7-component/es/utils/popper.js
var import_eventemitter35 = __toESM(require_eventemitter3());
var Popper = class _Popper extends import_eventemitter35.EventEmitter {
  get buttonRect() {
    return this.button.getBoundingClientRect();
  }
  constructor(button, option) {
    super();
    _defineProperty(this, "popperDOM", void 0);
    _defineProperty(this, "contentDOM", void 0);
    _defineProperty(this, "button", void 0);
    _defineProperty(this, "option", void 0);
    _defineProperty(this, "isShow", false);
    _defineProperty(this, "content", void 0);
    _defineProperty(this, "timeout", null);
    _defineProperty(this, "show", () => {
      if (this.isShow || !this.contentDOM.innerHTML) {
        return this;
      }
      this.resetPopperPosition();
      dom_exports.removeClass(this.popperDOM, "l7-popper-hide");
      this.isShow = true;
      if (this.option.unique) {
        _Popper.conflictPopperList.forEach((popper) => {
          if (popper !== this && popper.isShow) {
            popper.hide();
          }
        });
      }
      this.emit("show");
      window.addEventListener("pointerdown", this.onPopperUnClick);
      return this;
    });
    _defineProperty(this, "hide", () => {
      if (!this.isShow) {
        return this;
      }
      dom_exports.addClass(this.popperDOM, "l7-popper-hide");
      this.isShow = false;
      this.emit("hide");
      window.removeEventListener("pointerdown", this.onPopperUnClick);
      return this;
    });
    _defineProperty(this, "setHideTimeout", () => {
      if (this.timeout) {
        return;
      }
      this.timeout = window.setTimeout(() => {
        if (!this.isShow) {
          return;
        }
        this.hide();
        this.timeout = null;
      }, 300);
    });
    _defineProperty(this, "clearHideTimeout", () => {
      if (this.timeout) {
        window.clearTimeout(this.timeout);
        this.timeout = null;
      }
    });
    _defineProperty(this, "onBtnClick", () => {
      if (this.isShow) {
        this.hide();
      } else {
        this.show();
      }
    });
    _defineProperty(this, "onPopperUnClick", (e) => {
      if (!dom_exports.findParentElement(e.target, [".l7-button-control", ".l7-popper-content"])) {
        this.hide();
      }
    });
    _defineProperty(this, "onBtnMouseLeave", () => {
      this.setHideTimeout();
    });
    _defineProperty(this, "onBtnMouseMove", () => {
      this.clearHideTimeout();
      if (this.isShow) {
        return;
      }
      this.show();
    });
    this.button = button;
    this.option = option;
    this.init();
    if (option.unique) {
      _Popper.conflictPopperList.push(this);
    }
  }
  getPopperDOM() {
    return this.popperDOM;
  }
  getIsShow() {
    return this.isShow;
  }
  getContent() {
    return this.content;
  }
  setContent(content) {
    if (typeof content === "string") {
      this.contentDOM.innerHTML = content;
    } else if (content instanceof HTMLElement) {
      dom_exports.clearChildren(this.contentDOM);
      this.contentDOM.appendChild(content);
    }
    this.content = content;
  }
  init() {
    const {
      trigger
    } = this.option;
    this.popperDOM = this.createPopper();
    if (trigger === "click") {
      this.button.addEventListener("click", this.onBtnClick);
    } else {
      this.button.addEventListener("mousemove", this.onBtnMouseMove);
      this.button.addEventListener("mouseleave", this.onBtnMouseLeave);
      this.popperDOM.addEventListener("mousemove", this.onBtnMouseMove);
      this.popperDOM.addEventListener("mouseleave", this.onBtnMouseLeave);
    }
  }
  destroy() {
    this.button.removeEventListener("click", this.onBtnClick);
    this.button.removeEventListener("mousemove", this.onBtnMouseMove);
    this.button.removeEventListener("mousemove", this.onBtnMouseLeave);
    this.popperDOM.removeEventListener("mousemove", this.onBtnMouseMove);
    this.popperDOM.removeEventListener("mouseleave", this.onBtnMouseLeave);
    dom_exports.remove(this.popperDOM);
  }
  resetPopperPosition() {
    const popperStyleObj = {};
    const {
      container,
      offset = [0, 0],
      placement
    } = this.option;
    const [offsetX, offsetY] = offset;
    const buttonRect = this.button.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    const {
      left,
      right,
      top,
      bottom
    } = dom_exports.getDiffRect(buttonRect, containerRect);
    let isTransformX = false;
    let isTransformY = false;
    if (/^(left|right)/.test(placement)) {
      if (placement.includes("left")) {
        popperStyleObj.right = `${buttonRect.width + right}px`;
      } else if (placement.includes("right")) {
        popperStyleObj.left = `${buttonRect.width + left}px`;
      }
      if (placement.includes("start")) {
        popperStyleObj.top = `${top}px`;
      } else if (placement.includes("end")) {
        popperStyleObj.bottom = `${bottom}px`;
      } else {
        popperStyleObj.top = `${top + buttonRect.height / 2}px`;
        isTransformY = true;
        popperStyleObj.transform = `translate(${offsetX}px, calc(${offsetY}px - 50%))`;
      }
    } else if (/^(top|bottom)/.test(placement)) {
      if (placement.includes("top")) {
        popperStyleObj.bottom = `${buttonRect.height + bottom}px`;
      } else if (placement.includes("bottom")) {
        popperStyleObj.top = `${buttonRect.height + top}px`;
      }
      if (placement.includes("start")) {
        popperStyleObj.left = `${left}px`;
      } else if (placement.includes("end")) {
        popperStyleObj.right = `${right}px`;
      } else {
        popperStyleObj.left = `${left + buttonRect.width / 2}px`;
        isTransformX = true;
        popperStyleObj.transform = `translate(calc(${offsetX}px - 50%), ${offsetY}px)`;
      }
    }
    popperStyleObj.transform = `translate(calc(${offsetX}px - ${isTransformX ? "50%" : "0%"}), calc(${offsetY}px - ${isTransformY ? "50%" : "0%"})`;
    const posList = placement.split("-");
    if (posList.length) {
      dom_exports.addClass(this.popperDOM, posList.map((pos) => `l7-popper-${pos}`).join(" "));
    }
    dom_exports.addStyle(this.popperDOM, dom_exports.css2Style(popperStyleObj));
  }
  createPopper() {
    const {
      container,
      className = "",
      content
    } = this.option;
    const popper = dom_exports.create("div", `l7-popper l7-popper-hide ${className}`);
    const popperContent = dom_exports.create("div", "l7-popper-content");
    const popperArrow = dom_exports.create("div", "l7-popper-arrow");
    popper.appendChild(popperContent);
    popper.appendChild(popperArrow);
    container.appendChild(popper);
    this.popperDOM = popper;
    this.contentDOM = popperContent;
    if (content) {
      this.setContent(content);
    }
    return popper;
  }
};
_defineProperty(Popper, "conflictPopperList", []);

// node_modules/@antv/l7-component/es/control/baseControl/popperControl.js
var PopperPlacementMap = {
  topleft: "right-start",
  topcenter: "bottom",
  topright: "left-start",
  bottomleft: "right-end",
  bottomcenter: "top",
  bottomright: "left-end",
  lefttop: "bottom-start",
  leftcenter: "right",
  leftbottom: "top-start",
  righttop: "bottom-end",
  rightcenter: "left",
  rightbottom: "top-end"
};
var PopperControl = class extends ButtonControl {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "popper", void 0);
  }
  getPopper() {
    return this.popper;
  }
  hide() {
    this.popper.hide();
    super.hide();
  }
  /**
   * 获取默认配置
   * @param option
   */
  getDefault(option) {
    var _option$position;
    const defaultOption = super.getDefault(option);
    const position = (_option$position = option === null || option === void 0 ? void 0 : option.position) !== null && _option$position !== void 0 ? _option$position : defaultOption.position;
    return _objectSpread2(_objectSpread2({}, super.getDefault(option)), {}, {
      popperPlacement: position instanceof Element ? "bottom" : PopperPlacementMap[position],
      popperTrigger: "click"
    });
  }
  onAdd() {
    const button = super.onAdd();
    this.initPopper();
    return button;
  }
  onRemove() {
    this.popper.destroy();
  }
  initPopper() {
    const {
      popperClassName,
      popperPlacement,
      popperTrigger
    } = this.controlOption;
    const popperContainer = this.mapsService.getMapContainer();
    this.popper = new Popper(this.button, {
      className: popperClassName,
      placement: popperPlacement,
      trigger: popperTrigger,
      container: popperContainer,
      unique: true
    });
    this.popper.on("show", () => {
      this.emit("popperShow", this);
    }).on("hide", () => {
      this.emit("popperHide", this);
    });
    return this.popper;
  }
  setOptions(option) {
    super.setOptions(option);
    if (this.checkUpdateOption(option, ["popperPlacement", "popperTrigger", "popperClassName"])) {
      const content = this.popper.getContent();
      this.popper.destroy();
      this.initPopper();
      this.popper.setContent(content);
    }
  }
};

// node_modules/@antv/l7-component/es/control/baseControl/selectControl.js
var SelectControlConstant = function(SelectControlConstant2) {
  SelectControlConstant2["ActiveOptionClassName"] = "l7-select-control-item-active";
  SelectControlConstant2["OptionValueAttrKey"] = "data-option-value";
  SelectControlConstant2["OptionIndexAttrKey"] = "data-option-index";
  return SelectControlConstant2;
}(SelectControlConstant || {});
var SelectControl = class extends PopperControl {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "selectValue", []);
    _defineProperty(this, "optionDOMList", void 0);
    _defineProperty(this, "createNormalOption", (option) => {
      const isSelect = this.selectValue.includes(option.value);
      const optionDOM = dom_exports.create("div", `l7-select-control-item ${isSelect ? SelectControlConstant.ActiveOptionClassName : ""}`);
      if (this.getIsMultiple()) {
        optionDOM.appendChild(this.createCheckbox(isSelect));
      } else {
        optionDOM.appendChild(this.createRadio(isSelect));
      }
      if (option.icon) {
        optionDOM.appendChild(option.icon);
      }
      const textDOM = dom_exports.create("span");
      textDOM.innerText = option.text;
      optionDOM.appendChild(textDOM);
      return optionDOM;
    });
    _defineProperty(this, "onItemClick", (item) => {
      if (this.getIsMultiple()) {
        const targetIndex = this.selectValue.findIndex((value) => value === item.value);
        if (targetIndex > -1) {
          this.selectValue.splice(targetIndex, 1);
        } else {
          this.selectValue = [...this.selectValue, item.value];
        }
      } else {
        this.selectValue = [item.value];
      }
      this.setSelectValue(this.selectValue);
    });
  }
  setOptions(option) {
    super.setOptions(option);
    const {
      options
    } = option;
    if (options) {
      this.popper.setContent(this.getPopperContent(options));
    }
  }
  onAdd() {
    const button = super.onAdd();
    const {
      defaultValue: defaultValue2
    } = this.controlOption;
    if (defaultValue2) {
      this.selectValue = this.transSelectValue(defaultValue2);
    }
    this.popper.setContent(this.getPopperContent(this.controlOption.options));
    return button;
  }
  getSelectValue() {
    return this.getIsMultiple() ? this.selectValue : this.selectValue[0];
  }
  setSelectValue(value, emitEvent = true) {
    const finalValue = this.transSelectValue(value);
    this.optionDOMList.forEach((optionDOM) => {
      const optionValue = optionDOM.getAttribute(SelectControlConstant.OptionValueAttrKey);
      const checkboxDOM = optionDOM.querySelector("input[type=checkbox]");
      const radioDOM = optionDOM.querySelector("input[type=radio]");
      const isActive = finalValue.includes(optionValue);
      const setDOMState = (dom, active) => {
        dom_exports.toggleClass(optionDOM, SelectControlConstant.ActiveOptionClassName, active);
        if (dom) {
          dom_exports.setChecked(dom, active);
        }
      };
      setDOMState(checkboxDOM, isActive);
      setDOMState(radioDOM, isActive);
    });
    this.selectValue = finalValue;
    if (emitEvent) {
      this.emit("selectChange", this.getIsMultiple() ? finalValue : finalValue[0]);
    }
  }
  /**
   * 是否为多选
   * @protected
   */
  getIsMultiple() {
    return false;
  }
  /**
   * 渲染弹窗内容
   * @param options
   * @returns
   */
  getPopperContent(options) {
    const isImageOptions = this.isImageOptions();
    const content = dom_exports.create("div", isImageOptions ? "l7-select-control--image" : "l7-select-control--normal");
    if (this.getIsMultiple()) {
      dom_exports.addClass(content, "l7-select-control--multiple");
    }
    const optionsDOMList = options.map((option, optionIndex) => {
      const optionDOM = isImageOptions ? (
        // @ts-ignore
        this.createImageOption(option)
      ) : this.createNormalOption(option);
      optionDOM.setAttribute(SelectControlConstant.OptionValueAttrKey, option.value);
      optionDOM.setAttribute(SelectControlConstant.OptionIndexAttrKey, window.String(optionIndex));
      optionDOM.addEventListener("click", this.onItemClick.bind(this, option));
      return optionDOM;
    });
    content.append(...optionsDOMList);
    this.optionDOMList = optionsDOMList;
    return content;
  }
  createImageOption(option) {
    const isSelect = this.selectValue.includes(option.value);
    const optionDOM = dom_exports.create("div", `l7-select-control-item ${isSelect ? SelectControlConstant.ActiveOptionClassName : ""}`);
    const imgDOM = dom_exports.create("img");
    imgDOM.setAttribute("src", option.img);
    dom_exports.setUnDraggable(imgDOM);
    optionDOM.appendChild(imgDOM);
    const rowDOM = dom_exports.create("div", "l7-select-control-item-row");
    if (this.getIsMultiple()) {
      optionDOM.appendChild(this.createCheckbox(isSelect));
    }
    const textDOM = dom_exports.create("span");
    textDOM.innerText = option.text;
    rowDOM.appendChild(textDOM);
    optionDOM.appendChild(rowDOM);
    return optionDOM;
  }
  createCheckbox(isSelect) {
    const checkboxDOM = dom_exports.create("input");
    checkboxDOM.setAttribute("type", "checkbox");
    if (isSelect) {
      dom_exports.setChecked(checkboxDOM, true);
    }
    return checkboxDOM;
  }
  createRadio(isSelect) {
    const radioDOM = dom_exports.create("input");
    radioDOM.setAttribute("type", "radio");
    if (isSelect) {
      dom_exports.setChecked(radioDOM, true);
    }
    return radioDOM;
  }
  isImageOptions() {
    return !!this.controlOption.options.find((item) => item.img);
  }
  transSelectValue(value) {
    return Array.isArray(value) ? value : [value];
  }
};

// node_modules/@antv/l7-component/es/utils/icon.js
var createL7Icon = (className) => {
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.classList.add("l7-iconfont");
  svg.setAttribute("aria-hidden", "true");
  const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
  use.setAttributeNS("http://www.w3.org/1999/xlink", "href", `#${className}`);
  svg.appendChild(use);
  return svg;
};

// node_modules/@antv/l7-component/es/control/exportImage.js
var ExportImage = class extends ButtonControl {
  constructor(...args) {
    var _this;
    super(...args);
    _this = this;
    _defineProperty(this, "onClick", _asyncToGenerator(function* () {
      const {
        onExport
      } = _this.controlOption;
      onExport === null || onExport === void 0 || onExport(yield _this.getImage());
    }));
    _defineProperty(this, "mergeImage", _asyncToGenerator(function* (...base64List) {
      var _this$mapsService$get, _this$mapsService$get2;
      const {
        imageType
      } = _this.controlOption;
      const {
        width = 0,
        height = 0
      } = (_this$mapsService$get = (_this$mapsService$get2 = _this.mapsService.getContainer()) === null || _this$mapsService$get2 === void 0 ? void 0 : _this$mapsService$get2.getBoundingClientRect()) !== null && _this$mapsService$get !== void 0 ? _this$mapsService$get : {};
      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const context = canvas.getContext("2d");
      const imgList = yield Promise.all(base64List.map((base64) => {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            resolve(img);
          };
          img.src = base64;
        });
      }));
      imgList.forEach((img) => {
        context === null || context === void 0 || context.drawImage(img, 0, 0, width, height);
      });
      return canvas.toDataURL(`image/${imageType}`);
    }));
  }
  onAdd() {
    const button = super.onAdd();
    button.addEventListener("click", this.onClick);
    return button;
  }
  getDefault(option) {
    return _objectSpread2(_objectSpread2({}, super.getDefault(option)), {}, {
      title: "导出图片",
      btnIcon: createL7Icon("l7-icon-export-picture"),
      imageType: "png"
    });
  }
  getImage() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const mapImage = yield _this2.mapsService.exportMap("png");
      const layerImage = yield _this2.scene.exportPng("png");
      return _this2.mergeImage(
        ...[mapImage, layerImage].filter((base64) => base64)
      );
    })();
  }
};

// node_modules/@antv/l7-component/es/utils/screenfull.js
var methodMap = [
  ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
  // New WebKit
  ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"],
  // Old WebKit
  ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"],
  ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"],
  ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
];
var nativeAPI = (() => {
  if (typeof document === "undefined") {
    return false;
  }
  const unprefixedMethods = methodMap[0];
  const returnValue = {};
  for (const methodList of methodMap) {
    const exitFullscreenMethod = methodList === null || methodList === void 0 ? void 0 : methodList[1];
    if (exitFullscreenMethod in document) {
      for (const [index3, method] of methodList.entries()) {
        returnValue[unprefixedMethods[index3]] = method;
      }
      return returnValue;
    }
  }
  return false;
})();
var eventNameMap = {
  change: nativeAPI.fullscreenchange,
  error: nativeAPI.fullscreenerror
};
var screenfull = {
  // eslint-disable-next-line default-param-last
  request(element = document.documentElement, options) {
    return new Promise((resolve, reject) => {
      const onFullScreenEntered = () => {
        screenfull.off("change", onFullScreenEntered);
        resolve();
      };
      screenfull.on("change", onFullScreenEntered);
      const returnPromise = element[nativeAPI.requestFullscreen](options);
      if (returnPromise instanceof Promise) {
        returnPromise.then(onFullScreenEntered).catch(reject);
      }
    });
  },
  exit() {
    return new Promise((resolve, reject) => {
      if (!screenfull.isFullscreen) {
        resolve();
        return;
      }
      const onFullScreenExit = () => {
        screenfull.off("change", onFullScreenExit);
        resolve();
      };
      screenfull.on("change", onFullScreenExit);
      const returnPromise = document[nativeAPI.exitFullscreen]();
      if (returnPromise instanceof Promise) {
        returnPromise.then(onFullScreenExit).catch(reject);
      }
    });
  },
  toggle(element, options) {
    return screenfull.isFullscreen ? screenfull.exit() : screenfull.request(element, options);
  },
  onchange(callback) {
    screenfull.on("change", callback);
  },
  onerror(callback) {
    screenfull.on("error", callback);
  },
  on(event, callback) {
    const eventName = eventNameMap[event];
    if (eventName) {
      document.addEventListener(eventName, callback, false);
    }
  },
  off(event, callback) {
    const eventName = eventNameMap[event];
    if (eventName) {
      document.removeEventListener(eventName, callback, false);
    }
  },
  raw: nativeAPI
};
Object.defineProperties(screenfull, {
  isFullscreen: {
    get: () => Boolean(document[nativeAPI.fullscreenElement])
  },
  element: {
    enumerable: true,
    get: () => {
      var _document$nativeAPI$f;
      return (_document$nativeAPI$f = document[nativeAPI.fullscreenElement]) !== null && _document$nativeAPI$f !== void 0 ? _document$nativeAPI$f : void 0;
    }
  },
  isEnabled: {
    enumerable: true,
    // Coerce to boolean in case of old WebKit.
    get: () => Boolean(document[nativeAPI.fullscreenEnabled])
  }
});
if (!nativeAPI) {
  screenfull = {
    isEnabled: false
  };
}
var screenfull_default = screenfull;

// node_modules/@antv/l7-component/es/control/fullscreen.js
var Fullscreen = class extends ButtonControl {
  constructor(option) {
    var _this;
    super(option);
    _this = this;
    _defineProperty(this, "isFullscreen", false);
    _defineProperty(this, "mapContainer", void 0);
    _defineProperty(this, "toggleFullscreen", _asyncToGenerator(function* () {
      if (screenfull_default.isEnabled) {
        yield screenfull_default.toggle(_this.mapContainer);
      }
    }));
    _defineProperty(this, "onClick", () => {
      this.toggleFullscreen();
    });
    _defineProperty(this, "onFullscreenChange", () => {
      this.isFullscreen = !!document.fullscreenElement;
      const {
        btnText,
        btnIcon,
        title,
        exitBtnText,
        exitBtnIcon,
        exitTitle
      } = this.controlOption;
      if (this.isFullscreen) {
        this.setBtnTitle(exitTitle);
        this.setBtnText(exitBtnText);
        this.setBtnIcon(exitBtnIcon);
      } else {
        this.setBtnTitle(title);
        this.setBtnText(btnText);
        this.setBtnIcon(btnIcon);
      }
      this.emit("fullscreenChange", this.isFullscreen);
    });
    if (!screenfull_default.isEnabled) {
      console.warn("当前浏览器环境不支持对地图全屏化");
    }
  }
  setOptions(newOptions) {
    const {
      exitBtnText,
      exitBtnIcon,
      exitTitle
    } = newOptions;
    if (this.isFullscreen) {
      if (this.checkUpdateOption(newOptions, ["exitBtnIcon"])) {
        this.setBtnIcon(exitBtnIcon);
      }
      if (this.checkUpdateOption(newOptions, ["exitBtnText"])) {
        this.setBtnText(exitBtnText);
      }
      if (this.checkUpdateOption(newOptions, ["exitTitle"])) {
        this.setBtnTitle(exitTitle);
      }
    }
    super.setOptions(newOptions);
  }
  onAdd() {
    const button = super.onAdd();
    button.addEventListener("click", this.onClick);
    this.mapContainer = dom_exports.getContainer(this.scene.getSceneConfig().id);
    this.mapContainer.addEventListener("fullscreenchange", this.onFullscreenChange);
    return button;
  }
  onRemove() {
    super.onRemove();
    this.mapContainer.removeEventListener("fullscreenchange", this.onFullscreenChange);
  }
  getDefault(option) {
    return _objectSpread2(_objectSpread2({}, super.getDefault(option)), {}, {
      title: "全屏",
      btnIcon: createL7Icon("l7-icon-fullscreen"),
      exitTitle: "退出全屏",
      exitBtnIcon: createL7Icon("l7-icon-exit-fullscreen")
    });
  }
};

// node_modules/@antv/l7-component/es/control/geoLocate.js
var GeoLocate = class extends ButtonControl {
  constructor(option) {
    var _this;
    super(option);
    _this = this;
    _defineProperty(this, "getGeoLocation", () => {
      return new Promise((resolve, reject) => {
        window.navigator.geolocation.getCurrentPosition(({
          coords
        }) => {
          const {
            longitude: longitude2,
            latitude: latitude2
          } = coords !== null && coords !== void 0 ? coords : {};
          if (!isNaN(longitude2) && !isNaN(latitude2)) {
            resolve([longitude2, latitude2]);
          } else {
            reject();
          }
        }, (e) => {
          reject(e);
        });
      });
    });
    _defineProperty(this, "onClick", _asyncToGenerator(function* () {
      if (!window.navigator.geolocation) {
        return;
      }
      const {
        transform: transform2
      } = _this.controlOption;
      const position = yield _this.getGeoLocation();
      const currentZoom = _this.mapsService.getZoom();
      _this.mapsService.setZoomAndCenter(currentZoom > 15 ? currentZoom : 15, transform2 ? yield transform2(position) : position);
    }));
    if (!window.navigator.geolocation) {
      console.warn("当前浏览器环境不支持获取地理定位");
    }
  }
  getDefault(option) {
    return _objectSpread2(_objectSpread2({}, super.getDefault(option)), {}, {
      title: "定位",
      btnIcon: createL7Icon("l7-icon-reposition")
    });
  }
  onAdd() {
    const button = super.onAdd();
    button.addEventListener("click", this.onClick);
    return button;
  }
};

// node_modules/@antv/l7-component/es/control/layerSwitch.js
function isLayerSwitchItem(obj) {
  return Object.keys(obj !== null && obj !== void 0 ? obj : {}).every((key) => ["layer", "name", "img"].includes(key));
}
var LayerSwitch = class extends SelectControl {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "onLayerChange", () => {
      var _this$controlOption$l;
      if ((_this$controlOption$l = this.controlOption.layers) !== null && _this$controlOption$l !== void 0 && _this$controlOption$l.length) {
        return;
      }
      this.selectValue = this.getLayerVisible();
      this.setOptions({
        options: this.getLayerOptions()
      });
    });
    _defineProperty(this, "onLayerVisibleChane", () => {
      this.setSelectValue(this.getLayerVisible());
    });
    _defineProperty(this, "onSelectChange", () => {
      this.layers.forEach((layer) => {
        const needShow = this.selectValue.includes(layer.name);
        const isShow = layer.isVisible();
        if (needShow && !isShow) {
          layer.show();
        }
        if (!needShow && isShow) {
          layer.hide();
        }
      });
    });
  }
  get layers() {
    const layerService = this.layerService;
    const {
      layers
    } = this.controlOption;
    if (Array.isArray(layers) && layers.length) {
      const layerInstances = [];
      layers.forEach((layer) => {
        if (layer instanceof Object) {
          if (isLayerSwitchItem(layer)) {
            layerInstances.push(layer.layer);
          } else {
            layerInstances.push(layer);
          }
        }
        if (typeof layer === "string") {
          const targetLayer = layerService.getLayer(layer) || layerService.getLayerByName(layer);
          if (targetLayer) {
            layerInstances.push(targetLayer);
          }
        }
      });
      return layerInstances;
    }
    return layerService.getLayers() || [];
  }
  getDefault(option) {
    var _option$multiple;
    return _objectSpread2(_objectSpread2({}, super.getDefault(option)), {}, {
      title: "图层控制",
      btnIcon: createL7Icon("l7-icon-layer"),
      options: [],
      multiple: (_option$multiple = option === null || option === void 0 ? void 0 : option.multiple) !== null && _option$multiple !== void 0 ? _option$multiple : true
    });
  }
  getLayerVisible() {
    return this.layers.filter((layer) => layer.isVisible()).map((layer) => layer.name);
  }
  getLayerOptions() {
    const {
      layers
    } = this.controlOption;
    const isAllImg = layers === null || layers === void 0 ? void 0 : layers.every((item) => item.img);
    if (layers) {
      return layers === null || layers === void 0 ? void 0 : layers.map((layer) => {
        if (isLayerSwitchItem(layer)) {
          return {
            text: layer.name || layer.layer.name,
            value: layer.layer.name,
            img: isAllImg ? layer.img : void 0
          };
        } else if (typeof layer === "string") {
          const targetLayer = this.layerService.getLayer(layer) || this.layerService.getLayerByName(layer);
          return {
            text: targetLayer === null || targetLayer === void 0 ? void 0 : targetLayer.name,
            value: targetLayer === null || targetLayer === void 0 ? void 0 : targetLayer.name
          };
        }
        return {
          text: layer.name,
          value: layer.name
        };
      });
    }
    return this.layers.map((layer) => {
      return {
        text: layer.name,
        value: layer.name
      };
    });
  }
  setOptions(option) {
    const isLayerChange = this.checkUpdateOption(option, ["layers", "multiple"]);
    super.setOptions(option);
    if (isLayerChange) {
      if (this.controlOption.multiple === false) {
        this.handleSingleSelection();
      }
      this.selectValue = this.getLayerVisible();
      this.controlOption.options = this.getLayerOptions();
      this.popper.setContent(this.getPopperContent(this.controlOption.options));
    }
  }
  // TODO: 单选模式下，目前默认展示第一项，通过用户提供defaultValue展示默认选项的属性待开发
  // 如果是单选模式，则只显示第一个图层
  handleSingleSelection() {
    this.layers.forEach((layer, index3) => {
      index3 === 0 ? layer.show() : layer.hide();
    });
  }
  onAdd() {
    var _this$controlOption$o;
    if (this.controlOption.multiple === false) {
      this.handleSingleSelection();
    }
    if (!((_this$controlOption$o = this.controlOption.options) !== null && _this$controlOption$o !== void 0 && _this$controlOption$o.length)) {
      this.controlOption.options = this.getLayerOptions();
    }
    if (!this.controlOption.defaultValue) {
      this.controlOption.defaultValue = this.getLayerVisible();
    }
    this.on("selectChange", this.onSelectChange);
    this.layerService.on("layerChange", this.onLayerChange);
    return super.onAdd();
  }
  onRemove() {
    this.off("selectChange", this.onSelectChange);
    this.layerService.off("layerChange", this.onLayerChange);
  }
  getIsMultiple() {
    return this.controlOption.multiple;
  }
};

// node_modules/@antv/l7-component/es/control/logo.js
var Logo = class extends Control {
  getDefault() {
    return {
      position: PositionType.BOTTOMLEFT,
      name: "logo",
      href: "https://l7.antv.antgroup.com/",
      img: "https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*GRb1TKp4HcMAAAAAAAAAAAAAARQnAQ"
    };
  }
  onAdd() {
    const container = dom_exports.create("div", "l7-control-logo");
    this.setLogoContent(container);
    return container;
  }
  onRemove() {
    return null;
  }
  setOptions(option) {
    super.setOptions(option);
    if (this.checkUpdateOption(option, ["img", "href"])) {
      dom_exports.clearChildren(this.container);
      this.setLogoContent(this.container);
    }
  }
  setLogoContent(container) {
    const {
      href,
      img
    } = this.controlOption;
    const imgDOM = dom_exports.create("img");
    imgDOM.setAttribute("src", img);
    imgDOM.setAttribute("aria-label", "AntV logo");
    dom_exports.setUnDraggable(imgDOM);
    if (href) {
      const anchorDOM = dom_exports.create("a", "l7-control-logo-link");
      anchorDOM.target = "_blank";
      anchorDOM.href = href;
      anchorDOM.rel = "noopener nofollow";
      anchorDOM.setAttribute("rel", "noopener nofollow");
      anchorDOM.appendChild(imgDOM);
      container.appendChild(anchorDOM);
    } else {
      container.appendChild(imgDOM);
    }
  }
};

// node_modules/@antv/l7-component/es/constants/index.js
var GaodeMapStyleConfig = {
  normal: {
    text: "标准",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*qdFDSbvIalgAAAAAAAAAAAAADmJ7AQ/original"
  },
  light: {
    text: "月光银",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*d-vcRLzu8WIAAAAAAAAAAAAADmJ7AQ/original"
  },
  dark: {
    text: "幻影黑",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*HMbRTI3XnpIAAAAAAAAAAAAADmJ7AQ/original"
  },
  fresh: {
    text: "草色青",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*kqaGQ5kjSiAAAAAAAAAAAAAADmJ7AQ/original"
  },
  grey: {
    text: "雅士灰",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*XegrTpZIbqAAAAAAAAAAAAAADmJ7AQ/original"
  },
  graffiti: {
    text: "涂鸦",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*G5g9SZ_Jg4cAAAAAAAAAAAAADmJ7AQ/original"
  },
  macaron: {
    text: "马卡龙",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*irVvQbDpQMwAAAAAAAAAAAAADmJ7AQ/original"
  },
  darkblue: {
    text: "极夜蓝",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*lKRzQYB4iR0AAAAAAAAAAAAADmJ7AQ/original"
  },
  wine: {
    text: "酱籽",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*orY0T7QL-lwAAAAAAAAAAAAADmJ7AQ/original"
  }
};
var MapboxMapStyleConfig = {
  normal: {
    text: "标准",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*kIyZTok4Uk0AAAAAAAAAAAAADmJ7AQ/original"
  },
  light: {
    text: "亮",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*Z3JRQKDI-cIAAAAAAAAAAAAADmJ7AQ/original"
  },
  dark: {
    text: "暗",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*d7HCQbfmyaoAAAAAAAAAAAAADmJ7AQ/original"
  },
  satellite: {
    text: "卫星",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*TytUT6pS9okAAAAAAAAAAAAADmJ7AQ/original"
  },
  outdoors: {
    text: "户外",
    img: "https://mdn.alipayobjects.com/huamei_qa8qxu/afts/img/A*hWwFSYJEFWsAAAAAAAAAAAAADmJ7AQ/original"
  }
};

// node_modules/@antv/l7-component/es/control/mapTheme.js
var MapTheme = class extends SelectControl {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "onMapThemeChange", () => {
      this.mapsService.setMapStyle(this.selectValue[0]);
    });
  }
  getDefault(option) {
    return _objectSpread2(_objectSpread2({}, super.getDefault(option)), {}, {
      title: "地图样式",
      btnIcon: createL7Icon("l7-icon-color"),
      options: []
    });
  }
  getStyleOptions() {
    const mapStyleConfig = this.mapsService.getType() === "mapbox" ? MapboxMapStyleConfig : GaodeMapStyleConfig;
    return Object.entries(this.mapsService.getMapStyleConfig()).filter(([key, value]) => typeof value === "string" && key !== "blank").map(([key, value]) => {
      var _mapStyleConfig$key;
      const {
        text,
        img
      } = (_mapStyleConfig$key = mapStyleConfig[key]) !== null && _mapStyleConfig$key !== void 0 ? _mapStyleConfig$key : {};
      return {
        text: text !== null && text !== void 0 ? text : key,
        value,
        img,
        key
      };
    });
  }
  getMapStyle() {
    return this.mapsService.getMapStyle();
  }
  onAdd() {
    var _this$controlOption$o;
    if (!((_this$controlOption$o = this.controlOption.options) !== null && _this$controlOption$o !== void 0 && _this$controlOption$o.length)) {
      this.controlOption.options = this.getStyleOptions();
    }
    if (this.controlOption.defaultValue) {
      var _this$controlOption$o2, _this$controlOption$o3;
      const defaultValue2 = this.controlOption.defaultValue;
      this.controlOption.defaultValue = (_this$controlOption$o2 = (_this$controlOption$o3 = this.controlOption.options.find((item) => item.key === defaultValue2)) === null || _this$controlOption$o3 === void 0 ? void 0 : _this$controlOption$o3.value) !== null && _this$controlOption$o2 !== void 0 ? _this$controlOption$o2 : defaultValue2;
    } else {
      const defaultStyle = this.getMapStyle();
      if (defaultStyle) {
        this.controlOption.defaultValue = defaultStyle;
      } else {
        this.mapsService.map.once("styledata", () => {
          const mapboxStyle = this.mapsService.getMapStyle();
          this.controlOption.defaultValue = mapboxStyle;
          this.setSelectValue(mapboxStyle, false);
        });
      }
    }
    this.on("selectChange", this.onMapThemeChange);
    return super.onAdd();
  }
  getIsMultiple() {
    return false;
  }
};

// node_modules/@antv/l7-component/es/control/mouseLocation.js
var MouseLocation = class extends Control {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "location", [0, 0]);
    _defineProperty(this, "onMouseMove", (e) => {
      let position = this.location;
      const lngLat = e.lngLat || e.lnglat;
      const {
        transform: transform2
      } = this.controlOption;
      if (lngLat) {
        position = [lngLat.lng, lngLat.lat];
      }
      this.location = position;
      if (transform2) {
        position = transform2(position);
      }
      this.insertLocation2HTML(position);
      this.emit("locationChange", position);
    });
  }
  getLocation() {
    return this.location;
  }
  getDefault(option) {
    return _objectSpread2(_objectSpread2({}, super.getDefault(option)), {}, {
      position: PositionType.BOTTOMLEFT,
      transform: ([lng, lat]) => {
        return [+(+lng).toFixed(6), +(+lat).toFixed(6)];
      }
    });
  }
  onAdd() {
    const container = dom_exports.create("div", "l7-control-mouse-location");
    container.innerHTML = "&nbsp;";
    this.mapsService.on("mousemove", this.onMouseMove);
    return container;
  }
  onRemove() {
    this.mapsService.off("mousemove", this.onMouseMove);
  }
  insertLocation2HTML(position) {
    this.container.innerText = position.join(", ");
  }
};

// node_modules/@antv/l7-component/es/control/scale.js
var Scale = class extends Control {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "mScale", void 0);
    _defineProperty(this, "iScale", void 0);
    _defineProperty(this, "update", () => {
      const mapsService = this.mapsService;
      const {
        maxWidth
      } = this.controlOption;
      const y = mapsService.getSize()[1] / 2;
      const p1 = mapsService.containerToLngLat([0, y]);
      const p2 = mapsService.containerToLngLat([maxWidth, y]);
      const maxMeters = lnglatDistance([p1.lng, p1.lat], [p2.lng, p2.lat]);
      this.updateScales(maxMeters);
    });
  }
  getDefault(option) {
    return _objectSpread2(_objectSpread2({}, super.getDefault(option)), {}, {
      name: "scale",
      position: PositionType.BOTTOMLEFT,
      maxWidth: 100,
      metric: true,
      updateWhenIdle: false,
      imperial: false,
      lockWidth: true
    });
  }
  onAdd() {
    const className = "l7-control-scale";
    const container = dom_exports.create("div", className);
    this.resetScaleLines(container);
    const {
      updateWhenIdle
    } = this.controlOption;
    this.mapsService.on(updateWhenIdle ? "moveend" : "mapmove", this.update);
    this.mapsService.on(updateWhenIdle ? "zoomend" : "zoomchange", this.update);
    return container;
  }
  onRemove() {
    const {
      updateWhenIdle
    } = this.controlOption;
    this.mapsService.off(updateWhenIdle ? "zoomend" : "zoomchange", this.update);
    this.mapsService.off(updateWhenIdle ? "moveend" : "mapmove", this.update);
  }
  setOptions(newOption) {
    super.setOptions(newOption);
    if (this.checkUpdateOption(newOption, ["lockWidth", "maxWidth", "metric", "updateWhenIdle", "imperial"])) {
      this.resetScaleLines(this.container);
    }
  }
  updateScales(maxMeters) {
    const {
      metric,
      imperial
    } = this.controlOption;
    if (metric && maxMeters) {
      this.updateMetric(maxMeters);
    }
    if (imperial && maxMeters) {
      this.updateImperial(maxMeters);
    }
  }
  resetScaleLines(container) {
    dom_exports.clearChildren(container);
    const {
      metric,
      imperial,
      maxWidth,
      lockWidth
    } = this.controlOption;
    if (lockWidth) {
      dom_exports.addStyle(container, `width: ${maxWidth}px`);
    }
    if (metric) {
      this.mScale = dom_exports.create("div", "l7-control-scale-line", container);
    }
    if (imperial) {
      this.iScale = dom_exports.create("div", "l7-control-scale-line", container);
    }
    this.update();
  }
  updateScale(scale2, text, ratio) {
    const {
      maxWidth
    } = this.controlOption;
    scale2.style.width = Math.round(maxWidth * ratio) + "px";
    scale2.innerHTML = text;
  }
  getRoundNum(num) {
    const pow102 = Math.pow(10, (Math.floor(num) + "").length - 1);
    let d = num / pow102;
    d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
    return pow102 * d;
  }
  updateMetric(maxMeters) {
    const meters = this.getRoundNum(maxMeters);
    const label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
    this.updateScale(this.mScale, label, meters / maxMeters);
  }
  updateImperial(maxMeters) {
    const maxFeet = maxMeters * 3.2808399;
    let maxMiles;
    let miles;
    let feet;
    if (maxFeet > 5280) {
      maxMiles = maxFeet / 5280;
      miles = this.getRoundNum(maxMiles);
      this.updateScale(this.iScale, miles + " mi", miles / maxMiles);
    } else {
      feet = this.getRoundNum(maxFeet);
      this.updateScale(this.iScale, feet + " ft", feet / maxFeet);
    }
  }
};

// node_modules/@antv/l7-layers/es/core/BaseLayer.js
var import_eventemitter36 = __toESM(require_eventemitter3());

// node_modules/@antv/l7-layers/es/plugins/DataMappingPlugin.js
var DataMappingPlugin = class {
  constructor() {
    _defineProperty(this, "mapService", void 0);
    _defineProperty(this, "fontService", void 0);
  }
  apply(layer, {
    styleAttributeService,
    mapService,
    fontService
  }) {
    var _this = this;
    this.mapService = mapService;
    this.fontService = fontService;
    layer.hooks.init.tapPromise("DataMappingPlugin", _asyncToGenerator(function* () {
      layer.log(IDebugLog.MappingStart, ILayerStage.INIT);
      _this.generateMaping(layer, {
        styleAttributeService
      });
      layer.log(IDebugLog.MappingEnd, ILayerStage.INIT);
    }));
    layer.hooks.beforeRenderData.tapPromise("DataMappingPlugin", function() {
      var _ref2 = _asyncToGenerator(function* (flag) {
        if (!flag) {
          return flag;
        }
        layer.dataState.dataMappingNeedUpdate = false;
        layer.log(IDebugLog.MappingStart, ILayerStage.UPDATE);
        const mappingResult = _this.generateMaping(layer, {
          styleAttributeService
        });
        layer.log(IDebugLog.MappingEnd, ILayerStage.UPDATE);
        return mappingResult;
      });
      return function(_x) {
        return _ref2.apply(this, arguments);
      };
    }());
    layer.hooks.beforeRender.tap("DataMappingPlugin", () => {
      const source = layer.getSource();
      if (layer.layerModelNeedUpdate || !source || !source.inited) {
        return;
      }
      const attributes = styleAttributeService.getLayerStyleAttributes() || [];
      const filter3 = styleAttributeService.getLayerStyleAttribute("filter");
      const {
        dataArray
      } = source.data;
      if (Array.isArray(dataArray) && dataArray.length === 0) {
        return;
      }
      const attributesToRemapping = attributes.filter(
        (attribute) => attribute.needRemapping
        // 如果filter变化
      );
      let filterData = dataArray;
      if (filter3 !== null && filter3 !== void 0 && filter3.needRemapping && filter3 !== null && filter3 !== void 0 && filter3.scale) {
        filterData = dataArray.filter((record) => {
          return this.applyAttributeMapping(filter3, record)[0];
        });
      }
      if (attributesToRemapping.length) {
        const encodeData = this.mapping(
          layer,
          attributesToRemapping,
          filterData,
          layer.getEncodedData()
          // TODO 优化
        );
        layer.setEncodedData(encodeData);
      }
    });
  }
  generateMaping(layer, {
    styleAttributeService
  }) {
    const attributes = styleAttributeService.getLayerStyleAttributes() || [];
    const filter3 = styleAttributeService.getLayerStyleAttribute("filter");
    const {
      dataArray
    } = layer.getSource().data;
    let filterData = dataArray;
    if (filter3 !== null && filter3 !== void 0 && filter3.scale) {
      filterData = dataArray.filter((record) => {
        return this.applyAttributeMapping(filter3, record)[0];
      });
    }
    filterData = layer.processData(filterData);
    const encodeData = this.mapping(layer, attributes, filterData, void 0);
    layer.setEncodedData(encodeData);
    layer.emit("dataUpdate", null);
    return true;
  }
  mapping(layer, attributes, data, predata) {
    const usedAttributes = attributes.filter((attribute) => attribute.scale !== void 0).filter((attribute) => attribute.name !== "filter");
    const mappedData = data.map((record, i) => {
      const preRecord = predata ? predata[i] : {};
      const encodeRecord = _objectSpread2({
        id: record._id,
        coordinates: record.coordinates
      }, preRecord);
      usedAttributes.forEach((attribute) => {
        let values = this.applyAttributeMapping(attribute, record);
        if (attribute.name === "color" || attribute.name === "stroke") {
          values = values.map((c) => {
            return rgb2arr(c);
          });
        }
        encodeRecord[attribute.name] = Array.isArray(values) && values.length === 1 ? values[0] : values;
        if (attribute.name === "shape") {
          encodeRecord.shape = this.fontService.getIconFontKey(encodeRecord[attribute.name]);
        }
      });
      return encodeRecord;
    });
    attributes.forEach((attribute) => {
      attribute.needRemapping = false;
    });
    this.adjustData2SimpleCoordinates(mappedData);
    return mappedData;
  }
  adjustData2SimpleCoordinates(mappedData) {
    if (mappedData.length > 0 && this.mapService.version === "SIMPLE") {
      mappedData.map((d) => {
        if (!d.simpleCoordinate) {
          d.coordinates = this.unProjectCoordinates(d.coordinates);
          d.simpleCoordinate = true;
        }
      });
    }
  }
  unProjectCoordinates(coordinates) {
    if (typeof coordinates[0] === "number") {
      return this.mapService.simpleMapCoord.unproject(coordinates);
    }
    if (coordinates[0] && coordinates[0][0] instanceof Array) {
      const coords = [];
      coordinates.map((coord) => {
        const c1 = [];
        coord.map((co) => {
          c1.push(this.mapService.simpleMapCoord.unproject(co));
        });
        coords.push(c1);
      });
      return coords;
    } else {
      const coords = [];
      coordinates.map((coord) => {
        coords.push(this.mapService.simpleMapCoord.unproject(coord));
      });
      return coords;
    }
  }
  applyAttributeMapping(attribute, record) {
    var _attribute$scale;
    if (!attribute.scale) {
      return [];
    }
    const scalers = (attribute === null || attribute === void 0 || (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.scalers) || [];
    const params = [];
    scalers.forEach(({
      field
    }) => {
      var _attribute$scale2;
      if (record.hasOwnProperty(field) || ((_attribute$scale2 = attribute.scale) === null || _attribute$scale2 === void 0 ? void 0 : _attribute$scale2.type) === "variable") {
        params.push(record[field]);
      }
    });
    const mappingResult = attribute.mapping ? attribute.mapping(params) : [];
    return mappingResult;
  }
  getArrowPoints(p1, p2) {
    const dir = [p2[0] - p1[0], p2[1] - p1[1]];
    const normalizeDir = normalize(dir);
    const arrowPoint = [p1[0] + normalizeDir[0] * 1e-4, p1[1] + normalizeDir[1] * 1e-4];
    return arrowPoint;
  }
};

// node_modules/@antv/l7-layers/es/plugins/DataSourcePlugin.js
var DataSourcePlugin = class {
  constructor() {
    _defineProperty(this, "mapService", void 0);
  }
  apply(layer) {
    var _this = this;
    this.mapService = layer.getContainer().mapService;
    layer.hooks.init.tapPromise("DataSourcePlugin", _asyncToGenerator(function* () {
      layer.log(IDebugLog.SourceInitStart, ILayerStage.INIT);
      let source = layer.getSource();
      if (!source) {
        const {
          data,
          options
        } = layer.sourceOption || layer.defaultSourceConfig;
        source = new src_default(data, options);
        layer.setSource(source);
      }
      if (source.inited) {
        _this.updateClusterData(layer);
        layer.log(IDebugLog.SourceInitEnd, ILayerStage.INIT);
      } else {
        yield new Promise((resolve) => {
          source.on("update", (e) => {
            if (e.type === "inited") {
              _this.updateClusterData(layer);
              layer.log(IDebugLog.SourceInitEnd, ILayerStage.INIT);
            }
            resolve(null);
          });
        });
      }
    }));
    layer.hooks.beforeRenderData.tapPromise("DataSourcePlugin", _asyncToGenerator(function* () {
      const neeUpdateCluster = _this.updateClusterData(layer);
      const dataSourceNeedUpdate = layer.dataState.dataSourceNeedUpdate;
      layer.dataState.dataSourceNeedUpdate = false;
      const needScale = neeUpdateCluster || dataSourceNeedUpdate;
      return needScale;
    }));
  }
  updateClusterData(layer) {
    if (layer.isTileLayer || layer.tileLayer || !layer.getSource()) {
      return false;
    }
    const source = layer.getSource();
    const cluster2 = source.cluster;
    const {
      zoom = 0
    } = source.clusterOptions;
    const newZoom = this.mapService.getZoom() - 1;
    const dataSourceNeedUpdate = layer.dataState.dataSourceNeedUpdate;
    if (cluster2 && dataSourceNeedUpdate) {
      source.updateClusterData(Math.floor(newZoom));
    }
    if (cluster2 && Math.abs(layer.clusterZoom - newZoom) >= 1) {
      if (zoom !== Math.floor(newZoom)) {
        source.updateClusterData(Math.floor(newZoom));
      }
      layer.clusterZoom = newZoom;
      return true;
    }
    return false;
  }
};

// node_modules/d3-array/src/ascending.js
function ascending_default(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector_default(f) {
  let delta = f;
  let compare = f;
  if (f.length === 1) {
    delta = (d, x) => f(d) - x;
    compare = ascendingComparator(f);
  }
  function left(a, x, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) < 0)
        lo = mid + 1;
      else
        hi = mid;
    }
    return lo;
  }
  function right(a, x, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) > 0)
        hi = mid;
      else
        lo = mid + 1;
    }
    return lo;
  }
  function center(a, x, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left, center, right };
}
function ascendingComparator(f) {
  return (d, x) => ascending_default(f(d), x);
}

// node_modules/d3-array/src/number.js
function number_default(x) {
  return x === null ? NaN : +x;
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector_default(number_default).center;

// node_modules/d3-array/src/extent.js
function extent_default(values, valueof) {
  let min3;
  let max4;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min3 === void 0) {
          if (value >= value)
            min3 = max4 = value;
        } else {
          if (min3 > value)
            min3 = value;
          if (max4 < value)
            max4 = value;
        }
      }
    }
  } else {
    let index3 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index3, values)) != null) {
        if (min3 === void 0) {
          if (value >= value)
            min3 = max4 = value;
        } else {
          if (min3 > value)
            min3 = value;
          if (max4 < value)
            max4 = value;
        }
      }
    }
  }
  return [min3, max4];
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map2 = array.map;

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle(array4, i0 = 0, i1 = array4.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random() * m-- | 0, t = array4[m + i0];
      array4[m + i0] = array4[i + i0];
      array4[i + i0] = t;
    }
    return array4;
  };
}

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t2 = t12 * t12, t3 = t2 * t12;
  return ((1 - 3 * t12 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t12 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
function constant_default2(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default2(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default2(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default2(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray2(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x[i] = value_default(a[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x[i](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default2(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default2(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default2(b) : (t === "number" ? number_default2 : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray2(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default2)(a, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var cssNode;
var cssRoot;
var cssView;
var svgNode;
function parseCss(value) {
  if (value === "none")
    return identity;
  if (!cssNode)
    cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose_default(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}
function parseSvg(value) {
  if (value == null)
    return identity;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default2(xa, xb) }, { i: i - 2, x: number_default2(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default2(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default2(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale2(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default2(xa, xb) }, { i: i - 2, x: number_default2(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale2(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl(start)).h, (end = hsl(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y) {
    y = +y;
    function cubehelix3(start, end) {
      var h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-scale/node_modules/d3-array/src/ascending.js
function ascending_default2(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-scale/node_modules/d3-array/src/bisector.js
function bisector_default2(compare) {
  if (compare.length === 1)
    compare = ascendingComparator2(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0)
          lo = mid + 1;
        else
          hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0)
          hi = mid;
        else
          lo = mid + 1;
      }
      return lo;
    }
  };
}
function ascendingComparator2(f) {
  return function(d, x) {
    return ascending_default2(f(d), x);
  };
}

// node_modules/d3-scale/node_modules/d3-array/src/bisect.js
var ascendingBisect2 = bisector_default2(ascending_default2);
var bisectRight2 = ascendingBisect2.right;
var bisectLeft2 = ascendingBisect2.left;
var bisect_default2 = bisectRight2;

// node_modules/d3-scale/node_modules/d3-array/src/number.js
function number_default3(x) {
  return x === null ? NaN : +x;
}

// node_modules/d3-scale/node_modules/d3-array/src/array.js
var array2 = Array.prototype;
var slice2 = array2.slice;
var map4 = array2.map;

// node_modules/d3-scale/node_modules/d3-array/src/ticks.js
var e102 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);
function ticks_default2(start, stop, count2) {
  var reverse2, i = -1, n, ticks, step;
  stop = +stop, start = +start, count2 = +count2;
  if (start === stop && count2 > 0)
    return [start];
  if (reverse2 = stop < start)
    n = start, start = stop, stop = n;
  if ((step = tickIncrement2(start, stop, count2)) === 0 || !isFinite(step))
    return [];
  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n)
      ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n)
      ticks[i] = (start - i) / step;
  }
  if (reverse2)
    ticks.reverse();
  return ticks;
}
function tickIncrement2(start, stop, count2) {
  var step = (stop - start) / Math.max(0, count2), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e102 ? 10 : error >= e52 ? 5 : error >= e22 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e102 ? 10 : error >= e52 ? 5 : error >= e22 ? 2 : 1);
}
function tickStep2(start, stop, count2) {
  var step0 = Math.abs(stop - start) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e102)
    step1 *= 10;
  else if (error >= e52)
    step1 *= 5;
  else if (error >= e22)
    step1 *= 2;
  return stop < start ? -step1 : step1;
}

// node_modules/d3-scale/node_modules/d3-array/src/quantile.js
function quantile_default(values, p, valueof) {
  if (valueof == null)
    valueof = number_default3;
  if (!(n = values.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return +valueof(values[0], 0, values);
  if (p >= 1)
    return +valueof(values[n - 1], n - 1, values);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.interpolator(domain);
      break;
    default:
      this.interpolator(interpolator).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-collection/src/map.js
var prefix = "$";
function Map2() {
}
Map2.prototype = map5.prototype = {
  constructor: Map2,
  has: function(key) {
    return prefix + key in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this)
      if (property[0] === prefix)
        delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this)
      if (property[0] === prefix)
        keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this)
      if (property[0] === prefix)
        values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this)
      if (property[0] === prefix)
        entries.push({ key: property.slice(1), value: this[property] });
    return entries;
  },
  size: function() {
    var size2 = 0;
    for (var property in this)
      if (property[0] === prefix)
        ++size2;
    return size2;
  },
  empty: function() {
    for (var property in this)
      if (property[0] === prefix)
        return false;
    return true;
  },
  each: function(f) {
    for (var property in this)
      if (property[0] === prefix)
        f(this[property], property.slice(1), this);
  }
};
function map5(object, f) {
  var map8 = new Map2();
  if (object instanceof Map2)
    object.each(function(value, key2) {
      map8.set(key2, value);
    });
  else if (Array.isArray(object)) {
    var i = -1, n = object.length, o;
    if (f == null)
      while (++i < n)
        map8.set(i, object[i]);
    else
      while (++i < n)
        map8.set(f(o = object[i], i, object), o);
  } else if (object)
    for (var key in object)
      map8.set(key, object[key]);
  return map8;
}
var map_default = map5;

// node_modules/d3-collection/src/set.js
function Set2() {
}
var proto = map_default.prototype;
Set2.prototype = set2.prototype = {
  constructor: Set2,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};
function set2(object, f) {
  var set3 = new Set2();
  if (object instanceof Set2)
    object.each(function(value) {
      set3.add(value);
    });
  else if (object) {
    var i = -1, n = object.length;
    if (f == null)
      while (++i < n)
        set3.add(object[i]);
    else
      while (++i < n)
        set3.add(f(object[i], i, object));
  }
  return set3;
}

// node_modules/d3-scale/src/array.js
var array3 = Array.prototype;
var map6 = array3.map;
var slice3 = array3.slice;

// node_modules/d3-scale/src/ordinal.js
var implicit = { name: "implicit" };
function ordinal() {
  var index3 = map_default(), domain = [], range = [], unknown = implicit;
  function scale2(d) {
    var key = d + "", i = index3.get(key);
    if (!i) {
      if (unknown !== implicit)
        return unknown;
      index3.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }
  scale2.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index3 = map_default();
    var i = -1, n = _.length, d, key;
    while (++i < n)
      if (!index3.has(key = (d = _[i]) + ""))
        index3.set(key, domain.push(d));
    return scale2;
  };
  scale2.range = function(_) {
    return arguments.length ? (range = slice3.call(_), scale2) : range.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return scale2;
}

// node_modules/d3-scale/src/constant.js
function constant_default4(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-scale/src/number.js
function number_default4(x) {
  return +x;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity2(x) {
  return x;
}
function normalize2(a, b) {
  return (b -= a = +a) ? function(x) {
    return (x - a) / b;
  } : constant_default4(isNaN(b) ? NaN : 0.5);
}
function clamper(domain) {
  var a = domain[0], b = domain[domain.length - 1], t;
  if (a > b)
    t = a, a = b, b = t;
  return function(x) {
    return Math.max(a, Math.min(b, x));
  };
}
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0)
    d0 = normalize2(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize2(d0, d1), r0 = interpolate(r0, r1);
  return function(x) {
    return r0(d0(x));
  };
}
function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize2(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }
  return function(x) {
    var i2 = bisect_default2(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range = unit, interpolate = value_default, transform2, untransform, unknown, clamp2 = identity2, piecewise2, output, input;
  function rescale() {
    piecewise2 = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale2;
  }
  function scale2(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise2(domain.map(transform2), range, interpolate)))(transform2(clamp2(x)));
  }
  scale2.invert = function(y) {
    return clamp2(untransform((input || (input = piecewise2(range, domain.map(transform2), number_default2)))(y)));
  };
  scale2.domain = function(_) {
    return arguments.length ? (domain = map6.call(_, number_default4), clamp2 === identity2 || (clamp2 = clamper(domain)), rescale()) : domain.slice();
  };
  scale2.range = function(_) {
    return arguments.length ? (range = slice3.call(_), rescale()) : range.slice();
  };
  scale2.rangeRound = function(_) {
    return range = slice3.call(_), interpolate = round_default, rescale();
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? clamper(domain) : identity2, scale2) : clamp2 !== identity2;
  };
  scale2.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t, u4) {
    transform2 = t, untransform = u4;
    return rescale();
  };
}
function continuous(transform2, untransform) {
  return transformer()(transform2, untransform);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length2 = 0;
    while (i > 0 && g > 0) {
      if (length2 + g + 1 > width)
        g = Math.max(1, width - length2);
      t.push(value.substring(i -= g, i + g));
      if ((length2 += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": function(x, p) {
    return (x * 100).toFixed(p);
  },
  "b": function(x) {
    return Math.round(x).toString(2);
  },
  "c": function(x) {
    return x + "";
  },
  "d": formatDecimal_default,
  "e": function(x, p) {
    return x.toExponential(p);
  },
  "f": function(x, p) {
    return x.toFixed(p);
  },
  "g": function(x, p) {
    return x.toPrecision(p);
  },
  "o": function(x) {
    return Math.round(x).toString(8);
  },
  "p": function(x, p) {
    return formatRounded_default(x * 100, p);
  },
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": function(x) {
    return Math.round(x).toString(16).toUpperCase();
  },
  "x": function(x) {
    return Math.round(x).toString(16);
  }
};

// node_modules/d3-format/src/identity.js
function identity_default3(x) {
  return x;
}

// node_modules/d3-format/src/locale.js
var map7 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default3 : formatGroup_default(map7.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default3 : formatNumerals_default(map7.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "-" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align3 = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n")
      comma = true, type = "g";
    else if (!formatTypes_default[type])
      precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero2 || fill === "0" && align3 === "=")
      zero2 = true, fill = "0", align3 = "=";
    var prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix2, valueSuffix = suffix, i, n, c;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group2(value, Infinity);
      var length2 = valuePrefix.length + value.length + valueSuffix.length, padding = length2 < width ? new Array(width - length2 + 1).join(fill) : "";
      if (comma && zero2)
        value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align3) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length2 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length2);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix2 = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max4) {
  step = Math.abs(step), max4 = Math.abs(max4) - step;
  return Math.max(0, exponent_default(max4) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat_default(start, stop, count2, specifier) {
  var step = tickStep2(start, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale2) {
  var domain = scale2.domain;
  scale2.ticks = function(count2) {
    var d = domain();
    return ticks_default2(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale2.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat_default(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale2.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain(), i0 = 0, i1 = d.length - 1, start = d[i0], stop = d[i1], step;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    step = tickIncrement2(start, stop, count2);
    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement2(start, stop, count2);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement2(start, stop, count2);
    }
    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }
    return scale2;
  };
  return scale2;
}
function linear2() {
  var scale2 = continuous(identity2, identity2);
  scale2.copy = function() {
    return copy(scale2, linear2());
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}

// node_modules/d3-scale/src/nice.js
function nice_default(domain, interval) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }
  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

// node_modules/d3-scale/src/log.js
function transformLog(x) {
  return Math.log(x);
}
function transformExp(x) {
  return Math.exp(x);
}
function transformLogn(x) {
  return -Math.log(-x);
}
function transformExpn(x) {
  return -Math.exp(-x);
}
function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : function(x) {
    return Math.pow(base, x);
  };
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function(x) {
    return Math.log(x) / base;
  });
}
function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}
function loggish(transform2) {
  var scale2 = transform2(transformLog, transformExp), domain = scale2.domain, base = 10, logs, pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform2(transformLogn, transformExpn);
    } else {
      transform2(transformLog, transformExp);
    }
    return scale2;
  }
  scale2.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };
  scale2.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale2.ticks = function(count2) {
    var d = domain(), u4 = d[0], v2 = d[d.length - 1], r;
    if (r = v2 < u4)
      i = u4, u4 = v2, v2 = i;
    var i = logs(u4), j = logs(v2), p, k, t, n = count2 == null ? 10 : +count2, z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u4 > 0)
        for (; i < j; ++i) {
          for (k = 1, p = pows(i); k < base; ++k) {
            t = p * k;
            if (t < u4)
              continue;
            if (t > v2)
              break;
            z.push(t);
          }
        }
      else
        for (; i < j; ++i) {
          for (k = base - 1, p = pows(i); k >= 1; --k) {
            t = p * k;
            if (t < u4)
              continue;
            if (t > v2)
              break;
            z.push(t);
          }
        }
    } else {
      z = ticks_default2(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale2.tickFormat = function(count2, specifier) {
    if (specifier == null)
      specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function")
      specifier = format(specifier);
    if (count2 === Infinity)
      return specifier;
    if (count2 == null)
      count2 = 10;
    var k = Math.max(1, base * count2 / scale2.ticks().length);
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5)
        i *= base;
      return i <= k ? specifier(d) : "";
    };
  };
  scale2.nice = function() {
    return domain(nice_default(domain(), {
      floor: function(x) {
        return pows(Math.floor(logs(x)));
      },
      ceil: function(x) {
        return pows(Math.ceil(logs(x)));
      }
    }));
  };
  return scale2;
}
function log() {
  var scale2 = loggish(transformer()).domain([1, 10]);
  scale2.copy = function() {
    return copy(scale2, log()).base(scale2.base());
  };
  initRange.apply(scale2, arguments);
  return scale2;
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}
function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}
function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}
function powish(transform2) {
  var scale2 = transform2(identity2, identity2), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform2(identity2, identity2) : exponent === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent), transformPow(1 / exponent));
  }
  scale2.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return linearish(scale2);
}
function pow() {
  var scale2 = powish(transformer());
  scale2.copy = function() {
    return copy(scale2, pow()).exponent(scale2.exponent());
  };
  initRange.apply(scale2, arguments);
  return scale2;
}

// node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain = [], range = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n)
      thresholds[i - 1] = quantile_default(domain, i / n);
    return scale2;
  }
  function scale2(x) {
    return isNaN(x = +x) ? unknown : range[bisect_default2(thresholds, x)];
  }
  scale2.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };
  scale2.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i)
      if (d = _[i], d != null && !isNaN(d = +d))
        domain.push(d);
    domain.sort(ascending_default2);
    return rescale();
  };
  scale2.range = function(_) {
    return arguments.length ? (range = slice3.call(_), rescale()) : range.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.quantiles = function() {
    return thresholds.slice();
  };
  scale2.copy = function() {
    return quantile2().domain(domain).range(range).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}

// node_modules/d3-scale/src/quantize.js
function quantize() {
  var x0 = 0, x1 = 1, n = 1, domain = [0.5], range = [0, 1], unknown;
  function scale2(x) {
    return x <= x ? range[bisect_default2(domain, x, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n)
      domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale2;
  }
  scale2.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };
  scale2.range = function(_) {
    return arguments.length ? (n = (range = slice3.call(_)).length - 1, rescale()) : range.slice();
  };
  scale2.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : scale2;
  };
  scale2.thresholds = function() {
    return domain.slice();
  };
  scale2.copy = function() {
    return quantize().domain([x0, x1]).range(range).unknown(unknown);
  };
  return initRange.apply(linearish(scale2), arguments);
}

// node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain = [0.5], range = [0, 1], unknown, n = 1;
  function scale2(x) {
    return x <= x ? range[bisect_default2(domain, x, 0, n)] : unknown;
  }
  scale2.domain = function(_) {
    return arguments.length ? (domain = slice3.call(_), n = Math.min(domain.length, range.length - 1), scale2) : domain.slice();
  };
  scale2.range = function(_) {
    return arguments.length ? (range = slice3.call(_), n = Math.min(domain.length, range.length - 1), scale2) : range.slice();
  };
  scale2.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return threshold().domain(domain).range(range).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}

// node_modules/d3-time/src/interval.js
var t0 = /* @__PURE__ */ new Date();
var t1 = /* @__PURE__ */ new Date();
function newInterval(floori, offseti, count2, field) {
  function interval(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval.floor = function(date2) {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval.round = function(date2) {
    var d0 = interval(date2), d1 = interval.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval.offset = function(date2, step) {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0))
      return range;
    do
      range.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };
  interval.filter = function(test) {
    return newInterval(function(date2) {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, function(date2, step) {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count2(t0, t1));
    };
    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function(d) {
        return field(d) % step === 0;
      } : function(d) {
        return interval.count(0, d) % step === 0;
      });
    };
  }
  return interval;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = newInterval(function() {
}, function(date2, step) {
  date2.setTime(+date2 + step);
}, function(start, end) {
  return end - start;
});
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0))
    return null;
  if (!(k > 1))
    return millisecond;
  return newInterval(function(date2) {
    date2.setTime(Math.floor(date2 / k) * k);
  }, function(date2, step) {
    date2.setTime(+date2 + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
var millisecond_default = millisecond;
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

// node_modules/d3-time/src/second.js
var second = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step) {
  date2.setTime(+date2 + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date2) {
  return date2.getUTCSeconds();
});
var second_default = second;
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var minute = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date2) {
  return date2.getMinutes();
});
var minute_default = minute;
var minutes = minute.range;

// node_modules/d3-time/src/hour.js
var hour = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date2) {
  return date2.getHours();
});
var hour_default = hour;
var hours = hour.range;

// node_modules/d3-time/src/day.js
var day = newInterval(function(date2) {
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setDate(date2.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date2) {
  return date2.getDate() - 1;
});
var day_default = day;
var days = day.range;

// node_modules/d3-time/src/week.js
function weekday(i) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setDate(date2.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

// node_modules/d3-time/src/month.js
var month = newInterval(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setMonth(date2.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
var month_default = month;
var months = month.range;

// node_modules/d3-time/src/year.js
var year = newInterval(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setFullYear(date2.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setFullYear(date2.getFullYear() + step * k);
  });
};
var year_default = year;
var years = year.range;

// node_modules/d3-time/src/utcMinute.js
var utcMinute = newInterval(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date2) {
  return date2.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/utcHour.js
var utcHour = newInterval(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date2) {
  return date2.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/utcDay.js
var utcDay = newInterval(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCDate(date2.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
var utcDay_default = utcDay;
var utcDays = utcDay.range;

// node_modules/d3-time/src/utcWeek.js
function utcWeekday(i) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/utcMonth.js
var utcMonth = newInterval(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/utcYear.js
var utcYear = newInterval(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
  });
};
var utcYear_default = utcYear;
var utcYears = utcYear.range;

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y, m, d) {
  return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear2,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c, pad3, format2;
      if (!(date2 instanceof Date))
        date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad3 = pads[c = specifier.charAt(++i)]) != null)
            c = specifier.charAt(++i);
          else
            pad3 = c === "e" ? " " : "0";
          if (format2 = formats2[c])
            c = format2(date2, pad3);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day2;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay_default.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
          week = day_default.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c, parse;
    while (i < n) {
      if (j >= m)
        return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0)
          return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad2(value, fill, width) {
  var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length2 = string.length;
  return sign + (length2 < width ? new Array(width - length2 + 1).join(fill) + string : string);
}
function requote(s) {
  return s.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  var map8 = {}, i = -1, n = names.length;
  while (++i < n)
    map8[names[i].toLowerCase()] = i;
  return map8;
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad2(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad2(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad2(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad2(1 + day_default.count(year_default(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad2(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad2(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad2(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad2(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad2(sunday.count(year_default(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad2(thursday.count(year_default(d), d) + (year_default(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad2(monday.count(year_default(d) - 1, d), p, 2);
}
function formatYear2(d, p) {
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad2(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad2(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad2(z / 60 | 0, "0", 2) + pad2(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad2(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad2(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad2(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad2(1 + utcDay_default.count(utcYear_default(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad2(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad2(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad2(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad2(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad2(utcSunday.count(utcYear_default(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad2(utcThursday.count(utcYear_default(d), d) + (utcYear_default(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad2(utcMonday.count(utcYear_default(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date2) {
  return date2.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date2 = new Date(string);
  return isNaN(date2) ? null : date2;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/d3-scale/src/time.js
var durationSecond2 = 1e3;
var durationMinute2 = durationSecond2 * 60;
var durationHour2 = durationMinute2 * 60;
var durationDay2 = durationHour2 * 24;
var durationWeek2 = durationDay2 * 7;
var durationMonth = durationDay2 * 30;
var durationYear = durationDay2 * 365;
function date(t) {
  return new Date(t);
}
function number(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(year2, month2, week, day2, hour2, minute2, second2, millisecond2, format2) {
  var scale2 = continuous(identity2, identity2), invert = scale2.invert, domain = scale2.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear3 = format2("%Y");
  var tickIntervals = [
    [second2, 1, durationSecond2],
    [second2, 5, 5 * durationSecond2],
    [second2, 15, 15 * durationSecond2],
    [second2, 30, 30 * durationSecond2],
    [minute2, 1, durationMinute2],
    [minute2, 5, 5 * durationMinute2],
    [minute2, 15, 15 * durationMinute2],
    [minute2, 30, 30 * durationMinute2],
    [hour2, 1, durationHour2],
    [hour2, 3, 3 * durationHour2],
    [hour2, 6, 6 * durationHour2],
    [hour2, 12, 12 * durationHour2],
    [day2, 1, durationDay2],
    [day2, 2, 2 * durationDay2],
    [week, 1, durationWeek2],
    [month2, 1, durationMonth],
    [month2, 3, 3 * durationMonth],
    [year2, 1, durationYear]
  ];
  function tickFormat(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear3)(date2);
  }
  function tickInterval(interval, start, stop, step) {
    if (interval == null)
      interval = 10;
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval, i = bisector_default2(function(i2) {
        return i2[2];
      }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = tickStep2(start / durationYear, stop / durationYear, interval);
        interval = year2;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(tickStep2(start, stop, interval), 1);
        interval = millisecond2;
      }
    }
    return step == null ? interval : interval.every(step);
  }
  scale2.invert = function(y) {
    return new Date(invert(y));
  };
  scale2.domain = function(_) {
    return arguments.length ? domain(map6.call(_, number)) : domain().map(date);
  };
  scale2.ticks = function(interval, step) {
    var d = domain(), t02 = d[0], t12 = d[d.length - 1], r = t12 < t02, t;
    if (r)
      t = t02, t02 = t12, t12 = t;
    t = tickInterval(interval, t02, t12, step);
    t = t ? t.range(t02, t12 + 1) : [];
    return r ? t.reverse() : t;
  };
  scale2.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat : format2(specifier);
  };
  scale2.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain(nice_default(d, interval)) : scale2;
  };
  scale2.copy = function() {
    return copy(scale2, calendar(year2, month2, week, day2, hour2, minute2, second2, millisecond2, format2));
  };
  return scale2;
}
function time_default() {
  return initRange.apply(calendar(year_default, month_default, sunday, day_default, hour_default, minute_default, second_default, millisecond_default, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/sequential.js
function transformer2() {
  var x0 = 0, x1 = 1, t02, t12, k10, transform2, interpolator = identity2, clamp2 = false, unknown;
  function scale2(x) {
    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform2(x) - t02) * k10, clamp2 ? Math.max(0, Math.min(1, x)) : x));
  }
  scale2.domain = function(_) {
    return arguments.length ? (t02 = transform2(x0 = +_[0]), t12 = transform2(x1 = +_[1]), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale2) : [x0, x1];
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale2) : clamp2;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t) {
    transform2 = t, t02 = t(x0), t12 = t(x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
    return scale2;
  };
}
function copy2(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale2 = linearish(transformer2()(identity2));
  scale2.copy = function() {
    return copy2(scale2, sequential());
  };
  return initInterpolator.apply(scale2, arguments);
}

// node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x0 = 0, x1 = 0.5, x2 = 1, t02, t12, t2, k10, k21, interpolator = identity2, transform2, clamp2 = false, unknown;
  function scale2(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform2(x)) - t12) * (x < t12 ? k10 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x)) : x));
  }
  scale2.domain = function(_) {
    return arguments.length ? (t02 = transform2(x0 = +_[0]), t12 = transform2(x1 = +_[1]), t2 = transform2(x2 = +_[2]), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), scale2) : [x0, x1, x2];
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale2) : clamp2;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t) {
    transform2 = t, t02 = t(x0), t12 = t(x1), t2 = t(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12);
    return scale2;
  };
}
function diverging() {
  var scale2 = linearish(transformer3()(identity2));
  scale2.copy = function() {
    return copy2(scale2, diverging());
  };
  return initInterpolator.apply(scale2, arguments);
}

// node_modules/@antv/l7-layers/es/utils/identityScale.js
function identity4(d) {
  let unknown;
  let domain = [];
  function scale2(x) {
    return x == null ? unknown : x;
  }
  scale2.invert = scale2;
  scale2.domain = scale2.range = (v2) => {
    if (v2) {
      domain = v2;
      return v2;
    }
    return domain;
  };
  scale2.unknown = (v2) => {
    if (v2) {
      unknown = v2;
      return v2;
    }
    return unknown;
  };
  scale2.copy = () => {
    return identity4(d).unknown(unknown);
  };
  return scale2;
}

// node_modules/@antv/l7-layers/es/plugins/FeatureScalePlugin.js
var {
  isNil,
  isString: isString2,
  uniq
} = lodashUtil;
var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
var scaleMap = {
  [ScaleTypes.LINEAR]: linear2,
  [ScaleTypes.POWER]: pow,
  [ScaleTypes.LOG]: log,
  [ScaleTypes.IDENTITY]: identity4,
  [ScaleTypes.SEQUENTIAL]: sequential,
  [ScaleTypes.TIME]: time_default,
  [ScaleTypes.QUANTILE]: quantile2,
  [ScaleTypes.QUANTIZE]: quantize,
  [ScaleTypes.THRESHOLD]: threshold,
  [ScaleTypes.CAT]: ordinal,
  [ScaleTypes.DIVERGING]: diverging
};
var FeatureScalePlugin = class {
  constructor() {
    _defineProperty(this, "scaleOptions", {});
  }
  apply(layer, {
    styleAttributeService
  }) {
    var _this = this;
    layer.hooks.init.tapPromise("FeatureScalePlugin", _asyncToGenerator(function* () {
      var _layer$getSource;
      layer.log(IDebugLog.ScaleInitStart, ILayerStage.INIT);
      _this.scaleOptions = layer.getScaleOptions();
      const attributes = styleAttributeService.getLayerStyleAttributes();
      const dataArray = (_layer$getSource = layer.getSource()) === null || _layer$getSource === void 0 ? void 0 : _layer$getSource.data.dataArray;
      if (Array.isArray(dataArray) && dataArray.length === 0) {
        return;
      } else {
        _this.caculateScalesForAttributes(attributes || [], dataArray);
      }
      layer.log(IDebugLog.ScaleInitEnd, ILayerStage.INIT);
    }));
    layer.hooks.beforeRenderData.tapPromise("FeatureScalePlugin", function() {
      var _ref2 = _asyncToGenerator(function* (flag) {
        if (!flag) {
          return flag;
        }
        layer.log(IDebugLog.ScaleInitStart, ILayerStage.UPDATE);
        _this.scaleOptions = layer.getScaleOptions();
        const attributes = styleAttributeService.getLayerStyleAttributes();
        const dataArray = layer.getSource().data.dataArray;
        if (Array.isArray(dataArray) && dataArray.length === 0) {
          return true;
        }
        _this.caculateScalesForAttributes(attributes || [], dataArray);
        layer.log(IDebugLog.ScaleInitEnd, ILayerStage.UPDATE);
        layer.layerModelNeedUpdate = true;
        return true;
      });
      return function(_x) {
        return _ref2.apply(this, arguments);
      };
    }());
    layer.hooks.beforeRender.tap("FeatureScalePlugin", () => {
      if (layer.layerModelNeedUpdate) {
        return;
      }
      this.scaleOptions = layer.getScaleOptions();
      const attributes = styleAttributeService.getLayerStyleAttributes();
      const dataArray = layer.getSource().data.dataArray;
      if (Array.isArray(dataArray) && dataArray.length === 0) {
        return;
      }
      if (attributes) {
        const attributesToRescale = attributes.filter((attribute) => attribute.needRescale);
        if (attributesToRescale.length) {
          this.caculateScalesForAttributes(attributesToRescale, dataArray);
        }
      }
    });
  }
  isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
  caculateScalesForAttributes(attributes, dataArray) {
    attributes.forEach((attribute) => {
      if (attribute.scale) {
        const attributeScale = attribute.scale;
        const fieldValue = attribute.scale.field;
        attributeScale.names = this.parseFields(isNil(fieldValue) ? [] : fieldValue);
        const scales = [];
        attributeScale.names.forEach((field) => {
          var _attribute$scale;
          scales.push(this.createScale(field, attribute.name, (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.values, dataArray));
        });
        if (scales.some((scale2) => scale2.type === StyleScaleType.VARIABLE)) {
          attributeScale.type = StyleScaleType.VARIABLE;
          scales.forEach((scale2) => {
            if (!attributeScale.callback && attributeScale.values !== "text") {
              var _scale$option;
              switch ((_scale$option = scale2.option) === null || _scale$option === void 0 ? void 0 : _scale$option.type) {
                case ScaleTypes.LOG:
                case ScaleTypes.LINEAR:
                case ScaleTypes.POWER:
                  if (attributeScale.values && attributeScale.values.length > 2) {
                    const tick = scale2.scale.ticks(attributeScale.values.length);
                    scale2.scale.domain(tick);
                  }
                  attributeScale.values ? scale2.scale.range(attributeScale.values) : scale2.scale.range(scale2.option.domain);
                  break;
                case ScaleTypes.QUANTILE:
                case ScaleTypes.QUANTIZE:
                case ScaleTypes.THRESHOLD:
                  scale2.scale.range(attributeScale.values);
                  break;
                case ScaleTypes.IDENTITY:
                  break;
                case ScaleTypes.CAT:
                  attributeScale.values ? scale2.scale.range(attributeScale.values) : scale2.scale.range(scale2.option.domain);
                  break;
                case ScaleTypes.DIVERGING:
                case ScaleTypes.SEQUENTIAL:
                  scale2.scale.interpolator(
                    // @ts-ignore
                    rgbBasis(attributeScale.values)
                  );
                  break;
              }
            }
            if (attributeScale.values === "text") {
              var _scale$option2;
              scale2.scale.range((_scale$option2 = scale2.option) === null || _scale$option2 === void 0 ? void 0 : _scale$option2.domain);
            }
          });
        } else {
          attributeScale.type = StyleScaleType.CONSTANT;
          attributeScale.defaultValues = scales.map((scale2, index3) => {
            return scale2.scale(attributeScale.names[index3]);
          });
        }
        attributeScale.scalers = scales.map((scale2) => {
          return {
            field: scale2.field,
            func: scale2.scale,
            option: scale2.option
          };
        });
        attribute.needRescale = false;
      }
    });
  }
  /**
   * @example
   * 'w*h' => ['w', 'h']
   * 'w' => ['w']
   */
  parseFields(field) {
    if (Array.isArray(field)) {
      return field;
    }
    if (isString2(field)) {
      return field.split("*");
    }
    return [field];
  }
  createScale(field, name, values, data) {
    var _this$scaleOptions$na, _find;
    const scaleOption = this.scaleOptions[name] && ((_this$scaleOptions$na = this.scaleOptions[name]) === null || _this$scaleOptions$na === void 0 ? void 0 : _this$scaleOptions$na.field) === field ? this.scaleOptions[name] : this.scaleOptions[field];
    const styleScale = {
      field,
      scale: void 0,
      type: StyleScaleType.VARIABLE,
      option: scaleOption
    };
    if (!data || !data.length) {
      if (scaleOption && scaleOption.type) {
        styleScale.scale = this.createDefaultScale(scaleOption);
      } else {
        styleScale.scale = ordinal([field]);
        styleScale.type = StyleScaleType.CONSTANT;
      }
      return styleScale;
    }
    const firstValue = (_find = data.find((d) => !isNil(d[field]))) === null || _find === void 0 ? void 0 : _find[field];
    if (this.isNumber(field) || isNil(firstValue) && !scaleOption) {
      styleScale.scale = ordinal([field]);
      styleScale.type = StyleScaleType.CONSTANT;
    } else {
      let type = scaleOption && scaleOption.type || this.getDefaultType(firstValue);
      if (values === "text") {
        type = ScaleTypes.CAT;
      }
      if (values === void 0) {
        type = ScaleTypes.IDENTITY;
      }
      const cfg = this.createScaleConfig(type, field, scaleOption, data);
      styleScale.scale = this.createDefaultScale(cfg);
      styleScale.option = cfg;
    }
    return styleScale;
  }
  getDefaultType(firstValue) {
    let type = ScaleTypes.LINEAR;
    if (typeof firstValue === "string") {
      type = dateRegex.test(firstValue) ? ScaleTypes.TIME : ScaleTypes.CAT;
    }
    return type;
  }
  // 生成Scale 默认配置
  createScaleConfig(type, field, scaleOption, data) {
    const cfg = _objectSpread2(_objectSpread2({}, scaleOption), {}, {
      type
    });
    if (cfg !== null && cfg !== void 0 && cfg.domain)
      return cfg;
    let values = [];
    if (type === ScaleTypes.QUANTILE) {
      const idMap = /* @__PURE__ */ new Map();
      data === null || data === void 0 || data.forEach((obj) => {
        idMap.set(obj._id, obj[field]);
      });
      values = Array.from(idMap.values());
    } else {
      values = (data === null || data === void 0 ? void 0 : data.map((item) => item[field])) || [];
    }
    if (type === ScaleTypes.CAT || type === ScaleTypes.IDENTITY) {
      cfg.domain = uniq(values);
    } else if (type === ScaleTypes.QUANTILE) {
      cfg.domain = values;
    } else if (type === ScaleTypes.DIVERGING) {
      const minMax = extent_default(values);
      const neutral = (scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.neutral) !== void 0 ? scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.neutral : (minMax[0] + minMax[1]) / 2;
      cfg.domain = [minMax[0], neutral, minMax[1]];
    } else {
      cfg.domain = extent_default(values);
    }
    return cfg;
  }
  // 创建Scale 实例
  createDefaultScale({
    type,
    domain,
    unknown,
    clamp: clamp2,
    nice: nice2
  }) {
    const scale2 = scaleMap[type]();
    if (domain && scale2.domain) {
      scale2.domain(domain);
    }
    if (unknown) {
      scale2.unknown(unknown);
    }
    if (clamp2 !== void 0 && scale2.clamp) {
      scale2.clamp(clamp2);
    }
    if (nice2 !== void 0 && scale2.nice) {
      scale2.nice(nice2);
    }
    return scale2;
  }
};

// node_modules/@antv/l7-layers/es/plugins/LayerAnimateStylePlugin.js
var LayerAnimateStylePlugin = class {
  apply(layer) {
    layer.hooks.beforeRender.tap("LayerAnimateStylePlugin", () => {
      const animateStatus = layer.animateStatus;
      if (animateStatus) {
        layer.models.forEach((model) => {
          model.addUniforms(_objectSpread2({}, layer.layerModel.getAnimateUniforms()));
        });
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/plugins/LayerMaskPlugin.js
var LayerStylePlugin = class {
  apply(layer) {
    layer.hooks.afterInit.tap("LayerMaskPlugin", () => {
      const {
        maskLayers,
        enableMask
      } = layer.getLayerConfig();
      if (!layer.tileLayer && maskLayers && maskLayers.length > 0) {
        layer.updateLayerConfig({
          mask: enableMask
        });
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/plugins/LayerModelPlugin.js
var LayerModelPlugin = class {
  build(layer) {
    return _asyncToGenerator(function* () {
      layer.prepareBuildModel();
      yield layer.buildModels();
    })();
  }
  initLayerModel(layer) {
    var _this = this;
    return _asyncToGenerator(function* () {
      yield _this.build(layer);
      layer.styleNeedUpdate = false;
    })();
  }
  prepareLayerModel(layer) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      yield _this2.build(layer);
      layer.styleNeedUpdate = false;
    })();
  }
  apply(layer) {
    var _this3 = this;
    layer.hooks.init.tapPromise("LayerModelPlugin", _asyncToGenerator(function* () {
      if (layer.getSource().isTile) {
        layer.prepareBuildModel();
        return;
      }
      layer.log(IDebugLog.BuildModelStart, ILayerStage.INIT);
      yield _this3.initLayerModel(layer);
      layer.log(IDebugLog.BuildModelEnd, ILayerStage.INIT);
    }));
    layer.hooks.beforeRenderData.tapPromise("LayerModelPlugin", function() {
      var _ref2 = _asyncToGenerator(function* (flag) {
        if (!flag) {
          return false;
        }
        if (layer.getSource().isTile) {
          return false;
        }
        layer.log(IDebugLog.BuildModelStart, ILayerStage.UPDATE);
        yield _this3.prepareLayerModel(layer);
        layer.log(IDebugLog.BuildModelEnd, ILayerStage.UPDATE);
        return true;
      });
      return function(_x) {
        return _ref2.apply(this, arguments);
      };
    }());
  }
};

// node_modules/@antv/l7-layers/es/plugins/LayerStylePlugin.js
var LayerStylePlugin2 = class {
  apply(layer) {
    layer.hooks.afterInit.tap("LayerStylePlugin", () => {
      const {
        autoFit,
        fitBoundsOptions
      } = layer.getLayerConfig();
      if (autoFit) {
        layer.fitBounds(fitBoundsOptions);
      }
      layer.styleNeedUpdate = false;
    });
  }
};

// node_modules/@antv/l7-layers/es/plugins/LightingPlugin.js
var _excluded = ["type"];
var lightTypeUniformMap = {
  directional: {
    lights: "u_DirectionalLights",
    num: "u_NumOfDirectionalLights"
  },
  spot: {
    lights: "u_SpotLights",
    num: "u_NumOfSpotLights"
  }
};
var DEFAULT_LIGHT = {
  type: "directional",
  direction: [1, 10.5, 12],
  ambient: [0.2, 0.2, 0.2],
  diffuse: [0.6, 0.6, 0.6],
  specular: [0.1, 0.1, 0.1]
};
var DEFAULT_DIRECTIONAL_LIGHT = {
  direction: [0, 0, 0],
  ambient: [0, 0, 0],
  diffuse: [0, 0, 0],
  specular: [0, 0, 0]
};
var DEFAULT_SPOT_LIGHT = {
  position: [0, 0, 0],
  direction: [0, 0, 0],
  ambient: [0, 0, 0],
  diffuse: [0, 0, 0],
  specular: [0, 0, 0],
  constant: 1,
  linear: 0,
  quadratic: 0,
  angle: 14,
  exponent: 40,
  blur: 5
};
function generateLightingUniforms(lights) {
  const lightsMap = {
    u_DirectionalLights: new Array(3).fill(_objectSpread2({}, DEFAULT_DIRECTIONAL_LIGHT)),
    u_NumOfDirectionalLights: 0,
    u_SpotLights: new Array(3).fill(_objectSpread2({}, DEFAULT_SPOT_LIGHT)),
    u_NumOfSpotLights: 0
  };
  if (!lights || !lights.length) {
    lights = [DEFAULT_LIGHT];
  }
  lights.forEach((_ref) => {
    let {
      type = "directional"
    } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
    const lightsUniformName = lightTypeUniformMap[type].lights;
    const lightsNumUniformName = lightTypeUniformMap[type].num;
    const num = lightsMap[lightsNumUniformName];
    lightsMap[lightsUniformName][num] = _objectSpread2(_objectSpread2({}, lightsMap[lightsUniformName][num]), rest);
    lightsMap[lightsNumUniformName]++;
  });
  return lightsMap;
}
var LightingPlugin = class {
  apply(layer) {
    layer.hooks.beforeRender.tap("LightingPlugin", () => {
      const {
        enableLighting
      } = layer.getLayerConfig();
      if (enableLighting) {
        layer.models.forEach((model) => (
          // @ts-ignore
          model.addUniforms(_objectSpread2({}, generateLightingUniforms()))
        ));
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/utils/multiPassRender.js
function normalizePasses(passes) {
  return passes.map((pass) => {
    if (typeof pass === "string") {
      pass = [pass, {}];
    }
    return pass;
  });
}
function createMultiPassRenderer(layer, passes, postProcessingPassFactory, normalPassFactory) {
  const multiPassRenderer = layer.multiPassRenderer;
  multiPassRenderer.add(normalPassFactory("render"));
  normalizePasses(passes).forEach((pass) => {
    const [passName, initializationOptions] = pass;
    multiPassRenderer.add(postProcessingPassFactory(passName), initializationOptions);
  });
  multiPassRenderer.add(postProcessingPassFactory("copy"));
  return multiPassRenderer;
}

// node_modules/@antv/l7-layers/es/plugins/MultiPassRendererPlugin.js
var MultiPassRendererPlugin = class {
  constructor() {
    _defineProperty(this, "enabled", void 0);
  }
  apply(layer, {
    rendererService,
    postProcessingPassFactory,
    normalPassFactory
  }) {
    layer.hooks.init.tapPromise("MultiPassRendererPlugin", () => {
      const {
        enableMultiPassRenderer,
        passes = []
      } = layer.getLayerConfig();
      this.enabled = !!enableMultiPassRenderer && layer.getLayerConfig().enableMultiPassRenderer !== false;
      if (this.enabled) {
        layer.multiPassRenderer = createMultiPassRenderer(layer, passes, postProcessingPassFactory, normalPassFactory);
        layer.multiPassRenderer.setRenderFlag(true);
      }
    });
    layer.hooks.beforeRender.tap("MultiPassRendererPlugin", () => {
      if (this.enabled) {
        const {
          width,
          height
        } = rendererService.getViewportSize();
        layer.multiPassRenderer.resize(width, height);
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/core/CommonStyleAttribute.js
var COMMON_ATTRIBUTE_LOCATION = {
  // common attribute in RegisterStyleAttributePlugin
  POSITION: 0,
  // low part for double precision POSITION attribute
  POSITION_64LOW: 1,
  COLOR: 2,
  PICKING_COLOR: 3,
  // common style attribute
  STROKE: 4,
  OPACITY: 5,
  OFFSETS: 6,
  ROTATION: 7,
  // last index
  MAX: 8
};
function getCommonStyleAttributeOptions(name) {
  switch (name) {
    case "rotation":
      return {
        name: "Rotation",
        type: AttributeType.Attribute,
        descriptor: {
          name: "a_Rotation",
          shaderLocation: COMMON_ATTRIBUTE_LOCATION.ROTATION,
          buffer: {
            usage: gl.DYNAMIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 1,
          update: (feature) => {
            const {
              rotation = 0
            } = feature;
            return Array.isArray(rotation) ? [rotation[0]] : [rotation];
          }
        }
      };
    case "stroke":
      return {
        name: "stroke",
        type: AttributeType.Attribute,
        descriptor: {
          name: "a_Stroke",
          shaderLocation: COMMON_ATTRIBUTE_LOCATION.STROKE,
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: gl.DYNAMIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 4,
          update: (feature) => {
            const {
              stroke = [1, 1, 1, 1]
            } = feature;
            return stroke;
          }
        }
      };
    case "opacity":
      return {
        name: "opacity",
        type: AttributeType.Attribute,
        descriptor: {
          name: "a_Opacity",
          shaderLocation: COMMON_ATTRIBUTE_LOCATION.OPACITY,
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: gl.STATIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 1,
          update: (feature) => {
            const {
              opacity: op = 1
            } = feature;
            return [op];
          }
        }
      };
    case "offsets":
      return {
        name: "offsets",
        type: AttributeType.Attribute,
        descriptor: {
          name: "a_Offsets",
          shaderLocation: COMMON_ATTRIBUTE_LOCATION.OFFSETS,
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: gl.STATIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 2,
          update: (feature) => {
            const {
              offsets: epo
            } = feature;
            return epo;
          }
        }
      };
    default:
      return void 0;
  }
}

// node_modules/@antv/l7-layers/es/plugins/PixelPickingPlugin.js
var {
  isNumber: isNumber3
} = lodashUtil;
var PickingStage = {
  NONE: 0,
  ENCODE: 1,
  HIGHLIGHT: 2
};
var PixelPickingPlugin = class {
  constructor() {
    _defineProperty(this, "pickingUniformMap", void 0);
  }
  pickOption2Array() {
    const array4 = [];
    this.pickingUniformMap.forEach((value) => {
      if (isNumber3(value)) {
        array4.push(value);
      } else {
        array4.push(...value);
      }
    });
    return array4;
  }
  updatePickOption(options, layer) {
    Object.keys(options).forEach((key) => {
      this.pickingUniformMap.set(key, options[key]);
    });
    const u_PickingBuffer = layer.getLayerConfig().pickingBuffer || 0;
    const u_shaderPick = Number(layer.getShaderPickStat());
    this.pickingUniformMap.set("u_PickingBuffer", u_PickingBuffer);
    this.pickingUniformMap.set("u_shaderPick", u_shaderPick);
    const uniformBuffer = layer.getPickingUniformBuffer();
    uniformBuffer.subData({
      offset: 0,
      data: this.pickOption2Array()
    });
  }
  apply(layer, {
    styleAttributeService
  }) {
    this.pickingUniformMap = /* @__PURE__ */ new Map([["u_HighlightColor", [1, 0, 0, 1]], ["u_SelectColor", [1, 0, 0, 1]], ["u_PickingColor", [0, 0, 0]], ["u_PickingStage", 0], ["u_CurrentSelectedId", [0, 0, 0]], ["u_PickingThreshold", 10], ["u_PickingBuffer", 0], ["u_shaderPick", 0], ["u_activeMix", 0]]);
    layer.hooks.init.tapPromise("PixelPickingPlugin", () => {
      const {
        enablePicking
      } = layer.getLayerConfig();
      styleAttributeService.registerStyleAttribute({
        name: "pickingColor",
        type: AttributeType.Attribute,
        descriptor: {
          name: "a_PickingColor",
          shaderLocation: COMMON_ATTRIBUTE_LOCATION.PICKING_COLOR,
          buffer: {
            data: [],
            type: gl.FLOAT
          },
          size: 3,
          // TODO: 固定 feature range 范围内的 pickingColor 都是固定的，可以生成 cache
          update: (feature) => {
            const {
              id
            } = feature;
            return enablePicking ? encodePickingColor(id) : [0, 0, 0];
          }
        }
      });
    });
    layer.hooks.beforePickingEncode.tap("PixelPickingPlugin", () => {
      const {
        enablePicking
      } = layer.getLayerConfig();
      if (enablePicking && layer.isVisible()) {
        this.updatePickOption({
          u_PickingStage: PickingStage.ENCODE
        }, layer);
        layer.models.forEach((model) => model.addUniforms({
          u_PickingStage: PickingStage.ENCODE
        }));
      }
    });
    layer.hooks.afterPickingEncode.tap("PixelPickingPlugin", () => {
      const {
        enablePicking
      } = layer.getLayerConfig();
      if (enablePicking && layer.isVisible()) {
        this.updatePickOption({
          u_PickingStage: PickingStage.HIGHLIGHT
        }, layer);
        layer.models.forEach((model) => model.addUniforms({
          u_PickingStage: PickingStage.HIGHLIGHT
        }));
      }
    });
    layer.hooks.beforeHighlight.tap("PixelPickingPlugin", (pickedColor) => {
      const {
        highlightColor,
        activeMix = 0
      } = layer.getLayerConfig();
      const highlightColorInArray = typeof highlightColor === "string" ? rgb2arr(highlightColor) : highlightColor || [1, 0, 0, 1];
      layer.updateLayerConfig({
        pickedFeatureID: decodePickingColor(new Uint8Array(pickedColor))
      });
      const option = {
        u_PickingStage: PickingStage.HIGHLIGHT,
        u_PickingColor: pickedColor,
        u_HighlightColor: highlightColorInArray.map((c) => c * 255),
        u_activeMix: activeMix
      };
      this.updatePickOption(option, layer);
      layer.models.forEach((model) => model.addUniforms(option));
    });
    layer.hooks.beforeSelect.tap("PixelPickingPlugin", (pickedColor) => {
      const {
        selectColor,
        selectMix = 0
      } = layer.getLayerConfig();
      const highlightColorInArray = typeof selectColor === "string" ? rgb2arr(selectColor) : selectColor || [1, 0, 0, 1];
      layer.updateLayerConfig({
        pickedFeatureID: decodePickingColor(new Uint8Array(pickedColor))
      });
      const option = {
        u_PickingStage: PickingStage.HIGHLIGHT,
        u_PickingColor: pickedColor,
        u_HighlightColor: highlightColorInArray.map((c) => c * 255),
        u_activeMix: selectMix,
        u_CurrentSelectedId: pickedColor,
        u_SelectColor: highlightColorInArray.map((c) => c * 255)
      };
      this.updatePickOption(option, layer);
      layer.models.forEach((model) => model.addUniforms(option));
    });
  }
};

// node_modules/@antv/l7-layers/es/tile/utils/utils.js
var tileVectorParser = ["mvt", "geojsonvt", "testTile"];
function isTileGroup(layer) {
  const source = layer.getSource();
  return tileVectorParser.includes(source.parser.type);
}

// node_modules/@antv/l7-layers/es/plugins/RegisterStyleAttributePlugin.js
var RegisterStyleAttributePlugin = class {
  apply(layer, {
    styleAttributeService
  }) {
    layer.hooks.init.tapPromise("RegisterStyleAttributePlugin", () => {
      if (isTileGroup(layer)) {
        return;
      }
      this.registerBuiltinAttributes(styleAttributeService, layer);
    });
  }
  registerBuiltinAttributes(styleAttributeService, layer) {
    if (layer.type === "MaskLayer") {
      this.registerPositionAttribute(styleAttributeService);
      return;
    }
    this.registerPositionAttribute(styleAttributeService);
    this.registerColorAttribute(styleAttributeService);
  }
  registerPositionAttribute(styleAttributeService) {
    styleAttributeService.registerStyleAttribute({
      name: "position",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Position",
        shaderLocation: COMMON_ATTRIBUTE_LOCATION.POSITION,
        buffer: {
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex) => {
          return vertex.length === 2 ? [vertex[0], vertex[1], 0] : [vertex[0], vertex[1], vertex[2]];
        }
      }
    });
  }
  registerColorAttribute(styleAttributeService) {
    styleAttributeService.registerStyleAttribute({
      name: "color",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Color",
        shaderLocation: COMMON_ATTRIBUTE_LOCATION.COLOR,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature) => {
          const {
            color: color2
          } = feature;
          return !color2 || !color2.length ? [1, 1, 1, 1] : color2;
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/plugins/ShaderUniformPlugin.js
var ShaderUniformPlugin = class {
  constructor() {
    _defineProperty(this, "cameraService", void 0);
    _defineProperty(this, "coordinateSystemService", void 0);
    _defineProperty(this, "rendererService", void 0);
    _defineProperty(this, "mapService", void 0);
    _defineProperty(this, "layerService", void 0);
  }
  apply(layer, {
    rendererService,
    mapService,
    layerService,
    coordinateSystemService,
    cameraService
  }) {
    this.rendererService = rendererService;
    this.mapService = mapService;
    this.layerService = layerService;
    this.coordinateSystemService = coordinateSystemService;
    this.cameraService = cameraService;
    let uniformBuffer;
    if (!this.rendererService.uniformBuffers[0]) {
      uniformBuffer = this.rendererService.createBuffer({
        data: new Float32Array(16 * 4 + 4 * 7),
        isUBO: true,
        label: "renderUniformBuffer"
      });
      this.rendererService.uniformBuffers[0] = uniformBuffer;
    }
    layer.hooks.beforeRender.tap("ShaderUniformPlugin", () => {
      const offset = layer.getLayerConfig().tileOrigin;
      this.coordinateSystemService.refresh(offset);
      const {
        width,
        height
      } = this.rendererService.getViewportSize();
      const {
        data,
        uniforms
      } = this.generateUBO(width, height);
      if (this.layerService.alreadyInRendering && this.rendererService.uniformBuffers[0]) {
        const renderUniformBuffer = this.rendererService.uniformBuffers[0];
        renderUniformBuffer.subData({
          offset: 0,
          data
        });
      }
      const platformString = this.rendererService.queryVerdorInfo();
      if (platformString === "WebGL1") {
        layer.models.forEach((model) => {
          model.addUniforms(_objectSpread2(_objectSpread2({}, uniforms), {}, {
            // TODO: move these 2 uniforms to PixelPickingPlugin
            u_PickingBuffer: layer.getLayerConfig().pickingBuffer || 0,
            // Tip: 当前地图是否在拖动
            u_shaderPick: Number(layer.getShaderPickStat())
          }));
        });
      }
    });
  }
  generateUBO(width, height) {
    const u_ProjectionMatrix = this.cameraService.getProjectionMatrix();
    const u_ViewMatrix = this.cameraService.getViewMatrix();
    const u_ViewProjectionMatrix = this.cameraService.getViewProjectionMatrix();
    const u_ModelMatrix = this.cameraService.getModelMatrix();
    const u_ViewportCenterProjection = this.coordinateSystemService.getViewportCenterProjection();
    const u_PixelsPerDegree = this.coordinateSystemService.getPixelsPerDegree();
    const u_Zoom = this.cameraService.getZoom();
    const u_PixelsPerDegree2 = this.coordinateSystemService.getPixelsPerDegree2();
    const u_ZoomScale = this.cameraService.getZoomScale();
    const u_PixelsPerMeter = this.coordinateSystemService.getPixelsPerMeter();
    const u_CoordinateSystem = this.coordinateSystemService.getCoordinateSystem();
    const u_CameraPosition = this.cameraService.getCameraPosition();
    const u_DevicePixelRatio = window.devicePixelRatio;
    const u_ViewportCenter = this.coordinateSystemService.getViewportCenter();
    const u_ViewportSize = [width, height];
    const u_FocalDistance = this.cameraService.getFocalDistance();
    const data = [
      ...u_ViewMatrix,
      // 16
      ...u_ProjectionMatrix,
      // 16
      ...u_ViewProjectionMatrix,
      // 16
      ...u_ModelMatrix,
      // 16
      ...u_ViewportCenterProjection,
      // 4
      ...u_PixelsPerDegree,
      // 4
      u_Zoom,
      ...u_PixelsPerDegree2,
      // 4
      u_ZoomScale,
      ...u_PixelsPerMeter,
      // 4
      u_CoordinateSystem,
      ...u_CameraPosition,
      // 4
      u_DevicePixelRatio,
      // 4
      ...u_ViewportCenter,
      ...u_ViewportSize,
      // 4
      u_FocalDistance,
      // 1
      0,
      0,
      0
    ];
    return {
      data,
      uniforms: {
        // 相机参数，包含 VP 矩阵、缩放等级
        [CameraUniform.ProjectionMatrix]: u_ProjectionMatrix,
        [CameraUniform.ViewMatrix]: u_ViewMatrix,
        [CameraUniform.ViewProjectionMatrix]: u_ViewProjectionMatrix,
        [CameraUniform.Zoom]: u_Zoom,
        [CameraUniform.ZoomScale]: u_ZoomScale,
        [CameraUniform.FocalDistance]: u_FocalDistance,
        [CameraUniform.CameraPosition]: u_CameraPosition,
        // 坐标系参数
        [CoordinateUniform.CoordinateSystem]: u_CoordinateSystem,
        [CoordinateUniform.ViewportCenter]: u_ViewportCenter,
        [CoordinateUniform.ViewportCenterProjection]: u_ViewportCenterProjection,
        [CoordinateUniform.PixelsPerDegree]: u_PixelsPerDegree,
        [CoordinateUniform.PixelsPerDegree2]: u_PixelsPerDegree2,
        [CoordinateUniform.PixelsPerMeter]: u_PixelsPerMeter,
        // 其他参数，例如视口大小、DPR 等
        u_ViewportSize,
        u_ModelMatrix,
        u_DevicePixelRatio
      }
    };
  }
};

// node_modules/@antv/l7-layers/es/plugins/UpdateModelPlugin.js
var UpdateModelPlugin = class {
  apply(layer) {
    layer.hooks.beforeRender.tap("UpdateModelPlugin", () => {
      if (layer.layerModel) {
        layer.layerModel.needUpdate().then((flag) => {
          if (flag) {
            layer.renderLayers();
          }
        });
      }
    });
    layer.hooks.afterRender.tap("UpdateModelPlugin", () => {
      layer.layerModelNeedUpdate = false;
    });
  }
};

// node_modules/@antv/l7-layers/es/plugins/UpdateStyleAttributePlugin.js
var UpdateStyleAttributePlugin = class {
  apply(layer, {
    styleAttributeService
  }) {
    layer.hooks.init.tapPromise("UpdateStyleAttributePlugin", () => {
      this.initStyleAttribute(layer, {
        styleAttributeService
      });
    });
    layer.hooks.beforeRender.tap("UpdateStyleAttributePlugin", () => {
      if (layer.layerModelNeedUpdate) {
        return;
      }
      if (layer.inited) {
        this.updateStyleAttribute(layer, {
          styleAttributeService
        });
      }
    });
  }
  updateStyleAttribute(layer, {
    styleAttributeService
  }) {
    const attributes = styleAttributeService.getLayerStyleAttributes() || [];
    const filter3 = styleAttributeService.getLayerStyleAttribute("filter");
    if (filter3 && filter3.needRegenerateVertices) {
      layer.layerModelNeedUpdate = true;
      attributes.forEach((attr) => attr.needRegenerateVertices = false);
      return;
    }
    attributes.filter((attribute) => attribute.needRegenerateVertices).forEach((attribute) => {
      styleAttributeService.updateAttributeByFeatureRange(
        attribute.name,
        layer.getEncodedData(),
        // 获取经过 mapping 最新的数据
        attribute.featureRange.startIndex,
        attribute.featureRange.endIndex,
        layer
      );
      attribute.needRegenerateVertices = false;
    });
  }
  initStyleAttribute(layer, {
    styleAttributeService
  }) {
    const attributes = styleAttributeService.getLayerStyleAttributes() || [];
    attributes.filter((attribute) => attribute.needRegenerateVertices).forEach((attribute) => {
      styleAttributeService.updateAttributeByFeatureRange(
        attribute.name,
        layer.getEncodedData(),
        // 获取经过 mapping 最新的数据
        attribute.featureRange.startIndex,
        attribute.featureRange.endIndex
      );
      attribute.needRegenerateVertices = false;
    });
  }
};

// node_modules/@antv/l7-layers/es/plugins/index.js
function createPlugins() {
  return [new DataSourcePlugin(), new RegisterStyleAttributePlugin(), new FeatureScalePlugin(), new DataMappingPlugin(), new LayerStylePlugin2(), new LayerStylePlugin(), new UpdateStyleAttributePlugin(), new UpdateModelPlugin(), new MultiPassRendererPlugin(), new ShaderUniformPlugin(), new LayerAnimateStylePlugin(), new LightingPlugin(), new PixelPickingPlugin(), new LayerModelPlugin()];
}

// node_modules/@antv/l7-layers/es/utils/blend.js
var BlendTypes = {
  [BlendType.additive]: {
    enable: true,
    func: {
      srcRGB: gl.ONE,
      dstRGB: gl.ONE,
      srcAlpha: 1,
      dstAlpha: 1
    }
  },
  [BlendType.none]: {
    enable: false
  },
  [BlendType.normal]: {
    enable: true,
    func: {
      srcRGB: gl.SRC_ALPHA,
      dstRGB: gl.ONE_MINUS_SRC_ALPHA,
      srcAlpha: 1,
      dstAlpha: 1
    }
  },
  [BlendType.subtractive]: {
    enable: true,
    func: {
      srcRGB: gl.ONE,
      dstRGB: gl.ONE,
      srcAlpha: gl.ZERO,
      dstAlpha: gl.ONE_MINUS_SRC_COLOR
    },
    equation: {
      rgb: gl.FUNC_SUBTRACT,
      alpha: gl.FUNC_SUBTRACT
    }
  },
  [BlendType.max]: {
    enable: true,
    func: {
      srcRGB: gl.ONE,
      dstRGB: gl.ONE
    },
    equation: {
      rgb: gl.MAX_EXT
    }
  },
  [BlendType.min]: {
    enable: true,
    func: {
      srcRGB: gl.ONE,
      dstRGB: gl.ONE
    },
    equation: {
      rgb: gl.MIN_EXT
    }
  }
};

// node_modules/@antv/l7-layers/es/core/LayerPickService.js
var BaseLayerPickService = class {
  constructor(layer) {
    _defineProperty(this, "layer", void 0);
    this.layer = layer;
  }
  pickRender(target) {
    const container = this.layer.getContainer();
    const layerService = container.layerService;
    const layer = this.layer;
    if (layer.tileLayer) {
      return layer.tileLayer.pickRender(target);
    }
    layer.hooks.beforePickingEncode.call();
    layerService.renderTileLayerMask(layer);
    layer.renderModels({
      ispick: true
    });
    layer.hooks.afterPickingEncode.call();
  }
  pick(layer, target) {
    var _this = this;
    return _asyncToGenerator(function* () {
      const container = _this.layer.getContainer();
      const pickingService = container.pickingService;
      if (layer.type === "RasterLayer") {
        return _this.pickRasterLayer(layer, target);
      }
      _this.pickRender(target);
      return pickingService.pickFromPickingFBO(layer, target);
    })();
  }
  pickRasterLayer(layer, target, parent) {
    const container = this.layer.getContainer();
    const pickingService = container.pickingService;
    const mapService = container.mapService;
    const extent2 = this.layer.getSource().extent;
    const isPick = lngLatInExtent(target.lngLat, extent2);
    const layerTarget = {
      x: target.x,
      y: target.y,
      type: target.type,
      lngLat: target.lngLat,
      target,
      rasterValue: null
    };
    const adviceTarget = parent ? parent : layer;
    if (isPick) {
      const rasterValue = this.readRasterValue(layer, extent2, mapService, target.x, target.y);
      layerTarget.rasterValue = rasterValue;
      pickingService.triggerHoverOnLayer(adviceTarget, layerTarget);
      return true;
    } else {
      layerTarget.type = target.type === "mousemove" ? "mouseout" : "un" + target.type;
      pickingService.triggerHoverOnLayer(adviceTarget, _objectSpread2(_objectSpread2({}, layerTarget), {}, {
        type: "unpick"
      }));
      pickingService.triggerHoverOnLayer(adviceTarget, layerTarget);
      return false;
    }
  }
  readRasterValue(layer, bbox, mapService, x, y) {
    const rasterData = layer.getSource().data.dataArray[0];
    const [minLng = 0, minLat = 0, maxLng = 10, maxLat = -10] = bbox;
    const tileXY = mapService.lngLatToContainer([minLng, minLat]);
    const tileMaxXY = mapService.lngLatToContainer([maxLng, maxLat]);
    const tilePixelWidth = tileMaxXY.x - tileXY.x;
    const tilePixelHeight = tileXY.y - tileMaxXY.y;
    const pos = [
      (x - tileXY.x) / tilePixelWidth,
      // x
      (y - tileMaxXY.y) / tilePixelHeight
      // y
    ];
    const tileWidth = rasterData.width || 1;
    const tileHeight = rasterData.height || 1;
    const indexX = Math.floor(pos[0] * tileWidth);
    const indexY = Math.floor(pos[1] * tileHeight);
    const index3 = Math.max(0, indexY - 1) * tileWidth + indexX;
    const data = rasterData.data[index3];
    return data;
  }
  selectFeature(pickedColors) {
    const layer = this.layer;
    const [r, g, b] = pickedColors;
    layer.hooks.beforeSelect.call([r, g, b]);
  }
  highlightPickedFeature(pickedColors) {
    const [r, g, b] = pickedColors;
    this.layer.hooks.beforeHighlight.call([r, g, b]);
  }
  getFeatureById(pickedFeatureIdx) {
    return this.layer.getSource().getFeatureById(pickedFeatureIdx);
  }
};

// node_modules/@antv/l7-layers/es/core/TextureService.js
var TextureService = class {
  constructor(layer) {
    _defineProperty(this, "layer", void 0);
    _defineProperty(this, "rendererService", void 0);
    _defineProperty(this, "colorTexture", void 0);
    _defineProperty(this, "key", void 0);
    this.layer = layer;
    const container = this.layer.getContainer();
    this.rendererService = container.rendererService;
  }
  getColorTexture(colorRamp, domain) {
    const currentkey = this.getTextureKey(colorRamp, domain);
    if (this.key === currentkey) {
      return this.colorTexture;
    } else {
      this.createColorTexture(colorRamp, domain);
    }
    this.key = currentkey;
    return this.colorTexture;
  }
  createColorTexture(colorRamp, domain) {
    const {
      createTexture2D
    } = this.rendererService;
    const imageData = this.getColorRampBar(colorRamp, domain);
    const texture = createTexture2D({
      data: new Uint8Array(imageData.data),
      width: imageData.width,
      height: imageData.height,
      flipY: false,
      unorm: true
    });
    this.colorTexture = texture;
    return texture;
  }
  setColorTexture(texture, colorRamp, domain) {
    this.key = this.getTextureKey(colorRamp, domain);
    this.colorTexture = texture;
  }
  destroy() {
    var _this$colorTexture;
    (_this$colorTexture = this.colorTexture) === null || _this$colorTexture === void 0 || _this$colorTexture.destroy();
  }
  getColorRampBar(colorRamp, domain) {
    switch (colorRamp.type) {
      case "cat":
        return generateCatRamp(colorRamp);
      case "quantize":
        return generateQuantizeRamp(colorRamp);
      case "custom":
        return generateCustomRamp(colorRamp, domain);
      case "linear":
        return generateLinearRamp(colorRamp, domain);
      default:
        return generateColorRamp(colorRamp);
    }
  }
  getTextureKey(colorRamp, domain) {
    var _colorRamp$positions;
    return `${colorRamp.colors.join("_")}_${colorRamp === null || colorRamp === void 0 || (_colorRamp$positions = colorRamp.positions) === null || _colorRamp$positions === void 0 ? void 0 : _colorRamp$positions.join("_")}_${colorRamp.type}_${domain === null || domain === void 0 ? void 0 : domain.join("_")}`;
  }
};

// node_modules/@antv/l7-layers/es/core/BaseLayer.js
var _excluded2 = ["passes"];
var _excluded22 = ["moduleName", "vertexShader", "fragmentShader", "defines", "inject", "triangulation", "styleOption", "pickingEnabled"];
var {
  isEqual,
  isFunction: isFunction2,
  isNumber: isNumber4,
  isObject,
  isPlainObject,
  isUndefined
} = lodashUtil;
var layerIdCounter = 0;
var BaseLayer = class extends import_eventemitter36.EventEmitter {
  get shaderModuleService() {
    return this.container.shaderModuleService;
  }
  get cameraService() {
    return this.container.cameraService;
  }
  get coordinateService() {
    return this.container.coordinateSystemService;
  }
  get iconService() {
    return this.container.iconService;
  }
  get fontService() {
    return this.container.fontService;
  }
  get pickingService() {
    return this.container.pickingService;
  }
  get rendererService() {
    return this.container.rendererService;
  }
  get layerService() {
    return this.container.layerService;
  }
  get debugService() {
    return this.container.debugService;
  }
  get interactionService() {
    return this.container.interactionService;
  }
  get mapService() {
    var _this$container;
    return (_this$container = this.container) === null || _this$container === void 0 ? void 0 : _this$container.mapService;
  }
  get normalPassFactory() {
    return this.container.normalPassFactory;
  }
  constructor(config = {}) {
    super();
    _defineProperty(this, "id", `${layerIdCounter++}`);
    _defineProperty(this, "name", `${layerIdCounter}`);
    _defineProperty(this, "parent", void 0);
    _defineProperty(this, "coordCenter", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "visible", true);
    _defineProperty(this, "zIndex", 0);
    _defineProperty(this, "minZoom", void 0);
    _defineProperty(this, "maxZoom", void 0);
    _defineProperty(this, "inited", false);
    _defineProperty(this, "layerModelNeedUpdate", false);
    _defineProperty(this, "pickedFeatureID", null);
    _defineProperty(this, "selectedFeatureID", null);
    _defineProperty(this, "styleNeedUpdate", false);
    _defineProperty(this, "rendering", void 0);
    _defineProperty(this, "forceRender", false);
    _defineProperty(this, "clusterZoom", 0);
    _defineProperty(this, "layerType", void 0);
    _defineProperty(this, "triangulation", void 0);
    _defineProperty(this, "layerPickService", void 0);
    _defineProperty(this, "textureService", void 0);
    _defineProperty(this, "defaultSourceConfig", {
      data: [],
      options: {
        parser: {
          type: "json"
        }
      }
    });
    _defineProperty(this, "dataState", {
      dataSourceNeedUpdate: false,
      dataMappingNeedUpdate: false,
      filterNeedUpdate: false,
      featureScaleNeedUpdate: false,
      StyleAttrNeedUpdate: false
    });
    _defineProperty(this, "hooks", {
      init: new AsyncSeriesBailHook(),
      afterInit: new SyncBailHook(),
      beforeRender: new SyncBailHook(),
      beforeRenderData: new AsyncWaterfallHook(),
      afterRender: new SyncHook(),
      beforePickingEncode: new SyncHook(),
      afterPickingEncode: new SyncHook(),
      beforeHighlight: new SyncHook(["pickedColor"]),
      afterHighlight: new SyncHook(),
      beforeSelect: new SyncHook(["pickedColor"]),
      afterSelect: new SyncHook(),
      beforeDestroy: new SyncHook(),
      afterDestroy: new SyncHook()
    });
    _defineProperty(this, "models", []);
    _defineProperty(this, "multiPassRenderer", void 0);
    _defineProperty(this, "plugins", void 0);
    _defineProperty(this, "startInit", false);
    _defineProperty(this, "sourceOption", void 0);
    _defineProperty(this, "layerModel", void 0);
    _defineProperty(this, "shapeOption", void 0);
    _defineProperty(this, "tileLayer", void 0);
    _defineProperty(this, "layerChildren", []);
    _defineProperty(this, "masks", []);
    _defineProperty(this, "configService", globalConfigService);
    _defineProperty(this, "styleAttributeService", void 0);
    _defineProperty(this, "layerSource", void 0);
    _defineProperty(this, "postProcessingPassFactory", void 0);
    _defineProperty(this, "animateOptions", {
      enable: false
    });
    _defineProperty(this, "container", void 0);
    _defineProperty(this, "encodedData", void 0);
    _defineProperty(this, "currentPickId", null);
    _defineProperty(this, "rawConfig", void 0);
    _defineProperty(this, "needUpdateConfig", void 0);
    _defineProperty(this, "encodeStyleAttribute", {});
    _defineProperty(this, "enableShaderEncodeStyles", []);
    _defineProperty(this, "enableDataEncodeStyles", []);
    _defineProperty(this, "pendingStyleAttributes", []);
    _defineProperty(this, "scaleOptions", {});
    _defineProperty(this, "animateStartTime", void 0);
    _defineProperty(this, "animateStatus", false);
    _defineProperty(this, "isDestroyed", false);
    _defineProperty(this, "uniformBuffers", []);
    _defineProperty(this, "encodeDataLength", 0);
    _defineProperty(this, "sourceEvent", () => {
      this.dataState.dataSourceNeedUpdate = true;
      const layerConfig = this.getLayerConfig();
      if (layerConfig && layerConfig.autoFit) {
        this.fitBounds(layerConfig.fitBoundsOptions);
      }
      const autoRender = this.layerSource.getSourceCfg().autoRender;
      if (autoRender) {
        setTimeout(() => {
          this.reRender();
        }, 10);
      }
    });
    this.name = config.name || this.id;
    this.zIndex = config.zIndex || 0;
    this.rawConfig = config;
    this.masks = config.maskLayers || [];
  }
  addMask(layer) {
    this.masks.push(layer);
    this.updateLayerConfig({
      maskLayers: this.masks
    });
    this.enableMask();
  }
  removeMask(layer) {
    const layerIndex = this.masks.indexOf(layer);
    if (layerIndex > -1) {
      this.masks.splice(layerIndex, 1);
    }
    this.updateLayerConfig({
      maskLayers: this.masks
    });
  }
  disableMask() {
    this.updateLayerConfig({
      enableMask: false
    });
  }
  enableMask() {
    this.updateLayerConfig({
      enableMask: true
    });
  }
  /**
   * 将废弃
   * @deprecated
   */
  addMaskLayer(maskLayer) {
    this.masks.push(maskLayer);
  }
  /**
   * 将废弃
   * @deprecated
   */
  removeMaskLayer(maskLayer) {
    const layerIndex = this.masks.indexOf(maskLayer);
    if (layerIndex > -1) {
      this.masks.splice(layerIndex, 1);
    }
    maskLayer.destroy();
  }
  getAttribute(name) {
    return this.styleAttributeService.getLayerStyleAttribute(name);
  }
  getLayerConfig() {
    return this.configService.getLayerConfig(this.id);
  }
  updateLayerConfig(configToUpdate) {
    Object.keys(configToUpdate).map((key) => {
      if (key in this.rawConfig) {
        this.rawConfig[key] = configToUpdate[key];
      }
    });
    if (!this.startInit) {
      this.needUpdateConfig = _objectSpread2(_objectSpread2({}, this.needUpdateConfig), configToUpdate);
    } else {
      const sceneId = this.container.id;
      this.configService.setLayerConfig(sceneId, this.id, _objectSpread2(_objectSpread2(_objectSpread2({}, this.configService.getLayerConfig(this.id)), this.needUpdateConfig), configToUpdate));
      this.needUpdateConfig = {};
    }
  }
  /**
   * 注入图层容器，父容器为场景容器
   * RootContainer 1
   *  -> SceneContainer 1.*
   *   -> LayerContainer 1.*
   */
  setContainer(container) {
    this.container = container;
  }
  getContainer() {
    return this.container;
  }
  addPlugin(plugin) {
    this.plugins.push(plugin);
    return this;
  }
  init() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const sceneId = _this.container.id;
      _this.startInit = true;
      _this.configService.setLayerConfig(sceneId, _this.id, _this.rawConfig);
      _this.layerType = _this.rawConfig.layerType;
      const {
        enableMultiPassRenderer,
        passes
      } = _this.getLayerConfig();
      if (enableMultiPassRenderer && passes !== null && passes !== void 0 && passes.length && passes.length > 0) {
        _this.mapService.on("mapAfterFrameChange", () => {
          _this.renderLayers();
        });
      }
      _this.postProcessingPassFactory = _this.container.postProcessingPassFactory;
      _this.styleAttributeService = _this.container.styleAttributeService;
      if (enableMultiPassRenderer) {
        _this.multiPassRenderer = _this.container.multiPassRenderer;
        _this.multiPassRenderer.setLayer(_this);
      }
      _this.pendingStyleAttributes.forEach(({
        attributeName,
        attributeField,
        attributeValues,
        updateOptions
      }) => {
        _this.styleAttributeService.updateStyleAttribute(
          attributeName,
          {
            // @ts-ignore
            scale: _objectSpread2({
              field: attributeField
            }, _this.splitValuesAndCallbackInAttribute(
              // @ts-ignore
              attributeValues,
              // @ts-ignore
              attributeField ? void 0 : _this.getLayerConfig()[attributeName]
              // 设置了字段不需要设置默认值
            ))
          },
          // @ts-ignore
          updateOptions
        );
      });
      _this.pendingStyleAttributes = [];
      _this.plugins = createPlugins();
      for (const plugin of _this.plugins) {
        plugin.apply(_this, _this.container);
      }
      _this.layerPickService = new BaseLayerPickService(_this);
      _this.textureService = new TextureService(_this);
      _this.log(IDebugLog.LayerInitStart);
      yield _this.hooks.init.promise();
      _this.log(IDebugLog.LayerInitEnd);
      _this.inited = true;
      _this.emit("inited", {
        target: _this,
        type: "inited"
      });
      _this.emit("add", {
        target: _this,
        type: "add"
      });
      _this.hooks.afterInit.call();
    })();
  }
  log(logType, step = "init") {
    var _this$debugService;
    if (this.tileLayer || this.isTileLayer) {
      return;
    }
    const key = `${this.id}.${step}.${logType}`;
    const values = {
      id: this.id,
      type: this.type
    };
    (_this$debugService = this.debugService) === null || _this$debugService === void 0 || _this$debugService.log(key, values);
  }
  updateModelData(data) {
    if (data.attributes && data.elements) {
      this.models.map((m) => {
        m.updateAttributesAndElements(data.attributes, data.elements);
      });
    } else {
      console.warn("data error");
    }
  }
  setLayerPickService(layerPickService) {
    this.layerPickService = layerPickService;
  }
  /**
   * Model初始化前需要更新Model样式
   */
  prepareBuildModel() {
    if (Object.keys(this.needUpdateConfig || {}).length !== 0) {
      this.updateLayerConfig({});
    }
    const {
      animateOption
    } = this.getLayerConfig();
    if (animateOption !== null && animateOption !== void 0 && animateOption.enable) {
      this.layerService.startAnimate();
      this.animateStatus = true;
    }
  }
  color(field, values, updateOptions) {
    this.updateStyleAttribute("color", field, values, updateOptions);
    return this;
  }
  // 为对应的图层传入纹理的编号名称（point/image 在 shape 方法中传入纹理名称的方法并不通用）
  texture(field, values, updateOptions) {
    this.updateStyleAttribute("texture", field, values, updateOptions);
    return this;
  }
  rotate(field, values, updateOptions) {
    this.updateStyleAttribute("rotate", field, values, updateOptions);
    return this;
  }
  size(field, values, updateOptions) {
    this.updateStyleAttribute("size", field, values, updateOptions);
    return this;
  }
  // 对mapping后的数据过滤，scale保持不变
  filter(field, values, updateOptions) {
    const flag = this.updateStyleAttribute("filter", field, values, updateOptions);
    this.dataState.dataSourceNeedUpdate = flag && this.inited;
    return this;
  }
  shape(field, values, updateOptions) {
    this.shapeOption = {
      field,
      values
    };
    const flag = this.updateStyleAttribute("shape", field, values, updateOptions);
    this.dataState.dataSourceNeedUpdate = flag && this.inited;
    return this;
  }
  label(field, values, updateOptions) {
    this.pendingStyleAttributes.push({
      attributeName: "label",
      attributeField: field,
      attributeValues: values,
      updateOptions
    });
    return this;
  }
  animate(options) {
    let rawAnimate = {};
    if (isObject(options)) {
      rawAnimate.enable = true;
      rawAnimate = _objectSpread2(_objectSpread2({}, rawAnimate), options);
    } else {
      rawAnimate.enable = options;
    }
    this.updateLayerConfig({
      animateOption: rawAnimate
    });
    return this;
  }
  source(data, options) {
    if ((data === null || data === void 0 ? void 0 : data.type) === "source") {
      this.setSource(data);
      return this;
    }
    this.sourceOption = {
      data,
      options
    };
    this.clusterZoom = 0;
    return this;
  }
  setData(data, options) {
    if (this.inited) {
      this.dataUpdatelog();
      this.layerSource.setData(data, options);
    } else {
      this.on("inited", () => {
        this.dataUpdatelog();
        this.layerSource.setData(data, options);
      });
    }
    return this;
  }
  dataUpdatelog() {
    this.log(IDebugLog.SourceInitStart, ILayerStage.UPDATE);
    this.layerSource.once("update", () => {
      this.log(IDebugLog.SourceInitEnd, ILayerStage.UPDATE);
    });
  }
  style(options) {
    const {
      passes
    } = options, rest = _objectWithoutProperties(options, _excluded2);
    if (passes) {
      normalizePasses(passes).forEach((pass) => {
        const postProcessingPass = this.multiPassRenderer.getPostProcessor().getPostProcessingPassByName(pass[0]);
        if (postProcessingPass) {
          postProcessingPass.updateOptions(pass[1]);
        }
      });
    }
    if (rest.borderColor) {
      rest.stroke = rest.borderColor;
    }
    if (rest.borderWidth) {
      rest.strokeWidth = rest.borderWidth;
    }
    const newOption = rest;
    Object.keys(rest).forEach((key) => {
      const values = rest[key];
      if (Array.isArray(values) && values.length === 2 && !isNumber4(values[0]) && !isNumber4(values[1])) {
        newOption[key] = {
          field: values[0],
          value: values[1]
        };
      }
    });
    this.encodeStyle(newOption);
    this.updateLayerConfig(newOption);
    return this;
  }
  // 参与数据映射的字段 encodeing
  encodeStyle(options) {
    Object.keys(options).forEach((key) => {
      if (
        // 需要数据映射
        [...this.enableShaderEncodeStyles, ...this.enableDataEncodeStyles].includes(key) && isPlainObject(options[key]) && (options[key].field || options[key].value) && !isEqual(this.encodeStyleAttribute[key], options[key])
      ) {
        this.encodeStyleAttribute[key] = options[key];
        this.updateStyleAttribute(key, options[key].field, options[key].value);
        if (this.inited) {
          this.dataState.dataMappingNeedUpdate = true;
        }
      } else {
        if (this.encodeStyleAttribute[key]) {
          delete this.encodeStyleAttribute[key];
          this.dataState.dataSourceNeedUpdate = true;
        }
      }
    });
  }
  scale(field, cfg) {
    const preOption = _objectSpread2({}, this.scaleOptions);
    if (isObject(field)) {
      this.scaleOptions = _objectSpread2(_objectSpread2({}, this.scaleOptions), field);
    } else {
      this.scaleOptions[field] = cfg;
    }
    if (this.styleAttributeService && !isEqual(preOption, this.scaleOptions)) {
      const scaleOptions = isObject(field) ? field : {
        [field]: cfg
      };
      this.styleAttributeService.updateScaleAttribute(scaleOptions);
    }
    return this;
  }
  /**
   * 渲染所有的图层
   */
  renderLayers() {
    this.rendering = true;
    this.layerService.reRender();
    this.rendering = false;
  }
  prerender() {
  }
  render(options = {}) {
    if (this.tileLayer) {
      this.tileLayer.render();
      return this;
    }
    this.layerService.beforeRenderData(this);
    if (this.encodeDataLength <= 0 && !this.forceRender) {
      return this;
    }
    this.renderModels(options);
    return this;
  }
  /**
   * renderMultiPass 专门用于渲染支持 multipass 的 layer
   */
  renderMultiPass() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      if (_this2.encodeDataLength <= 0 && !_this2.forceRender) {
        return;
      }
      if (_this2.multiPassRenderer && _this2.multiPassRenderer.getRenderFlag()) {
        yield _this2.multiPassRenderer.render();
      } else {
        _this2.renderModels();
      }
    })();
  }
  active(options) {
    const activeOption = {};
    activeOption.enableHighlight = isObject(options) ? true : options;
    if (isObject(options)) {
      activeOption.enableHighlight = true;
      if (options.color) {
        activeOption.highlightColor = options.color;
      }
      if (options.mix) {
        activeOption.activeMix = options.mix;
      }
    } else {
      activeOption.enableHighlight = !!options;
    }
    this.updateLayerConfig(activeOption);
    return this;
  }
  setActive(id, options) {
    if (isObject(id)) {
      const {
        x = 0,
        y = 0
      } = id;
      this.updateLayerConfig({
        highlightColor: isObject(options) ? options.color : this.getLayerConfig().highlightColor,
        activeMix: isObject(options) ? options.mix : this.getLayerConfig().activeMix
      });
      this.pick({
        x,
        y
      });
    } else {
      this.updateLayerConfig({
        pickedFeatureID: id,
        highlightColor: isObject(options) ? options.color : this.getLayerConfig().highlightColor,
        activeMix: isObject(options) ? options.mix : this.getLayerConfig().activeMix
      });
      this.hooks.beforeHighlight.call(encodePickingColor(id)).then(() => {
        setTimeout(() => {
          this.reRender();
        }, 1);
      });
    }
  }
  select(option) {
    const activeOption = {};
    activeOption.enableSelect = isObject(option) ? true : option;
    if (isObject(option)) {
      activeOption.enableSelect = true;
      if (option.color) {
        activeOption.selectColor = option.color;
      }
      if (option.mix) {
        activeOption.selectMix = option.mix;
      }
    } else {
      activeOption.enableSelect = !!option;
    }
    this.updateLayerConfig(activeOption);
    return this;
  }
  setSelect(id, options) {
    if (isObject(id)) {
      const {
        x = 0,
        y = 0
      } = id;
      this.updateLayerConfig({
        selectColor: isObject(options) ? options.color : this.getLayerConfig().selectColor,
        selectMix: isObject(options) ? options.mix : this.getLayerConfig().selectMix
      });
      this.pick({
        x,
        y
      });
    } else {
      this.updateLayerConfig({
        pickedFeatureID: id,
        selectColor: isObject(options) ? options.color : this.getLayerConfig().selectColor,
        selectMix: isObject(options) ? options.mix : this.getLayerConfig().selectMix
      });
      this.hooks.beforeSelect.call(encodePickingColor(id)).then(() => {
        setTimeout(() => {
          this.reRender();
        }, 1);
      });
    }
  }
  setBlend(type) {
    this.updateLayerConfig({
      blend: type
    });
    this.reRender();
    return this;
  }
  show() {
    this.updateLayerConfig({
      visible: true
    });
    this.reRender();
    this.emit("show");
    return this;
  }
  hide() {
    this.updateLayerConfig({
      visible: false
    });
    this.reRender();
    this.emit("hide");
    return this;
  }
  setIndex(index3) {
    this.zIndex = index3;
    this.layerService.updateLayerRenderList();
    this.layerService.renderLayers();
    return this;
  }
  setCurrentPickId(id) {
    this.currentPickId = id;
  }
  getCurrentPickId() {
    return this.currentPickId;
  }
  setCurrentSelectedId(id) {
    this.selectedFeatureID = id;
  }
  getCurrentSelectedId() {
    return this.selectedFeatureID;
  }
  isVisible() {
    const zoom = this.mapService.getZoom();
    const {
      visible,
      minZoom = -Infinity,
      maxZoom = Infinity
    } = this.getLayerConfig();
    return !!visible && zoom >= minZoom && zoom < maxZoom;
  }
  setMultiPass(enableMultiPass, currentPasses) {
    this.updateLayerConfig({
      enableMultiPassRenderer: enableMultiPass
    });
    if (currentPasses) {
      this.updateLayerConfig({
        passes: currentPasses
      });
    }
    if (enableMultiPass) {
      const {
        passes = []
      } = this.getLayerConfig();
      this.multiPassRenderer = createMultiPassRenderer(this, passes, this.postProcessingPassFactory, this.normalPassFactory);
      this.multiPassRenderer.setRenderFlag(true);
      const {
        width,
        height
      } = this.rendererService.getViewportSize();
      this.multiPassRenderer.resize(width, height);
    }
    return this;
  }
  setMinZoom(minZoom) {
    this.updateLayerConfig({
      minZoom
    });
    return this;
  }
  getMinZoom() {
    const {
      minZoom
    } = this.getLayerConfig();
    return minZoom;
  }
  getMaxZoom() {
    const {
      maxZoom
    } = this.getLayerConfig();
    return maxZoom;
  }
  get(name) {
    const cfg = this.getLayerConfig();
    return cfg[name];
  }
  setMaxZoom(maxZoom) {
    this.updateLayerConfig({
      maxZoom
    });
    return this;
  }
  setAutoFit(autoFit) {
    this.updateLayerConfig({
      autoFit
    });
    return this;
  }
  /**
   * zoom to layer Bounds
   */
  fitBounds(fitBoundsOptions) {
    if (!this.inited) {
      this.updateLayerConfig({
        autoFit: true
      });
      return this;
    }
    const source = this.getSource();
    const extent2 = source.extent;
    const isValid = extent2.some((v2) => Math.abs(v2) === Infinity);
    if (isValid) {
      return this;
    }
    this.mapService.fitBounds([[extent2[0], extent2[1]], [extent2[2], extent2[3]]], fitBoundsOptions);
    return this;
  }
  destroy(refresh = true) {
    var _this$layerModel, _this$multiPassRender, _this$layerModel2, _this$tileLayer, _this$debugService2;
    if (this.isDestroyed) {
      return;
    }
    (_this$layerModel = this.layerModel) === null || _this$layerModel === void 0 || _this$layerModel.uniformBuffers.forEach((buffer) => {
      buffer.destroy();
    });
    this.layerChildren.map((child) => child.destroy(false));
    this.layerChildren = [];
    const {
      maskfence
    } = this.getLayerConfig();
    if (maskfence) {
      this.masks.map((mask) => mask.destroy(false));
      this.masks = [];
    }
    this.hooks.beforeDestroy.call();
    this.layerSource.off("update", this.sourceEvent);
    (_this$multiPassRender = this.multiPassRenderer) === null || _this$multiPassRender === void 0 || _this$multiPassRender.destroy();
    this.textureService.destroy();
    this.styleAttributeService.clearAllAttributes();
    this.hooks.afterDestroy.call();
    (_this$layerModel2 = this.layerModel) === null || _this$layerModel2 === void 0 || _this$layerModel2.clearModels(refresh);
    (_this$tileLayer = this.tileLayer) === null || _this$tileLayer === void 0 || _this$tileLayer.destroy();
    this.models = [];
    (_this$debugService2 = this.debugService) === null || _this$debugService2 === void 0 || _this$debugService2.removeLog(this.id);
    this.emit("remove", {
      target: this,
      type: "remove"
    });
    this.emit("destroy", {
      target: this,
      type: "destroy"
    });
    this.removeAllListeners();
    this.isDestroyed = true;
  }
  clear() {
    this.styleAttributeService.clearAllAttributes();
  }
  clearModels() {
    var _this$layerModel3;
    this.models.forEach((model) => model.destroy());
    (_this$layerModel3 = this.layerModel) === null || _this$layerModel3 === void 0 || _this$layerModel3.clearModels();
    this.models = [];
  }
  isDirty() {
    return !!(this.styleAttributeService.getLayerStyleAttributes() || []).filter((attribute) => attribute.needRescale || attribute.needRemapping || attribute.needRegenerateVertices).length;
  }
  // 外部初始化Source
  setSource(source) {
    if (this.layerSource) {
      this.layerSource.off("update", this.sourceEvent);
    }
    this.layerSource = source;
    this.clusterZoom = 0;
    if (this.inited && this.layerSource.cluster) {
      const zoom = this.mapService.getZoom();
      this.layerSource.updateClusterData(zoom);
    }
    if (this.layerSource.inited) {
      this.sourceEvent();
    }
    this.layerSource.on("update", ({
      type
    }) => {
      if (this.coordCenter === void 0) {
        const layerCenter = this.layerSource.center;
        this.coordCenter = layerCenter;
      }
      if (type === "update") {
        if (this.tileLayer) {
          this.tileLayer.reload();
          return;
        }
        this.sourceEvent();
      }
    });
  }
  getSource() {
    return this.layerSource;
  }
  getScaleOptions() {
    return this.scaleOptions;
  }
  setEncodedData(encodedData) {
    this.encodedData = encodedData;
    this.encodeDataLength = encodedData.length;
  }
  getEncodedData() {
    return this.encodedData;
  }
  getScale(name) {
    return this.styleAttributeService.getLayerAttributeScale(name);
  }
  getLegend(name) {
    var _attribute$scale, _scales$, _attribute$scale2;
    const attribute = this.styleAttributeService.getLayerStyleAttribute(name);
    const scales = (attribute === null || attribute === void 0 || (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.scalers) || [];
    return {
      type: (_scales$ = scales[0]) === null || _scales$ === void 0 || (_scales$ = _scales$.option) === null || _scales$ === void 0 ? void 0 : _scales$.type,
      field: attribute === null || attribute === void 0 || (_attribute$scale2 = attribute.scale) === null || _attribute$scale2 === void 0 ? void 0 : _attribute$scale2.field,
      items: this.getLegendItems(name)
    };
  }
  getLegendItems(name) {
    const scale2 = this.styleAttributeService.getLayerAttributeScale(name);
    if (!scale2) {
      return [];
    }
    if (scale2.invertExtent) {
      const items = scale2.range().map((item) => {
        return {
          value: scale2.invertExtent(item),
          [name]: item
        };
      });
      return items;
    } else if (scale2.ticks) {
      const items = scale2.ticks().map((item) => {
        return {
          value: item,
          [name]: scale2(item)
        };
      });
      return items;
    } else if (scale2 !== null && scale2 !== void 0 && scale2.domain) {
      const items = scale2.domain().filter((item) => !isUndefined(item)).map((item) => {
        return {
          value: item,
          [name]: scale2(item)
        };
      });
      return items;
    }
    return [];
  }
  pick({
    x,
    y
  }) {
    this.interactionService.triggerHover({
      x,
      y
    });
  }
  boxSelect(box, cb) {
    this.pickingService.boxPickLayer(this, box, cb);
  }
  buildLayerModel(options) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      const {
        moduleName,
        vertexShader,
        fragmentShader,
        defines,
        inject,
        triangulation,
        styleOption,
        pickingEnabled = true
      } = options, rest = _objectWithoutProperties(options, _excluded22);
      _this3.shaderModuleService.registerModule(moduleName, {
        vs: vertexShader,
        fs: fragmentShader,
        defines,
        inject
      });
      const {
        vs,
        fs,
        uniforms
      } = _this3.shaderModuleService.getModule(moduleName);
      const {
        createModel
      } = _this3.rendererService;
      return new Promise((resolve) => {
        const {
          attributes,
          elements,
          count: count2
        } = _this3.styleAttributeService.createAttributesAndIndices(_this3.encodedData, triangulation, styleOption, _this3);
        const uniformBuffers = [..._this3.layerModel.uniformBuffers, ..._this3.rendererService.uniformBuffers];
        if (pickingEnabled) {
          uniformBuffers.push(_this3.getPickingUniformBuffer());
        }
        const modelOptions = _objectSpread2({
          attributes,
          uniforms,
          fs,
          vs,
          elements,
          blend: BlendTypes[BlendType.normal],
          uniformBuffers,
          textures: _this3.layerModel.textures
        }, rest);
        if (count2) {
          modelOptions.count = count2;
        }
        const m = createModel(modelOptions);
        resolve(m);
      });
    })();
  }
  createAttributes(options) {
    const {
      triangulation
    } = options;
    const {
      attributes
    } = this.styleAttributeService.createAttributes(this.encodedData, triangulation);
    return attributes;
  }
  getTime() {
    return this.layerService.clock.getDelta();
  }
  setAnimateStartTime() {
    this.animateStartTime = this.layerService.clock.getElapsedTime();
  }
  stopAnimate() {
    if (this.animateStatus) {
      this.layerService.stopAnimate();
      this.animateStatus = false;
      this.updateLayerConfig({
        animateOption: {
          enable: false
        }
      });
    }
  }
  getLayerAnimateTime() {
    return this.layerService.clock.getElapsedTime() - this.animateStartTime;
  }
  needPick(type) {
    const {
      enableHighlight = true,
      enableSelect = true
    } = this.getLayerConfig();
    let isPick = this.eventNames().indexOf(type) !== -1 || this.eventNames().indexOf("un" + type) !== -1;
    if ((type === "click" || type === "dblclick") && enableSelect) {
      isPick = true;
    }
    if (type === "mousemove" && (enableHighlight || this.eventNames().indexOf("mouseenter") !== -1 || this.eventNames().indexOf("unmousemove") !== -1 || this.eventNames().indexOf("mouseout") !== -1)) {
      isPick = true;
    }
    return this.isVisible() && isPick;
  }
  buildModels() {
    return _asyncToGenerator(function* () {
      throw new Error("Method not implemented.");
    })();
  }
  rebuildModels() {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      yield _this4.buildModels();
    })();
  }
  renderMulPass(multiPassRenderer) {
    return _asyncToGenerator(function* () {
      yield multiPassRenderer.render();
    })();
  }
  renderModels(options = {}) {
    if (this.encodeDataLength <= 0 && !this.forceRender) {
      this.clearModels();
      return this;
    }
    this.hooks.beforeRender.call();
    this.models.forEach((model) => {
      model.draw({
        uniforms: this.layerModel.getUninforms(),
        blend: this.layerModel.getBlend(),
        stencil: this.layerModel.getStencil(options),
        textures: this.layerModel.textures
      }, (options === null || options === void 0 ? void 0 : options.ispick) || false);
    });
    this.hooks.afterRender.call();
    return this;
  }
  updateStyleAttribute(type, field, values, updateOptions) {
    const preAttribute = this.configService.getAttributeConfig(this.id) || {};
    if (isEqual(preAttribute[type], {
      field,
      values
    })) {
      return false;
    }
    if (["color", "size", "texture", "rotate", "filter", "label", "shape"].indexOf(type) !== -1) {
      this.configService.setAttributeConfig(this.id, {
        [type]: {
          field,
          values
        }
      });
    }
    if (!this.startInit) {
      this.pendingStyleAttributes.push({
        attributeName: type,
        attributeField: field,
        attributeValues: values,
        updateOptions
      });
    } else {
      this.styleAttributeService.updateStyleAttribute(
        type,
        {
          // @ts-ignore
          scale: _objectSpread2({
            field
          }, this.splitValuesAndCallbackInAttribute(
            // @ts-ignore
            values,
            // @ts-ignore
            this.getLayerConfig()[field]
          ))
        },
        // @ts-ignore
        updateOptions
      );
    }
    return true;
  }
  getLayerAttributeConfig() {
    return this.configService.getAttributeConfig(this.id);
  }
  getShaderPickStat() {
    return this.layerService.getShaderPickStat();
  }
  /**
   * 继承空方法
   * @param time
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setEarthTime(time) {
    console.warn("empty fn");
  }
  // 数据处理 在数据进行 mapping 生成 encodeData 之前对数据进行处理
  // 在各个 layer 中继承
  processData(filterData) {
    return filterData;
  }
  getModelType() {
    throw new Error("Method not implemented.");
  }
  getDefaultConfig() {
    return {};
  }
  initLayerModels() {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      _this5.models.forEach((model) => model.destroy());
      _this5.models = [];
      _this5.uniformBuffers.forEach((buffer) => {
        buffer.destroy();
      });
      _this5.uniformBuffers = [];
      const pickingUniforms = _this5.rendererService.createBuffer({
        data: new Float32Array(20).fill(0),
        isUBO: true,
        label: "pickingUniforms"
      });
      _this5.uniformBuffers.push(pickingUniforms);
      _this5.models = yield _this5.layerModel.initModels();
    })();
  }
  getPickingUniformBuffer() {
    return this.uniformBuffers[0];
  }
  reRender() {
    if (this.inited) {
      this.layerService.reRender();
    }
  }
  splitValuesAndCallbackInAttribute(valuesOrCallback) {
    return {
      values: isFunction2(valuesOrCallback) ? void 0 : valuesOrCallback,
      callback: isFunction2(valuesOrCallback) ? valuesOrCallback : void 0
    };
  }
};

// node_modules/@antv/l7-layers/es/utils/stencil.js
function getStencil(mask, maskInside) {
  return {
    enable: mask,
    mask: 255,
    func: {
      cmp: gl.EQUAL,
      // gl.EQUAL,
      ref: maskInside ? 1 : 0,
      mask: 1
    }
  };
}
function getStencilMask(option) {
  if (option.maskOperation === MaskOperation.OR) {
    return {
      enable: true,
      mask: 255,
      func: {
        cmp: gl.ALWAYS,
        ref: 1,
        mask: 255
      },
      opFront: {
        fail: gl.KEEP,
        zfail: gl.REPLACE,
        zpass: gl.REPLACE
      }
    };
  }
  return {
    enable: true,
    mask: 255,
    func: {
      cmp: option.stencilType === StencilType.SINGLE ? gl.ALWAYS : option.stencilIndex === 0 ? gl.ALWAYS : gl.LESS,
      ref: option.stencilType === StencilType.SINGLE ? 1 : option.stencilIndex === 0 ? 2 : 1,
      mask: 255
    },
    opFront: {
      fail: gl.KEEP,
      zfail: gl.REPLACE,
      zpass: gl.REPLACE
    }
  };
}

// node_modules/@antv/l7-layers/es/core/constant.js
var DefaultUniformStyleValue = {
  opacity: 1,
  stroke: [1, 0, 0, 1],
  offsets: [0, 0],
  rotation: 0,
  extrusionBase: 0,
  strokeOpacity: 1,
  thetaOffset: 0.314
};
var DefaultUniformStyleType = {
  opacity: "float",
  stroke: "vec4",
  offsets: "vec2",
  textOffset: "vec2",
  rotation: "float",
  extrusionBase: "float",
  strokeOpacity: "float",
  thetaOffset: "float"
};

// node_modules/@antv/l7-layers/es/core/utils.js
var import_earcut = __toESM(require_earcut());
function MultipleOfFourNumber(num) {
  return Math.max(Math.ceil(num / 4) * 4, 4);
}
function getPolygonSurfaceIndices(positions, holeIndices, positionSize, preproject = true) {
  const is3d = positionSize === 3;
  if (preproject) {
    positions = positions.slice();
    const p = [];
    for (let i = 0; i < positions.length; i += positionSize) {
      p[0] = positions[i];
      p[1] = positions[i + 1];
      if (is3d) {
        p[2] = positions[i + 2];
      }
      const xy = lngLatToMeters(p, true, {
        enable: false,
        decimal: 1
      });
      positions[i] = xy[0];
      positions[i + 1] = xy[1];
      if (is3d) {
        positions[i + 2] = xy[2];
      }
    }
  }
  const indices = (0, import_earcut.default)(positions, holeIndices, positionSize);
  return indices;
}

// node_modules/@antv/l7-layers/es/core/BaseModel.js
var DEFINE_ATTRIBUTE_LOCATION_PREFIX = "ATTRIBUTE_LOCATION_";
var BaseModel = class {
  /**
   * Attribute Layout Location in Shader
   */
  get attributeLocation() {
    return _objectSpread2({}, COMMON_ATTRIBUTE_LOCATION);
  }
  // style texture data mapping
  // 不支持数据映射的buffer
  // style texture data mapping
  constructor(layer) {
    _defineProperty(this, "triangulation", void 0);
    _defineProperty(this, "uniformBuffers", []);
    _defineProperty(this, "textures", []);
    _defineProperty(this, "createTexture2D", void 0);
    _defineProperty(this, "preStyleAttribute", {});
    _defineProperty(this, "encodeStyleAttribute", {});
    _defineProperty(this, "layer", void 0);
    _defineProperty(this, "dataTexture", void 0);
    _defineProperty(this, "DATA_TEXTURE_WIDTH", void 0);
    _defineProperty(this, "dataTextureTest", void 0);
    _defineProperty(this, "configService", void 0);
    _defineProperty(this, "shaderModuleService", void 0);
    _defineProperty(this, "rendererService", void 0);
    _defineProperty(this, "iconService", void 0);
    _defineProperty(this, "fontService", void 0);
    _defineProperty(this, "styleAttributeService", void 0);
    _defineProperty(this, "mapService", void 0);
    _defineProperty(this, "cameraService", void 0);
    _defineProperty(this, "layerService", void 0);
    _defineProperty(this, "pickingService", void 0);
    _defineProperty(this, "attributeUnifoms", void 0);
    _defineProperty(this, "commonUnifoms", void 0);
    this.layer = layer;
    this.configService = layer.getContainer().globalConfigService;
    this.rendererService = layer.getContainer().rendererService;
    this.pickingService = layer.getContainer().pickingService;
    this.shaderModuleService = layer.getContainer().shaderModuleService;
    this.styleAttributeService = layer.getContainer().styleAttributeService;
    this.mapService = layer.getContainer().mapService;
    this.iconService = layer.getContainer().iconService;
    this.fontService = layer.getContainer().fontService;
    this.cameraService = layer.getContainer().cameraService;
    this.layerService = layer.getContainer().layerService;
    this.registerStyleAttribute();
    this.registerBuiltinAttributes();
    this.startModelAnimate();
    const {
      createTexture2D
    } = this.rendererService;
    this.createTexture2D = createTexture2D;
  }
  // style datatexture mapping
  getBlend() {
    const {
      blend = "normal"
    } = this.layer.getLayerConfig();
    return BlendTypes[BlendType[blend]];
  }
  getStencil(option) {
    const {
      mask = false,
      maskInside = true,
      enableMask,
      maskOperation = MaskOperation.AND
    } = this.layer.getLayerConfig();
    if (this.layer.type === "MaskLayer") {
      return getStencilMask({
        isStencil: true,
        stencilType: StencilType.SINGLE
      });
    }
    if (option.isStencil) {
      return getStencilMask(_objectSpread2(_objectSpread2({}, option), {}, {
        maskOperation
      }));
    }
    const maskflag = mask || //  mask 兼容历史写法
    enableMask && this.layer.masks.length !== 0 || // 外部图层的mask
    this.layer.tileMask !== void 0;
    return getStencil(maskflag, maskInside);
  }
  getDefaultStyle() {
    return {};
  }
  // public getUninforms(): IModelUniform {
  //   throw new Error('Method not implemented.');
  // }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    const result = _objectSpread2(_objectSpread2({}, attributeInfo.uniformsOption), commoninfo.uniformsOption);
    Object.keys(result).forEach((key) => {
      if (typeof result[key] === "boolean") {
        result[key] = result[key] ? 1 : 0;
      }
    });
    if (!this.rendererService.hasOwnProperty("device") && this.textures && this.textures.length === 1) {
      result["u_texture"] = this.textures[0];
    }
    return result;
  }
  getAnimateUniforms() {
    return {};
  }
  needUpdate() {
    return _asyncToGenerator(function* () {
      return false;
    })();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  buildModels() {
    return _asyncToGenerator(function* () {
      throw new Error("Method not implemented.");
    })();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  initModels() {
    return _asyncToGenerator(function* () {
      throw new Error("Method not implemented.");
    })();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  clearModels(refresh = true) {
    return;
  }
  getAttribute() {
    throw new Error("Method not implemented.");
  }
  prerender() {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(renderOptions) {
    throw new Error("Method not implemented.");
  }
  registerBuiltinAttributes() {
    throw new Error("Method not implemented.");
  }
  animateOption2Array(option) {
    return [option.enable ? 0 : 1, option.duration || 4, option.interval || 0.2, option.trailLength || 0.1];
  }
  startModelAnimate() {
    const {
      animateOption
    } = this.layer.getLayerConfig();
    if (animateOption.enable) {
      this.layer.setAnimateStartTime();
    }
  }
  getInject() {
    const shaderInject = getDynamicStyleInject(this.layer.enableShaderEncodeStyles, this.layer.encodeStyleAttribute);
    return shaderInject;
  }
  getDefines() {
    const atributeLocationDefines = Object.keys(this.attributeLocation).reduce((result, key) => {
      const normalizedKey = DEFINE_ATTRIBUTE_LOCATION_PREFIX + key;
      result[normalizedKey] = this.attributeLocation[key];
      return result;
    }, {});
    return _objectSpread2({}, atributeLocationDefines);
  }
  // 获取数据映射样式
  getStyleAttribute() {
    const options = {};
    this.layer.enableShaderEncodeStyles.forEach((key) => {
      if (!this.layer.encodeStyleAttribute[key]) {
        const keyValue = this.layer.getLayerConfig()[key];
        let value = typeof keyValue === "undefined" ? DefaultUniformStyleValue[key] : keyValue;
        if (key === "stroke") {
          value = rgb2arr(value);
        }
        options["u_" + key] = value;
      }
    });
    return options;
  }
  // 注册数据映射样式
  registerStyleAttribute() {
    Object.keys(this.layer.encodeStyleAttribute).forEach((key) => {
      const options = getCommonStyleAttributeOptions(key);
      if (options) {
        this.styleAttributeService.registerStyleAttribute(options);
      }
    });
  }
  /**
   * 注册 Position 属性 64 位地位部分，当经纬度数据开启双精度浮点数使用，
   * 避免大于 20层级以上出现数据偏移
   */
  registerPosition64LowAttribute(enable64bitPosition = true) {
    this.styleAttributeService.registerStyleAttribute({
      name: "position64Low",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Position64Low",
        shaderLocation: this.attributeLocation.POSITION_64LOW,
        buffer: {
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return enable64bitPosition ? [fp64LowPart(vertex[0]), fp64LowPart(vertex[1])] : [0, 0];
        }
      }
    });
  }
  updateEncodeAttribute(type, flag) {
    this.encodeStyleAttribute[type] = flag;
  }
  initUniformsBuffer() {
    const attrUniforms = this.getUniformsBufferInfo(this.getStyleAttribute());
    const commonUniforms = this.getCommonUniformsInfo();
    if (attrUniforms.uniformsLength !== 0) {
      this.attributeUnifoms = this.rendererService.createBuffer({
        data: new Float32Array(MultipleOfFourNumber(attrUniforms.uniformsLength)).fill(0),
        // 长度需要大于等于 4
        isUBO: true,
        label: "layerModelAttributeUnifoms"
      });
      this.uniformBuffers.push(this.attributeUnifoms);
    }
    if (commonUniforms.uniformsLength !== 0) {
      this.commonUnifoms = this.rendererService.createBuffer({
        data: new Float32Array(MultipleOfFourNumber(commonUniforms.uniformsLength)).fill(0),
        isUBO: true,
        label: "layerModelCommonUnifoms"
      });
      this.uniformBuffers.push(this.commonUnifoms);
    }
  }
  // 获取数据映射 uniform 信息
  getUniformsBufferInfo(uniformsOption) {
    let uniformsLength = 0;
    const uniformsArray = [];
    Object.values(uniformsOption).forEach((value) => {
      if (Array.isArray(value)) {
        uniformsArray.push(...value);
        uniformsLength += value.length;
      } else if (typeof value === "number") {
        uniformsArray.push(value);
        uniformsLength += 1;
      } else if (typeof value === "boolean") {
        uniformsArray.push(Number(value));
        uniformsLength += 1;
      }
    });
    return {
      uniformsOption,
      uniformsLength,
      uniformsArray
    };
  }
  getCommonUniformsInfo() {
    return {
      uniformsLength: 0,
      uniformsArray: [],
      uniformsOption: {}
    };
  }
  // 更新支持数据映射的uniform
  updateStyleUnifoms() {
    var _this$attributeUnifom, _this$commonUnifoms;
    const {
      uniformsArray
    } = this.getUniformsBufferInfo(this.getStyleAttribute());
    const {
      uniformsArray: commonUniformsArray
    } = this.getCommonUniformsInfo();
    (_this$attributeUnifom = this.attributeUnifoms) === null || _this$attributeUnifom === void 0 || _this$attributeUnifom.subData({
      offset: 0,
      data: new Uint8Array(new Float32Array(uniformsArray).buffer)
    });
    (_this$commonUnifoms = this.commonUnifoms) === null || _this$commonUnifoms === void 0 || _this$commonUnifoms.subData({
      offset: 0,
      data: new Uint8Array(new Float32Array(commonUniformsArray).buffer)
    });
  }
};
function getDynamicStyleInject(shaderEncodeStyles, styleAttribute) {
  const uniforms = [];
  let vsDeclInjection = "";
  shaderEncodeStyles.forEach((key) => {
    const upperCaseKey = key.replace(/([a-z])([A-Z])/g, "$1_$2").toUpperCase();
    const shaderDefineName = DEFINE_ATTRIBUTE_LOCATION_PREFIX + upperCaseKey;
    if (styleAttribute[key]) {
      vsDeclInjection += `#define USE_ATTRIBUTE_${upperCaseKey} 0.0 
`;
    } else {
      uniforms.push(`  ${DefaultUniformStyleType[key]} u_${key};`);
    }
    vsDeclInjection += `
#ifdef USE_ATTRIBUTE_${upperCaseKey}
layout(location = ${shaderDefineName}) in ${DefaultUniformStyleType[key]} a_${key.charAt(0).toUpperCase() + key.slice(1)};
#endif 
`;
  });
  const fsDeclInjection = uniforms.length ? `
layout(std140) uniform AttributeUniforms {
  ${uniforms.join("\n")}
};
` : "";
  vsDeclInjection += fsDeclInjection;
  let vsMainInjection = "";
  shaderEncodeStyles.forEach((key) => {
    const upperCaseKey = key.replace(/([a-z])([A-Z])/g, "$1_$2").toUpperCase();
    vsMainInjection += `
  #ifdef USE_ATTRIBUTE_${upperCaseKey}
    ${DefaultUniformStyleType[key]} ${key} = a_${key.charAt(0).toUpperCase() + key.slice(1)};
  #else
    ${DefaultUniformStyleType[key]} ${key} = u_${key};
  #endif
  `;
  });
  return {
    "vs:#decl": vsDeclInjection,
    "fs:#decl": fsDeclInjection,
    "vs:#main-start": vsMainInjection
  };
}

// node_modules/@antv/l7-layers/es/core/interface.js
var lineStyleType = function(lineStyleType2) {
  lineStyleType2[lineStyleType2["solid"] = 0] = "solid";
  lineStyleType2[lineStyleType2["dash"] = 1] = "dash";
  return lineStyleType2;
}({});
var LinearDir = function(LinearDir2) {
  LinearDir2["VERTICAL"] = "vertical";
  LinearDir2["HORIZONTAL"] = "horizontal";
  return LinearDir2;
}({});
var TextureBlend = function(TextureBlend2) {
  TextureBlend2["NORMAL"] = "normal";
  TextureBlend2["REPLACE"] = "replace";
  return TextureBlend2;
}({});
var SizeUnitType = function(SizeUnitType2) {
  SizeUnitType2[SizeUnitType2["pixel"] = 0] = "pixel";
  SizeUnitType2[SizeUnitType2["meter"] = 1] = "meter";
  return SizeUnitType2;
}({});
var CanvasUpdateType = function(CanvasUpdateType2) {
  CanvasUpdateType2["ALWAYS"] = "always";
  CanvasUpdateType2["DRAGEND"] = "dragend";
  return CanvasUpdateType2;
}({});

// node_modules/@antv/l7-layers/es/canvas/models/constants.js
var CanvasContextTypeMap = {
  canvas2d: "2d",
  webgl: "webgl",
  webgl2: "webgl2",
  webgpu: "webgpu"
};

// node_modules/@antv/l7-layers/es/canvas/models/canvas.js
var CanvasModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "canvas", null);
    _defineProperty(this, "ctx", void 0);
    _defineProperty(this, "ctxType", void 0);
    _defineProperty(this, "viewportSize", void 0);
    _defineProperty(this, "initCanvas", () => {
      var _this$mapService$getC, _this$mapService$getC2, _this$mapService, _this$mapService$getM, _this$mapService2;
      const {
        zIndex,
        getContext
      } = this.layerConfig;
      const canvas = document.createElement("canvas");
      const modelType = this.layer.getModelType();
      this.canvas = canvas;
      canvas.classList.add("l7-canvas-layer");
      canvas.style.position = "absolute";
      canvas.style.top = "0";
      canvas.style.left = "0";
      canvas.style.zIndex = String(zIndex);
      this.resetCanvasSize();
      const container = (_this$mapService$getC = (_this$mapService$getC2 = (_this$mapService = this.mapService).getCanvasOverlays) === null || _this$mapService$getC2 === void 0 ? void 0 : _this$mapService$getC2.call(_this$mapService)) !== null && _this$mapService$getC !== void 0 ? _this$mapService$getC : (_this$mapService$getM = (_this$mapService2 = this.mapService).getMapCanvasContainer) === null || _this$mapService$getM === void 0 ? void 0 : _this$mapService$getM.call(_this$mapService2);
      container === null || container === void 0 || container.appendChild(canvas);
      this.ctx = getContext ? getContext(canvas) : canvas.getContext(CanvasContextTypeMap[modelType]);
      if (!this.ctx) {
        console.error("Failed to get rendering context for canvas");
      }
      this.bindListeners();
    });
    _defineProperty(this, "resetViewportSize", () => {
      const {
        width: viewWidth,
        height: viewHeight
      } = this.rendererService.getViewportSize();
      this.viewportSize = [viewWidth, viewHeight];
    });
    _defineProperty(this, "resetCanvasSize", () => {
      const canvas = this.canvas;
      if (!canvas) {
        return;
      }
      this.resetViewportSize();
      const [width, height] = this.mapService.getSize();
      const [viewWidth, viewHeight] = this.viewportSize;
      canvas.width = viewWidth;
      canvas.height = viewHeight;
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
    });
    _defineProperty(this, "renderCanvas", () => {
      var _ref;
      if (!this.canvas) {
        this.initCanvas();
      }
      const {
        draw,
        drawingOnCanvas
      } = this.layerConfig;
      const [width, height] = this.viewportSize;
      const bounds = this.mapService.getBounds();
      (_ref = draw !== null && draw !== void 0 ? draw : drawingOnCanvas) === null || _ref === void 0 || _ref({
        canvas: this.canvas,
        ctx: this.ctx,
        container: {
          width,
          height,
          bounds
        },
        size: [width, height],
        utils: {
          lngLatToContainer: this.lngLatToContainer
        },
        mapService: this.mapService
      });
    });
    _defineProperty(this, "removeCanvas", () => {
      if (this.canvas) {
        var _this$canvas$parentEl;
        (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 || _this$canvas$parentEl.removeChild(this.canvas);
        this.canvas = null;
      }
      this.unbindListeners();
    });
    _defineProperty(this, "onMapResize", () => {
      requestAnimationFrame(() => {
        this.resetCanvasSize();
        this.renderCanvas();
      });
    });
    _defineProperty(this, "lngLatToContainer", (lngLat) => {
      const {
        x,
        y
      } = this.mapService.lngLatToContainer(lngLat);
      return {
        x: x * window.devicePixelRatio,
        y: y * window.devicePixelRatio
      };
    });
  }
  get layerConfig() {
    return this.layer.getLayerConfig();
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.renderCanvas();
      return [];
    })();
  }
  bindListeners() {
    this.mapService.on("resize", this.onMapResize);
    const {
      trigger,
      update
    } = this.layerConfig;
    if (update === CanvasUpdateType.ALWAYS || trigger === "change") {
      this.mapService.on("mapchange", this.renderCanvas);
    } else {
      this.mapService.on("zoomstart", this.removeCanvas);
      this.mapService.on("zoomend", this.renderCanvas);
      this.mapService.on("movestart", this.removeCanvas);
      this.mapService.on("moveend", this.renderCanvas);
    }
  }
  unbindListeners() {
    this.mapService.off("resize", this.onMapResize);
    this.mapService.off("mapchange", this.renderCanvas);
    this.mapService.off("zoomstart", this.removeCanvas);
    this.mapService.off("zoomend", this.renderCanvas);
    this.mapService.off("movestart", this.removeCanvas);
    this.mapService.off("moveend", this.renderCanvas);
  }
  registerBuiltinAttributes() {
  }
};

// node_modules/@antv/l7-layers/es/canvas/index.js
var CanvasLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "CanvasLayer");
  }
  getDefaultConfig() {
    return {
      zIndex: 3,
      contextType: "canvas2d",
      trigger: "change"
    };
  }
  buildModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.layerModel = new CanvasModel(_this);
      yield _this.initLayerModels();
    })();
  }
  getModelType() {
    return this.getLayerConfig().contextType || "canvas2d";
  }
  draw(draw) {
    this.updateLayerConfig({
      draw
    });
    this.render();
    return this;
  }
  getLayerConfig() {
    const config = _objectSpread2(_objectSpread2({}, this.getDefaultConfig()), super.getLayerConfig());
    if (config.zIndex < 3) {
      config.zIndex = 3;
    }
    return config;
  }
  render() {
    var _this$layerModel;
    (_this$layerModel = this.layerModel) === null || _this$layerModel === void 0 || _this$layerModel.renderCanvas();
    return this;
  }
  getCanvas() {
    var _this$layerModel2;
    return (_this$layerModel2 = this.layerModel) === null || _this$layerModel2 === void 0 ? void 0 : _this$layerModel2.canvas;
  }
  show() {
    const canvas = this.getCanvas();
    if (canvas) {
      canvas.style.display = "unset";
    }
    return this;
  }
  hide() {
    const canvas = this.getCanvas();
    if (canvas) {
      canvas.style.display = "none";
    }
    return this;
  }
  destroy() {
    this.layerModel.removeCanvas();
    super.destroy();
  }
};

// node_modules/@antv/l7-layers/es/core/triangulation.js
var import_earcut3 = __toESM(require_earcut());

// node_modules/@antv/l7-layers/es/earth/utils.js
var EARTH_RADIUS = 100;
var EARTH_SEGMENTS = 36;
var EARTH_RADIUS_OUTER = 40;
function torad(deg) {
  return deg / 180 * Math.acos(-1);
}
function lglt2xyz(lnglat) {
  const lng = torad(lnglat[0]) + Math.PI / 2;
  const lat = torad(lnglat[1]);
  const radius = EARTH_RADIUS + Math.random() * 0.4;
  const z = radius * Math.cos(lat) * Math.cos(lng);
  const x = radius * Math.cos(lat) * Math.sin(lng);
  const y = radius * Math.sin(lat);
  return [x, y, z];
}
function primitiveSphere(radius, opt) {
  const matRotY = mat4_exports.create();
  const matRotZ = mat4_exports.create();
  const up = vec3_exports.fromValues(0, 1, 0);
  const tmpVec3 = vec3_exports.fromValues(0, 0, 0);
  opt = opt || {};
  radius = typeof radius !== "undefined" ? radius : 1;
  const segments = typeof opt.segments !== "undefined" ? opt.segments : 32;
  const totalZRotationSteps = 2 + segments;
  const totalYRotationSteps = 2 * totalZRotationSteps;
  const indices = [];
  const indicesArr = [];
  const positions = [];
  const positionsArr = [];
  const normalArr = [];
  const uvs = [];
  for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {
    const normalizedZ = zRotationStep / totalZRotationSteps;
    const angleZ = normalizedZ * Math.PI;
    for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {
      const normalizedY = yRotationStep / totalYRotationSteps;
      const angleY = normalizedY * Math.PI * 2;
      mat4_exports.identity(matRotZ);
      mat4_exports.rotateZ(matRotZ, matRotZ, -angleZ);
      mat4_exports.identity(matRotY);
      mat4_exports.rotateY(matRotY, matRotY, angleY);
      vec3_exports.transformMat4(tmpVec3, up, matRotZ);
      vec3_exports.transformMat4(tmpVec3, tmpVec3, matRotY);
      vec3_exports.scale(tmpVec3, tmpVec3, -radius);
      positions.push(tmpVec3.slice());
      positionsArr.push(...tmpVec3.slice());
      vec3_exports.normalize(tmpVec3, tmpVec3);
      normalArr.push(...tmpVec3.slice());
      uvs.push([normalizedY, 1 - normalizedZ]);
      positionsArr.push(normalizedY, 1 - normalizedZ);
    }
    if (zRotationStep > 0) {
      const verticesCount = positions.length;
      let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1);
      for (; firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {
        indices.push([firstIndex, firstIndex + 1, firstIndex + totalYRotationSteps + 1]);
        indicesArr.push(firstIndex, firstIndex + 1, firstIndex + totalYRotationSteps + 1);
        indices.push([firstIndex + totalYRotationSteps + 1, firstIndex + 1, firstIndex + totalYRotationSteps + 2]);
        indicesArr.push(firstIndex + totalYRotationSteps + 1, firstIndex + 1, firstIndex + totalYRotationSteps + 2);
      }
    }
  }
  return {
    cells: indices,
    positions,
    uvs,
    positionsArr,
    indicesArr,
    normalArr
  };
}

// node_modules/@antv/l7-layers/es/utils/extrude_polyline.js
var tmp = vec2_exports.create();
var capEnd = vec2_exports.create();
var lineA = vec2_exports.create();
var lineB = vec2_exports.create();
var tangent = vec2_exports.create();
function computeMiter(lineTangent, miter, start, end, halfThick) {
  vec2_exports.add(lineTangent, start, end);
  vec2_exports.normalize(lineTangent, lineTangent);
  miter = vec2_exports.fromValues(-lineTangent[1], lineTangent[0]);
  const tmpvec = vec2_exports.fromValues(-start[1], start[0]);
  return [halfThick / vec2_exports.dot(miter, tmpvec), miter];
}
function computeNormal(out, dir) {
  return vec2_exports.set(out, -dir[1], dir[0]);
}
function direction(out, a, b) {
  vec2_exports.sub(out, a, b);
  vec2_exports.normalize(out, out);
  return out;
}
function isPointEqual(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
var ExtrudePolyline = class {
  constructor(opts = {}) {
    _defineProperty(this, "complex", void 0);
    _defineProperty(this, "join", void 0);
    _defineProperty(this, "cap", void 0);
    _defineProperty(this, "miterLimit", void 0);
    _defineProperty(this, "thickness", void 0);
    _defineProperty(this, "normal", void 0);
    _defineProperty(this, "lastFlip", -1);
    _defineProperty(this, "miter", vec2_exports.fromValues(0, 0));
    _defineProperty(this, "started", false);
    _defineProperty(this, "dash", false);
    _defineProperty(this, "totalDistance", 0);
    _defineProperty(this, "currentIndex", 0);
    this.join = opts.join || "miter";
    this.cap = opts.cap || "butt";
    this.miterLimit = opts.miterLimit || 10;
    this.thickness = opts.thickness || 1;
    this.dash = opts.dash || false;
    this.complex = {
      positions: [],
      indices: [],
      normals: [],
      startIndex: 0,
      indexes: []
    };
  }
  simpleExtrude(points) {
    const complex = this.complex;
    if (points.length <= 1) {
      return complex;
    }
    this.lastFlip = -1;
    this.started = false;
    this.normal = null;
    this.totalDistance = 0;
    const total = points.length;
    let count2 = complex.startIndex;
    for (let i = 1; i < total; i++) {
      const last2 = points[i - 1];
      const cur = points[i];
      const next = i < points.length - 1 ? points[i + 1] : null;
      const amt = this.simpleSegment(complex, count2, last2, cur, next);
      count2 += amt;
    }
    if (this.dash) {
      for (let i = 0; i < complex.positions.length / 6; i++) {
        complex.positions[i * 6 + 5] = this.totalDistance;
      }
    }
    complex.startIndex = complex.positions.length / 6;
    return complex;
  }
  extrude(points) {
    const complex = this.complex;
    if (points.length <= 1) {
      return complex;
    }
    this.lastFlip = -1;
    this.started = false;
    this.normal = null;
    this.totalDistance = 0;
    const total = points.length;
    let count2 = complex.startIndex;
    for (let i = 1; i < total; i++) {
      const last2 = points[i - 1];
      const cur = points[i];
      const next = i < points.length - 1 ? points[i + 1] : null;
      const amt = this.segment(complex, count2, last2, cur, next);
      count2 += amt;
    }
    if (this.dash) {
      for (let i = 0; i < complex.positions.length / 6; i++) {
        complex.positions[i * 6 + 5] = this.totalDistance;
      }
    }
    complex.startIndex = complex.positions.length / 6;
    return complex;
  }
  simpleSegment(complex, index3, last2, cur, next) {
    let count2 = 0;
    const indices = complex.indices;
    const positions = complex.positions;
    const normals = complex.normals;
    const flatCur = aProjectFlat([cur[0], cur[1]]);
    const flatLast = aProjectFlat([last2[0], last2[1]]);
    direction(lineA, flatCur, flatLast);
    let segmentDistance = 0;
    if (this.dash) {
      segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
      this.totalDistance += segmentDistance;
    }
    if (!this.normal) {
      this.normal = vec2_exports.create();
      computeNormal(this.normal, lineA);
    }
    if (!this.started) {
      this.started = true;
      this.extrusions(positions, normals, last2, this.normal, this.thickness, this.totalDistance - segmentDistance);
    }
    indices.push(index3 + 0, index3 + 1, index3 + 2);
    if (!next) {
      computeNormal(this.normal, lineA);
      this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);
      indices.push(...this.lastFlip === 1 ? [index3, index3 + 2, index3 + 3] : [index3 + 2, index3 + 1, index3 + 3]);
      count2 += 2;
    } else {
      const flatNext = aProjectFlat([next[0], next[1]]);
      if (isPointEqual(flatCur, flatNext)) {
        vec2_exports.add(flatNext, flatCur, vec2_exports.normalize(flatNext, vec2_exports.subtract(flatNext, flatCur, flatLast)));
      }
      direction(lineB, flatNext, flatCur);
      const [miterLen, miter] = computeMiter(tangent, vec2_exports.create(), lineA, lineB, this.thickness);
      let flip = vec2_exports.dot(tangent, this.normal) < 0 ? -1 : 1;
      this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);
      indices.push(...this.lastFlip === 1 ? [index3, index3 + 2, index3 + 3] : [index3 + 2, index3 + 1, index3 + 3]);
      flip = -1;
      vec2_exports.copy(this.normal, miter);
      count2 += 2;
      this.lastFlip = flip;
    }
    return count2;
  }
  segment(complex, index3, last2, cur, next) {
    let count2 = 0;
    const indices = complex.indices;
    const positions = complex.positions;
    const normals = complex.normals;
    const capSquare = this.cap === "square";
    const joinBevel = this.join === "bevel";
    const flatCur = aProjectFlat([cur[0], cur[1]]);
    const flatLast = aProjectFlat([last2[0], last2[1]]);
    direction(lineA, flatCur, flatLast);
    let segmentDistance = 0;
    if (this.dash) {
      segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
      this.totalDistance += segmentDistance;
    }
    if (!this.normal) {
      this.normal = vec2_exports.create();
      computeNormal(this.normal, lineA);
    }
    if (!this.started) {
      this.started = true;
      if (capSquare) {
        const out1 = vec2_exports.create();
        const out2 = vec2_exports.create();
        vec2_exports.add(out1, this.normal, lineA);
        vec2_exports.add(out2, this.normal, lineA);
        normals.push(out2[0], out2[1], 0);
        normals.push(out1[0], out1[1], 0);
        positions.push(last2[0], last2[1], last2[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last2[2] | 0);
        this.complex.indexes.push(this.currentIndex);
        positions.push(last2[0], last2[1], last2[2] | 0, this.totalDistance - segmentDistance, this.thickness, last2[2] | 0);
        this.complex.indexes.push(this.currentIndex);
        this.currentIndex++;
      } else {
        this.extrusions(positions, normals, last2, this.normal, this.thickness, this.totalDistance - segmentDistance);
      }
    }
    indices.push(index3 + 0, index3 + 1, index3 + 2);
    if (!next) {
      computeNormal(this.normal, lineA);
      if (capSquare) {
        const out1 = vec2_exports.create();
        const out2 = vec2_exports.create();
        vec2_exports.sub(out2, lineA, this.normal);
        vec2_exports.add(out1, lineA, this.normal);
        normals.push(out2[0], out2[1], 0);
        normals.push(out1[0], out1[1], 0);
        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
        this.complex.indexes.push(this.currentIndex);
        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
        this.complex.indexes.push(this.currentIndex);
        this.currentIndex++;
      } else {
        this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);
      }
      indices.push(...this.lastFlip === 1 ? [index3, index3 + 2, index3 + 3] : [index3 + 2, index3 + 1, index3 + 3]);
      count2 += 2;
    } else {
      const flatNext = aProjectFlat([next[0], next[1]]);
      if (isPointEqual(flatCur, flatNext)) {
        vec2_exports.add(flatNext, flatCur, vec2_exports.normalize(flatNext, vec2_exports.subtract(flatNext, flatCur, flatLast)));
      }
      direction(lineB, flatNext, flatCur);
      const [miterLen, miter] = computeMiter(tangent, vec2_exports.create(), lineA, lineB, this.thickness);
      let flip = vec2_exports.dot(tangent, this.normal) < 0 ? -1 : 1;
      let bevel = joinBevel;
      if (!bevel && this.join === "miter") {
        const limit = miterLen;
        if (limit > this.miterLimit) {
          bevel = true;
        }
      }
      if (bevel) {
        normals.push(this.normal[0], this.normal[1], 0);
        normals.push(miter[0], miter[1], 0);
        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
        this.complex.indexes.push(this.currentIndex);
        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);
        this.complex.indexes.push(this.currentIndex);
        this.currentIndex++;
        indices.push(...this.lastFlip !== -flip ? [index3, index3 + 2, index3 + 3] : [index3 + 2, index3 + 1, index3 + 3]);
        indices.push(index3 + 2, index3 + 3, index3 + 4);
        computeNormal(tmp, lineB);
        vec2_exports.copy(this.normal, tmp);
        normals.push(this.normal[0], this.normal[1], 0);
        positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
        this.complex.indexes.push(this.currentIndex);
        this.currentIndex++;
        count2 += 3;
      } else {
        this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);
        indices.push(...this.lastFlip === 1 ? [index3, index3 + 2, index3 + 3] : [index3 + 2, index3 + 1, index3 + 3]);
        flip = -1;
        vec2_exports.copy(this.normal, miter);
        count2 += 2;
      }
      this.lastFlip = flip;
    }
    return count2;
  }
  extrusions(positions, normals, point2, normal, thickness, distanceRadio) {
    normals.push(normal[0], normal[1], 0);
    normals.push(normal[0], normal[1], 0);
    positions.push(point2[0], point2[1], point2[2] | 0, distanceRadio, -thickness, point2[2] | 0);
    this.complex.indexes.push(this.currentIndex);
    positions.push(point2[0], point2[1], point2[2] | 0, distanceRadio, thickness, point2[2] | 0);
    this.complex.indexes.push(this.currentIndex);
    this.currentIndex++;
  }
  lineSegmentDistance(b1, a1) {
    const dx = a1[0] - b1[0];
    const dy = a1[1] - b1[1];
    return Math.sqrt(dx * dx + dy * dy);
  }
};

// node_modules/@antv/l7-layers/es/core/shape/Path.js
var ShapeType3D = function(ShapeType3D2) {
  ShapeType3D2["CYLINDER"] = "cylinder";
  ShapeType3D2["SQUARECOLUMN"] = "squareColumn";
  ShapeType3D2["TRIANGLECOLUMN"] = "triangleColumn";
  ShapeType3D2["HEXAGONCOLUMN"] = "hexagonColumn";
  ShapeType3D2["PENTAGONCOLUMN"] = "pentagonColumn";
  return ShapeType3D2;
}({});
var ShapeType2D = function(ShapeType2D2) {
  ShapeType2D2["CIRCLE"] = "circle";
  ShapeType2D2["SQUARE"] = "square";
  ShapeType2D2["TRIANGLE"] = "triangle";
  ShapeType2D2["HEXAGON"] = "hexagon";
  ShapeType2D2["PENTAGON"] = "pentagon";
  return ShapeType2D2;
}({});
function polygonPath(pointCount, start = 0) {
  const step = Math.PI * 2 / pointCount;
  const line = [];
  for (let i = 0; i < pointCount; i++) {
    line.push(step * i + start * Math.PI / 12);
  }
  const path = line.map((t) => {
    const x = Math.sin(t + Math.PI / 4);
    const y = Math.cos(t + Math.PI / 4);
    return [x, y, 0];
  });
  return path;
}
function circle() {
  return polygonPath(30);
}
function square() {
  return polygonPath(4);
}
function triangle() {
  return polygonPath(3);
}
function hexagon() {
  return polygonPath(6, 1);
}
function pentagon() {
  return polygonPath(5);
}
var geometryShape = {
  [ShapeType2D.CIRCLE]: circle,
  [ShapeType2D.HEXAGON]: hexagon,
  [ShapeType2D.TRIANGLE]: triangle,
  [ShapeType2D.SQUARE]: square,
  [ShapeType2D.PENTAGON]: pentagon,
  [ShapeType3D.CYLINDER]: circle,
  [ShapeType3D.HEXAGONCOLUMN]: hexagon,
  [ShapeType3D.TRIANGLECOLUMN]: triangle,
  [ShapeType3D.SQUARECOLUMN]: square,
  [ShapeType3D.PENTAGONCOLUMN]: pentagon
};

// node_modules/@antv/l7-layers/es/core/shape/extrude.js
var import_earcut2 = __toESM(require_earcut());
function extrudePolygon(path) {
  const p1 = path[0][0];
  const p2 = path[0][path[0].length - 1];
  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    path[0] = path[0].slice(0, path[0].length - 1);
  }
  const n = path[0].length;
  const flattengeo = import_earcut2.default.flatten(path);
  const {
    vertices,
    dimensions
  } = flattengeo;
  const positions = [];
  const indexArray = [];
  for (let j = 0; j < vertices.length / dimensions; j++) {
    if (dimensions === 2) {
      positions.push(vertices[j * 2], vertices[j * 2 + 1], 1);
    } else {
      positions.push(vertices[j * 3], vertices[j * 3 + 1], 1);
    }
  }
  const triangles = (0, import_earcut2.default)(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  indexArray.push(...triangles);
  for (let i = 0; i < n; i++) {
    const prePoint = flattengeo.vertices.slice(i * dimensions, (i + 1) * dimensions);
    let nextPoint = flattengeo.vertices.slice((i + 1) * dimensions, (i + 2) * dimensions);
    if (nextPoint.length === 0) {
      nextPoint = flattengeo.vertices.slice(0, dimensions);
    }
    const indexOffset = positions.length / 3;
    positions.push(prePoint[0], prePoint[1], 1, nextPoint[0], nextPoint[1], 1, prePoint[0], prePoint[1], 0, nextPoint[0], nextPoint[1], 0);
    indexArray.push(...[0, 2, 1, 2, 3, 1].map((v2) => v2 + indexOffset));
  }
  return {
    positions,
    index: indexArray
  };
}
function fillPolygon(points) {
  const flattengeo = import_earcut2.default.flatten(points);
  const triangles = (0, import_earcut2.default)(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  return {
    positions: flattengeo.vertices,
    index: triangles
  };
}
function extrude_PolygonNormal(path, needFlat = false) {
  const p1 = path[0][0];
  const p2 = path[0][path[0].length - 1];
  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    path[0] = path[0].slice(0, path[0].length - 1);
  }
  const n = path[0].length;
  const flattengeo = import_earcut2.default.flatten(path);
  const {
    vertices,
    dimensions,
    holes
  } = flattengeo;
  const positions = [];
  const indexArray = [];
  const normals = [];
  for (let j = 0; j < vertices.length / dimensions; j++) {
    positions.push(
      vertices[j * dimensions],
      // x
      vertices[j * dimensions + 1],
      // y
      1,
      // z
      -1,
      // 顶部uv
      -1
      // 顶部uv
    );
    normals.push(0, 0, 1);
  }
  const indices = getPolygonSurfaceIndices(vertices, holes, dimensions, needFlat);
  indexArray.push(...indices);
  for (let i = 0; i < n; i++) {
    const prePoint = flattengeo.vertices.slice(i * dimensions, (i + 1) * dimensions);
    let nextPoint = flattengeo.vertices.slice((i + 1) * dimensions, (i + 2) * dimensions);
    if (nextPoint.length === 0) {
      nextPoint = flattengeo.vertices.slice(0, dimensions);
    }
    const indexOffset = positions.length / 5;
    positions.push(
      prePoint[0],
      prePoint[1],
      1,
      0,
      0,
      nextPoint[0],
      nextPoint[1],
      1,
      0.1,
      // 侧面 低uv
      0,
      // 侧面低 uv
      prePoint[0],
      prePoint[1],
      0,
      0,
      0.8,
      nextPoint[0],
      nextPoint[1],
      0,
      0.1,
      0.8
    );
    const normal = computeVertexNormals([nextPoint[0], nextPoint[1], 1], [prePoint[0], prePoint[1], 0], [prePoint[0], prePoint[1], 1], needFlat);
    normals.push(...normal, ...normal, ...normal, ...normal);
    indexArray.push(...[1, 2, 0, 3, 2, 1].map((v2) => v2 + indexOffset));
  }
  return {
    positions,
    index: indexArray,
    normals
  };
}
function computeVertexNormals(p1, p2, p3, needFlat = false) {
  const cb = vec3_exports.create();
  const ab4 = vec3_exports.create();
  const normal = vec3_exports.create();
  if (needFlat) {
    p1 = lngLatToMeters(p1);
    p2 = lngLatToMeters(p2);
    p3 = lngLatToMeters(p3);
  }
  const pA = vec3_exports.fromValues(...p1);
  const pB = vec3_exports.fromValues(...p2);
  const pC = vec3_exports.fromValues(...p3);
  vec3_exports.sub(cb, pC, pB);
  vec3_exports.sub(ab4, pA, pB);
  vec3_exports.cross(normal, cb, ab4);
  const newNormal = vec3_exports.create();
  vec3_exports.normalize(newNormal, normal);
  return newNormal;
}

// node_modules/@antv/l7-layers/es/core/triangulation.js
var GeometryCache = {};
function PointFillTriangulation(feature) {
  const coordinates = calculateCentroid(feature.coordinates);
  return {
    vertices: [...coordinates, ...coordinates, ...coordinates, ...coordinates],
    indices: [0, 1, 2, 2, 3, 0],
    size: coordinates.length
  };
}
function GlobelPointFillTriangulation(feature) {
  const coordinates = calculateCentroid(feature.coordinates);
  const xyz = lglt2xyz(coordinates);
  return {
    vertices: [...xyz, ...xyz, ...xyz, ...xyz],
    indices: [0, 1, 2, 2, 3, 0],
    size: xyz.length
  };
}
function PointExtrudeTriangulation(feature) {
  const {
    shape
  } = feature;
  const {
    positions,
    index: index3,
    normals
  } = getGeometry(shape, false);
  return {
    vertices: positions,
    indices: index3,
    normals,
    size: 5
  };
}
function PointImageTriangulation(feature) {
  const coordinates = calculateCentroid(feature.coordinates);
  return {
    vertices: [...coordinates],
    indices: [0],
    size: coordinates.length
  };
}
function LineTriangulation(feature) {
  const {
    coordinates
  } = feature;
  const line = new ExtrudePolyline({
    dash: true,
    join: "bevel"
  });
  let path = coordinates;
  if (path[0] && !Array.isArray(path[0][0])) {
    path = [coordinates];
  }
  path.forEach((item) => {
    line.extrude(item);
  });
  const linebuffer = line.complex;
  return {
    vertices: linebuffer.positions,
    // [ x,y,z, distance, miter,total ]
    indices: linebuffer.indices,
    normals: linebuffer.normals,
    indexes: linebuffer.indexes,
    size: 6
  };
}
function SimpleLineTriangulation(feature) {
  const {
    coordinates
  } = feature;
  const pos = [];
  if (!Array.isArray(coordinates[0])) {
    return {
      vertices: [],
      indices: [],
      normals: [],
      size: 6,
      count: 0
    };
  }
  const {
    results,
    totalDistance
  } = getSimpleLineVertices(coordinates);
  results.map((point2) => {
    pos.push(point2[0], point2[1], point2[2], point2[3], 0, totalDistance);
  });
  return {
    vertices: pos,
    indices: [],
    normals: [],
    size: 6,
    count: results.length
  };
}
function lineSegmentDistance(b1, a1) {
  const dx = a1[0] - b1[0];
  const dy = a1[1] - b1[1];
  return Math.sqrt(dx * dx + dy * dy);
}
function pushDis(point2, n) {
  if (point2.length < 3) {
    point2.push(0);
  }
  if (n !== void 0) {
    point2.push(n);
  }
  return point2;
}
function getSimpleLineVertices(coordinates) {
  let points = coordinates;
  if (Array.isArray(points) && Array.isArray(points[0]) && Array.isArray(points[0][0])) {
    points = coordinates.flat();
  }
  let distance = 0;
  if (points.length < 2) {
    return {
      results: points,
      totalDistance: 0
    };
  } else {
    const results = [];
    const point2 = pushDis(points[0], distance);
    results.push(point2);
    for (let i = 1; i < points.length - 1; i++) {
      const subDistance = lineSegmentDistance(aProjectFlat(points[i - 1]), aProjectFlat(points[i]));
      distance += subDistance;
      const mulPoint = pushDis(points[i], distance);
      results.push(mulPoint);
      results.push(mulPoint);
    }
    const pointDistance = lineSegmentDistance(aProjectFlat(points[points.length - 2]), aProjectFlat(points[points.length - 1]));
    distance += pointDistance;
    results.push(pushDis(points[points.length - 1], distance));
    return {
      results,
      totalDistance: distance
    };
  }
}
function polygonTriangulation(feature) {
  const {
    coordinates
  } = feature;
  const flattengeo = import_earcut3.default.flatten(coordinates);
  const {
    vertices,
    dimensions,
    holes
  } = flattengeo;
  const indices = getPolygonSurfaceIndices(vertices, holes, dimensions);
  return {
    indices,
    vertices,
    size: dimensions
  };
}
function polygonTriangulationWithCenter(feature) {
  const {
    indices,
    vertices,
    size: size2
  } = polygonTriangulation(feature);
  return {
    indices,
    vertices: getVerticesWithCenter(vertices),
    size: size2 + 4
  };
}
function getVerticesWithCenter(vertices) {
  const verticesWithCenter = [];
  const {
    center,
    radius
  } = calculatePointsCenterAndRadius(vertices);
  for (let i = 0; i < vertices.length; i += 2) {
    const lng = vertices[i];
    const lat = vertices[i + 1];
    verticesWithCenter.push(lng, lat, 0, ...center, radius);
  }
  return verticesWithCenter;
}
function PolygonExtrudeTriangulation(feature) {
  const coordinates = feature.coordinates;
  const {
    positions,
    index: index3,
    normals
  } = extrude_PolygonNormal(coordinates, true);
  return {
    vertices: positions,
    // [ x, y, z, uv.x,uv.y ]
    indices: index3,
    normals,
    size: 5
  };
}
function HeatmapGridTriangulation(feature) {
  const {
    shape
  } = feature;
  const {
    positions,
    index: index3
  } = getHeatmapGeometry(shape);
  return {
    vertices: positions,
    // [ x, y, z ] 多边形顶点
    indices: index3,
    size: 3
  };
}
function RasterImageTriangulation(feature) {
  const coordinates = feature.coordinates;
  const positions = [...coordinates[0], 0, 0, 0, ...coordinates[1], 0, 1, 0, ...coordinates[2], 0, 1, 1, ...coordinates[3], 0, 0, 1];
  const indexs = [0, 1, 2, 0, 2, 3];
  return {
    vertices: positions,
    indices: indexs,
    size: 5
  };
}
function LineArcTriangulation(feature, styleOption) {
  const {
    segmentNumber = 30
  } = styleOption;
  const coordinates = feature.coordinates;
  const positions = [];
  const indexArray = [];
  for (let i = 0; i < segmentNumber; i++) {
    positions.push(i, 1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1], i, -1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1]);
    if (i !== segmentNumber - 1) {
      indexArray.push(...[0, 1, 2, 1, 3, 2].map((v2) => {
        return i * 2 + v2;
      }));
    }
  }
  return {
    vertices: positions,
    indices: indexArray,
    size: 7
  };
}
function HeatmapTriangulation(feature) {
  const coordinates = feature.coordinates;
  if (coordinates.length === 2) {
    coordinates.push(0);
  }
  const dir = addDir(-1, 1);
  const dir1 = addDir(1, 1);
  const dir2 = addDir(-1, -1);
  const dir3 = addDir(1, -1);
  const positions = [...coordinates, ...dir, ...coordinates, ...dir2, ...coordinates, ...dir3, ...coordinates, ...dir1];
  const indexArray = [0, 1, 2, 3, 0, 2];
  return {
    vertices: positions,
    indices: indexArray,
    size: 5
  };
}
function getGeometry(shape, needFlat = false) {
  if (GeometryCache && GeometryCache[shape]) {
    return GeometryCache[shape];
  }
  const path = geometryShape[shape] ? geometryShape[shape]() : geometryShape.cylinder();
  const geometry = extrude_PolygonNormal([path], needFlat);
  GeometryCache[shape] = geometry;
  return geometry;
}
function getHeatmapGeometry(shape) {
  const shape3d = ["cylinder", "triangleColumn", "hexagonColumn", "squareColumn"];
  const path = geometryShape[shape] ? geometryShape[shape]() : geometryShape.circle();
  const geometry = shape3d.indexOf(shape) === -1 ? fillPolygon([path]) : extrudePolygon([path]);
  return geometry;
}
function addDir(dirX, dirY) {
  const x = (dirX + 1) / 2;
  const y = (dirY + 1) / 2;
  return [x, y];
}
function earthTriangulation() {
  const earthmesh = primitiveSphere(EARTH_RADIUS, {
    segments: EARTH_SEGMENTS
  });
  const {
    positionsArr,
    indicesArr,
    normalArr
  } = earthmesh;
  return {
    vertices: positionsArr,
    indices: indicesArr,
    size: 5,
    normals: normalArr
  };
}
function earthOuterTriangulation() {
  const earthmesh = primitiveSphere(EARTH_RADIUS + EARTH_RADIUS_OUTER, {
    segments: EARTH_SEGMENTS
  });
  const {
    positionsArr,
    indicesArr,
    normalArr
  } = earthmesh;
  return {
    vertices: positionsArr,
    indices: indicesArr,
    size: 5,
    normals: normalArr
  };
}

// node_modules/@antv/l7-layers/es/citybuliding/models/build.js
var buildFrag = 'precision highp float;\nlayout(std140) uniform commonUniforms {\n  vec4 u_baseColor: [ 1.0, 0, 0, 1.0 ];\n  vec4 u_brightColor: [ 1.0, 0, 0, 1.0 ];\n  vec4 u_windowColor: [ 1.0, 0, 0, 1.0 ];\n  vec4 u_circleSweepColor;\n  vec2 u_cityCenter;\n  float u_circleSweep;\n  float u_cityMinSize;\n  float u_circleSweepSpeed;\n  float u_opacity: 1.0;\n  float u_near: 0;\n  float u_far: 1;\n  float u_time;\n};\nin vec4 v_Color;\nin vec2 v_texCoord;\nin float v_worldDis;\nout vec4 outputColor;\n\n#pragma include "picking"\n#pragma include "scene_uniforms"\n\nvec3 getWindowColor(float n, float hot, vec3 brightColor, vec3 darkColor) {\n    float s = step(hot, n);\n    vec3 color = mix(brightColor,vec3(0.9,0.9,1.0),n);\n\n    return mix(darkColor, color, s);\n}\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat LinearizeDepth()\n{\n    float z = gl_FragCoord.z * 2.0 - 1.0;\n    return (2.0 * u_near * u_far) / (u_far + u_near - z * (u_far - u_near));\n}\n\nvec3 fog(vec3 color, vec3 fogColor, float depth){\n    float fogFactor=clamp(depth,0.0,1.0);\n    vec3 output_color=mix(fogColor,color,fogFactor);\n    return output_color;\n}\n\nfloat sdRect(vec2 p, vec2 sz) {\n  vec2 d = abs(p) - sz;\n  float outside = length(max(d, 0.));\n  float inside = min(max(d.x, d.y), 0.);\n  return outside + inside;\n}\n\nvoid main() {\n  outputColor = v_Color;\n  vec3 baseColor = u_baseColor.xyz;\n  vec3 brightColor = u_brightColor.xyz;\n  vec3 windowColor = u_windowColor.xyz;\n  float targetColId = 5.;\n  float depth = 1.0 - LinearizeDepth() / u_far * u_Zoom;\n  vec3 fogColor = vec3(23.0/255.0,31.0/255.0,51.0/255.0);\n  if(v_texCoord.x < 0.) { //顶部颜色\n       vec3 foggedColor = fog(baseColor.xyz + vec3(0.12*0.9,0.2*0.9,0.3*0.9),fogColor,depth);\n       outputColor = vec4( foggedColor, v_Color.w);\n  }else { // 侧面颜色\n        vec2 st = v_texCoord;\n        vec2  UvScale = v_texCoord;\n        float tStep = min(0.08,max(0.05* (18.0-u_Zoom),0.02));\n        float tStart = 0.25 * tStep;\n        float tEnd = 0.75 * tStep;\n        float u = mod(UvScale.x, tStep);\n        float v = mod(UvScale.y, tStep);\n        float ux = floor(UvScale.x/tStep);\n        float uy = floor(UvScale.y/tStep);\n        float n = random(vec2(ux,uy));\n        float lightP = u_time;\n        float head = 1.0- step(0.005,st.y);\n        /*step3*/\n        // 将窗户颜色和墙面颜色区别开来\n        float sU = step(tStart, u) - step(tEnd, u);\n        float sV = step(tStart, v) - step(tEnd, v);\n        vec2 windowSize = vec2(abs(tEnd-tStart),abs(tEnd-tStart));\n        float dist = sdRect(vec2(u,v), windowSize);\n        float s = sU * sV;\n\n        float curColId = floor(UvScale.x / tStep);\n        float sCol = step(targetColId - 0.2, curColId) - step(targetColId + 0.2, curColId);\n\n        float mLightP = mod(lightP, 2.);\n        float sRow = step(mLightP - 0.2, st.y) - step(mLightP, st.y);\n        if(ux == targetColId){\n            n =0.;\n        }\n        float timeP = min(0.75, abs ( sin(u_time/3.0) ) );\n        float hot = smoothstep(1.0,0.0,timeP);\n        vec3 color = mix(baseColor, getWindowColor(n,hot,brightColor,windowColor), s);\n        //vec3 color = mix(baseColor, getWindowColor(n,hot,brightColor,windowColor), 1.0);\n        float sFinal = s * sCol * sRow;\n        color += mix(baseColor, brightColor, sFinal*n);\n        if (st.y<0.01){\n        color = baseColor;\n         }\n        if(head ==1.0) { // 顶部亮线\n            color = brightColor;\n        }\n        color = color * v_Color.rgb;\n\n        vec3 foggedColor = fog(color,fogColor,depth);\n\n        outputColor = vec4(foggedColor,1.0);\n  }\n\n\n  if(u_circleSweep > 0.0 && v_worldDis < u_cityMinSize) {\n    float r = fract(((v_worldDis/u_cityMinSize) - u_time * u_circleSweepSpeed) * 2.0);\n    outputColor.rgb += r * r * u_circleSweepColor.rgb;\n  }\n\n  outputColor.a *= u_opacity;\n  outputColor = filterColor(outputColor);\n}\n';
var buildVert = 'precision highp float;\n\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nout vec2 v_texCoord;\nout vec4 v_Color;\nout float v_worldDis;\n\nlayout(std140) uniform commonUniforms {\n  vec4 u_baseColor : [ 1.0, 0, 0, 1.0 ];\n  vec4 u_brightColor : [ 1.0, 0, 0, 1.0 ];\n  vec4 u_windowColor : [ 1.0, 0, 0, 1.0 ];\n  vec4 u_circleSweepColor;\n  vec2 u_cityCenter;\n  float u_circleSweep;\n  float u_cityMinSize;\n  float u_circleSweepSpeed;\n  float u_opacity: 1.0;\n  float u_near : 0;\n  float u_far : 1;\n  float u_time;\n};\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\n\nvoid main() {\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  vec4 project_pos = project_position(pos);\n\n   v_texCoord = a_Uv;\n\n  if(u_circleSweep > 0.0) {\n     vec2 lnglatscale = vec2(0.0);\n    lnglatscale = (a_Position.xy - u_cityCenter) * vec2(0.0, 0.135);\n    v_worldDis = length(a_Position.xy + lnglatscale - u_cityCenter);\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  float lightWeight = calc_lighting(pos);\n  // v_Color = a_Color;\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  setPickingColor(a_PickingColor);\n}\n';
var CityBuildModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "cityCenter", void 0);
    _defineProperty(this, "cityMinSize", void 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      NORMAL: 10,
      UV: 11
    });
  }
  getCommonUniformsInfo() {
    const {
      opacity = 1,
      baseColor = "rgb(16,16,16)",
      brightColor = "rgb(255,176,38)",
      windowColor = "rgb(30,60,89)",
      time = 0,
      sweep = {
        enable: false,
        sweepRadius: 1,
        sweepColor: "rgb(255, 255, 255)",
        sweepSpeed: 0.4,
        sweepCenter: this.cityCenter
      }
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_baseColor: rgb2arr(baseColor),
      u_brightColor: rgb2arr(brightColor),
      u_windowColor: rgb2arr(windowColor),
      u_circleSweepColor: [...rgb2arr(sweep.sweepColor).slice(0, 3), 1],
      u_cityCenter: sweep.sweepCenter || this.cityCenter,
      u_circleSweep: sweep.enable ? 1 : 0,
      u_cityMinSize: this.cityMinSize * sweep.sweepRadius,
      u_circleSweepSpeed: sweep.sweepSpeed,
      u_opacity: opacity,
      u_near: 0,
      u_far: 1,
      u_time: this.layer.getLayerAnimateTime() || time
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  calCityGeo() {
    const [minLng, minLat, maxLng, maxLat] = this.layer.getSource().extent;
    const w = maxLng - minLng;
    const h = maxLat - minLat;
    this.cityCenter = [(maxLng + minLng) / 2, (maxLat + minLat) / 2];
    this.cityMinSize = Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2)) / 4;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.calCityGeo();
      _this.initUniformsBuffer();
      _this.startModelAnimate();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "cityBuilding",
        vertexShader: buildVert,
        fragmentShader: buildFrag,
        triangulation: PolygonExtrudeTriangulation,
        depth: {
          enable: true
        },
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        cull: {
          enable: true,
          face: gl.BACK
        }
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "normal",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Normal",
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 10
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/citybuliding/building.js
var CityBuildingLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "CityBuildingLayer");
  }
  buildModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.layerModel = new CityBuildModel(_this);
      yield _this.initLayerModels();
    })();
  }
  setLight(t) {
    this.updateLayerConfig({
      time: t
    });
  }
  getModelType() {
    return "citybuilding";
  }
};

// node_modules/@antv/l7-layers/es/geometry/models/billboard.js
var planeFrag = 'layout(std140) uniform commonUniforms {\n vec2 u_size;\n float u_raisingHeight;\n float u_rotation;\n float u_opacity;\n};\n\nuniform sampler2D u_texture;\n\nin vec2 v_uv;\nout vec4 outputColor;\n\n#pragma include "picking"\nvoid main() {\n  outputColor = texture(SAMPLER_2D(u_texture), vec2(v_uv.x, 1.0 - v_uv.y));\n  outputColor.a *= u_opacity;\n  outputColor = filterColor(outputColor);\n}\n';
var planeVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_size;\n  float u_raisingHeight;\n  float u_rotation;\n  float u_opacity;\n};\n\nout vec2 v_uv;\n\n#pragma include "projection"\n#pragma include "picking"\n#pragma include "rotation_2d"\nvoid main() {\n  vec3 extrude = a_Extrude;\n  v_uv = a_Uv;\n  float raiseHeight = u_raisingHeight;\n  if (\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n  ) {\n    float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\n    raiseHeight = u_raisingHeight * mapboxZoomScale;\n  }\n\n  // 计算经纬度点位坐标\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\n\n  // 计算绕 z 轴旋转后的偏移\n  vec2 offsetXY = project_pixel(rotate_matrix(vec2(extrude.x * u_size.x, 0.0), u_rotation));\n  // 绕 z 轴旋转\n  float x = project_pos.x + offsetXY.x;\n  float y = project_pos.y + offsetXY.y;\n  // z 轴不参与旋转\n  float z = project_pixel(extrude.y * u_size.y + raiseHeight);\n\n  gl_Position = project_common_position_to_clipspace(vec4(x, y, z, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n';
var BillBoardModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "radian", 0);
    _defineProperty(this, "planeGeometryTriangulation", () => {
      const {
        center = [120, 30]
      } = this.layer.getLayerConfig();
      return {
        size: 4,
        indices: [0, 1, 2, 2, 3, 0],
        vertices: [...center, ...[1, 1], ...center, ...[0, 1], ...center, ...[0, 0], ...center, ...[1, 0]]
      };
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      EXTRUDE: 9,
      UV: 10
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      width = 1,
      height = 1,
      raisingHeight = 0
    } = this.layer.getLayerConfig();
    let rotateFlag = 1;
    if (this.mapService.getType() === "amap") {
      rotateFlag = -1;
    }
    this.radian = rotateFlag * Math.PI * (this.mapService.getRotation() % 360) / 180;
    const commonOptions = {
      u_size: [width, height],
      u_raisingHeight: Number(raisingHeight),
      u_rotation: this.radian,
      u_opacity: opacity || 1,
      u_texture: this.texture
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const {
        drawCanvas
      } = _this.layer.getLayerConfig();
      const {
        createTexture2D
      } = _this.rendererService;
      _this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      if (drawCanvas) {
        _this.updateTexture(drawCanvas);
      }
      _this.initUniformsBuffer();
      const model = yield _this.layer.buildLayerModel({
        moduleName: "geometryBillboard",
        vertexShader: planeVert,
        fragmentShader: planeFrag,
        triangulation: _this.planeGeometryTriangulation,
        defines: _this.getDefines(),
        inject: _this.getInject(),
        primitive: gl.TRIANGLES,
        depth: {
          enable: true
        }
      });
      return [model];
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      return _this2.initModels();
    })();
  }
  updateTexture(drawCanvas) {
    const {
      createTexture2D
    } = this.rendererService;
    const {
      canvasWidth = 1,
      canvasHeight = 1
    } = this.layer.getLayerConfig();
    const canvas = document.createElement("canvas");
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    const ctx = canvas.getContext("2d");
    if (ctx) {
      drawCanvas(canvas);
      this.texture = createTexture2D({
        data: canvas,
        width: canvas.width,
        height: canvas.height,
        wrapS: gl.CLAMP_TO_EDGE,
        wrapT: gl.CLAMP_TO_EDGE
      });
      this.layerService.reRender();
    }
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "extrude",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Extrude",
        shaderLocation: this.attributeLocation.EXTRUDE,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx) => {
          const extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
          const extrudeIndex = attributeIdx % 4 * 3;
          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[2], vertex[3]];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/geometry/models/plane.js
var planeFrag2 = 'uniform sampler2D u_texture;\nlayout(std140) uniform commonUniforms {\n  float u_opacity;\n  float u_mapFlag;\n  float u_terrainClipHeight;\n};\n\nin vec3 v_Color;\nin vec2 v_uv;\nin float v_clip;\nout vec4 outputColor;\n\n#pragma include "picking"\nvoid main() {\n  if (u_mapFlag > 0.0) {\n    outputColor = texture(SAMPLER_2D(u_texture), vec2(v_uv.x, 1.0 - v_uv.y));\n    outputColor.a *= u_opacity;\n  } else {\n    outputColor = vec4(v_Color, u_opacity);\n  }\n  outputColor.a *= v_clip;\n  outputColor = filterColor(outputColor);\n}\n';
var planeVert2 = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec3 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  float u_opacity;\n  float u_mapFlag;\n  float u_terrainClipHeight;\n};\n\nout vec3 v_Color;\nout vec2 v_uv;\nout float v_clip;\n\n#pragma include "projection"\n#pragma include "picking"\nvoid main() {\n  v_Color = a_Color;\n  v_uv = a_Uv;\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n  v_clip = 1.0;\n  if (a_Position.z < u_terrainClipHeight) {\n    v_clip = 0.0;\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, a_Position.z, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n';
var PlaneModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "terrainImage", void 0);
    _defineProperty(this, "terrainImageLoaded", false);
    _defineProperty(this, "mapTexture", void 0);
    _defineProperty(this, "planeGeometryTriangulation", () => {
      const {
        width = 1,
        height = 1,
        widthSegments = 1,
        heightSegments = 1,
        center = [120, 30],
        terrainTexture,
        rgb2height = (r, g, b) => r + g + b
      } = this.layer.getLayerConfig();
      const {
        indices,
        positions
      } = this.initPlane(width, height, widthSegments, heightSegments, ...center);
      if (terrainTexture) {
        return this.translateVertex(positions, indices, this.terrainImage, widthSegments, heightSegments, rgb2height);
      }
      return {
        vertices: positions,
        indices,
        size: 5
      };
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      UV: 10
    });
  }
  initPlane(width = 1, height = 1, widthSegments = 1, heightSegments = 1, lng = 120, lat = 30) {
    const widthHalf = width / 2;
    const heightHalf = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segmentWidth = width / gridX;
    const segmentHeight = height / gridY;
    const indices = [];
    const positions = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segmentHeight - heightHalf;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segmentWidth - widthHalf;
        positions.push(x + lng, -y + lat, 0);
        positions.push(ix / gridX);
        positions.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    return {
      indices,
      positions
    };
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      mapTexture,
      terrainClipHeight = 0,
      terrainTexture
    } = this.layer.getLayerConfig();
    if (this.mapTexture !== mapTexture) {
      var _this$texture;
      this.mapTexture = mapTexture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
      this.updateTexture(mapTexture);
    }
    const commonOptions = {
      u_opacity: opacity || 1,
      u_mapFlag: mapTexture ? 1 : 0,
      u_terrainClipHeight: terrainTexture ? terrainClipHeight : -1,
      u_texture: this.texture
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  clearModels() {
    var _this$texture2;
    this.terrainImage = null;
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    this.textures = [];
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const {
        mapTexture,
        terrainTexture
      } = _this.layer.getLayerConfig();
      _this.mapTexture = mapTexture;
      const {
        createTexture2D
      } = _this.rendererService;
      _this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      _this.updateTexture(mapTexture);
      _this.initUniformsBuffer();
      if (terrainTexture) {
        _this.terrainImage = yield _this.loadTerrainImage(terrainTexture);
      }
      const model = yield _this.layer.buildLayerModel({
        moduleName: "geometryPlane",
        vertexShader: planeVert2,
        fragmentShader: planeFrag2,
        triangulation: _this.planeGeometryTriangulation,
        defines: _this.getDefines(),
        inject: _this.getInject(),
        primitive: gl.TRIANGLES,
        depth: {
          enable: true
        },
        cull: {
          enable: true,
          face: gl.BACK
          // gl.FRONT | gl.BACK;
        }
      });
      return [model];
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      return _this2.initModels();
    })();
  }
  createModelData(options) {
    if (options) {
      const {
        widthSegments: oldwidthSegments,
        heightSegments: oldheightSegments,
        width: oldwidth,
        height: oldheight
      } = this.layer.getLayerConfig();
      const {
        widthSegments,
        heightSegments,
        width,
        height
      } = options;
      this.layer.style({
        widthSegments: widthSegments !== void 0 ? widthSegments : oldwidthSegments,
        heightSegments: heightSegments !== void 0 ? heightSegments : oldheightSegments,
        width: width !== void 0 ? width : oldwidth,
        height: height !== void 0 ? height : oldheight
      });
    }
    const oldFeatures = this.layer.getEncodedData();
    const res = this.styleAttributeService.createAttributesAndIndices(oldFeatures, this.planeGeometryTriangulation);
    return res;
  }
  updateTexture(mapTexture) {
    const {
      createTexture2D
    } = this.rendererService;
    if (mapTexture) {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        this.texture = createTexture2D({
          data: img,
          width: img.width,
          height: img.height,
          wrapS: gl.CLAMP_TO_EDGE,
          wrapT: gl.CLAMP_TO_EDGE
        });
        this.layerService.reRender();
      };
      img.src = mapTexture;
    } else {
      this.texture = createTexture2D({
        width: 0,
        height: 0
      });
    }
  }
  getImageData(img) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const {
      width,
      height
    } = img;
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img, 0, 0, width, height);
    const imageData = ctx.getImageData(0, 0, width, height);
    return imageData;
  }
  translateVertex(positions, indices, image2, widthSegments, heightSegments, rgb2height) {
    const imgWidth = image2.width;
    const imgHeight = image2.height;
    const imageData = this.getImageData(image2).data;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const widthStep = imgWidth / gridX;
    const heightStep = imgHeight / gridY;
    for (let iy = 0; iy < gridY1; iy++) {
      const imgIndexY = Math.floor(iy * heightStep);
      const imgLen = imgIndexY * imgWidth;
      for (let ix = 0; ix < gridX1; ix++) {
        const imgIndexX = Math.floor(ix * widthStep);
        const imgDataIndex = (imgLen + imgIndexX) * 4;
        const r = imageData[imgDataIndex];
        const g = imageData[imgDataIndex + 1];
        const b = imageData[imgDataIndex + 2];
        const z = (iy * gridX1 + ix) * 5 + 2;
        positions[z] = rgb2height(r, g, b);
      }
    }
    return {
      vertices: positions,
      indices,
      size: 5
    };
  }
  loadTerrainImage(terrainTexture) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      if (_this3.terrainImage) {
        if (_this3.terrainImageLoaded) {
          return _this3.terrainImage;
        } else {
          return new Promise((resolve) => {
            _this3.terrainImage.onload = () => {
              resolve(_this3.terrainImage);
            };
          });
        }
      } else {
        const terrainImage = new Image();
        terrainImage.crossOrigin = "anonymous";
        return new Promise((resolve) => {
          terrainImage.onload = () => {
            _this3.terrainImageLoaded = true;
            resolve(terrainImage);
            setTimeout(() => _this3.layer.emit("terrainImageLoaded", null));
          };
          terrainImage.src = terrainTexture;
        });
      }
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/geometry/models/sprite.js
var spriteFrag = "\nlayout(std140) uniform commonUniforms {\n  float u_opacity;\n  float u_mapFlag;\n  float u_Scale;\n};\nuniform sampler2D u_texture;\n\nin vec3 v_Color;\nin float v_d;\nout vec4 outputColor;\n\nvoid main() {\n\n  if(v_d < 0.0) {\n    discard;\n  }\n\n  if(u_mapFlag > 0.0) {\n    outputColor = texture(SAMPLER_2D(u_texture), gl_PointCoord);\n    outputColor.a *= u_opacity;\n  } else {\n    outputColor = vec4(v_Color, u_opacity);\n  }\n}\n";
var spriteVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec3 a_Color;\n\nlayout(std140) uniform commonUniforms {\n  float u_opacity;\n  float u_mapFlag;\n  float u_Scale;\n};\n\nout vec3 v_Color;\nout float v_d;\n\n#pragma include "projection"\nvoid main() {\n  v_Color = a_Color.xyz;\n  v_d = a_Position.z;\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, a_Position.z, 1.0));\n  gl_PointSize = pow(u_Zoom - 1.0, 2.0) * u_Scale;\n}\n';
var SPRITE_ANIMATE_DIR = function(SPRITE_ANIMATE_DIR2) {
  SPRITE_ANIMATE_DIR2["UP"] = "up";
  SPRITE_ANIMATE_DIR2["DOWN"] = "down";
  return SPRITE_ANIMATE_DIR2;
}(SPRITE_ANIMATE_DIR || {});
var SpriteModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "mapTexture", void 0);
    _defineProperty(this, "positions", void 0);
    _defineProperty(this, "indices", void 0);
    _defineProperty(this, "timer", void 0);
    _defineProperty(this, "spriteTop", void 0);
    _defineProperty(this, "spriteUpdate", void 0);
    _defineProperty(this, "spriteAnimate", void 0);
    _defineProperty(this, "planeGeometryUpdateTriangulation", () => {
      const {
        spriteBottom = -10
      } = this.layer.getLayerConfig();
      const updateZ = this.spriteUpdate;
      const bottomZ = spriteBottom;
      const topZ = this.spriteTop;
      for (let i = 0; i < this.positions.length; i += 5) {
        if (this.spriteAnimate === SPRITE_ANIMATE_DIR.UP) {
          this.positions[i + 2] += updateZ;
          if (this.positions[i + 2] > topZ) {
            this.positions[i + 2] = bottomZ;
          }
        } else {
          this.positions[i + 2] -= updateZ;
          if (this.positions[i + 2] < bottomZ) {
            this.positions[i + 2] = topZ;
          }
        }
      }
      return {
        vertices: this.positions,
        indices: this.indices,
        size: 5
      };
    });
    _defineProperty(this, "updatePosition", () => {
      var _this$styleAttributeS;
      this.planeGeometryUpdateTriangulation();
      const vertexAttribute = (_this$styleAttributeS = this.styleAttributeService.getLayerStyleAttribute("position")) === null || _this$styleAttributeS === void 0 ? void 0 : _this$styleAttributeS.vertexAttribute;
      if (vertexAttribute) {
        const updated = [];
        for (let i = 0; i < this.positions.length; i += 5) {
          updated.push(this.positions[i], this.positions[i + 1], this.positions[i + 2]);
        }
        vertexAttribute.updateBuffer({
          data: updated,
          offset: 0
        });
      }
      this.layerService.throttleRenderLayers();
      this.timer = requestAnimationFrame(this.updatePosition);
    });
    _defineProperty(this, "planeGeometryTriangulation", () => {
      const {
        center = [120, 30],
        spriteCount = 100,
        spriteRadius = 10
      } = this.layer.getLayerConfig();
      const {
        indices,
        positions
      } = this.initSprite(spriteRadius, spriteCount, ...center);
      this.positions = positions;
      this.indices = indices;
      return {
        vertices: positions,
        indices,
        size: 5
      };
    });
  }
  initSprite(radius = 10, spriteCount = 100, lng = 120, lat = 30) {
    const indices = [];
    const positions = [];
    const heightLimit = this.spriteAnimate === SPRITE_ANIMATE_DIR.UP ? -this.spriteTop : this.spriteTop;
    for (let i = 0; i < spriteCount; i++) {
      const height = Math.random() * heightLimit;
      positions.push(...getPos(height));
    }
    for (let i = 0; i < spriteCount; i++) {
      indices.push(i);
    }
    function getPos(z) {
      const randomX = radius * Math.random();
      const randomY = radius * Math.random();
      const x = -radius / 2 + randomX;
      const y = -radius / 2 + randomY;
      return [x + lng, -y + lat, z, 0, 0];
    }
    return {
      indices,
      positions
    };
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      mapTexture,
      spriteScale = 1
    } = this.layer.getLayerConfig();
    if (this.mapTexture !== mapTexture) {
      var _this$texture;
      this.mapTexture = mapTexture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
      this.textures = [];
      this.updateTexture(mapTexture);
    }
    const commonOptions = {
      u_opacity: opacity || 1,
      u_mapFlag: mapTexture ? 1 : 0,
      u_Scale: spriteScale,
      u_texture: this.texture
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  clearModels() {
    var _this$texture2;
    cancelAnimationFrame(this.timer);
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    this.textures = [];
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const {
        mapTexture,
        spriteTop = 300,
        spriteUpdate = 10,
        spriteAnimate = SPRITE_ANIMATE_DIR.DOWN
      } = _this.layer.getLayerConfig();
      _this.initUniformsBuffer();
      _this.mapTexture = mapTexture;
      _this.spriteTop = spriteTop;
      _this.spriteUpdate = spriteUpdate;
      spriteAnimate === "up" ? _this.spriteAnimate = SPRITE_ANIMATE_DIR.UP : _this.spriteAnimate = SPRITE_ANIMATE_DIR.DOWN;
      const {
        createTexture2D
      } = _this.rendererService;
      _this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      _this.updateTexture(mapTexture);
      setTimeout(() => {
        _this.updatePosition();
      }, 100);
      const model = yield _this.layer.buildLayerModel({
        moduleName: "geometrySprite",
        vertexShader: spriteVert,
        fragmentShader: spriteFrag,
        triangulation: _this.planeGeometryTriangulation,
        defines: _this.getDefines(),
        inject: _this.getInject(),
        primitive: gl.POINTS,
        depth: {
          enable: false
        },
        blend: _this.getBlend()
      });
      return [model];
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      return _this2.initModels();
    })();
  }
  updateTexture(mapTexture) {
    const {
      createTexture2D
    } = this.rendererService;
    if (mapTexture) {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        this.texture = createTexture2D({
          data: img,
          width: img.width,
          height: img.height,
          wrapS: gl.CLAMP_TO_EDGE,
          wrapT: gl.CLAMP_TO_EDGE
        });
        this.layerService.reRender();
      };
      img.src = mapTexture;
    } else {
      this.texture = createTexture2D({
        width: 1,
        height: 1
      });
    }
  }
  registerBuiltinAttributes() {
    return "";
  }
};

// node_modules/@antv/l7-layers/es/geometry/models/index.js
var GeometryModels = {
  plane: PlaneModel,
  sprite: SpriteModel,
  billboard: BillBoardModel
};
var models_default = GeometryModels;

// node_modules/@antv/l7-layers/es/geometry/index.js
var GeometryLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "GeometryLayer");
    _defineProperty(this, "defaultSourceConfig", {
      data: [{
        x: 0,
        y: 0
      }],
      options: {
        parser: {
          type: "json",
          x: "x",
          y: "y"
        }
      }
    });
  }
  buildModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const modelType = _this.getModelType();
      _this.layerModel = new models_default[modelType](_this);
      yield _this.initLayerModels();
    })();
  }
  getDefaultConfig() {
    const type = this.getModelType();
    const defaultConfig = {
      plane: {},
      sprite: {},
      billboard: {}
    };
    return defaultConfig[type];
  }
  getModelType() {
    var _shapeAttribute$scale;
    const shapeAttribute = this.styleAttributeService.getLayerStyleAttribute("shape");
    const shape = shapeAttribute === null || shapeAttribute === void 0 || (_shapeAttribute$scale = shapeAttribute.scale) === null || _shapeAttribute$scale === void 0 ? void 0 : _shapeAttribute$scale.field;
    if (shape === "plane") {
      return "plane";
    } else if (shape === "sprite") {
      return "sprite";
    } else if (shape === "billboard") {
      return "billboard";
    } else {
      return "plane";
    }
  }
};

// node_modules/@antv/l7-layers/es/utils/rampcolor_legend.js
function rampColor2legend(rampColors, name) {
  return {
    type: rampColors.type,
    field: "value",
    items: rampColors.positions.map((value, index3) => {
      return {
        [name]: index3 >= rampColors.colors.length ? null : rampColors.colors[index3],
        value
      };
    })
  };
}

// node_modules/@antv/l7-layers/es/heatmap/models/grid.js
var grid_frag = 'in vec4 v_color;\n\n#pragma include "scene_uniforms"\n#pragma include "picking"\nout vec4 outputColor;\nvoid main() {\n  outputColor = v_color;\n  outputColor = filterColor(outputColor);\n}\n';
var grid_vert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location =  ATTRIBUTE_LOCATION_POS) in vec3 a_Pos;\n\nlayout(std140) uniform commonUniforms {\n    vec2 u_radius;\n    float u_opacity;\n    float u_coverage;\n    float u_angle;\n};\n\nout vec4 v_color;\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nvoid main() {\n  v_color = a_Color;\n  v_color.a *= u_opacity;\n\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\n  vec2 offset = a_Position.xy * u_radius * rotationMatrix * u_coverage;\n\n  vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\n  vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\n  gl_Position = project_common_position_to_clipspace(project_pos);\n\n  setPickingColor(a_PickingColor);\n}\n';
var GridModel = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      POS: 9
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      coverage,
      angle
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset],
      u_opacity: opacity || 1,
      u_coverage: coverage || 0.9,
      u_angle: angle || 0
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "heatmapGrid",
        vertexShader: grid_vert,
        fragmentShader: grid_frag,
        defines: _this2.getDefines(),
        triangulation: HeatmapGridTriangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        }
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "pos",
      // 顶点经纬度位置
      type: AttributeType.Attribute,
      descriptor: {
        shaderLocation: this.attributeLocation.POS,
        name: "a_Pos",
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature) => {
          const coordinates = feature.coordinates;
          return [coordinates[0], coordinates[1], 0];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/heatmap/models/grid3d.js
var grid_3d_frag = 'in vec4 v_color;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_radius;\n  float u_opacity;\n  float u_coverage;\n  float u_angle;\n};\n\n#pragma include "scene_uniforms"\n#pragma include "picking"\n\nout vec4 outputColor;\nvoid main() {\n  outputColor = v_color;\n  outputColor = filterColor(outputColor);\n}\n';
var grid_3d_vert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_POS) in vec3 a_Pos;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_radius;\n  float u_opacity;\n  float u_coverage;\n  float u_angle;\n};\n\nout vec4 v_color;\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "light"\n#pragma include "picking"\n\nvoid main() {\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\n  vec2 offset = vec2(a_Position.xy * u_radius * rotationMatrix * u_coverage);\n\n  vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // 实际的经纬度\n  vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\n\n  float lightWeight = calc_lighting(project_pos);\n  v_color = vec4(a_Color.rgb * lightWeight, a_Color.w);\n\n  gl_Position = project_common_position_to_clipspace(project_pos);\n\n  setPickingColor(a_PickingColor);\n}\n';
var Grid3DModel = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      POS: 10,
      NORMAL: 11
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      coverage,
      angle
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset],
      u_opacity: opacity || 1,
      u_coverage: coverage || 0.9,
      u_angle: angle || 0
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "heatmapGrid3d",
        vertexShader: grid_3d_vert,
        fragmentShader: grid_3d_frag,
        defines: _this2.getDefines(),
        triangulation: PointExtrudeTriangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: true
        }
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        shaderLocation: this.attributeLocation.SIZE,
        name: "a_Size",
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "normal",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Normal",
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "pos",
      // 顶点经纬度位置
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Pos",
        shaderLocation: this.attributeLocation.POS,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature) => {
          const coordinates = feature.coordinates;
          return [coordinates[0], coordinates[1], 0];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/heatmap/triangulation.js
function heatMap3DTriangulation(width, height) {
  const indices = [];
  const vertices = [];
  const uvs = [];
  const gridX1 = width + 1;
  const gridY1 = height + 1;
  const widthHalf = width / 2;
  const heightHalf = height / 2;
  for (let iy = 0; iy < gridY1; iy++) {
    const y = iy - heightHalf;
    for (let ix = 0; ix < gridX1; ix++) {
      const x = ix - widthHalf;
      vertices.push(x / widthHalf, -y / heightHalf, 0);
      uvs.push(ix / width);
      uvs.push(1 - iy / height);
    }
  }
  for (let iy = 0; iy < height; iy++) {
    for (let ix = 0; ix < width; ix++) {
      const a = ix + gridX1 * iy;
      const b = ix + gridX1 * (iy + 1);
      const c = ix + 1 + gridX1 * (iy + 1);
      const d = ix + 1 + gridX1 * iy;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  return {
    vertices,
    indices,
    uvs
  };
}

// node_modules/@antv/l7-layers/es/heatmap/models/heatmap.js
var heatmap_3d_frag = "layout(std140) uniform commonUniforms {\n  mat4 u_ViewProjectionMatrixUncentered;\n  mat4 u_InverseViewProjectionMatrix;\n  float u_opacity;\n  float u_common_uniforms_padding1;\n  float u_common_uniforms_padding2;\n  float u_common_uniforms_padding3;\n};\n\nuniform sampler2D u_texture;\nuniform sampler2D u_colorTexture;\n\nin vec2 v_texCoord;\nin float v_intensity;\nout vec4 outputColor;\n\nvoid main(){\n   \n    float intensity = texture(SAMPLER_2D(u_texture), v_texCoord).r;\n    vec4 color = texture(SAMPLER_2D(u_colorTexture),vec2(intensity, 0));\n    outputColor = color;\n    // gl_FragColor.a = color.a * smoothstep(0.1,0.2,intensity)* u_opacity;\n   outputColor.a = color.a * smoothstep(0.,0.1,intensity) * u_opacity;\n}\n";
var heatmap_3d_vert = 'layout(location = 0) in vec3 a_Position;\nlayout(location = 10) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  mat4 u_ViewProjectionMatrixUncentered;\n  mat4 u_InverseViewProjectionMatrix;\n  float u_opacity;\n  float u_common_uniforms_padding1;\n  float u_common_uniforms_padding2;\n  float u_common_uniforms_padding3;\n};\n\nuniform sampler2D u_texture;\nuniform sampler2D u_colorTexture;\n\nout vec2 v_texCoord;\nout float v_intensity;\n\nvec2 toBezier(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\n  float t2 = t * t;\n  float one_minus_t = 1.0 - t;\n  float one_minus_t2 = one_minus_t * one_minus_t;\n  return P0 * one_minus_t2 * one_minus_t +\n  P1 * 3.0 * t * one_minus_t2 +\n  P2 * 3.0 * t2 * one_minus_t +\n  P3 * t2 * t;\n}\nvec2 toBezier(float t, vec4 p) {\n  return toBezier(t, vec2(0.0, 0.0), vec2(p.x, p.y), vec2(p.z, p.w), vec2(1.0, 1.0));\n}\n\n#pragma include "projection"\n#pragma include "project"\n\nvoid main() {\n  v_texCoord = a_Uv;\n\n  vec2 pos = a_Uv * vec2(2.0) - vec2(1.0); // 将原本 0 -> 1 的 uv 转换为 -1 -> 1 的标准坐标空间（NDC）\n\n  vec4 p1 = vec4(pos, 0.0, 1.0); // x/y 平面上的点（z == 0）可以认为是三维上的点被投影到平面后的点\n  vec4 p2 = vec4(pos, 1.0, 1.0); // 平行于x/y平面、z==1 的平面上的点\n\n  vec4 inverseP1 = u_InverseViewProjectionMatrix * p1; // 根据视图投影矩阵的逆矩阵平面上的反算出三维空间中的点（p1平面上的点）\n  vec4 inverseP2 = u_InverseViewProjectionMatrix * p2;\n\n  inverseP1 = inverseP1 / inverseP1.w; // 归一化操作（归一化后为世界坐标）\n  inverseP2 = inverseP2 / inverseP2.w;\n\n  float zPos = (0.0 - inverseP1.z) / (inverseP2.z - inverseP1.z); // ??\n  vec4 position = inverseP1 + zPos * (inverseP2 - inverseP1);\n\n  vec4 b = vec4(0.5, 0.0, 1.0, 0.5);\n  float fh;\n\n  v_intensity = texture(SAMPLER_2D(u_texture), v_texCoord).r;\n  fh = toBezier(v_intensity, b).y;\n  gl_Position = u_ViewProjectionMatrixUncentered * vec4(position.xy, fh * project_pixel(50.0), 1.0);\n\n}\n';
var heatmap_frag = 'uniform sampler2D u_texture;        // 热力强度图\nuniform sampler2D u_colorTexture;   // 根据强度分布的色带\n\nlayout(std140) uniform commonUniforms {\n  float u_opacity;\n  float u_common_uniforms_padding1;\n  float u_common_uniforms_padding2;\n  float u_common_uniforms_padding3;\n};\nin vec2 v_texCoord;\nout vec4 outputColor;\n\n#pragma include "scene_uniforms"\n\nfloat getBlurIndusty() {\n    float vW = 2.0/ u_ViewportSize.x;\n    float vH = 2.0/ u_ViewportSize.y;\n    vec2 vUv = v_texCoord;\n    float i11 = texture(SAMPLER_2D(u_texture), vec2( vUv.x - 1.0 * vW, vUv.y + 1.0 * vH) ).r;\n    float i12 = texture(SAMPLER_2D(u_texture), vec2( vUv.x - 0.0 * vW, vUv.y + 1.0 * vH) ).r;\n    float i13 = texture(SAMPLER_2D(u_texture), vec2( vUv.x + 1.0 * vW, vUv.y + 1.0 * vH) ).r;\n\n    float i21 = texture(SAMPLER_2D(u_texture), vec2( vUv.x - 1.0 * vW, vUv.y) ).r;\n    float i22 = texture(SAMPLER_2D(u_texture), vec2( vUv.x , vUv.y) ).r;\n    float i23 = texture(SAMPLER_2D(u_texture), vec2( vUv.x + 1.0 * vW, vUv.y) ).r;\n\n    float i31 = texture(SAMPLER_2D(u_texture), vec2( vUv.x - 1.0 * vW, vUv.y-1.0*vH) ).r;\n    float i32 = texture(SAMPLER_2D(u_texture), vec2( vUv.x - 0.0 * vW, vUv.y-1.0*vH) ).r;\n    float i33 = texture(SAMPLER_2D(u_texture), vec2( vUv.x + 1.0 * vW, vUv.y-1.0*vH) ).r;\n\n    return(\n        i11 + \n        i12 + \n        i13 + \n        i21 + \n        i21 + \n        i22 + \n        i23 + \n        i31 + \n        i32 + \n        i33\n        )/9.0;\n}\n\n\nvoid main(){\n    // float intensity = texture(u_texture, v_texCoord).r;\n    float intensity = getBlurIndusty();\n    vec4 color = texture(SAMPLER_2D(u_colorTexture), vec2(intensity, 0.0));\n    outputColor = color;\n    outputColor.a = color.a * smoothstep(0.,0.1,intensity) * u_opacity;\n}\n';
var heatmap_vert = 'layout(location = 0) in vec3 a_Position;\nlayout(location = 10) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  float u_opacity;\n  float u_common_uniforms_padding1;\n  float u_common_uniforms_padding2;\n  float u_common_uniforms_padding3;\n};\n\n#pragma include "scene_uniforms"\n\nout vec2 v_texCoord;\nvoid main() {\n  v_texCoord = a_Uv;\n  #ifdef VIEWPORT_ORIGIN_TL\n  v_texCoord.y = 1.0 - v_texCoord.y;\n  #endif\n\n  gl_Position = vec4(a_Position.xy, 0, 1.0);\n}\n';
var heatmap_framebuffer_frag = "layout(std140) uniform commonUniforms {\n  float u_radius;\n  float u_intensity;\n  float u_common_uniforms_padding1;\n  float u_common_uniforms_padding2;\n};\n\nin vec2 v_extrude;\nin float v_weight;\nout vec4 outputColor;\n#define GAUSS_COEF  0.3989422804014327\n\nvoid main(){\n    float d = -0.5 * 3.0 * 3.0 * dot(v_extrude, v_extrude);\n    float val = v_weight * u_intensity * GAUSS_COEF * exp(d);\n    outputColor = vec4(val, 1., 1., 1.);\n}\n";
var heatmap_framebuffer_vert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_DIR) in vec2 a_Dir;\n\nlayout(std140) uniform commonUniforms {\n  float u_radius;\n  float u_intensity;\n  float u_common_uniforms_padding1;\n  float u_common_uniforms_padding2;\n};\n\nout vec2 v_extrude;\nout float v_weight;\n\n#define GAUSS_COEF (0.3989422804014327)\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  vec3 picking_color_placeholder = u_PickingColor;\n\n  v_weight = a_Size;\n  float ZERO = 1.0 / 255.0 / 16.0;\n  float extrude_x = a_Dir.x * 2.0 - 1.0;\n  float extrude_y = a_Dir.y * 2.0 - 1.0;\n  vec2 extrude_dir = normalize(vec2(extrude_x, extrude_y));\n  float S = sqrt(-2.0 * log(ZERO / a_Size / u_intensity / GAUSS_COEF)) / 2.5;\n  v_extrude = extrude_dir * S;\n\n  vec2 offset = project_pixel(v_extrude * u_radius);\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n\n}\n';
var {
  isEqual: isEqual2
} = lodashUtil;
var HeatMapModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "colorTexture", void 0);
    _defineProperty(this, "heatmapFramerBuffer", void 0);
    _defineProperty(this, "heatmapTexture", void 0);
    _defineProperty(this, "intensityModel", void 0);
    _defineProperty(this, "colorModel", void 0);
    _defineProperty(this, "shapeType", void 0);
    _defineProperty(this, "preRampColors", void 0);
    _defineProperty(this, "colorModelUniformBuffer", []);
    _defineProperty(this, "heat3DModelUniformBuffer", []);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      UV: 10,
      DIR: 11
    });
  }
  prerender() {
    const {
      clear,
      useFramebuffer
    } = this.rendererService;
    useFramebuffer(this.heatmapFramerBuffer, () => {
      clear({
        color: [0, 0, 0, 0],
        depth: 1,
        stencil: 0,
        framebuffer: this.heatmapFramerBuffer
      });
      this.drawIntensityMode();
    });
  }
  render(options) {
    const {
      rampColors
    } = this.layer.getLayerConfig();
    if (!isEqual2(this.preRampColors, rampColors)) {
      this.updateColorTexture();
    }
    this.shapeType === "heatmap" ? this.drawHeatMap(options) : this.draw3DHeatMap(options);
  }
  getUninforms() {
    throw new Error("Method not implemented.");
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      var _shapeAttr$scale;
      const {
        createFramebuffer,
        getViewportSize,
        createTexture2D
      } = _this.rendererService;
      const shapeAttr = _this.styleAttributeService.getLayerStyleAttribute("shape");
      const shapeType = (shapeAttr === null || shapeAttr === void 0 || (_shapeAttr$scale = shapeAttr.scale) === null || _shapeAttr$scale === void 0 ? void 0 : _shapeAttr$scale.field) || "heatmap";
      _this.shapeType = shapeType;
      _this.intensityModel = yield _this.buildHeatMapIntensity();
      _this.colorModel = shapeType === "heatmap" ? _this.buildHeatmap() : _this.build3dHeatMap();
      const {
        width,
        height
      } = getViewportSize();
      _this.heatmapTexture = createTexture2D({
        width: Math.floor(width / 4),
        height: Math.floor(height / 4),
        wrapS: gl.CLAMP_TO_EDGE,
        wrapT: gl.CLAMP_TO_EDGE,
        min: gl.LINEAR,
        mag: gl.LINEAR,
        usage: TextureUsage.RENDER_TARGET
      });
      _this.heatmapFramerBuffer = createFramebuffer({
        color: _this.heatmapTexture,
        depth: true,
        width: Math.floor(width / 4),
        height: Math.floor(height / 4)
      });
      _this.updateColorTexture();
      return [_this.intensityModel, _this.colorModel];
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      return _this2.initModels();
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "dir",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Dir",
        shaderLocation: this.attributeLocation.DIR,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 1
          } = feature;
          return [size2];
        }
      }
    });
  }
  /**
   * 热力图密度图
   */
  buildHeatMapIntensity() {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      _this3.uniformBuffers = [_this3.rendererService.createBuffer({
        // opacity
        data: new Float32Array(4).fill(0),
        // 长度需要大于等于 4
        isUBO: true
      })];
      _this3.layer.triangulation = HeatmapTriangulation;
      const model = yield _this3.layer.buildLayerModel({
        moduleName: "heatmapIntensity",
        vertexShader: heatmap_framebuffer_vert,
        fragmentShader: heatmap_framebuffer_frag,
        triangulation: HeatmapTriangulation,
        defines: _this3.getDefines(),
        depth: {
          enable: false
        },
        cull: {
          enable: true,
          face: gl.FRONT
        }
      });
      return model;
    })();
  }
  buildHeatmap() {
    this.shaderModuleService.registerModule("heatmapColor", {
      vs: heatmap_vert,
      fs: heatmap_frag
    });
    this.colorModelUniformBuffer = [this.rendererService.createBuffer({
      // opacity
      data: new Float32Array(4).fill(0),
      // 长度需要大于等于 4
      isUBO: true
    })];
    const {
      vs,
      fs,
      uniforms
    } = this.shaderModuleService.getModule("heatmapColor");
    const {
      createAttribute,
      createElements,
      createBuffer: createBuffer2,
      createModel
    } = this.rendererService;
    return createModel({
      vs,
      fs,
      uniformBuffers: [...this.colorModelUniformBuffer, ...this.rendererService.uniformBuffers],
      attributes: {
        a_Position: createAttribute({
          shaderLocation: this.attributeLocation.POSITION,
          buffer: createBuffer2({
            data: [-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
            type: gl.FLOAT
          }),
          size: 3
        }),
        a_Uv: createAttribute({
          shaderLocation: this.attributeLocation.UV,
          buffer: createBuffer2({
            data: [0, 1, 1, 1, 0, 0, 1, 0],
            type: gl.FLOAT
          }),
          size: 2
        })
      },
      uniforms: _objectSpread2({}, uniforms),
      depth: {
        enable: false
      },
      elements: createElements({
        data: [0, 2, 1, 2, 3, 1],
        type: gl.UNSIGNED_INT,
        count: 6
      })
    });
  }
  build3dHeatMap() {
    const {
      getViewportSize
    } = this.rendererService;
    const {
      width,
      height
    } = getViewportSize();
    const triangulation = heatMap3DTriangulation(width / 4, height / 4);
    this.shaderModuleService.registerModule("heatmap3dColor", {
      vs: heatmap_3d_vert,
      fs: heatmap_3d_frag
    });
    this.heat3DModelUniformBuffer = [this.rendererService.createBuffer({
      // opacity
      data: new Float32Array(16 * 2 + 4).fill(0),
      // 长度需要大于等于 4
      isUBO: true
    })];
    const {
      vs,
      fs,
      uniforms
    } = this.shaderModuleService.getModule("heatmap3dColor");
    const {
      createAttribute,
      createElements,
      createBuffer: createBuffer2,
      createModel
    } = this.rendererService;
    return createModel({
      vs,
      fs,
      attributes: {
        a_Position: createAttribute({
          shaderLocation: this.attributeLocation.POSITION,
          buffer: createBuffer2({
            data: triangulation.vertices,
            type: gl.FLOAT
          }),
          size: 3
        }),
        a_Uv: createAttribute({
          shaderLocation: this.attributeLocation.UV,
          buffer: createBuffer2({
            data: triangulation.uvs,
            type: gl.FLOAT
          }),
          size: 2
        })
      },
      primitive: gl.TRIANGLES,
      uniformBuffers: [...this.heat3DModelUniformBuffer, ...this.rendererService.uniformBuffers],
      uniforms: _objectSpread2({}, uniforms),
      depth: {
        enable: true
      },
      blend: {
        enable: true,
        func: {
          srcRGB: gl.SRC_ALPHA,
          srcAlpha: 1,
          dstRGB: gl.ONE_MINUS_SRC_ALPHA,
          dstAlpha: 1
        }
      },
      elements: createElements({
        data: triangulation.indices,
        type: gl.UNSIGNED_INT,
        count: triangulation.indices.length
      })
    });
  }
  // 绘制密度图
  drawIntensityMode() {
    var _this$intensityModel;
    const {
      intensity = 10,
      radius = 5
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_radius: radius,
      u_intensity: intensity
    };
    this.uniformBuffers[0].subData({
      offset: 0,
      data: [radius, intensity]
    });
    this.layerService.beforeRenderData(this.layer);
    this.layer.hooks.beforeRender.call();
    (_this$intensityModel = this.intensityModel) === null || _this$intensityModel === void 0 || _this$intensityModel.draw({
      uniforms: commonOptions,
      blend: {
        enable: true,
        func: {
          srcRGB: gl.ONE,
          srcAlpha: 1,
          dstRGB: gl.ONE,
          dstAlpha: 1
        }
      },
      stencil: {
        enable: false,
        mask: 255,
        func: {
          cmp: 514,
          // gl.EQUAL,
          ref: 1,
          mask: 255
        }
      }
    });
    this.layer.hooks.afterRender.call();
  }
  drawHeatMap(options) {
    var _this$colorModel;
    const {
      opacity = 1
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_opacity: opacity,
      u_colorTexture: this.colorTexture,
      u_texture: this.heatmapFramerBuffer
    };
    const textures = [this.heatmapTexture, this.colorTexture];
    this.colorModelUniformBuffer[0].subData({
      offset: 0,
      data: [opacity]
    });
    (_this$colorModel = this.colorModel) === null || _this$colorModel === void 0 || _this$colorModel.draw({
      uniforms: commonOptions,
      textures,
      blend: this.getBlend(),
      stencil: this.getStencil(options)
    });
  }
  draw3DHeatMap(options) {
    var _this$colorModel2;
    const {
      opacity = 1
    } = this.layer.getLayerConfig();
    const invert = mat4_exports.create();
    mat4_exports.invert(invert, this.cameraService.getViewProjectionMatrixUncentered());
    const commonOptions = {
      u_opacity: opacity,
      u_colorTexture: this.colorTexture,
      u_texture: this.heatmapFramerBuffer,
      u_ViewProjectionMatrixUncentered: this.cameraService.getViewProjectionMatrixUncentered(),
      u_InverseViewProjectionMatrix: [...invert]
    };
    this.heat3DModelUniformBuffer[0].subData({
      offset: 0,
      data: [...commonOptions.u_ViewProjectionMatrixUncentered, ...commonOptions.u_InverseViewProjectionMatrix, opacity]
    });
    const textures = [this.heatmapTexture, this.colorTexture];
    (_this$colorModel2 = this.colorModel) === null || _this$colorModel2 === void 0 || _this$colorModel2.draw({
      uniforms: commonOptions,
      textures,
      blend: {
        enable: true,
        func: {
          srcRGB: gl.SRC_ALPHA,
          srcAlpha: 1,
          dstRGB: gl.ONE_MINUS_SRC_ALPHA,
          dstAlpha: 1
        }
      },
      stencil: this.getStencil(options)
    });
  }
  updateColorTexture() {
    const {
      createTexture2D
    } = this.rendererService;
    if (this.texture) {
      this.texture.destroy();
    }
    const {
      rampColors
    } = this.layer.getLayerConfig();
    const imageData = generateColorRamp(rampColors);
    this.colorTexture = createTexture2D({
      data: imageData.data,
      usage: TextureUsage.SAMPLED,
      width: imageData.width,
      height: imageData.height,
      wrapS: gl.CLAMP_TO_EDGE,
      wrapT: gl.CLAMP_TO_EDGE,
      min: gl.NEAREST,
      mag: gl.NEAREST,
      flipY: false,
      unorm: true
    });
    this.preRampColors = rampColors;
  }
};

// node_modules/@antv/l7-layers/es/heatmap/models/hexagon.js
var hexagon_frag = 'in vec4 v_color;\n\n#pragma include "picking"\nout vec4 outputColor;\nvoid main() {\n  outputColor = v_color;\n  outputColor = filterColor(outputColor);\n}\n';
var hexagon_vert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_POS) in vec3 a_Pos;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_radius;\n  float u_opacity;\n  float u_coverage;\n  float u_angle;\n};\n\nout vec4 v_color;\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nvoid main() {\n  v_color = a_Color;\n  v_color.a *= u_opacity;\n\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\n  vec2 offset = vec2(a_Position.xy * u_radius * rotationMatrix * u_coverage);\n  vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\n\n  vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0.0, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n';
var HexagonModel = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      POS: 9
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      coverage,
      angle
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset],
      u_opacity: opacity || 1,
      u_coverage: coverage || 0.9,
      u_angle: angle || 0
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "heatmapHexagon",
        vertexShader: hexagon_vert,
        fragmentShader: hexagon_frag,
        defines: _this2.getDefines(),
        triangulation: HeatmapGridTriangulation,
        depth: {
          enable: false
        },
        primitive: gl.TRIANGLES
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "pos",
      // 顶点经纬度位置
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Pos",
        shaderLocation: this.attributeLocation.POS,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature) => {
          const coordinates = feature.coordinates;
          return [coordinates[0], coordinates[1], 0];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/heatmap/models/index.js
var HeatMapModels = {
  heatmap: HeatMapModel,
  heatmap3d: HeatMapModel,
  grid: GridModel,
  grid3d: Grid3DModel,
  hexagon: HexagonModel
};
var models_default2 = HeatMapModels;

// node_modules/@antv/l7-layers/es/heatmap/index.js
var HeatMapLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "HeatMapLayer");
  }
  buildModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const shape = _this.getModelType();
      _this.layerModel = new models_default2[shape](_this);
      yield _this.initLayerModels();
    })();
  }
  prerender() {
    const shape = this.getModelType();
    if (shape === "heatmap") {
      if (this.layerModel) {
        this.layerModel.prerender();
      }
    }
  }
  renderModels(options = {}) {
    const shape = this.getModelType();
    if (shape === "heatmap") {
      if (this.layerModel) {
        this.layerModel.render(options);
      }
      return this;
    }
    if (this.encodeDataLength <= 0 && !this.forceRender) {
      return this;
    }
    this.hooks.beforeRender.call();
    this.models.forEach((model) => model.draw({
      uniforms: this.layerModel.getUninforms(),
      blend: this.layerModel.getBlend(),
      stencil: this.layerModel.getStencil(options)
    }));
    this.hooks.afterRender.call();
    return this;
  }
  updateModelData(data) {
    if (data.attributes && data.elements) {
      this.models[0].updateAttributesAndElements(data.attributes, data.elements);
    } else {
      console.warn("data error");
    }
  }
  getModelType() {
    var _shapeAttribute$scale;
    const shapeAttribute = this.styleAttributeService.getLayerStyleAttribute("shape");
    const {
      shape3d
    } = this.getLayerConfig();
    const source = this.getSource();
    const sourceType = source.data.type;
    const shape = (shapeAttribute === null || shapeAttribute === void 0 || (_shapeAttribute$scale = shapeAttribute.scale) === null || _shapeAttribute$scale === void 0 ? void 0 : _shapeAttribute$scale.field) || "heatmap";
    if (shape === "heatmap" || shape === "heatmap3d") {
      return "heatmap";
    }
    if (sourceType === "hexagon") {
      return (shape3d === null || shape3d === void 0 ? void 0 : shape3d.indexOf(shape)) === -1 ? "hexagon" : "grid3d";
    }
    if (sourceType === "grid") {
      return (shape3d === null || shape3d === void 0 ? void 0 : shape3d.indexOf(shape)) === -1 ? "grid" : "grid3d";
    }
    return "heatmap";
  }
  getLegend(name) {
    if (this.getModelType() === "heatmap") {
      if (name !== "color")
        return {
          type: void 0,
          field: void 0,
          items: []
        };
      const rampColors = this.getLayerConfig().rampColors;
      return rampColor2legend(rampColors, name);
    } else {
      return super.getLegend(name);
    }
  }
};

// node_modules/@antv/l7-layers/es/image/models/image.js
var ImageFrag = "uniform sampler2D u_texture;\nlayout(std140) uniform commonUniforms {\n    float u_opacity:1.0;\n    float u_brightness:1.0;\n    float u_contrast:1.0;\n    float u_saturation:1.0;\n    float u_gamma:1.0;\n};\n\nin vec2 v_texCoord;\nout vec4 outputColor;\nvec3 setContrast(vec3 rgb, float contrast) {\n  vec3 color = mix(vec3(0.5), rgb, contrast);\n  color = clamp(color, 0.0, 1.0);\n  return color;\n}\nvec3 setSaturation(vec3 rgb, float adjustment) {\n  const vec3 grayVector = vec3(0.2125, 0.7154, 0.0721);\n  vec3 intensity = vec3(dot(rgb, grayVector));\n  vec3 color = mix(intensity, rgb, adjustment);\n  color = clamp(color, 0.0, 1.0);\n  return color;\n}\nvoid main() {\n  vec4 color = texture(SAMPLER_2D(u_texture),vec2(v_texCoord.x,v_texCoord.y));\n  //brightness\n  color.rgb = mix(vec3(0.0, 0.0, 0.0), color.rgb, u_brightness);\n  //contrast\n  color.rgb = setContrast(color.rgb, u_contrast);\n  // saturation\n  color.rgb = setSaturation(color.rgb, u_saturation);\n  // gamma\n  color.rgb = pow(color.rgb, vec3(u_gamma));\n  outputColor = color;\n  outputColor.a *= u_opacity;\n  if(outputColor.a < 0.01)\n    discard;\n}\n";
var ImageVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n    float u_opacity:1.0;\n    float u_brightness:1.0;\n    float u_contrast:1.0;\n    float u_saturation:1.0;\n    float u_gamma:1.0;\n};\n\nout vec2 v_texCoord;\n#pragma include "projection"\n\nvoid main() {\n  v_texCoord = a_Uv;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0.0, 1.0));\n}\n';
var ImageModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      UV: 9
    });
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      brightness,
      contrast,
      saturation,
      gamma: gamma2
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_opacity: defaultValue(opacity, 1),
      u_brightness: defaultValue(brightness, 1),
      u_contrast: defaultValue(contrast, 1),
      u_saturation: defaultValue(saturation, 1),
      u_gamma: defaultValue(gamma2, 1)
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      yield _this.loadTexture();
      return _this.buildModels();
    })();
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
  }
  loadTexture() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        createTexture2D
      } = _this2.rendererService;
      const source = _this2.layer.getSource();
      const imageData = yield source.data.images;
      _this2.texture = createTexture2D({
        data: imageData[0],
        width: imageData[0].width,
        height: imageData[0].height,
        mag: gl.LINEAR,
        min: gl.LINEAR
      });
    })();
  }
  buildModels() {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      _this3.initUniformsBuffer();
      const model = yield _this3.layer.buildLayerModel({
        moduleName: "rasterImage",
        vertexShader: ImageVert,
        fragmentShader: ImageFrag,
        defines: _this3.getDefines(),
        triangulation: RasterImageTriangulation,
        primitive: gl.TRIANGLES,
        blend: {
          // Tip: 优化显示效果
          enable: true
        },
        depth: {
          enable: false
        },
        pickingEnabled: false
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/image/models/index.js
var ImageModels = {
  image: ImageModel
};
var models_default3 = ImageModels;

// node_modules/@antv/l7-layers/es/image/index.js
var ImageLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "ImageLayer");
  }
  buildModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const modelType = _this.getModelType();
      _this.layerModel = new models_default3[modelType](_this);
      yield _this.initLayerModels();
    })();
  }
  getDefaultConfig() {
    const type = this.getModelType();
    const defaultConfig = {
      image: {}
    };
    return defaultConfig[type];
  }
  getModelType() {
    return "image";
  }
};

// node_modules/@antv/l7-layers/es/line/models/arc.js
var arc_line_frag = '\n#define Animate 0.0\n#define LineTexture 1.0\nuniform sampler2D u_texture;\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_dash_array;\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float segmentNumber;\n  float u_lineDir: 1.0;\n  float u_icon_step: 100;\n  float u_line_texture: 0.0;\n  float u_textureBlend;\n  float u_blur : 0.9;\n  float u_line_type: 0.0;\n  float u_time;\n  float u_linearColor: 0.0;\n};\n\nin vec4 v_color;\nin vec2 v_iconMapUV;\nin vec4 v_lineData;\n//dash\nin vec4 v_dash_array;\nin float v_distance_ratio;\n\nout vec4 outputColor;\n#pragma include "picking"\n\nvoid main() {\n  if(u_dash_array!=vec4(0.0)){\n    float dashLength = mod(v_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(!(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z))) {\n      discard;\n    };\n  }\n  float animateSpeed = 0.0; // 运动速度\n  outputColor = v_color;\n  if(u_animate.x == Animate && u_line_texture != LineTexture) {\n      animateSpeed = u_time / u_animate.y;\n      float alpha =1.0 - fract( mod(1.0- v_lineData.b, u_animate.z)* (1.0/ u_animate.z) + u_time / u_animate.y);\n      alpha = (alpha + u_animate.w -1.0) / u_animate.w;\n      // alpha = smoothstep(0., 1., alpha);\n      alpha = clamp(alpha, 0.0, 1.0);\n      outputColor.a *= alpha;\n  }\n\n  // 当存在贴图时在底色上贴上贴图\n  if(u_line_texture == LineTexture) { // while load texture\n    float arcRadio = smoothstep( 0.0, 1.0, (v_lineData.r / segmentNumber));\n    // float arcRadio = smoothstep( 0.0, 1.0, d_distance_ratio);\n\n    float count = v_lineData.g; // 贴图在弧线上重复的数量\n\n    float time = 0.0;\n    if(u_animate.x == Animate) {\n      time = u_time / u_animate.y;\n    }\n    float redioCount = arcRadio * count;\n\n    float u = fract(redioCount - time);\n    float v = v_lineData.a; // 横向 v\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n\n    vec4 pattern = texture(SAMPLER_2D(u_texture), uv);\n\n    if(u_animate.x == Animate) {\n      float currentPlane = floor(redioCount - time);\n      float textureStep = floor(count * u_animate.z);\n      float a = mod(currentPlane, textureStep);\n      if(a < textureStep - 1.0) {\n        pattern = vec4(0.0);\n      }\n    }\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      outputColor = filterColor(outputColor + pattern);\n    } else { // replace\n        pattern.a *= v_color.a;\n        if(outputColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        outputColor = filterColor(pattern);\n    }\n    \n  } else {\n     outputColor = filterColor(outputColor);\n  }\n}';
var arc_line_vert = '#define Animate (0.0)\n#define LineTexture (1.0)\n\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_INSTANCE) in vec4 a_Instance;\nlayout(location = ATTRIBUTE_LOCATION_INSTANCE_64LOW) in vec4 a_Instance64Low;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_iconMapUV;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_dash_array;\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float segmentNumber;\n  float u_lineDir: 1.0;\n  float u_icon_step: 100;\n  float u_line_texture: 0.0;\n  float u_textureBlend;\n  float u_blur : 0.9;\n  float u_line_type: 0.0;\n  float u_time;\n  float u_linearColor: 0.0;\n};\n\nout vec4 v_color;\nout vec2 v_iconMapUV;\nout vec4 v_lineData;\n//dash\nout vec4 v_dash_array;\nout float v_distance_ratio;\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1.0 - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\nvec2 midPoint(vec2 source, vec2 target, float arcThetaOffset) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = arcThetaOffset;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2 * cos(theta2) + source.x, r2 * sin(theta2) + source.y);\n  if (u_lineDir == 1.0) {\n    // 正向\n    return mid;\n  } else {\n    // 逆向\n    // (mid + vmin)/2 = (s + t)/2\n    vec2 vmid = source + target - mid;\n    return vmid;\n  }\n  // return mid;\n}\nfloat getSegmentRatio(float index) {\n  // dash: index / (segmentNumber - 1.);\n  // normal: smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\n  return smoothstep(0.0, 1.0, index / (segmentNumber - 1.0));\n  //  return index / (segmentNumber - 1.);\n}\nvec2 interpolate(vec2 source, vec2 target, float t, float arcThetaOffset) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  vec2 mid = midPoint(source, target, arcThetaOffset);\n  vec3 x = vec3(source.x, mid.x, target.x);\n  vec3 y = vec3(source.y, mid.y, target.y);\n  return vec2(bezier3(x, t), bezier3(y, t));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n   return dir_screenspace.xy * sign(offset_direction);\n}\n\nvoid main() {\n  //vs中计算渐变色\n  if (u_linearColor == 1.0) {\n    float d_segmentIndex = a_Position.x + 1.0; // 当前顶点在弧线中所处的分段位置\n    v_color = mix(u_sourceColor, u_targetColor, d_segmentIndex / segmentNumber);\n  } else {\n    v_color = a_Color;\n  }\n  v_color.a = v_color.a * opacity;\n\n  vec2 source_world = a_Instance.rg; // 起始点\n  vec2 target_world = a_Instance.ba; // 终点\n\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  // 计算 dashArray 和 distanceRatio 输出到片元\n  float total_Distance = pixelDistance(source_world, target_world) / 2.0 * PI;\n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / total_Distance;\n  v_distance_ratio = segmentIndex / segmentNumber;\n\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  float d_distance_ratio;\n\n  if(u_animate.x == Animate) {\n      d_distance_ratio = segmentIndex / segmentNumber;\n      if(u_lineDir != 1.0) {\n        d_distance_ratio = 1.0 - d_distance_ratio;\n      }\n  }\n\n  v_lineData.b = d_distance_ratio;\n\n  vec4 source = project_position(vec4(source_world, 0, 1.), a_Instance64Low.xy);\n  vec4 target = project_position(vec4(target_world, 0, 1.), a_Instance64Low.zw);\n\n  vec2 currPos = interpolate(source.xy, target.xy, segmentRatio, thetaOffset);\n  vec2 nextPos = interpolate(source.xy, target.xy, nextSegmentRatio, thetaOffset);\n\n  vec2 offset = project_pixel(\n    getExtrusionOffset((nextPos.xy - currPos.xy) * indexDir, a_Position.y)\n  );\n\n  float d_segmentIndex = a_Position.x + 1.0; // 当前顶点在弧线中所处的分段位置\n  v_lineData.r = d_segmentIndex;\n\n  if(LineTexture == u_line_texture) { // 开启贴图模式\n    float arcDistrance = length(source - target); // 起始点和终点的距离\n    arcDistrance = project_pixel(arcDistrance);\n\n    v_iconMapUV = a_iconMapUV;\n\n    float pixelLen = project_pixel_texture(u_icon_step); // 贴图沿弧线方向的长度 - 随地图缩放改变\n    float texCount = floor(arcDistrance / pixelLen); // 贴图在弧线上重复的数量\n    v_lineData.g = texCount;\n\n    float lineOffsetWidth = length(offset + offset * sign(a_Position.y)); // 线横向偏移的距离\n    float linePixelSize = project_pixel(a_Size); // 定点位置偏移\n    v_lineData.a = lineOffsetWidth / linePixelSize; // 线图层贴图部分的 v 坐标值\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(currPos.xy + offset, 0, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n';
var lineStyleObj = {
  solid: 0,
  dash: 1
};
var ArcModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "updateTexture", () => {
      const {
        createTexture2D
      } = this.rendererService;
      if (this.texture) {
        this.texture.update({
          data: this.iconService.getCanvas()
        });
        this.layer.render();
        return;
      }
      this.texture = createTexture2D({
        data: this.iconService.getCanvas(),
        mag: gl.NEAREST,
        min: gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: this.iconService.canvasHeight || 128
      });
      this.textures = [this.texture];
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      INSTANCE: 10,
      INSTANCE_64LOW: 11,
      UV: 12,
      THETA_OFFSET: 13
    });
  }
  getCommonUniformsInfo() {
    const {
      sourceColor,
      targetColor,
      textureBlend = "normal",
      lineType = "solid",
      dashArray = [10, 5],
      forward = true,
      lineTexture = false,
      iconStep = 100,
      segmentNumber = 30
      // thetaOffset = 0.314,
    } = this.layer.getLayerConfig();
    const {
      animateOption
    } = this.layer.getLayerConfig();
    let u_dash_array = dashArray;
    if (lineType !== "dash") {
      u_dash_array = [0, 0];
    }
    if (u_dash_array.length === 2) {
      u_dash_array.push(0, 0);
    }
    let useLinearColor = 0;
    let sourceColorArr = [0, 0, 0, 0];
    let targetColorArr = [0, 0, 0, 0];
    if (sourceColor && targetColor) {
      sourceColorArr = rgb2arr(sourceColor);
      targetColorArr = rgb2arr(targetColor);
      useLinearColor = 1;
    }
    if (this.rendererService.getDirty()) {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();
    }
    const commonOptions = {
      u_animate: this.animateOption2Array(animateOption),
      u_dash_array,
      u_sourceColor: sourceColorArr,
      u_targetColor: targetColorArr,
      u_textSize: [1024, this.iconService.canvasHeight || 128],
      segmentNumber,
      u_lineDir: forward ? 1 : -1,
      u_icon_step: iconStep,
      u_line_texture: lineTexture ? 1 : 0,
      // 传入线的标识
      u_textureBlend: textureBlend === "normal" ? 0 : 1,
      u_blur: 0.9,
      u_line_type: lineStyleObj[lineType || "solid"],
      u_time: this.layer.getLayerAnimateTime() || 0,
      // // 纹理支持参数
      // u_texture: this.texture, // 贴图
      // 渐变色支持参数
      u_linearColor: useLinearColor
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  // public getAnimateUniforms(): IModelUniform {
  //   const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;
  //   return {
  //     u_animate: this.animateOption2Array(animateOption as IAnimateOption),
  //     u_time: this.layer.getLayerAnimateTime(),
  //   };
  // }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.updateTexture();
      _this.iconService.on("imageUpdate", _this.updateTexture);
      return _this.buildModels();
    })();
  }
  clearModels() {
    var _this$texture2;
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    this.iconService.off("imageUpdate", this.updateTexture);
  }
  getShaders() {
    return {
      frag: arc_line_frag,
      vert: arc_line_vert,
      type: ""
    };
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const {
        segmentNumber = 30
      } = _this2.layer.getLayerConfig();
      const {
        frag,
        vert,
        type
      } = _this2.getShaders();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "lineArc2d" + type,
        vertexShader: vert,
        fragmentShader: frag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation: LineArcTriangulation,
        depth: {
          enable: false
        },
        styleOption: {
          segmentNumber
        }
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 1
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "instance",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Instance",
        shaderLocation: this.attributeLocation.INSTANCE,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4], vertex[5], vertex[6]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "instance64Low",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Instance64Low",
        shaderLocation: this.attributeLocation.INSTANCE_64LOW,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          return [fp64LowPart(vertex[3]), fp64LowPart(vertex[4]), fp64LowPart(vertex[5]), fp64LowPart(vertex[6])];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_iconMapUV",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature) => {
          const iconMap = this.iconService.getIconMap();
          const {
            texture
          } = feature;
          const {
            x,
            y
          } = iconMap[texture] || {
            x: 0,
            y: 0
          };
          return [x, y];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "thetaOffset",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_ThetaOffset",
        shaderLocation: this.attributeLocation.THETA_OFFSET,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            thetaOffset: op = 1
          } = feature;
          return [op];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/line/models/arc_3d.js
var arc3d_line_frag = '#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\n\nuniform sampler2D u_texture;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_dash_array: [10.0, 5., 0, 0];\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float u_globel;\n  float u_globel_radius;\n  float u_global_height: 10;\n  float segmentNumber;\n  float u_line_type: 0.0;\n  float u_icon_step: 100;\n  float u_line_texture: 0.0;\n  float u_textureBlend;\n  float u_time;\n  float u_linearColor: 0.0;\n};\n\nin vec4 v_color;\nin vec4 v_dash_array;\nin float v_segmentIndex;\nin vec2 v_iconMapUV;\nin vec4 v_line_data;\n\nout vec4 outputColor;\n\n#pragma include "picking"\n\nvoid main() {\n  float animateSpeed = 0.0; // 运动速度\n  float d_distance_ratio = v_line_data.g; // 当前点位距离占线总长的比例\n  outputColor = v_color;\n\n  if(u_line_type == LineTypeDash) {\n    float flag = 0.;\n    float dashLength = mod(d_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z)) {\n      flag = 1.;\n    }\n    outputColor.a *=flag;\n  }\n\n  if(u_animate.x == Animate && u_line_texture != LineTexture) {\n      animateSpeed = u_time / u_animate.y;\n      float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_animate.z)* (1.0/ u_animate.z) + u_time / u_animate.y);\n\n      alpha = (alpha + u_animate.w -1.0) / u_animate.w;\n      // alpha = smoothstep(0., 1., alpha);\n      alpha = clamp(alpha, 0.0, 1.0);\n      outputColor.a *= alpha;\n\n      // u_animate\n      // x enable\n      // y duration\n      // z interval\n      // w trailLength\n  }\n\n  if(u_line_texture == LineTexture && u_line_type != LineTypeDash) { // while load texture\n    // float arcRadio = smoothstep( 0.0, 1.0, (v_segmentIndex / segmentNumber));\n    float arcRadio = v_segmentIndex / (segmentNumber - 1.0);\n    float count = v_line_data.b; // // 贴图在弧线上重复的数量\n\n    float time = 0.0;\n    if(u_animate.x == Animate) {\n      time = u_time / u_animate.y;\n    }\n    float redioCount = arcRadio * count;\n\n    float u = fract(redioCount - time);\n\n    float v = v_line_data.a;  // 线图层贴图部分的 v 坐标值\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n    vec4 pattern = texture(SAMPLER_2D(u_texture), uv);\n\n    if(u_animate.x == Animate) {\n      float currentPlane = floor(redioCount - time);\n      float textureStep = floor(count * u_animate.z);\n      float a = mod(currentPlane, textureStep);\n      if(a < textureStep - 1.0) {\n        pattern = vec4(0.0);\n      }\n    }\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      outputColor = filterColor(outputColor + pattern);\n    } else { // replace\n        pattern.a *= v_color.a;\n        if(outputColor.a <= 0.0) {\n          pattern.a = 0.0;\n          discard;\n        } else {\n          outputColor = filterColor(pattern);\n        }\n    }\n\n  } else {\n    outputColor = filterColor(outputColor);\n  }\n}\n';
var arc3d_line_vert = '#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\n\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_INSTANCE) in vec4 a_Instance;\nlayout(location = ATTRIBUTE_LOCATION_INSTANCE_64LOW) in vec4 a_Instance64Low;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_iconMapUV;\n\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_dash_array: [10.0, 5., 0, 0];\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float u_globel;\n  float u_globel_radius;\n  float u_global_height: 10;\n  float segmentNumber;\n  float u_line_type: 0.0;\n  float u_icon_step: 100;\n  float u_line_texture: 0.0;\n  float u_textureBlend;\n  float u_time;\n  float u_linearColor: 0.0;\n};\nout vec4 v_color;\nout vec4 v_dash_array;\nout float v_segmentIndex;\nout vec2 v_iconMapUV;\nout vec4 v_line_data;\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nfloat maps (float value, float start1, float stop1, float start2, float stop2) {\n  return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (segmentNumber - 1.0));\n}\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertex_height = paraboloid(source, target, segmentRatio);\n\n  return vec3(\n    mix(source, target, segmentRatio),\n    sqrt(max(0.0, vertex_height))\n  );\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  return dir_screenspace.xy * sign(offset_direction);\n}\n\nfloat torad(float deg) {\n  return (deg / 180.0) * acos(-1.0);\n}\n\nvec3 lglt2xyz(vec2 lnglat) {\n  float pi = 3.1415926;\n  // + Math.PI/2 是为了对齐坐标\n  float lng = torad(lnglat.x) + pi / 2.0;\n  float lat = torad(lnglat.y);\n\n  // 手动增加一些偏移，减轻面的冲突\n  float radius = u_globel_radius;\n\n  float z = radius * cos(lat) * cos(lng);\n  float x = radius * cos(lat) * sin(lng);\n  float y = radius * sin(lat);\n  return vec3(x, y, z);\n}\n\nvoid main() {\n  //vs中计算渐变色\n  if(u_linearColor==1.0){\n    float d_segmentIndex = a_Position.x + 1.0; // 当前顶点在弧线中所处的分段位置\n    v_color = mix(u_sourceColor, u_targetColor, d_segmentIndex/segmentNumber);\n  }\n  else{\n    v_color = a_Color;\n  }\n  v_color.a = v_color.a * opacity;\n  vec2 source = project_position(vec4(a_Instance.rg, 0, 0), a_Instance64Low.xy).xy;\n  vec2 target = project_position(vec4(a_Instance.ba, 0, 0), a_Instance64Low.zw).xy;\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n\n  float d_distance_ratio;\n   if(u_line_type == LineTypeDash) {\n    d_distance_ratio = segmentIndex / segmentNumber;\n    float total_Distance = pixelDistance(source, target) / 2.0 * PI;\n    v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / (total_Distance / segmentNumber * segmentIndex);\n  }\n    if(u_animate.x == Animate) {\n      d_distance_ratio = segmentIndex / segmentNumber;\n  }\n  v_line_data.g = d_distance_ratio; // 当前点位距离占线总长的比例\n\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  vec3 curr = getPos(source, target, segmentRatio);\n  vec3 next = getPos(source, target, nextSegmentRatio);\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y);\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n\n\n  v_segmentIndex = a_Position.x;\n  if(LineTexture == u_line_texture && u_line_type != LineTypeDash) { // 开启贴图模式\n\n    float arcDistrance = length(source - target);\n    float pixelLen =  project_pixel_texture(u_icon_step);\n    v_line_data.b = floor(arcDistrance/pixelLen); // 贴图在弧线上重复的数量\n\n    vec2 projectOffset = project_pixel(offset);\n    float lineOffsetWidth = length(projectOffset + projectOffset * sign(a_Position.y)); // 线横向偏移的距离\n    float linePixelSize = project_pixel(a_Size);  // 定点位置偏移，按地图等级缩放后的距离\n    v_line_data.a = lineOffsetWidth/linePixelSize;  // 线图层贴图部分的 v 坐标值\n\n    v_iconMapUV = a_iconMapUV;\n  }\n\n\n  gl_Position = project_common_position_to_clipspace(vec4(curr.xy + project_pixel(offset), curr.z * thetaOffset, 1.0));\n\n  // 地球模式\n  if(u_globel > 0.0) {\n    vec3 startLngLat = lglt2xyz(a_Instance.rg);\n    vec3 endLngLat = lglt2xyz(a_Instance.ba);\n    float globalRadius = length(startLngLat);\n\n    vec3 lineDir = normalize(endLngLat - startLngLat);\n    vec3 midPointDir = normalize((startLngLat + endLngLat)/2.0);\n\n    // 线的偏移\n    vec3 lnglatOffset = cross(lineDir, midPointDir) * a_Position.y;\n    // 计算起始点和终止点的距离\n    float lnglatLength = length(a_Instance.rg - a_Instance.ba)/50.0;\n    // 计算飞线各个节点相应的高度\n    float lineHeight = u_global_height * (-4.0*segmentRatio*segmentRatio + 4.0 * segmentRatio) * lnglatLength;\n    // 地球点位\n    vec3 globalPoint = normalize(mix(startLngLat, endLngLat, segmentRatio)) * (globalRadius + lineHeight) + lnglatOffset * a_Size;\n\n    gl_Position = u_ViewProjectionMatrix * vec4(globalPoint, 1.0);\n  }\n\n\n  setPickingColor(a_PickingColor);\n}\n';
var lineStyleObj2 = {
  solid: 0,
  dash: 1
};
var Arc3DModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "updateTexture", () => {
      const {
        createTexture2D
      } = this.rendererService;
      if (this.texture) {
        this.texture.update({
          data: this.iconService.getCanvas()
        });
        this.layer.render();
        return;
      }
      this.texture = createTexture2D({
        data: this.iconService.getCanvas(),
        mag: gl.NEAREST,
        min: gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: this.iconService.canvasHeight || 128
      });
      this.textures = [this.texture];
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      INSTANCE: 10,
      INSTANCE_64LOW: 11,
      UV: 12,
      THETA_OFFSET: 13
    });
  }
  // public enableShaderEncodeStyles = ['opacity'];
  getCommonUniformsInfo() {
    const {
      sourceColor,
      targetColor,
      textureBlend = "normal",
      lineType = "solid",
      dashArray = [10, 5],
      lineTexture = false,
      iconStep = 100,
      segmentNumber = 30,
      globalArcHeight = 10
    } = this.layer.getLayerConfig();
    const {
      animateOption
    } = this.layer.getLayerConfig();
    if (dashArray.length === 2) {
      dashArray.push(0, 0);
    }
    let useLinearColor = 0;
    let sourceColorArr = [0, 0, 0, 0];
    let targetColorArr = [0, 0, 0, 0];
    if (sourceColor && targetColor) {
      sourceColorArr = rgb2arr(sourceColor);
      targetColorArr = rgb2arr(targetColor);
      useLinearColor = 1;
    }
    if (this.rendererService.getDirty()) {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();
    }
    const commonOptions = {
      u_animate: this.animateOption2Array(animateOption),
      u_dash_array: dashArray,
      u_sourceColor: sourceColorArr,
      u_targetColor: targetColorArr,
      u_textSize: [1024, this.iconService.canvasHeight || 128],
      u_globel: this.mapService.version === "GLOBEL" ? 1 : 0,
      u_globel_radius: EARTH_RADIUS,
      // 地球半径
      u_global_height: globalArcHeight,
      segmentNumber,
      u_line_type: lineStyleObj2[lineType] || 0,
      u_icon_step: iconStep,
      u_line_texture: lineTexture ? 1 : 0,
      // 传入线的标识
      u_textureBlend: textureBlend === "normal" ? 0 : 1,
      u_time: this.layer.getLayerAnimateTime() || 0,
      u_linearColor: useLinearColor
      //是否使用渐变色
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  // public getAnimateUniforms(): IModelUniform {
  //   const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;
  //   return {
  //     u_animate: this.animateOption2Array(animateOption as IAnimateOption),
  //     u_time: this.layer.getLayerAnimateTime(),
  //   };
  // }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      _this.updateTexture();
      _this.iconService.on("imageUpdate", _this.updateTexture);
      return _this.buildModels();
    })();
  }
  clearModels() {
    var _this$texture2;
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    this.iconService.off("imageUpdate", this.updateTexture);
  }
  getShaders() {
    return {
      frag: arc3d_line_frag,
      vert: arc3d_line_vert,
      type: ""
    };
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        segmentNumber = 30
      } = _this2.layer.getLayerConfig();
      const {
        frag,
        vert,
        type
      } = _this2.getShaders();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "lineArc3d" + type,
        vertexShader: vert,
        fragmentShader: frag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation: LineArcTriangulation,
        styleOption: {
          segmentNumber
        }
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 1
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "instance",
      // 弧线起始点信息
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Instance",
        shaderLocation: this.attributeLocation.INSTANCE,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4], vertex[5], vertex[6]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "instance64Low",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Instance64Low",
        shaderLocation: this.attributeLocation.INSTANCE_64LOW,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          return [fp64LowPart(vertex[3]), fp64LowPart(vertex[4]), fp64LowPart(vertex[5]), fp64LowPart(vertex[6])];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_iconMapUV",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature) => {
          const iconMap = this.iconService.getIconMap();
          const {
            texture
          } = feature;
          const {
            x,
            y
          } = iconMap[texture] || {
            x: 0,
            y: 0
          };
          return [x, y];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "thetaOffset",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_ThetaOffset",
        shaderLocation: this.attributeLocation.THETA_OFFSET,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            thetaOffset: op = 1
          } = feature;
          return [op];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/core/shape/arrow.js
var import_earcut4 = __toESM(require_earcut());
var maxArrowWidthMap = {
  circle: 2,
  triangle: 2,
  diamond: 4,
  rect: 2,
  classic: 3,
  halfTriangle: 2,
  none: 0
};
var PathHeight = 1 / 2;
function halfTriangleArrow(dir, options) {
  const {
    width = 2,
    height = 1
  } = options;
  return {
    vertices: [0, PathHeight * dir, 1 * dir * width, -(height + PathHeight) * dir, 1 * dir * width, (height - PathHeight) * dir, 0, PathHeight * dir, 1 * dir * width, -(height + PathHeight) * dir, 1 * dir * width, (height - PathHeight) * dir],
    indices: [3, 4, 5],
    outLineIndices: [0, 1, 2],
    normals: [
      1 * dir,
      -2 * dir,
      1,
      // y,x
      -2 * dir,
      1.5 * dir,
      1,
      1 * dir,
      1.5 * dir,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    dimensions: 2
  };
}
function triangleArrow(dir, options) {
  const {
    width = 2,
    height = 3
  } = options;
  return {
    vertices: [0, 0, 1 * dir * width, 1 * height, 1 * dir * width, -1 * height, 0, 0, 1 * dir * width, 1 * height, 1 * dir * width, -1 * height],
    outLineIndices: [0, 1, 2],
    indices: [3, 4, 5],
    normals: [0, -1.5 * dir, 1, 2, 1 * dir, 1, -2, 1 * dir, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    dimensions: 2
  };
}
function rectArrow(dir, options) {
  const {
    width = 2,
    height = 2
  } = options;
  return {
    vertices: [0, height / 2, dir * width * 1, height / 2, dir * width * 1, -height / 2, 0, -height / 2, 0, height / 2, dir * width * 1, height / 2, dir * width * 1, -height / 2, 0, -height / 2],
    dimensions: 2,
    indices: [4, 5, 6, 4, 6, 7],
    outLineIndices: [0, 1, 2, 0, 2, 3],
    normals: [0, -dir, 1, 1, 0, 1, 0, -dir, 1, -1, -0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  };
}
function diamondArrow(dir, options) {
  const {
    width = 2,
    height = 3
  } = options;
  return {
    vertices: [0, 0, 1 * width * dir, 0.5 * height, 2 * width * dir, 0, 1 * width * dir, -0.5 * height, 0, 0, 1 * width * dir, 0.5 * height, 2 * width * dir, 0, 1 * width * dir, -0.5 * height],
    dimensions: 2,
    indices: [4, 5, 6, 4, 6, 7],
    outLineIndices: [0, 1, 2, 0, 2, 3],
    normals: [0, -dir, 1, 1, 0, 1, 0, -dir, 1, -1, -0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  };
}
function classicArrow(dir, options) {
  const {
    width = 2,
    height = 3
  } = options;
  return {
    vertices: [0, 0, 2 * dir * width, 1 * height, 1.5 * dir * width, 0, 2 * dir * width, -1 * height, 0, 0, 2 * dir * width, 1 * height, 1.5 * dir * width, 0, 2 * dir * width, -1 * height],
    dimensions: 2,
    indices: [4, 5, 6, 4, 6, 7],
    outLineIndices: [0, 1, 2, 0, 2, 3],
    normals: [0, -dir, 1, 1, 0, 1, 0, -dir, 1, -1, -0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  };
}
function circleArraw(dir, options) {
  const {
    width = 2,
    height = 2
  } = options;
  const path = circle();
  const flattengeo = import_earcut4.default.flatten([path]);
  const triangles = (0, import_earcut4.default)(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  const vertice = path.map((t) => [t[0] * width * dir, t[1] * height]).flat();
  return {
    vertices: [...vertice, ...vertice],
    dimensions: 2,
    indices: triangles.map((v2) => v2 + path.length),
    outLineIndices: triangles,
    normals: [
      // @ts-ignore
      ...path.map((t) => [t[1] * height, t[0] * width * dir, 1]).flat(),
      ...new Array(path.length * 3).fill(0)
    ]
  };
}
function lineArrowPath(coord, indexOffset = 0, symbol) {
  const sourceType = typeof symbol["source"] === "object" ? symbol["source"].type : symbol["source"];
  const targetType = typeof symbol["target"] === "object" ? symbol["target"].type : symbol["target"];
  const {
    width: sourceWidth = sourceType ? maxArrowWidthMap[sourceType] : 0
  } = typeof symbol["source"] === "object" ? symbol["source"] : {};
  const {
    width: targetWidth = targetType ? maxArrowWidthMap[targetType] : 0
  } = typeof symbol["target"] === "object" ? symbol["target"] : {};
  return {
    vertices: [0, PathHeight, 1 * sourceWidth, ...coord, 1, PathHeight, -1 * targetWidth, ...coord, 1, -PathHeight, -1 * targetWidth, ...coord, 0, -PathHeight, 1 * sourceWidth, ...coord, 0, PathHeight, 1 * sourceWidth, ...coord, 1, PathHeight, -1 * targetWidth, ...coord, 1, -PathHeight, -1 * targetWidth, ...coord, 0, -PathHeight, 1 * sourceWidth, ...coord],
    outLineIndices: [0, 1, 2, 0, 2, 3].map((t) => t + indexOffset),
    indices: [4, 5, 6, 4, 6, 7].map((t) => t + indexOffset),
    normals: [1, -1, 1, 1, 1, 1, -1, 0, 1, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    dimensions: 2
  };
}
function getSymbol(type, position) {
  const shape = typeof type === "object" ? type.type : type;
  const dir = position === "source" ? 1 : -1;
  const option = typeof type === "object" ? type : {};
  switch (shape) {
    case "circle":
      return circleArraw(dir, option);
    case "triangle":
      return triangleArrow(dir, option);
    case "diamond":
      return diamondArrow(dir, option);
    case "rect":
      return rectArrow(dir, option);
    case "classic":
      return classicArrow(dir, option);
    case "halfTriangle":
      return halfTriangleArrow(dir, option);
    default:
      return {
        vertices: [],
        indices: [],
        normals: [],
        dimensions: 2,
        outLineIndices: [],
        outLineNormals: []
      };
  }
}

// node_modules/@antv/l7-layers/es/core/line_trangluation.js
function FlowHalfArrowFillTriangulation(feature) {
  const coord = feature.coordinates.flat();
  const tin = 1;
  const tout = 1;
  return {
    vertices: [
      1,
      0,
      0,
      ...coord,
      // 0
      1,
      2,
      -3,
      ...coord,
      // 1
      1,
      1,
      -3,
      ...coord,
      // 2
      0,
      1,
      0,
      ...coord,
      // 3
      0,
      0,
      0,
      ...coord,
      // 4
      1,
      0,
      0,
      ...coord,
      // 0
      1,
      2,
      -3,
      ...coord,
      // 1
      1,
      1,
      -3,
      ...coord,
      // 2
      0,
      1,
      0,
      ...coord,
      // 3
      0,
      0,
      0,
      ...coord
      // 4
    ],
    normals: [
      -tin,
      2 * tout,
      1,
      // 0
      2 * tout,
      -tout,
      1,
      // 1
      tout,
      -tout,
      1,
      // 2
      tout,
      -tout,
      1,
      // 3
      -tin,
      -tout,
      1,
      // 4
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ],
    indices: [0, 1, 2, 0, 2, 3, 0, 3, 4, 5, 6, 7, 5, 7, 8, 5, 8, 9],
    size: 7
  };
}
function FlowLineTriangulation(feature, symbolOption) {
  return symbolOption ? ArrowLineTriangulation(feature, symbolOption) : FlowHalfArrowFillTriangulation(feature);
}
function ArrowLineTriangulation(feature, symbolOption) {
  const coord = feature.coordinates.flat();
  const {
    target = "classic",
    source = "circle"
  } = symbolOption;
  const startSymbol = shape2Vertices(getSymbol(source, "source"), coord, 0, 0);
  const linePath = lineArrowPath(coord, startSymbol.vertices.length / 7, symbolOption);
  const endSymbol = shape2Vertices(getSymbol(target, "target"), coord, 1, startSymbol.vertices.length / 7 + linePath.vertices.length / 7);
  const data = {
    vertices: [...startSymbol.vertices, ...linePath.vertices, ...endSymbol.vertices],
    indices: [...startSymbol.outLineIndices, ...linePath.outLineIndices, ...endSymbol.outLineIndices, ...startSymbol.indices, ...linePath.indices, ...endSymbol.indices],
    normals: [...startSymbol.normals, ...linePath.normals, ...endSymbol.normals],
    size: 7
  };
  return data;
}
function shape2Vertices(shape, coord, type = 1, indexOffset = 0) {
  const shapeVertices = [];
  const {
    vertices,
    indices,
    dimensions,
    outLineIndices
  } = shape;
  for (let i = 0; i < vertices.length; i += dimensions) {
    shapeVertices.push(type, vertices[i + 1], vertices[i], ...coord);
  }
  return _objectSpread2(_objectSpread2({}, shape), {}, {
    vertices: shapeVertices,
    indices: indices.map((i) => i + indexOffset),
    outLineIndices: outLineIndices.map((i) => i + indexOffset)
  });
}

// node_modules/@antv/l7-layers/es/line/models/flow.js
var flow_line_frag = '// #extension GL_OES_standard_derivatives : enable\n\nin vec4 v_color;\nout vec4 outputColor;\n\n\n// line texture\n\n#pragma include "picking"\n\nvoid main() {\n  outputColor = v_color;\n  outputColor = filterColor(outputColor);\n}\n';
var flow_line_vert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec2 a_Size;\nlayout(location = ATTRIBUTE_LOCATION_INSTANCE) in vec4 a_Instance;\nlayout(location = ATTRIBUTE_LOCATION_INSTANCE_64LOW) in vec4 a_Instance64Low;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\n\nlayout(std140) uniform commonUniorm {\n  float u_gap_width: 1.0;\n  float u_stroke_width: 1.0;\n  float u_stroke_opacity: 1.0;\n};\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nout vec4 v_color;\n\nvec2 project_pixel_offset(vec2 offsets) {\n  vec2 data = project_pixel(offsets);\n\n  return vec2(data.x, -data.y);\n}\n\nvec2 line_dir(vec2 target, vec2 source) {\n  return normalize(ProjectFlat(target) - ProjectFlat(source));\n}\n\n\nvoid main() {\n  // 透明度计算\n  vec2 source_world = a_Instance.rg; // 起点\n  vec2 target_world = a_Instance.ba; // 终点\n  vec2 flowlineDir = line_dir(target_world, source_world);\n  vec2 perpendicularDir = vec2(-flowlineDir.y, flowlineDir.x);\n\n  vec2 position = mix(source_world, target_world, a_Position.x);\n  vec2 position64Low = mix(a_Instance64Low.rg, a_Instance64Low.ba, a_Position.x);\n\n  float lengthCommon = length(\n    project_position(vec4(target_world, 0, 1)) - project_position(vec4(source_world, 0, 1))\n  );\n  vec2 offsetDistances = a_Size.x * project_pixel_offset(vec2(a_Position.y, a_Position.z)); // Mapbox || 高德\n  vec2 limitedOffsetDistances = clamp(\n    offsetDistances,\n    project_pixel(-lengthCommon * 0.2),\n    project_pixel(lengthCommon * 0.2)\n  );\n\n  float startOffsetCommon = project_pixel(offsets[0]);\n  float endOffsetCommon = project_pixel(offsets[1]);\n  float endpointOffset = mix(\n    clamp(startOffsetCommon, 0.0, lengthCommon * 0.2),\n    -clamp(endOffsetCommon, 0.0, lengthCommon * 0.2),\n    a_Position.x\n  );\n\n  vec2 normalsCommon = u_stroke_width * project_pixel_offset(vec2(a_Normal.x, a_Normal.y));\n\n  float gapCommon = -1. * project_pixel(u_gap_width);\n  vec3 offsetCommon = vec3(\n    flowlineDir * (limitedOffsetDistances[1] + normalsCommon.y + endpointOffset * 1.05) -\n      perpendicularDir * (limitedOffsetDistances[0] + gapCommon + normalsCommon.x),\n    0.0\n  );\n\n  vec4 project_pos = project_position(vec4(position.xy, 0, 1.0), position64Low);\n\n  vec4 fillColor = vec4(a_Color.rgb, a_Color.a * opacity);\n  v_color = mix(fillColor, vec4(u_stroke.xyz, u_stroke.w * fillColor.w * u_stroke_opacity), a_Normal.z);\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy +  offsetCommon.xy, 0., 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n';
var FlowLineModel = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      INSTANCE: 10,
      INSTANCE_64LOW: 11,
      NORMAL: 12
    });
  }
  getCommonUniformsInfo() {
    const {
      gapWidth = 2,
      strokeWidth = 1,
      strokeOpacity = 1
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_gap_width: gapWidth,
      u_stroke_width: strokeWidth,
      u_stroke_opacity: strokeOpacity
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const modelFill = yield _this2.layer.buildLayerModel({
        moduleName: "flow_line",
        vertexShader: flow_line_vert,
        fragmentShader: flow_line_frag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation: FlowLineTriangulation,
        styleOption: _this2.layer.getLayerConfig().symbol,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        },
        pick: false
      });
      return [modelFill];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        // 宽度
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature) => {
          const {
            size: size2 = 1
          } = feature;
          return Array.isArray(size2) ? [size2[0], size2[1]] : [size2, 0];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "instance",
      // 弧线起始点信息
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Instance",
        shaderLocation: this.attributeLocation.INSTANCE,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4], vertex[5], vertex[6]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "instance64Low",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Instance64Low",
        shaderLocation: this.attributeLocation.INSTANCE_64LOW,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          return [fp64LowPart(vertex[3]), fp64LowPart(vertex[4]), fp64LowPart(vertex[5]), fp64LowPart(vertex[6])];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "normal",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Normal",
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/line/models/great_circle.js
var line_arc_frag = '#define LineTypeSolid 0.0\n#define LineTypeDash 1.0\n#define Animate 0.0\n#define LineTexture 1.0\n\nuniform sampler2D u_texture;\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_dash_array: [10.0, 5., 0, 0];\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float segmentNumber;\n  float u_line_type: 0.0;\n  float u_icon_step: 100;\n  float u_line_texture: 0.0;\n  float u_textureBlend;\n  float u_time;\n  float u_linearColor: 0;\n};\n\nin vec4 v_dash_array;\nin vec4 v_color;\nin vec2 v_iconMapUV;\nin vec4 v_line_data;\nin float v_distance_ratio;\n\nout vec4 outputColor;\n#pragma include "picking"\n#pragma include "project"\n#pragma include "projection"\n\nvoid main() {\n\n  float animateSpeed = 0.0;\n  float d_segmentIndex = v_line_data.g;\n\n  // 设置弧线的底色\n  if(u_linearColor == 1.0) { // 使用渐变颜色\n    outputColor = mix(u_sourceColor, u_targetColor, d_segmentIndex/segmentNumber);\n    outputColor.a *= v_color.a;\n  } else { // 使用 color 方法传入的颜色\n    outputColor = v_color;\n  }\n\n  // float blur = 1.- smoothstep(u_blur, 1., length(v_normal.xy));\n  // float blur = smoothstep(1.0, u_blur, length(v_normal.xy));\n  if(u_line_type == LineTypeDash) {\n    float dashLength = mod(v_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z)) {\n      // 实线部分\n    } else {\n      // 虚线部分\n      discard;\n    };\n  }\n\n  // 设置弧线的动画模式\n  if(u_animate.x == Animate) {\n      animateSpeed = u_time / u_animate.y;\n      float alpha =1.0 - fract( mod(1.0- v_distance_ratio, u_animate.z)* (1.0/ u_animate.z) + u_time / u_animate.y);\n      alpha = (alpha + u_animate.w -1.0) / u_animate.w;\n      alpha = smoothstep(0., 1., alpha);\n      outputColor.a *= alpha;\n  }\n\n  // 设置弧线的贴图\n  if(LineTexture == u_line_texture && u_line_type != LineTypeDash) {\n    float arcRadio = smoothstep( 0.0, 1.0, (d_segmentIndex / (segmentNumber - 1.0)));\n    // float arcRadio = d_segmentIndex / (segmentNumber - 1.0);\n    float count = v_line_data.b; // 贴图在弧线上重复的数量\n    float u = fract(arcRadio * count - animateSpeed * count);\n    // float u = fract(arcRadio * count - animateSpeed);\n    if(u_animate.x == Animate) {\n      u = outputColor.a/v_color.a;\n    }\n\n    float v = v_line_data.a; // 线图层贴图部分的 v 坐标值\n\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n    vec4 pattern = texture(SAMPLER_2D(u_texture), uv);\n\n    // 设置贴图和底色的叠加模式\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      outputColor = filterColor(outputColor + pattern);\n    } else { // replace\n        pattern.a *= v_color.a;\n        if(outputColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        outputColor = filterColor(pattern);\n    }\n  } else {\n    outputColor = filterColor(outputColor);\n  }\n\n  // gl_FragColor = filterColor(gl_FragColor);\n}\n';
var line_arc2d_vert = '#define LineTypeSolid (0.0)\n#define LineTypeDash (1.0)\n#define Animate (0.0)\n#define LineTexture (1.0)\n\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_INSTANCE) in vec4 a_Instance;\nlayout(location = ATTRIBUTE_LOCATION_INSTANCE_64LOW) in vec4 a_Instance64Low;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_iconMapUV;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_dash_array: [10.0, 5., 0, 0];\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float segmentNumber;\n  float u_line_type: 0.0;\n  float u_icon_step: 100;\n  float u_line_texture: 0.0;\n  float u_textureBlend;\n  float u_time;\n  float u_linearColor: 0;\n};\n\nout vec4 v_dash_array;\nout vec4 v_color;\nout vec2 v_iconMapUV;\nout vec4 v_line_data;\nout float v_distance_ratio;\n\n#pragma include "projection"\n#pragma include "project"\n#pragma include "picking"\n\nfloat maps(float value, float start1, float stop1, float start2, float stop2) {\n  return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat getSegmentRatio(float index) {\n  return index / (segmentNumber - 1.0);\n}\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertex_height = paraboloid(source, target, segmentRatio);\n\n  return vec3(mix(source, target, segmentRatio), sqrt(max(0.0, vertex_height)));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\n  return offset;\n}\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n  return dir_screenspace.xy * sign(offset_direction);\n}\nfloat getAngularDist(vec2 source, vec2 target) {\n  vec2 delta = source - target;\n  vec2 sin_half_delta = sin(delta / 2.0);\n  float a =\n    sin_half_delta.y * sin_half_delta.y +\n    cos(source.y) * cos(target.y) * sin_half_delta.x * sin_half_delta.x;\n  return 2.0 * atan(sqrt(a), sqrt(1.0 - a));\n}\n\nvec2 midPoint(vec2 source, vec2 target) {\n  vec2 center = target - source;\n  float r = length(center);\n  float theta = atan(center.y, center.x);\n  float thetaOffset = 0.314;\n  float r2 = r / 2.0 / cos(thetaOffset);\n  float theta2 = theta + thetaOffset;\n  vec2 mid = vec2(r2 * cos(theta2) + source.x, r2 * sin(theta2) + source.y);\n  return mid;\n}\nfloat bezier3(vec3 arr, float t) {\n  float ut = 1.0 - t;\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\n}\n\nvec2 interpolate(vec2 source, vec2 target, float angularDist, float t) {\n  if (abs(angularDist - PI) < 0.001) {\n    return (1.0 - t) * source + t * target;\n  }\n  float a = sin((1.0 - t) * angularDist) / sin(angularDist);\n  float b = sin(t * angularDist) / sin(angularDist);\n  vec2 sin_source = sin(source);\n  vec2 cos_source = cos(source);\n  vec2 sin_target = sin(target);\n  vec2 cos_target = cos(target);\n  float x = a * cos_source.y * cos_source.x + b * cos_target.y * cos_target.x;\n  float y = a * cos_source.y * sin_source.x + b * cos_target.y * sin_target.x;\n  float z = a * sin_source.y + b * sin_target.y;\n  return vec2(atan(y, x), atan(z, sqrt(x * x + y * y)));\n\n}\n\nvoid main() {\n  v_color = a_Color;\n  v_color.a = v_color.a * opacity;\n  vec2 source = radians(a_Instance.rg);\n  vec2 target = radians(a_Instance.ba);\n  float angularDist = getAngularDist(source, target);\n  float segmentIndex = a_Position.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n\n  if (u_line_type == LineTypeDash) {\n    v_distance_ratio = segmentIndex / segmentNumber;\n    float total_Distance = pixelDistance(source, target) / 2.0 * PI;\n    total_Distance = total_Distance * 16.0; // total_Distance*16.0 调整默认的效果\n    v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / total_Distance;\n  }\n\n  if (u_animate.x == Animate) {\n    v_distance_ratio = segmentIndex / segmentNumber;\n  }\n\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  v_distance_ratio = segmentIndex / segmentNumber;\n\n  vec4 curr = project_position(vec4(degrees(interpolate(source, target, angularDist, segmentRatio)), 0.0, 1.0), a_Instance64Low.xy);\n  vec4 next = project_position(vec4(degrees(interpolate(source, target, angularDist, nextSegmentRatio)), 0.0, 1.0), a_Instance64Low.zw);\n\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\n  //  vec4 project_pos = project_position(vec4(curr.xy, 0, 1.0));\n  // gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, curr.z, 1.0));\n\n  v_line_data.g = a_Position.x; // 该顶点在弧线上的分段排序\n  if (LineTexture == u_line_texture) {\n    float d_arcDistrance = length(source - target);\n    d_arcDistrance = project_pixel(d_arcDistrance);\n\n    float d_pixelLen = project_pixel(u_icon_step) / 8.0;\n    v_line_data.b = floor(d_arcDistrance / d_pixelLen); // 贴图在弧线上重复的数量\n\n    float lineOffsetWidth = length(offset + offset * sign(a_Position.y)); // 线横向偏移的距离\n    float linePixelSize = project_pixel(a_Size); // 定点位置偏移，按地图等级缩放后的距离\n    v_line_data.a = lineOffsetWidth / linePixelSize; // 线图层贴图部分的 v 坐标值\n\n    v_iconMapUV = a_iconMapUV;\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\n  setPickingColor(a_PickingColor);\n}\n\n';
var lineStyleObj3 = {
  solid: 0,
  dash: 1
};
var GreatCircleModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "updateTexture", () => {
      const {
        createTexture2D
      } = this.rendererService;
      if (this.texture) {
        this.texture.update({
          data: this.iconService.getCanvas()
        });
        this.layer.render();
        return;
      }
      this.texture = createTexture2D({
        data: this.iconService.getCanvas(),
        mag: gl.NEAREST,
        min: gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: this.iconService.canvasHeight || 128
      });
      this.textures = [this.texture];
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      INSTANCE: 10,
      INSTANCE_64LOW: 11,
      UV: 12
    });
  }
  getCommonUniformsInfo() {
    const {
      sourceColor,
      targetColor,
      textureBlend = "normal",
      lineType = "solid",
      dashArray = [10, 5],
      lineTexture = false,
      iconStep = 100,
      segmentNumber = 30
    } = this.layer.getLayerConfig();
    const {
      animateOption
    } = this.layer.getLayerConfig();
    if (dashArray.length === 2) {
      dashArray.push(0, 0);
    }
    if (this.rendererService.getDirty()) {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();
    }
    let useLinearColor = 0;
    let sourceColorArr = [0, 0, 0, 0];
    let targetColorArr = [0, 0, 0, 0];
    if (sourceColor && targetColor) {
      sourceColorArr = rgb2arr(sourceColor);
      targetColorArr = rgb2arr(targetColor);
      useLinearColor = 1;
    }
    let u_time = this.layer.getLayerAnimateTime();
    if (isNaN(u_time)) {
      u_time = 0;
    }
    const commonOptions = {
      u_animate: this.animateOption2Array(animateOption),
      u_dash_array: dashArray,
      u_sourceColor: sourceColorArr,
      u_targetColor: targetColorArr,
      u_textSize: [1024, this.iconService.canvasHeight || 128],
      segmentNumber,
      u_line_type: lineStyleObj3[lineType] || 0,
      u_icon_step: iconStep,
      u_line_texture: lineTexture ? 1 : 0,
      // 传入线的标识
      u_textureBlend: textureBlend === "normal" ? 0 : 1,
      u_time,
      // 纹理支持参数
      // u_texture: this.texture, // 贴图
      // 渐变色支持参数
      u_linearColor: useLinearColor
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  // public getAnimateUniforms(): IModelUniform {
  //   const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;
  //   return {
  //     u_animate: this.animateOption2Array(animateOption as IAnimateOption),
  //     u_time: this.layer.getLayerAnimateTime(),
  //   };
  // }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      _this.updateTexture();
      _this.iconService.on("imageUpdate", _this.updateTexture);
      return _this.buildModels();
    })();
  }
  clearModels() {
    var _this$texture2;
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    this.iconService.off("imageUpdate", this.updateTexture);
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        segmentNumber = 30
      } = _this2.layer.getLayerConfig();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "lineGreatCircle",
        vertexShader: line_arc2d_vert,
        fragmentShader: line_arc_frag,
        triangulation: LineArcTriangulation,
        styleOption: {
          segmentNumber
        },
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        depth: {
          enable: false
        }
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 1
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "instance",
      // 弧线起始点信息
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Instance",
        shaderLocation: this.attributeLocation.INSTANCE,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4], vertex[5], vertex[6]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "instance64Low",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Instance64Low",
        shaderLocation: this.attributeLocation.INSTANCE_64LOW,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          return [fp64LowPart(vertex[3]), fp64LowPart(vertex[4]), fp64LowPart(vertex[5]), fp64LowPart(vertex[6])];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_iconMapUV",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature) => {
          const iconMap = this.iconService.getIconMap();
          const {
            texture
          } = feature;
          const {
            x,
            y
          } = iconMap[texture] || {
            x: 0,
            y: 0
          };
          return [x, y];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/line/models/line.js
var line_frag = '// #extension GL_OES_standard_derivatives : enable\n#define Animate 0.0\n#define LineTexture 1.0\n\nuniform sampler2D u_texture;\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_dash_array;\n  vec4 u_blur;\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float u_icon_step: 100;\n  float u_heightfixed: 0.0;\n  float u_vertexScale: 1.0;\n  float u_raisingHeight: 0.0;\n  float u_strokeWidth: 0.0;\n  float u_textureBlend;\n  float u_line_texture;\n  float u_linearDir: 1.0;\n  float u_linearColor: 0;\n  float u_time;\n};\n\nin vec4 v_color;\nin vec4 v_stroke;\n// dash\nin vec4 v_dash_array;\nin float v_d_distance_ratio;\nin vec2 v_iconMapUV;\nin vec4 v_texture_data;\n\nout vec4 outputColor;\n#pragma include "picking"\n\n// [animate, duration, interval, trailLength],\nvoid main() {\n  if(u_dash_array!=vec4(0.0)){\n    float dashLength = mod(v_d_distance_ratio, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(!(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z))) {\n      // 虚线部分\n      discard;\n    };\n  }\n  float animateSpeed = 0.0; // 运动速度\n  float d_distance_ratio = v_texture_data.r; // 当前点位距离占线总长的比例\n  if(u_linearDir < 1.0) {\n    d_distance_ratio = v_texture_data.a;\n  }\n  if(u_linearColor == 1.0) { // 使用渐变颜色\n    outputColor = mix(u_sourceColor, u_targetColor, d_distance_ratio);\n    outputColor.a *= v_color.a;\n  } else { // 使用 color 方法传入的颜色\n     outputColor = v_color;\n  }\n  // anti-alias\n  // float blur = 1.0 - smoothstep(u_blur, 1., length(v_normal.xy));\n  if(u_animate.x == Animate) {\n      animateSpeed = u_time / u_animate.y;\n       float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_animate.z)* (1.0/ u_animate.z) + animateSpeed);\n      alpha = (alpha + u_animate.w -1.0) / u_animate.w;\n      alpha = smoothstep(0., 1., alpha);\n      outputColor.a *= alpha;\n  }\n\n  if(u_line_texture == LineTexture) { // while load texture\n    float aDistance = v_texture_data.g;      // 当前顶点的距离\n    float d_texPixelLen = v_texture_data.b;  // 贴图的像素长度，根据地图层级缩放\n    float u = fract(mod(aDistance, d_texPixelLen)/d_texPixelLen - animateSpeed);\n    float v = v_texture_data.a;  // 线图层贴图部分的 v 坐标值\n\n    // v = max(smoothstep(0.95, 1.0, v), v);\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n     vec4 pattern = texture(SAMPLER_2D(u_texture), uv);\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      outputColor += pattern;\n    } else { // replace\n        pattern.a *= v_color.a;\n        if(outputColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        outputColor = pattern;\n    }\n  } \n\n  float v = v_texture_data.a;\n  float strokeWidth = min(0.5, u_strokeWidth);\n  // 绘制 border\n  if(strokeWidth > 0.01) {\n    float borderOuterWidth = strokeWidth / 2.0;\n\n\n    if(v >= 1.0 - strokeWidth || v <= strokeWidth) {\n      if(v > strokeWidth) { // 外侧\n        float linear = smoothstep(0.0, 1.0, (v - (1.0 - strokeWidth))/strokeWidth);\n        //  float linear = step(0.0, (v - (1.0 - borderWidth))/borderWidth);\n        outputColor.rgb = mix(outputColor.rgb, v_stroke.rgb, linear);\n      } else if(v <= strokeWidth) {\n        float linear = smoothstep(0.0, 1.0, v/strokeWidth);\n        outputColor.rgb = mix(v_stroke.rgb, outputColor.rgb, linear);\n      }\n    }\n\n    if(v < borderOuterWidth) {\n      outputColor.a = mix(0.0, outputColor.a, v/borderOuterWidth);\n    } else if(v > 1.0 - borderOuterWidth) {\n      outputColor.a = mix(outputColor.a, 0.0, (v - (1.0 - borderOuterWidth))/borderOuterWidth);\n    }\n  }\n\n  // blur\n  float blurV = v_texture_data.a;\n  if(blurV < 0.5) {\n    outputColor.a *= mix(u_blur.r, u_blur.g, blurV/0.5);\n  } else {\n    outputColor.a *= mix(u_blur.g, u_blur.b, (blurV - 0.5)/0.5);\n  }\n  \n  outputColor = filterColor(outputColor);\n}\n';
var line_vert = '#define Animate (0.0)\n\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec2 a_Size;\nlayout(location = ATTRIBUTE_LOCATION_DISTANCE_INDEX) in vec3 a_DistanceAndIndexAndMiter;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec4 a_Normal_Total_Distance;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_iconMapUV;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_dash_array;\n  vec4 u_blur;\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float u_icon_step: 100;\n  float u_heightfixed: 0.0;\n  float u_vertexScale: 1.0;\n  float u_raisingHeight: 0.0;\n  float u_strokeWidth: 0.0;\n  float u_textureBlend;\n  float u_line_texture;\n  float u_linearDir: 1.0;\n  float u_linearColor: 0;\n  float u_time;\n};\n\nout vec4 v_color;\nout vec4 v_stroke;\n//dash\nout vec4 v_dash_array;\nout float v_d_distance_ratio;\n// texV 线图层 - 贴图部分的 v 坐标（线的宽度方向）\nout vec2 v_iconMapUV;\nout vec4 v_texture_data;\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  vec2 a_DistanceAndIndex = a_DistanceAndIndexAndMiter.xy;\n  float a_Miter = a_DistanceAndIndexAndMiter.z;\n  vec3 a_Normal = a_Normal_Total_Distance.xyz;\n  float a_Total_Distance = a_Normal_Total_Distance.w;\n  //dash输出\n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / a_Total_Distance;\n  v_d_distance_ratio = a_DistanceAndIndex.x / a_Total_Distance;\n\n  // cal style mapping - 数据纹理映射部分的计算\n  float d_texPixelLen; // 贴图的像素长度，根据地图层级缩放\n  v_iconMapUV = a_iconMapUV;\n  d_texPixelLen = project_float_pixel(u_icon_step);\n\n  v_color = a_Color;\n  v_color.a *= opacity;\n  v_stroke = stroke;\n\n  vec3 size = a_Miter * setPickingSize(a_Size.x) * a_Normal;\n\n  vec2 offset = project_pixel(size.xy);\n\n  float lineDistance = a_DistanceAndIndex.x;\n  float currentLinePointRatio = lineDistance / a_Total_Distance;\n\n  float lineOffsetWidth = length(offset + offset * sign(a_Miter)); // 线横向偏移的距离（向两侧偏移的和）\n  float linePixelSize = project_pixel(a_Size.x) * 2.0; // 定点位置偏移，按地图等级缩放后的距离 单侧 * 2\n  float texV = lineOffsetWidth / linePixelSize; // 线图层贴图部分的 v 坐标值\n\n  v_texture_data = vec4(currentLinePointRatio, lineDistance, d_texPixelLen, texV);\n  // 设置数据集的参数\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0), a_Position64Low);\n\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, a_Size.y, 1.0));\n\n  float h = float(a_Position.z) * u_vertexScale; // 线顶点的高度 - 兼容不存在第三个数值的情况 vertex height\n  float lineHeight = a_Size.y; // size 第二个参数代表的高度 [linewidth, lineheight]\n\n  // 兼容 mapbox 在线高度上的效果表现基本一致\n  if (\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n  ) {\n    // mapbox\n    // 保持高度相对不变\n    float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\n    h *= mapboxZoomScale;\n    h += u_raisingHeight * mapboxZoomScale;\n    if (u_heightfixed > 0.0) {\n      lineHeight *= mapboxZoomScale;\n    }\n  }\n\n  gl_Position = project_common_position_to_clipspace(\n    vec4(project_pos.xy + offset, lineHeight + h, 1.0)\n  );\n\n  setPickingColor(a_PickingColor);\n}\n';
var LineModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "textureEventFlag", false);
    _defineProperty(this, "texture", this.createTexture2D({
      data: new Uint8Array([0, 0, 0, 0]),
      width: 1,
      height: 1
    }));
    _defineProperty(this, "updateTexture", () => {
      const {
        createTexture2D
      } = this.rendererService;
      if (this.textures.length === 0) {
        this.textures = [this.texture];
      }
      if (this.texture) {
        this.texture.update({
          data: this.iconService.getCanvas()
        });
        this.layer.render();
        return;
      }
      this.texture = createTexture2D({
        data: this.iconService.getCanvas(),
        mag: gl.NEAREST,
        min: gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: this.iconService.canvasHeight || 128
      });
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      DISTANCE_INDEX: 10,
      NORMAL: 11,
      UV: 12
    });
  }
  getCommonUniformsInfo() {
    const {
      sourceColor,
      targetColor,
      textureBlend = "normal",
      lineType = "solid",
      dashArray = [10, 5, 0, 0],
      lineTexture = false,
      iconStep = 100,
      vertexHeightScale = 20,
      strokeWidth = 0,
      raisingHeight = 0,
      heightfixed = false,
      linearDir = LinearDir.VERTICAL,
      // 默认纵向
      blur = [1, 1, 1, 0]
    } = this.layer.getLayerConfig();
    let u_dash_array = dashArray;
    if (lineType !== "dash") {
      u_dash_array = [0, 0, 0, 0];
    }
    if (u_dash_array.length === 2) {
      u_dash_array.push(0, 0);
    }
    if (this.rendererService.getDirty() && this.texture) {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();
    }
    const {
      animateOption
    } = this.layer.getLayerConfig();
    let useLinearColor = 0;
    let sourceColorArr = [0, 0, 0, 0];
    let targetColorArr = [0, 0, 0, 0];
    if (sourceColor && targetColor) {
      sourceColorArr = rgb2arr(sourceColor);
      targetColorArr = rgb2arr(targetColor);
      useLinearColor = 1;
    }
    const commonOptions = {
      u_animate: this.animateOption2Array(animateOption),
      u_dash_array,
      u_blur: blur,
      u_sourceColor: sourceColorArr,
      u_targetColor: targetColorArr,
      u_textSize: [1024, this.iconService.canvasHeight || 128],
      u_icon_step: iconStep,
      // 是否固定高度
      u_heightfixed: Number(heightfixed),
      // 顶点高度 scale
      u_vertexScale: vertexHeightScale,
      u_raisingHeight: Number(raisingHeight),
      // line border 参数
      u_strokeWidth: strokeWidth,
      u_textureBlend: textureBlend === TextureBlend.NORMAL ? 0 : 1,
      u_line_texture: lineTexture ? 1 : 0,
      // 传入线的标识
      u_linearDir: linearDir === LinearDir.VERTICAL ? 1 : 0,
      u_linearColor: useLinearColor,
      u_time: this.layer.getLayerAnimateTime() || 0
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  // public getAnimateUniforms(): IModelUniform {
  //   const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;
  //   return {
  //     u_animate: this.animateOption2Array(animateOption as IAnimateOption),
  //     u_time: this.layer.getLayerAnimateTime(),
  //   };
  // }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      if (!_this.textureEventFlag) {
        _this.textureEventFlag = true;
        _this.updateTexture();
        _this.iconService.on("imageUpdate", _this.updateTexture);
      }
      return _this.buildModels();
    })();
  }
  clearModels() {
    var _this$texture2;
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    this.iconService.off("imageUpdate", this.updateTexture);
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        depth = false
      } = _this2.layer.getLayerConfig();
      const {
        frag,
        vert,
        type
      } = _this2.getShaders();
      _this2.layer.triangulation = LineTriangulation;
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "line" + type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: LineTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        depth: {
          enable: depth
        }
      });
      return [model];
    })();
  }
  /**
   * 根据参数获取不同的 shader 代码
   * @returns
   */
  getShaders() {
    return {
      frag: line_frag,
      vert: line_vert,
      type: ""
    };
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "distanceAndIndex",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_DistanceAndIndexAndMiter",
        shaderLocation: this.attributeLocation.DISTANCE_INDEX,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal, vertexIndex) => {
          return vertexIndex === void 0 ? [vertex[3], 10, vertex[4]] : [vertex[3], vertexIndex, vertex[4]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature) => {
          const {
            size: size2 = 1
          } = feature;
          return Array.isArray(size2) ? [size2[0], size2[1]] : [size2, 0];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "normal_total_distance",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Normal_Total_Distance",
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return [...normal, vertex[5]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_iconMapUV",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature) => {
          const iconMap = this.iconService.getIconMap();
          const {
            texture
          } = feature;
          const {
            x,
            y
          } = iconMap[texture] || {
            x: 0,
            y: 0
          };
          return [x, y];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/line/models/simple_line.js
var simple_line_frag = "\nlayout(std140) uniform commonUniorm {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec4 u_dash_array;\n  float u_vertexScale: 1.0;\n  float u_linearColor: 0;\n};\nin float v_distanceScale;\nin vec4 v_color;\n//dash\nin vec4 v_dash_array;\n\nout vec4 outputColor;\nvoid main() {\n  if(u_dash_array!=vec4(0.0)){\n    float dashLength = mod(v_distanceScale, v_dash_array.x + v_dash_array.y + v_dash_array.z + v_dash_array.w);\n    if(!(dashLength < v_dash_array.x || (dashLength > (v_dash_array.x + v_dash_array.y) && dashLength <  v_dash_array.x + v_dash_array.y + v_dash_array.z))) {\n      // 虚线部分\n      discard;\n    };\n  }\n  if(u_linearColor==1.0){\n    outputColor = mix(u_sourceColor, u_targetColor, v_distanceScale);\n    outputColor.a *= v_color.a; // 全局透明度\n  }\n  else{\n    outputColor = v_color;\n  }\n}\n";
var simple_line_vert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec4 a_SizeDistanceAndTotalDistance;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec4 u_dash_array;\n  float u_vertexScale: 1.0;\n  float u_linearColor: 0;\n};\n\n#pragma include "projection"\n#pragma include "picking"\n\nout vec4 v_color;\nout float v_distanceScale;\nout vec4 v_dash_array;\n\nvoid main() {\n  //dash输出\n  v_dash_array = pow(2.0, 20.0 - u_Zoom) * u_dash_array / a_SizeDistanceAndTotalDistance.a;\n\n  v_color = a_Color;\n  v_distanceScale = a_SizeDistanceAndTotalDistance.b / a_SizeDistanceAndTotalDistance.a;\n  v_color.a = v_color.a * opacity;\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0), a_Position64Low);\n\n  float h = float(a_Position.z) * u_vertexScale; // 线顶点的高度 - 兼容不存在第三个数值的情况\n\n  float lineHeight = a_SizeDistanceAndTotalDistance.y;\n  // 兼容 mapbox 在线高度上的效果表现基本一致\n  if (\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n  ) {\n    // 保持高度相对不变\n    h *= 2.0 / pow(2.0, 20.0 - u_Zoom);\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, lineHeight + h, 1.0));\n  gl_PointSize = 10.0;\n\n}\n';
var SimpleLineModel = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9
    });
  }
  getCommonUniformsInfo() {
    const {
      sourceColor,
      targetColor,
      lineType = "solid",
      dashArray = [10, 5, 0, 0],
      vertexHeightScale = 20
    } = this.layer.getLayerConfig();
    let u_dash_array = dashArray;
    if (lineType !== "dash") {
      u_dash_array = [0, 0, 0, 0];
    }
    if (u_dash_array.length === 2) {
      u_dash_array.push(0, 0);
    }
    let useLinearColor = 0;
    let sourceColorArr = [0, 0, 0, 0];
    let targetColorArr = [0, 0, 0, 0];
    if (sourceColor && targetColor) {
      sourceColorArr = rgb2arr(sourceColor);
      targetColorArr = rgb2arr(targetColor);
      useLinearColor = 1;
    }
    const commonOptions = {
      u_sourceColor: sourceColorArr,
      u_targetColor: targetColorArr,
      u_dash_array,
      // 顶点高度 scale
      u_vertexScale: vertexHeightScale,
      // 渐变色支持参数
      u_linearColor: useLinearColor
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  getShaders() {
    return {
      frag: simple_line_frag,
      vert: simple_line_vert,
      type: "lineSimpleNormal"
    };
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const {
        frag,
        vert,
        type
      } = _this2.getShaders();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        triangulation: SimpleLineTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        primitive: gl.LINES,
        depth: {
          enable: false
        },
        pick: false
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "sizeDistanceAndTotalDistance",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_SizeDistanceAndTotalDistance",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature, featureIdx, vertex) => {
          const {
            size: size2 = 1
          } = feature;
          const a_Size = Array.isArray(size2) ? [size2[0], size2[1]] : [size2, 0];
          return [a_Size[0], a_Size[1], vertex[3], vertex[5]];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/line/models/wall.js
var line_frag2 = '#define Animate 0.0\n#define LineTexture 1.0\n\n// line texture\n\nuniform sampler2D u_texture;\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float u_icon_step: 100;\n  float u_heightfixed;\n  float u_linearColor: 0;\n  float u_line_texture;\n  float u_textureBlend;\n  float u_iconStepCount;\n  float u_time;\n};\n\n\nin vec2 v_iconMapUV;\nin vec4 v_color;\nin float v_blur;\nin vec4 v_dataset;\n\nout vec4 outputColor;\n\n#pragma include "picking"\n\nvoid main() {\n  float animateSpeed = 0.0; // 运动速度\n  float d_distance_ratio = v_dataset.r; // 当前点位距离占线总长的比例\n  float v = v_dataset.a;\n\n  if(u_linearColor == 1.0) { // 使用渐变颜色\n    outputColor = mix(u_sourceColor, u_targetColor, v);\n  } else { // 使用 color 方法传入的颜色\n     outputColor = v_color;\n  }\n\n  outputColor.a *= v_color.a; // 全局透明度\n  if(u_animate.x == Animate) {\n      animateSpeed = u_time / u_animate.y;\n       float alpha =1.0 - fract( mod(1.0- d_distance_ratio, u_animate.z)* (1.0/ u_animate.z) + animateSpeed);\n      alpha = (alpha + u_animate.w -1.0) / u_animate.w;\n      alpha = smoothstep(0., 1., alpha);\n      outputColor.a *= alpha;\n  }\n\n  if(u_line_texture == LineTexture) { // while load texture\n    float aDistance = v_dataset.g;      // 当前顶点的距离\n    float d_texPixelLen = v_dataset.b;  // 贴图的像素长度，根据地图层级缩放\n    float u = fract(mod(aDistance, d_texPixelLen)/d_texPixelLen - animateSpeed);\n    float v = v_dataset.a;  // 线图层贴图部分的 v 坐标值\n\n    // 计算纹理间隔 start\n    float flag = 0.0;\n    if(u > 1.0/u_iconStepCount) {\n      flag = 1.0;\n    }\n    u = fract(u*u_iconStepCount);\n    // 计算纹理间隔 end\n\n    vec2 uv= v_iconMapUV / u_textSize + vec2(u, v) / u_textSize * 64.;\n    vec4 pattern = texture(SAMPLER_2D(u_texture), uv);\n\n    // Tip: 判断纹理间隔\n    if(flag > 0.0) {\n      pattern = vec4(0.0);\n    }\n\n    if(u_textureBlend == 0.0) { // normal\n      pattern.a = 0.0;\n      outputColor = filterColor(outputColor + pattern);\n    } else { // replace\n        pattern.a *= v_color.a;\n        if(outputColor.a <= 0.0) {\n          pattern.a = 0.0;\n        }\n        outputColor = filterColor(pattern);\n    }\n  }\n\n\n  // blur - AA\n  if(v < v_blur) {\n    outputColor.a = mix(0.0, outputColor.a, v/v_blur);\n  } else if(v > 1.0 - v_blur) {\n    outputColor.a = mix(outputColor.a, 0.0, (v - (1.0 - v_blur))/v_blur);\n  }\n\n  outputColor = filterColor(outputColor);\n}\n';
var line_vert2 = '#define Animate 0.0\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec2 a_Size;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_iconMapUV;\nlayout(location = ATTRIBUTE_LOCATION_DISTANCE_MITER_TOTAL) in vec3 a_Distance_Total_Miter;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_animate: [ 1., 2., 1.0, 0.2 ];\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  vec2 u_textSize;\n  float u_icon_step: 100;\n  float u_heightfixed;\n  float u_linearColor: 0;\n  float u_line_texture;\n  float u_textureBlend;\n  float u_iconStepCount;\n  float u_time;\n};\n\n// texV 线图层 - 贴图部分的 v 坐标（线的宽度方向）\nout vec2 v_iconMapUV;\nout vec4 v_color;\nout float v_blur;\nout vec4 v_dataset;\n\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\nvoid main() {\n  float a_Distance = a_Distance_Total_Miter.x;\n  float a_Miter = a_Distance_Total_Miter.y;\n  float a_Total_Distance = a_Distance_Total_Miter.z;\n\n  float d_distance_ratio; // 当前点位距离占线总长的比例\n  float d_texPixelLen; // 贴图的像素长度，根据地图层级缩放\n\n  v_iconMapUV = a_iconMapUV;\n  if (u_heightfixed < 1.0) {\n    // 高度随 zoom 调整\n    d_texPixelLen = project_pixel(u_icon_step);\n  } else {\n    d_texPixelLen = u_icon_step;\n  }\n\n  if (u_animate.x == Animate || u_linearColor == 1.0) {\n    d_distance_ratio = a_Distance / a_Total_Distance;\n  }\n\n  float miter = (a_Miter + 1.0) / 2.0;\n  // 设置数据集的参数\n  v_dataset[0] = d_distance_ratio; // 当前点位距离占线总长的比例\n  v_dataset[1] = a_Distance; // 当前顶点的距离\n  v_dataset[2] = d_texPixelLen; // 贴图的像素长度，根据地图层级缩放\n  v_dataset[3] = miter; // 线图层贴图部分的 v 坐标值 0 - 1\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0, 1.0), a_Position64Low);\n\n  float originSize = a_Size.x; // 固定高度\n  if (u_heightfixed < 1.0) {\n    originSize = project_float_meter(a_Size.x); // 高度随 zoom 调整\n  }\n\n  float wallHeight = originSize * miter;\n  float lightWeight = calc_lighting(vec4(project_pos.xy, wallHeight, 1.0));\n\n  v_blur = min(project_float_pixel(2.0) / originSize, 0.05);\n  v_color = vec4(a_Color.rgb * lightWeight, a_Color.w * opacity);\n\n  // 兼容 mapbox 在线高度上的效果表现基本一致\n  if (\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n  ) {\n    // mapbox\n    // 保持高度相对不变\n    float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\n    if (u_heightfixed > 0.0) {\n      wallHeight *= mapboxZoomScale;\n    }\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, wallHeight, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n';
var LineWallModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "updateTexture", () => {
      const {
        createTexture2D
      } = this.rendererService;
      if (this.texture) {
        this.texture.update({
          data: this.iconService.getCanvas()
        });
        this.layer.render();
        return;
      }
      this.texture = createTexture2D({
        data: this.iconService.getCanvas(),
        mag: gl.NEAREST,
        min: gl.NEAREST,
        premultiplyAlpha: false,
        width: 1024,
        height: this.iconService.canvasHeight || 128
      });
      this.textures = [this.texture];
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      NORMAL: 12,
      UV: 13,
      DISTANCE_MITER_TOTAL: 15
    });
  }
  getCommonUniformsInfo() {
    const {
      sourceColor,
      targetColor,
      textureBlend = "normal",
      heightfixed = false,
      lineTexture = false,
      iconStep = 100,
      iconStepCount = 1
    } = this.layer.getLayerConfig();
    const {
      animateOption
    } = this.layer.getLayerConfig();
    if (this.rendererService.getDirty()) {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();
    }
    let useLinearColor = 0;
    let sourceColorArr = [0, 0, 0, 0];
    let targetColorArr = [0, 0, 0, 0];
    if (sourceColor && targetColor) {
      sourceColorArr = rgb2arr(sourceColor);
      targetColorArr = rgb2arr(targetColor);
      useLinearColor = 1;
    }
    const commonOptions = {
      u_animate: this.animateOption2Array(animateOption),
      u_sourceColor: sourceColorArr,
      u_targetColor: targetColorArr,
      u_textSize: [1024, this.iconService.canvasHeight || 128],
      u_icon_step: iconStep,
      u_heightfixed: Number(heightfixed),
      // 渐变色支持参数
      u_linearColor: useLinearColor,
      u_line_texture: lineTexture ? 1 : 0,
      // 传入线的标识
      u_textureBlend: textureBlend === "normal" ? 0 : 1,
      u_iconStepCount: iconStepCount,
      u_time: this.layer.getLayerAnimateTime() || 0
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  // public getAnimateUniforms(): IModelUniform {
  //   const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;
  //   return {
  //     u_animate: this.animateOption2Array(animateOption as IAnimateOption),
  //     u_time: this.layer.getLayerAnimateTime(),
  //   };
  // }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      _this.updateTexture();
      _this.iconService.on("imageUpdate", _this.updateTexture);
      return _this.buildModels();
    })();
  }
  clearModels() {
    var _this$texture2;
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    this.iconService.off("imageUpdate", this.updateTexture);
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "lineWall",
        vertexShader: line_vert2,
        fragmentShader: line_frag2,
        triangulation: LineTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        depth: {
          enable: false
        },
        blend: _this2.getBlend()
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature) => {
          const {
            size: size2 = 1
          } = feature;
          return Array.isArray(size2) ? [size2[0], size2[1]] : [size2, 0];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "normal",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Normal",
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        // @ts-ignore
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "distanceAndTotalAndMiter",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Distance_Total_Miter",
        shaderLocation: this.attributeLocation.DISTANCE_MITER_TOTAL,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4], vertex[5]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_iconMapUV",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature) => {
          const iconMap = this.iconService.getIconMap();
          const {
            texture
          } = feature;
          const {
            x,
            y
          } = iconMap[texture] || {
            x: 0,
            y: 0
          };
          return [x, y];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/line/models/index.js
var LineModels = {
  arc: ArcModel,
  arc3d: Arc3DModel,
  greatcircle: GreatCircleModel,
  wall: LineWallModel,
  line: LineModel,
  simple: SimpleLineModel,
  flowline: FlowLineModel,
  earthArc3d: Arc3DModel
};
var models_default4 = LineModels;

// node_modules/@antv/l7-layers/es/line/index.js
var LineLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "LineLayer");
    _defineProperty(this, "enableShaderEncodeStyles", ["stroke", "offsets", "opacity", "thetaOffset"]);
    _defineProperty(this, "arrowInsertCount", 0);
    _defineProperty(this, "defaultSourceConfig", {
      data: [{
        lng1: 100,
        lat1: 30,
        lng2: 130,
        lat2: 30
      }],
      options: {
        parser: {
          type: "json",
          x: "lng1",
          y: "lat1",
          x1: "lng2",
          y1: "lat2"
        }
      }
    });
  }
  buildModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const shape = _this.getModelType();
      _this.layerModel = new models_default4[shape](_this);
      yield _this.initLayerModels();
    })();
  }
  getDefaultConfig() {
    const type = this.getModelType();
    const defaultConfig = {
      line: {},
      linearline: {},
      simple: {},
      wall: {},
      arc3d: {
        blend: "additive"
      },
      arc: {
        blend: "additive"
      },
      greatcircle: {
        blend: "additive"
      },
      tileLine: {},
      earthArc3d: {},
      flowline: {},
      arrow: {}
    };
    return defaultConfig[type];
  }
  getModelType() {
    var _shapeAttribute$scale;
    if (this.layerType) {
      return this.layerType;
    }
    const shapeAttribute = this.styleAttributeService.getLayerStyleAttribute("shape");
    const shape = shapeAttribute === null || shapeAttribute === void 0 || (_shapeAttribute$scale = shapeAttribute.scale) === null || _shapeAttribute$scale === void 0 ? void 0 : _shapeAttribute$scale.field;
    return shape || "line";
  }
  processData(filterData) {
    if (this.getModelType() !== "simple") {
      return filterData;
    }
    const dataArray = [];
    filterData.map((data) => {
      if (Array.isArray(data.coordinates) && Array.isArray(data.coordinates[0]) && Array.isArray(data.coordinates[0][0])) {
        const object = _objectSpread2({}, data);
        data.coordinates.map((d) => {
          dataArray.push(_objectSpread2(_objectSpread2({}, object), {}, {
            coordinates: d
          }));
        });
      } else {
        dataArray.push(data);
      }
    });
    return dataArray;
  }
};

// node_modules/@antv/l7-layers/es/point/models/billboard_point.js
var simplePointFrag = '\nlayout(std140) uniform commonUniorm {\n  vec4 u_stroke_color;\n  float u_additive;\n  float u_stroke_opacity;\n  float u_stroke_width;\n};\n\nin vec4 v_color;\nin float v_blur;\nin float v_innerRadius;\n\nout vec4 outputColor;\n\n#pragma include "picking"\nvoid main() {\n  vec2 center = vec2(0.5);\n\n  // Tip: 片元到中心点的距离 0 - 1\n  float fragmengTocenter = distance(center, gl_PointCoord) * 2.0;\n  // Tip: 片元的剪切成圆形\n  float circleClipOpacity = 1.0 - smoothstep(v_blur, 1.0, fragmengTocenter);\n\n\n  if(v_innerRadius < 0.99) {\n    // 当存在 stroke 且 stroke > 0.01\n    float blurWidth = (1.0 - v_blur)/2.0;\n    vec4 stroke = vec4(u_stroke_color.rgb, u_stroke_opacity);\n    if(fragmengTocenter > v_innerRadius + blurWidth) {\n      outputColor = stroke;\n    } else if(fragmengTocenter > v_innerRadius - blurWidth){\n      float mixR = (fragmengTocenter - (v_innerRadius - blurWidth)) / (blurWidth * 2.0);\n      outputColor = mix(v_color, stroke, mixR);\n    } else {\n      outputColor = v_color;\n    }\n  } else {\n    // 当不存在 stroke 或 stroke <= 0.01\n    outputColor = v_color;\n  }\n\n  outputColor = filterColor(outputColor);\n  \n  if(u_additive > 0.0) {\n    outputColor *= circleClipOpacity;\n  } else {\n    outputColor.a *= circleClipOpacity;\n  }\n\n}\n';
var simplePointVert = '\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_stroke_color;\n  float u_additive;\n  float u_stroke_opacity;\n  float u_stroke_width;\n};\n\nout vec4 v_color;\nout float v_blur;\nout float v_innerRadius;\n\n#pragma include "projection"\n#pragma include "picking"\n#pragma include "project"\nvoid main() {\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\n  v_blur = 1.0 - max(2.0 / a_Size, 0.05);\n  v_innerRadius = max((a_Size - u_stroke_width) / a_Size, 0.0);\n\n  vec2 offset = project_pixel(u_offsets);\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n  gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy+offset),project_pos.z,project_pos.w));\n\n  gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n  setPickingColor(a_PickingColor);\n}\n';
function PointTriangulation(feature) {
  const coordinates = feature.coordinates;
  return {
    vertices: [...coordinates],
    indices: [0],
    size: coordinates.length
  };
}
var SimplePointModel = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9
    });
  }
  getDefaultStyle() {
    return {
      blend: "additive"
    };
  }
  getCommonUniformsInfo() {
    const {
      blend,
      strokeOpacity = 1,
      strokeWidth = 0,
      stroke = "#fff"
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_stroke_color: rgb2arr(stroke),
      u_additive: blend === "additive" ? 1 : 0,
      u_stroke_opacity: strokeOpacity,
      u_stroke_width: strokeWidth
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.layer.triangulation = PointTriangulation;
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "pointSimple",
        vertexShader: simplePointVert,
        fragmentShader: simplePointFrag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation: PointTriangulation,
        depth: {
          enable: false
        },
        primitive: gl.POINTS
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 1
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/point/models/earthExtrude.js
var pointExtrudeFrag = 'precision highp float;\nin vec4 v_color;\n\n#pragma include "picking"\n\nlayout(std140) uniform commonUniform {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  float u_linearColor: 0;\n  float u_heightfixed: 0.0; // 默认不固定\n  float u_globel;\n  float u_r;\n  float u_pickLight: 0.0;\n  float u_opacitylinear: 0.0;\n  float u_opacitylinear_dir: 1.0;\n  float u_lightEnable: 1.0;\n};\nin float v_lightWeight;\nin float v_barLinearZ;\nout vec4 outputColor;\nvoid main() {\n\n   outputColor = v_color;\n\n  // 开启透明度渐变\n  if(u_opacitylinear > 0.0) {\n    outputColor.a *= u_opacitylinear_dir > 0.0 ? (1.0 - v_barLinearZ): v_barLinearZ;\n  }\n\n  // picking\n  if(u_pickLight > 0.0) {\n    outputColor = filterColorAlpha(outputColor, v_lightWeight);\n  } else {\n    outputColor = filterColor(outputColor);\n  }\n}\n';
var pointExtrudeVert = 'precision highp float;\n\n#define pi 3.1415926535\n#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec3 a_Size;\nlayout(location = ATTRIBUTE_LOCATION_POS) in vec3 a_Pos;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\n\nlayout(std140) uniform commonUniform {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  float u_linearColor: 0;\n  float u_heightfixed: 0.0; // 默认不固定\n  float u_globel;\n  float u_r;\n  float u_pickLight: 0.0;\n  float u_opacitylinear: 0.0;\n  float u_opacitylinear_dir: 1.0;\n  float u_lightEnable: 1.0;\n};\n\nout vec4 v_color;\nout float v_lightWeight;\nout float v_barLinearZ;\n// 用于将在顶点着色器中计算好的样式值传递给片元\n\n\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\nfloat getYRadian(float x, float z) {\n  if(x > 0.0 && z > 0.0) {\n    return atan(x/z);\n  } else if(x > 0.0 && z <= 0.0){\n    return atan(-z/x) + pi/2.0;\n  } else if(x <= 0.0 && z <= 0.0) {\n    return  pi + atan(x/z); //atan(x/z) +\n  } else {\n    return atan(z/-x) + pi*3.0/2.0;\n  }\n}\n\nfloat getXRadian(float y, float r) {\n  return atan(y/r);\n}\n\nvoid main() {\n\n  // cal style mapping - 数据纹理映射部分的计算\n  vec3 size = a_Size * a_Position;\n\n  // a_Position.z 是在构建网格的时候传入的标准值 0 - 1，在插值器插值可以获取 0～1 线性渐变的值\n  v_barLinearZ =  a_Position.z;\n\n  vec3 offset = size; // 控制圆柱体的大小 - 从标准单位圆柱体进行偏移\n  if(u_heightfixed < 1.0) { // 圆柱体不固定高度\n    //\n  } else {// 圆柱体固定高度 （ 处理 mapbox ）\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      offset *= 4.0/pow(2.0, 21.0 - u_Zoom);\n    }\n  }\n\n\n  vec4 project_pos = project_position(vec4(a_Pos.xy, 0., 1.0));\n\n  // u_r 控制圆柱的生长\n  vec4 pos = vec4(project_pos.xy + offset.xy, offset.z * u_r, 1.0);\n\n  // 圆柱光照效果\n  float lightWeight = 1.0;\n  if(u_lightEnable > 0.0) { // 取消三元表达式，增强健壮性\n    lightWeight = calc_lighting(pos);\n  }\n  v_lightWeight = lightWeight;\n  // 设置圆柱的底色\n  if(u_linearColor == 1.0) { // 使用渐变颜色\n    v_color = mix(u_sourceColor, u_targetColor, v_barLinearZ);\n    v_color.rgb *= lightWeight;\n  } else { // 使用 color 方法传入的颜色\n     v_color = a_Color;\n  }\n  v_color.a *= u_opacity;\n\n\n  // 在地球模式下，将原本垂直于 xy 平面的圆柱调整姿态到适应圆的角度\n  //旋转矩阵mx，创建绕x轴旋转矩阵\n  float r = sqrt(a_Pos.z*a_Pos.z + a_Pos.x*a_Pos.x);\n  float xRadian = getXRadian(a_Pos.y, r);\n  float xcos = cos(xRadian);//求解旋转角度余弦值\n  float xsin = sin(xRadian);//求解旋转角度正弦值\n  mat4 mx = mat4(\n    1,0,0,0,\n    0,xcos,-xsin,0,\n    0,xsin,xcos,0,\n    0,0,0,1);\n\n  //旋转矩阵my，创建绕y轴旋转矩阵\n  float yRadian = getYRadian(a_Pos.x, a_Pos.z);\n  float ycos = cos(yRadian);//求解旋转角度余弦值\n  float ysin = sin(yRadian);//求解旋转角度正弦值\n  mat4 my = mat4(\n    ycos,0,-ysin,0,\n    0,1,0,0,\n    ysin,0,ycos,0,\n    0,0,0,1);\n\n  gl_Position = u_ViewProjectionMatrix * vec4(( my * mx *  vec4(a_Position * a_Size, 1.0)).xyz + a_Pos, 1.0);\n\n\n  setPickingColor(a_PickingColor);\n}\n';
var {
  isNumber: isNumber5
} = lodashUtil;
var ExtrudeModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "raiseCount", 0);
    _defineProperty(this, "raiseRepeat", 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      POS: 10,
      NORMAL: 11
    });
  }
  getCommonUniformsInfo() {
    const {
      animateOption = {
        enable: false,
        speed: 0.01,
        repeat: false
      },
      opacity = 1,
      sourceColor,
      targetColor,
      pickLight = false,
      heightfixed = true,
      opacityLinear = {
        enable: false,
        dir: "up"
      },
      lightEnable = true
    } = this.layer.getLayerConfig();
    let useLinearColor = 0;
    let sourceColorArr = [0, 0, 0, 0];
    let targetColorArr = [0, 0, 0, 0];
    if (sourceColor && targetColor) {
      sourceColorArr = rgb2arr(sourceColor);
      targetColorArr = rgb2arr(targetColor);
      useLinearColor = 1;
    }
    if (this.raiseCount < 1 && this.raiseRepeat > 0) {
      if (animateOption.enable) {
        const {
          speed = 0.01
        } = animateOption;
        this.raiseCount += speed;
        if (this.raiseCount >= 1) {
          if (this.raiseRepeat > 1) {
            this.raiseCount = 0;
            this.raiseRepeat--;
          } else {
            this.raiseCount = 1;
          }
        }
      }
    }
    const commonOptions = {
      u_sourceColor: sourceColorArr,
      u_targetColor: targetColorArr,
      // 渐变色支持参数
      u_linearColor: useLinearColor,
      // 圆柱体的拾取高亮是否要计算光照
      u_pickLight: Number(pickLight),
      // 圆柱体是否固定高度
      u_heightfixed: Number(heightfixed),
      u_r: animateOption.enable && this.raiseRepeat > 0 ? this.raiseCount : 1,
      u_opacity: isNumber5(opacity) ? opacity : 1,
      // 透明度渐变
      u_opacitylinear: Number(opacityLinear.enable),
      u_opacitylinear_dir: opacityLinear.dir === "up" ? 1 : 0,
      // 光照计算开关
      u_lightEnable: Number(lightEnable)
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        animateOption: {
          repeat = 1
        }
      } = _this2.layer.getLayerConfig();
      _this2.raiseRepeat = repeat;
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "pointEarthExtrude",
        vertexShader: pointExtrudeVert,
        fragmentShader: pointExtrudeFrag,
        triangulation: PointExtrudeTriangulation,
        depth: {
          enable: true
        },
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        cull: {
          enable: true,
          face: gl.FRONT
        },
        blend: _this2.getBlend()
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature) => {
          const {
            size: size2
          } = feature;
          if (size2) {
            let buffersize = [];
            if (Array.isArray(size2)) {
              buffersize = size2.length === 2 ? [size2[0], size2[0], size2[1]] : size2;
            }
            if (!Array.isArray(size2)) {
              buffersize = [size2, size2, size2];
            }
            return buffersize;
          } else {
            return [2, 2, 2];
          }
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "normal",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Normal",
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "pos",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Pos",
        shaderLocation: this.attributeLocation.POS,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature) => {
          const coordinates = calculateCentroid(feature.coordinates);
          return lglt2xyz([coordinates[0], coordinates[1]]);
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/point/models/earthFill.js
var pointFillFrag = `in vec4 v_data;
in vec4 v_color;
in float v_radius;

layout(std140) uniform commonUniform {
  float u_additive;
  float u_stroke_opacity : 1;
  float u_stroke_width : 2;
  float u_blur : 0.0;
};
#pragma include "sdf_2d"
#pragma include "picking"

out vec4 outputColor;

void main() {
  int shape = int(floor(v_data.w + 0.5));

  vec4 strokeColor = u_stroke == vec4(0.0) ? v_color : u_stroke;

  lowp float antialiasblur = v_data.z;
  float r = v_radius / (v_radius + u_stroke_width);

  float outer_df;
  float inner_df;
  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'
  if (shape == 0) {
    outer_df = sdCircle(v_data.xy, 1.0);
    inner_df = sdCircle(v_data.xy, r);
  } else if (shape == 1) {
    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);
    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);
  } else if (shape == 2) {
    outer_df = sdBox(v_data.xy, vec2(1.));
    inner_df = sdBox(v_data.xy, vec2(r));
  } else if (shape == 3) {
    outer_df = sdPentagon(v_data.xy, 0.8);
    inner_df = sdPentagon(v_data.xy, r * 0.8);
  } else if (shape == 4) {
    outer_df = sdHexagon(v_data.xy, 0.8);
    inner_df = sdHexagon(v_data.xy, r * 0.8);
  } else if (shape == 5) {
    outer_df = sdOctogon(v_data.xy, 1.0);
    inner_df = sdOctogon(v_data.xy, r);
  } else if (shape == 6) {
    outer_df = sdHexagram(v_data.xy, 0.52);
    inner_df = sdHexagram(v_data.xy, r * 0.52);
  } else if (shape == 7) {
    outer_df = sdRhombus(v_data.xy, vec2(1.0));
    inner_df = sdRhombus(v_data.xy, vec2(r));
  } else if (shape == 8) {
    outer_df = sdVesica(v_data.xy, 1.1, 0.8);
    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);
  }

  if(outer_df > antialiasblur + 0.018) discard;

  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);

  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(
    antialiasblur,
    0.0,
    inner_df
  );

  if(u_stroke_width < 0.01) {
    outputColor = vec4(v_color.rgb, v_color.a * u_opacity);
  } else {
    outputColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), strokeColor * u_stroke_opacity, color_t);
  }

  if(u_additive > 0.0) {
    outputColor *= opacity_t;
    outputColor = filterColorAlpha(outputColor, outputColor.a);
  } else {
    outputColor.a *= opacity_t;
    outputColor = filterColor(outputColor);
  }
}
`;
var pointFillVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_SHAPE) in float a_Shape;\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\n\nlayout(std140) uniform commonUniform {\n  float u_additive;\n  float u_stroke_opacity : 1;\n  float u_stroke_width : 2;\n  float u_blur : 0.0;\n};\nout vec4 v_data;\nout vec4 v_color;\nout float v_radius;\n\n#pragma include "projection"\n#pragma include "picking"\n\n\nvoid main() {\n  vec3 extrude = a_Extrude;\n  float shape_type = a_Shape;\n  /*\n  *  setPickingSize 设置拾取大小\n  */\n  float newSize = setPickingSize(a_Size);\n  // float newSize = setPickingSize(a_Size) * 0.00001038445708445579;\n\n  // unpack color(vec2)\n  v_color = a_Color;\n\n  // radius(16-bit)\n  v_radius = newSize;\n\n  // anti-alias\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / newSize, u_blur);\n\n  // TODP: /abs(extrude.x) 是为了兼容地球模式\n  v_data = vec4(extrude.x/abs(extrude.x), extrude.y/abs(extrude.y), antialiasblur,shape_type);\n\n  gl_Position = u_ViewProjectionMatrix * vec4(a_Position + extrude * newSize * 0.1 + vec3(u_offsets,0.0), 1.0);\n\n  setPickingColor(a_PickingColor);\n}\n';
var FillModel = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      SHAPE: 10,
      EXTRUDE: 11
    });
  }
  getCommonUniformsInfo() {
    const {
      strokeOpacity = 1,
      strokeWidth = 0,
      // offsets = [0, 0],
      blend,
      blur = 0
    } = this.layer.getLayerConfig();
    this.layer.getLayerConfig();
    const commonOptions = {
      u_additive: blend === "additive" ? 1 : 0,
      u_stroke_opacity: strokeOpacity,
      u_stroke_width: strokeWidth,
      u_blur: blur
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.layer.triangulation = GlobelPointFillTriangulation;
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "pointEarthFill",
        vertexShader: pointFillVert,
        fragmentShader: pointFillFrag,
        triangulation: GlobelPointFillTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        depth: {
          enable: true
        },
        blend: _this2.getBlend()
      });
      return [model];
    })();
  }
  // overwrite baseModel func
  animateOption2Array(option) {
    return [option.enable ? 0 : 1, option.speed || 1, option.rings || 3, 0];
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "extrude",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Extrude",
        shaderLocation: this.attributeLocation.EXTRUDE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx) => {
          const [x, y, z] = vertex;
          const n1 = vec3_exports.fromValues(0, 0, 1);
          const n2 = vec3_exports.fromValues(x, 0, z);
          const xzReg = x >= 0 ? vec3_exports.angle(n1, n2) : Math.PI * 2 - vec3_exports.angle(n1, n2);
          const yReg = Math.PI * 2 - Math.asin(y / 100);
          const m = mat4_exports.create();
          mat4_exports.rotateY(m, m, xzReg);
          mat4_exports.rotateX(m, m, yReg);
          const v1 = vec3_exports.fromValues(1, 1, 0);
          vec3_exports.transformMat4(v1, v1, m);
          vec3_exports.normalize(v1, v1);
          const v2 = vec3_exports.fromValues(-1, 1, 0);
          vec3_exports.transformMat4(v2, v2, m);
          vec3_exports.normalize(v2, v2);
          const v3 = vec3_exports.fromValues(-1, -1, 0);
          vec3_exports.transformMat4(v3, v3, m);
          vec3_exports.normalize(v3, v3);
          const v4 = vec3_exports.fromValues(1, -1, 0);
          vec3_exports.transformMat4(v4, v4, m);
          vec3_exports.normalize(v4, v4);
          const extrude = [...v1, ...v2, ...v3, ...v4];
          const extrudeIndex = attributeIdx % 4 * 3;
          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 5
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "shape",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Shape",
        shaderLocation: this.attributeLocation.SHAPE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            shape = 2
          } = feature;
          const shape2d = this.layer.getLayerConfig().shape2d;
          const shapeIndex = shape2d.indexOf(shape);
          return [shapeIndex];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/point/models/extrude.js
var pointExtrudeFrag2 = '\nin vec4 v_color;\nin float v_lightWeight;\nout vec4 outputColor;\n\nlayout(std140) uniform commonUniforms {\n  float u_pickLight;\n  float u_heightfixed;\n  float u_r;\n  float u_linearColor;\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  float u_opacitylinear;\n  float u_opacitylinear_dir;\n  float u_lightEnable;\n};\n\n#pragma include "scene_uniforms"\n#pragma include "picking"\n\nvoid main() {\n\n  outputColor = v_color;\n  // 开启透明度渐变\n  // picking\n  if(u_pickLight > 0.0) {\n    outputColor = filterColorAlpha(outputColor, v_lightWeight);\n  } else {\n    outputColor = filterColor(outputColor);\n  }\n}\n';
var pointExtrudeVert2 = '#define pi (3.1415926535)\n\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in vec3 a_Size;\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec4 a_Extrude;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\n\nlayout(std140) uniform commonUniforms {\n  float u_pickLight;\n  float u_heightfixed;\n  float u_r;\n  float u_linearColor;\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  float u_opacitylinear;\n  float u_opacitylinear_dir;\n  float u_lightEnable;\n};\nout vec4 v_color;\nout float v_lightWeight;\n\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\nfloat getYRadian(float x, float z) {\n  if (x > 0.0 && z > 0.0) {\n    return atan(x / z);\n  } else if (x > 0.0 && z <= 0.0) {\n    return atan(-z / x) + pi / 2.0;\n  } else if (x <= 0.0 && z <= 0.0) {\n    return pi + atan(x / z); //atan(x/z) +\n  } else {\n    return atan(z / -x) + pi * 3.0 / 2.0;\n  }\n}\n\nfloat getXRadian(float y, float r) {\n  return atan(y / r);\n}\n\nvoid main() {\n  vec3 size = a_Size * a_Position;\n\n  vec3 offset = size; // 控制圆柱体的大小 - 从标准单位圆柱体进行偏移\n\n  if (u_heightfixed < 1.0) {\n    // 圆柱体不固定高度\n  } else {\n    // 圆柱体固定高度 （ 处理 mapbox ）\n    if (\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n    ) {\n      offset *= 4.0 / pow(2.0, 21.0 - u_Zoom);\n    }\n  }\n\n  vec2 positions = a_Extrude.xy;\n  vec2 positions64Low = a_Extrude.zw;\n  vec4 project_pos = project_position(vec4(positions, 0.0, 1.0), positions64Low);\n\n  // u_r 控制圆柱的生长\n  vec4 pos = vec4(project_pos.xy + offset.xy, offset.z * u_r, 1.0);\n\n  // // 圆柱光照效果\n  float lightWeight = 1.0;\n\n  if (u_lightEnable > 0.0) {\n    // 取消三元表达式，增强健壮性\n    lightWeight = calc_lighting(pos);\n  }\n\n  v_lightWeight = lightWeight;\n\n  v_color = a_Color;\n\n  // 设置圆柱的底色\n  if (u_linearColor == 1.0) {\n    // 使用渐变颜色\n    v_color = mix(u_sourceColor, u_targetColor, a_Position.z);\n    v_color.a = v_color.a * opacity;\n  } else {\n    v_color = vec4(a_Color.rgb * lightWeight, a_Color.w * opacity);\n  }\n\n  if (u_opacitylinear > 0.0) {\n    v_color.a *= u_opacitylinear_dir > 0.0 ? 1.0 - a_Position.z : a_Position.z;\n  }\n\n  gl_Position = project_common_position_to_clipspace(pos);\n\n  setPickingColor(a_PickingColor);\n}\n';
var ExtrudeModel2 = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "raiseCount", 0);
    _defineProperty(this, "raiseRepeat", 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      EXTRUDE: 10,
      NORMAL: 11
    });
  }
  getCommonUniformsInfo() {
    const {
      animateOption = {
        enable: false,
        speed: 0.01,
        repeat: false
      },
      sourceColor,
      targetColor,
      pickLight = false,
      heightfixed = false,
      opacityLinear = {
        enable: false,
        dir: "up"
      },
      lightEnable = true
    } = this.layer.getLayerConfig();
    let useLinearColor = 0;
    let sourceColorArr = [0, 0, 0, 0];
    let targetColorArr = [0, 0, 0, 0];
    if (sourceColor && targetColor) {
      sourceColorArr = rgb2arr(sourceColor);
      targetColorArr = rgb2arr(targetColor);
      useLinearColor = 1;
    }
    if (this.raiseCount < 1 && this.raiseRepeat > 0) {
      if (animateOption.enable) {
        const {
          speed = 0.01
        } = animateOption;
        this.raiseCount += speed;
        if (this.raiseCount >= 1) {
          if (this.raiseRepeat > 1) {
            this.raiseCount = 0;
            this.raiseRepeat--;
          } else {
            this.raiseCount = 1;
          }
        }
      }
    }
    const commonOptions = {
      // 圆柱体的拾取高亮是否要计算光照
      u_pickLight: Number(pickLight),
      // 圆柱体是否固定高度
      u_heightfixed: Number(heightfixed),
      u_r: animateOption.enable && this.raiseRepeat > 0 ? this.raiseCount : 1,
      // 渐变色支持参数
      u_linearColor: useLinearColor,
      u_sourceColor: sourceColorArr,
      u_targetColor: targetColorArr,
      // 透明度渐变
      u_opacitylinear: Number(opacityLinear.enable),
      u_opacitylinear_dir: opacityLinear.dir === "up" ? 1 : 0,
      // 光照计算开关
      u_lightEnable: Number(lightEnable)
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        depth = true,
        animateOption: {
          repeat = 1
        }
      } = _this2.layer.getLayerConfig();
      _this2.raiseRepeat = repeat;
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "pointExtrude",
        vertexShader: pointExtrudeVert2,
        fragmentShader: pointExtrudeFrag2,
        triangulation: PointExtrudeTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        cull: {
          enable: true,
          face: gl.FRONT
        },
        depth: {
          enable: depth
        }
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature) => {
          const {
            size: size2
          } = feature;
          if (size2) {
            let buffersize = [];
            if (Array.isArray(size2)) {
              buffersize = size2.length === 2 ? [size2[0], size2[0], size2[1]] : size2;
            }
            if (!Array.isArray(size2)) {
              buffersize = [size2, size2, size2];
            }
            return buffersize;
          } else {
            return [2, 2, 2];
          }
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "normal",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Normal",
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "extrude",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Extrude",
        shaderLocation: this.attributeLocation.EXTRUDE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 4,
        update: (feature) => {
          const coordinates = calculateCentroid(feature.coordinates);
          return [coordinates[0], coordinates[1], fp64LowPart(coordinates[0]), fp64LowPart(coordinates[1])];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/point/models/fill.js
var pointFillFrag2 = `
layout(std140) uniform commonUniforms {
  vec3 u_blur_height_fixed;
  float u_stroke_width;
  float u_additive;
  float u_stroke_opacity;
  float u_size_unit;
  float u_time;
  vec4 u_animate;
};

in vec4 v_color;
in vec4 v_stroke;
in vec4 v_data;
in float v_radius;

#pragma include "scene_uniforms"
#pragma include "sdf_2d"
#pragma include "picking"

out vec4 outputColor;

void main() {
  int shape = int(floor(v_data.w + 0.5));
  lowp float antialiasblur = v_data.z;
  float r = v_radius / (v_radius + u_stroke_width);

  float outer_df;
  float inner_df;
  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'
  if (shape == 0) {
    outer_df = sdCircle(v_data.xy, 1.0);
    inner_df = sdCircle(v_data.xy, r);
  } else if (shape == 1) {
    outer_df = sdEquilateralTriangle(1.1 * v_data.xy);
    inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);
  } else if (shape == 2) {
    outer_df = sdBox(v_data.xy, vec2(1.));
    inner_df = sdBox(v_data.xy, vec2(r));
  } else if (shape == 3) {
    outer_df = sdPentagon(v_data.xy, 0.8);
    inner_df = sdPentagon(v_data.xy, r * 0.8);
  } else if (shape == 4) {
    outer_df = sdHexagon(v_data.xy, 0.8);
    inner_df = sdHexagon(v_data.xy, r * 0.8);
  } else if (shape == 5) {
    outer_df = sdOctogon(v_data.xy, 1.0);
    inner_df = sdOctogon(v_data.xy, r);
  } else if (shape == 6) {
    outer_df = sdHexagram(v_data.xy, 0.52);
    inner_df = sdHexagram(v_data.xy, r * 0.52);
  } else if (shape == 7) {
    outer_df = sdRhombus(v_data.xy, vec2(1.0));
    inner_df = sdRhombus(v_data.xy, vec2(r));
  } else if (shape == 8) {
    outer_df = sdVesica(v_data.xy, 1.1, 0.8);
    inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);
  }

  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);

  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(
    antialiasblur,
    0.0,
    inner_df
  );

  float PI = 3.14159;
  float N_RINGS = 3.0;
  float FREQ = 1.0;

  if(u_stroke_width < 0.01) {
    outputColor = v_color;
  } else {
    outputColor = mix(v_color, v_stroke * u_stroke_opacity, color_t);
  }
  float intensity = 1.0;
  if(u_time!=-1.0){
    //wave相关逻辑
    float d = length(v_data.xy);
    if(d > 0.5) {
      discard;
    }
    intensity = clamp(cos(d * PI), 0.0, 1.0) * clamp(cos(2.0 * PI * (d * 2.0 * u_animate.z - u_animate.y * u_time)), 0.0, 1.0);
  }

  if(u_additive > 0.0) {
    outputColor *= opacity_t;
    outputColor *= intensity;//wave
    outputColor = filterColorAlpha(outputColor, outputColor.a);
  } else {
    outputColor.a *= opacity_t;
    outputColor.a *= intensity;//wave 
    outputColor = filterColor(outputColor);
  }
   // 作为 mask 模板时需要丢弃透明的像素
  if(outputColor.a < 0.01) {
    discard;
  } 
}
`;
var pointFillVert2 = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_SHAPE) in float a_Shape;\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\n\nlayout(std140) uniform commonUniforms {\n  vec3 u_blur_height_fixed;\n  float u_stroke_width;\n  float u_additive;\n  float u_stroke_opacity;\n  float u_size_unit;\n  float u_time;\n  vec4 u_animate;\n};\n\nout vec4 v_color;\nout vec4 v_stroke;\nout vec4 v_data;\nout float v_radius;\n\n#pragma include "projection"\n#pragma include "picking"\n#pragma include "rotation_2d"\n\nvoid main() {\n  // 透明度计算\n   v_stroke = stroke;\n  vec3 extrude = a_Extrude;\n  float shape_type = a_Shape;\n  /*\n  *  setPickingSize 设置拾取大小\n  *  u_meter2coord 在等面积大小的时候设置单位\n  */\n  float newSize = setPickingSize(a_Size);\n  // float newSize = setPickingSize(a_Size) * 0.00001038445708445579;\n\n\n\n  // unpack color(vec2)\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\n\n  if(u_size_unit == 1.0) {\n    newSize = newSize  * u_PixelsPerMeter.z;\n  }\n\n   v_radius = newSize;\n\n  // anti-alias\n  //  float antialiased_blur = -max(u_blur, antialiasblur);\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / newSize, u_blur_height_fixed.x);\n\n  vec2 offset = (extrude.xy * (newSize + u_stroke_width) + u_offsets);\n\n  offset = project_pixel(offset);\n  offset = rotate_matrix(offset,rotation);\n\n  // TODP: /abs(extrude.x) 是为了兼容地球模式\n  v_data = vec4(extrude.x/abs(extrude.x), extrude.y/abs(extrude.y), antialiasblur,shape_type);\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0), a_Position64Low);\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\n\n  float raisingHeight = u_blur_height_fixed.y;\n\n  if(u_blur_height_fixed.z < 1.0) { // false\n    raisingHeight = project_pixel(u_blur_height_fixed.y);\n  } else {\n     if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n      float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n      raisingHeight = u_blur_height_fixed.y * mapboxZoomScale;\n    }\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, raisingHeight, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n';
var FillModel2 = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      SHAPE: 10,
      EXTRUDE: 11
    });
  }
  getCommonUniformsInfo() {
    const {
      strokeOpacity = 1,
      strokeWidth = 0,
      blend,
      blur = 0,
      raisingHeight = 0,
      heightfixed = false,
      unit: unit2 = "pixel"
    } = this.layer.getLayerConfig();
    let u_time = this.getAnimateUniforms().u_time;
    if (isNaN(u_time)) {
      u_time = -1;
    }
    const commonOptions = {
      u_blur_height_fixed: [blur, Number(raisingHeight), Number(heightfixed)],
      u_stroke_width: strokeWidth,
      u_additive: blend === "additive" ? 1 : 0,
      u_stroke_opacity: strokeOpacity,
      u_size_unit: SizeUnitType[unit2],
      u_time,
      u_animate: this.getAnimateUniforms().u_animate
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getAnimateUniforms() {
    const {
      animateOption = {
        enable: false
      }
    } = this.layer.getLayerConfig();
    return {
      u_animate: this.animateOption2Array(animateOption),
      u_time: this.layer.getLayerAnimateTime()
    };
  }
  getAttribute() {
    return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), PointFillTriangulation);
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        frag,
        vert,
        type
      } = _this2.getShaders();
      _this2.layer.triangulation = PointFillTriangulation;
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation: PointFillTriangulation,
        depth: {
          enable: false
        }
      });
      return [model];
    })();
  }
  /**
   * 根据 animateOption 的值返回对应的 shader 代码
   * @returns
   */
  getShaders() {
    return {
      frag: pointFillFrag2,
      vert: pointFillVert2,
      type: "pointFill"
    };
  }
  // overwrite baseModel func
  animateOption2Array(option) {
    return [option.enable ? 0 : 1, option.speed || 1, option.rings || 3, 0];
  }
  registerBuiltinAttributes() {
    const shape2d = this.layer.getLayerConfig().shape2d;
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "extrude",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Extrude",
        shaderLocation: this.attributeLocation.EXTRUDE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx) => {
          const extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
          const extrudeIndex = attributeIdx % 4 * 3;
          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 5
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "shape",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Shape",
        shaderLocation: this.attributeLocation.SHAPE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            shape = 2
          } = feature;
          const shapeIndex = shape2d.indexOf(shape);
          return [shapeIndex];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/point/models/fillImage.js
var pointFillFrag3 = 'in vec2 v_uv;// 本身的 uv 坐标\nin vec2 v_Iconuv;\nin float v_opacity;\nout vec4 outputColor;\n\nuniform sampler2D u_texture;\nlayout(std140) uniform commonUniform {\n  vec2 u_textSize;\n  float u_heightfixed: 0.0;\n  float u_raisingHeight: 0.0;\n  float u_size_unit;\n};\n\n#pragma include "scene_uniforms"\n#pragma include "sdf_2d"\n#pragma include "picking"\n\nvoid main() {\n  vec2 pos = v_Iconuv / u_textSize + v_uv / u_textSize * 64.;\n  outputColor = texture(SAMPLER_2D(u_texture), pos);\n  outputColor.a *= v_opacity;\n  outputColor = filterColor(outputColor);\n}\n';
var pointFillVert3 = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniform {\n  vec2 u_textSize;\n  float u_heightfixed;\n  float u_raisingHeight;\n  float u_size_unit;\n};\n\nout vec2 v_uv;\nout vec2 v_Iconuv;\nout float v_opacity;\n\n#pragma include "projection"\n#pragma include "picking"\n#pragma include "rotation_2d"\n\nvoid main() {\n  vec3 extrude = a_Extrude;\n  v_uv = (a_Extrude.xy + 1.0) / 2.0;\n  v_uv.y = 1.0 - v_uv.y;\n  v_Iconuv = a_Uv;\n  v_opacity = opacity;\n  float newSize = a_Size;\n  if (u_size_unit == 1.0) {\n    newSize = newSize * u_PixelsPerMeter.z;\n  }\n\n  // vec2 offset = (u_RotateMatrix * extrude.xy * (a_Size) + textrueOffsets);\n  vec2 offset = extrude.xy * newSize + offsets;\n\n  offset = rotate_matrix(offset, rotation);\n\n  offset = project_pixel(offset);\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0), a_Position64Low);\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n';
var FillImageModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "meter2coord", 1);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "isMeter", false);
    _defineProperty(this, "radian", 0);
    _defineProperty(this, "updateTexture", () => {
      const {
        createTexture2D
      } = this.rendererService;
      if (this.texture) {
        this.texture.update({
          data: this.iconService.getCanvas(),
          mag: "linear",
          min: "linear mipmap nearest",
          mipmap: true
        });
        this.layerService.throttleRenderLayers();
        return;
      }
      this.texture = createTexture2D({
        data: this.iconService.getCanvas(),
        mag: gl.LINEAR,
        min: gl.LINEAR_MIPMAP_LINEAR,
        premultiplyAlpha: false,
        width: 1024,
        height: this.iconService.canvasHeight || 128,
        mipmap: true
      });
      this.textures = [this.texture];
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      EXTRUDE: 10,
      UV: 11
    });
  }
  // 旋转的弧度
  getCommonUniformsInfo() {
    const {
      raisingHeight = 0,
      heightfixed = false,
      unit: unit2 = "pixel"
    } = this.layer.getLayerConfig();
    if (this.rendererService.getDirty()) {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();
    }
    const commonOptions = {
      u_textSize: [1024, this.iconService.canvasHeight || 128],
      u_heightfixed: Number(heightfixed),
      u_raisingHeight: Number(raisingHeight),
      u_size_unit: SizeUnitType[unit2]
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getAttribute() {
    return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), PointFillTriangulation);
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.iconService.on("imageUpdate", _this.updateTexture);
      _this.updateTexture();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "pointFillImage",
        vertexShader: pointFillVert3,
        fragmentShader: pointFillFrag3,
        triangulation: PointFillTriangulation,
        depth: {
          enable: false
        },
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        cull: {
          enable: true,
          face: gl.FRONT
        }
      });
      return [model];
    })();
  }
  clearModels() {
    var _this$texture2;
    this.iconService.off("imageUpdate", this.updateTexture);
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
  }
  // overwrite baseModel func
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature) => {
          const iconMap = this.iconService.getIconMap();
          const {
            shape
          } = feature;
          const {
            x,
            y
          } = iconMap[shape] || {
            x: -64,
            y: -64
          };
          return [x, y];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "extrude",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Extrude",
        shaderLocation: this.attributeLocation.EXTRUDE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx) => {
          const extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
          const extrudeIndex = attributeIdx % 4 * 3;
          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 5
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/point/models/image.js
var pointImageFrag = 'layout(std140) uniform commonUniforms {\n  vec2 u_textSize;\n  float u_raisingHeight;\n  float u_heightfixed;\n};\n\nuniform sampler2D u_texture;\n\nin vec4 v_color;\nin vec2 v_uv;\nin float v_opacity;\n\n#pragma include "picking"\n\nout vec4 outputColor;\n\nvoid main(){\n  vec2 pos = v_uv / u_textSize + gl_PointCoord / u_textSize * 64.;\n  vec4 textureColor;\n\n  // Y = 0.299R + 0.587G + 0.114B // 亮度提取\n  \n  textureColor = texture(SAMPLER_2D(u_texture), pos);\n\n  // Tip: 去除边缘部分 mipmap 导致的混合变暗\n  float fragmengTocenter = distance(vec2(0.5), gl_PointCoord);\n  if(fragmengTocenter >= 0.5) {\n        float luma = 0.299 * textureColor.r + 0.587 * textureColor.g + 0.114 * textureColor.b;\n        textureColor.a *= luma;\n  }\n  \n  if(all(lessThan(v_color, vec4(1.0+0.00001))) && all(greaterThan(v_color, vec4(1.0-0.00001))) || v_color==vec4(1.0)){\n        outputColor= textureColor;\n  }else {\n        outputColor= step(0.01, textureColor.z) * v_color;\n  }\n  outputColor.a *= v_opacity;\n  if (outputColor.a < 0.01) {\n      discard;\n  }\n  outputColor = filterColor(outputColor);\n}\n';
var pointImageVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_textSize;\n  float u_raisingHeight;\n  float u_heightfixed;\n};\n\nout vec4 v_color;\nout vec2 v_uv;\nout float v_opacity;\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n  v_color = a_Color;\n  v_opacity = opacity;\n  v_uv = a_Uv;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n\n  vec2 offset = project_pixel(offsets);\n\n  float raisingHeight = u_raisingHeight;\n  if (u_heightfixed < 1.0) {\n    // false\n    raisingHeight = project_pixel(u_raisingHeight);\n  } else {\n    if (\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n    ) {\n      float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\n      raisingHeight = u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, raisingHeight, 1.0));\n\n  gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n  setPickingColor(a_PickingColor);\n}\n';
var ImageModel2 = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "updateTexture", () => {
      const {
        createTexture2D
      } = this.rendererService;
      if (this.texture) {
        this.texture.update({
          data: this.iconService.getCanvas(),
          mag: "linear",
          min: "linear mipmap nearest",
          mipmap: true
        });
        setTimeout(() => {
          this.layerService.throttleRenderLayers();
        });
        return;
      }
      this.texture = createTexture2D({
        data: this.iconService.getCanvas(),
        mag: gl.LINEAR,
        min: gl.LINEAR_MIPMAP_LINEAR,
        premultiplyAlpha: false,
        width: 1024,
        height: this.iconService.canvasHeight || 128,
        mipmap: true
      });
    });
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      UV: 10
    });
  }
  getUninforms() {
    if (this.rendererService.getDirty()) {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.bind();
    }
    const commonInfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commonInfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      raisingHeight = 0,
      heightfixed = false
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_textSize: [1024, this.iconService.canvasHeight || 128],
      u_raisingHeight: Number(raisingHeight),
      u_heightfixed: Number(heightfixed),
      u_texture: this.texture
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.iconService.on("imageUpdate", _this.updateTexture);
      _this.updateTexture();
      return _this.buildModels();
    })();
  }
  clearModels() {
    var _this$texture2;
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    this.iconService.off("imageUpdate", this.updateTexture);
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "pointImage",
        vertexShader: pointImageVert,
        fragmentShader: pointImageFrag,
        triangulation: PointImageTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        depth: {
          enable: false
        },
        primitive: gl.POINTS
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 5
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature) => {
          const iconMap = this.iconService.getIconMap();
          const {
            shape
          } = feature;
          const {
            x,
            y
          } = iconMap[shape] || {
            x: -64,
            y: -64
          };
          return [x, y];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/point/models/normal.js
var normalFrag = "in vec4 v_color;\nout vec4 outputColor;\nvoid main() {\n  outputColor = v_color;\n}";
var normalVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\n\nlayout(std140) uniform u_Common {\n  float u_size_scale;\n};\n\nout vec4 v_color;\n\n#pragma include "projection"\n#pragma include "project"\n\nvoid main() {\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n  gl_Position = project_common_position_to_clipspace(project_pos);\n\n  gl_PointSize = a_Size * u_size_scale * 2.0 * u_DevicePixelRatio;\n}\n';
function PointTriangulation2(feature) {
  const coordinates = feature.coordinates;
  return {
    vertices: [...coordinates],
    indices: [0],
    size: coordinates.length
  };
}
var NormalModel = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9
    });
  }
  getDefaultStyle() {
    return {
      blend: "additive"
    };
  }
  getCommonUniformsInfo() {
    const commonOptions = {
      u_size_scale: 0.5
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.layer.triangulation = PointTriangulation2;
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "pointNormal",
        vertexShader: normalVert,
        fragmentShader: normalFrag,
        triangulation: PointTriangulation2,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        depth: {
          enable: false
        },
        primitive: gl.POINTS,
        pick: false
      });
      return [model];
    })();
  }
  clearModels() {
    return;
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 1
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/point/models/radar.js
var pointFillFrag4 = '\nlayout(std140) uniform commonUniorm{\n  float u_additive;\n  float u_size_unit;\n  float u_speed: 1.0;\n  float u_time;\n};\nin vec4 v_data;\nin vec4 v_color;\nin float v_radius;\nin vec2 v_extrude;\n#pragma include "sdf_2d"\n#pragma include "picking"\n\nout vec4 outputColor;\n\nvoid main() {\n\n  lowp float antialiasblur = v_data.z;\n  float r = v_radius / (v_radius);\n\n  float outer_df = sdCircle(v_data.xy, 1.0);\n  float inner_df = sdCircle(v_data.xy, r);\n\n  float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\n\n  outputColor = vec4(v_color.rgb, v_color.a);\n\n  if(u_additive > 0.0) {\n    outputColor *= opacity_t;\n  } else {\n    outputColor.a *= opacity_t;\n  }\n\n  if(outputColor.a > 0.0) {\n    outputColor = filterColor(outputColor);\n  }\n\n  vec2 extrude =  v_extrude;\n  vec2 dir = normalize(extrude);\n  vec2 baseDir = vec2(1.0, 0.0);\n  float pi = 3.14159265359;\n  float flag = sign(dir.y);\n  float rades = dot(dir, baseDir);\n  float radar_v = (flag - 1.0) * -0.5 * acos(rades)/pi;\n  // simple AA\n  if(radar_v > 0.99) {\n    radar_v = 1.0 - (radar_v - 0.99)/0.01;\n  }\n\n  outputColor.a *= radar_v;\n}\n';
var pointFillVert4 = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_EXTRUDE) in vec3 a_Extrude;\n\nlayout(std140) uniform commonUniorm {\n  float u_additive;\n  float u_size_unit;\n  float u_speed: 1.0;\n  float u_time;\n};\n\nout vec4 v_data;\nout vec4 v_color;\nout float v_radius;\nout vec2 v_extrude;\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  float newSize = setPickingSize(a_Size);\n\n  float time = u_time * u_speed;\n  mat2 rotateMatrix = mat2(\n    cos(time), sin(time),\n    -sin(time), cos(time)\n  );\n  v_extrude = rotateMatrix * a_Extrude.xy;\n\n  v_color = a_Color;\n  v_color.a *= opacity;\n\n  float blur = 0.0;\n  float antialiasblur = -max(2.0 / u_DevicePixelRatio / a_Size, blur);\n\n  if(u_size_unit == 1.) {\n    newSize = newSize  * u_PixelsPerMeter.z;\n  }\n  v_radius = newSize;\n\n  vec2 offset = (a_Extrude.xy * (newSize));\n\n  offset = project_pixel(offset);\n\n  v_data = vec4(a_Extrude.x, a_Extrude.y, antialiasblur, -1.0);\n\n  vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0), a_Position64Low);\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, project_pixel(setPickingOrder(0.0)), 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n';
var RadarModel = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      EXTRUDE: 10
    });
  }
  getCommonUniformsInfo() {
    const {
      blend,
      speed = 1,
      unit: unit2 = "pixel"
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_additive: blend === "additive" ? 1 : 0,
      u_size_unit: SizeUnitType[unit2],
      u_speed: speed,
      u_time: this.layer.getLayerAnimateTime()
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getAnimateUniforms() {
    return {};
  }
  getAttribute() {
    return this.styleAttributeService.createAttributesAndIndices(this.layer.getEncodedData(), PointFillTriangulation);
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "pointRadar",
        vertexShader: pointFillVert4,
        fragmentShader: pointFillFrag4,
        triangulation: PointFillTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        depth: {
          enable: false
        }
      });
      return [model];
    })();
  }
  // overwrite baseModel func
  animateOption2Array(option) {
    return [option.enable ? 0 : 1, option.speed || 1, option.rings || 3, 0];
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "extrude",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Extrude",
        shaderLocation: this.attributeLocation.EXTRUDE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx) => {
          const extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
          const extrudeIndex = attributeIdx % 4 * 3;
          return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        shaderLocation: this.attributeLocation.SIZE,
        name: "a_Size",
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 5
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/utils/grid-index.js
var GridIndex = class {
  constructor(width, height, cellSize) {
    _defineProperty(this, "boxCells", []);
    _defineProperty(this, "xCellCount", void 0);
    _defineProperty(this, "yCellCount", void 0);
    _defineProperty(this, "boxKeys", void 0);
    _defineProperty(this, "bboxes", void 0);
    _defineProperty(this, "width", void 0);
    _defineProperty(this, "height", void 0);
    _defineProperty(this, "xScale", void 0);
    _defineProperty(this, "yScale", void 0);
    _defineProperty(this, "boxUid", void 0);
    const boxCells = this.boxCells;
    this.xCellCount = Math.ceil(width / cellSize);
    this.yCellCount = Math.ceil(height / cellSize);
    for (let i = 0; i < this.xCellCount * this.yCellCount; i++) {
      boxCells.push([]);
    }
    this.boxKeys = [];
    this.bboxes = [];
    this.width = width;
    this.height = height;
    this.xScale = this.xCellCount / width;
    this.yScale = this.yCellCount / height;
    this.boxUid = 0;
  }
  insert(key, x1, y1, x2, y2) {
    this.forEachCell(x1, y1, x2, y2, this.insertBoxCell, this.boxUid++);
    this.boxKeys.push(key);
    this.bboxes.push(x1);
    this.bboxes.push(y1);
    this.bboxes.push(x2);
    this.bboxes.push(y2);
  }
  query(x1, y1, x2, y2, predicate) {
    return this.queryHitTest(x1, y1, x2, y2, false, predicate);
  }
  hitTest(x1, y1, x2, y2, predicate) {
    return this.queryHitTest(x1, y1, x2, y2, true, predicate);
  }
  insertBoxCell(x1, y1, x2, y2, cellIndex, uid) {
    this.boxCells[cellIndex].push(uid);
  }
  queryHitTest(x1, y1, x2, y2, hitTest, predicate) {
    if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {
      return hitTest ? false : [];
    }
    const result = [];
    if (x1 <= 0 && y1 <= 0 && this.width <= x2 && this.height <= y2) {
      if (hitTest) {
        return true;
      }
      for (let boxUid = 0; boxUid < this.boxKeys.length; boxUid++) {
        result.push({
          key: this.boxKeys[boxUid],
          x1: this.bboxes[boxUid * 4],
          y1: this.bboxes[boxUid * 4 + 1],
          x2: this.bboxes[boxUid * 4 + 2],
          y2: this.bboxes[boxUid * 4 + 3]
        });
      }
      return predicate ? result.filter(predicate) : result;
    }
    const queryArgs = {
      hitTest,
      seenUids: {
        box: {},
        circle: {}
      }
    };
    this.forEachCell(x1, y1, x2, y2, this.queryCell, result, queryArgs, predicate);
    return hitTest ? result.length > 0 : result;
  }
  queryCell(x1, y1, x2, y2, cellIndex, result, queryArgs, predicate) {
    const seenUids = queryArgs.seenUids;
    const boxCell = this.boxCells[cellIndex];
    if (boxCell !== null) {
      const bboxes = this.bboxes;
      for (const boxUid of boxCell) {
        if (!seenUids.box[boxUid]) {
          seenUids.box[boxUid] = true;
          const offset = boxUid * 4;
          if (x1 <= bboxes[offset + 2] && y1 <= bboxes[offset + 3] && x2 >= bboxes[offset + 0] && y2 >= bboxes[offset + 1] && (!predicate || predicate(this.boxKeys[boxUid]))) {
            if (queryArgs.hitTest) {
              result.push(true);
              return true;
            }
            result.push({
              key: this.boxKeys[boxUid],
              x1: bboxes[offset],
              y1: bboxes[offset + 1],
              x2: bboxes[offset + 2],
              y2: bboxes[offset + 3]
            });
          }
        }
      }
    }
    return false;
  }
  forEachCell(x1, y1, x2, y2, fn, arg1, arg2, predicate) {
    const cx1 = this.convertToXCellCoord(x1);
    const cy1 = this.convertToYCellCoord(y1);
    const cx2 = this.convertToXCellCoord(x2);
    const cy2 = this.convertToYCellCoord(y2);
    for (let x = cx1; x <= cx2; x++) {
      for (let y = cy1; y <= cy2; y++) {
        const cellIndex = this.xCellCount * y + x;
        if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, predicate)) {
          return;
        }
      }
    }
  }
  convertToXCellCoord(x) {
    return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(x * this.xScale)));
  }
  convertToYCellCoord(y) {
    return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(y * this.yScale)));
  }
};
var grid_index_default = GridIndex;

// node_modules/@antv/l7-layers/es/utils/collision-index.js
var CollisionIndex = class {
  constructor(width, height) {
    _defineProperty(this, "width", void 0);
    _defineProperty(this, "height", void 0);
    _defineProperty(this, "grid", void 0);
    _defineProperty(this, "viewportPadding", 100);
    _defineProperty(this, "screenRightBoundary", void 0);
    _defineProperty(this, "screenBottomBoundary", void 0);
    _defineProperty(this, "gridRightBoundary", void 0);
    _defineProperty(this, "gridBottomBoundary", void 0);
    this.width = width;
    this.height = height;
    this.viewportPadding = Math.max(width, height);
    this.grid = new grid_index_default(width + this.viewportPadding, height + this.viewportPadding, 25);
    this.screenRightBoundary = width + this.viewportPadding;
    this.screenBottomBoundary = height + this.viewportPadding;
    this.gridRightBoundary = width + 2 * this.viewportPadding;
    this.gridBottomBoundary = height + 2 * this.viewportPadding;
  }
  placeCollisionBox(collisionBox) {
    const tlX = collisionBox.x1 + collisionBox.anchorPointX + this.viewportPadding;
    const tlY = collisionBox.y1 + collisionBox.anchorPointY + this.viewportPadding;
    const brX = collisionBox.x2 + collisionBox.anchorPointX + this.viewportPadding;
    const brY = collisionBox.y2 + collisionBox.anchorPointY + this.viewportPadding;
    if (!this.isInsideGrid(tlX, tlY, brX, brY) || this.grid.hitTest(tlX, tlY, brX, brY)) {
      return {
        box: []
      };
    }
    return {
      box: [tlX, tlY, brX, brY]
    };
  }
  insertCollisionBox(box, featureIndex) {
    const key = {
      featureIndex
    };
    this.grid.insert(key, box[0], box[1], box[2], box[3]);
  }
  /**
   * 后续碰撞检测都需要投影到 viewport 坐标系
   * @param {THREE.Matrix4} mvpMatrix mvp矩阵
   * @param {number} x P20 平面坐标X
   * @param {number} y P20 平面坐标Y
   * @return {Point} projectedPoint
   */
  project(mvpMatrix, x, y) {
    const point2 = vec4_exports.fromValues(x, y, 0, 1);
    const out = vec4_exports.create();
    const mat = mat4_exports.fromValues(...mvpMatrix);
    vec4_exports.transformMat4(out, point2, mat);
    return {
      x: (out[0] / out[3] + 1) / 2 * this.width + this.viewportPadding,
      y: (-out[1] / out[3] + 1) / 2 * this.height + this.viewportPadding
    };
  }
  /**
   * 判断包围盒是否在整个网格内，需要加上 buffer
   * @param {number} x1 x1
   * @param {number} y1 y1
   * @param {number} x2 x2
   * @param {number} y2 y2
   * @return {Point} isInside
   */
  isInsideGrid(x1, y1, x2, y2) {
    return x2 >= 0 && x1 < this.gridRightBoundary && y2 >= 0 && y1 < this.gridBottomBoundary;
  }
};

// node_modules/@antv/l7-layers/es/utils/symbol-layout.js
function getAnchorAlignment(anchor) {
  let horizontalAlign = 0.5;
  let verticalAlign = 0.5;
  switch (anchor) {
    case "right":
    case "top-right":
    case "bottom-right":
      horizontalAlign = 1;
      break;
    case "left":
    case "top-left":
    case "bottom-left":
      horizontalAlign = 0;
      break;
    default:
      horizontalAlign = 0.5;
  }
  switch (anchor) {
    case "bottom":
    case "bottom-right":
    case "bottom-left":
      verticalAlign = 1;
      break;
    case "top":
    case "top-right":
    case "top-left":
      verticalAlign = 0;
      break;
    default:
      verticalAlign = 0.5;
  }
  return {
    horizontalAlign,
    verticalAlign
  };
}
function justifyLine(positionedGlyphs, glyphMap, start, end, justify) {
  if (!justify) {
    return;
  }
  const lastPositionedGlyph = positionedGlyphs[end];
  const glyph = lastPositionedGlyph.glyph;
  if (glyph) {
    const lastAdvance = glyphMap[glyph].advance * lastPositionedGlyph.scale;
    const lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;
    for (let j = start; j <= end; j++) {
      positionedGlyphs[j].x -= lineIndent;
    }
  }
}
function align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lineCount) {
  const shiftX = (justify - horizontalAlign) * maxLineLength;
  const shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;
  for (const glyphs of positionedGlyphs) {
    glyphs.x += shiftX;
    glyphs.y += shiftY;
  }
}
function shapeLines(shaping, glyphMap, lines, lineHeight, textAnchor, textJustify, spacing) {
  const yOffset = -8;
  let x = 0;
  let y = yOffset;
  let maxLineLength = 0;
  const positionedGlyphs = shaping.positionedGlyphs;
  const justify = textJustify === "right" ? 1 : textJustify === "left" ? 0 : 0.5;
  const lineStartIndex = positionedGlyphs.length;
  lines.forEach((line) => {
    line.split("").forEach((char) => {
      const glyph = glyphMap[char];
      const baselineOffset = 0;
      if (glyph) {
        positionedGlyphs.push({
          glyph: char,
          x,
          y: y + baselineOffset,
          vertical: false,
          // TODO：目前只支持水平方向
          scale: 1,
          metrics: glyph
        });
        x += glyph.advance + spacing;
      }
    });
    if (positionedGlyphs.length !== lineStartIndex) {
      const lineLength = x - spacing;
      maxLineLength = Math.max(lineLength, maxLineLength);
      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);
    }
    x = 0;
    y -= lineHeight + 5;
  });
  const {
    horizontalAlign,
    verticalAlign
  } = getAnchorAlignment(textAnchor);
  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);
  const height = y - yOffset;
  shaping.top += -verticalAlign * height;
  shaping.bottom = shaping.top - height;
  shaping.left += -horizontalAlign * maxLineLength;
  shaping.right = shaping.left + maxLineLength;
}
function shapeIconFont(shaping, glyphMap, iconfonts, lineHeight, textAnchor, textJustify, spacing) {
  const yOffset = -8;
  let x = 0;
  let y = yOffset;
  let maxLineLength = 0;
  const positionedGlyphs = shaping.positionedGlyphs;
  const justify = textJustify === "right" ? 1 : textJustify === "left" ? 0 : 0.5;
  const lineStartIndex = positionedGlyphs.length;
  iconfonts.forEach((iconfont) => {
    const glyph = glyphMap[iconfont];
    const baselineOffset = 0;
    if (glyph) {
      positionedGlyphs.push({
        glyph: iconfont,
        // x,
        /**
         * iconfont
         * 在计算大小的时候计算的是 unicode 字符 如 &#xe6d4;
         * 在布局计算 icon 位置的时候应该始终保持居中（且 icon 只占一个字符的位置）
         */
        x: glyph.advance / 2,
        y: y + baselineOffset,
        vertical: false,
        // TODO：目前只支持水平方向
        scale: 1,
        metrics: glyph
      });
      x += glyph.advance + spacing;
    }
    if (positionedGlyphs.length !== lineStartIndex) {
      const lineLength = x - spacing;
      maxLineLength = Math.max(lineLength, maxLineLength);
      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);
    }
    x = 0;
    y -= lineHeight + 5;
  });
  const {
    horizontalAlign,
    verticalAlign
  } = getAnchorAlignment(textAnchor);
  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, iconfonts.length);
  const height = y - yOffset;
  shaping.top += -verticalAlign * height;
  shaping.bottom = shaping.top - height;
  shaping.left += -horizontalAlign * maxLineLength;
  shaping.right = shaping.left + maxLineLength;
}
function shapeText(text, glyphs, lineHeight, textAnchor, textJustify, spacing, translate = [0, 0], isIconFont) {
  const lines = text.split("\n");
  const positionedGlyphs = [];
  const shaping = {
    positionedGlyphs,
    top: translate[1],
    bottom: translate[1],
    left: translate[0],
    right: translate[0],
    lineCount: lines.length,
    text
  };
  isIconFont ? shapeIconFont(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing) : shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing);
  if (!positionedGlyphs.length) {
    return false;
  }
  return shaping;
}
function getGlyphQuads(shaping, textOffset = [0, 0], alongLine) {
  const {
    positionedGlyphs = []
  } = shaping;
  const quads = [];
  for (const positionedGlyph of positionedGlyphs) {
    const rect = positionedGlyph.metrics;
    const rectBuffer = 4;
    const halfAdvance = rect.advance * positionedGlyph.scale / 2;
    const glyphOffset = alongLine ? [positionedGlyph.x + halfAdvance, positionedGlyph.y] : [0, 0];
    const builtInOffset = alongLine ? [0, 0] : [positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1]];
    const x1 = (0 - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];
    const y1 = (0 - rectBuffer) * positionedGlyph.scale + builtInOffset[1];
    const x2 = x1 + rect.width * positionedGlyph.scale;
    const y2 = y1 + rect.height * positionedGlyph.scale;
    const tl = {
      x: x1,
      y: y1
    };
    const tr = {
      x: x2,
      y: y1
    };
    const bl = {
      x: x1,
      y: y2
    };
    const br = {
      x: x2,
      y: y2
    };
    quads.push({
      tl,
      tr,
      bl,
      br,
      tex: rect,
      glyphOffset
    });
  }
  return quads;
}

// node_modules/@antv/l7-layers/es/point/models/text.js
var textFrag = '#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 48.0\n\nuniform sampler2D u_sdf_map;\nlayout(std140) uniform commonUniforms {\n  vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\n  vec2 u_sdf_map_size;\n  float u_raisingHeight: 0.0;\n  float u_stroke_width : 2;\n  float u_gamma_scale : 0.5;\n  float u_halo_blur : 0.5;\n};\n\nin vec2 v_uv;\nin float v_gamma_scale;\nin vec4 v_color;\nin vec4 v_stroke_color;\nin float v_fontScale;\n\nout vec4 outputColor;\n\n#pragma include "picking"\nvoid main() {\n  // get style data mapping\n\n  // get sdf from atlas\n  float dist = texture(SAMPLER_2D(u_sdf_map), v_uv).a;\n\n  lowp float buff = (6.0 - u_stroke_width / v_fontScale) / SDF_PX;\n  highp float gamma = (u_halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (v_fontScale * u_gamma_scale) / 1.0;\n\n  highp float gamma_scaled = gamma * v_gamma_scale;\n\n  highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n\n  outputColor = mix(v_color, v_stroke_color, smoothstep(0., 0.5, 1.- dist));\n\n  outputColor.a *= alpha;\n   // 作为 mask 模板时需要丢弃透明的像素\n  if (outputColor.a < 0.01) {\n    discard;\n  }\n  outputColor = filterColor(outputColor);\n}\n';
var textVert = '#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 24.0\n\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_TEXT_OFFSETS) in vec2 a_textOffsets;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_tex;\n\nlayout(std140) uniform commonUniforms {\n  vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\n  vec2 u_sdf_map_size;\n  float u_raisingHeight: 0.0;\n  float u_stroke_width : 2;\n  float u_gamma_scale : 0.5;\n  float u_halo_blur : 0.5;\n};\n\nout vec2 v_uv;\nout float v_gamma_scale;\nout vec4 v_color;\nout vec4 v_stroke_color;\nout float v_fontScale;\n\n#pragma include "projection"\n#pragma include "picking"\n#pragma include "rotation_2d"\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n\n  v_uv = a_tex / u_sdf_map_size;\n\n\n\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\n  v_stroke_color = vec4(u_stroke_color.xyz, u_stroke_color.w * opacity);\n\n  // 文本缩放比例\n  float fontScale = a_Size / FONT_SIZE;\n  v_fontScale = fontScale;\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n  // vec4 projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  vec2 offset = rotate_matrix(a_textOffsets,rotation);\n\n  // gl_Position = vec4(projected_position.xy / projected_position.w + rotation_matrix * a_textOffsets * fontScale / u_ViewportSize * 2.0 * u_DevicePixelRatio, 0.0, 1.0);\n\n  float raiseHeight = u_raisingHeight;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n    raiseHeight = u_raisingHeight * mapboxZoomScale;\n  }\n\n  vec4 projected_position = project_common_position_to_clipspace(vec4(project_pos.xyz + vec3(0.0, 0.0, raiseHeight), 1.0));\n\n  gl_Position = vec4(\n    projected_position.xy / projected_position.w + offset * fontScale / u_ViewportSize * 2.0 * u_DevicePixelRatio, 0.0, 1.0);\n  v_gamma_scale = gl_Position.w;\n  setPickingColor(a_PickingColor);\n\n}\n';
var {
  isEqual: isEqual3
} = lodashUtil;
function TextTrianglation(feature) {
  const that = this;
  const id = feature.id;
  const vertices = [];
  const indices = [];
  if (!that.glyphInfoMap || !that.glyphInfoMap[id]) {
    return {
      vertices: [],
      // [ x, y, z, tex.x,tex.y, offset.x. offset.y]
      indices: [],
      size: 7
    };
  }
  const centroid = that.glyphInfoMap[id].centroid;
  const coord = centroid.length === 2 ? [centroid[0], centroid[1], 0] : centroid;
  that.glyphInfoMap[id].glyphQuads.forEach((quad, index3) => {
    vertices.push(...coord, quad.tex.x, quad.tex.y + quad.tex.height, quad.tl.x, quad.tl.y, ...coord, quad.tex.x + quad.tex.width, quad.tex.y + quad.tex.height, quad.tr.x, quad.tr.y, ...coord, quad.tex.x + quad.tex.width, quad.tex.y, quad.br.x, quad.br.y, ...coord, quad.tex.x, quad.tex.y, quad.bl.x, quad.bl.y);
    indices.push(0 + index3 * 4, 1 + index3 * 4, 2 + index3 * 4, 2 + index3 * 4, 3 + index3 * 4, 0 + index3 * 4);
  });
  return {
    vertices,
    // [ x, y, z, tex.x,tex.y, offset.x. offset.y]
    indices,
    size: 7
  };
}
var TextModel = class extends BaseModel {
  constructor(...args) {
    var _this;
    super(...args);
    _this = this;
    _defineProperty(this, "glyphInfo", void 0);
    _defineProperty(this, "glyphInfoMap", {});
    _defineProperty(this, "rawEncodeData", void 0);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "currentZoom", -1);
    _defineProperty(this, "extent", void 0);
    _defineProperty(this, "textureHeight", 0);
    _defineProperty(this, "textCount", 0);
    _defineProperty(this, "preTextStyle", {});
    _defineProperty(this, "mapping", _asyncToGenerator(function* () {
      _this.initGlyph();
      _this.updateTexture();
      yield _this.reBuildModel();
    }));
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      TEXT_OFFSETS: 10,
      UV: 11
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption), {
      u_sdf_map: this.textures[0]
    });
  }
  getCommonUniformsInfo() {
    const {
      stroke = "#fff",
      strokeWidth = 0,
      halo = 0.5,
      gamma: gamma2 = 2,
      raisingHeight = 0
    } = this.layer.getLayerConfig();
    const mapping = this.getFontServiceMapping();
    const canvas = this.getFontServiceCanvas();
    if (mapping && Object.keys(mapping).length !== this.textCount && canvas) {
      this.updateTexture();
      this.textCount = Object.keys(mapping).length;
    }
    this.preTextStyle = this.getTextStyle();
    const commonOptions = {
      u_stroke_color: rgb2arr(stroke),
      u_sdf_map_size: [(canvas === null || canvas === void 0 ? void 0 : canvas.width) || 1, (canvas === null || canvas === void 0 ? void 0 : canvas.height) || 1],
      u_raisingHeight: Number(raisingHeight),
      u_stroke_width: strokeWidth,
      u_gamma_scale: gamma2,
      u_halo_blur: halo
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.bindEvent();
      _this2.extent = _this2.textExtent();
      _this2.rawEncodeData = _this2.layer.getEncodedData();
      _this2.preTextStyle = _this2.getTextStyle();
      _this2.initUniformsBuffer();
      return _this2.buildModels();
    })();
  }
  buildModels() {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      const {
        textAllowOverlap = false
      } = _this3.layer.getLayerConfig();
      _this3.initGlyph();
      _this3.updateTexture();
      if (!textAllowOverlap) {
        _this3.filterGlyphs();
      }
      const model = yield _this3.layer.buildLayerModel({
        moduleName: "pointText",
        vertexShader: textVert,
        fragmentShader: textFrag,
        defines: _this3.getDefines(),
        inject: _this3.getInject(),
        triangulation: TextTrianglation.bind(_this3),
        depth: {
          enable: false
        }
      });
      return [model];
    })();
  }
  // 需要更新的场景
  // 1. 文本偏移量发生改变
  // 2. 文本锚点发生改变
  // 3. 文本允许重叠发生改变
  // 4. 文本字体发生改变
  // 5. 文本字体粗细发生改变
  needUpdate() {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      const {
        textAllowOverlap = false,
        textAnchor = "center",
        textOffset,
        padding,
        fontFamily,
        fontWeight
      } = _this4.getTextStyle();
      if (!isEqual3(padding, _this4.preTextStyle.padding) || !isEqual3(textOffset, _this4.preTextStyle.textOffset) || !isEqual3(textAnchor, _this4.preTextStyle.textAnchor) || !isEqual3(fontFamily, _this4.preTextStyle.fontFamily) || !isEqual3(fontWeight, _this4.preTextStyle.fontWeight)) {
        yield _this4.mapping();
        return true;
      }
      if (textAllowOverlap) {
        return false;
      }
      const zoom = _this4.mapService.getZoom();
      const extent2 = _this4.mapService.getBounds();
      const flag = boundsContains(_this4.extent, extent2);
      if (Math.abs(_this4.currentZoom - zoom) > 0.5 || !flag || textAllowOverlap !== _this4.preTextStyle.textAllowOverlap) {
        yield _this4.reBuildModel();
        return true;
      }
      return false;
    })();
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
    this.layer.off("remapping", this.mapping);
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "textOffsets",
      type: AttributeType.Attribute,
      descriptor: {
        shaderLocation: this.attributeLocation.TEXT_OFFSETS,
        name: "a_textOffsets",
        // 文字偏移量
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[5], vertex[6]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "textUv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_tex",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 12
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
  }
  bindEvent() {
    if (!this.layer.isTileLayer) {
      this.layer.on("remapping", this.mapping);
    }
  }
  textExtent() {
    const bounds = this.mapService.getBounds();
    return padBounds(bounds, 0.5);
  }
  /**
   * 生成文字纹理（生成文字纹理字典）
   */
  initTextFont() {
    const {
      fontWeight,
      fontFamily
    } = this.getTextStyle();
    const data = this.rawEncodeData;
    const characterSet = [];
    data.forEach((item) => {
      let {
        shape = ""
      } = item;
      shape = shape.toString();
      for (const char of shape) {
        if (characterSet.indexOf(char) === -1) {
          characterSet.push(char);
        }
      }
    });
    this.fontService.setFontOptions({
      characterSet,
      fontWeight,
      fontFamily,
      iconfont: false
    });
  }
  /**
   * 生成 iconfont 纹理字典
   */
  initIconFontTex() {
    const {
      fontWeight,
      fontFamily
    } = this.getTextStyle();
    const data = this.rawEncodeData;
    const characterSet = [];
    data.forEach((item) => {
      let {
        shape = ""
      } = item;
      shape = `${shape}`;
      if (characterSet.indexOf(shape) === -1) {
        characterSet.push(shape);
      }
    });
    this.fontService.setFontOptions({
      characterSet,
      fontWeight,
      fontFamily,
      iconfont: true
    });
  }
  getTextStyle() {
    const {
      fontWeight = "400",
      fontFamily = "sans-serif",
      textAllowOverlap = false,
      padding = [0, 0],
      textAnchor = "center",
      textOffset = [0, 0],
      opacity = 1,
      strokeOpacity = 1,
      strokeWidth = 0,
      stroke = "#000"
    } = this.layer.getLayerConfig();
    return {
      fontWeight,
      fontFamily,
      textAllowOverlap,
      padding,
      textAnchor,
      textOffset,
      opacity,
      strokeOpacity,
      strokeWidth,
      stroke
    };
  }
  /**
   * 生成文字布局（对照文字纹理字典提取对应文字的位置很好信息）
   */
  generateGlyphLayout(iconfont) {
    const mapping = this.getFontServiceMapping();
    const {
      spacing = 2,
      textAnchor = "center",
      textOffset
    } = this.layer.getLayerConfig();
    const data = this.rawEncodeData;
    this.glyphInfo = data.map((feature) => {
      const {
        shape = "",
        id,
        size: size2 = 1
      } = feature;
      const offset = feature.textOffset ? feature.textOffset : textOffset || [0, 0];
      const anchor = feature.textAnchor ? feature.textAnchor : textAnchor || "center";
      const shaping = shapeText(
        shape.toString(),
        mapping,
        // @ts-ignore
        size2,
        anchor,
        "left",
        spacing,
        offset,
        //
        iconfont
      );
      const glyphQuads = getGlyphQuads(shaping, offset, false);
      feature.shaping = shaping;
      feature.glyphQuads = glyphQuads;
      feature.centroid = calculateCentroid(feature.coordinates);
      this.glyphInfoMap[id] = {
        shaping,
        glyphQuads,
        centroid: calculateCentroid(feature.coordinates)
      };
      return feature;
    });
  }
  getFontServiceMapping() {
    const {
      fontWeight = "400",
      fontFamily = "sans-serif"
    } = this.layer.getLayerConfig();
    return this.fontService.getMappingByKey(`${fontFamily}_${fontWeight}`);
  }
  getFontServiceCanvas() {
    const {
      fontWeight = "400",
      fontFamily = "sans-serif"
    } = this.layer.getLayerConfig();
    return this.fontService.getCanvasByKey(`${fontFamily}_${fontWeight}`);
  }
  /**
   * 文字避让 depend on originCentorid
   */
  filterGlyphs() {
    const {
      padding = [0, 0],
      textAllowOverlap = false
    } = this.layer.getLayerConfig();
    if (textAllowOverlap) {
      return;
    }
    this.glyphInfoMap = {};
    this.currentZoom = this.mapService.getZoom();
    this.extent = this.textExtent();
    const {
      width,
      height
    } = this.rendererService.getViewportSize();
    const collisionIndex = new CollisionIndex(width, height);
    const filterData = this.glyphInfo.filter((feature) => {
      const {
        shaping,
        id = 0
      } = feature;
      const centroid = feature.centroid;
      const size2 = feature.size;
      const fontScale = size2 / 16;
      const pixels = this.mapService.lngLatToContainer(centroid);
      const {
        box
      } = collisionIndex.placeCollisionBox({
        x1: shaping.left * fontScale - padding[0],
        x2: shaping.right * fontScale + padding[0],
        y1: shaping.top * fontScale - padding[1],
        y2: shaping.bottom * fontScale + padding[1],
        anchorPointX: pixels.x,
        anchorPointY: pixels.y
      });
      if (box && box.length) {
        collisionIndex.insertCollisionBox(box, id);
        return true;
      } else {
        return false;
      }
    });
    filterData.forEach((item) => {
      this.glyphInfoMap[item.id] = item;
    });
  }
  /**
   * 初始化文字布局
   */
  initGlyph() {
    const {
      iconfont = false
    } = this.layer.getLayerConfig();
    iconfont ? this.initIconFontTex() : this.initTextFont();
    this.generateGlyphLayout(iconfont);
  }
  /**
   * 更新文字纹理
   */
  updateTexture() {
    const {
      createTexture2D
    } = this.rendererService;
    const canvas = this.getFontServiceCanvas();
    this.textureHeight = canvas.height;
    if (this.texture) {
      this.texture.destroy();
    }
    this.texture = createTexture2D({
      data: canvas,
      mag: gl.LINEAR,
      min: gl.LINEAR,
      width: canvas.width,
      height: canvas.height
    });
    this.textures = [this.texture];
  }
  reBuildModel() {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      _this5.filterGlyphs();
      const model = yield _this5.layer.buildLayerModel({
        moduleName: "pointText",
        vertexShader: textVert,
        fragmentShader: textFrag,
        triangulation: TextTrianglation.bind(_this5),
        defines: _this5.getDefines(),
        inject: _this5.getInject(),
        depth: {
          enable: false
        }
      });
      _this5.layer.models = [model];
    })();
  }
};

// node_modules/@antv/l7-layers/es/point/models/index.js
var PointModels = {
  fillImage: FillImageModel,
  fill: FillModel2,
  radar: RadarModel,
  image: ImageModel2,
  normal: NormalModel,
  simplePoint: SimplePointModel,
  extrude: ExtrudeModel2,
  text: TextModel,
  earthFill: FillModel,
  earthExtrude: ExtrudeModel
};
var models_default5 = PointModels;

// node_modules/@antv/l7-layers/es/point/index.js
var PointLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "PointLayer");
    _defineProperty(this, "enableShaderEncodeStyles", ["stroke", "offsets", "opacity", "rotation"]);
    _defineProperty(this, "enableDataEncodeStyles", ["textOffset", "textAnchor"]);
    _defineProperty(this, "defaultSourceConfig", {
      data: [],
      options: {
        parser: {
          type: "json",
          x: "lng",
          y: "lat"
        }
      }
    });
  }
  buildModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const modelType = _this.getModelType();
      if (_this.layerModel) {
        _this.layerModel.clearModels();
      }
      _this.layerModel = new models_default5[modelType](_this);
      yield _this.initLayerModels();
    })();
  }
  rebuildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      yield _this2.buildModels();
    })();
  }
  /**
   * 在未传入数据的时候判断点图层的 shape 类型
   * @returns
   */
  getModelTypeWillEmptyData() {
    if (this.shapeOption) {
      const {
        field,
        values
      } = this.shapeOption;
      const {
        shape2d
      } = this.getLayerConfig();
      const iconMap = this.iconService.getIconMap();
      if (field && (shape2d === null || shape2d === void 0 ? void 0 : shape2d.indexOf(field)) !== -1) {
        return "fill";
      }
      if (values === "text") {
        return "text";
      }
      if (values && values instanceof Array) {
        for (const v2 of values) {
          if (typeof v2 === "string" && iconMap.hasOwnProperty(v2)) {
            return "image";
          }
        }
      }
    }
    return "normal";
  }
  getDefaultConfig() {
    const type = this.getModelType();
    const defaultConfig = {
      fillImage: {},
      normal: {
        blend: "additive"
      },
      radar: {},
      simplePoint: {},
      fill: {
        blend: "normal"
      },
      extrude: {},
      image: {},
      text: {
        blend: "normal"
      },
      tile: {},
      tileText: {},
      earthFill: {},
      earthExtrude: {}
    };
    return defaultConfig[type];
  }
  getModelType() {
    const layerData = this.getEncodedData();
    const {
      shape2d,
      shape3d,
      billboard = true
    } = this.getLayerConfig();
    const iconMap = this.iconService.getIconMap();
    const item = layerData.find((fe) => {
      return fe.hasOwnProperty("shape");
    });
    if (!item) {
      return this.getModelTypeWillEmptyData();
    } else {
      const shape = item.shape;
      if (shape === "dot") {
        return "normal";
      }
      if (shape === "simple") {
        return "simplePoint";
      }
      if (shape === "radar") {
        return "radar";
      }
      if (this.layerType === "fillImage" || billboard === false) {
        return "fillImage";
      }
      if ((shape2d === null || shape2d === void 0 ? void 0 : shape2d.indexOf(shape)) !== -1) {
        if (this.mapService.version === "GLOBEL") {
          return "earthFill";
        } else {
          return "fill";
        }
      }
      if ((shape3d === null || shape3d === void 0 ? void 0 : shape3d.indexOf(shape)) !== -1) {
        if (this.mapService.version === "GLOBEL") {
          return "earthExtrude";
        } else {
          return "extrude";
        }
      }
      if (iconMap.hasOwnProperty(shape)) {
        return "image";
      }
      return "text";
    }
  }
};

// node_modules/@antv/l7-layers/es/utils/load-image.js
function loadImage(_x) {
  return _loadImage.apply(this, arguments);
}
function _loadImage() {
  _loadImage = _asyncToGenerator(function* (url) {
    if (window.createImageBitmap) {
      const response = yield fetch(url);
      const imageBitmap = yield createImageBitmap(yield response.blob());
      return imageBitmap;
    } else {
      const image2 = new window.Image();
      return new Promise((res) => {
        image2.onload = () => res(image2);
        image2.src = url;
        image2.crossOrigin = "Anonymous";
      });
    }
  });
  return _loadImage.apply(this, arguments);
}

// node_modules/@antv/l7-layers/es/polygon/models/extrude.js
var polygonExtrudeFrag = 'layout(std140) uniform commonUniforms {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  float u_linearColor;\n  float u_topsurface;\n  float u_sidesurface;\n  float u_heightfixed; // 默认不固定\n  float u_raisingHeight;\n};\n\nin vec4 v_Color;\n#pragma include "scene_uniforms"\n#pragma include "picking"\nout vec4 outputColor;\nvoid main() {\n\n     // top face\n    if(u_topsurface < 1.0) {\n      discard;\n    }\n\n    outputColor = v_Color;\n  \n  outputColor = filterColor(outputColor);\n}\n';
var polygonExtrudePickLightFrag = '\nlayout(std140) uniform commonUniforms {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  float u_linearColor;\n  float u_topsurface;\n  float u_sidesurface;\n  float u_heightfixed; // 默认不固定\n  float u_raisingHeight;\n};\n\nin vec4 v_Color;\nin vec3 v_uvs;\nin vec2 v_texture_data;\nout vec4 outputColor;\n\n#pragma include "scene_uniforms"\n#pragma include "picking"\n\nvoid main() {\n  float isSide =  v_texture_data.x;\n  float sidey = v_uvs[2];\n  float lightWeight = v_texture_data.y;\n\n  // Tip: 部分机型 GPU 计算精度兼容\n  if(isSide < 0.999) {\n    // side face\n    if(u_sidesurface < 1.0) {\n      discard;\n    }\n    \n    if( u_linearColor == 1.0) {\n      // side use linear\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\n      linearColor.rgb *= lightWeight;\n      outputColor = linearColor;\n    } else {\n      // side notuse linear\n       outputColor = v_Color;\n    }\n  } else {\n    // top face\n    if(u_topsurface < 1.0) {\n      discard;\n    }\n    outputColor = v_Color;\n  }\n\n  outputColor = filterColorAlpha(outputColor, lightWeight);\n}\n';
var polygonExtrudePickLightVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec3 a_uvs;\n\nlayout(std140) uniform commonUniforms {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  float u_linearColor;\n  float u_topsurface;\n  float u_sidesurface;\n  float u_heightfixed; // 默认不固定\n  float u_raisingHeight;\n};\n\nout vec4 v_Color;\nout vec3 v_uvs;\nout vec2 v_texture_data;\n\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\nvoid main() {\n  v_uvs = a_uvs;\n  // cal style mapping - 数据纹理映射部分的计算\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  vec4 project_pos = project_position(pos, a_Position64Low);\n\n  if (u_heightfixed > 0.0) {\n    // 判断几何体是否固定高度\n    project_pos.z = a_Position.z * a_Size;\n    project_pos.z += u_raisingHeight;\n    if (\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n    ) {\n      float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\n      project_pos.z *= mapboxZoomScale;\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  float lightWeight = calc_lighting(project_pos);\n  v_texture_data = vec2(a_Position.z, lightWeight);\n\n  v_Color = vec4(a_Color.rgb * lightWeight, a_Color.w * opacity);\n\n  setPickingColor(a_PickingColor);\n}\n';
var polygonExtrudeVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec3 a_uvs;\n\nlayout(std140) uniform commonUniforms {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  float u_linearColor;\n  float u_topsurface;\n  float u_sidesurface;\n  float u_heightfixed; // 默认不固定\n  float u_raisingHeight;\n};\n\nout vec4 v_Color;\n\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\nvoid main() {\n  float isSide = a_Position.z;\n  float topU = a_uvs[0];\n  float topV = 1.0 - a_uvs[1];\n  float sidey = a_uvs[2];\n\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n\n  vec4 project_pos = project_position(pos, a_Position64Low);\n  float lightWeight = calc_lighting(project_pos);\n\n  if (u_heightfixed > 0.0) {\n    // 判断几何体是否固定高度\n    project_pos.z = a_Position.z * a_Size;\n    project_pos.z += u_raisingHeight;\n\n    if (\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n    ) {\n      float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\n      project_pos.z *= mapboxZoomScale;\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  // Tip: 部分机型 GPU 计算精度兼容\n  if (isSide < 0.999) {\n    // side face\n    // if(u_sidesurface < 1.0) {\n    //   discard;\n    // }\n\n    if (u_linearColor == 1.0) {\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\n      linearColor.rgb *= lightWeight;\n      v_Color = linearColor;\n    } else {\n      v_Color = a_Color;\n    }\n\n  } else {\n    v_Color = a_Color;\n  }\n\n  v_Color = vec4(v_Color.rgb * lightWeight, v_Color.w * opacity);\n\n  setPickingColor(a_PickingColor);\n}\n';
var polygonExtrudeTexFrag = 'uniform sampler2D u_texture;\n\nlayout(std140) uniform commonUniforms {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  float u_linearColor;\n  float u_topsurface;\n  float u_sidesurface;\n  float u_heightfixed; // 默认不固定\n  float u_raisingHeight;\n};\n\nin vec4 v_Color;\nin vec3 v_uvs;\nin vec2 v_texture_data;\n\n#pragma include "scene_uniforms"\n#pragma include "picking"\n\nout vec4 outputColor;\n\nvoid main() {\n  float opacity = u_opacity;\n  float isSide = v_texture_data.x;\n  float lightWeight = v_texture_data.y;\n  float topU = v_uvs[0];\n  float topV = 1.0 - v_uvs[1];\n  float sidey = v_uvs[2];\n\n  outputColor = texture(SAMPLER_2D(u_texture), vec2(topU, topV));\n  // Tip: 部分机型 GPU 计算精度兼容\n  if (isSide < 0.999) {// 是否是边缘\n    // side face\n    if (u_sidesurface < 1.0) {\n      discard;\n    }\n\n    if (u_linearColor == 1.0) {\n      vec4 linearColor = mix(u_targetColor, u_sourceColor, sidey);\n      linearColor.rgb *= lightWeight;\n      outputColor = linearColor;\n    } else {\n      outputColor = v_Color;\n    }\n  } else {\n     // top face\n    if (u_topsurface < 1.0) {\n      discard;\n    }\n  }\n  \n  outputColor.a *= opacity;\n  outputColor = filterColor(outputColor);\n}\n';
var polygonExtrudeTexVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec3 a_uvs;\n\nlayout(std140) uniform commonUniforms {\n  vec4 u_sourceColor;\n  vec4 u_targetColor;\n  float u_linearColor;\n  float u_topsurface;\n  float u_sidesurface;\n  float u_heightfixed; // 默认不固定\n  float u_raisingHeight;\n};\n\nout vec4 v_Color;\nout vec3 v_uvs;\nout vec2 v_texture_data;\n\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\nvoid main() {\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size, 1.0);\n  vec4 project_pos = project_position(pos, a_Position64Low);\n  float lightWeight = calc_lighting(project_pos);\n  v_uvs = a_uvs;\n  v_Color = a_Color;\n  v_Color.a *= opacity;\n\n  v_texture_data = vec2(a_Position.z, lightWeight);\n\n  if (u_heightfixed > 0.0) {\n    // 判断几何体是否固定高度\n    project_pos.z = a_Position.z * a_Size;\n    project_pos.z += u_raisingHeight;\n\n    if (\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n      u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n    ) {\n      float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\n      project_pos.z *= mapboxZoomScale;\n      project_pos.z += u_raisingHeight * mapboxZoomScale;\n    }\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n';
var ExtrudeModel3 = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      NORMAL: 10,
      UV: 11
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      mapTexture,
      heightfixed = false,
      raisingHeight = 0,
      topsurface = true,
      sidesurface = true,
      sourceColor,
      targetColor
    } = this.layer.getLayerConfig();
    let useLinearColor = 0;
    let sourceColorArr = [1, 1, 1, 1];
    let targetColorArr = [1, 1, 1, 1];
    if (sourceColor && targetColor) {
      sourceColorArr = rgb2arr(sourceColor);
      targetColorArr = rgb2arr(targetColor);
      useLinearColor = 1;
    }
    const commonOptions = {
      u_sourceColor: sourceColorArr,
      u_targetColor: targetColorArr,
      u_linearColor: useLinearColor,
      // 控制侧面和顶面的显示隐藏
      u_topsurface: Number(topsurface),
      u_sidesurface: Number(sidesurface),
      u_heightfixed: Number(heightfixed),
      u_raisingHeight: Number(raisingHeight)
    };
    if (mapTexture && this.texture) {
      commonOptions.u_texture = this.texture;
      this.textures = [this.texture];
    }
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      yield _this.loadTexture();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        frag,
        vert,
        type
      } = _this2.getShaders();
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        depth: {
          enable: true
        },
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation: PolygonExtrudeTriangulation
      });
      return [model];
    })();
  }
  getShaders() {
    const {
      pickLight,
      mapTexture
    } = this.layer.getLayerConfig();
    if (mapTexture) {
      return {
        frag: polygonExtrudeTexFrag,
        vert: polygonExtrudeTexVert,
        type: "polygonExtrudeTexture"
      };
    }
    if (pickLight) {
      return {
        frag: polygonExtrudePickLightFrag,
        vert: polygonExtrudePickLightVert,
        type: "polygonExtrudePickLight"
      };
    } else {
      return {
        frag: polygonExtrudeFrag,
        vert: polygonExtrudeVert,
        type: "polygonExtrude"
      };
    }
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
    this.textures = [];
  }
  registerBuiltinAttributes() {
    const bounds = this.layer.getSource().extent;
    const lngLen = bounds[2] - bounds[0];
    const latLen = bounds[3] - bounds[1];
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "uvs",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_uvs",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex) => {
          const lng = vertex[0];
          const lat = vertex[1];
          return [(lng - bounds[0]) / lngLen, (lat - bounds[1]) / latLen, vertex[4]];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "normal",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Normal",
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 10
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
  }
  loadTexture() {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      const {
        mapTexture
      } = _this3.layer.getLayerConfig();
      const {
        createTexture2D
      } = _this3.rendererService;
      _this3.texture = createTexture2D({
        height: 1,
        width: 1
      });
      if (mapTexture) {
        const image2 = yield loadImage(mapTexture);
        _this3.texture = createTexture2D({
          data: image2,
          width: image2.width,
          height: image2.height,
          wrapS: gl.CLAMP_TO_EDGE,
          wrapT: gl.CLAMP_TO_EDGE,
          min: gl.LINEAR,
          mag: gl.LINEAR
        });
      }
    })();
  }
};

// node_modules/@antv/l7-layers/es/polygon/models/extrusion.js
var polygonExtrudeFrag2 = '\nin vec4 v_Color;\n#pragma include "scene_uniforms"\n#pragma include "picking"\nout vec4 outputColor;\nvoid main() {\n\n  outputColor = v_Color;\n  outputColor = filterColor(outputColor);\n}\n';
var polygonExtrudeVert2 = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_SIZE) in float a_Size;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\n\nout vec4 v_Color;\n\n#pragma include "projection"\n#pragma include "light"\n#pragma include "picking"\n\nvoid main() {\n  vec4 pos = vec4(a_Position.xy, a_Position.z * a_Size + (1.0 - a_Position.z) * extrusionBase, 1.0);\n\n  vec4 project_pos = project_position(pos, a_Position64Low);\n  float lightWeight = calc_lighting(project_pos);\n  v_Color = a_Color;\n  v_Color = vec4(v_Color.rgb * lightWeight, v_Color.w * opacity);\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n';
var ExtrusionModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      SIZE: 9,
      NORMAL: 10,
      EXTRUSION_BASE: 11
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const commonOptions = {};
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        frag,
        vert,
        type
      } = _this2.getShaders();
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation: PolygonExtrudeTriangulation,
        depth: {
          enable: true
        }
      });
      return [model];
    })();
  }
  getShaders() {
    return {
      frag: polygonExtrudeFrag2,
      vert: polygonExtrudeVert2,
      type: "polygonExtrude"
    };
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "normal",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Normal",
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "size",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Size",
        shaderLocation: this.attributeLocation.SIZE,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            size: size2 = 10
          } = feature;
          return Array.isArray(size2) ? [size2[0]] : [size2];
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "extrusionBase",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_ExtrusionBase",
        shaderLocation: this.attributeLocation.EXTRUSION_BASE,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 1,
        update: (feature) => {
          const {
            extrusionBase: op = 0
          } = feature;
          return [op];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/polygon/models/fill.js
var polygon_frag = 'in vec4 v_color;\n#pragma include "scene_uniforms"\n#pragma include "picking"\nout vec4 outputColor;\nvoid main() {\n  outputColor = v_color;\n  outputColor = filterColor(outputColor);\n}\n';
var polygon_linear_frag = '\nlayout(std140) uniform commonUniforms {\n  float u_raisingHeight;\n  float u_opacitylinear;\n  float u_dir;\n};\n\nin vec4 v_color;\nin vec3 v_linear;\nin vec2 v_pos;\nout vec4 outputColor;\n#pragma include "scene_uniforms"\n#pragma include "picking"\n\nvoid main() {\n  outputColor = v_color;\n  if (u_opacitylinear > 0.0) {\n    outputColor.a *= u_dir == 1.0 ? 1.0 - length(v_pos - v_linear.xy)/v_linear.z : length(v_pos - v_linear.xy)/v_linear.z;\n  }\n  outputColor = filterColor(outputColor);\n}\n';
var polygon_linear_vert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_LINEAR) in vec3 a_linear;\n\nlayout(std140) uniform commonUniforms {\n  float u_raisingHeight;\n  float u_opacitylinear;\n  float u_dir;\n};\n\nout vec4 v_color;\nout vec3 v_linear;\nout vec2 v_pos;\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  if (u_opacitylinear > 0.0) {\n    v_linear = a_linear;\n    v_pos = a_Position.xy;\n  }\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n  project_pos.z += u_raisingHeight;\n\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n    project_pos.z *= mapboxZoomScale;\n    project_pos.z += u_raisingHeight * mapboxZoomScale;\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  setPickingColor(a_PickingColor);\n}\n';
var polygon_vert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\n\nlayout(std140) uniform commonUniforms {\n  float u_raisingHeight;\n};\n\nout vec4 v_color;\n\n#pragma include "projection"\n#pragma include "picking"\n\nvoid main() {\n  // cal style mapping - 数据纹理映射部分的计算\n\n  v_color = vec4(a_Color.xyz, a_Color.w * opacity);\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n\n  project_pos.z += u_raisingHeight;\n\n  if (\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\n  ) {\n    float mapboxZoomScale = 4.0 / pow(2.0, 21.0 - u_Zoom);\n    project_pos.z *= mapboxZoomScale;\n    project_pos.z += u_raisingHeight * mapboxZoomScale;\n  }\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  setPickingColor(a_PickingColor);\n}\n\n';
var FillModel3 = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      LINEAR: 9
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      raisingHeight = 0,
      opacityLinear = {
        enable: false,
        dir: "in"
      }
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_raisingHeight: Number(raisingHeight),
      u_opacitylinear: Number(opacityLinear.enable),
      u_dir: opacityLinear.dir === "in" ? 1 : 0
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        frag,
        vert,
        triangulation,
        type
      } = _this2.getModelParams();
      _this2.initUniformsBuffer();
      _this2.layer.triangulation = triangulation;
      const model = yield _this2.layer.buildLayerModel({
        moduleName: type,
        vertexShader: vert,
        fragmentShader: frag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        }
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    const {
      opacityLinear = {
        enable: false,
        dir: "in"
      }
    } = this.layer.getLayerConfig();
    if (opacityLinear.enable) {
      this.styleAttributeService.registerStyleAttribute({
        name: "linear",
        type: AttributeType.Attribute,
        descriptor: {
          name: "a_linear",
          shaderLocation: this.attributeLocation.LINEAR,
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: gl.STATIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 3,
          update: (feature, featureIdx, vertex) => {
            return [vertex[3], vertex[4], vertex[5]];
          }
        }
      });
    }
  }
  getModelParams() {
    const {
      opacityLinear = {
        enable: false
      }
    } = this.layer.getLayerConfig();
    if (opacityLinear.enable) {
      return {
        frag: polygon_linear_frag,
        vert: polygon_linear_vert,
        type: "polygonLinear",
        triangulation: polygonTriangulationWithCenter
      };
    } else {
      return {
        frag: polygon_frag,
        vert: polygon_vert,
        type: "polygonFill",
        triangulation: polygonTriangulation
      };
    }
  }
};

// node_modules/@antv/l7-layers/es/polygon/models/ocean.js
var ocean_frag = `
layout(std140) uniform commonUniforms {
  vec4 u_watercolor;
  vec4 u_watercolor2;
  float u_time;
};

in vec2 v_uv;
in float v_opacity;
out vec4 outputColor;

float coast2water_fadedepth = 0.10;
float large_waveheight      = .750; // change to adjust the "heavy" waves
float large_wavesize        = 3.4;  // factor to adjust the large wave size
float small_waveheight      = 0.6;  // change to adjust the small random waves
float small_wavesize        = 0.5;   // factor to ajust the small wave size
float water_softlight_fact  = 15.;  // range [1..200] (should be << smaller than glossy-fact)
float water_glossylight_fact= 120.; // range [1..200]
float particle_amount       = 70.;

vec3 water_specularcolor    = vec3(1.3, 1.3, 0.9);    // specular Color (RGB) of the water-highlights
#define light                 vec3(-0., sin(u_time*0.5)*.5 + .35, 2.8) // position of the sun

uniform sampler2D u_texture1;
uniform sampler2D u_texture2;
uniform sampler2D u_texture3;

  

float hash( float n ) {
    return fract(sin(n)*43758.5453123);
}

// 2d noise function
float noise1( in vec2 x ) {
  vec2 p  = floor(x);
  vec2 f  = smoothstep(0.0, 1.0, fract(x));
  float n = p.x + p.y*57.0;
  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),
    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);
}

float noise(vec2 p) {
    return texture(SAMPLER_2D(u_texture2),p*vec2(1./256.)).x;
}

vec4 highness(vec2 p) {
    vec4 t = texture(SAMPLER_2D(u_texture1),fract(p));
    float clipped = -2.0-smoothstep(3.,10.,t.a)*6.9-smoothstep(10.,100.,t.a)*89.9-smoothstep(0.,10000.,t.a)*10000.0;
    return clamp(t, 0.0,3.0)+clamp(t/3.0-1.0, 0.0,1.0)+clamp(t/16.0-1.0, 0.0,1.0);
}

float height_map( vec2 p ) {
    vec4 height=highness(p);
    /*
    height = -0.5+
        0.5*smoothstep(-100.,0.,-height)+
        2.75*smoothstep(0.,2.,height)+
        1.75*smoothstep(2.,4.,height)+
        2.75*smoothstep(4.,16.,height)+
        1.5*smoothstep(16.,1000.,height);
    */

    mat2 m = mat2( 0.9563*1.4,  -0.2924*1.4,  0.2924*1.4,  0.9563*1.4 );
    //p = p*6.;
    float f = 0.6000*noise1( p ); p = m*p*1.1*6.;
    f += 0.2500*noise( p ); p = m*p*1.32;
    f += 0.1666*noise( p ); p = m*p*1.11;
    f += 0.0834*noise( p ); p = m*p*1.12;
    f += 0.0634*noise( p ); p = m*p*1.13;
    f += 0.0444*noise( p ); p = m*p*1.14;
    f += 0.0274*noise( p ); p = m*p*1.15;
    f += 0.0134*noise( p ); p = m*p*1.16;
    f += 0.0104*noise( p ); p = m*p*1.17;
    f += 0.0084*noise( p );
    f = .25*f+dot(height,vec4(-.03125,-.125,.25,.25))*.5;
        const float FLAT_LEVEL = 0.92525;
        //f = f*0.25+height*0.75;
    if (f<FLAT_LEVEL)
        f = f;
    else
        f = pow((f-FLAT_LEVEL)/(1.-FLAT_LEVEL), 2.)*(1.-FLAT_LEVEL)*2.0+FLAT_LEVEL; // makes a smooth coast-increase
    return clamp(f, 0., 10.);
}

vec3 plasma_quintic( float x ) {
    x = clamp( x, 0.0, 1.0);
    vec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3
    vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7
    return vec3(
        dot( x1.xyzw, vec4( +0.063861086, +1.992659096, -1.023901152, -0.490832805 ) ) + dot( x2.xy, vec2( +1.308442123, -0.914547012 ) ),
        dot( x1.xyzw, vec4( +0.049718590, -0.791144343, +2.892305078, +0.811726816 ) ) + dot( x2.xy, vec2( -4.686502417, +2.717794514 ) ),
        dot( x1.xyzw, vec4( +0.513275779, +1.580255060, -5.164414457, +4.559573646 ) ) + dot( x2.xy, vec2( -1.916810682, +0.570638854 ) ) );
}

vec4 color(vec2 p){
    vec4 c1 = vec4(1.7,1.6,.9,1);
    vec4 c2 = vec4(.2,.94,.1,1);
    vec4 c3 = vec4(.3,.2,.0,1);
    vec4 c4 = vec4(.99,.99,1.6,1);
    vec4 v = highness(p);
    float los = smoothstep(0.1,1.1,v.b);
    float his = smoothstep(3.5,6.5,v.b);
    float ces = smoothstep(1.,5.,v.a);
    vec4 lo = mix(c1,c2,los);
    vec4 hi = mix(c3,c4,his);
    vec4 ce = mix(lo,hi,ces);

    return vec4(plasma_quintic(ces),1).ragb;
}

vec3 terrain_map( vec2 p )
{
  return color(p).rgb*0.75+0.25*vec3(0.7, .55, .4)+texture(SAMPLER_2D(u_texture3), fract(p*5.)).rgb*.5; // test-terrain is simply 'sandstone'
}

const mat2 m = mat2( 0.72, -1.60,  1.60,  0.72 );

float water_map( vec2 p, float height ) {
    vec2 p2 = p*large_wavesize;
    vec2 shift1 = 0.001*vec2( u_time*160.0*2.0, u_time*120.0*2.0 );
    vec2 shift2 = 0.001*vec2( u_time*190.0*2.0, -u_time*130.0*2.0 );

    // coarse crossing 'ocean' waves...
    float f = 0.6000*noise( p );
    f += 0.2500*noise( p*m );
    f += 0.1666*noise( p*m*m );
    float wave = sin(p2.x*0.622+p2.y*0.622+shift2.x*4.269)*large_waveheight*f*height*height ;

    p *= small_wavesize;
    f = 0.;
    float amp = 1.0, s = .5;
    for (int i=0; i<9; i++)
    { p = m*p*.947; f -= amp*abs(sin((noise( p+shift1*s )-.5)*2.)); amp = amp*.59; s*=-1.329; }
    
    return wave+f*small_waveheight;
}

float nautic(vec2 p) {
    p *= 18.;
    float f = 0.;
    float amp = 1.0, s = .5;
    for (int i=0; i<3; i++)
    { p = m*p*1.2; f += amp*abs(smoothstep(0., 1., noise( p+u_time*s ))-.5); amp = amp*.5; s*=-1.227; }
    return pow(1.-f, 5.);
}

float particles(vec2 p) {
    p *= 200.;
    float f = 0.;
    float amp = 1.0, s = 1.5;
    for (int i=0; i<3; i++)
    { p = m*p*1.2; f += amp*noise( p+u_time*s ); amp = amp*.5; s*=-1.227; }
    return pow(f*.35, 7.)*particle_amount;
}

float test_shadow( vec2 xy, float height) {
    vec3 r0 = vec3(xy, height);
    vec3 rd = normalize( light - r0 );
    
    float hit = 1.0;
    float t   = 0.001;
    for (int j=1; j<25; j++)
    {
        vec3 p = r0 + t*rd;
        float h = height_map( p.xy );
        float height_diff = p.z - h;
        if (height_diff<0.0)
        {
            return 0.0;
        }
        t += 0.01+height_diff*.02;
        hit = min(hit, 2.*height_diff/t); // soft shaddow   
    }
    return hit;
}

vec3 CalcTerrain(vec2 uv, float height) {
    vec3 col = terrain_map( uv );
    vec2 iResolution = vec2(512.);
    float h1 = height_map(uv-vec2(0., 0.5)/ iResolution.xy);
    float h2 = height_map(uv+vec2(0., 0.5)/ iResolution.xy);
    float h3 = height_map(uv-vec2(0.5, 0.)/ iResolution.xy);
    float h4 = height_map(uv+vec2(0.5, 0.)/ iResolution.xy);
    vec3 norm = normalize(vec3(h3-h4, h1-h2, 1.));
    vec3 r0 = vec3(uv, height);
    vec3 rd = normalize( light - r0 );
    float grad = dot(norm, rd);
    col *= grad+pow(grad, 8.);
    float terrainshade = test_shadow( uv, height );
    col = mix(col*.25, col, terrainshade);
    return col;
}


void main() {
  vec3 watercolor = u_watercolor.rgb;
  vec3 watercolor2 = u_watercolor2.rgb;
  vec2 uv = v_uv;
  float WATER_LEVEL = 0.84; // Water level (range: 0.0 - 2.0)
  float deepwater_fadedepth   = 0.4 + coast2water_fadedepth;
  float height = height_map( uv );
  vec3 col;

    float waveheight = clamp(WATER_LEVEL*3.-1.5, 0., 1.);
    float level = WATER_LEVEL + .2*water_map(uv*15. + vec2(u_time*.1), waveheight);
    if (height > level)
    {
        col = CalcTerrain(uv, height);
    }
    if (height <= level)
    {
        vec2 dif = vec2(.0, .01);
        vec2 pos = uv*15. + vec2(u_time*.01);
        float h1 = water_map(pos-dif,waveheight);
        float h2 = water_map(pos+dif,waveheight);
        float h3 = water_map(pos-dif.yx,waveheight);
        float h4 = water_map(pos+dif.yx,waveheight);
        vec3 normwater = normalize(vec3(h3-h4, h1-h2, .125)); // norm-vector of the 'bumpy' water-plane
        uv += normwater.xy*.002*(level-height);
        
        col = CalcTerrain(uv, height);

        float coastfade = clamp((level-height)/coast2water_fadedepth, 0., 1.);
        float coastfade2= clamp((level-height)/deepwater_fadedepth, 0., 1.);
        float intensity = col.r*.2126+col.g*.7152+col.b*.0722;
        watercolor = mix(watercolor*intensity, watercolor2, smoothstep(0., 1., coastfade2));

        vec3 r0 = vec3(uv, WATER_LEVEL);
        vec3 rd = normalize( light - r0 ); // ray-direction to the light from water-position
        float grad     = dot(normwater, rd); // dot-product of norm-vector and light-direction
        float specular = pow(grad, water_softlight_fact);  // used for soft highlights                          
        float specular2= pow(grad, water_glossylight_fact); // used for glossy highlights
        float gradpos  = dot(vec3(0., 0., 1.), rd);
        float specular1= smoothstep(0., 1., pow(gradpos, 5.));  // used for diffusity (some darker corona around light's specular reflections...)                          
        float watershade  = test_shadow( uv, level );
        watercolor *= 2.2+watershade;
        watercolor += (.2+.8*watershade) * ((grad-1.0)*.5+specular) * .25;
        watercolor /= (1.+specular1*1.25);
        watercolor += watershade*specular2*water_specularcolor;
        watercolor += watershade*coastfade*(1.-coastfade2)*(vec3(.5, .6, .7)*nautic(uv)+vec3(1., 1., 1.)*particles(uv));
        
        col = mix(col, watercolor, coastfade);
    }
    
  outputColor = vec4(col, v_opacity);  
}
`;
var ocean_vert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_uv;\n\nlayout(std140) uniform commonUniforms {\n  vec4 u_watercolor;\n  vec4 u_watercolor2;\n  float u_time;\n};\n\nout vec2 v_uv;\nout float v_opacity;\n\n#pragma include "projection"\n\nvoid main() {\n  v_uv = a_uv;\n  v_opacity = opacity;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n}\n\n';
var OceanModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture1", void 0);
    _defineProperty(this, "texture2", void 0);
    _defineProperty(this, "texture3", void 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      UV: 9
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      watercolor = "#6D99A8",
      watercolor2 = "#0F121C"
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_watercolor: rgb2arr(watercolor),
      u_watercolor2: rgb2arr(watercolor2),
      u_time: this.layer.getLayerAnimateTime(),
      u_texture1: this.texture1,
      u_texture2: this.texture2,
      u_texture3: this.texture3
    };
    this.textures = [this.texture1, this.texture2, this.texture3];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getAnimateUniforms() {
    return {
      u_time: this.layer.getLayerAnimateTime()
    };
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.loadTexture();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "polygonOcean",
        vertexShader: ocean_vert,
        fragmentShader: ocean_frag,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        triangulation: polygonTriangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        }
      });
      return [model];
    })();
  }
  clearModels() {
    var _this$texture, _this$texture2, _this$texture3;
    (_this$texture = this.texture1) === null || _this$texture === void 0 || _this$texture.destroy();
    (_this$texture2 = this.texture2) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    (_this$texture3 = this.texture3) === null || _this$texture3 === void 0 || _this$texture3.destroy();
  }
  registerBuiltinAttributes() {
    const bbox = this.layer.getSource().extent;
    const [minLng, minLat, maxLng, maxLat] = bbox;
    const lngLen = maxLng - minLng;
    const latLen = maxLat - minLat;
    this.styleAttributeService.registerStyleAttribute({
      name: "oceanUv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          const [lng, lat] = vertex;
          return [(lng - minLng) / lngLen, (lat - minLat) / latLen];
        }
      }
    });
  }
  loadTexture() {
    const {
      createTexture2D
    } = this.rendererService;
    const defaultTextureOptions = {
      height: 0,
      width: 0
    };
    this.texture1 = createTexture2D(defaultTextureOptions);
    this.texture2 = createTexture2D(defaultTextureOptions);
    this.texture3 = createTexture2D(defaultTextureOptions);
    initImage((images) => {
      this.texture1 = initTex(images[0]);
      this.texture2 = initTex(images[1]);
      this.texture3 = initTex(images[2]);
      this.layerService.reRender();
    });
    function initImage(callback) {
      let loadedCount = 0;
      const loadedImages = [];
      const images = ["https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ", "https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*MJ22QbpuCzIAAAAAAAAAAAAAARQnAQ", "https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*-z2HSIVDsHIAAAAAAAAAAAAAARQnAQ"];
      images.map((imgSrc) => {
        const image2 = new Image();
        image2.crossOrigin = "";
        image2.src = imgSrc;
        loadedImages.push(image2);
        image2.onload = () => {
          loadedCount++;
          if (loadedCount === 3) {
            callback(loadedImages);
          }
        };
      });
    }
    function initTex(image2) {
      return createTexture2D({
        data: image2,
        width: image2.width,
        height: image2.height,
        wrapS: gl.MIRRORED_REPEAT,
        wrapT: gl.MIRRORED_REPEAT,
        min: gl.LINEAR,
        mag: gl.LINEAR
      });
    }
  }
};

// node_modules/@antv/l7-layers/es/polygon/models/water.js
var water_frag = "uniform sampler2D u_texture;\nlayout(std140) uniform commonUniforms {\n  float u_speed;\n  float u_time;\n};\n\nout vec4 outputColor;\n\n\nin vec4 v_Color;\nin vec2 v_uv;\n\nfloat rand(vec2 n) { return 0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453); }\n\nfloat water(vec3 p) {\n  float t = u_time * u_speed;\n  p.z += t * 2.; p.x += t * 2.;\n  vec3 c1 = texture(SAMPLER_2D(u_texture), p.xz / 30.).xyz;\n  p.z += t * 3.; p.x += t * 0.52;\n  vec3 c2 = texture(SAMPLER_2D(u_texture), p.xz / 30.).xyz;\n  p.z += t * 4.; p.x += t * 0.8;\n  vec3 c3 = texture(SAMPLER_2D(u_texture), p.xz / 30.).xyz;\n  c1 += c2 - c3;\n  float z = (c1.x + c1.y + c1.z) / 3.;\n  return p.y + z / 4.;\n}\n\nfloat map(vec3 p) {\n  float d = 100.0;\n  d = water(p);\n  return d;\n}\n\nfloat intersect(vec3 ro, vec3 rd) {\n  float d = 0.0;\n  for (int i = 0; i <= 100; i++) {\n    float h = map(ro + rd * d);\n    if (h < 0.1) return  d;\n    d += h;\n  }\n  return 0.0;\n}\n\nvec3 norm(vec3 p) {\n  float eps = .1;\n  return normalize(vec3(\n    map(p + vec3(eps, 0, 0)) - map(p + vec3(-eps, 0, 0)),\n    map(p + vec3(0, eps, 0)) - map(p + vec3(0, -eps, 0)),\n    map(p + vec3(0, 0, eps)) - map(p + vec3(0, 0, -eps))\n  ));\n} \n\nfloat calSpc() {\n  vec3 l1 = normalize(vec3(1, 1, 1));\n  vec3 ro = vec3(-3, 20, -8);\n  vec3 rc = vec3(0, 0, 0);\n  vec3 ww = normalize(rc - ro);\n  vec3 uu = normalize(cross(vec3(0,1,0), ww));\n  vec3 vv = normalize(cross(rc - ro, uu));\n  vec3 rd = normalize(uu * v_uv.x + vv * v_uv.y + ww);\n  float d = intersect(ro, rd);\n  vec3 p = ro + rd * d;\n  vec3 n = norm(p);\n  float spc = pow(max(0.0, dot(reflect(l1, n), rd)), 30.0);\n  return spc;\n}\n\nvoid main() {\n\n  outputColor = v_Color;\n  float spc = calSpc();\n  outputColor += spc * 0.4;\n}\n";
var water_vert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) in vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_uv;\n\nlayout(std140) uniform commonUniforms {\n  float u_speed;\n  float u_time;\n};\nout vec4 v_Color;\nout vec2 v_uv;\n\n#pragma include "projection"\n\nvoid main() {\n  v_uv = a_uv;\n  v_Color = a_Color;\n  v_Color.a *= opacity;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n}\n\n';
var WaterModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      UV: 9
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      speed = 0.5
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_speed: speed,
      u_time: this.layer.getLayerAnimateTime(),
      u_texture: this.texture
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getAnimateUniforms() {
    return {
      u_time: this.layer.getLayerAnimateTime()
    };
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.loadTexture();
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "polygonWater",
        vertexShader: water_vert,
        fragmentShader: water_frag,
        triangulation: polygonTriangulation,
        defines: _this2.getDefines(),
        inject: _this2.getInject(),
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        },
        pickingEnabled: false,
        diagnosticDerivativeUniformityEnabled: false
      });
      return [model];
    })();
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
  }
  registerBuiltinAttributes() {
    const bbox = this.layer.getSource().extent;
    const [minLng, minLat, maxLng, maxLat] = bbox;
    const lngLen = maxLng - minLng;
    const latLen = maxLat - minLat;
    this.styleAttributeService.registerStyleAttribute({
      name: "waterUv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          const [lng, lat] = vertex;
          return [(lng - minLng) / lngLen, (lat - minLat) / latLen];
        }
      }
    });
  }
  loadTexture() {
    const {
      waterTexture
    } = this.layer.getLayerConfig();
    const {
      createTexture2D
    } = this.rendererService;
    this.texture = createTexture2D({
      height: 1,
      width: 1
    });
    const image2 = new Image();
    image2.crossOrigin = "";
    if (waterTexture) {
      console.warn("L7 recommend：https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ");
      image2.src = waterTexture;
    } else {
      image2.src = "https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ";
    }
    image2.onload = () => {
      this.texture = createTexture2D({
        data: image2,
        width: image2.width,
        height: image2.height,
        wrapS: gl.MIRRORED_REPEAT,
        wrapT: gl.MIRRORED_REPEAT,
        min: gl.LINEAR,
        mag: gl.LINEAR
      });
      this.layerService.reRender();
    };
  }
};

// node_modules/@antv/l7-layers/es/polygon/models/index.js
var PolygonModels = {
  fill: FillModel3,
  line: LineModel,
  extrude: ExtrudeModel3,
  text: TextModel,
  point_fill: FillModel2,
  point_image: ImageModel2,
  point_normal: NormalModel,
  point_extrude: ExtrudeModel2,
  water: WaterModel,
  ocean: OceanModel,
  extrusion: ExtrusionModel
  // point_fill: PointModels.fill,
};
var models_default6 = PolygonModels;

// node_modules/@antv/l7-layers/es/polygon/index.js
var PolygonLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "PolygonLayer");
    _defineProperty(this, "enableShaderEncodeStyles", [
      "opacity",
      "extrusionBase",
      // shape 为文本时
      "rotation",
      "offsets",
      "stroke"
    ]);
  }
  buildModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const shape = _this.getModelType();
      _this.layerModel = new models_default6[shape](_this);
      yield _this.initLayerModels();
    })();
  }
  getModelType() {
    var _shapeAttribute$scale;
    const shapeAttribute = this.styleAttributeService.getLayerStyleAttribute("shape");
    const shape = shapeAttribute === null || shapeAttribute === void 0 || (_shapeAttribute$scale = shapeAttribute.scale) === null || _shapeAttribute$scale === void 0 ? void 0 : _shapeAttribute$scale.field;
    if (shape === "fill" || !shape) {
      return "fill";
    } else if (shape === "extrude") {
      return "extrude";
    } else if (shape === "extrusion") {
      return "extrusion";
    } else if (shape === "water") {
      return "water";
    } else if (shape === "ocean") {
      return "ocean";
    } else if (shape === "line") {
      return "line";
    } else {
      return this.getPointModelType();
    }
  }
  getPointModelType() {
    const layerData = this.getEncodedData();
    const {
      shape2d,
      shape3d
    } = this.getLayerConfig();
    const iconMap = this.iconService.getIconMap();
    const item = layerData.find((fe) => {
      return fe.hasOwnProperty("shape");
    });
    if (!item) {
      return "fill";
    } else {
      const shape = item.shape;
      if (shape === "dot") {
        return "point_normal";
      }
      if ((shape2d === null || shape2d === void 0 ? void 0 : shape2d.indexOf(shape)) !== -1) {
        return "point_fill";
      }
      if ((shape3d === null || shape3d === void 0 ? void 0 : shape3d.indexOf(shape)) !== -1) {
        return "point_extrude";
      }
      if (iconMap.hasOwnProperty(shape)) {
        return "point_image";
      }
      return "text";
    }
  }
};

// node_modules/@antv/l7-layers/es/raster/models/raster.js
var rasterFrag = "layout(std140) uniform commonUniforms {\n  vec2 u_domain;\n  float u_opacity;\n  float u_noDataValue;\n  float u_clampLow;\n  float u_clampHigh;\n};\n\nuniform sampler2D u_rasterTexture;\nuniform sampler2D u_colorTexture;\n\nin vec2 v_texCoord;\n\nbool isnan_emu(float x) { return (x > 0.0 || x < 0.0) ? x != x : x != 0.0; }\n\nout vec4 outputColor;\n\nvoid main() {\n  // Can use any component here since u_rasterTexture is under luminance format.\n  float value = texture(SAMPLER_2D(u_rasterTexture), vec2(v_texCoord.x, v_texCoord.y)).r;\n  if (value == u_noDataValue || isnan_emu(value)) {\n    discard;\n  } else if ((u_clampLow < 0.5 && value < u_domain[0]) || (u_clampHigh < 0.5 && value > u_domain[1])) {\n    discard;\n  } else {\n    float normalisedValue =(value - u_domain[0]) / (u_domain[1] - u_domain[0]);\n    vec4 color = texture(SAMPLER_2D(u_colorTexture), vec2(normalisedValue, 0));\n    \n    outputColor = color;\n    outputColor.a = outputColor.a * u_opacity ;\n    if (outputColor.a < 0.01)\n      discard;\n  }\n}\n";
var rasterVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_domain;\n  float u_opacity;\n  float u_noDataValue;\n  float u_clampLow;\n  float u_clampHigh;\n};\n\nout vec2 v_texCoord;\n\n#pragma include "projection"\n\nvoid main() {\n  v_texCoord = a_Uv;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0.0, 1.0));\n}\n';
var RasterModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "colorTexture", void 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      UV: 9
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity = 1,
      clampLow = true,
      clampHigh = true,
      noDataValue = -9999999,
      domain,
      rampColors
    } = this.layer.getLayerConfig();
    const newdomain = domain || getDefaultDomain(rampColors);
    this.colorTexture = this.layer.textureService.getColorTexture(rampColors, newdomain);
    const commonOptions = {
      u_domain: newdomain,
      u_opacity: opacity || 1,
      u_noDataValue: noDataValue,
      u_clampLow: clampLow ? 1 : 0,
      u_clampHigh: (typeof clampHigh !== "undefined" ? clampHigh : clampLow) ? 1 : 0,
      u_rasterTexture: this.texture,
      u_colorTexture: this.colorTexture
    };
    this.textures = [this.texture, this.colorTexture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getRasterData(parserDataItem) {
    return _asyncToGenerator(function* () {
      if (Array.isArray(parserDataItem.data)) {
        return {
          data: parserDataItem.data,
          width: parserDataItem.width,
          height: parserDataItem.height
        };
      } else {
        const {
          rasterData,
          width,
          height
        } = yield parserDataItem.data;
        return {
          data: Array.from(rasterData),
          width,
          height
        };
      }
    })();
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const source = _this2.layer.getSource();
      const {
        createTexture2D,
        queryVerdorInfo
      } = _this2.rendererService;
      const parserDataItem = source.data.dataArray[0];
      const {
        data,
        width,
        height
      } = yield _this2.getRasterData(parserDataItem);
      _this2.texture = createTexture2D({
        // @ts-ignore
        data: new Float32Array(data),
        width,
        height,
        /**
         * WebGL1 allow the combination of gl.LUMINANCE & gl.FLOAT with OES_texture_float
         * TODO: https://github.com/antvis/g-device-api/issues/188
         */
        format: queryVerdorInfo() === "WebGL1" ? gl.LUMINANCE : gl.RED,
        type: gl.FLOAT,
        alignment: 1
      });
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "rasterImageData",
        vertexShader: rasterVert,
        fragmentShader: rasterFrag,
        defines: _this2.getDefines(),
        triangulation: RasterImageTriangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        },
        pickingEnabled: false
      });
      return [model];
    })();
  }
  clearModels() {
    var _this$texture, _this$colorTexture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
    (_this$colorTexture = this.colorTexture) === null || _this$colorTexture === void 0 || _this$colorTexture.destroy();
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        shaderLocation: this.attributeLocation.UV,
        name: "a_Uv",
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/raster/models/rasterRgb.js
var _excluded3 = ["data"];
var _excluded23 = ["rasterData"];
var rasterFrag2 = "uniform sampler2D u_texture;\nlayout(std140) uniform commonUniforms {\n vec2 u_rminmax;\n vec2 u_gminmax;\n vec2 u_bminmax;\n float u_opacity;\n float u_noDataValue;\n};\n\nin vec2 v_texCoord;\n\nout vec4 outputColor;\n\nvoid main() {\n\n  vec3 rgb = texture(SAMPLER_2D(u_texture),vec2(v_texCoord.x,v_texCoord.y)).rgb;\n\n  if(rgb == vec3(u_noDataValue)) {\n    outputColor = vec4(0.0, 0, 0, 0.0);\n  } else {\n    outputColor = vec4(rgb.r / (u_rminmax.y -u_rminmax.x), rgb.g /(u_gminmax.y -u_gminmax.x), rgb.b/ (u_bminmax.y - u_bminmax.x), u_opacity);\n  }\n\n  if(outputColor.a < 0.01)\n    discard;\n \n}";
var rasterVert2 = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_POSITION_64LOW) in vec2 a_Position64Low;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  vec2 u_rminmax;\n  vec2 u_gminmax;\n  vec2 u_bminmax;\n  float u_opacity;\n  float u_noDataValue;\n};\n\nout vec2 v_texCoord;\n\n#pragma include "projection"\n\nvoid main() {\n  v_texCoord = a_Uv;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0), a_Position64Low);\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0.0, 1.0));\n}\n';
var RasterModel2 = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "dataOption", {});
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      UV: 9
    });
  }
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity = 1,
      noDataValue = 0
    } = this.layer.getLayerConfig();
    const {
      rMinMax = [0, 255],
      gMinMax = [0, 255],
      bMinMax = [0, 255]
    } = this.dataOption;
    const commonOptions = {
      u_rminmax: rMinMax,
      u_gminmax: gMinMax,
      u_bminmax: bMinMax,
      u_opacity: opacity || 1,
      u_noDataValue: noDataValue,
      u_texture: this.texture
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  getRasterData(parserDataItem) {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (Array.isArray(parserDataItem.data)) {
        const {
          data
        } = parserDataItem, rescfg = _objectWithoutProperties(parserDataItem, _excluded3);
        _this.dataOption = rescfg;
        return _objectSpread2({
          data
        }, rescfg);
      }
      const _yield$parserDataItem = yield parserDataItem.data, {
        rasterData
      } = _yield$parserDataItem, rest = _objectWithoutProperties(_yield$parserDataItem, _excluded23);
      _this.dataOption = rest;
      if (Array.isArray(rasterData)) {
        return _objectSpread2({
          data: rasterData
        }, rest);
      } else {
        return _objectSpread2({
          data: Array.from(rasterData)
        }, rest);
      }
    })();
  }
  initModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const source = _this2.layer.getSource();
      const {
        createTexture2D
      } = _this2.rendererService;
      const parserDataItem = source.data.dataArray[0];
      const {
        data,
        width,
        height
      } = yield _this2.getRasterData(parserDataItem);
      _this2.texture = createTexture2D({
        // @ts-ignore
        data: new Float32Array(data),
        width,
        height,
        format: gl.RGB,
        type: gl.FLOAT
      });
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "rasterImageDataRGBA",
        vertexShader: rasterVert2,
        fragmentShader: rasterFrag2,
        defines: _this2.getDefines(),
        triangulation: RasterImageTriangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        },
        pickingEnabled: false
      });
      return [model];
    })();
  }
  buildModels() {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      return _this3.initModels();
    })();
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/raster/models/rasterTerrainRgb.js
var Raster_terrainFrag = "uniform sampler2D u_texture;\nuniform sampler2D u_colorTexture;\n\nlayout(std140) uniform commonUniforms {\n vec4 u_unpack;\n vec2 u_domain;\n float u_opacity;\n float u_noDataValue;\n float u_clampLow;\n float u_clampHigh;\n};\n\nin vec2 v_texCoord;\nout vec4 outputColor;\n\n\nfloat getElevation(vec2 coord, float bias) {\n    // Convert encoded elevation value to meters\n    vec4 data =  texture(SAMPLER_2D(u_texture), coord,bias) * 255.0;\n    data.a = -1.0;\n    return dot(data, u_unpack);\n}\n\nvec4 getColor(float value) {\n   float normalisedValue =(value- u_domain[0]) / (u_domain[1] - u_domain[0]);\n    vec2 coord = vec2(normalisedValue, 0);\n    return  texture(SAMPLER_2D(u_colorTexture), coord);\n}\n\nvoid main() {\n  float value = getElevation(v_texCoord,0.0);\n  if (value == u_noDataValue) {\n    outputColor = vec4(0.0, 0, 0, 0.0);\n  } else if ((u_clampLow < 0.5 && value < u_domain[0]) || (u_clampHigh < 0.5 && value > u_domain[1])) {\n     outputColor = vec4(0.0, 0, 0, 0.0);\n  } else {\n   \n    outputColor = getColor(value);\n    outputColor.a =  outputColor.a * u_opacity ;\n      if(outputColor.a < 0.01)\n      discard;\n  }\n}\n";
var Raster_terrainVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n  vec4 u_unpack;\n  vec2 u_domain;\n  float u_opacity;\n  float u_noDataValue;\n  float u_clampLow;\n  float u_clampHigh;\n};\nout vec2 v_texCoord;\n#pragma include "projection"\n\nvoid main() {\n  v_texCoord = a_Uv;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0.0, 1.0));\n}\n';
var RasterTerrainRGB = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      UV: 9
    });
  }
  getCommonUniformsInfo() {
    const {
      opacity,
      clampLow = true,
      clampHigh = true,
      noDataValue = -9999999,
      domain,
      rampColors,
      colorTexture,
      rScaler = 6553.6,
      gScaler = 25.6,
      bScaler = 0.1,
      offset = 1e4
    } = this.layer.getLayerConfig();
    const newdomain = domain || getDefaultDomain(rampColors);
    let texture = colorTexture;
    if (!colorTexture) {
      texture = this.layer.textureService.getColorTexture(rampColors, newdomain);
    } else {
      this.layer.textureService.setColorTexture(colorTexture, rampColors, newdomain);
    }
    const commonOptions = {
      u_unpack: [rScaler, gScaler, bScaler, offset],
      u_domain: newdomain,
      u_opacity: opacity || 1,
      u_noDataValue: noDataValue,
      u_clampLow: clampLow,
      u_clampHigh: typeof clampHigh !== "undefined" ? clampHigh : clampLow,
      u_texture: this.texture,
      u_colorTexture: texture
    };
    this.textures = [this.texture, texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      const source = _this.layer.getSource();
      const {
        createTexture2D
      } = _this.rendererService;
      const imageData = yield source.data.images;
      _this.texture = createTexture2D({
        data: imageData[0],
        width: imageData[0].width,
        height: imageData[0].height,
        min: gl.LINEAR,
        mag: gl.LINEAR
      });
      const model = yield _this.layer.buildLayerModel({
        moduleName: "RasterTileDataImage",
        vertexShader: Raster_terrainVert,
        fragmentShader: Raster_terrainFrag,
        defines: _this.getDefines(),
        triangulation: RasterImageTriangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        }
      });
      return [model];
    })();
  }
  clearModels() {
    var _this$texture;
    (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      return _this2.initModels();
    })();
  }
  registerBuiltinAttributes() {
    this.registerPosition64LowAttribute();
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/raster/models/index.js
var RasterModels = {
  raster: RasterModel,
  rasterRgb: RasterModel2,
  raster3d: RasterModel,
  rasterTerrainRgb: RasterTerrainRGB
};
var models_default7 = RasterModels;

// node_modules/@antv/l7-layers/es/raster/index.js
var RasterLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "RasterLayer");
  }
  buildModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const modelType = _this.getModelType();
      _this.layerModel = new models_default7[modelType](_this);
      yield _this.initLayerModels();
    })();
  }
  getDefaultConfig() {
    const type = this.getModelType();
    const defaultConfig = {
      raster: {},
      rasterRgb: {},
      raster3d: {},
      rasterTerrainRgb: {}
    };
    return defaultConfig[type];
  }
  getModelType() {
    const parserType = this.layerSource.getParserType();
    switch (parserType) {
      case "raster":
        return "raster";
      case "rasterRgb":
        return "rasterRgb";
      case "rgb":
        return "rasterRgb";
      case "image":
        return "rasterTerrainRgb";
      default:
        return "raster";
    }
  }
  getLegend(name) {
    if (name !== "color")
      return {
        type: void 0,
        field: void 0,
        items: []
      };
    const rampColors = this.getLayerConfig().rampColors;
    return rampColor2legend(rampColors, name);
  }
};

// node_modules/@antv/l7-layers/es/tile/service/TileLayerService.js
var TileLayerService = class {
  constructor({
    rendererService,
    layerService,
    parent
  }) {
    _defineProperty(this, "tileResource", /* @__PURE__ */ new Map());
    _defineProperty(this, "rendererService", void 0);
    _defineProperty(this, "layerService", void 0);
    _defineProperty(this, "parent", void 0);
    _defineProperty(this, "layerTiles", []);
    this.rendererService = rendererService;
    this.layerService = layerService;
    this.parent = parent;
  }
  get tiles() {
    return this.layerTiles;
  }
  hasTile(tileKey) {
    return this.layerTiles.some((tile) => tile.key === tileKey);
  }
  addTile(tile) {
    this.layerTiles.push(tile);
  }
  getTile(tileKey) {
    return this.layerTiles.find((tile) => tile.key === tileKey);
  }
  getVisibleTileBylngLat(lngLat) {
    return this.layerTiles.find((tile) => tile.isLoaded && tile.visible && tile.lnglatInBounds(lngLat));
  }
  removeTile(tileKey) {
    const index3 = this.layerTiles.findIndex((t) => t.key === tileKey);
    const tile = this.layerTiles.splice(index3, 1);
    if (tile[0]) {
      tile[0].destroy();
    }
  }
  updateTileVisible(sourceTile) {
    const tile = this.getTile(sourceTile.key);
    if (sourceTile.isVisible) {
      if (sourceTile.parent) {
        const flag = this.isChildrenLoaded(sourceTile.parent);
        tile === null || tile === void 0 || tile.updateVisible(flag);
      } else {
        tile === null || tile === void 0 || tile.updateVisible(true);
      }
    } else {
      if (sourceTile.parent) {
        const flag = this.isChildrenLoaded(sourceTile.parent);
        tile === null || tile === void 0 || tile.updateVisible(!flag);
      } else {
        tile === null || tile === void 0 || tile.updateVisible(false);
      }
    }
  }
  isParentLoaded(sourceTile) {
    const parentTile = sourceTile.parent;
    if (!parentTile) {
      return true;
    }
    const tile = this.getTile(parentTile === null || parentTile === void 0 ? void 0 : parentTile.key);
    if (tile !== null && tile !== void 0 && tile.isLoaded) {
      return true;
    }
    return false;
  }
  isChildrenLoaded(sourceTile) {
    const childrenTile = sourceTile === null || sourceTile === void 0 ? void 0 : sourceTile.children;
    if (childrenTile.length === 0) {
      return true;
    }
    return childrenTile.every((tile) => {
      const tileLayer = this.getTile(tile === null || tile === void 0 ? void 0 : tile.key);
      if (!tileLayer) {
        return true;
      }
      return (tileLayer === null || tileLayer === void 0 ? void 0 : tileLayer.isLoaded) === true;
    });
  }
  render() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const layers = _this.getRenderLayers();
      const renders = layers.map(function() {
        var _ref = _asyncToGenerator(function* (layer) {
          yield _this.layerService.renderTileLayer(layer);
        });
        return function(_x) {
          return _ref.apply(this, arguments);
        };
      }());
      yield Promise.all(renders);
    })();
  }
  getRenderLayers() {
    const tileList = this.layerTiles.filter((t) => t.visible && t.isLoaded);
    const layers = [];
    tileList.map((tile) => layers.push(...tile.getLayers()));
    return layers;
  }
  getLayers() {
    const tileList = this.layerTiles.filter((t) => t.isLoaded);
    const layers = [];
    tileList.map((tile) => layers.push(...tile.getLayers()));
    return layers;
  }
  getTiles() {
    return this.layerTiles;
  }
  destroy() {
    this.layerTiles.forEach((t) => t.destroy());
    this.tileResource.clear();
  }
};

// node_modules/splaytree/dist/splay.esm.js
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v2) {
      return step([n, v2]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var Node = (
  /** @class */
  function() {
    function Node2(key, data) {
      this.next = null;
      this.key = key;
      this.data = data;
      this.left = null;
      this.right = null;
    }
    return Node2;
  }()
);
function DEFAULT_COMPARE(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function splay(i, t, comparator) {
  var N = new Node(null, null);
  var l = N;
  var r = N;
  while (true) {
    var cmp2 = comparator(i, t.key);
    if (cmp2 < 0) {
      if (t.left === null)
        break;
      if (comparator(i, t.left.key) < 0) {
        var y = t.left;
        t.left = y.right;
        y.right = t;
        t = y;
        if (t.left === null)
          break;
      }
      r.left = t;
      r = t;
      t = t.left;
    } else if (cmp2 > 0) {
      if (t.right === null)
        break;
      if (comparator(i, t.right.key) > 0) {
        var y = t.right;
        t.right = y.left;
        y.left = t;
        t = y;
        if (t.right === null)
          break;
      }
      l.right = t;
      l = t;
      t = t.right;
    } else
      break;
  }
  l.right = t.left;
  r.left = t.right;
  t.left = N.right;
  t.right = N.left;
  return t;
}
function insert(i, data, t, comparator) {
  var node = new Node(i, data);
  if (t === null) {
    node.left = node.right = null;
    return node;
  }
  t = splay(i, t, comparator);
  var cmp2 = comparator(i, t.key);
  if (cmp2 < 0) {
    node.left = t.left;
    node.right = t;
    t.left = null;
  } else if (cmp2 >= 0) {
    node.right = t.right;
    node.left = t;
    t.right = null;
  }
  return node;
}
function split(key, v2, comparator) {
  var left = null;
  var right = null;
  if (v2) {
    v2 = splay(key, v2, comparator);
    var cmp2 = comparator(v2.key, key);
    if (cmp2 === 0) {
      left = v2.left;
      right = v2.right;
    } else if (cmp2 < 0) {
      right = v2.right;
      v2.right = null;
      left = v2;
    } else {
      left = v2.left;
      v2.left = null;
      right = v2;
    }
  }
  return { left, right };
}
function merge3(left, right, comparator) {
  if (right === null)
    return left;
  if (left === null)
    return right;
  right = splay(left.key, right, comparator);
  right.left = left;
  return right;
}
function printRow(root, prefix2, isTail, out, printNode) {
  if (root) {
    out("" + prefix2 + (isTail ? "└── " : "├── ") + printNode(root) + "\n");
    var indent = prefix2 + (isTail ? "    " : "│   ");
    if (root.left)
      printRow(root.left, indent, false, out, printNode);
    if (root.right)
      printRow(root.right, indent, true, out, printNode);
  }
}
var Tree = (
  /** @class */
  function() {
    function Tree2(comparator) {
      if (comparator === void 0) {
        comparator = DEFAULT_COMPARE;
      }
      this._root = null;
      this._size = 0;
      this._comparator = comparator;
    }
    Tree2.prototype.insert = function(key, data) {
      this._size++;
      return this._root = insert(key, data, this._root, this._comparator);
    };
    Tree2.prototype.add = function(key, data) {
      var node = new Node(key, data);
      if (this._root === null) {
        node.left = node.right = null;
        this._size++;
        this._root = node;
      }
      var comparator = this._comparator;
      var t = splay(key, this._root, comparator);
      var cmp2 = comparator(key, t.key);
      if (cmp2 === 0)
        this._root = t;
      else {
        if (cmp2 < 0) {
          node.left = t.left;
          node.right = t;
          t.left = null;
        } else if (cmp2 > 0) {
          node.right = t.right;
          node.left = t;
          t.right = null;
        }
        this._size++;
        this._root = node;
      }
      return this._root;
    };
    Tree2.prototype.remove = function(key) {
      this._root = this._remove(key, this._root, this._comparator);
    };
    Tree2.prototype._remove = function(i, t, comparator) {
      var x;
      if (t === null)
        return null;
      t = splay(i, t, comparator);
      var cmp2 = comparator(i, t.key);
      if (cmp2 === 0) {
        if (t.left === null) {
          x = t.right;
        } else {
          x = splay(i, t.left, comparator);
          x.right = t.right;
        }
        this._size--;
        return x;
      }
      return t;
    };
    Tree2.prototype.pop = function() {
      var node = this._root;
      if (node) {
        while (node.left)
          node = node.left;
        this._root = splay(node.key, this._root, this._comparator);
        this._root = this._remove(node.key, this._root, this._comparator);
        return { key: node.key, data: node.data };
      }
      return null;
    };
    Tree2.prototype.findStatic = function(key) {
      var current = this._root;
      var compare = this._comparator;
      while (current) {
        var cmp2 = compare(key, current.key);
        if (cmp2 === 0)
          return current;
        else if (cmp2 < 0)
          current = current.left;
        else
          current = current.right;
      }
      return null;
    };
    Tree2.prototype.find = function(key) {
      if (this._root) {
        this._root = splay(key, this._root, this._comparator);
        if (this._comparator(key, this._root.key) !== 0)
          return null;
      }
      return this._root;
    };
    Tree2.prototype.contains = function(key) {
      var current = this._root;
      var compare = this._comparator;
      while (current) {
        var cmp2 = compare(key, current.key);
        if (cmp2 === 0)
          return true;
        else if (cmp2 < 0)
          current = current.left;
        else
          current = current.right;
      }
      return false;
    };
    Tree2.prototype.forEach = function(visitor, ctx) {
      var current = this._root;
      var Q = [];
      var done = false;
      while (!done) {
        if (current !== null) {
          Q.push(current);
          current = current.left;
        } else {
          if (Q.length !== 0) {
            current = Q.pop();
            visitor.call(ctx, current);
            current = current.right;
          } else
            done = true;
        }
      }
      return this;
    };
    Tree2.prototype.range = function(low, high, fn, ctx) {
      var Q = [];
      var compare = this._comparator;
      var node = this._root;
      var cmp2;
      while (Q.length !== 0 || node) {
        if (node) {
          Q.push(node);
          node = node.left;
        } else {
          node = Q.pop();
          cmp2 = compare(node.key, high);
          if (cmp2 > 0) {
            break;
          } else if (compare(node.key, low) >= 0) {
            if (fn.call(ctx, node))
              return this;
          }
          node = node.right;
        }
      }
      return this;
    };
    Tree2.prototype.keys = function() {
      var keys = [];
      this.forEach(function(_a2) {
        var key = _a2.key;
        return keys.push(key);
      });
      return keys;
    };
    Tree2.prototype.values = function() {
      var values = [];
      this.forEach(function(_a2) {
        var data = _a2.data;
        return values.push(data);
      });
      return values;
    };
    Tree2.prototype.min = function() {
      if (this._root)
        return this.minNode(this._root).key;
      return null;
    };
    Tree2.prototype.max = function() {
      if (this._root)
        return this.maxNode(this._root).key;
      return null;
    };
    Tree2.prototype.minNode = function(t) {
      if (t === void 0) {
        t = this._root;
      }
      if (t)
        while (t.left)
          t = t.left;
      return t;
    };
    Tree2.prototype.maxNode = function(t) {
      if (t === void 0) {
        t = this._root;
      }
      if (t)
        while (t.right)
          t = t.right;
      return t;
    };
    Tree2.prototype.at = function(index3) {
      var current = this._root;
      var done = false;
      var i = 0;
      var Q = [];
      while (!done) {
        if (current) {
          Q.push(current);
          current = current.left;
        } else {
          if (Q.length > 0) {
            current = Q.pop();
            if (i === index3)
              return current;
            i++;
            current = current.right;
          } else
            done = true;
        }
      }
      return null;
    };
    Tree2.prototype.next = function(d) {
      var root = this._root;
      var successor = null;
      if (d.right) {
        successor = d.right;
        while (successor.left)
          successor = successor.left;
        return successor;
      }
      var comparator = this._comparator;
      while (root) {
        var cmp2 = comparator(d.key, root.key);
        if (cmp2 === 0)
          break;
        else if (cmp2 < 0) {
          successor = root;
          root = root.left;
        } else
          root = root.right;
      }
      return successor;
    };
    Tree2.prototype.prev = function(d) {
      var root = this._root;
      var predecessor = null;
      if (d.left !== null) {
        predecessor = d.left;
        while (predecessor.right)
          predecessor = predecessor.right;
        return predecessor;
      }
      var comparator = this._comparator;
      while (root) {
        var cmp2 = comparator(d.key, root.key);
        if (cmp2 === 0)
          break;
        else if (cmp2 < 0)
          root = root.left;
        else {
          predecessor = root;
          root = root.right;
        }
      }
      return predecessor;
    };
    Tree2.prototype.clear = function() {
      this._root = null;
      this._size = 0;
      return this;
    };
    Tree2.prototype.toList = function() {
      return toList(this._root);
    };
    Tree2.prototype.load = function(keys, values, presort) {
      if (values === void 0) {
        values = [];
      }
      if (presort === void 0) {
        presort = false;
      }
      var size2 = keys.length;
      var comparator = this._comparator;
      if (presort)
        sort2(keys, values, 0, size2 - 1, comparator);
      if (this._root === null) {
        this._root = loadRecursive(keys, values, 0, size2);
        this._size = size2;
      } else {
        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
        size2 = this._size + size2;
        this._root = sortedListToBST({ head: mergedList }, 0, size2);
      }
      return this;
    };
    Tree2.prototype.isEmpty = function() {
      return this._root === null;
    };
    Object.defineProperty(Tree2.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Tree2.prototype, "root", {
      get: function() {
        return this._root;
      },
      enumerable: true,
      configurable: true
    });
    Tree2.prototype.toString = function(printNode) {
      if (printNode === void 0) {
        printNode = function(n) {
          return String(n.key);
        };
      }
      var out = [];
      printRow(this._root, "", true, function(v2) {
        return out.push(v2);
      }, printNode);
      return out.join("");
    };
    Tree2.prototype.update = function(key, newKey, newData) {
      var comparator = this._comparator;
      var _a2 = split(key, this._root, comparator), left = _a2.left, right = _a2.right;
      if (comparator(key, newKey) < 0) {
        right = insert(newKey, newData, right, comparator);
      } else {
        left = insert(newKey, newData, left, comparator);
      }
      this._root = merge3(left, right, comparator);
    };
    Tree2.prototype.split = function(key) {
      return split(key, this._root, this._comparator);
    };
    Tree2.prototype[Symbol.iterator] = function() {
      var current, Q, done;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            current = this._root;
            Q = [];
            done = false;
            _a2.label = 1;
          case 1:
            if (!!done)
              return [3, 6];
            if (!(current !== null))
              return [3, 2];
            Q.push(current);
            current = current.left;
            return [3, 5];
          case 2:
            if (!(Q.length !== 0))
              return [3, 4];
            current = Q.pop();
            return [4, current];
          case 3:
            _a2.sent();
            current = current.right;
            return [3, 5];
          case 4:
            done = true;
            _a2.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [
              2
              /*return*/
            ];
        }
      });
    };
    return Tree2;
  }()
);
function loadRecursive(keys, values, start, end) {
  var size2 = end - start;
  if (size2 > 0) {
    var middle = start + Math.floor(size2 / 2);
    var key = keys[middle];
    var data = values[middle];
    var node = new Node(key, data);
    node.left = loadRecursive(keys, values, start, middle);
    node.right = loadRecursive(keys, values, middle + 1, end);
    return node;
  }
  return null;
}
function createList(keys, values) {
  var head2 = new Node(null, null);
  var p = head2;
  for (var i = 0; i < keys.length; i++) {
    p = p.next = new Node(keys[i], values[i]);
  }
  p.next = null;
  return head2.next;
}
function toList(root) {
  var current = root;
  var Q = [];
  var done = false;
  var head2 = new Node(null, null);
  var p = head2;
  while (!done) {
    if (current) {
      Q.push(current);
      current = current.left;
    } else {
      if (Q.length > 0) {
        current = p = p.next = Q.pop();
        current = current.right;
      } else
        done = true;
    }
  }
  p.next = null;
  return head2.next;
}
function sortedListToBST(list, start, end) {
  var size2 = end - start;
  if (size2 > 0) {
    var middle = start + Math.floor(size2 / 2);
    var left = sortedListToBST(list, start, middle);
    var root = list.head;
    root.left = left;
    list.head = list.head.next;
    root.right = sortedListToBST(list, middle + 1, end);
    return root;
  }
  return null;
}
function mergeLists(l1, l2, compare) {
  var head2 = new Node(null, null);
  var p = head2;
  var p1 = l1;
  var p2 = l2;
  while (p1 !== null && p2 !== null) {
    if (compare(p1.key, p2.key) < 0) {
      p.next = p1;
      p1 = p1.next;
    } else {
      p.next = p2;
      p2 = p2.next;
    }
    p = p.next;
  }
  if (p1 !== null) {
    p.next = p1;
  } else if (p2 !== null) {
    p.next = p2;
  }
  return head2.next;
}
function sort2(keys, values, left, right, compare) {
  if (left >= right)
    return;
  var pivot = keys[left + right >> 1];
  var i = left - 1;
  var j = right + 1;
  while (true) {
    do
      i++;
    while (compare(keys[i], pivot) < 0);
    do
      j--;
    while (compare(keys[j], pivot) > 0);
    if (i >= j)
      break;
    var tmp2 = keys[i];
    keys[i] = keys[j];
    keys[j] = tmp2;
    tmp2 = values[i];
    values[i] = values[j];
    values[j] = tmp2;
  }
  sort2(keys, values, left, j, compare);
  sort2(keys, values, j + 1, right, compare);
}
var splay_esm_default = Tree;

// node_modules/robust-predicates/esm/util.js
var epsilon = 11102230246251565e-32;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon) * epsilon;
function sum3(elen, e, flen, f, h) {
  let Q, Qnew, hh, bvirt;
  let enow = e[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e) {
  let Q = e[0];
  for (let i = 1; i < elen; i++)
    Q += e[i];
  return Q;
}
function vec(n) {
  return new Float64Array(n);
}

// node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon) * epsilon;
var ccwerrboundB = (2 + 12 * epsilon) * epsilon;
var ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
var B = vec(4);
var C1 = vec(8);
var C2 = vec(12);
var D = vec(16);
var u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t12, t02, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t12 = acy * bcx;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t02;
  bvirt = s0 - _i;
  B[0] = s0 - (_i + bvirt) + (bvirt - t02);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t12;
  bvirt = _0 - _i;
  B[1] = _0 - (_i + bvirt) + (bvirt - t12);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B[3] = u32;
  let det = estimate(4, B);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound)
    return det;
  s1 = acxtail * bcy;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t12 = acytail * bcx;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t02;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t02);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t12;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t12);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C1len = sum3(4, B, 4, u, C1);
  s1 = acx * bcytail;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t12 = acy * bcxtail;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t02;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t02);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t12;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t12);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C2len = sum3(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t12 = acytail * bcxtail;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t02;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t02);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t12;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t12);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const Dlen = sum3(C2len, C2, 4, u, D);
  return D[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum)
    return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon) * epsilon;
var o3derrboundB = (3 + 28 * epsilon) * epsilon;
var o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u2 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);

// node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon) * epsilon;
var iccerrboundB = (4 + 48 * epsilon) * epsilon;
var iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u3 = vec(4);
var v = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon) * epsilon;
var isperrboundB = (5 + 72 * epsilon) * epsilon;
var isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin4 = vec(1152);

// node_modules/polygon-clipping/dist/polygon-clipping.esm.js
var isInBbox = (bbox, point2) => {
  return bbox.ll.x <= point2.x && point2.x <= bbox.ur.x && bbox.ll.y <= point2.y && point2.y <= bbox.ur.y;
};
var getBboxOverlap = (b1, b2) => {
  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y)
    return null;
  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
  return {
    ll: {
      x: lowerX,
      y: lowerY
    },
    ur: {
      x: upperX,
      y: upperY
    }
  };
};
var epsilon2 = Number.EPSILON;
if (epsilon2 === void 0)
  epsilon2 = Math.pow(2, -52);
var EPSILON_SQ = epsilon2 * epsilon2;
var cmp = (a, b) => {
  if (-epsilon2 < a && a < epsilon2) {
    if (-epsilon2 < b && b < epsilon2) {
      return 0;
    }
  }
  const ab4 = a - b;
  if (ab4 * ab4 < EPSILON_SQ * a * b) {
    return 0;
  }
  return a < b ? -1 : 1;
};
var PtRounder = class {
  constructor() {
    this.reset();
  }
  reset() {
    this.xRounder = new CoordRounder();
    this.yRounder = new CoordRounder();
  }
  round(x, y) {
    return {
      x: this.xRounder.round(x),
      y: this.yRounder.round(y)
    };
  }
};
var CoordRounder = class {
  constructor() {
    this.tree = new splay_esm_default();
    this.round(0);
  }
  // Note: this can rounds input values backwards or forwards.
  //       You might ask, why not restrict this to just rounding
  //       forwards? Wouldn't that allow left endpoints to always
  //       remain left endpoints during splitting (never change to
  //       right). No - it wouldn't, because we snap intersections
  //       to endpoints (to establish independence from the segment
  //       angle for t-intersections).
  round(coord) {
    const node = this.tree.add(coord);
    const prevNode = this.tree.prev(node);
    if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
      this.tree.remove(coord);
      return prevNode.key;
    }
    const nextNode = this.tree.next(node);
    if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
      this.tree.remove(coord);
      return nextNode.key;
    }
    return coord;
  }
};
var rounder = new PtRounder();
var crossProduct = (a, b) => a.x * b.y - a.y * b.x;
var dotProduct = (a, b) => a.x * b.x + a.y * b.y;
var compareVectorAngles = (basePt, endPt1, endPt2) => {
  const res = orient2d(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);
  if (res > 0)
    return -1;
  if (res < 0)
    return 1;
  return 0;
};
var length = (v2) => Math.sqrt(dotProduct(v2, v2));
var sineOfAngle = (pShared, pBase, pAngle) => {
  const vBase = {
    x: pBase.x - pShared.x,
    y: pBase.y - pShared.y
  };
  const vAngle = {
    x: pAngle.x - pShared.x,
    y: pAngle.y - pShared.y
  };
  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
};
var cosineOfAngle = (pShared, pBase, pAngle) => {
  const vBase = {
    x: pBase.x - pShared.x,
    y: pBase.y - pShared.y
  };
  const vAngle = {
    x: pAngle.x - pShared.x,
    y: pAngle.y - pShared.y
  };
  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
};
var horizontalIntersection = (pt, v2, y) => {
  if (v2.y === 0)
    return null;
  return {
    x: pt.x + v2.x / v2.y * (y - pt.y),
    y
  };
};
var verticalIntersection = (pt, v2, x) => {
  if (v2.x === 0)
    return null;
  return {
    x,
    y: pt.y + v2.y / v2.x * (x - pt.x)
  };
};
var intersection$1 = (pt1, v1, pt2, v2) => {
  if (v1.x === 0)
    return verticalIntersection(pt2, v2, pt1.x);
  if (v2.x === 0)
    return verticalIntersection(pt1, v1, pt2.x);
  if (v1.y === 0)
    return horizontalIntersection(pt2, v2, pt1.y);
  if (v2.y === 0)
    return horizontalIntersection(pt1, v1, pt2.y);
  const kross = crossProduct(v1, v2);
  if (kross == 0)
    return null;
  const ve = {
    x: pt2.x - pt1.x,
    y: pt2.y - pt1.y
  };
  const d1 = crossProduct(ve, v1) / kross;
  const d2 = crossProduct(ve, v2) / kross;
  const x1 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;
  const y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;
  const x = (x1 + x2) / 2;
  const y = (y1 + y2) / 2;
  return {
    x,
    y
  };
};
var SweepEvent = class _SweepEvent {
  // for ordering sweep events in the sweep event queue
  static compare(a, b) {
    const ptCmp = _SweepEvent.comparePoints(a.point, b.point);
    if (ptCmp !== 0)
      return ptCmp;
    if (a.point !== b.point)
      a.link(b);
    if (a.isLeft !== b.isLeft)
      return a.isLeft ? 1 : -1;
    return Segment.compare(a.segment, b.segment);
  }
  // for ordering points in sweep line order
  static comparePoints(aPt, bPt) {
    if (aPt.x < bPt.x)
      return -1;
    if (aPt.x > bPt.x)
      return 1;
    if (aPt.y < bPt.y)
      return -1;
    if (aPt.y > bPt.y)
      return 1;
    return 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(point2, isLeft) {
    if (point2.events === void 0)
      point2.events = [this];
    else
      point2.events.push(this);
    this.point = point2;
    this.isLeft = isLeft;
  }
  link(other) {
    if (other.point === this.point) {
      throw new Error("Tried to link already linked events");
    }
    const otherEvents = other.point.events;
    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {
      const evt = otherEvents[i];
      this.point.events.push(evt);
      evt.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const numEvents = this.point.events.length;
    for (let i = 0; i < numEvents; i++) {
      const evt1 = this.point.events[i];
      if (evt1.segment.consumedBy !== void 0)
        continue;
      for (let j = i + 1; j < numEvents; j++) {
        const evt2 = this.point.events[j];
        if (evt2.consumedBy !== void 0)
          continue;
        if (evt1.otherSE.point.events !== evt2.otherSE.point.events)
          continue;
        evt1.segment.consume(evt2.segment);
      }
    }
  }
  getAvailableLinkedEvents() {
    const events = [];
    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {
      const evt = this.point.events[i];
      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
        events.push(evt);
      }
    }
    return events;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(baseEvent) {
    const cache = /* @__PURE__ */ new Map();
    const fillCache = (linkedEvent) => {
      const nextEvent = linkedEvent.otherSE;
      cache.set(linkedEvent, {
        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),
        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)
      });
    };
    return (a, b) => {
      if (!cache.has(a))
        fillCache(a);
      if (!cache.has(b))
        fillCache(b);
      const {
        sine: asine,
        cosine: acosine
      } = cache.get(a);
      const {
        sine: bsine,
        cosine: bcosine
      } = cache.get(b);
      if (asine >= 0 && bsine >= 0) {
        if (acosine < bcosine)
          return 1;
        if (acosine > bcosine)
          return -1;
        return 0;
      }
      if (asine < 0 && bsine < 0) {
        if (acosine < bcosine)
          return -1;
        if (acosine > bcosine)
          return 1;
        return 0;
      }
      if (bsine < asine)
        return -1;
      if (bsine > asine)
        return 1;
      return 0;
    };
  }
};
var segmentId = 0;
var Segment = class _Segment {
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(a, b) {
    const alx = a.leftSE.point.x;
    const blx = b.leftSE.point.x;
    const arx = a.rightSE.point.x;
    const brx = b.rightSE.point.x;
    if (brx < alx)
      return 1;
    if (arx < blx)
      return -1;
    const aly = a.leftSE.point.y;
    const bly = b.leftSE.point.y;
    const ary = a.rightSE.point.y;
    const bry = b.rightSE.point.y;
    if (alx < blx) {
      if (bly < aly && bly < ary)
        return 1;
      if (bly > aly && bly > ary)
        return -1;
      const aCmpBLeft = a.comparePoint(b.leftSE.point);
      if (aCmpBLeft < 0)
        return 1;
      if (aCmpBLeft > 0)
        return -1;
      const bCmpARight = b.comparePoint(a.rightSE.point);
      if (bCmpARight !== 0)
        return bCmpARight;
      return -1;
    }
    if (alx > blx) {
      if (aly < bly && aly < bry)
        return -1;
      if (aly > bly && aly > bry)
        return 1;
      const bCmpALeft = b.comparePoint(a.leftSE.point);
      if (bCmpALeft !== 0)
        return bCmpALeft;
      const aCmpBRight = a.comparePoint(b.rightSE.point);
      if (aCmpBRight < 0)
        return 1;
      if (aCmpBRight > 0)
        return -1;
      return 1;
    }
    if (aly < bly)
      return -1;
    if (aly > bly)
      return 1;
    if (arx < brx) {
      const bCmpARight = b.comparePoint(a.rightSE.point);
      if (bCmpARight !== 0)
        return bCmpARight;
    }
    if (arx > brx) {
      const aCmpBRight = a.comparePoint(b.rightSE.point);
      if (aCmpBRight < 0)
        return 1;
      if (aCmpBRight > 0)
        return -1;
    }
    if (arx !== brx) {
      const ay = ary - aly;
      const ax = arx - alx;
      const by = bry - bly;
      const bx = brx - blx;
      if (ay > ax && by < bx)
        return 1;
      if (ay < ax && by > bx)
        return -1;
    }
    if (arx > brx)
      return 1;
    if (arx < brx)
      return -1;
    if (ary < bry)
      return -1;
    if (ary > bry)
      return 1;
    if (a.id < b.id)
      return -1;
    if (a.id > b.id)
      return 1;
    return 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(leftSE, rightSE, rings, windings) {
    this.id = ++segmentId;
    this.leftSE = leftSE;
    leftSE.segment = this;
    leftSE.otherSE = rightSE;
    this.rightSE = rightSE;
    rightSE.segment = this;
    rightSE.otherSE = leftSE;
    this.rings = rings;
    this.windings = windings;
  }
  static fromRing(pt1, pt2, ring) {
    let leftPt, rightPt, winding;
    const cmpPts = SweepEvent.comparePoints(pt1, pt2);
    if (cmpPts < 0) {
      leftPt = pt1;
      rightPt = pt2;
      winding = 1;
    } else if (cmpPts > 0) {
      leftPt = pt2;
      rightPt = pt1;
      winding = -1;
    } else
      throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);
    const leftSE = new SweepEvent(leftPt, true);
    const rightSE = new SweepEvent(rightPt, false);
    return new _Segment(leftSE, rightSE, [ring], [winding]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(newRightSE) {
    this.rightSE = newRightSE;
    this.rightSE.segment = this;
    this.rightSE.otherSE = this.leftSE;
    this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const y1 = this.leftSE.point.y;
    const y2 = this.rightSE.point.y;
    return {
      ll: {
        x: this.leftSE.point.x,
        y: y1 < y2 ? y1 : y2
      },
      ur: {
        x: this.rightSE.point.x,
        y: y1 > y2 ? y1 : y2
      }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x - this.leftSE.point.x,
      y: this.rightSE.point.y - this.leftSE.point.y
    };
  }
  isAnEndpoint(pt) {
    return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(point2) {
    if (this.isAnEndpoint(point2))
      return 0;
    const lPt = this.leftSE.point;
    const rPt = this.rightSE.point;
    const v2 = this.vector();
    if (lPt.x === rPt.x) {
      if (point2.x === lPt.x)
        return 0;
      return point2.x < lPt.x ? 1 : -1;
    }
    const yDist = (point2.y - lPt.y) / v2.y;
    const xFromYDist = lPt.x + yDist * v2.x;
    if (point2.x === xFromYDist)
      return 0;
    const xDist = (point2.x - lPt.x) / v2.x;
    const yFromXDist = lPt.y + xDist * v2.y;
    if (point2.y === yFromXDist)
      return 0;
    return point2.y < yFromXDist ? -1 : 1;
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(other) {
    const tBbox = this.bbox();
    const oBbox = other.bbox();
    const bboxOverlap = getBboxOverlap(tBbox, oBbox);
    if (bboxOverlap === null)
      return null;
    const tlp = this.leftSE.point;
    const trp = this.rightSE.point;
    const olp = other.leftSE.point;
    const orp = other.rightSE.point;
    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
    if (touchesThisLSE && touchesOtherLSE) {
      if (touchesThisRSE && !touchesOtherRSE)
        return trp;
      if (!touchesThisRSE && touchesOtherRSE)
        return orp;
      return null;
    }
    if (touchesThisLSE) {
      if (touchesOtherRSE) {
        if (tlp.x === orp.x && tlp.y === orp.y)
          return null;
      }
      return tlp;
    }
    if (touchesOtherLSE) {
      if (touchesThisRSE) {
        if (trp.x === olp.x && trp.y === olp.y)
          return null;
      }
      return olp;
    }
    if (touchesThisRSE && touchesOtherRSE)
      return null;
    if (touchesThisRSE)
      return trp;
    if (touchesOtherRSE)
      return orp;
    const pt = intersection$1(tlp, this.vector(), olp, other.vector());
    if (pt === null)
      return null;
    if (!isInBbox(bboxOverlap, pt))
      return null;
    return rounder.round(pt.x, pt.y);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(point2) {
    const newEvents = [];
    const alreadyLinked = point2.events !== void 0;
    const newLeftSE = new SweepEvent(point2, true);
    const newRightSE = new SweepEvent(point2, false);
    const oldRightSE = this.rightSE;
    this.replaceRightSE(newRightSE);
    newEvents.push(newRightSE);
    newEvents.push(newLeftSE);
    const newSeg = new _Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
      newSeg.swapEvents();
    }
    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
      this.swapEvents();
    }
    if (alreadyLinked) {
      newLeftSE.checkForConsuming();
      newRightSE.checkForConsuming();
    }
    return newEvents;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const tmpEvt = this.rightSE;
    this.rightSE = this.leftSE;
    this.leftSE = tmpEvt;
    this.leftSE.isLeft = true;
    this.rightSE.isLeft = false;
    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {
      this.windings[i] *= -1;
    }
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(other) {
    let consumer = this;
    let consumee = other;
    while (consumer.consumedBy)
      consumer = consumer.consumedBy;
    while (consumee.consumedBy)
      consumee = consumee.consumedBy;
    const cmp2 = _Segment.compare(consumer, consumee);
    if (cmp2 === 0)
      return;
    if (cmp2 > 0) {
      const tmp2 = consumer;
      consumer = consumee;
      consumee = tmp2;
    }
    if (consumer.prev === consumee) {
      const tmp2 = consumer;
      consumer = consumee;
      consumee = tmp2;
    }
    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {
      const ring = consumee.rings[i];
      const winding = consumee.windings[i];
      const index3 = consumer.rings.indexOf(ring);
      if (index3 === -1) {
        consumer.rings.push(ring);
        consumer.windings.push(winding);
      } else
        consumer.windings[index3] += winding;
    }
    consumee.rings = null;
    consumee.windings = null;
    consumee.consumedBy = consumer;
    consumee.leftSE.consumedBy = consumer.leftSE;
    consumee.rightSE.consumedBy = consumer.rightSE;
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    if (this._prevInResult !== void 0)
      return this._prevInResult;
    if (!this.prev)
      this._prevInResult = null;
    else if (this.prev.isInResult())
      this._prevInResult = this.prev;
    else
      this._prevInResult = this.prev.prevInResult();
    return this._prevInResult;
  }
  beforeState() {
    if (this._beforeState !== void 0)
      return this._beforeState;
    if (!this.prev)
      this._beforeState = {
        rings: [],
        windings: [],
        multiPolys: []
      };
    else {
      const seg = this.prev.consumedBy || this.prev;
      this._beforeState = seg.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0)
      return this._afterState;
    const beforeState = this.beforeState();
    this._afterState = {
      rings: beforeState.rings.slice(0),
      windings: beforeState.windings.slice(0),
      multiPolys: []
    };
    const ringsAfter = this._afterState.rings;
    const windingsAfter = this._afterState.windings;
    const mpsAfter = this._afterState.multiPolys;
    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {
      const ring = this.rings[i];
      const winding = this.windings[i];
      const index3 = ringsAfter.indexOf(ring);
      if (index3 === -1) {
        ringsAfter.push(ring);
        windingsAfter.push(winding);
      } else
        windingsAfter[index3] += winding;
    }
    const polysAfter = [];
    const polysExclude = [];
    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {
      if (windingsAfter[i] === 0)
        continue;
      const ring = ringsAfter[i];
      const poly = ring.poly;
      if (polysExclude.indexOf(poly) !== -1)
        continue;
      if (ring.isExterior)
        polysAfter.push(poly);
      else {
        if (polysExclude.indexOf(poly) === -1)
          polysExclude.push(poly);
        const index3 = polysAfter.indexOf(ring.poly);
        if (index3 !== -1)
          polysAfter.splice(index3, 1);
      }
    }
    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {
      const mp = polysAfter[i].multiPoly;
      if (mpsAfter.indexOf(mp) === -1)
        mpsAfter.push(mp);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy)
      return false;
    if (this._isInResult !== void 0)
      return this._isInResult;
    const mpsBefore = this.beforeState().multiPolys;
    const mpsAfter = this.afterState().multiPolys;
    switch (operation.type) {
      case "union": {
        const noBefores = mpsBefore.length === 0;
        const noAfters = mpsAfter.length === 0;
        this._isInResult = noBefores !== noAfters;
        break;
      }
      case "intersection": {
        let least2;
        let most;
        if (mpsBefore.length < mpsAfter.length) {
          least2 = mpsBefore.length;
          most = mpsAfter.length;
        } else {
          least2 = mpsAfter.length;
          most = mpsBefore.length;
        }
        this._isInResult = most === operation.numMultiPolys && least2 < most;
        break;
      }
      case "xor": {
        const diff = Math.abs(mpsBefore.length - mpsAfter.length);
        this._isInResult = diff % 2 === 1;
        break;
      }
      case "difference": {
        const isJustSubject = (mps) => mps.length === 1 && mps[0].isSubject;
        this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
        break;
      }
      default:
        throw new Error(`Unrecognized operation type found ${operation.type}`);
    }
    return this._isInResult;
  }
};
var RingIn = class {
  constructor(geomRing, poly, isExterior) {
    if (!Array.isArray(geomRing) || geomRing.length === 0) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.poly = poly;
    this.isExterior = isExterior;
    this.segments = [];
    if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
    this.bbox = {
      ll: {
        x: firstPoint.x,
        y: firstPoint.y
      },
      ur: {
        x: firstPoint.x,
        y: firstPoint.y
      }
    };
    let prevPoint = firstPoint;
    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {
      if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      let point2 = rounder.round(geomRing[i][0], geomRing[i][1]);
      if (point2.x === prevPoint.x && point2.y === prevPoint.y)
        continue;
      this.segments.push(Segment.fromRing(prevPoint, point2, this));
      if (point2.x < this.bbox.ll.x)
        this.bbox.ll.x = point2.x;
      if (point2.y < this.bbox.ll.y)
        this.bbox.ll.y = point2.y;
      if (point2.x > this.bbox.ur.x)
        this.bbox.ur.x = point2.x;
      if (point2.y > this.bbox.ur.y)
        this.bbox.ur.y = point2.y;
      prevPoint = point2;
    }
    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
    }
  }
  getSweepEvents() {
    const sweepEvents = [];
    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {
      const segment = this.segments[i];
      sweepEvents.push(segment.leftSE);
      sweepEvents.push(segment.rightSE);
    }
    return sweepEvents;
  }
};
var PolyIn = class {
  constructor(geomPoly, multiPoly) {
    if (!Array.isArray(geomPoly)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    this.exteriorRing = new RingIn(geomPoly[0], this, true);
    this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    };
    this.interiorRings = [];
    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {
      const ring = new RingIn(geomPoly[i], this, false);
      if (ring.bbox.ll.x < this.bbox.ll.x)
        this.bbox.ll.x = ring.bbox.ll.x;
      if (ring.bbox.ll.y < this.bbox.ll.y)
        this.bbox.ll.y = ring.bbox.ll.y;
      if (ring.bbox.ur.x > this.bbox.ur.x)
        this.bbox.ur.x = ring.bbox.ur.x;
      if (ring.bbox.ur.y > this.bbox.ur.y)
        this.bbox.ur.y = ring.bbox.ur.y;
      this.interiorRings.push(ring);
    }
    this.multiPoly = multiPoly;
  }
  getSweepEvents() {
    const sweepEvents = this.exteriorRing.getSweepEvents();
    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
      const ringSweepEvents = this.interiorRings[i].getSweepEvents();
      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
        sweepEvents.push(ringSweepEvents[j]);
      }
    }
    return sweepEvents;
  }
};
var MultiPolyIn = class {
  constructor(geom, isSubject) {
    if (!Array.isArray(geom)) {
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    }
    try {
      if (typeof geom[0][0][0] === "number")
        geom = [geom];
    } catch (ex) {
    }
    this.polys = [];
    this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (let i = 0, iMax = geom.length; i < iMax; i++) {
      const poly = new PolyIn(geom[i], this);
      if (poly.bbox.ll.x < this.bbox.ll.x)
        this.bbox.ll.x = poly.bbox.ll.x;
      if (poly.bbox.ll.y < this.bbox.ll.y)
        this.bbox.ll.y = poly.bbox.ll.y;
      if (poly.bbox.ur.x > this.bbox.ur.x)
        this.bbox.ur.x = poly.bbox.ur.x;
      if (poly.bbox.ur.y > this.bbox.ur.y)
        this.bbox.ur.y = poly.bbox.ur.y;
      this.polys.push(poly);
    }
    this.isSubject = isSubject;
  }
  getSweepEvents() {
    const sweepEvents = [];
    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
      const polySweepEvents = this.polys[i].getSweepEvents();
      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
        sweepEvents.push(polySweepEvents[j]);
      }
    }
    return sweepEvents;
  }
};
var RingOut = class _RingOut {
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(allSegments) {
    const ringsOut = [];
    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {
      const segment = allSegments[i];
      if (!segment.isInResult() || segment.ringOut)
        continue;
      let prevEvent = null;
      let event = segment.leftSE;
      let nextEvent = segment.rightSE;
      const events = [event];
      const startingPoint = event.point;
      const intersectionLEs = [];
      while (true) {
        prevEvent = event;
        event = nextEvent;
        events.push(event);
        if (event.point === startingPoint)
          break;
        while (true) {
          const availableLEs = event.getAvailableLinkedEvents();
          if (availableLEs.length === 0) {
            const firstPt = events[0].point;
            const lastPt = events[events.length - 1].point;
            throw new Error(`Unable to complete output ring starting at [${firstPt.x}, ${firstPt.y}]. Last matching segment found ends at [${lastPt.x}, ${lastPt.y}].`);
          }
          if (availableLEs.length === 1) {
            nextEvent = availableLEs[0].otherSE;
            break;
          }
          let indexLE = null;
          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
            if (intersectionLEs[j].point === event.point) {
              indexLE = j;
              break;
            }
          }
          if (indexLE !== null) {
            const intersectionLE = intersectionLEs.splice(indexLE)[0];
            const ringEvents = events.splice(intersectionLE.index);
            ringEvents.unshift(ringEvents[0].otherSE);
            ringsOut.push(new _RingOut(ringEvents.reverse()));
            continue;
          }
          intersectionLEs.push({
            index: events.length,
            point: event.point
          });
          const comparator = event.getLeftmostComparator(prevEvent);
          nextEvent = availableLEs.sort(comparator)[0].otherSE;
          break;
        }
      }
      ringsOut.push(new _RingOut(events));
    }
    return ringsOut;
  }
  constructor(events) {
    this.events = events;
    for (let i = 0, iMax = events.length; i < iMax; i++) {
      events[i].segment.ringOut = this;
    }
    this.poly = null;
  }
  getGeom() {
    let prevPt = this.events[0].point;
    const points = [prevPt];
    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {
      const pt2 = this.events[i].point;
      const nextPt2 = this.events[i + 1].point;
      if (compareVectorAngles(pt2, prevPt, nextPt2) === 0)
        continue;
      points.push(pt2);
      prevPt = pt2;
    }
    if (points.length === 1)
      return null;
    const pt = points[0];
    const nextPt = points[1];
    if (compareVectorAngles(pt, prevPt, nextPt) === 0)
      points.shift();
    points.push(points[0]);
    const step = this.isExteriorRing() ? 1 : -1;
    const iStart = this.isExteriorRing() ? 0 : points.length - 1;
    const iEnd = this.isExteriorRing() ? points.length : -1;
    const orderedPoints = [];
    for (let i = iStart; i != iEnd; i += step)
      orderedPoints.push([points[i].x, points[i].y]);
    return orderedPoints;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const enclosing = this.enclosingRing();
      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    if (this._enclosingRing === void 0) {
      this._enclosingRing = this._calcEnclosingRing();
    }
    return this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let leftMostEvt = this.events[0];
    for (let i = 1, iMax = this.events.length; i < iMax; i++) {
      const evt = this.events[i];
      if (SweepEvent.compare(leftMostEvt, evt) > 0)
        leftMostEvt = evt;
    }
    let prevSeg = leftMostEvt.segment.prevInResult();
    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
    while (true) {
      if (!prevSeg)
        return null;
      if (!prevPrevSeg)
        return prevSeg.ringOut;
      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
          return prevSeg.ringOut;
        } else
          return prevSeg.ringOut.enclosingRing();
      }
      prevSeg = prevPrevSeg.prevInResult();
      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
    }
  }
};
var PolyOut = class {
  constructor(exteriorRing) {
    this.exteriorRing = exteriorRing;
    exteriorRing.poly = this;
    this.interiorRings = [];
  }
  addInterior(ring) {
    this.interiorRings.push(ring);
    ring.poly = this;
  }
  getGeom() {
    const geom = [this.exteriorRing.getGeom()];
    if (geom[0] === null)
      return null;
    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
      const ringGeom = this.interiorRings[i].getGeom();
      if (ringGeom === null)
        continue;
      geom.push(ringGeom);
    }
    return geom;
  }
};
var MultiPolyOut = class {
  constructor(rings) {
    this.rings = rings;
    this.polys = this._composePolys(rings);
  }
  getGeom() {
    const geom = [];
    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
      const polyGeom = this.polys[i].getGeom();
      if (polyGeom === null)
        continue;
      geom.push(polyGeom);
    }
    return geom;
  }
  _composePolys(rings) {
    const polys = [];
    for (let i = 0, iMax = rings.length; i < iMax; i++) {
      const ring = rings[i];
      if (ring.poly)
        continue;
      if (ring.isExteriorRing())
        polys.push(new PolyOut(ring));
      else {
        const enclosingRing = ring.enclosingRing();
        if (!enclosingRing.poly)
          polys.push(new PolyOut(enclosingRing));
        enclosingRing.poly.addInterior(ring);
      }
    }
    return polys;
  }
};
var SweepLine = class {
  constructor(queue) {
    let comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment.compare;
    this.queue = queue;
    this.tree = new splay_esm_default(comparator);
    this.segments = [];
  }
  process(event) {
    const segment = event.segment;
    const newEvents = [];
    if (event.consumedBy) {
      if (event.isLeft)
        this.queue.remove(event.otherSE);
      else
        this.tree.remove(segment);
      return newEvents;
    }
    const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);
    if (!node)
      throw new Error(`Unable to find segment #${segment.id} [${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> [${segment.rightSE.point.x}, ${segment.rightSE.point.y}] in SweepLine tree.`);
    let prevNode = node;
    let nextNode = node;
    let prevSeg = void 0;
    let nextSeg = void 0;
    while (prevSeg === void 0) {
      prevNode = this.tree.prev(prevNode);
      if (prevNode === null)
        prevSeg = null;
      else if (prevNode.key.consumedBy === void 0)
        prevSeg = prevNode.key;
    }
    while (nextSeg === void 0) {
      nextNode = this.tree.next(nextNode);
      if (nextNode === null)
        nextSeg = null;
      else if (nextNode.key.consumedBy === void 0)
        nextSeg = nextNode.key;
    }
    if (event.isLeft) {
      let prevMySplitter = null;
      if (prevSeg) {
        const prevInter = prevSeg.getIntersection(segment);
        if (prevInter !== null) {
          if (!segment.isAnEndpoint(prevInter))
            prevMySplitter = prevInter;
          if (!prevSeg.isAnEndpoint(prevInter)) {
            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      let nextMySplitter = null;
      if (nextSeg) {
        const nextInter = nextSeg.getIntersection(segment);
        if (nextInter !== null) {
          if (!segment.isAnEndpoint(nextInter))
            nextMySplitter = nextInter;
          if (!nextSeg.isAnEndpoint(nextInter)) {
            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      if (prevMySplitter !== null || nextMySplitter !== null) {
        let mySplitter = null;
        if (prevMySplitter === null)
          mySplitter = nextMySplitter;
        else if (nextMySplitter === null)
          mySplitter = prevMySplitter;
        else {
          const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
        }
        this.queue.remove(segment.rightSE);
        newEvents.push(segment.rightSE);
        const newEventsFromSplit = segment.split(mySplitter);
        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
          newEvents.push(newEventsFromSplit[i]);
        }
      }
      if (newEvents.length > 0) {
        this.tree.remove(segment);
        newEvents.push(event);
      } else {
        this.segments.push(segment);
        segment.prev = prevSeg;
      }
    } else {
      if (prevSeg && nextSeg) {
        const inter = prevSeg.getIntersection(nextSeg);
        if (inter !== null) {
          if (!prevSeg.isAnEndpoint(inter)) {
            const newEventsFromSplit = this._splitSafely(prevSeg, inter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
          if (!nextSeg.isAnEndpoint(inter)) {
            const newEventsFromSplit = this._splitSafely(nextSeg, inter);
            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
              newEvents.push(newEventsFromSplit[i]);
            }
          }
        }
      }
      this.tree.remove(segment);
    }
    return newEvents;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(seg, pt) {
    this.tree.remove(seg);
    const rightSE = seg.rightSE;
    this.queue.remove(rightSE);
    const newEvents = seg.split(pt);
    newEvents.push(rightSE);
    if (seg.consumedBy === void 0)
      this.tree.add(seg);
    return newEvents;
  }
};
var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
var Operation = class {
  run(type, geom, moreGeoms) {
    operation.type = type;
    rounder.reset();
    const multipolys = [new MultiPolyIn(geom, true)];
    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {
      multipolys.push(new MultiPolyIn(moreGeoms[i], false));
    }
    operation.numMultiPolys = multipolys.length;
    if (operation.type === "difference") {
      const subject = multipolys[0];
      let i = 1;
      while (i < multipolys.length) {
        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null)
          i++;
        else
          multipolys.splice(i, 1);
      }
    }
    if (operation.type === "intersection") {
      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
        const mpA = multipolys[i];
        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {
          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null)
            return [];
        }
      }
    }
    const queue = new splay_esm_default(SweepEvent.compare);
    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
      const sweepEvents = multipolys[i].getSweepEvents();
      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {
        queue.insert(sweepEvents[j]);
        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
          throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
        }
      }
    }
    const sweepLine = new SweepLine(queue);
    let prevQueueSize = queue.size;
    let node = queue.pop();
    while (node) {
      const evt = node.key;
      if (queue.size === prevQueueSize) {
        const seg = evt.segment;
        throw new Error(`Unable to pop() ${evt.isLeft ? "left" : "right"} SweepEvent [${evt.point.x}, ${evt.point.y}] from segment #${seg.id} [${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> [${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);
      }
      if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
        throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
      }
      if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
        throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
      }
      const newEvents = sweepLine.process(evt);
      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {
        const evt2 = newEvents[i];
        if (evt2.consumedBy === void 0)
          queue.insert(evt2);
      }
      prevQueueSize = queue.size;
      node = queue.pop();
    }
    rounder.reset();
    const ringsOut = RingOut.factory(sweepLine.segments);
    const result = new MultiPolyOut(ringsOut);
    return result.getGeom();
  }
};
var operation = new Operation();
var union2 = function(geom) {
  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    moreGeoms[_key - 1] = arguments[_key];
  }
  return operation.run("union", geom, moreGeoms);
};
var intersection2 = function(geom) {
  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    moreGeoms[_key2 - 1] = arguments[_key2];
  }
  return operation.run("intersection", geom, moreGeoms);
};
var xor = function(geom) {
  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    moreGeoms[_key3 - 1] = arguments[_key3];
  }
  return operation.run("xor", geom, moreGeoms);
};
var difference2 = function(subjectGeom) {
  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    clippingGeoms[_key4 - 1] = arguments[_key4];
  }
  return operation.run("difference", subjectGeom, clippingGeoms);
};
var index2 = {
  union: union2,
  intersection: intersection2,
  xor,
  difference: difference2
};

// node_modules/@turf/union/dist/es/index.js
function union3(poly1, poly2, options) {
  if (options === void 0) {
    options = {};
  }
  var geom1 = getGeom(poly1);
  var geom2 = getGeom(poly2);
  var unioned = index2.union(geom1.coordinates, geom2.coordinates);
  if (unioned.length === 0)
    return null;
  if (unioned.length === 1)
    return polygon(unioned[0], options.properties);
  else
    return multiPolygon(unioned, options.properties);
}
var es_default = union3;

// node_modules/@antv/l7-layers/es/tile/service/TileSourceService.js
var TileSourceService = class {
  getCombineFeature(features) {
    let p = null;
    const properties = features[0];
    features.map((feature) => {
      const polygon2 = polygon(feature.coordinates);
      if (p === null) {
        p = polygon2;
      } else {
        p = es_default(p, polygon2);
      }
    });
    if (properties) {
      p.properties = _objectSpread2({}, properties);
    }
    return p;
  }
};

// node_modules/@antv/l7-layers/es/tile/service/TilePickService.js
var SELECT = "select";
var ACTIVE = "active";
var TilePickService = class {
  constructor({
    layerService,
    tileLayerService,
    parent
  }) {
    _defineProperty(this, "layerService", void 0);
    _defineProperty(this, "tileLayerService", void 0);
    _defineProperty(this, "tileSourceService", void 0);
    _defineProperty(this, "parent", void 0);
    _defineProperty(this, "tilePickID", /* @__PURE__ */ new Map());
    this.layerService = layerService;
    this.tileLayerService = tileLayerService;
    this.parent = parent;
    this.tileSourceService = new TileSourceService();
  }
  pickRender(target) {
    const tile = this.tileLayerService.getVisibleTileBylngLat(target.lngLat);
    if (tile) {
      const pickLayer = tile.getMainLayer();
      pickLayer === null || pickLayer === void 0 || pickLayer.layerPickService.pickRender(target);
    }
  }
  pick(layer, target) {
    var _this = this;
    return _asyncToGenerator(function* () {
      const container = _this.parent.getContainer();
      const pickingService = container.pickingService;
      if (layer.type === "RasterLayer") {
        const tile = _this.tileLayerService.getVisibleTileBylngLat(target.lngLat);
        if (tile && tile.getMainLayer() !== void 0) {
          const pickLayer = tile.getMainLayer();
          return pickLayer.layerPickService.pickRasterLayer(pickLayer, target, _this.parent);
        }
        return false;
      }
      _this.pickRender(target);
      return pickingService.pickFromPickingFBO(layer, target);
    })();
  }
  selectFeature(pickedColors) {
    const [r, g, b] = pickedColors;
    const id = this.color2PickId(r, g, b);
    this.tilePickID.set(SELECT, id);
    this.updateHighLight(r, g, b, SELECT);
  }
  highlightPickedFeature(pickedColors) {
    const [r, g, b] = pickedColors;
    const id = this.color2PickId(r, g, b);
    this.tilePickID.set(ACTIVE, id);
    this.updateHighLight(r, g, b, ACTIVE);
  }
  updateHighLight(r, g, b, type) {
    this.tileLayerService.tiles.map((tile) => {
      const layer = tile.getMainLayer();
      switch (type) {
        case SELECT:
          layer === null || layer === void 0 || layer.hooks.beforeSelect.call([r, g, b]);
          break;
        case ACTIVE:
          layer === null || layer === void 0 || layer.hooks.beforeHighlight.call([r, g, b]);
          break;
      }
    });
  }
  setPickState() {
    const selectColor = this.tilePickID.get(SELECT);
    const activeColor = this.tilePickID.get(ACTIVE);
    if (selectColor) {
      const [r, g, b] = this.pickId2Color(selectColor);
      this.updateHighLight(r, g, b, SELECT);
      return;
    }
    if (activeColor) {
      const [r, g, b] = this.pickId2Color(activeColor);
      this.updateHighLight(r, g, b, ACTIVE);
      return;
    }
  }
  color2PickId(r, g, b) {
    return decodePickingColor(new Uint8Array([r, g, b]));
  }
  pickId2Color(str) {
    return encodePickingColor(str);
  }
  /** 从瓦片中根据数据 */
  getFeatureById(pickedFeatureIdx) {
    const tiles = this.tileLayerService.getTiles().filter((tile) => tile.visible);
    const features = [];
    tiles.forEach((tile) => {
      features.push(...tile.getFeatureById(pickedFeatureIdx));
    });
    return features;
  }
  // Tip: for interface define
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  pickRasterLayer() {
    return false;
  }
};

// node_modules/@antv/l7-layers/es/tile/tile/Tile.js
var import_eventemitter37 = __toESM(require_eventemitter3());

// node_modules/@antv/l7-layers/es/tile/tile/util.js
function getTileLayer(type) {
  if (type === "PolygonLayer") {
    return PolygonLayer;
  }
  if (type === "LineLayer") {
    return LineLayer;
  }
  if (type === "PointLayer") {
    return PointLayer;
  }
  return PointLayer;
}
function isNeedMask(type) {
  return ["PolygonLayer", "LineLayer"].indexOf(type) !== -1;
}

// node_modules/@antv/l7-layers/es/tile/tile/Tile.js
var Tile = class extends import_eventemitter37.EventEmitter {
  constructor(sourceTile, parent) {
    super();
    _defineProperty(this, "x", void 0);
    _defineProperty(this, "y", void 0);
    _defineProperty(this, "z", void 0);
    _defineProperty(this, "key", void 0);
    _defineProperty(this, "parent", void 0);
    _defineProperty(this, "sourceTile", void 0);
    _defineProperty(this, "visible", true);
    _defineProperty(this, "layers", []);
    _defineProperty(this, "isLoaded", false);
    _defineProperty(this, "tileMaskLayers", []);
    _defineProperty(this, "tileMask", void 0);
    this.parent = parent;
    this.sourceTile = sourceTile;
    this.x = sourceTile.x;
    this.y = sourceTile.y;
    this.z = sourceTile.z;
    this.key = `${this.x}_${this.y}_${this.z}`;
  }
  getLayers() {
    return this.layers;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  styleUpdate(...arg) {
    return;
  }
  lnglatInBounds(lnglat) {
    const [minLng, minLat, maxLng, maxLat] = this.sourceTile.bounds;
    const {
      lng,
      lat
    } = lnglat;
    return lng >= minLng && lng <= maxLng && lat >= minLat && lat <= maxLat;
  }
  getLayerOptions() {
    var _options$maskLayers;
    const options = this.parent.getLayerConfig();
    return _objectSpread2(_objectSpread2({}, options), {}, {
      textAllowOverlap: true,
      // 文本允许重叠
      autoFit: false,
      maskLayers: this.getMaskLayer(),
      tileMask: isNeedMask(this.parent.type),
      mask: options.mask || ((_options$maskLayers = options.maskLayers) === null || _options$maskLayers === void 0 ? void 0 : _options$maskLayers.length) !== 0 && options.enableMask
    });
  }
  // 获取Mask 图层
  getMaskLayer() {
    const {
      maskLayers
    } = this.parent.getLayerConfig();
    const layers = [];
    maskLayers === null || maskLayers === void 0 || maskLayers.forEach((layer) => {
      if (!layer.tileLayer) {
        layers.push(layer);
        return layer;
      }
      const tileLayer = layer.tileLayer;
      const tile = tileLayer.getTile(this.sourceTile.key);
      const l = tile === null || tile === void 0 ? void 0 : tile.getLayers()[0];
      if (l) {
        layers.push(l);
      }
    });
    return layers;
  }
  addTileMask() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const mask = new PolygonLayer({
        name: "mask",
        visible: true,
        enablePicking: false
      }).source({
        type: "FeatureCollection",
        features: [_this.sourceTile.bboxPolygon]
      }, {
        parser: {
          type: "geojson",
          featureId: "id"
        }
      }).shape("fill").color("#0f0").style({
        opacity: 0.5
      });
      const container = createLayerContainer(_this.parent.container);
      mask.setContainer(container);
      yield mask.init();
      _this.tileMask = mask;
      const mainLayer = _this.getMainLayer();
      if (mainLayer !== void 0) {
        mainLayer.tileMask = mask;
      }
      return mask;
    })();
  }
  // 全局 Mask
  addMask(layer, mask) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const container = createLayerContainer(_this2.parent.container);
      mask.setContainer(container);
      yield mask.init();
      layer.addMask(mask);
      _this2.tileMaskLayers.push(mask);
    })();
  }
  addLayer(layer) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      layer.isTileLayer = true;
      const container = createLayerContainer(_this3.parent.container);
      layer.setContainer(container);
      _this3.layers.push(layer);
      yield layer.init();
    })();
  }
  updateVisible(value) {
    this.visible = value;
    this.updateOptions("visible", value);
  }
  updateOptions(key, value) {
    this.layers.forEach((l) => {
      l.updateLayerConfig({
        [key]: value
      });
    });
  }
  /**
   * 一个 Tile 可能有多个 layer，但是在发生拾取、点击事件的时候只有一个生效
   */
  getMainLayer() {
    return this.layers[0];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getFeatures(sourceLayer) {
    return [];
  }
  /**
   * 在一个 Tile 中可能存在一个相同 ID 的 feature
   * @param id
   * @returns
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getFeatureById(id) {
    return [];
  }
  destroy() {
    var _this$tileMask;
    (_this$tileMask = this.tileMask) === null || _this$tileMask === void 0 || _this$tileMask.destroy();
    this.layers.forEach((layer) => layer.destroy());
  }
};

// node_modules/@antv/l7-layers/es/tile/tile/DebugTile.js
var DebugTile = class extends Tile {
  initTileLayer() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const sourceOptions = _this.getSourceOption();
      const pointData = sourceOptions.data.features[0].properties;
      const lineLayer = new LineLayer().source(sourceOptions.data, sourceOptions.options).size(1).shape("line").color("red");
      const pointLayer = new PointLayer({
        minZoom: _this.z - 1,
        maxZoom: _this.z + 1,
        textAllowOverlap: true
      }).source([pointData], {
        parser: {
          type: "json",
          x: "x",
          y: "y"
        }
      }).size(20).color("red").shape(_this.key).style({
        stroke: "#fff",
        strokeWidth: 2
      });
      yield _this.addLayer(lineLayer);
      yield _this.addLayer(pointLayer);
      _this.isLoaded = true;
    })();
  }
  getSourceOption() {
    const rawSource = this.parent.getSource();
    const features = this.sourceTile.data.layers.testTile.features;
    return {
      data: {
        type: "FeatureCollection",
        features
      },
      options: {
        parser: {
          type: "geojson"
        },
        transforms: rawSource.transforms
      }
    };
  }
};

// node_modules/@antv/l7-layers/es/tile/tile/ImageTile.js
var ImageTile = class extends Tile {
  initTileLayer() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const attributes = _this.parent.getLayerAttributeConfig();
      const layerOptions = _this.getLayerOptions();
      const sourceOptions = _this.getSourceOption();
      const layer = new ImageLayer(_objectSpread2({}, layerOptions)).source(sourceOptions.data, sourceOptions.options);
      attributes && Object.keys(attributes).forEach((type) => {
        var _attributes$attr, _attributes$attr2;
        const attr = type;
        layer[attr]((_attributes$attr = attributes[attr]) === null || _attributes$attr === void 0 ? void 0 : _attributes$attr.field, (_attributes$attr2 = attributes[attr]) === null || _attributes$attr2 === void 0 ? void 0 : _attributes$attr2.values);
      });
      yield _this.addLayer(layer);
      _this.isLoaded = true;
    })();
  }
  getSourceOption() {
    const rawSource = this.parent.getSource();
    return {
      data: this.sourceTile.data,
      options: {
        parser: {
          type: "image",
          extent: this.sourceTile.bounds
        },
        transforms: rawSource.transforms
      }
    };
  }
};

// node_modules/@antv/l7-layers/es/mask/models/fill.js
var mask_frag = "layout(std140) uniform commonUniorm {\n  vec4 u_color;\n  float u_opacity;\n};\n\nout vec4 outputColor;\n\nvoid main() {\n  outputColor = u_color;\n  outputColor.a *= u_opacity;\n}\n";
var mask_vert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\n\nlayout(std140) uniform commonUniorm {\n  vec4 u_color;\n  float u_opacity;\n};\n\n#pragma include "projection"\n\nvoid main() {\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n}\n\n';
var MaskModel = class extends BaseModel {
  getUninforms() {
    const commoninfo = this.getCommonUniformsInfo();
    const attributeInfo = this.getUniformsBufferInfo(this.getStyleAttribute());
    this.updateStyleUnifoms();
    return _objectSpread2(_objectSpread2({}, commoninfo.uniformsOption), attributeInfo.uniformsOption);
  }
  getCommonUniformsInfo() {
    const {
      opacity = 1,
      color: color2 = "#000"
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_color: rgb2arr(color2),
      u_opacity: opacity || 1
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      return _this.buildModels();
    })();
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.initUniformsBuffer();
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "mask",
        vertexShader: mask_vert,
        fragmentShader: mask_frag,
        defines: _this2.getDefines(),
        triangulation: polygonTriangulation,
        depth: {
          enable: false
        },
        pick: false
      });
      return [model];
    })();
  }
  clearModels(refresh = true) {
    if (refresh) {
      this.layerService.clear();
    }
  }
  registerBuiltinAttributes() {
    return "";
  }
};

// node_modules/@antv/l7-layers/es/mask/models/index.js
var MaskModels = {
  fill: MaskModel
};
var models_default8 = MaskModels;

// node_modules/@antv/l7-layers/es/mask/index.js
var MaskLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "MaskLayer");
  }
  buildModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const shape = _this.getModelType();
      _this.layerModel = new models_default8[shape](_this);
      yield _this.initLayerModels();
    })();
  }
  getModelType() {
    return "fill";
  }
};

// node_modules/@antv/l7-layers/es/tile/tile/MaskTile.js
var MaskTile = class extends Tile {
  initTileLayer() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const attributes = _this.parent.getLayerAttributeConfig();
      const layerOptions = _this.getLayerOptions();
      const sourceOptions = _this.getSourceOption();
      const layer = new MaskLayer(_objectSpread2({}, layerOptions)).source(sourceOptions.data, sourceOptions.options);
      attributes && Object.keys(attributes).forEach((type) => {
        var _attributes$attr, _attributes$attr2;
        const attr = type;
        layer[attr]((_attributes$attr = attributes[attr]) === null || _attributes$attr === void 0 ? void 0 : _attributes$attr.field, (_attributes$attr2 = attributes[attr]) === null || _attributes$attr2 === void 0 ? void 0 : _attributes$attr2.values);
      });
      yield _this.addLayer(layer);
      _this.isLoaded = true;
    })();
  }
  getFeatures(sourceLayer) {
    if (!sourceLayer) {
      return [];
    }
    const source = this.sourceTile.data;
    return source.getTileData(sourceLayer);
  }
  getSourceOption() {
    const rawSource = this.parent.getSource();
    const {
      sourceLayer,
      featureId
    } = this.parent.getLayerConfig();
    const features = this.getFeatures(sourceLayer);
    return {
      data: {
        type: "FeatureCollection",
        features
      },
      options: {
        parser: {
          type: "geojson",
          featureId
        },
        transforms: rawSource.transforms
      }
    };
  }
};

// node_modules/@antv/l7-layers/es/tile/tile/RasterRGBTile.js
var _excluded4 = ["rasterData"];
var RasterTile = class extends Tile {
  initTileLayer() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const attributes = _this.parent.getLayerAttributeConfig();
      const layerOptions = _this.getLayerOptions();
      const sourceOptions = _this.getSourceOption();
      const layer = new RasterLayer(_objectSpread2({}, layerOptions)).source(sourceOptions.data, sourceOptions.options);
      attributes && Object.keys(attributes).forEach((type) => {
        var _attributes$attr, _attributes$attr2;
        const attr = type;
        layer[attr]((_attributes$attr = attributes[attr]) === null || _attributes$attr === void 0 ? void 0 : _attributes$attr.field, (_attributes$attr2 = attributes[attr]) === null || _attributes$attr2 === void 0 ? void 0 : _attributes$attr2.values);
      });
      yield _this.addLayer(layer);
      _this.isLoaded = true;
    })();
  }
  getSourceOption() {
    const rawSource = this.parent.getSource();
    const _this$sourceTile$data = this.sourceTile.data.data, {
      rasterData
    } = _this$sourceTile$data, res = _objectWithoutProperties(_this$sourceTile$data, _excluded4);
    return {
      data: rasterData,
      // 栅格数
      options: {
        parser: _objectSpread2({
          type: "rasterRgb",
          extent: this.sourceTile.bounds
        }, res),
        transforms: rawSource.transforms
      }
    };
  }
};

// node_modules/@antv/l7-layers/es/tile/tile/RasterTerrainRGBTile.js
var RasterTerrainRGBTile = class extends Tile {
  initTileLayer() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const attributes = _this.parent.getLayerAttributeConfig();
      const layerOptions = _this.getLayerOptions();
      const sourceOptions = _this.getSourceOption();
      const layer = new RasterLayer(_objectSpread2({}, layerOptions)).source(sourceOptions.data, sourceOptions.options);
      attributes && Object.keys(attributes).forEach((type) => {
        var _attributes$attr, _attributes$attr2;
        const attr = type;
        layer[attr]((_attributes$attr = attributes[attr]) === null || _attributes$attr === void 0 ? void 0 : _attributes$attr.field, (_attributes$attr2 = attributes[attr]) === null || _attributes$attr2 === void 0 ? void 0 : _attributes$attr2.values);
      });
      yield _this.addLayer(layer);
      _this.isLoaded = true;
    })();
  }
  getSourceOption() {
    const rawSource = this.parent.getSource();
    return {
      data: this.sourceTile.data,
      options: {
        parser: {
          type: "image",
          extent: this.sourceTile.bounds
        },
        transforms: rawSource.transforms
      }
    };
  }
};

// node_modules/@antv/l7-layers/es/tile/tile/RasterTile.js
var _excluded5 = ["rasterData"];
var DEFAULT_COLOR_TEXTURE_OPTION = {
  positions: [0, 1],
  colors: ["#000", "#fff"]
};
var RasterTile2 = class extends Tile {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "colorTexture", void 0);
  }
  initTileLayer() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const attributes = _this.parent.getLayerAttributeConfig();
      const layerOptions = _this.getLayerOptions();
      const sourceOptions = _this.getSourceOption();
      const {
        rampColors,
        domain
      } = _this.getLayerOptions();
      _this.colorTexture = _this.parent.textureService.getColorTexture(rampColors, domain);
      const layer = new RasterLayer(_objectSpread2(_objectSpread2({}, layerOptions), {}, {
        colorTexture: _this.colorTexture
      })).source(sourceOptions.data, sourceOptions.options);
      attributes && Object.keys(attributes).forEach((type) => {
        var _attributes$attr, _attributes$attr2;
        const attr = type;
        layer[attr]((_attributes$attr = attributes[attr]) === null || _attributes$attr === void 0 ? void 0 : _attributes$attr.field, (_attributes$attr2 = attributes[attr]) === null || _attributes$attr2 === void 0 ? void 0 : _attributes$attr2.values);
      });
      yield _this.addLayer(layer);
      _this.isLoaded = true;
    })();
  }
  getSourceOption() {
    const rawSource = this.parent.getSource();
    const _this$sourceTile$data = this.sourceTile.data.data, {
      rasterData
    } = _this$sourceTile$data, res = _objectWithoutProperties(_this$sourceTile$data, _excluded5);
    return {
      data: rasterData,
      options: {
        parser: _objectSpread2({
          type: "raster",
          extent: this.sourceTile.bounds
        }, res),
        transforms: rawSource.transforms
      }
    };
  }
  /**
   * 用于 style 更新 colorTexture 的优化
   * @param arg
   */
  styleUpdate(...arg) {
    const {
      rampColors = DEFAULT_COLOR_TEXTURE_OPTION,
      domain
    } = arg;
    this.colorTexture = this.parent.textureService.getColorTexture(rampColors, domain || getDefaultDomain(rampColors));
    this.layers.forEach((layer) => layer.style({
      colorTexture: this.colorTexture
    }));
  }
  destroy() {
    this.layers.forEach((layer) => layer.destroy());
  }
};

// node_modules/@antv/l7-layers/es/tile/tile/VectorTile.js
var VectorTile2 = class extends Tile {
  initTileLayer() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const attributes = _this.parent.getLayerAttributeConfig();
      const layerOptions = _this.getLayerOptions();
      const vectorLayer = getTileLayer(_this.parent.type);
      const sourceOptions = _this.getSourceOption();
      if (!sourceOptions) {
        _this.isLoaded = true;
        _this.emit("loaded");
        return;
      }
      const layer = new vectorLayer(_objectSpread2({}, layerOptions)).source(sourceOptions.data, sourceOptions.options);
      Object.keys(attributes).forEach((type) => {
        var _attributes$attr, _attributes$attr2;
        const attr = type;
        layer[attr]((_attributes$attr = attributes[attr]) === null || _attributes$attr === void 0 ? void 0 : _attributes$attr.field, (_attributes$attr2 = attributes[attr]) === null || _attributes$attr2 === void 0 ? void 0 : _attributes$attr2.values);
      });
      yield _this.addLayer(layer);
      if (layerOptions.tileMask) {
        yield _this.addTileMask();
      }
      _this.setLayerMinMaxZoom(layer);
      _this.isLoaded = true;
      _this.emit("loaded");
    })();
  }
  getSourceOption() {
    const rawSource = this.parent.getSource();
    const {
      sourceLayer = "defaultLayer",
      featureId = "id"
    } = this.parent.getLayerConfig();
    const features = this.getFeatures(sourceLayer);
    return {
      data: {
        type: "FeatureCollection",
        features
      },
      options: {
        parser: {
          type: "geojson",
          featureId
        },
        transforms: rawSource.transforms
      }
    };
  }
  setLayerMinMaxZoom(layer) {
    if (layer.getModelType() === "text") {
      layer.updateLayerConfig({
        maxZoom: this.z + 1,
        minZoom: this.z - 1
      });
    }
  }
  // 获取瓦片数据
  getFeatures(sourceLayer) {
    const source = this.sourceTile.data;
    return source.getTileData(sourceLayer);
  }
  /**
   * 在一个 Tile 中可能存在一个相同 ID 的 feature
   * @param id
   * @returns
   */
  getFeatureById(id) {
    const layer = this.getMainLayer();
    if (!layer) {
      return [];
    }
    const res = layer.getSource().data.dataArray.filter((d) => d._id === id);
    return res;
  }
};

// node_modules/@antv/l7-layers/es/tile/tile/index.js
function getTileFactory(layer) {
  const tileType = layer.type;
  switch (tileType) {
    case "PolygonLayer":
      return VectorTile2;
    case "LineLayer":
      return VectorTile2;
    case "PointLayer":
      return VectorTile2;
    case "TileDebugLayer":
      return DebugTile;
    case "MaskLayer":
      return MaskTile;
    case "RasterLayer":
      const {
        dataType
      } = layer.getSource().parser;
      switch (dataType) {
        case RasterTileType.RGB:
        case RasterTileType.CUSTOMRGB:
          return RasterTile;
        case RasterTileType.ARRAYBUFFER:
        case RasterTileType.CUSTOMARRAYBUFFER:
          return RasterTile2;
        case RasterTileType.TERRAINRGB:
        case RasterTileType.CUSTOMTERRAINRGB:
          return RasterTerrainRGBTile;
        default:
          return ImageTile;
      }
    default:
      return VectorTile2;
  }
}

// node_modules/@antv/l7-layers/es/tile/utils/constants.js
var ProxyFuncs = [
  /**
   * 1. 需要作用到所属子图层才会生效的方法
   * 2. 不需要主动重新创建 model 的方法
   */
  "shape",
  "color",
  "size",
  "style",
  "animate",
  "filter",
  "rotate",
  "scale",
  "setBlend",
  "setSelect",
  "setActive",
  "disableMask",
  "enableMask",
  "addMask",
  "removeMask"
];

// node_modules/@antv/l7-layers/es/tile/core/BaseLayer.js
var {
  debounce
} = lodashUtil;
var BaseTileLayer = class {
  constructor(parent) {
    _defineProperty(this, "parent", void 0);
    _defineProperty(this, "tileLayerService", void 0);
    _defineProperty(this, "mapService", void 0);
    _defineProperty(this, "layerService", void 0);
    _defineProperty(this, "rendererService", void 0);
    _defineProperty(this, "pickingService", void 0);
    _defineProperty(this, "tilePickService", void 0);
    _defineProperty(this, "tilesetManager", void 0);
    _defineProperty(this, "initedTileset", false);
    _defineProperty(this, "lastViewStates", void 0);
    _defineProperty(this, "mapchange", () => {
      var _this$tilesetManager;
      if (this.parent.isVisible() === false) {
        return;
      }
      const {
        latLonBounds,
        zoom
      } = this.getCurrentView();
      if (this.lastViewStates && this.lastViewStates.zoom === zoom && this.lastViewStates.latLonBounds.toString() === latLonBounds.toString()) {
        return;
      }
      this.lastViewStates = {
        zoom,
        latLonBounds
      };
      (_this$tilesetManager = this.tilesetManager) === null || _this$tilesetManager === void 0 || _this$tilesetManager.throttleUpdate(zoom, latLonBounds);
    });
    _defineProperty(this, "viewchange", debounce(this.mapchange, 24));
    this.parent = parent;
    const container = this.parent.getContainer();
    this.rendererService = container.rendererService;
    this.layerService = container.layerService;
    this.mapService = container.mapService;
    this.pickingService = container.pickingService;
    this.tileLayerService = new TileLayerService({
      rendererService: this.rendererService,
      layerService: this.layerService,
      parent
    });
    this.tilePickService = new TilePickService({
      tileLayerService: this.tileLayerService,
      layerService: this.layerService,
      parent
    });
    this.parent.setLayerPickService(this.tilePickService);
    this.proxy(parent);
    this.initTileSetManager();
  }
  initTileSetManager() {
    var _this$tilesetManager2;
    const source = this.parent.getSource();
    this.tilesetManager = source.tileset;
    if (!this.initedTileset) {
      this.bindTilesetEvent();
      this.initedTileset = true;
    }
    if (this.parent.isVisible() === false) {
      return;
    }
    const {
      latLonBounds,
      zoom
    } = this.getCurrentView();
    (_this$tilesetManager2 = this.tilesetManager) === null || _this$tilesetManager2 === void 0 || _this$tilesetManager2.update(zoom, latLonBounds);
  }
  getCurrentView() {
    const bounds = this.mapService.getBounds();
    const latLonBounds = [bounds[0][0], bounds[0][1], bounds[1][0], bounds[1][1]];
    const zoom = this.mapService.getZoom();
    return {
      latLonBounds,
      zoom
    };
  }
  bindTilesetEvent() {
    this.tilesetManager.on("tile-loaded", (tile) => {
    });
    this.tilesetManager.on("tile-unload", (tile) => {
      this.tileUnLoad(tile);
    });
    this.tilesetManager.on("tile-error", (error, tile) => {
      this.tileError(error);
    });
    this.tilesetManager.on("tile-update", () => {
      this.tileUpdate();
    });
    this.mapService.on("zoomend", this.mapchange);
    this.mapService.on("moveend", this.viewchange);
  }
  render() {
    this.tileLayerService.render();
  }
  getLayers() {
    return this.tileLayerService.getLayers();
  }
  getTiles() {
    return this.tileLayerService.getTiles();
  }
  getTile(key) {
    return this.tileLayerService.getTile(key);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  tileLoaded(tile) {
  }
  tileError(error) {
    console.warn("error:", error);
  }
  destroy() {
    var _this$tilesetManager3;
    this.mapService.off("zoomend", this.mapchange);
    this.mapService.off("moveend", this.viewchange);
    (_this$tilesetManager3 = this.tilesetManager) === null || _this$tilesetManager3 === void 0 || _this$tilesetManager3.destroy();
    this.tileLayerService.destroy();
  }
  // 重新加载
  reload() {
    var _this$tilesetManager4;
    this.tilesetManager.clear();
    const {
      latLonBounds,
      zoom
    } = this.getCurrentView();
    (_this$tilesetManager4 = this.tilesetManager) === null || _this$tilesetManager4 === void 0 || _this$tilesetManager4.update(zoom, latLonBounds);
  }
  tileUnLoad(tile) {
    this.tileLayerService.removeTile(tile.key);
  }
  tileUpdate() {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (!_this.tilesetManager) {
        return;
      }
      const minZoom = _this.parent.getMinZoom();
      const maxZoom = _this.parent.getMaxZoom();
      const tiles = _this.tilesetManager.tiles.filter((tile) => tile.isLoaded).filter((tile) => tile.isVisibleChange).filter((tile) => tile.data).filter((tile) => tile.z >= minZoom && tile.z < maxZoom);
      yield Promise.all(tiles.map(function() {
        var _ref = _asyncToGenerator(function* (tile) {
          if (!_this.tileLayerService.hasTile(tile.key)) {
            const tileInstance = getTileFactory(_this.parent);
            const tileLayer = new tileInstance(tile, _this.parent);
            yield tileLayer.initTileLayer();
            _this.tilePickService.setPickState();
            if (tileLayer.getLayers().length !== 0) {
              _this.tileLayerService.addTile(tileLayer);
              _this.tileLayerService.updateTileVisible(tile);
              _this.layerService.reRender();
            }
          } else {
            _this.tileLayerService.updateTileVisible(tile);
            _this.tilePickService.setPickState();
            _this.layerService.reRender();
          }
        });
        return function(_x) {
          return _ref.apply(this, arguments);
        };
      }()));
      if (_this.tilesetManager.isLoaded) {
        _this.parent.emit("tiles-loaded", _this.tilesetManager.currentTiles);
      }
    })();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setPickState(layers) {
    return;
  }
  pickRender(target) {
    this.tilePickService.pickRender(target);
  }
  selectFeature(pickedColors) {
    this.tilePickService.selectFeature(pickedColors);
  }
  highlightPickedFeature(pickedColors) {
    this.tilePickService.highlightPickedFeature(pickedColors);
  }
  /**
   * 实现 TileLayer 对子图层方法的代理
   * @param parent
   */
  proxy(parent) {
    ProxyFuncs.forEach((func) => {
      const oldStyleFunc = parent[func].bind(parent);
      parent[func] = (...args) => {
        oldStyleFunc(...args);
        this.getLayers().map((child) => {
          child[func](...args);
        });
        if (func === "style") {
          this.getTiles().forEach((tile) => tile.styleUpdate(...args));
        }
        return parent;
      };
    });
  }
};

// node_modules/@antv/l7-layers/es/tile/core/TileDebugLayer.js
var TileDebugLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "TileDebugLayer");
    _defineProperty(this, "zIndex", 1e4);
    _defineProperty(this, "defaultSourceConfig", {
      data: [],
      options: {
        parser: {
          type: "testTile"
        }
      }
    });
  }
  buildModels() {
    return _asyncToGenerator(function* () {
      return;
    })();
  }
};

// node_modules/@antv/l7-layers/es/earth/models/atmosphere.js
var atmoSphereFrag = '\nlayout(std140) uniform commonUniforms {\n float u_opacity;\n};\nin vec3 vVertexNormal;\nin float v_offset;\nin vec4 v_Color;\n\n#pragma include "scene_uniforms"\nout vec4 outputColor;\nvoid main() {\n    \n    \n    // float intensity = pow(0.5 + dot(normalize(vVertexNormal), normalize(u_CameraPosition)), 3.0);\n    float intensity = pow(v_offset + dot(normalize(vVertexNormal), normalize(u_CameraPosition)), 3.0);\n    // 去除背面\n    if(intensity > 1.0) intensity = 0.0;\n\n    outputColor = vec4(v_Color.rgb, v_Color.a * intensity * u_opacity);\n}\n';
var atmoSphereVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n float u_opacity;\n};\n\n#pragma include "scene_uniforms"\nout vec3 vVertexNormal;\nout vec4 v_Color;\nout float v_offset;\n\nvoid main() {\n    float EARTH_RADIUS = 100.0;\n\n    v_Color = a_Color;\n\n    v_offset = min(((length(u_CameraPosition) - EARTH_RADIUS)/600.0) * 0.5 + 0.4, 1.0);\n    vVertexNormal = a_Normal;\n\n    gl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(a_Position, 1.0);\n}\n';
var {
  isNumber: isNumber6
} = lodashUtil;
var EarthAtomSphereModel = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      NORMAL: 9,
      UV: 10
    });
  }
  getCommonUniformsInfo() {
    const {
      opacity = 1
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_opacity: isNumber6(opacity) ? opacity : 1
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      return _this.buildModels();
    })();
  }
  clearModels() {
    return "";
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.layer.zIndex = -997;
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "earthAtmoSphere",
        vertexShader: atmoSphereVert,
        fragmentShader: atmoSphereFrag,
        defines: _this2.getDefines(),
        triangulation: earthTriangulation,
        depth: {
          enable: false
        },
        blend: _this2.getBlend()
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "normal",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Normal",
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/earth/models/base.js
var baseFrag = "uniform sampler2D u_texture;\n\nin vec2 v_texCoord;\nin float v_lightWeight;\nout vec4 outputColor;\n\nvoid main() {\n    vec4 color = texture(SAMPLER_2D(u_texture),vec2(v_texCoord.x,v_texCoord.y));\n    color.xyz = color.xyz * v_lightWeight;\n    outputColor = color;\n}\n";
var baseVert = '// attribute vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\n// attribute vec2 a_Extrude;\n// attribute float a_Size;\n// attribute float a_Shape;\n\nlayout(std140) uniform commonUniforms {\n	vec4 u_sunLight: [1.0, -10.5, 12.0,0.0];\n	float u_ambientRatio : 0.5;\n	float u_diffuseRatio : 0.3;\n	float u_specularRatio : 0.2;\n};\n\n#pragma include "scene_uniforms"\n\nout vec2 v_texCoord;\nout float v_lightWeight;\n\nfloat calc_lighting(vec4 pos) {\n\n	vec3 worldPos = vec3(pos * u_ModelMatrix);\n\n	vec3 worldNormal = a_Normal;\n\n	// cal light weight\n	vec3 viewDir = normalize(u_CameraPosition - worldPos);\n\n	vec3 lightDir = normalize(u_sunLight.xyz);\n\n	vec3 halfDir = normalize(viewDir+lightDir);\n	// lambert\n	float lambert = dot(worldNormal, lightDir);\n	// specular\n	float specular = pow(max(0.0, dot(worldNormal, halfDir)), 32.0);\n	//sum to light weight\n	float lightWeight = u_ambientRatio + u_diffuseRatio * lambert + u_specularRatio * specular;\n\n	return lightWeight;\n}\n\nvoid main() {\n\n	v_texCoord = a_Uv;\n\n	float lightWeight = calc_lighting(vec4(a_Position, 1.0));\n	v_lightWeight = lightWeight;\n\n	gl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(a_Position, 1.0);\n}\n';
var BaseEarthModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "earthTime", 3.4);
    _defineProperty(this, "sunX", 1e3);
    _defineProperty(this, "sunY", 1e3);
    _defineProperty(this, "sunZ", 1e3);
    _defineProperty(this, "sunRadius", Math.sqrt(this.sunX * this.sunX + this.sunY * this.sunY + this.sunZ * this.sunZ));
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      NORMAL: 9,
      UV: 10
    });
  }
  getCommonUniformsInfo() {
    const {
      animateOption,
      globalOptions
    } = this.layer.getLayerConfig();
    if (animateOption !== null && animateOption !== void 0 && animateOption.enable) {
      this.mapService.rotateY({
        reg: 2e-3
      });
      this.earthTime += 0.02;
      this.sunY = 10;
      this.sunX = Math.cos(this.earthTime) * (this.sunRadius - this.sunY);
      this.sunZ = Math.sin(this.earthTime) * (this.sunRadius - this.sunY);
    }
    const commonOptions = {
      u_sunLight: [this.sunX, this.sunY, this.sunZ, 0],
      u_ambientRatio: (globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.ambientRatio) || 0.6,
      // 环境光
      u_diffuseRatio: (globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.diffuseRatio) || 0.4,
      // 漫反射
      u_specularRatio: (globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.specularRatio) || 0.1
      // 高光反射
      // u_texture: this.texture,
    };
    this.textures = [this.texture];
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  setEarthTime(time) {
    this.earthTime = time;
    this.sunY = 10;
    this.sunX = Math.cos(this.earthTime) * (this.sunRadius - this.sunY);
    this.sunZ = Math.sin(this.earthTime) * (this.sunRadius - this.sunY);
    this.layerService.throttleRenderLayers();
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const {
        globalOptions
      } = _this.layer.getLayerConfig();
      if ((globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.earthTime) !== void 0) {
        _this.setEarthTime(globalOptions.earthTime);
      }
      const source = _this.layer.getSource();
      const {
        createTexture2D
      } = _this.rendererService;
      _this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      source.data.images.then((imageData) => {
        _this.texture = createTexture2D({
          data: imageData[0],
          width: imageData[0].width,
          height: imageData[0].height
        });
        _this.textures = [_this.texture];
        _this.layerService.reRender();
      });
      _this.initUniformsBuffer();
      return _this.buildModels();
    })();
  }
  clearModels() {
    return "";
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.layer.zIndex = -998;
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "earthBase",
        vertexShader: baseVert,
        fragmentShader: baseFrag,
        defines: _this2.getDefines(),
        triangulation: earthTriangulation,
        depth: {
          enable: true
        },
        blend: _this2.getBlend()
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "normal",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Normal",
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/earth/models/bloomsphere.js
var bloomSphereFrag = '\nin vec3 vVertexNormal;\nin vec4 v_Color;\n\nlayout(std140) uniform commonUniforms {\n float u_opacity;\n};\nout vec4 outputColor;\n#pragma include "scene_uniforms"\nvoid main() {\n    float intensity =  - dot(normalize(vVertexNormal), normalize(u_CameraPosition));\n    // 去除背面\n    if(intensity > 1.0) intensity = 0.0;\n\n    outputColor = vec4(v_Color.rgb, v_Color.a * intensity * u_opacity);\n}\n';
var bloomSphereVert = 'layout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_COLOR) vec4 a_Color;\nlayout(location = ATTRIBUTE_LOCATION_NORMAL) in vec3 a_Normal;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nlayout(std140) uniform commonUniforms {\n float u_opacity;\n};\n#pragma include "scene_uniforms"\n\nout vec3 vVertexNormal;\nout vec4 v_Color;\n\nvoid main() {\n    v_Color = a_Color;\n\n    vVertexNormal = a_Normal;\n\n    gl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(a_Position, 1.0);\n}\n';
var {
  isNumber: isNumber7
} = lodashUtil;
var EarthBloomSphereModel = class extends BaseModel {
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      NORMAL: 9,
      UV: 10
    });
  }
  getCommonUniformsInfo() {
    const {
      opacity = 1
    } = this.layer.getLayerConfig();
    const commonOptions = {
      u_opacity: isNumber7(opacity) ? opacity : 1
    };
    const commonBufferInfo = this.getUniformsBufferInfo(commonOptions);
    return commonBufferInfo;
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.initUniformsBuffer();
      return _this.buildModels();
    })();
  }
  clearModels() {
    return "";
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      _this2.layer.zIndex = -999;
      const model = yield _this2.layer.buildLayerModel({
        moduleName: "earthBloom",
        vertexShader: bloomSphereVert,
        fragmentShader: bloomSphereFrag,
        defines: _this2.getDefines(),
        triangulation: earthOuterTriangulation,
        depth: {
          enable: false
        },
        blend: _this2.getBlend()
      });
      return [model];
    })();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "normal",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Normal",
        shaderLocation: this.attributeLocation.NORMAL,
        buffer: {
          usage: gl.STATIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 3,
        update: (feature, featureIdx, vertex, attributeIdx, normal) => {
          return normal;
        }
      }
    });
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
};

// node_modules/@antv/l7-layers/es/earth/index.js
var EarthModels = {
  base: BaseEarthModel,
  atomSphere: EarthAtomSphereModel,
  bloomSphere: EarthBloomSphereModel
};
var earthLayerTypes = ["base", "atomSphere", "bloomSphere"];
var EarthLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "EarthLayer");
    _defineProperty(this, "defaultSourceConfig", {
      data: [],
      options: {
        parser: {
          type: "json"
        }
      }
    });
  }
  buildModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const shape = _this.getModelType();
      _this.layerModel = new EarthModels[shape](_this);
      yield _this.initLayerModels();
    })();
  }
  /**
   * 设置当前地球时间
   * @param time
   */
  setEarthTime(time) {
    if (this.layerModel && this.layerModel.setEarthTime) {
      this.layerModel.setEarthTime(time);
    } else {
      console.warn("请在 scene loaded 之后执行该方法！");
    }
  }
  getModelType() {
    var _shapeAttribute$scale;
    const shapeAttribute = this.styleAttributeService.getLayerStyleAttribute("shape");
    let shape = (shapeAttribute === null || shapeAttribute === void 0 || (_shapeAttribute$scale = shapeAttribute.scale) === null || _shapeAttribute$scale === void 0 ? void 0 : _shapeAttribute$scale.field) || "base";
    if (earthLayerTypes.indexOf(shape) < 0) {
      shape = "base";
    }
    return shape;
  }
};

// node_modules/@antv/l7-layers/es/wind/models/utils.js
function createProgram(gl2, vshader, fshader) {
  const vertexShader = loadShader(gl2, gl2.VERTEX_SHADER, vshader);
  const fragmentShader = loadShader(gl2, gl2.FRAGMENT_SHADER, fshader);
  if (!vertexShader || !fragmentShader) {
    return null;
  }
  const program = gl2.createProgram();
  if (!program) {
    return null;
  }
  gl2.attachShader(program, vertexShader);
  gl2.attachShader(program, fragmentShader);
  gl2.linkProgram(program);
  const linked = gl2.getProgramParameter(program, gl2.LINK_STATUS);
  if (!linked) {
    const error = gl2.getProgramInfoLog(program);
    console.warn("Failed to link program: " + error);
    gl2.deleteProgram(program);
    gl2.deleteShader(fragmentShader);
    gl2.deleteShader(vertexShader);
    return null;
  }
  const numAttributes = gl2.getProgramParameter(program, gl2.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < numAttributes; i++) {
    const attribute = gl2.getActiveAttrib(program, i);
    program[attribute.name] = gl2.getAttribLocation(program, attribute.name);
  }
  const numUniforms = gl2.getProgramParameter(program, gl2.ACTIVE_UNIFORMS);
  for (let i$1 = 0; i$1 < numUniforms; i$1++) {
    const uniform = gl2.getActiveUniform(program, i$1);
    program[uniform.name] = gl2.getUniformLocation(program, uniform.name);
  }
  program.vertexShader = vertexShader;
  program.fragmentShader = fragmentShader;
  return program;
}
function loadShader(gl2, type, source) {
  const shader = gl2.createShader(type);
  if (shader == null) {
    console.warn("unable to create shader");
    return null;
  }
  gl2.shaderSource(shader, source);
  gl2.compileShader(shader);
  const compiled = gl2.getShaderParameter(shader, gl2.COMPILE_STATUS);
  if (!compiled) {
    const error = gl2.getShaderInfoLog(shader);
    console.warn("Failed to compile shader: " + error);
    gl2.deleteShader(shader);
    return null;
  }
  return shader;
}
function createTexture(gl2, filter3, data, width, height) {
  const texture = gl2.createTexture();
  gl2.bindTexture(gl2.TEXTURE_2D, texture);
  gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
  gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
  gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, filter3);
  gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, filter3);
  gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, width, height, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, data);
  gl2.bindTexture(gl2.TEXTURE_2D, null);
  return texture;
}
function createDataTexture(gl2, filter3, data) {
  const texture = gl2.createTexture();
  gl2.bindTexture(gl2.TEXTURE_2D, texture);
  gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
  gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
  gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, filter3);
  gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, filter3);
  gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, gl2.RGBA, gl2.UNSIGNED_BYTE, data);
  gl2.bindTexture(gl2.TEXTURE_2D, null);
  return texture;
}
function bindTexture(gl2, texture, unit2) {
  gl2.activeTexture(gl2.TEXTURE0 + unit2);
  gl2.bindTexture(gl2.TEXTURE_2D, texture);
}
function createBuffer(gl2, data) {
  const buffer = gl2.createBuffer();
  gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer);
  gl2.bufferData(gl2.ARRAY_BUFFER, data, gl2.STATIC_DRAW);
  return buffer;
}

// node_modules/@antv/l7-layers/es/wind/models/windShader.js
var drawVert = `
 precision mediump float;

 attribute float a_index;

 uniform sampler2D u_particles;
 uniform float u_particles_res;

 varying vec2 v_particle_pos;

 void main() {
     vec4 color = texture2D(u_particles, vec2(
         fract(a_index / u_particles_res),
         floor(a_index / u_particles_res) / u_particles_res)
     );

     // decode current particle position from the pixel's RGBA value
     v_particle_pos = vec2( color.r / 255.0 + color.b, color.g / 255.0 + color.a);

     gl_PointSize = 1.0;
     gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);
 }`;
var drawFrag = `
 precision mediump float;

 uniform sampler2D u_wind;
 uniform vec2 u_wind_min;
 uniform vec2 u_wind_max;
 uniform sampler2D u_color_ramp;

 varying vec2 v_particle_pos;

 void main() {
     vec2 velocity = mix(u_wind_min, u_wind_max, texture2D(u_wind, v_particle_pos).rg);
     float speed_t = length(velocity) / length(u_wind_max);

     // color ramp is encoded in a 16x16 texture
     vec2 ramp_pos = vec2( fract(16.0 * speed_t), floor(16.0 * speed_t) / 16.0);

     gl_FragColor = texture2D(u_color_ramp, ramp_pos);
 }`;
var updateVert = `
 precision mediump float;

 attribute vec2 a_pos;

 varying vec2 v_tex_pos;

 void main() {
     v_tex_pos = a_pos;
     gl_Position = vec4(1.0 - 2.0 * a_pos, 0, 1);
     // framebuffer 始终用铺满屏幕的 texture
 }`;
var updateFrag = `
 precision highp float;

 uniform sampler2D u_particles;
 uniform sampler2D u_wind;
 uniform vec2 u_wind_res;
 uniform vec2 u_wind_min;
 uniform vec2 u_wind_max;
 uniform float u_rand_seed;
 uniform float u_speed_factor;
 uniform float u_drop_rate;
 uniform float u_drop_rate_bump;

 varying vec2 v_tex_pos;

 // pseudo-random generator
 const vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);
 float rand(const vec2 co) {
 float t = dot(rand_constants.xy, co);
     return fract(sin(t) * (rand_constants.z + t));
 }

 // wind speed lookup; use manual bilinear filtering based on 4 adjacent pixels for smooth interpolation
 vec2 lookup_wind(const vec2 uv) {
     // return texture2D(u_wind, uv).rg; // lower-res hardware filtering
     vec2 px = 1.0 / u_wind_res;
     vec2 vc = (floor(uv * u_wind_res)) * px;
     vec2 f = fract(uv * u_wind_res);
     vec2 tl = texture2D(u_wind, vc).rg;
     vec2 tr = texture2D(u_wind, vc + vec2(px.x, 0)).rg;
     vec2 bl = texture2D(u_wind, vc + vec2(0, px.y)).rg;
     vec2 br = texture2D(u_wind, vc + px).rg;
     return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);
 }

 void main() {
     vec4 color = texture2D(u_particles, v_tex_pos);
     vec2 pos = vec2(
         color.r / 255.0 + color.b,
         color.g / 255.0 + color.a); // decode particle position from pixel RGBA
     vec2 velocity = mix(u_wind_min, u_wind_max, lookup_wind(pos));
     float speed_t = length(velocity) / length(u_wind_max);

     // take EPSG:4236 distortion into account for calculating where the particle moved
     float distortion = cos(radians(pos.y * 180.0 - 90.0));
     vec2 offset = vec2(velocity.x / distortion, -velocity.y) * 0.0001 * u_speed_factor;

     // update particle position, wrapping around the date line
     pos = fract(1.0 + pos + offset);

     // a random seed to use for the particle drop
     vec2 seed = (pos + v_tex_pos) * u_rand_seed;

     // drop rate is a chance a particle will restart at random position, to avoid degeneration
     float drop_rate = u_drop_rate + speed_t * u_drop_rate_bump;
     float drop = step(1.0 - drop_rate, rand(seed));

     vec2 random_pos = vec2(
         rand(seed + 1.3),
         rand(seed + 2.1));
         pos = mix(pos, random_pos, drop);

     // encode the new particle position back into RGBA
     gl_FragColor = vec4(
         fract(pos * 255.0),
         floor(pos * 255.0) / 255.0);
 }`;
var fullScreenVert = `
     precision mediump float;

     attribute vec2 a_pos;

     varying vec2 v_tex_pos;

     void main() {
         v_tex_pos = a_pos;
         gl_Position = vec4(1.0 - 2.0 * a_pos, 0.0, 1.0);
         gl_PointSize = 100.0;
 }`;
var fullScreenFrag = `
 precision mediump float;

 uniform sampler2D u_screen;
 uniform float u_opacity;
 varying vec2 v_tex_pos;

 void main() {
     vec4 color = texture2D(u_screen, 1.0 - v_tex_pos);

     // a hack to guarantee opacity fade out even with a value close to 1.0
     gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);
 }`;

// node_modules/@antv/l7-layers/es/wind/models/windRender.js
function getColorRamp(colors) {
  let canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  canvas.width = 256;
  canvas.height = 1;
  const gradient2 = ctx.createLinearGradient(0, 0, 256, 0);
  for (const stop of Object.keys(colors)) {
    gradient2.addColorStop(+stop, colors[+stop]);
  }
  ctx.fillStyle = gradient2;
  ctx.fillRect(0, 0, 256, 1);
  canvas = null;
  return new Uint8Array(ctx.getImageData(0, 0, 256, 1).data);
}
function bindAttribute(gl2, buffer, attribute, numComponents) {
  gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer);
  gl2.enableVertexAttribArray(attribute);
  gl2.vertexAttribPointer(attribute, numComponents, gl2.FLOAT, false, 0, 0);
}
function bindFramebuffer(gl2, framebuffer, texture) {
  gl2.bindFramebuffer(gl2.FRAMEBUFFER, framebuffer);
  if (texture) {
    gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, texture, 0);
  }
}
var Wind = class {
  constructor(options) {
    _defineProperty(this, "width", 512);
    _defineProperty(this, "height", 512);
    _defineProperty(this, "pixels", void 0);
    _defineProperty(this, "fadeOpacity", void 0);
    _defineProperty(this, "speedFactor", void 0);
    _defineProperty(this, "dropRate", void 0);
    _defineProperty(this, "dropRateBump", void 0);
    _defineProperty(this, "gl", void 0);
    _defineProperty(this, "drawProgram", void 0);
    _defineProperty(this, "fullScreenProgram", void 0);
    _defineProperty(this, "updateProgram", void 0);
    _defineProperty(this, "rampColors", void 0);
    _defineProperty(this, "numParticles", 65536);
    _defineProperty(this, "numParticlesSize", void 0);
    _defineProperty(this, "particleStateResolution", void 0);
    _defineProperty(this, "quadBuffer", void 0);
    _defineProperty(this, "particleIndexBuffer", void 0);
    _defineProperty(this, "framebuffer", void 0);
    _defineProperty(this, "colorRampTexture", void 0);
    _defineProperty(this, "backgroundTexture", void 0);
    _defineProperty(this, "screenTexture", void 0);
    _defineProperty(this, "particleStateTexture0", void 0);
    _defineProperty(this, "particleStateTexture1", void 0);
    _defineProperty(this, "windTexture", void 0);
    _defineProperty(this, "windData", void 0);
    this.gl = options.glContext;
    this.width = options.imageWidth;
    this.height = options.imageHeight;
    this.fadeOpacity = options.fadeOpacity;
    this.speedFactor = options.speedFactor;
    this.dropRate = options.dropRate;
    this.dropRateBump = options.dropRateBump;
    this.rampColors = options.rampColors;
    this.init();
  }
  init() {
    const gl2 = this.gl;
    this.fadeOpacity = 0.996;
    this.speedFactor = 0.25;
    this.dropRate = 3e-3;
    this.dropRateBump = 0.01;
    this.drawProgram = createProgram(gl2, drawVert, drawFrag);
    this.fullScreenProgram = createProgram(gl2, fullScreenVert, fullScreenFrag);
    this.updateProgram = createProgram(gl2, updateVert, updateFrag);
    this.quadBuffer = createBuffer(gl2, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]));
    this.framebuffer = gl2.createFramebuffer();
    this.colorRampTexture = createTexture(this.gl, this.gl.LINEAR, getColorRamp(this.rampColors), 16, 16);
    const emptyPixels = new Uint8Array(this.width * this.height * 4);
    this.backgroundTexture = createTexture(gl2, gl2.NEAREST, emptyPixels, this.width, this.height);
    this.screenTexture = createTexture(gl2, gl2.NEAREST, emptyPixels, this.width, this.height);
    const particleRes = this.particleStateResolution = Math.ceil(Math.sqrt(this.numParticles));
    this.numParticlesSize = particleRes * particleRes;
    const particleState = new Uint8Array(this.numParticlesSize * 4);
    for (let i = 0; i < particleState.length; i++) {
      particleState[i] = Math.floor(Math.random() * 256);
    }
    this.particleStateTexture0 = createTexture(gl2, gl2.NEAREST, particleState, particleRes, particleRes);
    this.particleStateTexture1 = createTexture(gl2, gl2.NEAREST, particleState, particleRes, particleRes);
    const particleIndices = new Float32Array(this.numParticlesSize);
    for (let i$1 = 0; i$1 < this.numParticlesSize; i$1++) {
      particleIndices[i$1] = i$1;
    }
    this.particleIndexBuffer = createBuffer(gl2, particleIndices);
  }
  setWind(windData) {
    this.windData = windData;
    this.windTexture = createDataTexture(this.gl, this.gl.LINEAR, windData.image);
  }
  /**
   * 更新风场粒子数量
   * @param num
   */
  updateParticelNum(num) {
    const gl2 = this.gl;
    if (num !== this.numParticles) {
      this.numParticles = num;
      const particleRes = this.particleStateResolution = Math.ceil(Math.sqrt(this.numParticles));
      this.numParticlesSize = particleRes * particleRes;
      const particleState = new Uint8Array(this.numParticlesSize * 4);
      for (let i = 0; i < particleState.length; i++) {
        particleState[i] = Math.floor(Math.random() * 256);
      }
      this.particleStateTexture0 = createTexture(gl2, gl2.NEAREST, particleState, particleRes, particleRes);
      this.particleStateTexture1 = createTexture(gl2, gl2.NEAREST, particleState, particleRes, particleRes);
      const particleIndices = new Float32Array(this.numParticlesSize);
      for (let i$1 = 0; i$1 < this.numParticlesSize; i$1++) {
        particleIndices[i$1] = i$1;
      }
      this.particleIndexBuffer = createBuffer(gl2, particleIndices);
    }
  }
  /**
   * 更新风场风向风速
   * @param uMin
   * @param uMax
   * @param vMin
   * @param vMax
   */
  updateWindDir(uMin, uMax, vMin, vMax) {
    this.windData.uMin = uMin;
    this.windData.uMax = uMax;
    this.windData.vMin = vMin;
    this.windData.vMax = vMax;
  }
  /**
   * update rampColors
   * @param rampColors
   */
  updateColorRampTexture(rampColors) {
    if (this.isColorChanged(rampColors)) {
      this.rampColors = rampColors;
      const gl2 = this.gl;
      gl2.deleteTexture(this.colorRampTexture);
      this.colorRampTexture = createTexture(gl2, gl2.LINEAR, getColorRamp(rampColors), 16, 16);
    }
  }
  isColorChanged(rampColors) {
    const keys = Object.keys(rampColors);
    for (const item of keys) {
      const key = Number(item);
      if (!this.rampColors[key]) {
        return true;
      }
      if (this.rampColors[key] && this.rampColors[key] !== rampColors[key]) {
        return true;
      }
    }
    return false;
  }
  reSize(width, height) {
    if (width !== this.width || height !== this.height) {
      const gl2 = this.gl;
      gl2.deleteTexture(this.backgroundTexture);
      gl2.deleteTexture(this.screenTexture);
      this.width = width;
      this.height = height;
      const emptyPixels = new Uint8Array(width * height * 4);
      this.backgroundTexture = createTexture(gl2, gl2.NEAREST, emptyPixels, width, height);
      this.screenTexture = createTexture(gl2, gl2.NEAREST, emptyPixels, width, height);
    }
  }
  draw() {
    var _this$windData;
    if ((_this$windData = this.windData) !== null && _this$windData !== void 0 && _this$windData.image) {
      const gl2 = this.gl;
      bindTexture(gl2, this.windTexture, 0);
      bindTexture(gl2, this.particleStateTexture0, 1);
      this.drawScreen();
      this.updateParticles();
      return {
        d: this.pixels,
        w: this.width,
        h: this.height
      };
    } else {
      return {
        d: new Uint8Array([0, 0, 0, 0]),
        w: 1,
        h: 1
      };
    }
  }
  drawScreen() {
    const gl2 = this.gl;
    bindFramebuffer(gl2, this.framebuffer, this.screenTexture);
    gl2.viewport(0, 0, this.width, this.height);
    gl2.disable(gl2.BLEND);
    this.drawFullTexture(this.backgroundTexture, this.fadeOpacity);
    this.drawParticles();
    this.pixels = new Uint8Array(4 * this.width * this.height);
    gl2.readPixels(0, 0, this.width, this.height, gl2.RGBA, gl2.UNSIGNED_BYTE, this.pixels);
    bindFramebuffer(gl2, null, null);
    gl2.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
    const temp = this.backgroundTexture;
    this.backgroundTexture = this.screenTexture;
    this.screenTexture = temp;
  }
  drawFullTexture(texture, opacity) {
    const gl2 = this.gl;
    const program = this.fullScreenProgram;
    gl2.useProgram(program);
    gl2.bindBuffer(gl2.ARRAY_BUFFER, this.quadBuffer);
    gl2.vertexAttribPointer(program.a_pos, 2, gl2.FLOAT, false, 0, 0);
    gl2.enableVertexAttribArray(program.a_pos);
    gl2.bindBuffer(gl2.ARRAY_BUFFER, null);
    bindTexture(gl2, texture, 2);
    gl2.uniform1i(program.u_screen, 2);
    gl2.uniform1f(program.u_opacity, opacity);
    gl2.drawArrays(gl2.TRIANGLES, 0, 6);
  }
  drawParticles() {
    const gl2 = this.gl;
    const program = this.drawProgram;
    gl2.useProgram(program);
    bindAttribute(gl2, this.particleIndexBuffer, program.a_index, 1);
    bindTexture(gl2, this.colorRampTexture, 2);
    gl2.uniform1i(program.u_wind, 0);
    gl2.uniform1i(program.u_particles, 1);
    gl2.uniform1i(program.u_color_ramp, 2);
    gl2.uniform1f(program.u_particles_res, this.particleStateResolution);
    gl2.uniform2f(program.u_wind_min, this.windData.uMin, this.windData.vMin);
    gl2.uniform2f(program.u_wind_max, this.windData.uMax, this.windData.vMax);
    gl2.drawArrays(gl2.POINTS, 0, this.numParticlesSize);
  }
  updateParticles() {
    const gl2 = this.gl;
    bindFramebuffer(gl2, this.framebuffer, this.particleStateTexture1);
    gl2.viewport(0, 0, this.particleStateResolution, this.particleStateResolution);
    const program = this.updateProgram;
    gl2.useProgram(program);
    bindAttribute(gl2, this.quadBuffer, program.a_pos, 2);
    gl2.uniform1i(program.u_wind, 0);
    gl2.uniform1i(program.u_particles, 1);
    gl2.uniform1f(program.u_rand_seed, Math.random());
    gl2.uniform2f(program.u_wind_res, this.windData.image.width * 2, this.windData.image.height * 2);
    gl2.uniform2f(program.u_wind_min, this.windData.uMin, this.windData.vMin);
    gl2.uniform2f(program.u_wind_max, this.windData.uMax, this.windData.vMax);
    gl2.uniform1f(program.u_speed_factor, this.speedFactor);
    gl2.uniform1f(program.u_drop_rate, this.dropRate);
    gl2.uniform1f(program.u_drop_rate_bump, this.dropRateBump);
    gl2.drawArrays(gl2.TRIANGLES, 0, 6);
    const temp = this.particleStateTexture0;
    this.particleStateTexture0 = this.particleStateTexture1;
    this.particleStateTexture1 = temp;
    bindFramebuffer(gl2, null, null);
  }
  destroy() {
    this.gl.deleteBuffer(this.quadBuffer);
    this.gl.deleteBuffer(this.particleIndexBuffer);
    this.gl.deleteFramebuffer(this.framebuffer);
    this.gl.deleteShader(this.drawProgram.vertexShader);
    this.gl.deleteShader(this.drawProgram.fragmentShader);
    this.gl.deleteProgram(this.drawProgram);
    this.gl.deleteShader(this.fullScreenProgram.vertexShader);
    this.gl.deleteShader(this.fullScreenProgram.fragmentShader);
    this.gl.deleteProgram(this.fullScreenProgram);
    this.gl.deleteShader(this.updateProgram.vertexShader);
    this.gl.deleteShader(this.updateProgram.fragmentShader);
    this.gl.deleteProgram(this.updateProgram);
    this.gl.deleteTexture(this.colorRampTexture);
    this.gl.deleteTexture(this.backgroundTexture);
    this.gl.deleteTexture(this.screenTexture);
    this.gl.deleteTexture(this.particleStateTexture0);
    this.gl.deleteTexture(this.particleStateTexture1);
    this.gl.deleteTexture(this.windTexture);
  }
};

// node_modules/@antv/l7-layers/es/wind/models/wind.js
var WindFrag = "precision mediump float;\nuniform float u_opacity: 1.0;\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\nvoid main() {\n  vec4 color = texture2D(u_texture,vec2(v_texCoord.x,v_texCoord.y));\n  gl_FragColor = color;\n  gl_FragColor.a *= u_opacity;\n}\n";
var WindVert = 'precision highp float;\nuniform mat4 u_ModelMatrix;\n\nlayout(location = ATTRIBUTE_LOCATION_POSITION) in vec3 a_Position;\nlayout(location = ATTRIBUTE_LOCATION_UV) in vec2 a_Uv;\n\nvarying vec2 v_texCoord;\n#pragma include "projection"\nvoid main() {\n  v_texCoord = a_Uv;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n  gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0.0, 1.0));\n}\n';
var defaultRampColors = {
  0: "#3288bd",
  0.1: "#66c2a5",
  0.2: "#abdda4",
  0.3: "#e6f598",
  0.4: "#fee08b",
  0.5: "#fdae61",
  0.6: "#f46d43",
  1: "#d53e4f"
};
var WindModel = class extends BaseModel {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "colorModel", void 0);
    _defineProperty(this, "wind", void 0);
    _defineProperty(this, "imageCoords", void 0);
    _defineProperty(this, "sizeScale", 0.5);
    _defineProperty(this, "frequency", new FrequencyController(7.2));
    _defineProperty(this, "cacheZoom", void 0);
  }
  get attributeLocation() {
    return Object.assign(super.attributeLocation, {
      MAX: super.attributeLocation.MAX,
      UV: 9
    });
  }
  render(options) {
    this.drawColorMode(options);
    this.frequency.run(() => {
      this.drawWind();
    });
  }
  getUninforms() {
    throw new Error("Method not implemented.");
  }
  initModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      var _source$data, _source$data2;
      const {
        uMin = -21.32,
        uMax = 26.8,
        vMin = -21.57,
        vMax = 21.42,
        fadeOpacity = 0.996,
        speedFactor = 0.25,
        dropRate = 3e-3,
        dropRateBump = 0.01,
        rampColors = defaultRampColors,
        sizeScale = 0.5
        // mask
      } = _this.layer.getLayerConfig();
      const {
        createTexture2D
      } = _this.rendererService;
      const source = _this.layer.getSource();
      _this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      _this.cacheZoom = Math.floor(_this.mapService.getZoom());
      const glContext = _this.rendererService.getGLContext();
      _this.imageCoords = (_source$data = source.data) === null || _source$data === void 0 ? void 0 : _source$data.dataArray[0].coordinates;
      (_source$data2 = source.data) === null || _source$data2 === void 0 || (_source$data2 = _source$data2.images) === null || _source$data2 === void 0 || _source$data2.then((imageData) => {
        var _this$texture;
        _this.sizeScale = sizeScale * _this.getZoomScale();
        const {
          imageWidth,
          imageHeight
        } = _this.getWindSize();
        const options = {
          glContext,
          imageWidth,
          imageHeight,
          fadeOpacity,
          speedFactor,
          dropRate,
          dropRateBump,
          rampColors
        };
        _this.wind = new Wind(options);
        _this.wind.setWind({
          uMin,
          uMax,
          vMin,
          vMax,
          image: imageData[0]
        });
        (_this$texture = _this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
        _this.texture = createTexture2D({
          width: imageWidth,
          height: imageHeight
        });
        _this.layerService.reRender();
      });
      const model = yield _this.layer.buildLayerModel({
        moduleName: "wind",
        vertexShader: WindVert,
        fragmentShader: WindFrag,
        defines: _this.getDefines(),
        triangulation: RasterImageTriangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        }
      });
      _this.colorModel = model;
      return [model];
    })();
  }
  getWindSize() {
    const p1 = this.mapService.lngLatToPixel(this.imageCoords[0]);
    const p2 = this.mapService.lngLatToPixel(this.imageCoords[1]);
    const imageWidth = Math.min(Math.floor((p2.x - p1.x) * this.sizeScale), 2048);
    const imageHeight = Math.min(Math.floor((p1.y - p2.y) * this.sizeScale), 2048);
    return {
      imageWidth,
      imageHeight
    };
  }
  buildModels() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      return _this2.initModels();
    })();
  }
  clearModels() {
    var _this$texture2, _this$wind;
    (_this$texture2 = this.texture) === null || _this$texture2 === void 0 || _this$texture2.destroy();
    (_this$wind = this.wind) === null || _this$wind === void 0 || _this$wind.destroy();
  }
  registerBuiltinAttributes() {
    this.styleAttributeService.registerStyleAttribute({
      name: "uv",
      type: AttributeType.Attribute,
      descriptor: {
        name: "a_Uv",
        shaderLocation: this.attributeLocation.UV,
        buffer: {
          // give the WebGL driver a hint that this buffer may change
          usage: gl.DYNAMIC_DRAW,
          data: [],
          type: gl.FLOAT
        },
        size: 2,
        update: (feature, featureIdx, vertex) => {
          return [vertex[3], vertex[4]];
        }
      }
    });
  }
  getZoomScale() {
    return Math.min((this.cacheZoom + 4) / 30 * 2, 2);
  }
  drawWind() {
    if (this.wind) {
      const {
        uMin = -21.32,
        uMax = 26.8,
        vMin = -21.57,
        vMax = 21.42,
        numParticles = 65535,
        fadeOpacity = 0.996,
        speedFactor = 0.25,
        dropRate = 3e-3,
        dropRateBump = 0.01,
        rampColors = defaultRampColors,
        sizeScale = 0.5
      } = this.layer.getLayerConfig();
      let newNumParticles = numParticles;
      const currentZoom = Math.floor(this.mapService.getZoom());
      if (typeof sizeScale === "number" && sizeScale !== this.sizeScale || currentZoom !== this.cacheZoom) {
        const zoomScale = this.getZoomScale();
        this.sizeScale = sizeScale;
        newNumParticles *= zoomScale;
        const {
          imageWidth,
          imageHeight
        } = this.getWindSize();
        this.wind.reSize(imageWidth, imageHeight);
        this.cacheZoom = currentZoom;
      }
      this.wind.updateWindDir(uMin, uMax, vMin, vMax);
      this.wind.updateParticelNum(newNumParticles);
      this.wind.updateColorRampTexture(rampColors);
      this.wind.fadeOpacity = fadeOpacity;
      this.wind.speedFactor = speedFactor;
      this.wind.dropRate = dropRate;
      this.wind.dropRateBump = dropRateBump;
      const {
        d,
        w,
        h
      } = this.wind.draw();
      this.rendererService.setBaseState();
      this.texture.update({
        data: d,
        width: w,
        height: h
      });
    }
  }
  drawColorMode(options = {}) {
    var _this$colorModel;
    const {
      opacity
    } = this.layer.getLayerConfig();
    this.layerService.beforeRenderData(this.layer);
    this.layer.hooks.beforeRender.call();
    this.layerService.renderMask(this.layer.masks);
    (_this$colorModel = this.colorModel) === null || _this$colorModel === void 0 || _this$colorModel.draw({
      uniforms: {
        u_opacity: opacity || 1,
        u_texture: this.texture
      },
      blend: this.getBlend(),
      stencil: this.getStencil(options)
    });
    this.layer.hooks.afterRender.call();
  }
};

// node_modules/@antv/l7-layers/es/wind/models/index.js
var WindModels = {
  wind: WindModel
};
var models_default9 = WindModels;

// node_modules/@antv/l7-layers/es/wind/index.js
var WindLayer = class extends BaseLayer {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "type", "WindLayer");
  }
  buildModels() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const modelType = _this.getModelType();
      _this.layerModel = new models_default9[modelType](_this);
      yield _this.initLayerModels();
    })();
  }
  renderModels(options = {}) {
    if (this.layerModel) {
      this.layerModel.render(options);
    }
    return this;
  }
  getDefaultConfig() {
    const type = this.getModelType();
    const defaultConfig = {
      wind: {}
    };
    return defaultConfig[type];
  }
  getModelType() {
    return "wind";
  }
};

// node_modules/@antv/l7-component/es/control/swipe.js
var Swipe = class extends Control {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "isMoving", false);
    _defineProperty(this, "maskLayer", void 0);
    _defineProperty(this, "move", (e) => {
      e.stopPropagation();
      switch (e.type) {
        case "touchcancel":
        case "touchend":
        case "mouseup": {
          var _this$scene;
          this.isMoving = false;
          ["mouseup", "mousemove", "touchend", "touchcancel", "touchmove"].forEach((eventName) => {
            document.removeEventListener(eventName, this.move);
          });
          (_this$scene = this.scene) === null || _this$scene === void 0 || _this$scene.render();
          break;
        }
        case "mousedown":
        case "touchstart": {
          this.isMoving = true;
          ["mouseup", "mousemove", "touchend", "touchcancel", "touchmove"].forEach((eventName) => {
            document.addEventListener(eventName, this.move);
          });
        }
        case "mousemove":
        case "touchmove": {
          if (this.isMoving) {
            if (this.controlOption.orientation === "vertical") {
              let pageX;
              if ("pageX" in e) {
                pageX = e.pageX;
              } else if (e.touches && e.touches.length && e.touches[0].pageX) {
                pageX = e.touches[0].pageX;
              } else if (e.changedTouches && e.changedTouches.length) {
                pageX = e.changedTouches[0].pageX;
              }
              if (!pageX) {
                break;
              }
              const containerRect = this.getContainerDOMRect();
              const containerSize = this.getContainerSize();
              const containerWidth = containerSize[0];
              const containerRectLeft = (containerRect === null || containerRect === void 0 ? void 0 : containerRect.left) || 0;
              const offsetX = pageX - containerRectLeft + window.scrollX - document.documentElement.clientLeft;
              const width = containerWidth - Math.min(Math.max(0, containerWidth - offsetX), containerWidth);
              const ratio = width / containerWidth;
              this.setOptions({
                ratio
              });
              this.emit("moving", {
                size: [width, containerSize[1]],
                ratio: [ratio, 0]
              });
            } else {
              let pageY;
              if ("pageY" in e) {
                pageY = e.pageY;
              } else if (e.touches && e.touches.length && e.touches[0].pageY) {
                pageY = e.touches[0].pageY;
              } else if (e.changedTouches && e.changedTouches.length) {
                pageY = e.changedTouches[0].pageY;
              }
              if (!pageY) {
                break;
              }
              const containerRect = this.getContainerDOMRect();
              const containerSize = this.getContainerSize();
              const containerHeight = containerSize[1];
              const containerRectLeft = (containerRect === null || containerRect === void 0 ? void 0 : containerRect.top) || 0;
              const offsetY = pageY - containerRectLeft + window.scrollY - document.documentElement.clientTop;
              const height = containerHeight - Math.min(Math.max(0, containerHeight - offsetY), containerHeight);
              const ratio = height / containerHeight;
              this.setOptions({
                ratio
              });
              this.emit("moving", {
                size: [containerSize[0], height],
                ratio: [0, ratio]
              });
            }
          }
          break;
        }
        default:
          break;
      }
    });
    _defineProperty(this, "getMaskLayer", () => {
      console.log(this.getMaskGeoData());
      return new PolygonLayer({
        visible: false
      }).source(this.getMaskGeoData()).shape("fill").color("red").style({
        opacity: 0.1
      });
    });
    _defineProperty(this, "updateMask", () => {
      var _this$maskLayer;
      if (!this.mapsService)
        return;
      const geoJSON2 = this.getMaskGeoData();
      (_this$maskLayer = this.maskLayer) === null || _this$maskLayer === void 0 || _this$maskLayer.setData(geoJSON2);
    });
  }
  getDefault() {
    return _objectSpread2(_objectSpread2({}, super.getDefault()), {}, {
      layers: [],
      rightLayers: [],
      ratio: 0.5,
      orientation: "vertical"
    });
  }
  onAdd() {
    const container = dom_exports.create("div", "l7-control-swipe");
    dom_exports.create("button", "l7-control-swipe__button", container);
    const {
      orientation = "vertical",
      ratio = 0.5
    } = this.controlOption;
    if (orientation === "horizontal") {
      container.style.top = ratio * 100 + "%";
      container.style.left = "";
    } else {
      container.style.left = ratio * 100 + "%";
      container.style.top = "";
    }
    container.classList.add(orientation);
    return container;
  }
  addTo(sceneContainer) {
    this.mapsService = sceneContainer.mapService;
    this.renderService = sceneContainer.rendererService;
    this.layerService = sceneContainer.layerService;
    this.controlService = sceneContainer.controlService;
    this.configService = sceneContainer.globalConfigService;
    this.scene = sceneContainer.sceneService;
    this.sceneContainer = sceneContainer;
    this.isShow = true;
    this.container = this.onAdd();
    const {
      className,
      style,
      layers,
      rightLayers
    } = this.controlOption;
    if (className) {
      this.setClassName(className);
    }
    if (style) {
      this.setStyle(style);
    }
    this.mapsService.getMarkerContainer().appendChild(this.container);
    this.maskLayer = this.getMaskLayer();
    this.registerEvent();
    const layerContainer = createLayerContainer(sceneContainer);
    this.maskLayer.setContainer(layerContainer);
    this.scene.addLayer(this.maskLayer);
    this.addMaskToLayers(layers, false);
    this.addMaskToLayers(rightLayers, true);
    this.emit("add", this);
    return this;
  }
  onRemove() {
    if (this.maskLayer) {
      var _this$layerService;
      const {
        layers,
        rightLayers
      } = this.controlOption;
      this.removeMaskFromLayers(layers);
      this.removeMaskFromLayers(rightLayers);
      (_this$layerService = this.layerService) === null || _this$layerService === void 0 || _this$layerService.remove(this.maskLayer);
    }
    this.unRegisterEvent();
    this.removeAllListeners();
  }
  show() {
    var _this$scene2;
    const container = this.container;
    dom_exports.removeClass(container, "l7-control-swipe_hide");
    const {
      layers,
      rightLayers
    } = this.controlOption;
    layers.forEach((layer) => layer.enableMask());
    rightLayers.forEach((layer) => layer.enableMask());
    (_this$scene2 = this.scene) === null || _this$scene2 === void 0 || _this$scene2.render();
    this.isShow = true;
    this.emit("show", this);
  }
  hide() {
    var _this$scene3;
    const container = this.container;
    dom_exports.addClass(container, "l7-control-swipe_hide");
    const {
      layers,
      rightLayers
    } = this.controlOption;
    layers.forEach((layer) => layer.disableMask());
    rightLayers.forEach((layer) => layer.disableMask());
    (_this$scene3 = this.scene) === null || _this$scene3 === void 0 || _this$scene3.render();
    this.isShow = false;
    this.emit("hide", this);
  }
  setOptions(newOptions) {
    const controlOption = _objectSpread2(_objectSpread2({}, this.controlOption), newOptions);
    if (newOptions.className) {
      this.setClassName(newOptions.className);
    }
    if (newOptions.style) {
      this.setStyle(newOptions.style);
    }
    if (newOptions.orientation || newOptions.ratio !== void 0) {
      this.setOrientationAndRatio(controlOption.orientation, controlOption.ratio);
    }
    if (newOptions.layers) {
      const newLayers = newOptions.layers;
      const oldLayers = this.controlOption.layers;
      this.setLayers(newLayers, oldLayers, false);
    }
    if (newOptions.rightLayers) {
      const newLayers = newOptions.rightLayers;
      const oldLayers = this.controlOption.rightLayers;
      this.setLayers(newLayers, oldLayers, true);
    }
    this.controlOption = controlOption;
    this.updateMask();
  }
  registerEvent() {
    this.container.addEventListener("mousedown", this.move);
    this.container.addEventListener("touchstart", this.move);
    this.mapsService.on("camerachange", this.updateMask);
  }
  unRegisterEvent() {
    var _this$mapsService;
    this.container.removeEventListener("mousedown", this.move);
    this.container.removeEventListener("touchstart", this.move);
    (_this$mapsService = this.mapsService) === null || _this$mapsService === void 0 || _this$mapsService.off("camerachange", this.updateMask);
  }
  setOrientationAndRatio(orientation = "vertical", ratio = 0.5) {
    this.container.classList.remove("horizontal", "vertical");
    this.container.classList.add(orientation);
    if (orientation === "horizontal") {
      this.container.style.top = ratio * 100 + "%";
      this.container.style.left = "";
    } else {
      this.container.style.left = ratio * 100 + "%";
      this.container.style.top = "";
    }
  }
  setLayers(newLayers, oldLayers, isRightLayer = false) {
    const addLayers = newLayers.filter((layer) => oldLayers.includes(layer) === false);
    const removeLayers = oldLayers.filter((layer) => newLayers.includes(layer) === false);
    this.addMaskToLayers(addLayers, isRightLayer);
    this.removeMaskFromLayers(removeLayers);
  }
  addMaskToLayers(layers, isRightLayer) {
    layers.forEach((layer) => {
      layer.updateLayerConfig({
        maskInside: isRightLayer ? false : true
      });
      layer.addMask(this.maskLayer);
    });
  }
  removeMaskFromLayers(layers) {
    layers.forEach((layer) => {
      layer.updateLayerConfig({
        maskInside: true
      });
      layer.removeMask(this.maskLayer);
    });
  }
  getMaskGeoData() {
    const {
      ratio = 0.5,
      orientation = "vertical"
    } = this.controlOption;
    const isVertical = orientation === "vertical";
    const [sw, ne] = this.getBounds();
    const [swLng, swLat] = sw;
    const [neLng, neLat] = ne;
    let coordinate;
    if (isVertical) {
      const centerLng = swLng + (neLng - swLng) * ratio;
      coordinate = [[swLng, neLat], [centerLng, neLat], [centerLng, swLat], sw, [swLng, neLat]];
    } else {
      const size2 = this.getContainerSize();
      const lngLat = this.mapsService.containerToLngLat([size2[0], size2[1] * ratio]);
      const centerLat = lngLat.lat;
      coordinate = [[swLng, neLat], ne, [neLng, centerLat], [swLng, centerLat], [swLng, neLat]];
    }
    const geoJSON2 = {
      type: "FeatureCollection",
      features: [{
        type: "Feature",
        properties: {},
        geometry: {
          type: "Polygon",
          coordinates: [coordinate]
        }
      }]
    };
    return geoJSON2;
  }
  getContainerDOMRect() {
    var _this$mapsService$get;
    const rect = (_this$mapsService$get = this.mapsService.getContainer()) === null || _this$mapsService$get === void 0 ? void 0 : _this$mapsService$get.getBoundingClientRect();
    return rect;
  }
  getContainerSize() {
    const size2 = this.mapsService.getSize();
    return size2;
  }
  getBounds() {
    const bounds = this.mapsService.getBounds();
    return bounds;
  }
  /**
   * 添加要剪裁的图层
   * @param layer 剪裁的图层
   * @param addRight 是否添加图层到右侧, 默认添加到左侧.
   */
  addLayer(layer, addRight = false) {
    const layers = Array.isArray(layer) ? layer : [layer];
    if (addRight) {
      const rightLayers = this.controlOption.rightLayers.concat(...layers);
      this.setOptions({
        rightLayers
      });
    } else {
      const leftLayers = this.controlOption.layers.concat(...layers);
      this.setOptions({
        layers: leftLayers
      });
    }
  }
  /**
   * 移除剪裁的图层
   */
  removeLayer(layer) {
    const layers = Array.isArray(layer) ? layer : [layer];
    const leftLayers = this.controlOption.layers.filter((layer2) => layers.includes(layer2));
    const rightLayers = this.controlOption.rightLayers.filter((layer2) => layers.includes(layer2));
    this.setOptions({
      layers: leftLayers,
      rightLayers
    });
  }
  /**
   * 清除所有图层
   */
  removeLayers() {
    this.setOptions({
      layers: [],
      rightLayers: []
    });
  }
};

// node_modules/@antv/l7-component/es/control/zoom.js
var Zoom = class extends Control {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "disabled", void 0);
    _defineProperty(this, "zoomInButton", void 0);
    _defineProperty(this, "zoomOutButton", void 0);
    _defineProperty(this, "zoomNumDiv", void 0);
    _defineProperty(this, "zoomIn", () => {
      if (!this.disabled && this.mapsService.getZoom() < this.mapsService.getMaxZoom()) {
        this.mapsService.zoomIn();
      }
    });
    _defineProperty(this, "zoomOut", () => {
      if (!this.disabled && this.mapsService.getZoom() > this.mapsService.getMinZoom()) {
        this.mapsService.zoomOut();
      }
    });
    _defineProperty(this, "updateDisabled", () => {
      const mapsService = this.mapsService;
      this.zoomInButton.removeAttribute("disabled");
      this.zoomOutButton.removeAttribute("disabled");
      if (this.disabled || mapsService.getZoom() <= mapsService.getMinZoom()) {
        this.zoomOutButton.setAttribute("disabled", "true");
      }
      if (this.controlOption.showZoom && this.zoomNumDiv) {
        this.zoomNumDiv.innerText = String(Math.floor(mapsService.getZoom()));
      }
      if (this.disabled || mapsService.getZoom() >= mapsService.getMaxZoom()) {
        this.zoomInButton.setAttribute("disabled", "true");
      }
    });
  }
  getDefault(option) {
    return _objectSpread2(_objectSpread2({}, super.getDefault(option)), {}, {
      position: PositionType.BOTTOMRIGHT,
      name: "zoom",
      zoomInText: createL7Icon("l7-icon-enlarge"),
      zoomInTitle: "Zoom in",
      zoomOutText: createL7Icon("l7-icon-narrow"),
      zoomOutTitle: "Zoom out",
      showZoom: false
    });
  }
  setOptions(newOptions) {
    super.setOptions(newOptions);
    if (this.checkUpdateOption(newOptions, ["zoomInText", "zoomInTitle", "zoomOutText", "zoomOutTitle", "showZoom"])) {
      this.resetButtonGroup(this.container);
    }
  }
  onAdd() {
    const container = dom_exports.create("div", "l7-control-zoom");
    this.resetButtonGroup(container);
    this.mapsService.on("zoomend", this.updateDisabled);
    this.mapsService.on("zoomchange", this.updateDisabled);
    return container;
  }
  onRemove() {
    this.mapsService.off("zoomend", this.updateDisabled);
    this.mapsService.off("zoomchange", this.updateDisabled);
  }
  disable() {
    this.disabled = true;
    this.updateDisabled();
    return this;
  }
  enable() {
    this.disabled = false;
    this.updateDisabled();
    return this;
  }
  resetButtonGroup(container) {
    dom_exports.clearChildren(container);
    this.zoomInButton = this.createButton(this.controlOption.zoomInText, this.controlOption.zoomInTitle, "l7-button-control", container, this.zoomIn);
    if (this.controlOption.showZoom) {
      this.zoomNumDiv = this.createButton("0", "", "l7-button-control l7-control-zoom__number", container);
    }
    this.zoomOutButton = this.createButton(this.controlOption.zoomOutText, this.controlOption.zoomOutTitle, "l7-button-control", container, this.zoomOut);
    this.updateDisabled();
  }
  createButton(html, tile, className, container, fn) {
    const link = dom_exports.create("button", className, container);
    if (typeof html === "string") {
      link.innerHTML = html;
    } else {
      link.append(html);
    }
    link.title = tile;
    if (fn) {
      link.addEventListener("click", fn);
    }
    return link;
  }
};

// node_modules/@antv/l7-component/es/popup/popup.js
var import_eventemitter38 = __toESM(require_eventemitter3());
var Popup = class extends import_eventemitter38.EventEmitter {
  get lngLat() {
    var _this$popupOption$lng;
    return (_this$popupOption$lng = this.popupOption.lngLat) !== null && _this$popupOption$lng !== void 0 ? _this$popupOption$lng : {
      lng: 0,
      lat: 0
    };
  }
  set lngLat(newLngLat) {
    this.popupOption.lngLat = newLngLat;
  }
  constructor(cfg) {
    super();
    _defineProperty(this, "popupOption", void 0);
    _defineProperty(this, "mapsService", void 0);
    _defineProperty(this, "sceneService", void 0);
    _defineProperty(this, "layerService", void 0);
    _defineProperty(this, "scene", void 0);
    _defineProperty(this, "closeButton", void 0);
    _defineProperty(this, "container", void 0);
    _defineProperty(this, "content", void 0);
    _defineProperty(this, "contentTitle", void 0);
    _defineProperty(this, "contentPanel", void 0);
    _defineProperty(this, "tip", void 0);
    _defineProperty(this, "isShow", true);
    _defineProperty(this, "onMouseMove", (e) => {
      var _container$getBoundin;
      const container = this.mapsService.getMapContainer();
      const {
        left = 0,
        top = 0
      } = (_container$getBoundin = container === null || container === void 0 ? void 0 : container.getBoundingClientRect()) !== null && _container$getBoundin !== void 0 ? _container$getBoundin : {};
      this.setPopupPosition(e.clientX - left, e.clientY - top);
    });
    _defineProperty(this, "updateLngLatPosition", () => {
      if (!this.mapsService || this.popupOption.followCursor) {
        return;
      }
      const {
        lng,
        lat
      } = this.lngLat;
      const {
        x,
        y
      } = this.mapsService.lngLatToContainer([lng, lat]);
      this.setPopupPosition(x, y);
    });
    _defineProperty(this, "updateLngLatPositionWhenZoom", (ev) => {
      if (!this.mapsService || this.popupOption.followCursor) {
        return;
      }
      const map8 = ev.map;
      const viewHalf = map8.getSize();
      viewHalf.x = viewHalf.x / 2;
      viewHalf.y = viewHalf.y / 2;
      const center = ev.center;
      const zoom = ev.zoom;
      const projectedCenter = map8.DE(this.lngLat, zoom, center);
      projectedCenter.x = Math.round(projectedCenter.x);
      projectedCenter.y = Math.round(projectedCenter.y);
      this.setPopupPosition(projectedCenter.x, projectedCenter.y, true);
    });
    _defineProperty(this, "onKeyDown", (e) => {
      if (e.keyCode === 27) {
        this.remove();
      }
    });
    _defineProperty(this, "onCloseButtonClick", (e) => {
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      this.hide();
    });
    _defineProperty(this, "updatePosition", (ev, zoom = true) => {
      const hasPosition = !!this.lngLat;
      const {
        className,
        style,
        maxWidth,
        anchor,
        stopPropagation
      } = this.popupOption;
      if (!this.mapsService || !hasPosition || !this.content) {
        return;
      }
      const popupContainer = this.mapsService.getMarkerContainer();
      if (!this.container && popupContainer) {
        this.container = dom_exports.create("div", `l7-popup ${className !== null && className !== void 0 ? className : ""} ${!this.isShow ? "l7-popup-hide" : ""}`, popupContainer);
        if (style) {
          this.container.setAttribute("style", style);
        }
        this.tip = dom_exports.create("div", "l7-popup-tip", this.container);
        this.container.appendChild(this.content);
        if (stopPropagation) {
          ["mousemove", "mousedown", "mouseup", "click", "dblclick"].forEach((type) => {
            this.container.addEventListener(type, (e) => {
              e.stopPropagation();
            });
          });
        }
        this.container.style.whiteSpace = "nowrap";
      }
      if (zoom) {
        this.updateLngLatPositionWhenZoom(ev);
      } else {
        this.updateLngLatPosition();
      }
      dom_exports.setTransform(this.container, `${anchorTranslate[anchor]}`);
      applyAnchorClass(this.container, anchor, "popup");
      if (maxWidth) {
        const {
          width
        } = this.container.getBoundingClientRect();
        if (width > parseFloat(maxWidth)) {
          this.container.style.width = maxWidth;
        }
      } else {
        this.container.style.removeProperty("width");
      }
    });
    _defineProperty(this, "updateWhenZoom", (ev) => {
      this.updatePosition(ev, true);
    });
    _defineProperty(this, "update", () => {
      this.updatePosition(null, false);
    });
    this.popupOption = _objectSpread2(_objectSpread2({}, this.getDefault(cfg !== null && cfg !== void 0 ? cfg : {})), cfg);
    const {
      lngLat
    } = this.popupOption;
    if (lngLat) {
      this.lngLat = lngLat;
    }
  }
  getIsShow() {
    return this.isShow;
  }
  addTo(scene) {
    this.mapsService = scene.mapService;
    this.sceneService = scene.sceneService;
    this.layerService = scene.layerService;
    this.mapsService.on("camerachange", this.update);
    this.mapsService.on("viewchange", this.update);
    this.scene = scene;
    this.update();
    this.updateCloseOnClick();
    this.updateCloseOnEsc();
    this.updateFollowCursor();
    const {
      html,
      text,
      title
    } = this.popupOption;
    if (html) {
      this.setHTML(html);
    } else if (text) {
      this.setText(text);
    }
    if (title) {
      this.setTitle(title);
    }
    this.emit("open");
    return this;
  }
  // 移除popup
  remove() {
    if (!(this !== null && this !== void 0 && this.isOpen())) {
      return;
    }
    if (this.content) {
      dom_exports.remove(this.content);
    }
    if (this.container) {
      dom_exports.remove(this.container);
      delete this.container;
    }
    if (this.mapsService) {
      this.mapsService.off("camerachange", this.update);
      this.mapsService.off("viewchange", this.update);
      this.updateCloseOnClick(true);
      this.updateCloseOnEsc(true);
      this.updateFollowCursor(true);
      delete this.mapsService;
    }
    this.emit("close");
    return this;
  }
  /**
   * 获取 option 配置
   */
  getOptions() {
    return this.popupOption;
  }
  setOptions(option) {
    this.show();
    const {
      className: oldClassName
    } = this.popupOption;
    this.popupOption = _objectSpread2(_objectSpread2({}, this.popupOption), option);
    if (this.checkUpdateOption(option, ["html", "text", "title", "closeButton", "closeButtonOffsets", "maxWidth", "anchor", "stopPropagation", "lngLat", "offsets"])) {
      if (this.container) {
        dom_exports.remove(this.container);
        this.container = void 0;
      }
      if (this.popupOption.html) {
        this.setHTML(this.popupOption.html);
      } else if (this.popupOption.text) {
        this.setText(this.popupOption.text);
      }
      if (this.popupOption.title) {
        this.setTitle(this.popupOption.title);
      }
    }
    if (this.checkUpdateOption(option, ["closeOnEsc"])) {
      this.updateCloseOnEsc();
    }
    if (this.checkUpdateOption(option, ["closeOnClick"])) {
      this.updateCloseOnClick();
    }
    if (this.checkUpdateOption(option, ["followCursor"])) {
      this.updateFollowCursor();
    }
    if (this.checkUpdateOption(option, ["html"]) && option.html) {
      this.setHTML(option.html);
    } else if (this.checkUpdateOption(option, ["text"]) && option.text) {
      this.setText(option.text);
    }
    if (this.checkUpdateOption(option, ["className"])) {
      var _option$className;
      if (oldClassName) {
        this.container.classList.remove(oldClassName !== null && oldClassName !== void 0 ? oldClassName : "");
      }
      this.container.classList.add((_option$className = option.className) !== null && _option$className !== void 0 ? _option$className : "");
    }
    if (this.checkUpdateOption(option, ["style"])) {
      var _option$style;
      dom_exports.addStyle(this.container, (_option$style = option.style) !== null && _option$style !== void 0 ? _option$style : "");
    }
    if (this.checkUpdateOption(option, ["lngLat"]) && option.lngLat) {
      this.setLnglat(option.lngLat);
    }
    return this;
  }
  open() {
    this.addTo(this.scene);
    return this;
  }
  close() {
    this.remove();
    return this;
  }
  show() {
    if (this.isShow) {
      return;
    }
    if (this.container) {
      dom_exports.removeClass(this.container, "l7-popup-hide");
    }
    this.isShow = true;
    this.emit("show");
    return this;
  }
  hide() {
    if (!this.isShow) {
      return;
    }
    if (this.container) {
      dom_exports.addClass(this.container, "l7-popup-hide");
    }
    this.isShow = false;
    this.emit("hide");
    return this;
  }
  /**
   * 设置 HTML 内容
   * @param html
   */
  setHTML(html) {
    this.popupOption.html = html;
    return this.setDOMContent(html);
  }
  /**
   * 设置 Popup 展示文本
   * @param text
   */
  setText(text) {
    this.popupOption.text = text;
    return this.setDOMContent(window.document.createTextNode(text));
  }
  setTitle(title) {
    this.show();
    this.popupOption.title = title;
    if (title) {
      if (!this.contentTitle) {
        this.contentTitle = dom_exports.create("div", "l7-popup-content__title");
        if (this.content.firstChild) {
          this.content.insertBefore(this.contentTitle, this.content.firstChild);
        } else {
          this.content.append(this.contentTitle);
        }
      }
      dom_exports.clearChildren(this.contentTitle);
      dom_exports.appendElementType(this.contentTitle, title);
    } else if (this.contentTitle) {
      dom_exports.remove(this.contentTitle);
      this.contentTitle = void 0;
    }
  }
  /**
   * 将地图自动平移到气泡位置
   */
  panToPopup() {
    const {
      lng,
      lat
    } = this.lngLat;
    if (this.popupOption.autoPan) {
      this.mapsService.panTo([lng, lat]);
    }
    return this;
  }
  setLngLat(lngLat) {
    return this.setLnglat(lngLat);
  }
  /**
   * 设置 Popup 所在经纬度
   * @param lngLat
   */
  setLnglat(lngLat) {
    this.show();
    this.lngLat = lngLat;
    if (Array.isArray(lngLat)) {
      this.lngLat = {
        lng: lngLat[0],
        lat: lngLat[1]
      };
    }
    if (this.mapsService) {
      this.mapsService.off("camerachange", this.update);
      this.mapsService.off("viewchange", this.update);
      this.mapsService.on("camerachange", this.update);
      this.mapsService.on("viewchange", this.update);
    }
    this.update();
    if (this.popupOption.autoPan) {
      setTimeout(() => {
        this.panToPopup();
      }, 0);
    }
    return this;
  }
  /**
   * 获取 Popup 所在经纬度
   */
  getLnglat() {
    return this.lngLat;
  }
  /**
   * 设置 Popup 最大宽度
   * @param maxWidth
   */
  setMaxWidth(maxWidth) {
    this.popupOption.maxWidth = maxWidth;
    this.update();
    return this;
  }
  isOpen() {
    return !!this.mapsService;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getDefault(option) {
    return {
      closeButton: true,
      closeOnClick: false,
      maxWidth: "240px",
      offsets: [0, 0],
      anchor: anchorType.BOTTOM,
      stopPropagation: true,
      autoPan: false,
      autoClose: true,
      closeOnEsc: false,
      followCursor: false
    };
  }
  /**
   * 设置 Popup 内容 HTML
   * @param element
   */
  setDOMContent(element) {
    this.show();
    this.createContent();
    dom_exports.appendElementType(this.contentPanel, element);
    this.update();
    return this;
  }
  /**
   * 绑定地图点击事件触发销毁 Popup
   * @protected
   */
  updateCloseOnClick(onlyClear) {
    const mapsService = this.mapsService;
    if (mapsService) {
      mapsService === null || mapsService === void 0 || mapsService.off("click", this.onCloseButtonClick);
      if (this.popupOption.closeOnClick && !onlyClear) {
        requestAnimationFrame(() => {
          mapsService === null || mapsService === void 0 || mapsService.on("click", this.onCloseButtonClick);
        });
      }
    }
  }
  updateCloseOnEsc(onlyClear) {
    window.removeEventListener("keydown", this.onKeyDown);
    if (this.popupOption.closeOnEsc && !onlyClear) {
      window.addEventListener("keydown", this.onKeyDown);
    }
  }
  updateFollowCursor(onlyClear) {
    var _this$mapsService;
    const container = (_this$mapsService = this.mapsService) === null || _this$mapsService === void 0 ? void 0 : _this$mapsService.getContainer();
    if (container) {
      container === null || container === void 0 || container.removeEventListener("mousemove", this.onMouseMove);
      if (this.popupOption.followCursor && !onlyClear) {
        container === null || container === void 0 || container.addEventListener("mousemove", this.onMouseMove);
      }
    }
  }
  /**
   * 创建 Popup 内容容器的 DOM （在每次 setHTML 或 setText 时都会被调用）
   * @protected
   */
  createContent() {
    if (this.content) {
      dom_exports.remove(this.content);
    }
    this.contentTitle = void 0;
    this.content = dom_exports.create("div", "l7-popup-content", this.container);
    this.setTitle(this.popupOption.title);
    if (this.popupOption.closeButton) {
      const closeButton = createL7Icon("l7-icon-guanbi");
      dom_exports.addClass(closeButton, "l7-popup-close-button");
      this.content.appendChild(closeButton);
      if (this.popupOption.closeButtonOffsets) {
        closeButton.style.right = this.popupOption.closeButtonOffsets[0] + "px";
        closeButton.style.top = this.popupOption.closeButtonOffsets[1] + "px";
      }
      closeButton.setAttribute("aria-label", "Close popup");
      closeButton.addEventListener("click", () => {
        this.hide();
      });
      closeButton.addEventListener("pointerup", (e) => {
        e.stopPropagation();
      });
      closeButton.addEventListener("pointerdown", (e) => {
        e.stopPropagation();
      });
      this.closeButton = closeButton;
    } else {
      this.closeButton = void 0;
    }
    this.contentPanel = dom_exports.create("div", "l7-popup-content__panel", this.content);
  }
  /**
   * 设置 Popup 相对于地图容器的 Position
   * @param {Number} left
   * @param {Number} top
   * @param {Boolean} [useTransition=false] 是否使用过度效果
   * @protected
   */
  setPopupPosition(left, top, useTransition = false) {
    if (this.container) {
      const {
        offsets
      } = this.popupOption;
      this.container.style.left = left + offsets[0] + "px";
      this.container.style.top = top - offsets[1] + "px";
      if (useTransition) {
        this.container.style.transition = "left 0.25s cubic-bezier(0,0,0.25,1), top 0.25s cubic-bezier(0,0,0.25,1)";
      } else {
        this.container.style.transition = "";
      }
    }
  }
  /**
   * 检查当前传入 option 是否包含 keys 字段
   * @param option
   * @param keys
   * @protected
   */
  checkUpdateOption(option, keys) {
    return keys.some((key) => key in option);
  }
};

// node_modules/@antv/l7-component/es/popup/layerPopup.js
var {
  get
} = lodashUtil;
var LayerPopup = class extends Popup {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "layerClickCountByFrame", 0);
    _defineProperty(this, "layerConfigMap", /* @__PURE__ */ new WeakMap());
    _defineProperty(this, "displayFeatureInfo", void 0);
    _defineProperty(this, "onLayerClick", (layer, e) => {
      requestAnimationFrame(() => {
        if (this.popupOption.closeOnClick) {
          this.layerClickCountByFrame++;
        }
        if (this.isShow && this.isSameFeature(layer, e.featureId)) {
          this.hide();
        } else {
          const {
            title,
            content
          } = this.getLayerInfoFrag(layer, e);
          this.setDOMContent(content);
          this.setLnglat(e.lngLat);
          this.setTitle(title);
          this.setDisplayFeatureInfo({
            layer,
            featureId: e.featureId
          });
          this.show();
        }
      });
    });
    _defineProperty(this, "onSceneClick", () => {
      this.layerClickCountByFrame = 0;
      requestAnimationFrame(() => {
        if (!this.layerClickCountByFrame) {
          this.hide();
        }
      });
    });
    _defineProperty(this, "onLayerHide", () => {
      this.hide();
      this.setDisplayFeatureInfo(void 0);
    });
    _defineProperty(this, "updateCloseOnClick", () => {
    });
  }
  get layerConfigItems() {
    var _ref;
    const {
      config,
      items
    } = this.popupOption;
    return (_ref = config !== null && config !== void 0 ? config : items) !== null && _ref !== void 0 ? _ref : [];
  }
  addTo(scene) {
    super.addTo(scene);
    this.bindLayerEvent();
    this.hide();
    return this;
  }
  remove() {
    super.remove();
    this.unbindLayerEvent();
    return this;
  }
  setOptions(option) {
    this.unbindLayerEvent();
    const newOption = _objectSpread2({}, option);
    const trigger = newOption.trigger || this.popupOption.trigger;
    const items = newOption.items || this.popupOption.items;
    const isEmptyItems = (items === null || items === void 0 ? void 0 : items.length) === 0;
    newOption.followCursor = trigger === "hover" && !isEmptyItems;
    const isShow = this.isShow;
    super.setOptions(newOption);
    this.bindLayerEvent();
    if (isEmptyItems || !isShow) {
      this.hide();
    }
    return this;
  }
  getDefault(option) {
    const isHoverTrigger = option.trigger !== "click";
    return _objectSpread2(_objectSpread2({}, super.getDefault(option)), {}, {
      trigger: "hover",
      followCursor: isHoverTrigger,
      lngLat: {
        lng: 0,
        lat: 0
      },
      offsets: [0, 10],
      closeButton: false,
      closeOnClick: true,
      autoClose: false,
      closeOnEsc: false
    });
  }
  /**
   * 绑定对应的图层事件
   * @protected
   */
  bindLayerEvent() {
    const {
      trigger,
      closeOnClick
    } = this.popupOption;
    this.layerConfigItems.forEach((configItem) => {
      var _layer$getSource;
      const layer = this.getLayerByConfig(configItem);
      if (!layer) {
        return;
      }
      const layerInfo = _objectSpread2({}, configItem);
      if (trigger === "hover") {
        const onMouseMove = this.onLayerMouseMove.bind(this, layer);
        const onMouseOut = this.onLayerMouseOut.bind(this, layer);
        layerInfo.onMouseMove = onMouseMove;
        layerInfo.onMouseOut = onMouseOut;
        layer === null || layer === void 0 || layer.on("mousemove", onMouseMove);
        layer === null || layer === void 0 || layer.on("mouseout", onMouseOut);
      } else {
        var _this$mapsService;
        const onLayerClick = this.onLayerClick.bind(this, layer);
        layerInfo.onClick = onLayerClick;
        layer === null || layer === void 0 || layer.on("click", onLayerClick);
        const mapContainer = (_this$mapsService = this.mapsService) === null || _this$mapsService === void 0 ? void 0 : _this$mapsService.getMapContainer();
        if (mapContainer && closeOnClick) {
          mapContainer.addEventListener("click", this.onSceneClick);
        }
      }
      const source = layer === null || layer === void 0 || (_layer$getSource = layer.getSource) === null || _layer$getSource === void 0 ? void 0 : _layer$getSource.call(layer);
      const onSourceUpdate = this.onSourceUpdate.bind(this);
      source === null || source === void 0 || source.on("update", onSourceUpdate);
      layerInfo.onSourceUpdate = onSourceUpdate;
      this.layerConfigMap.set(layer, layerInfo);
    });
  }
  /**
   * 解绑对应的图层事件
   * @protected
   */
  unbindLayerEvent() {
    this.layerConfigItems.forEach((configItem) => {
      var _this$mapsService2;
      const layer = this.getLayerByConfig(configItem);
      const layerInfo = layer && this.layerConfigMap.get(layer);
      if (!layerInfo) {
        return;
      }
      const {
        onMouseMove,
        onMouseOut,
        onClick,
        onSourceUpdate
      } = layerInfo;
      if (onMouseMove) {
        layer.off("mousemove", onMouseMove);
      }
      if (onMouseOut) {
        layer.off("mouseout", onMouseOut);
      }
      if (onClick) {
        layer.off("click", onClick);
      }
      if (onSourceUpdate) {
        var _layer$getSource2;
        layer === null || layer === void 0 || (_layer$getSource2 = layer.getSource()) === null || _layer$getSource2 === void 0 || _layer$getSource2.off("update", onSourceUpdate);
      }
      const mapContainer = (_this$mapsService2 = this.mapsService) === null || _this$mapsService2 === void 0 ? void 0 : _this$mapsService2.getMapContainer();
      if (mapContainer) {
        mapContainer.removeEventListener("click", this.onSceneClick);
      }
    });
  }
  onLayerMouseMove(layer, e) {
    if (!this.isSameFeature(layer, e.featureId)) {
      const {
        title,
        content
      } = this.getLayerInfoFrag(layer, e);
      this.setDOMContent(content);
      this.setTitle(title);
      this.setDisplayFeatureInfo({
        layer,
        featureId: e.featureId
      });
      this.show();
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onLayerMouseOut(layer, e) {
    this.setDisplayFeatureInfo(void 0);
    if (this.isShow) {
      this.hide();
    }
  }
  onSourceUpdate() {
    this.hide();
    this.setDisplayFeatureInfo(void 0);
  }
  /**
   * 通过当前图层和对应选中的元素获取气泡展示的 HTML 内容
   * @param layer
   * @param e
   * @protected
   */
  getLayerInfoFrag(layer, e) {
    const layerInfo = this.layerConfigMap.get(layer);
    let titleFrag;
    const contentFrag = document.createDocumentFragment();
    if (layerInfo) {
      let feature = e.feature;
      if (feature.type === "Feature" && "properties" in feature && "geometry" in feature) {
        feature = feature.properties;
      }
      const {
        title,
        fields,
        customContent
      } = layerInfo;
      if (title) {
        titleFrag = document.createDocumentFragment();
        const titleElement = title instanceof Function ? title(feature) : title;
        dom_exports.appendElementType(titleFrag, titleElement);
      }
      if (customContent) {
        const content = customContent instanceof Function ? customContent(feature) : customContent;
        dom_exports.appendElementType(contentFrag, content);
      } else if (fields !== null && fields !== void 0 && fields.length) {
        fields === null || fields === void 0 || fields.forEach((fieldConfig) => {
          var _ref2, _ref3;
          const {
            field,
            formatField,
            formatValue,
            getValue
          } = typeof fieldConfig === "string" ? (
            // tslint:disable-next-line:no-object-literal-type-assertion
            {
              field: fieldConfig
            }
          ) : fieldConfig;
          const row = dom_exports.create("div", "l7-layer-popup__row");
          const value = getValue ? getValue(e.feature) : get(feature, field);
          const fieldElement = (_ref2 = formatField instanceof Function ? formatField(field, feature) : formatField) !== null && _ref2 !== void 0 ? _ref2 : field;
          let valueElement = (_ref3 = formatValue instanceof Function ? formatValue(value, feature) : formatValue) !== null && _ref3 !== void 0 ? _ref3 : value;
          const fieldSpan = dom_exports.create("span", "l7-layer-popup__key", row);
          dom_exports.appendElementType(fieldSpan, fieldElement);
          dom_exports.appendElementType(fieldSpan, document.createTextNode("："));
          const valueSpan = dom_exports.create("span", "l7-layer-popup__value", row);
          if (Array.isArray(valueElement) && valueElement.every((item) => !(item instanceof Object))) {
            valueElement = valueElement.map((item) => String(item)).join(",");
          }
          dom_exports.appendElementType(valueSpan, valueElement);
          contentFrag.appendChild(row);
        });
      }
    }
    return {
      title: titleFrag,
      content: contentFrag
    };
  }
  /**
   * 通过 Layer 配置访问到真实的 Layer 实例
   * @param configItem
   * @protected
   */
  getLayerByConfig(configItem) {
    const layer = configItem.layer;
    if (layer instanceof Object) {
      return layer;
    }
    if (typeof layer === "string") {
      return this.layerService.getLayer(layer) || this.layerService.getLayerByName(layer);
    }
  }
  /**
   * 判断当前展示的 Feature 是否和上一次查看的一致
   * @param layer
   * @param featureId
   * @protected
   */
  isSameFeature(layer, featureId) {
    const displayFeatureInfo = this.displayFeatureInfo;
    return displayFeatureInfo && layer === displayFeatureInfo.layer && featureId === displayFeatureInfo.featureId;
  }
  setDisplayFeatureInfo(displayFeatureInfo) {
    const oldDisplayFeatureInfo = this.displayFeatureInfo;
    if (oldDisplayFeatureInfo) {
      oldDisplayFeatureInfo.layer.off("hide", this.onLayerHide);
    }
    if (displayFeatureInfo) {
      displayFeatureInfo.layer.on("hide", this.onLayerHide);
    }
    this.displayFeatureInfo = displayFeatureInfo;
  }
};

// node_modules/@antv/l7-component/es/index.js
function loadStyles(css, doc) {
  var isMiniAli = typeof my !== "undefined" && !!my && typeof my.showToast === "function" && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== "undefined" && wx !== null && (typeof wx.request !== "undefined" || typeof wx.miniProgram !== "undefined");
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc)
    doc = document;
  if (!doc) {
    return;
  }
  var head2 = doc.head || doc.getElementsByTagName("head")[0];
  if (!head2) {
    head2 = doc.createElement("head");
    var body = doc.body || doc.getElementsByTagName("body")[0];
    if (body) {
      body.parentNode.insertBefore(head2, body);
    } else {
      doc.documentElement.appendChild(head2);
    }
  }
  var style = doc.createElement("style");
  style.type = "text/css";
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head2.appendChild(style);
  return style;
}
loadStyles(`.l7-marker-container {
  position: absolute;
  width: 100%;
  height: 100%;
  overflow: hidden;
}
.l7-marker {
  position: absolute !important;
  top: 0;
  left: 0;
  z-index: 5;
  cursor: pointer;
}
.l7-marker-cluster {
  width: 40px;
  height: 40px;
  background-color: rgba(181, 226, 140, 0.6);
  background-clip: padding-box;
  border-radius: 20px;
}
.l7-marker-cluster div {
  width: 30px;
  height: 30px;
  margin-top: 5px;
  margin-left: 5px;
  font:
    12px 'Helvetica Neue',
    Arial,
    Helvetica,
    sans-serif;
  text-align: center;
  background-color: rgba(110, 204, 57, 0.6);
  border-radius: 15px;
}
.l7-marker-cluster span {
  line-height: 30px;
}
.l7-touch .l7-control-attribution,
.l7-touch .l7-control-layers,
.l7-touch .l7-bar {
  box-shadow: none;
}
.l7-touch .l7-control-layers,
.l7-touch .l7-bar {
  background-clip: padding-box;
  border: 2px solid rgba(0, 0, 0, 0.2);
}
.mapboxgl-ctrl-logo,
.amap-logo {
  display: none !important;
}
.l7-select-box {
  border: 3px dashed gray;
  border-radius: 2px;
  position: absolute;
  z-index: 999;
  box-sizing: border-box;
}
.l7-control-container {
  font:
    12px/1.5 'Helvetica Neue',
    Arial,
    Helvetica,
    sans-serif;
}
.l7-control-container .l7-control {
  position: relative;
  z-index: 999;
  float: left;
  clear: both;
  color: #595959;
  font-size: 12px;
  pointer-events: visiblePainted;
  /* IE 9-10 doesn't have auto */
  pointer-events: auto;
}
.l7-control-container .l7-control.l7-control--hide {
  display: none;
}
.l7-control-container .l7-top {
  top: 0;
  display: flex;
  position: absolute;
  z-index: 999;
  pointer-events: none;
}
.l7-control-container .l7-top .l7-control:not(.l7-control--hide) {
  margin-top: 8px;
}
.l7-control-container .l7-right {
  right: 0;
  display: flex;
  position: absolute;
  z-index: 999;
  pointer-events: none;
}
.l7-control-container .l7-right .l7-control:not(.l7-control--hide) {
  margin-right: 8px;
}
.l7-control-container .l7-bottom {
  bottom: 0;
  display: flex;
  position: absolute;
  z-index: 999;
  pointer-events: none;
}
.l7-control-container .l7-bottom .l7-control:not(.l7-control--hide) {
  margin-bottom: 8px;
}
.l7-control-container .l7-left {
  left: 0;
  display: flex;
  position: absolute;
  z-index: 999;
  pointer-events: none;
}
.l7-control-container .l7-left .l7-control:not(.l7-control--hide) {
  margin-left: 8px;
}
.l7-control-container .l7-center {
  position: absolute;
  display: flex;
  justify-content: center;
}
.l7-control-container .l7-center.l7-top,
.l7-control-container .l7-center.l7-bottom {
  width: 100%;
}
.l7-control-container .l7-center.l7-left,
.l7-control-container .l7-center.l7-right {
  height: 100%;
}
.l7-control-container .l7-center .l7-control {
  margin-right: 8px;
  margin-bottom: 8px;
}
.l7-control-container .l7-row {
  flex-direction: row;
}
.l7-control-container .l7-row.l7-top {
  align-items: flex-start;
}
.l7-control-container .l7-row.l7-bottom {
  align-items: flex-end;
}
.l7-control-container .l7-column {
  flex-direction: column;
}
.l7-control-container .l7-column.l7-left {
  align-items: flex-start;
}
.l7-control-container .l7-column.l7-right {
  align-items: flex-end;
}
.l7-button-control {
  min-width: 28px;
  height: 28px;
  background-color: #fff;
  border-width: 0;
  border-radius: 2px;
  outline: 0;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0 6px;
  box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.15);
  line-height: 16px;
}
.l7-button-control .l7-iconfont {
  fill: #595959;
  color: #595959;
  width: 16px;
  height: 16px;
}
.l7-button-control.l7-button-control--row {
  padding: 0 16px 0 13px;
}
.l7-button-control.l7-button-control--row * + .l7-button-control__text {
  margin-left: 8px;
}
.l7-button-control.l7-button-control--column {
  height: 44px;
  flex-direction: column;
}
.l7-button-control.l7-button-control--column .l7-iconfont {
  margin-top: 3px;
}
.l7-button-control.l7-button-control--column .l7-button-control__text {
  margin-top: 3px;
  font-size: 10px;
  -webkit-transform: scale(0.83333);
          transform: scale(0.83333);
}
.l7-button-control:not(:disabled):hover {
  background-color: #f3f3f3;
}
.l7-button-control:not(:disabled):active {
  background-color: #f3f3f3;
}
.l7-button-control:disabled {
  background-color: #fafafa;
  color: #bdbdbd;
  cursor: not-allowed;
}
.l7-button-control:disabled .l7-iconfont {
  fill: #bdbdbd;
  color: #bdbdbd;
}
.l7-button-control:disabled:hover {
  background-color: #fafafa;
}
.l7-button-control:disabled:active {
  background-color: #fafafa;
}
.l7-popper {
  position: absolute;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 5;
  color: #595959;
}
.l7-popper.l7-popper-hide {
  display: none;
}
.l7-popper .l7-popper-content {
  min-height: 28px;
  background: #fff;
  border-radius: 2px;
  box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.15);
}
.l7-popper .l7-popper-arrow {
  width: 0;
  height: 0;
  border-width: 4px;
  border-style: solid;
  border-top-color: transparent;
  border-bottom-color: transparent;
  border-left-color: transparent;
  border-right-color: transparent;
  box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.15);
}
.l7-popper.l7-popper-left {
  flex-direction: row;
}
.l7-popper.l7-popper-left .l7-popper-arrow {
  border-left-color: #fff;
  margin: 10px 0;
}
.l7-popper.l7-popper-right {
  flex-direction: row-reverse;
}
.l7-popper.l7-popper-right .l7-popper-arrow {
  border-right-color: #fff;
  margin: 10px 0;
}
.l7-popper.l7-popper-top {
  flex-direction: column;
}
.l7-popper.l7-popper-top .l7-popper-arrow {
  border-top-color: #fff;
  margin: 0 10px;
}
.l7-popper.l7-popper-bottom {
  flex-direction: column-reverse;
}
.l7-popper.l7-popper-bottom .l7-popper-arrow {
  border-bottom-color: #fff;
  margin: 0 10px;
}
.l7-popper.l7-popper-start {
  align-items: flex-start;
}
.l7-popper.l7-popper-end {
  align-items: flex-end;
}
.l7-select-control--normal {
  padding: 4px 0;
}
.l7-select-control--normal .l7-select-control-item {
  display: flex;
  align-items: center;
  height: 24px;
  padding: 0 16px;
  font-size: 12px;
  line-height: 24px;
}
.l7-select-control--normal .l7-select-control-item > * + * {
  margin-left: 6px;
}
.l7-select-control--normal .l7-select-control-item input[type='checkbox'] {
  width: 14px;
  height: 14px;
}
.l7-select-control--normal .l7-select-control-item:hover {
  background-color: #f3f3f3;
}
.l7-select-control--image {
  display: flex;
  flex-wrap: wrap;
  align-items: flex-start;
  box-sizing: content-box;
  max-width: 460px;
  max-height: 400px;
  margin: 12px 0 0 12px;
  overflow-x: hidden;
  overflow-y: auto;
}
.l7-select-control--image .l7-select-control-item {
  position: relative;
  display: flex;
  flex: 0 0 calc((100% - (12px + 9px) * 2) / 3);
  flex-direction: column;
  justify-content: center;
  box-sizing: content-box;
  margin-right: 12px;
  margin-bottom: 12px;
  overflow: hidden;
  font-size: 12px;
  border: 1px solid #fff;
  border-radius: 2px;
}
.l7-select-control--image .l7-select-control-item img {
  width: 100%;
  height: 80px;
}
.l7-select-control--image .l7-select-control-item input[type='checkbox'] {
  position: absolute;
  top: 0;
  right: 0;
}
.l7-select-control--image .l7-select-control-item .l7-select-control-item-row {
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 26px;
}
.l7-select-control--image .l7-select-control-item .l7-select-control-item-row > * + * {
  margin-left: 8px;
}
.l7-select-control--image .l7-select-control-item.l7-select-control-item-active {
  border-color: #0370fe;
}
.l7-select-control-item {
  cursor: pointer;
}
.l7-select-control-item input[type='checkbox'] {
  margin: 0;
  cursor: pointer;
}
.l7-select-control--multiple .l7-select-control-item:hover {
  background-color: transparent;
}
.l7-control-logo {
  width: 89px;
  height: 16px;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}
.l7-control-logo img {
  height: 100%;
  width: 100%;
}
.l7-control-logo .l7-control-logo-link {
  display: block;
  cursor: pointer;
}
.l7-control-logo .l7-control-logo-link img {
  cursor: pointer;
}
.l7-control-mouse-location {
  background-color: #fff;
  border-radius: 2px;
  box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.15);
  padding: 2px 4px;
  min-width: 130px;
}
.l7-control-zoom {
  overflow: hidden;
  border-radius: 2px;
  box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.15);
}
.l7-control-zoom .l7-button-control {
  font-size: 16px;
  border-bottom: 1px solid #f0f0f0;
  border-radius: 0;
  box-shadow: 0 0 0;
}
.l7-control-zoom .l7-button-control .l7-iconfont {
  width: 14px;
  height: 14px;
}
.l7-control-zoom .l7-button-control:last-child {
  border-bottom: 0;
}
.l7-control-zoom .l7-control-zoom__number {
  color: #595959;
  padding: 0;
}
.l7-control-zoom .l7-control-zoom__number:hover {
  background-color: #fff;
}
.l7-control-scale {
  display: flex;
  flex-direction: column;
}
.l7-control-scale .l7-control-scale-line {
  box-sizing: border-box;
  padding: 2px 5px 1px;
  overflow: hidden;
  color: #595959;
  font-size: 10px;
  line-height: 1.1;
  white-space: nowrap;
  background: #fff;
  border: 2px solid #000;
  border-top: 0;
  transition: width 0.1s;
}
.l7-control-scale .l7-control-scale-line + .l7-control-scale .l7-control-scale-line {
  margin-top: -2px;
  border-top: 2px solid #777;
  border-bottom: none;
}
.l7-right .l7-control-scale {
  display: flex;
  align-items: flex-end;
}
.l7-right .l7-control-scale .l7-control-scale-line {
  text-align: right;
}
.l7-popup {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 5;
  display: flex;
  will-change: transform;
  pointer-events: none;
}
.l7-popup.l7-popup-hide {
  display: none;
}
.l7-popup .l7-popup-content {
  position: relative;
  padding: 16px;
  font-size: 14px;
  background: #fff;
  border-radius: 3px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}
.l7-popup .l7-popup-content .l7-popup-content__title {
  margin-bottom: 8px;
  font-weight: bold;
}
.l7-popup .l7-popup-content .l7-popup-close-button,
.l7-popup .l7-popup-content .l7-popup-content__title,
.l7-popup .l7-popup-content .l7-popup-content__panel {
  white-space: normal;
  -webkit-user-select: text;
     -moz-user-select: text;
      -ms-user-select: text;
          user-select: text;
  pointer-events: initial;
}
.l7-popup .l7-popup-content .l7-popup-close-button {
  position: absolute;
  top: 0;
  right: 0;
  width: 18px;
  height: 18px;
  padding: 0;
  font-size: 14px;
  line-height: 18px;
  text-align: center;
  background-color: transparent;
  border: 0;
  border-radius: 0 3px 0 0;
  cursor: pointer;
}
.l7-popup .l7-popup-tip {
  position: relative;
  z-index: 1;
  width: 0;
  height: 0;
  border: 10px solid transparent;
}
.l7-popup.l7-popup-anchor-bottom,
.l7-popup.l7-popup-anchor-bottom-left,
.l7-popup.l7-popup-anchor-bottom-right {
  flex-direction: column-reverse;
}
.l7-popup.l7-popup-anchor-bottom .l7-popup-tip,
.l7-popup.l7-popup-anchor-bottom-left .l7-popup-tip,
.l7-popup.l7-popup-anchor-bottom-right .l7-popup-tip {
  bottom: 1px;
}
.l7-popup.l7-popup-anchor-top,
.l7-popup.l7-popup-anchor-top-left,
.l7-popup.l7-popup-anchor-top-right {
  flex-direction: column;
}
.l7-popup.l7-popup-anchor-top .l7-popup-tip,
.l7-popup.l7-popup-anchor-top-left .l7-popup-tip,
.l7-popup.l7-popup-anchor-top-right .l7-popup-tip {
  top: 1px;
}
.l7-popup.l7-popup-anchor-left {
  flex-direction: row;
}
.l7-popup.l7-popup-anchor-right {
  flex-direction: row-reverse;
}
.l7-popup-anchor-top .l7-popup-tip {
  position: relative;
  align-self: center;
  border-top: none;
  border-bottom-color: #fff;
}
.l7-popup-anchor-top-left .l7-popup-tip {
  align-self: flex-start;
  border-top: none;
  border-bottom-color: #fff;
  border-left: none;
}
.l7-popup-anchor-top-right .l7-popup-tip {
  align-self: flex-end;
  border-top: none;
  border-right: none;
  border-bottom-color: #fff;
}
.l7-popup-anchor-bottom .l7-popup-tip {
  align-self: center;
  border-top-color: #fff;
  border-bottom: none;
}
.l7-popup-anchor-bottom-left .l7-popup-tip {
  align-self: flex-start;
  border-top-color: #fff;
  border-bottom: none;
  border-left: none;
}
.l7-popup-anchor-bottom-right .l7-popup-tip {
  align-self: flex-end;
  border-top-color: #fff;
  border-right: none;
  border-bottom: none;
}
.l7-popup-anchor-left .l7-popup-tip {
  align-self: center;
  border-right-color: #fff;
  border-left: none;
}
.l7-popup-anchor-right .l7-popup-tip {
  right: 1px;
  align-self: center;
  border-right: none;
  border-left-color: #fff;
}
.l7-popup-anchor-top-left .l7-popup-content {
  border-top-left-radius: 0;
}
.l7-popup-anchor-top-right .l7-popup-content {
  border-top-right-radius: 0;
}
.l7-popup-anchor-bottom-left .l7-popup-content {
  border-bottom-left-radius: 0;
}
.l7-popup-anchor-bottom-right .l7-popup-content {
  border-bottom-right-radius: 0;
}
.l7-popup-track-pointer {
  display: none;
}
.l7-popup-track-pointer * {
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  pointer-events: none;
}
.l7-map:hover .l7-popup-track-pointer {
  display: flex;
}
.l7-map:active .l7-popup-track-pointer {
  display: none;
}
.l7-layer-popup__row {
  font-size: 12px;
}
.l7-layer-popup__row + .l7-layer-popup__row {
  margin-top: 4px;
}
.l7-control-swipe {
  position: absolute;
  top: 50%;
  left: 50%;
  z-index: 6;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  touch-action: none;
}
.l7-control-swipe_hide {
  display: none;
}
.l7-control-swipe:before {
  position: absolute;
  top: -5000px;
  bottom: -5000px;
  left: 50%;
  z-index: -1;
  width: 4px;
  background: #fff;
  -webkit-transform: translate(-2px, 0);
          transform: translate(-2px, 0);
  content: '';
}
.l7-control-swipe.horizontal:before {
  top: 50%;
  right: -5000px;
  bottom: auto;
  left: -5000px;
  width: auto;
  height: 4px;
}
.l7-control-swipe__button {
  display: block;
  width: 28px;
  height: 28px;
  margin: 0;
  padding: 0;
  color: #595959;
  font-weight: bold;
  font-size: inherit;
  text-align: center;
  text-decoration: none;
  background-color: #fff;
  border: none;
  border-radius: 2px;
  outline: none;
}
.l7-control-swipe,
.l7-control-swipe__button {
  cursor: ew-resize;
}
.l7-control-swipe.horizontal,
.l7-control-swipe.horizontal button {
  cursor: ns-resize;
}
.l7-control-swipe:after,
.l7-control-swipe__button:before,
.l7-control-swipe__button:after {
  position: absolute;
  top: 25%;
  bottom: 25%;
  left: 50%;
  width: 2px;
  background: currentColor;
  -webkit-transform: translate(-1px, 0);
          transform: translate(-1px, 0);
  content: '';
}
.l7-control-swipe__button:after {
  -webkit-transform: translateX(4px);
          transform: translateX(4px);
}
.l7-control-swipe__button:before {
  -webkit-transform: translateX(-6px);
          transform: translateX(-6px);
}
`);

// node_modules/@antv/util/esm/color/arr2rgb.js
function toHex(value) {
  var x16Value = Math.round(value).toString(16);
  return x16Value.length === 1 ? "0".concat(x16Value) : x16Value;
}
function arr2rgb(arr) {
  return "#".concat(toHex(arr[0])).concat(toHex(arr[1])).concat(toHex(arr[2]));
}

// node_modules/@antv/util/esm/lodash/is-nil.js
function isNil2(value) {
  return value === null || value === void 0;
}

// node_modules/@antv/util/esm/lodash/is-type.js
var toString = {}.toString;

// node_modules/@antv/util/esm/lodash/pull.js
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;

// node_modules/@antv/util/esm/lodash/pull-at.js
var splice2 = Array.prototype.splice;

// node_modules/@antv/util/esm/lodash/clamp.js
var clamp = function(a, min3, max4) {
  if (a < min3) {
    return min3;
  } else if (a > max4) {
    return max4;
  }
  return a;
};
var clamp_default = clamp;

// node_modules/@antv/util/esm/lodash/is-number.js
function isNumber8(value) {
  return typeof value === "number";
}

// node_modules/@antv/util/esm/lodash/to-degree.js
var DEGREE = 180 / Math.PI;

// node_modules/@antv/util/esm/lodash/to-radian.js
var RADIAN = Math.PI / 180;

// node_modules/@antv/util/esm/lodash/get-type.js
var toString2 = {}.toString;

// node_modules/@antv/util/esm/lodash/is-prototype.js
var objectProto = Object.prototype;

// node_modules/@antv/util/esm/lodash/memoize.js
function flru(max4) {
  var num, curr, prev;
  var limit = max4 || 1;
  function keep(key, value) {
    if (++num > limit) {
      prev = curr;
      reset(1);
      ++num;
    }
    curr[key] = value;
  }
  function reset(isPartial) {
    num = 0;
    curr = /* @__PURE__ */ Object.create(null);
    isPartial || (prev = /* @__PURE__ */ Object.create(null));
  }
  reset();
  return {
    clear: reset,
    has: function(key) {
      return curr[key] !== void 0 || prev[key] !== void 0;
    },
    get: function(key) {
      var val = curr[key];
      if (val !== void 0)
        return val;
      if ((val = prev[key]) !== void 0) {
        keep(key, val);
        return val;
      }
    },
    set: function(key, value) {
      if (curr[key] !== void 0) {
        curr[key] = value;
      } else {
        keep(key, value);
      }
    }
  };
}
var CacheMap = /* @__PURE__ */ new Map();
function memoize(fn, resolver, maxSize) {
  if (maxSize === void 0) {
    maxSize = 128;
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    if (!CacheMap.has(fn))
      CacheMap.set(fn, flru(maxSize));
    var cache = CacheMap.get(fn);
    if (cache.has(key))
      return cache.get(key);
    var result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
  return memoized;
}

// node_modules/@antv/util/esm/lodash/cache.js
var default_1 = (
  /** @class */
  function() {
    function default_12() {
      this.map = {};
    }
    default_12.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_12.prototype.get = function(key, def) {
      var v2 = this.map[key];
      return v2 === void 0 ? def : v2;
    };
    default_12.prototype.set = function(key, value) {
      this.map[key] = value;
    };
    default_12.prototype.clear = function() {
      this.map = {};
    };
    default_12.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_12.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_12;
  }()
);

// node_modules/@antv/util/esm/color/torgb.js
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
function getTmp() {
  var i = document.getElementById("antv-web-colour-picker");
  if (i) {
    return i;
  }
  i = document.createElement("i");
  i.id = "antv-web-colour-picker";
  i.title = "Web Colour Picker";
  i.style.display = "none";
  document.body.appendChild(i);
  return i;
}
function toRGBString(color2) {
  if (color2[0] === "#" && color2.length === 7) {
    return color2;
  }
  var iEl = getTmp();
  iEl.style.color = color2;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function(s) {
    return Number(s);
  });
  rst = arr2rgb(cArray);
  return rst;
}
var toRGB = memoize(toRGBString, function(color2) {
  return color2;
}, 256);

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator2(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v2) {
      return step([n, v2]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/@antv/util/esm/path/parser/path-parser.js
var PathParser = (
  /** @class */
  function() {
    function PathParser2(pathString) {
      this.pathValue = pathString;
      this.segments = [];
      this.max = pathString.length;
      this.index = 0;
      this.param = 0;
      this.segmentStart = 0;
      this.data = [];
      this.err = "";
    }
    return PathParser2;
  }()
);

// node_modules/@antv/g-device-api/node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter32(), 1);
var eventemitter3_default = import_index.default;

// node_modules/@antv/g-device-api/es/index.js
var GL;
(function(GL2) {
  GL2[GL2["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
  GL2[GL2["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
  GL2[GL2["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
  GL2[GL2["POINTS"] = 0] = "POINTS";
  GL2[GL2["LINES"] = 1] = "LINES";
  GL2[GL2["LINE_LOOP"] = 2] = "LINE_LOOP";
  GL2[GL2["LINE_STRIP"] = 3] = "LINE_STRIP";
  GL2[GL2["TRIANGLES"] = 4] = "TRIANGLES";
  GL2[GL2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  GL2[GL2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  GL2[GL2["ZERO"] = 0] = "ZERO";
  GL2[GL2["ONE"] = 1] = "ONE";
  GL2[GL2["SRC_COLOR"] = 768] = "SRC_COLOR";
  GL2[GL2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  GL2[GL2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  GL2[GL2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  GL2[GL2["DST_ALPHA"] = 772] = "DST_ALPHA";
  GL2[GL2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  GL2[GL2["DST_COLOR"] = 774] = "DST_COLOR";
  GL2[GL2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  GL2[GL2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
  GL2[GL2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
  GL2[GL2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
  GL2[GL2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
  GL2[GL2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
  GL2[GL2["FUNC_ADD"] = 32774] = "FUNC_ADD";
  GL2[GL2["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
  GL2[GL2["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
  GL2[GL2["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
  GL2[GL2["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
  GL2[GL2["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
  GL2[GL2["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
  GL2[GL2["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
  GL2[GL2["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
  GL2[GL2["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
  GL2[GL2["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
  GL2[GL2["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
  GL2[GL2["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
  GL2[GL2["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
  GL2[GL2["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
  GL2[GL2["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
  GL2[GL2["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
  GL2[GL2["FRONT_FACE"] = 2886] = "FRONT_FACE";
  GL2[GL2["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
  GL2[GL2["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
  GL2[GL2["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
  GL2[GL2["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
  GL2[GL2["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
  GL2[GL2["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
  GL2[GL2["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
  GL2[GL2["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
  GL2[GL2["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
  GL2[GL2["STENCIL_REF"] = 2967] = "STENCIL_REF";
  GL2[GL2["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
  GL2[GL2["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
  GL2[GL2["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
  GL2[GL2["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
  GL2[GL2["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
  GL2[GL2["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
  GL2[GL2["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
  GL2[GL2["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
  GL2[GL2["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
  GL2[GL2["VIEWPORT"] = 2978] = "VIEWPORT";
  GL2[GL2["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
  GL2[GL2["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
  GL2[GL2["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
  GL2[GL2["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
  GL2[GL2["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
  GL2[GL2["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
  GL2[GL2["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
  GL2[GL2["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
  GL2[GL2["RED_BITS"] = 3410] = "RED_BITS";
  GL2[GL2["GREEN_BITS"] = 3411] = "GREEN_BITS";
  GL2[GL2["BLUE_BITS"] = 3412] = "BLUE_BITS";
  GL2[GL2["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
  GL2[GL2["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
  GL2[GL2["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
  GL2[GL2["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
  GL2[GL2["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
  GL2[GL2["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
  GL2[GL2["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
  GL2[GL2["SAMPLES"] = 32937] = "SAMPLES";
  GL2[GL2["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
  GL2[GL2["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
  GL2[GL2["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
  GL2[GL2["VENDOR"] = 7936] = "VENDOR";
  GL2[GL2["RENDERER"] = 7937] = "RENDERER";
  GL2[GL2["VERSION"] = 7938] = "VERSION";
  GL2[GL2["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
  GL2[GL2["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
  GL2[GL2["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
  GL2[GL2["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
  GL2[GL2["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
  GL2[GL2["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
  GL2[GL2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  GL2[GL2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  GL2[GL2["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
  GL2[GL2["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
  GL2[GL2["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
  GL2[GL2["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
  GL2[GL2["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
  GL2[GL2["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
  GL2[GL2["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
  GL2[GL2["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
  GL2[GL2["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
  GL2[GL2["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
  GL2[GL2["CULL_FACE"] = 2884] = "CULL_FACE";
  GL2[GL2["FRONT"] = 1028] = "FRONT";
  GL2[GL2["BACK"] = 1029] = "BACK";
  GL2[GL2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
  GL2[GL2["BLEND"] = 3042] = "BLEND";
  GL2[GL2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
  GL2[GL2["DITHER"] = 3024] = "DITHER";
  GL2[GL2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
  GL2[GL2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
  GL2[GL2["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
  GL2[GL2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
  GL2[GL2["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
  GL2[GL2["NO_ERROR"] = 0] = "NO_ERROR";
  GL2[GL2["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
  GL2[GL2["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
  GL2[GL2["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
  GL2[GL2["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
  GL2[GL2["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
  GL2[GL2["CW"] = 2304] = "CW";
  GL2[GL2["CCW"] = 2305] = "CCW";
  GL2[GL2["DONT_CARE"] = 4352] = "DONT_CARE";
  GL2[GL2["FASTEST"] = 4353] = "FASTEST";
  GL2[GL2["NICEST"] = 4354] = "NICEST";
  GL2[GL2["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
  GL2[GL2["BYTE"] = 5120] = "BYTE";
  GL2[GL2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  GL2[GL2["SHORT"] = 5122] = "SHORT";
  GL2[GL2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  GL2[GL2["INT"] = 5124] = "INT";
  GL2[GL2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  GL2[GL2["FLOAT"] = 5126] = "FLOAT";
  GL2[GL2["DOUBLE"] = 5130] = "DOUBLE";
  GL2[GL2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  GL2[GL2["ALPHA"] = 6406] = "ALPHA";
  GL2[GL2["RGB"] = 6407] = "RGB";
  GL2[GL2["RGBA"] = 6408] = "RGBA";
  GL2[GL2["LUMINANCE"] = 6409] = "LUMINANCE";
  GL2[GL2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  GL2[GL2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  GL2[GL2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  GL2[GL2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  GL2[GL2["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
  GL2[GL2["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
  GL2[GL2["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
  GL2[GL2["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
  GL2[GL2["LINK_STATUS"] = 35714] = "LINK_STATUS";
  GL2[GL2["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
  GL2[GL2["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
  GL2[GL2["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
  GL2[GL2["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
  GL2[GL2["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
  GL2[GL2["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
  GL2[GL2["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
  GL2[GL2["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
  GL2[GL2["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
  GL2[GL2["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
  GL2[GL2["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
  GL2[GL2["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
  GL2[GL2["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
  GL2[GL2["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
  GL2[GL2["NEVER"] = 512] = "NEVER";
  GL2[GL2["ALWAYS"] = 519] = "ALWAYS";
  GL2[GL2["LESS"] = 513] = "LESS";
  GL2[GL2["EQUAL"] = 514] = "EQUAL";
  GL2[GL2["LEQUAL"] = 515] = "LEQUAL";
  GL2[GL2["GREATER"] = 516] = "GREATER";
  GL2[GL2["GEQUAL"] = 518] = "GEQUAL";
  GL2[GL2["NOTEQUAL"] = 517] = "NOTEQUAL";
  GL2[GL2["KEEP"] = 7680] = "KEEP";
  GL2[GL2["REPLACE"] = 7681] = "REPLACE";
  GL2[GL2["INCR"] = 7682] = "INCR";
  GL2[GL2["DECR"] = 7683] = "DECR";
  GL2[GL2["INVERT"] = 5386] = "INVERT";
  GL2[GL2["INCR_WRAP"] = 34055] = "INCR_WRAP";
  GL2[GL2["DECR_WRAP"] = 34056] = "DECR_WRAP";
  GL2[GL2["NEAREST"] = 9728] = "NEAREST";
  GL2[GL2["LINEAR"] = 9729] = "LINEAR";
  GL2[GL2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  GL2[GL2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  GL2[GL2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  GL2[GL2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
  GL2[GL2["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
  GL2[GL2["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
  GL2[GL2["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
  GL2[GL2["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
  GL2[GL2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  GL2[GL2["TEXTURE"] = 5890] = "TEXTURE";
  GL2[GL2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  GL2[GL2["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
  GL2[GL2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  GL2[GL2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  GL2[GL2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  GL2[GL2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  GL2[GL2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  GL2[GL2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  GL2[GL2["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
  GL2[GL2["TEXTURE0"] = 33984] = "TEXTURE0";
  GL2[GL2["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
  GL2[GL2["REPEAT"] = 10497] = "REPEAT";
  GL2[GL2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  GL2[GL2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  GL2[GL2["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
  GL2[GL2["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
  GL2[GL2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  GL2[GL2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  GL2[GL2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  GL2[GL2["INT_VEC2"] = 35667] = "INT_VEC2";
  GL2[GL2["INT_VEC3"] = 35668] = "INT_VEC3";
  GL2[GL2["INT_VEC4"] = 35669] = "INT_VEC4";
  GL2[GL2["BOOL"] = 35670] = "BOOL";
  GL2[GL2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  GL2[GL2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  GL2[GL2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  GL2[GL2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  GL2[GL2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  GL2[GL2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  GL2[GL2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  GL2[GL2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  GL2[GL2["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
  GL2[GL2["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
  GL2[GL2["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
  GL2[GL2["LOW_INT"] = 36339] = "LOW_INT";
  GL2[GL2["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
  GL2[GL2["HIGH_INT"] = 36341] = "HIGH_INT";
  GL2[GL2["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
  GL2[GL2["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
  GL2[GL2["RGBA4"] = 32854] = "RGBA4";
  GL2[GL2["RGB5_A1"] = 32855] = "RGB5_A1";
  GL2[GL2["RGB565"] = 36194] = "RGB565";
  GL2[GL2["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
  GL2[GL2["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
  GL2[GL2["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
  GL2[GL2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  GL2[GL2["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
  GL2[GL2["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
  GL2[GL2["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
  GL2[GL2["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
  GL2[GL2["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
  GL2[GL2["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
  GL2[GL2["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
  GL2[GL2["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
  GL2[GL2["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
  GL2[GL2["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
  GL2[GL2["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
  GL2[GL2["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
  GL2[GL2["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
  GL2[GL2["NONE"] = 0] = "NONE";
  GL2[GL2["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
  GL2[GL2["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
  GL2[GL2["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
  GL2[GL2["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
  GL2[GL2["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
  GL2[GL2["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
  GL2[GL2["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
  GL2[GL2["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
  GL2[GL2["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
  GL2[GL2["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
  GL2[GL2["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
  GL2[GL2["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
  GL2[GL2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
  GL2[GL2["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
  GL2[GL2["READ_BUFFER"] = 3074] = "READ_BUFFER";
  GL2[GL2["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
  GL2[GL2["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
  GL2[GL2["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
  GL2[GL2["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
  GL2[GL2["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
  GL2[GL2["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
  GL2[GL2["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
  GL2[GL2["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
  GL2[GL2["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
  GL2[GL2["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
  GL2[GL2["MAX_ELEMENTS_VERTICES"] = 33e3] = "MAX_ELEMENTS_VERTICES";
  GL2[GL2["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
  GL2[GL2["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
  GL2[GL2["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
  GL2[GL2["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
  GL2[GL2["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
  GL2[GL2["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
  GL2[GL2["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
  GL2[GL2["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
  GL2[GL2["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
  GL2[GL2["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
  GL2[GL2["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
  GL2[GL2["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
  GL2[GL2["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
  GL2[GL2["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
  GL2[GL2["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
  GL2[GL2["RED"] = 6403] = "RED";
  GL2[GL2["RGB8"] = 32849] = "RGB8";
  GL2[GL2["RGBA8"] = 32856] = "RGBA8";
  GL2[GL2["RGB10_A2"] = 32857] = "RGB10_A2";
  GL2[GL2["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
  GL2[GL2["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
  GL2[GL2["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
  GL2[GL2["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
  GL2[GL2["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
  GL2[GL2["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
  GL2[GL2["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
  GL2[GL2["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
  GL2[GL2["SRGB"] = 35904] = "SRGB";
  GL2[GL2["SRGB8"] = 35905] = "SRGB8";
  GL2[GL2["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
  GL2[GL2["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
  GL2[GL2["RGBA32F"] = 34836] = "RGBA32F";
  GL2[GL2["RGB32F"] = 34837] = "RGB32F";
  GL2[GL2["RGBA16F"] = 34842] = "RGBA16F";
  GL2[GL2["RGB16F"] = 34843] = "RGB16F";
  GL2[GL2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  GL2[GL2["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
  GL2[GL2["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
  GL2[GL2["RGB9_E5"] = 35901] = "RGB9_E5";
  GL2[GL2["RGBA32UI"] = 36208] = "RGBA32UI";
  GL2[GL2["RGB32UI"] = 36209] = "RGB32UI";
  GL2[GL2["RGBA16UI"] = 36214] = "RGBA16UI";
  GL2[GL2["RGB16UI"] = 36215] = "RGB16UI";
  GL2[GL2["RGBA8UI"] = 36220] = "RGBA8UI";
  GL2[GL2["RGB8UI"] = 36221] = "RGB8UI";
  GL2[GL2["RGBA32I"] = 36226] = "RGBA32I";
  GL2[GL2["RGB32I"] = 36227] = "RGB32I";
  GL2[GL2["RGBA16I"] = 36232] = "RGBA16I";
  GL2[GL2["RGB16I"] = 36233] = "RGB16I";
  GL2[GL2["RGBA8I"] = 36238] = "RGBA8I";
  GL2[GL2["RGB8I"] = 36239] = "RGB8I";
  GL2[GL2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  GL2[GL2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  GL2[GL2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  GL2[GL2["R8"] = 33321] = "R8";
  GL2[GL2["RG8"] = 33323] = "RG8";
  GL2[GL2["R16F"] = 33325] = "R16F";
  GL2[GL2["R32F"] = 33326] = "R32F";
  GL2[GL2["RG16F"] = 33327] = "RG16F";
  GL2[GL2["RG32F"] = 33328] = "RG32F";
  GL2[GL2["R8I"] = 33329] = "R8I";
  GL2[GL2["R8UI"] = 33330] = "R8UI";
  GL2[GL2["R16I"] = 33331] = "R16I";
  GL2[GL2["R16UI"] = 33332] = "R16UI";
  GL2[GL2["R32I"] = 33333] = "R32I";
  GL2[GL2["R32UI"] = 33334] = "R32UI";
  GL2[GL2["RG8I"] = 33335] = "RG8I";
  GL2[GL2["RG8UI"] = 33336] = "RG8UI";
  GL2[GL2["RG16I"] = 33337] = "RG16I";
  GL2[GL2["RG16UI"] = 33338] = "RG16UI";
  GL2[GL2["RG32I"] = 33339] = "RG32I";
  GL2[GL2["RG32UI"] = 33340] = "RG32UI";
  GL2[GL2["R8_SNORM"] = 36756] = "R8_SNORM";
  GL2[GL2["RG8_SNORM"] = 36757] = "RG8_SNORM";
  GL2[GL2["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
  GL2[GL2["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
  GL2[GL2["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
  GL2[GL2["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
  GL2[GL2["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
  GL2[GL2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  GL2[GL2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  GL2[GL2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  GL2[GL2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  GL2[GL2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  GL2[GL2["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
  GL2[GL2["RG"] = 33319] = "RG";
  GL2[GL2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  GL2[GL2["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
  GL2[GL2["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
  GL2[GL2["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
  GL2[GL2["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
  GL2[GL2["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
  GL2[GL2["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
  GL2[GL2["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
  GL2[GL2["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
  GL2[GL2["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
  GL2[GL2["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
  GL2[GL2["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
  GL2[GL2["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
  GL2[GL2["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
  GL2[GL2["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
  GL2[GL2["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
  GL2[GL2["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
  GL2[GL2["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
  GL2[GL2["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
  GL2[GL2["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
  GL2[GL2["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
  GL2[GL2["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
  GL2[GL2["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
  GL2[GL2["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
  GL2[GL2["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
  GL2[GL2["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
  GL2[GL2["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
  GL2[GL2["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
  GL2[GL2["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
  GL2[GL2["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
  GL2[GL2["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
  GL2[GL2["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
  GL2[GL2["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
  GL2[GL2["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
  GL2[GL2["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
  GL2[GL2["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
  GL2[GL2["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
  GL2[GL2["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
  GL2[GL2["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
  GL2[GL2["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
  GL2[GL2["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
  GL2[GL2["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
  GL2[GL2["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
  GL2[GL2["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
  GL2[GL2["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
  GL2[GL2["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
  GL2[GL2["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
  GL2[GL2["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
  GL2[GL2["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
  GL2[GL2["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
  GL2[GL2["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
  GL2[GL2["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
  GL2[GL2["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
  GL2[GL2["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
  GL2[GL2["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
  GL2[GL2["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
  GL2[GL2["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
  GL2[GL2["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
  GL2[GL2["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
  GL2[GL2["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
  GL2[GL2["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
  GL2[GL2["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
  GL2[GL2["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
  GL2[GL2["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
  GL2[GL2["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
  GL2[GL2["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
  GL2[GL2["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
  GL2[GL2["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
  GL2[GL2["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
  GL2[GL2["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
  GL2[GL2["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
  GL2[GL2["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
  GL2[GL2["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
  GL2[GL2["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
  GL2[GL2["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
  GL2[GL2["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
  GL2[GL2["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
  GL2[GL2["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
  GL2[GL2["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
  GL2[GL2["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
  GL2[GL2["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
  GL2[GL2["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
  GL2[GL2["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
  GL2[GL2["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
  GL2[GL2["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
  GL2[GL2["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
  GL2[GL2["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
  GL2[GL2["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
  GL2[GL2["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
  GL2[GL2["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
  GL2[GL2["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
  GL2[GL2["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
  GL2[GL2["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
  GL2[GL2["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
  GL2[GL2["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
  GL2[GL2["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
  GL2[GL2["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
  GL2[GL2["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
  GL2[GL2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  GL2[GL2["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
  GL2[GL2["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
  GL2[GL2["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
  GL2[GL2["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
  GL2[GL2["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
  GL2[GL2["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
  GL2[GL2["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
  GL2[GL2["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
  GL2[GL2["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
  GL2[GL2["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
  GL2[GL2["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
  GL2[GL2["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
  GL2[GL2["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
  GL2[GL2["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
  GL2[GL2["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
  GL2[GL2["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
  GL2[GL2["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
  GL2[GL2["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
  GL2[GL2["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
  GL2[GL2["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
  GL2[GL2["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
  GL2[GL2["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
  GL2[GL2["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
  GL2[GL2["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
  GL2[GL2["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
  GL2[GL2["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
  GL2[GL2["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
  GL2[GL2["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
  GL2[GL2["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
  GL2[GL2["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
  GL2[GL2["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
  GL2[GL2["UNSIGNALED"] = 37144] = "UNSIGNALED";
  GL2[GL2["SIGNALED"] = 37145] = "SIGNALED";
  GL2[GL2["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
  GL2[GL2["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
  GL2[GL2["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
  GL2[GL2["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
  GL2[GL2["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
  GL2[GL2["COLOR"] = 6144] = "COLOR";
  GL2[GL2["DEPTH"] = 6145] = "DEPTH";
  GL2[GL2["STENCIL"] = 6146] = "STENCIL";
  GL2[GL2["MIN"] = 32775] = "MIN";
  GL2[GL2["MAX"] = 32776] = "MAX";
  GL2[GL2["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
  GL2[GL2["STREAM_READ"] = 35041] = "STREAM_READ";
  GL2[GL2["STREAM_COPY"] = 35042] = "STREAM_COPY";
  GL2[GL2["STATIC_READ"] = 35045] = "STATIC_READ";
  GL2[GL2["STATIC_COPY"] = 35046] = "STATIC_COPY";
  GL2[GL2["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
  GL2[GL2["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
  GL2[GL2["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
  GL2[GL2["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
  GL2[GL2["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
  GL2[GL2["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
  GL2[GL2["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
  GL2[GL2["VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE";
  GL2[GL2["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
  GL2[GL2["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
  GL2[GL2["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
  GL2[GL2["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
  GL2[GL2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  GL2[GL2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  GL2[GL2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  GL2[GL2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  GL2[GL2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  GL2[GL2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  GL2[GL2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  GL2[GL2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  GL2[GL2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  GL2[GL2["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
  GL2[GL2["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
  GL2[GL2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  GL2[GL2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GL2[GL2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GL2[GL2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  GL2[GL2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  GL2[GL2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  GL2[GL2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  GL2[GL2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  GL2[GL2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  GL2[GL2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  GL2[GL2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
  GL2[GL2["UNSIGNED_INT_24_8_WEBGL"] = 34042] = "UNSIGNED_INT_24_8_WEBGL";
  GL2[GL2["HALF_FLOAT_OES"] = 36193] = "HALF_FLOAT_OES";
  GL2[GL2["RGBA32F_EXT"] = 34836] = "RGBA32F_EXT";
  GL2[GL2["RGB32F_EXT"] = 34837] = "RGB32F_EXT";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT";
  GL2[GL2["UNSIGNED_NORMALIZED_EXT"] = 35863] = "UNSIGNED_NORMALIZED_EXT";
  GL2[GL2["MIN_EXT"] = 32775] = "MIN_EXT";
  GL2[GL2["MAX_EXT"] = 32776] = "MAX_EXT";
  GL2[GL2["SRGB_EXT"] = 35904] = "SRGB_EXT";
  GL2[GL2["SRGB_ALPHA_EXT"] = 35906] = "SRGB_ALPHA_EXT";
  GL2[GL2["SRGB8_ALPHA8_EXT"] = 35907] = "SRGB8_ALPHA8_EXT";
  GL2[GL2["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT";
  GL2[GL2["FRAGMENT_SHADER_DERIVATIVE_HINT_OES"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT_OES";
  GL2[GL2["COLOR_ATTACHMENT0_WEBGL"] = 36064] = "COLOR_ATTACHMENT0_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT1_WEBGL"] = 36065] = "COLOR_ATTACHMENT1_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT2_WEBGL"] = 36066] = "COLOR_ATTACHMENT2_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT3_WEBGL"] = 36067] = "COLOR_ATTACHMENT3_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT4_WEBGL"] = 36068] = "COLOR_ATTACHMENT4_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT5_WEBGL"] = 36069] = "COLOR_ATTACHMENT5_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT6_WEBGL"] = 36070] = "COLOR_ATTACHMENT6_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT7_WEBGL"] = 36071] = "COLOR_ATTACHMENT7_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT8_WEBGL"] = 36072] = "COLOR_ATTACHMENT8_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT9_WEBGL"] = 36073] = "COLOR_ATTACHMENT9_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT10_WEBGL"] = 36074] = "COLOR_ATTACHMENT10_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT11_WEBGL"] = 36075] = "COLOR_ATTACHMENT11_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT12_WEBGL"] = 36076] = "COLOR_ATTACHMENT12_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT13_WEBGL"] = 36077] = "COLOR_ATTACHMENT13_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT14_WEBGL"] = 36078] = "COLOR_ATTACHMENT14_WEBGL";
  GL2[GL2["COLOR_ATTACHMENT15_WEBGL"] = 36079] = "COLOR_ATTACHMENT15_WEBGL";
  GL2[GL2["DRAW_BUFFER0_WEBGL"] = 34853] = "DRAW_BUFFER0_WEBGL";
  GL2[GL2["DRAW_BUFFER1_WEBGL"] = 34854] = "DRAW_BUFFER1_WEBGL";
  GL2[GL2["DRAW_BUFFER2_WEBGL"] = 34855] = "DRAW_BUFFER2_WEBGL";
  GL2[GL2["DRAW_BUFFER3_WEBGL"] = 34856] = "DRAW_BUFFER3_WEBGL";
  GL2[GL2["DRAW_BUFFER4_WEBGL"] = 34857] = "DRAW_BUFFER4_WEBGL";
  GL2[GL2["DRAW_BUFFER5_WEBGL"] = 34858] = "DRAW_BUFFER5_WEBGL";
  GL2[GL2["DRAW_BUFFER6_WEBGL"] = 34859] = "DRAW_BUFFER6_WEBGL";
  GL2[GL2["DRAW_BUFFER7_WEBGL"] = 34860] = "DRAW_BUFFER7_WEBGL";
  GL2[GL2["DRAW_BUFFER8_WEBGL"] = 34861] = "DRAW_BUFFER8_WEBGL";
  GL2[GL2["DRAW_BUFFER9_WEBGL"] = 34862] = "DRAW_BUFFER9_WEBGL";
  GL2[GL2["DRAW_BUFFER10_WEBGL"] = 34863] = "DRAW_BUFFER10_WEBGL";
  GL2[GL2["DRAW_BUFFER11_WEBGL"] = 34864] = "DRAW_BUFFER11_WEBGL";
  GL2[GL2["DRAW_BUFFER12_WEBGL"] = 34865] = "DRAW_BUFFER12_WEBGL";
  GL2[GL2["DRAW_BUFFER13_WEBGL"] = 34866] = "DRAW_BUFFER13_WEBGL";
  GL2[GL2["DRAW_BUFFER14_WEBGL"] = 34867] = "DRAW_BUFFER14_WEBGL";
  GL2[GL2["DRAW_BUFFER15_WEBGL"] = 34868] = "DRAW_BUFFER15_WEBGL";
  GL2[GL2["MAX_COLOR_ATTACHMENTS_WEBGL"] = 36063] = "MAX_COLOR_ATTACHMENTS_WEBGL";
  GL2[GL2["MAX_DRAW_BUFFERS_WEBGL"] = 34852] = "MAX_DRAW_BUFFERS_WEBGL";
  GL2[GL2["VERTEX_ARRAY_BINDING_OES"] = 34229] = "VERTEX_ARRAY_BINDING_OES";
  GL2[GL2["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
  GL2[GL2["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
  GL2[GL2["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
  GL2[GL2["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
  GL2[GL2["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
  GL2[GL2["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
  GL2[GL2["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
})(GL || (GL = {}));
var ResourceType;
(function(ResourceType2) {
  ResourceType2[ResourceType2["Buffer"] = 0] = "Buffer";
  ResourceType2[ResourceType2["Texture"] = 1] = "Texture";
  ResourceType2[ResourceType2["RenderTarget"] = 2] = "RenderTarget";
  ResourceType2[ResourceType2["Sampler"] = 3] = "Sampler";
  ResourceType2[ResourceType2["Program"] = 4] = "Program";
  ResourceType2[ResourceType2["Bindings"] = 5] = "Bindings";
  ResourceType2[ResourceType2["InputLayout"] = 6] = "InputLayout";
  ResourceType2[ResourceType2["RenderPipeline"] = 7] = "RenderPipeline";
  ResourceType2[ResourceType2["ComputePipeline"] = 8] = "ComputePipeline";
  ResourceType2[ResourceType2["Readback"] = 9] = "Readback";
  ResourceType2[ResourceType2["QueryPool"] = 10] = "QueryPool";
  ResourceType2[ResourceType2["RenderBundle"] = 11] = "RenderBundle";
})(ResourceType || (ResourceType = {}));
var CompareFunction;
(function(CompareFunction2) {
  CompareFunction2[CompareFunction2["NEVER"] = 512] = "NEVER";
  CompareFunction2[CompareFunction2["LESS"] = 513] = "LESS";
  CompareFunction2[CompareFunction2["EQUAL"] = 514] = "EQUAL";
  CompareFunction2[CompareFunction2["LEQUAL"] = 515] = "LEQUAL";
  CompareFunction2[CompareFunction2["GREATER"] = 516] = "GREATER";
  CompareFunction2[CompareFunction2["NOTEQUAL"] = 517] = "NOTEQUAL";
  CompareFunction2[CompareFunction2["GEQUAL"] = 518] = "GEQUAL";
  CompareFunction2[CompareFunction2["ALWAYS"] = 519] = "ALWAYS";
})(CompareFunction || (CompareFunction = {}));
var FrontFace;
(function(FrontFace2) {
  FrontFace2[FrontFace2["CCW"] = 2305] = "CCW";
  FrontFace2[FrontFace2["CW"] = 2304] = "CW";
})(FrontFace || (FrontFace = {}));
var CullMode;
(function(CullMode2) {
  CullMode2[CullMode2["NONE"] = 0] = "NONE";
  CullMode2[CullMode2["FRONT"] = 1] = "FRONT";
  CullMode2[CullMode2["BACK"] = 2] = "BACK";
  CullMode2[CullMode2["FRONT_AND_BACK"] = 3] = "FRONT_AND_BACK";
})(CullMode || (CullMode = {}));
var BlendFactor;
(function(BlendFactor2) {
  BlendFactor2[BlendFactor2["ZERO"] = 0] = "ZERO";
  BlendFactor2[BlendFactor2["ONE"] = 1] = "ONE";
  BlendFactor2[BlendFactor2["SRC"] = 768] = "SRC";
  BlendFactor2[BlendFactor2["ONE_MINUS_SRC"] = 769] = "ONE_MINUS_SRC";
  BlendFactor2[BlendFactor2["DST"] = 774] = "DST";
  BlendFactor2[BlendFactor2["ONE_MINUS_DST"] = 775] = "ONE_MINUS_DST";
  BlendFactor2[BlendFactor2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  BlendFactor2[BlendFactor2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  BlendFactor2[BlendFactor2["DST_ALPHA"] = 772] = "DST_ALPHA";
  BlendFactor2[BlendFactor2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  BlendFactor2[BlendFactor2["CONST"] = 32769] = "CONST";
  BlendFactor2[BlendFactor2["ONE_MINUS_CONSTANT"] = 32770] = "ONE_MINUS_CONSTANT";
  BlendFactor2[BlendFactor2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
})(BlendFactor || (BlendFactor = {}));
var BlendMode;
(function(BlendMode2) {
  BlendMode2[BlendMode2["ADD"] = 32774] = "ADD";
  BlendMode2[BlendMode2["SUBSTRACT"] = 32778] = "SUBSTRACT";
  BlendMode2[BlendMode2["REVERSE_SUBSTRACT"] = 32779] = "REVERSE_SUBSTRACT";
  BlendMode2[BlendMode2["MIN"] = 32775] = "MIN";
  BlendMode2[BlendMode2["MAX"] = 32776] = "MAX";
})(BlendMode || (BlendMode = {}));
var AddressMode;
(function(AddressMode2) {
  AddressMode2[AddressMode2["CLAMP_TO_EDGE"] = 0] = "CLAMP_TO_EDGE";
  AddressMode2[AddressMode2["REPEAT"] = 1] = "REPEAT";
  AddressMode2[AddressMode2["MIRRORED_REPEAT"] = 2] = "MIRRORED_REPEAT";
})(AddressMode || (AddressMode = {}));
var FilterMode;
(function(FilterMode2) {
  FilterMode2[FilterMode2["POINT"] = 0] = "POINT";
  FilterMode2[FilterMode2["BILINEAR"] = 1] = "BILINEAR";
})(FilterMode || (FilterMode = {}));
var MipmapFilterMode;
(function(MipmapFilterMode2) {
  MipmapFilterMode2[MipmapFilterMode2["NO_MIP"] = 0] = "NO_MIP";
  MipmapFilterMode2[MipmapFilterMode2["NEAREST"] = 1] = "NEAREST";
  MipmapFilterMode2[MipmapFilterMode2["LINEAR"] = 2] = "LINEAR";
})(MipmapFilterMode || (MipmapFilterMode = {}));
var PrimitiveTopology;
(function(PrimitiveTopology2) {
  PrimitiveTopology2[PrimitiveTopology2["POINTS"] = 0] = "POINTS";
  PrimitiveTopology2[PrimitiveTopology2["TRIANGLES"] = 1] = "TRIANGLES";
  PrimitiveTopology2[PrimitiveTopology2["TRIANGLE_STRIP"] = 2] = "TRIANGLE_STRIP";
  PrimitiveTopology2[PrimitiveTopology2["LINES"] = 3] = "LINES";
  PrimitiveTopology2[PrimitiveTopology2["LINE_STRIP"] = 4] = "LINE_STRIP";
})(PrimitiveTopology || (PrimitiveTopology = {}));
var BufferUsage;
(function(BufferUsage2) {
  BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
  BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
  BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
  BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
  BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
  BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
  BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
  BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
  BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
  BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
})(BufferUsage || (BufferUsage = {}));
var BufferFrequencyHint;
(function(BufferFrequencyHint2) {
  BufferFrequencyHint2[BufferFrequencyHint2["STATIC"] = 1] = "STATIC";
  BufferFrequencyHint2[BufferFrequencyHint2["DYNAMIC"] = 2] = "DYNAMIC";
})(BufferFrequencyHint || (BufferFrequencyHint = {}));
var VertexStepMode;
(function(VertexStepMode2) {
  VertexStepMode2[VertexStepMode2["VERTEX"] = 1] = "VERTEX";
  VertexStepMode2[VertexStepMode2["INSTANCE"] = 2] = "INSTANCE";
})(VertexStepMode || (VertexStepMode = {}));
var TextureEvent;
(function(TextureEvent2) {
  TextureEvent2["LOADED"] = "loaded";
})(TextureEvent || (TextureEvent = {}));
var TextureDimension;
(function(TextureDimension2) {
  TextureDimension2[TextureDimension2["TEXTURE_2D"] = 0] = "TEXTURE_2D";
  TextureDimension2[TextureDimension2["TEXTURE_2D_ARRAY"] = 1] = "TEXTURE_2D_ARRAY";
  TextureDimension2[TextureDimension2["TEXTURE_3D"] = 2] = "TEXTURE_3D";
  TextureDimension2[TextureDimension2["TEXTURE_CUBE_MAP"] = 3] = "TEXTURE_CUBE_MAP";
})(TextureDimension || (TextureDimension = {}));
var TextureUsage2;
(function(TextureUsage3) {
  TextureUsage3[TextureUsage3["SAMPLED"] = 1] = "SAMPLED";
  TextureUsage3[TextureUsage3["RENDER_TARGET"] = 2] = "RENDER_TARGET";
  TextureUsage3[TextureUsage3["STORAGE"] = 4] = "STORAGE";
})(TextureUsage2 || (TextureUsage2 = {}));
var ChannelWriteMask;
(function(ChannelWriteMask2) {
  ChannelWriteMask2[ChannelWriteMask2["NONE"] = 0] = "NONE";
  ChannelWriteMask2[ChannelWriteMask2["RED"] = 1] = "RED";
  ChannelWriteMask2[ChannelWriteMask2["GREEN"] = 2] = "GREEN";
  ChannelWriteMask2[ChannelWriteMask2["BLUE"] = 4] = "BLUE";
  ChannelWriteMask2[ChannelWriteMask2["ALPHA"] = 8] = "ALPHA";
  ChannelWriteMask2[ChannelWriteMask2["RGB"] = 7] = "RGB";
  ChannelWriteMask2[ChannelWriteMask2["ALL"] = 15] = "ALL";
})(ChannelWriteMask || (ChannelWriteMask = {}));
var StencilOp;
(function(StencilOp2) {
  StencilOp2[StencilOp2["KEEP"] = 7680] = "KEEP";
  StencilOp2[StencilOp2["ZERO"] = 0] = "ZERO";
  StencilOp2[StencilOp2["REPLACE"] = 7681] = "REPLACE";
  StencilOp2[StencilOp2["INVERT"] = 5386] = "INVERT";
  StencilOp2[StencilOp2["INCREMENT_CLAMP"] = 7682] = "INCREMENT_CLAMP";
  StencilOp2[StencilOp2["DECREMENT_CLAMP"] = 7683] = "DECREMENT_CLAMP";
  StencilOp2[StencilOp2["INCREMENT_WRAP"] = 34055] = "INCREMENT_WRAP";
  StencilOp2[StencilOp2["DECREMENT_WRAP"] = 34056] = "DECREMENT_WRAP";
})(StencilOp || (StencilOp = {}));
var SamplerFormatKind;
(function(SamplerFormatKind2) {
  SamplerFormatKind2[SamplerFormatKind2["Float"] = 0] = "Float";
  SamplerFormatKind2[SamplerFormatKind2["UnfilterableFloat"] = 1] = "UnfilterableFloat";
  SamplerFormatKind2[SamplerFormatKind2["Uint"] = 2] = "Uint";
  SamplerFormatKind2[SamplerFormatKind2["Sint"] = 3] = "Sint";
  SamplerFormatKind2[SamplerFormatKind2["Depth"] = 4] = "Depth";
})(SamplerFormatKind || (SamplerFormatKind = {}));
var ViewportOrigin;
(function(ViewportOrigin2) {
  ViewportOrigin2[ViewportOrigin2["LOWER_LEFT"] = 0] = "LOWER_LEFT";
  ViewportOrigin2[ViewportOrigin2["UPPER_LEFT"] = 1] = "UPPER_LEFT";
})(ViewportOrigin || (ViewportOrigin = {}));
var ClipSpaceNearZ;
(function(ClipSpaceNearZ2) {
  ClipSpaceNearZ2[ClipSpaceNearZ2["NEGATIVE_ONE"] = 0] = "NEGATIVE_ONE";
  ClipSpaceNearZ2[ClipSpaceNearZ2["ZERO"] = 1] = "ZERO";
})(ClipSpaceNearZ || (ClipSpaceNearZ = {}));
var QueryPoolType;
(function(QueryPoolType2) {
  QueryPoolType2[QueryPoolType2["OcclusionConservative"] = 0] = "OcclusionConservative";
})(QueryPoolType || (QueryPoolType = {}));
var FormatTypeFlags;
(function(FormatTypeFlags2) {
  FormatTypeFlags2[FormatTypeFlags2["U8"] = 1] = "U8";
  FormatTypeFlags2[FormatTypeFlags2["U16"] = 2] = "U16";
  FormatTypeFlags2[FormatTypeFlags2["U32"] = 3] = "U32";
  FormatTypeFlags2[FormatTypeFlags2["S8"] = 4] = "S8";
  FormatTypeFlags2[FormatTypeFlags2["S16"] = 5] = "S16";
  FormatTypeFlags2[FormatTypeFlags2["S32"] = 6] = "S32";
  FormatTypeFlags2[FormatTypeFlags2["F16"] = 7] = "F16";
  FormatTypeFlags2[FormatTypeFlags2["F32"] = 8] = "F32";
  FormatTypeFlags2[FormatTypeFlags2["BC1"] = 65] = "BC1";
  FormatTypeFlags2[FormatTypeFlags2["BC2"] = 66] = "BC2";
  FormatTypeFlags2[FormatTypeFlags2["BC3"] = 67] = "BC3";
  FormatTypeFlags2[FormatTypeFlags2["BC4_UNORM"] = 68] = "BC4_UNORM";
  FormatTypeFlags2[FormatTypeFlags2["BC4_SNORM"] = 69] = "BC4_SNORM";
  FormatTypeFlags2[FormatTypeFlags2["BC5_UNORM"] = 70] = "BC5_UNORM";
  FormatTypeFlags2[FormatTypeFlags2["BC5_SNORM"] = 71] = "BC5_SNORM";
  FormatTypeFlags2[FormatTypeFlags2["U16_PACKED_5551"] = 97] = "U16_PACKED_5551";
  FormatTypeFlags2[FormatTypeFlags2["U16_PACKED_565"] = 98] = "U16_PACKED_565";
  FormatTypeFlags2[FormatTypeFlags2["D24"] = 129] = "D24";
  FormatTypeFlags2[FormatTypeFlags2["D32F"] = 130] = "D32F";
  FormatTypeFlags2[FormatTypeFlags2["D24S8"] = 131] = "D24S8";
  FormatTypeFlags2[FormatTypeFlags2["D32FS8"] = 132] = "D32FS8";
})(FormatTypeFlags || (FormatTypeFlags = {}));
var FormatCompFlags;
(function(FormatCompFlags2) {
  FormatCompFlags2[FormatCompFlags2["R"] = 1] = "R";
  FormatCompFlags2[FormatCompFlags2["RG"] = 2] = "RG";
  FormatCompFlags2[FormatCompFlags2["RGB"] = 3] = "RGB";
  FormatCompFlags2[FormatCompFlags2["RGBA"] = 4] = "RGBA";
  FormatCompFlags2[FormatCompFlags2["A"] = 5] = "A";
})(FormatCompFlags || (FormatCompFlags = {}));
function getFormatCompFlagsComponentCount(n) {
  return n;
}
var FormatFlags;
(function(FormatFlags2) {
  FormatFlags2[FormatFlags2["None"] = 0] = "None";
  FormatFlags2[FormatFlags2["Normalized"] = 1] = "Normalized";
  FormatFlags2[FormatFlags2["sRGB"] = 2] = "sRGB";
  FormatFlags2[FormatFlags2["Depth"] = 4] = "Depth";
  FormatFlags2[FormatFlags2["Stencil"] = 8] = "Stencil";
  FormatFlags2[FormatFlags2["RenderTarget"] = 16] = "RenderTarget";
  FormatFlags2[FormatFlags2["Luminance"] = 32] = "Luminance";
})(FormatFlags || (FormatFlags = {}));
function makeFormat(type, comp, flags) {
  return type << 16 | comp << 8 | flags;
}
var Format;
(function(Format2) {
  Format2[Format2["ALPHA"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.A, FormatFlags.None)] = "ALPHA";
  Format2[Format2["U8_LUMINANCE"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.A, FormatFlags.Luminance)] = "U8_LUMINANCE";
  Format2[Format2["F16_LUMINANCE"] = makeFormat(FormatTypeFlags.F16, FormatCompFlags.A, FormatFlags.Luminance)] = "F16_LUMINANCE";
  Format2[Format2["F32_LUMINANCE"] = makeFormat(FormatTypeFlags.F32, FormatCompFlags.A, FormatFlags.Luminance)] = "F32_LUMINANCE";
  Format2[Format2["F16_R"] = makeFormat(FormatTypeFlags.F16, FormatCompFlags.R, FormatFlags.None)] = "F16_R";
  Format2[Format2["F16_RG"] = makeFormat(FormatTypeFlags.F16, FormatCompFlags.RG, FormatFlags.None)] = "F16_RG";
  Format2[Format2["F16_RGB"] = makeFormat(FormatTypeFlags.F16, FormatCompFlags.RGB, FormatFlags.None)] = "F16_RGB";
  Format2[Format2["F16_RGBA"] = makeFormat(FormatTypeFlags.F16, FormatCompFlags.RGBA, FormatFlags.None)] = "F16_RGBA";
  Format2[Format2["F32_R"] = makeFormat(FormatTypeFlags.F32, FormatCompFlags.R, FormatFlags.None)] = "F32_R";
  Format2[Format2["F32_RG"] = makeFormat(FormatTypeFlags.F32, FormatCompFlags.RG, FormatFlags.None)] = "F32_RG";
  Format2[Format2["F32_RGB"] = makeFormat(FormatTypeFlags.F32, FormatCompFlags.RGB, FormatFlags.None)] = "F32_RGB";
  Format2[Format2["F32_RGBA"] = makeFormat(FormatTypeFlags.F32, FormatCompFlags.RGBA, FormatFlags.None)] = "F32_RGBA";
  Format2[Format2["U8_R"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.R, FormatFlags.None)] = "U8_R";
  Format2[Format2["U8_R_NORM"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.R, FormatFlags.Normalized)] = "U8_R_NORM";
  Format2[Format2["U8_RG"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.RG, FormatFlags.None)] = "U8_RG";
  Format2[Format2["U8_RG_NORM"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.RG, FormatFlags.Normalized)] = "U8_RG_NORM";
  Format2[Format2["U8_RGB"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.RGB, FormatFlags.None)] = "U8_RGB";
  Format2[Format2["U8_RGB_NORM"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.RGB, FormatFlags.Normalized)] = "U8_RGB_NORM";
  Format2[Format2["U8_RGB_SRGB"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.RGB, FormatFlags.sRGB | FormatFlags.Normalized)] = "U8_RGB_SRGB";
  Format2[Format2["U8_RGBA"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.RGBA, FormatFlags.None)] = "U8_RGBA";
  Format2[Format2["U8_RGBA_NORM"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.RGBA, FormatFlags.Normalized)] = "U8_RGBA_NORM";
  Format2[Format2["U8_RGBA_SRGB"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.RGBA, FormatFlags.sRGB | FormatFlags.Normalized)] = "U8_RGBA_SRGB";
  Format2[Format2["U16_R"] = makeFormat(FormatTypeFlags.U16, FormatCompFlags.R, FormatFlags.None)] = "U16_R";
  Format2[Format2["U16_R_NORM"] = makeFormat(FormatTypeFlags.U16, FormatCompFlags.R, FormatFlags.Normalized)] = "U16_R_NORM";
  Format2[Format2["U16_RG_NORM"] = makeFormat(FormatTypeFlags.U16, FormatCompFlags.RG, FormatFlags.Normalized)] = "U16_RG_NORM";
  Format2[Format2["U16_RGBA_NORM"] = makeFormat(FormatTypeFlags.U16, FormatCompFlags.RGBA, FormatFlags.Normalized)] = "U16_RGBA_NORM";
  Format2[Format2["U16_RGBA"] = makeFormat(FormatTypeFlags.U16, FormatCompFlags.RGBA, FormatFlags.None)] = "U16_RGBA";
  Format2[Format2["U16_RGB"] = makeFormat(FormatTypeFlags.U16, FormatCompFlags.RGB, FormatFlags.None)] = "U16_RGB";
  Format2[Format2["U16_RG"] = makeFormat(FormatTypeFlags.U16, FormatCompFlags.RG, FormatFlags.None)] = "U16_RG";
  Format2[Format2["U32_R"] = makeFormat(FormatTypeFlags.U32, FormatCompFlags.R, FormatFlags.None)] = "U32_R";
  Format2[Format2["U32_RG"] = makeFormat(FormatTypeFlags.U32, FormatCompFlags.RG, FormatFlags.None)] = "U32_RG";
  Format2[Format2["U32_RGB"] = makeFormat(FormatTypeFlags.U32, FormatCompFlags.RGB, FormatFlags.None)] = "U32_RGB";
  Format2[Format2["U32_RGBA"] = makeFormat(FormatTypeFlags.U32, FormatCompFlags.RGBA, FormatFlags.None)] = "U32_RGBA";
  Format2[Format2["S8_R"] = makeFormat(FormatTypeFlags.S8, FormatCompFlags.R, FormatFlags.None)] = "S8_R";
  Format2[Format2["S8_R_NORM"] = makeFormat(FormatTypeFlags.S8, FormatCompFlags.R, FormatFlags.Normalized)] = "S8_R_NORM";
  Format2[Format2["S8_RG_NORM"] = makeFormat(FormatTypeFlags.S8, FormatCompFlags.RG, FormatFlags.Normalized)] = "S8_RG_NORM";
  Format2[Format2["S8_RGB_NORM"] = makeFormat(FormatTypeFlags.S8, FormatCompFlags.RGB, FormatFlags.Normalized)] = "S8_RGB_NORM";
  Format2[Format2["S8_RGBA_NORM"] = makeFormat(FormatTypeFlags.S8, FormatCompFlags.RGBA, FormatFlags.Normalized)] = "S8_RGBA_NORM";
  Format2[Format2["S16_R"] = makeFormat(FormatTypeFlags.S16, FormatCompFlags.R, FormatFlags.None)] = "S16_R";
  Format2[Format2["S16_RG"] = makeFormat(FormatTypeFlags.S16, FormatCompFlags.RG, FormatFlags.None)] = "S16_RG";
  Format2[Format2["S16_RG_NORM"] = makeFormat(FormatTypeFlags.S16, FormatCompFlags.RG, FormatFlags.Normalized)] = "S16_RG_NORM";
  Format2[Format2["S16_RGB_NORM"] = makeFormat(FormatTypeFlags.S16, FormatCompFlags.RGB, FormatFlags.Normalized)] = "S16_RGB_NORM";
  Format2[Format2["S16_RGBA"] = makeFormat(FormatTypeFlags.S16, FormatCompFlags.RGBA, FormatFlags.None)] = "S16_RGBA";
  Format2[Format2["S16_RGBA_NORM"] = makeFormat(FormatTypeFlags.S16, FormatCompFlags.RGBA, FormatFlags.Normalized)] = "S16_RGBA_NORM";
  Format2[Format2["S32_R"] = makeFormat(FormatTypeFlags.S32, FormatCompFlags.R, FormatFlags.None)] = "S32_R";
  Format2[Format2["S32_RG"] = makeFormat(FormatTypeFlags.S32, FormatCompFlags.RG, FormatFlags.None)] = "S32_RG";
  Format2[Format2["S32_RGB"] = makeFormat(FormatTypeFlags.S32, FormatCompFlags.RGB, FormatFlags.None)] = "S32_RGB";
  Format2[Format2["S32_RGBA"] = makeFormat(FormatTypeFlags.S32, FormatCompFlags.RGBA, FormatFlags.None)] = "S32_RGBA";
  Format2[Format2["U16_RGBA_5551"] = makeFormat(FormatTypeFlags.U16_PACKED_5551, FormatCompFlags.RGBA, FormatFlags.Normalized)] = "U16_RGBA_5551";
  Format2[Format2["U16_RGB_565"] = makeFormat(FormatTypeFlags.U16_PACKED_565, FormatCompFlags.RGB, FormatFlags.Normalized)] = "U16_RGB_565";
  Format2[Format2["BC1"] = makeFormat(FormatTypeFlags.BC1, FormatCompFlags.RGBA, FormatFlags.Normalized)] = "BC1";
  Format2[Format2["BC1_SRGB"] = makeFormat(FormatTypeFlags.BC1, FormatCompFlags.RGBA, FormatFlags.Normalized | FormatFlags.sRGB)] = "BC1_SRGB";
  Format2[Format2["BC2"] = makeFormat(FormatTypeFlags.BC2, FormatCompFlags.RGBA, FormatFlags.Normalized)] = "BC2";
  Format2[Format2["BC2_SRGB"] = makeFormat(FormatTypeFlags.BC2, FormatCompFlags.RGBA, FormatFlags.Normalized | FormatFlags.sRGB)] = "BC2_SRGB";
  Format2[Format2["BC3"] = makeFormat(FormatTypeFlags.BC3, FormatCompFlags.RGBA, FormatFlags.Normalized)] = "BC3";
  Format2[Format2["BC3_SRGB"] = makeFormat(FormatTypeFlags.BC3, FormatCompFlags.RGBA, FormatFlags.Normalized | FormatFlags.sRGB)] = "BC3_SRGB";
  Format2[Format2["BC4_UNORM"] = makeFormat(FormatTypeFlags.BC4_UNORM, FormatCompFlags.R, FormatFlags.Normalized)] = "BC4_UNORM";
  Format2[Format2["BC4_SNORM"] = makeFormat(FormatTypeFlags.BC4_SNORM, FormatCompFlags.R, FormatFlags.Normalized)] = "BC4_SNORM";
  Format2[Format2["BC5_UNORM"] = makeFormat(FormatTypeFlags.BC5_UNORM, FormatCompFlags.RG, FormatFlags.Normalized)] = "BC5_UNORM";
  Format2[Format2["BC5_SNORM"] = makeFormat(FormatTypeFlags.BC5_SNORM, FormatCompFlags.RG, FormatFlags.Normalized)] = "BC5_SNORM";
  Format2[Format2["D24"] = makeFormat(FormatTypeFlags.D24, FormatCompFlags.R, FormatFlags.Depth)] = "D24";
  Format2[Format2["D24_S8"] = makeFormat(FormatTypeFlags.D24S8, FormatCompFlags.RG, FormatFlags.Depth | FormatFlags.Stencil)] = "D24_S8";
  Format2[Format2["D32F"] = makeFormat(FormatTypeFlags.D32F, FormatCompFlags.R, FormatFlags.Depth)] = "D32F";
  Format2[Format2["D32F_S8"] = makeFormat(FormatTypeFlags.D32FS8, FormatCompFlags.RG, FormatFlags.Depth | FormatFlags.Stencil)] = "D32F_S8";
  Format2[Format2["U8_RGB_RT"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.RGB, FormatFlags.RenderTarget | FormatFlags.Normalized)] = "U8_RGB_RT";
  Format2[Format2["U8_RGBA_RT"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.RGBA, FormatFlags.RenderTarget | FormatFlags.Normalized)] = "U8_RGBA_RT";
  Format2[Format2["U8_RGBA_RT_SRGB"] = makeFormat(FormatTypeFlags.U8, FormatCompFlags.RGBA, FormatFlags.RenderTarget | FormatFlags.Normalized | FormatFlags.sRGB)] = "U8_RGBA_RT_SRGB";
})(Format || (Format = {}));
function getFormatCompFlags(fmt) {
  return fmt >>> 8 & 255;
}
function getFormatTypeFlags(fmt) {
  return fmt >>> 16 & 255;
}
function getFormatFlags(fmt) {
  return fmt & 255;
}
function getFormatTypeFlagsByteSize(typeFlags) {
  switch (typeFlags) {
    case FormatTypeFlags.F32:
    case FormatTypeFlags.U32:
    case FormatTypeFlags.S32:
      return 4;
    case FormatTypeFlags.U16:
    case FormatTypeFlags.S16:
    case FormatTypeFlags.F16:
      return 2;
    case FormatTypeFlags.U8:
    case FormatTypeFlags.S8:
      return 1;
    default:
      throw new Error("whoops");
  }
}
function getFormatCompByteSize(fmt) {
  return getFormatTypeFlagsByteSize(getFormatTypeFlags(fmt));
}
function getFormatByteSize(fmt) {
  var typeByteSize = getFormatTypeFlagsByteSize(getFormatTypeFlags(fmt));
  var componentCount = getFormatCompFlagsComponentCount(getFormatCompFlags(fmt));
  return typeByteSize * componentCount;
}
function getFormatSamplerKind(fmt) {
  var flags = getFormatFlags(fmt);
  if (flags & FormatFlags.Depth) {
    return SamplerFormatKind.Depth;
  }
  if (flags & FormatFlags.Normalized) {
    return SamplerFormatKind.Float;
  }
  var typeFlags = getFormatTypeFlags(fmt);
  if (typeFlags === FormatTypeFlags.F16 || typeFlags === FormatTypeFlags.F32) {
    return SamplerFormatKind.Float;
  } else if (typeFlags === FormatTypeFlags.U8 || typeFlags === FormatTypeFlags.U16 || typeFlags === FormatTypeFlags.U32) {
    return SamplerFormatKind.Uint;
  } else if (typeFlags === FormatTypeFlags.S8 || typeFlags === FormatTypeFlags.S16 || typeFlags === FormatTypeFlags.S32) {
    return SamplerFormatKind.Sint;
  } else {
    throw new Error("whoops");
  }
}
function assert(b, message) {
  if (message === void 0) {
    message = "";
  }
  if (!b) {
    throw new Error("Assert fail: ".concat(message));
  }
}
function assertExists(v2) {
  if (v2 !== void 0 && v2 !== null)
    return v2;
  else
    throw new Error("Missing object");
}
function colorEqual(c0, c1) {
  return c0.r === c1.r && c0.g === c1.g && c0.b === c1.b && c0.a === c1.a;
}
function colorCopy(dst, src) {
  dst.r = src.r;
  dst.g = src.g;
  dst.b = src.b;
  dst.a = src.a;
}
function colorNewCopy(src) {
  var r = src.r, g = src.g, b = src.b, a = src.a;
  return { r, g, b, a };
}
function colorNewFromRGBA(r, g, b, a) {
  if (a === void 0) {
    a = 1;
  }
  return { r, g, b, a };
}
var TransparentBlack = colorNewFromRGBA(0, 0, 0, 0);
var OpaqueBlack = colorNewFromRGBA(0, 0, 0, 1);
var TransparentWhite = colorNewFromRGBA(1, 1, 1, 0);
var OpaqueWhite = colorNewFromRGBA(1, 1, 1, 1);
function isPowerOfTwo(n) {
  return !!(n && (n & n - 1) === 0);
}
function fallbackUndefined(v2, fallback) {
  return v2 !== null && v2 !== void 0 ? v2 : fallback;
}
function nullify(v2) {
  return v2 === void 0 ? null : v2;
}
function align2(n, multiple) {
  var mask = multiple - 1;
  return n + mask & ~mask;
}
function nArray(n, c) {
  var d = new Array(n);
  for (var i = 0; i < n; i++)
    d[i] = c();
  return d;
}
function prependLineNo(str, lineStart) {
  if (lineStart === void 0) {
    lineStart = 1;
  }
  var lines = str.split("\n");
  return lines.map(function(s, i) {
    return "".concat(leftPad("" + (lineStart + i), 4, " "), "  ").concat(s);
  }).join("\n");
}
function leftPad(S, spaces, ch) {
  if (ch === void 0) {
    ch = "0";
  }
  while (S.length < spaces)
    S = "".concat(ch).concat(S);
  return S;
}
function copyChannelBlendState(dst, src) {
  dst.blendDstFactor = src.blendDstFactor;
  dst.blendSrcFactor = src.blendSrcFactor;
  dst.blendMode = src.blendMode;
}
function copyStencilFaceState(dst, src) {
  if (dst === void 0) {
    dst = {};
  }
  dst.compare = src.compare;
  dst.depthFailOp = src.depthFailOp;
  dst.passOp = src.passOp;
  dst.failOp = src.failOp;
  dst.mask = src.mask;
  return dst;
}
function copyAttachmentState(dst, src) {
  if (dst === void 0) {
    dst = {
      rgbBlendState: {},
      alphaBlendState: {},
      channelWriteMask: 0
    };
  }
  copyChannelBlendState(dst.rgbBlendState, src.rgbBlendState);
  copyChannelBlendState(dst.alphaBlendState, src.alphaBlendState);
  dst.channelWriteMask = src.channelWriteMask;
  return dst;
}
function copyAttachmentsState(dst, src) {
  if (dst.length !== src.length)
    dst.length = src.length;
  for (var i = 0; i < src.length; i++)
    dst[i] = copyAttachmentState(dst[i], src[i]);
}
function setMegaStateFlags(dst, src) {
  if (src.attachmentsState !== void 0) {
    copyAttachmentsState(dst.attachmentsState, src.attachmentsState);
  }
  if (dst.blendConstant && src.blendConstant) {
    colorCopy(dst.blendConstant, src.blendConstant);
  }
  dst.depthCompare = fallbackUndefined(src.depthCompare, dst.depthCompare);
  dst.depthWrite = fallbackUndefined(src.depthWrite, dst.depthWrite);
  dst.stencilWrite = fallbackUndefined(src.stencilWrite, dst.stencilWrite);
  if (dst.stencilFront && src.stencilFront) {
    copyStencilFaceState(dst.stencilFront, src.stencilFront);
  }
  if (dst.stencilBack && src.stencilBack) {
    copyStencilFaceState(dst.stencilBack, src.stencilBack);
  }
  dst.cullMode = fallbackUndefined(src.cullMode, dst.cullMode);
  dst.frontFace = fallbackUndefined(src.frontFace, dst.frontFace);
  dst.polygonOffset = fallbackUndefined(src.polygonOffset, dst.polygonOffset);
  dst.polygonOffsetFactor = fallbackUndefined(src.polygonOffsetFactor, dst.polygonOffsetFactor);
  dst.polygonOffsetUnits = fallbackUndefined(src.polygonOffsetUnits, dst.polygonOffsetUnits);
}
function copyMegaState(src) {
  var dst = Object.assign({}, src);
  dst.attachmentsState = [];
  copyAttachmentsState(dst.attachmentsState, src.attachmentsState);
  dst.blendConstant = dst.blendConstant && colorNewCopy(dst.blendConstant);
  dst.stencilFront = copyStencilFaceState(void 0, src.stencilFront);
  dst.stencilBack = copyStencilFaceState(void 0, src.stencilBack);
  return dst;
}
var defaultBlendState = {
  blendMode: BlendMode.ADD,
  blendSrcFactor: BlendFactor.ONE,
  blendDstFactor: BlendFactor.ZERO
};
var defaultMegaState = {
  attachmentsState: [
    {
      channelWriteMask: ChannelWriteMask.ALL,
      rgbBlendState: defaultBlendState,
      alphaBlendState: defaultBlendState
    }
  ],
  blendConstant: colorNewCopy(TransparentBlack),
  depthWrite: true,
  depthCompare: CompareFunction.LEQUAL,
  stencilWrite: false,
  stencilFront: {
    compare: CompareFunction.ALWAYS,
    passOp: StencilOp.KEEP,
    depthFailOp: StencilOp.KEEP,
    failOp: StencilOp.KEEP
  },
  stencilBack: {
    compare: CompareFunction.ALWAYS,
    passOp: StencilOp.KEEP,
    depthFailOp: StencilOp.KEEP,
    failOp: StencilOp.KEEP
  },
  cullMode: CullMode.NONE,
  frontFace: FrontFace.CCW,
  polygonOffset: false,
  polygonOffsetFactor: 0,
  polygonOffsetUnits: 0
};
function makeMegaState(other, src) {
  if (other === void 0) {
    other = null;
  }
  if (src === void 0) {
    src = defaultMegaState;
  }
  var dst = copyMegaState(src);
  if (other !== null)
    setMegaStateFlags(dst, other);
  return dst;
}
var fullscreenMegaState = makeMegaState({ depthCompare: CompareFunction.ALWAYS, depthWrite: false }, defaultMegaState);
var defaultBindingLayoutSamplerDescriptor = {
  texture: null,
  sampler: null,
  formatKind: SamplerFormatKind.Float,
  dimension: TextureDimension.TEXTURE_2D
};
function arrayEqual(a, b, e) {
  if (a.length !== b.length)
    return false;
  for (var i = 0; i < a.length; i++)
    if (!e(a[i], b[i]))
      return false;
  return true;
}
function arrayCopy(a, copyFunc) {
  var b = Array(a.length);
  for (var i = 0; i < a.length; i++)
    b[i] = copyFunc(a[i]);
  return b;
}
function textureBindingEquals(a, b) {
  return a.texture === b.texture && a.binding === b.binding;
}
function bufferBindingEquals(a, b) {
  return a.buffer === b.buffer && a.size === b.size && a.binding === b.binding && a.offset === b.offset;
}
function samplerBindingEquals(a, b) {
  if (a === null)
    return b === null;
  if (b === null)
    return false;
  return a.sampler === b.sampler && a.texture === b.texture && a.dimension === b.dimension && a.formatKind === b.formatKind && a.comparison === b.comparison;
}
function bindingsDescriptorEquals(a, b) {
  a.samplerBindings = a.samplerBindings || [];
  a.uniformBufferBindings = a.uniformBufferBindings || [];
  a.storageBufferBindings = a.storageBufferBindings || [];
  a.storageTextureBindings = a.storageTextureBindings || [];
  b.samplerBindings = b.samplerBindings || [];
  b.uniformBufferBindings = b.uniformBufferBindings || [];
  b.storageBufferBindings = b.storageBufferBindings || [];
  b.storageTextureBindings = b.storageTextureBindings || [];
  if (a.samplerBindings.length !== b.samplerBindings.length)
    return false;
  if (!arrayEqual(a.samplerBindings, b.samplerBindings, samplerBindingEquals))
    return false;
  if (!arrayEqual(a.uniformBufferBindings, b.uniformBufferBindings, bufferBindingEquals))
    return false;
  if (!arrayEqual(a.storageBufferBindings, b.storageBufferBindings, bufferBindingEquals))
    return false;
  if (!arrayEqual(a.storageTextureBindings, b.storageTextureBindings, textureBindingEquals))
    return false;
  return true;
}
function channelBlendStateEquals(a, b) {
  return a.blendMode == b.blendMode && a.blendSrcFactor === b.blendSrcFactor && a.blendDstFactor === b.blendDstFactor;
}
function attachmentStateEquals(a, b) {
  if (!channelBlendStateEquals(a.rgbBlendState, b.rgbBlendState))
    return false;
  if (!channelBlendStateEquals(a.alphaBlendState, b.alphaBlendState))
    return false;
  if (a.channelWriteMask !== b.channelWriteMask)
    return false;
  return true;
}
function stencilFaceStateEquals(a, b) {
  return a.compare == b.compare && a.depthFailOp === b.depthFailOp && a.failOp === b.failOp && a.passOp === b.passOp && a.mask === b.mask;
}
function megaStateDescriptorEquals(a, b) {
  if (!arrayEqual(a.attachmentsState, b.attachmentsState, attachmentStateEquals))
    return false;
  if (a.blendConstant && b.blendConstant && !colorEqual(a.blendConstant, b.blendConstant))
    return false;
  if (a.stencilFront && b.stencilFront && !stencilFaceStateEquals(a.stencilFront, b.stencilFront))
    return false;
  if (a.stencilBack && b.stencilBack && !stencilFaceStateEquals(a.stencilBack, b.stencilBack))
    return false;
  return a.depthCompare === b.depthCompare && a.depthWrite === b.depthWrite && a.stencilWrite === b.stencilWrite && a.cullMode === b.cullMode && a.frontFace === b.frontFace && a.polygonOffset === b.polygonOffset && a.polygonOffsetFactor === b.polygonOffsetFactor && a.polygonOffsetUnits === b.polygonOffsetUnits;
}
function programEquals(a, b) {
  return a.id === b.id;
}
function formatEquals(a, b) {
  return a === b;
}
function renderPipelineDescriptorEquals(a, b) {
  if (a.topology !== b.topology)
    return false;
  if (a.inputLayout !== b.inputLayout)
    return false;
  if (a.sampleCount !== b.sampleCount)
    return false;
  if (a.megaStateDescriptor && b.megaStateDescriptor && !megaStateDescriptorEquals(a.megaStateDescriptor, b.megaStateDescriptor))
    return false;
  if (!programEquals(a.program, b.program))
    return false;
  if (!arrayEqual(a.colorAttachmentFormats, b.colorAttachmentFormats, formatEquals))
    return false;
  if (a.depthStencilAttachmentFormat !== b.depthStencilAttachmentFormat)
    return false;
  return true;
}
function vertexAttributeDescriptorEquals(a, b) {
  return a.offset === b.offset && a.shaderLocation === b.shaderLocation && a.format === b.format && a.divisor === b.divisor;
}
function inputLayoutBufferDescriptorEquals(a, b) {
  if (isNil2(a))
    return isNil2(b);
  if (isNil2(b))
    return false;
  return a.arrayStride === b.arrayStride && a.stepMode === b.stepMode && arrayEqual(a.attributes, b.attributes, vertexAttributeDescriptorEquals);
}
function inputLayoutDescriptorEquals(a, b) {
  if (a.indexBufferFormat !== b.indexBufferFormat)
    return false;
  if (!arrayEqual(a.vertexBufferDescriptors, b.vertexBufferDescriptors, inputLayoutBufferDescriptorEquals))
    return false;
  if (!programEquals(a.program, b.program))
    return false;
  return true;
}
function samplerBindingCopy(a) {
  var sampler = a.sampler;
  var texture = a.texture;
  var dimension = a.dimension;
  var formatKind = a.formatKind;
  var comparison = a.comparison;
  return { sampler, texture, dimension, formatKind, comparison };
}
function bufferBindingCopy(a) {
  var buffer = a.buffer;
  var size2 = a.size;
  var binding = a.binding;
  var offset = a.offset;
  return { binding, buffer, offset, size: size2 };
}
function textureBindingCopy(a) {
  var binding = a.binding;
  var texture = a.texture;
  return { binding, texture };
}
function bindingsDescriptorCopy(a) {
  var samplerBindings = a.samplerBindings && arrayCopy(a.samplerBindings, samplerBindingCopy);
  var uniformBufferBindings = a.uniformBufferBindings && arrayCopy(a.uniformBufferBindings, bufferBindingCopy);
  var storageBufferBindings = a.storageBufferBindings && arrayCopy(a.storageBufferBindings, bufferBindingCopy);
  var storageTextureBindings = a.storageTextureBindings && arrayCopy(a.storageTextureBindings, textureBindingCopy);
  return {
    samplerBindings,
    uniformBufferBindings,
    storageBufferBindings,
    storageTextureBindings,
    pipeline: a.pipeline
  };
}
function renderPipelineDescriptorCopy(a) {
  var inputLayout = a.inputLayout;
  var program = a.program;
  var topology = a.topology;
  var megaStateDescriptor = a.megaStateDescriptor && copyMegaState(a.megaStateDescriptor);
  var colorAttachmentFormats = a.colorAttachmentFormats.slice();
  var depthStencilAttachmentFormat = a.depthStencilAttachmentFormat;
  var sampleCount = a.sampleCount;
  return {
    inputLayout,
    megaStateDescriptor,
    program,
    topology,
    colorAttachmentFormats,
    depthStencilAttachmentFormat,
    sampleCount
  };
}
function vertexAttributeDescriptorCopy(a) {
  var shaderLocation = a.shaderLocation;
  var format2 = a.format;
  var offset = a.offset;
  var divisor = a.divisor;
  return {
    shaderLocation,
    format: format2,
    offset,
    divisor
  };
}
function inputLayoutBufferDescriptorCopy(a) {
  if (!isNil2(a)) {
    var arrayStride = a.arrayStride;
    var stepMode = a.stepMode;
    var attributes = arrayCopy(a.attributes, vertexAttributeDescriptorCopy);
    return { arrayStride, stepMode, attributes };
  } else {
    return a;
  }
}
function inputLayoutDescriptorCopy(a) {
  var vertexBufferDescriptors = arrayCopy(a.vertexBufferDescriptors, inputLayoutBufferDescriptorCopy);
  var indexBufferFormat = a.indexBufferFormat;
  var program = a.program;
  return {
    vertexBufferDescriptors,
    indexBufferFormat,
    program
  };
}
var _a;
var UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
function parseUniformName(name) {
  if (name[name.length - 1] !== "]") {
    return {
      name,
      length: 1,
      isArray: false
    };
  }
  var matches = name.match(UNIFORM_NAME_REGEXP);
  if (!matches || matches.length < 2) {
    throw new Error("Failed to parse GLSL uniform name ".concat(name));
  }
  return {
    name: matches[1],
    length: Number(matches[2]) || 1,
    isArray: Boolean(matches[2])
  };
}
function getSamplerSetter() {
  var cache = null;
  return function(gl2, location, value) {
    var update = cache !== value;
    if (update) {
      gl2.uniform1i(location, value);
      cache = value;
    }
    return update;
  };
}
function getArraySetter(functionName, toArray, size2, uniformSetter) {
  var cache = null;
  var cacheLength = null;
  return function(gl2, location, value) {
    var arrayValue = toArray(value, size2);
    var length2 = arrayValue.length;
    var update = false;
    if (cache === null) {
      cache = new Float32Array(length2);
      cacheLength = length2;
      update = true;
    } else {
      assert(cacheLength === length2, "Uniform length cannot change.");
      for (var i = 0; i < length2; ++i) {
        if (arrayValue[i] !== cache[i]) {
          update = true;
          break;
        }
      }
    }
    if (update) {
      uniformSetter(gl2, functionName, location, arrayValue);
      cache.set(arrayValue);
    }
    return update;
  };
}
function setVectorUniform(gl2, functionName, location, value) {
  gl2[functionName](location, value);
}
function setMatrixUniform(gl2, functionName, location, value) {
  gl2[functionName](location, false, value);
}
var FLOAT_ARRAY = {};
var INT_ARRAY = {};
var UINT_ARRAY = {};
var array1 = [0];
function toTypedArray(value, uniformLength, Type, cache) {
  if (uniformLength === 1 && typeof value === "boolean") {
    value = value ? 1 : 0;
  }
  if (Number.isFinite(value)) {
    array1[0] = value;
    value = array1;
  }
  var length2 = value.length;
  if (value instanceof Type) {
    return value;
  }
  var result = cache[length2];
  if (!result) {
    result = new Type(length2);
    cache[length2] = result;
  }
  for (var i = 0; i < length2; i++) {
    result[i] = value[i];
  }
  return result;
}
function toFloatArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
}
function toIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
}
function toUIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
}
var UNIFORM_SETTERS = (_a = {}, // WEBGL1
_a[GL.FLOAT] = getArraySetter.bind(null, "uniform1fv", toFloatArray, 1, setVectorUniform), _a[GL.FLOAT_VEC2] = getArraySetter.bind(null, "uniform2fv", toFloatArray, 2, setVectorUniform), _a[GL.FLOAT_VEC3] = getArraySetter.bind(null, "uniform3fv", toFloatArray, 3, setVectorUniform), _a[GL.FLOAT_VEC4] = getArraySetter.bind(null, "uniform4fv", toFloatArray, 4, setVectorUniform), _a[GL.INT] = getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform), _a[GL.INT_VEC2] = getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform), _a[GL.INT_VEC3] = getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform), _a[GL.INT_VEC4] = getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform), _a[GL.BOOL] = getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform), _a[GL.BOOL_VEC2] = getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform), _a[GL.BOOL_VEC3] = getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform), _a[GL.BOOL_VEC4] = getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform), // uniformMatrix(false): don't transpose the matrix
_a[GL.FLOAT_MAT2] = getArraySetter.bind(null, "uniformMatrix2fv", toFloatArray, 4, setMatrixUniform), _a[GL.FLOAT_MAT3] = getArraySetter.bind(null, "uniformMatrix3fv", toFloatArray, 9, setMatrixUniform), _a[GL.FLOAT_MAT4] = getArraySetter.bind(null, "uniformMatrix4fv", toFloatArray, 16, setMatrixUniform), // WEBGL2 - unsigned integers, irregular matrices, additional texture samplers
_a[GL.UNSIGNED_INT] = getArraySetter.bind(null, "uniform1uiv", toUIntArray, 1, setVectorUniform), _a[GL.UNSIGNED_INT_VEC2] = getArraySetter.bind(null, "uniform2uiv", toUIntArray, 2, setVectorUniform), _a[GL.UNSIGNED_INT_VEC3] = getArraySetter.bind(null, "uniform3uiv", toUIntArray, 3, setVectorUniform), _a[GL.UNSIGNED_INT_VEC4] = getArraySetter.bind(null, "uniform4uiv", toUIntArray, 4, setVectorUniform), // uniformMatrix(false): don't transpose the matrix
_a[GL.FLOAT_MAT2x3] = getArraySetter.bind(null, "uniformMatrix2x3fv", toFloatArray, 6, setMatrixUniform), _a[GL.FLOAT_MAT2x4] = getArraySetter.bind(null, "uniformMatrix2x4fv", toFloatArray, 8, setMatrixUniform), _a[GL.FLOAT_MAT3x2] = getArraySetter.bind(null, "uniformMatrix3x2fv", toFloatArray, 6, setMatrixUniform), _a[GL.FLOAT_MAT3x4] = getArraySetter.bind(null, "uniformMatrix3x4fv", toFloatArray, 12, setMatrixUniform), _a[GL.FLOAT_MAT4x2] = getArraySetter.bind(null, "uniformMatrix4x2fv", toFloatArray, 8, setMatrixUniform), _a[GL.FLOAT_MAT4x3] = getArraySetter.bind(null, "uniformMatrix4x3fv", toFloatArray, 12, setMatrixUniform), _a[GL.SAMPLER_2D] = getSamplerSetter, _a[GL.SAMPLER_CUBE] = getSamplerSetter, _a[GL.SAMPLER_3D] = getSamplerSetter, _a[GL.SAMPLER_2D_SHADOW] = getSamplerSetter, _a[GL.SAMPLER_2D_ARRAY] = getSamplerSetter, _a[GL.SAMPLER_2D_ARRAY_SHADOW] = getSamplerSetter, _a[GL.SAMPLER_CUBE_SHADOW] = getSamplerSetter, _a[GL.INT_SAMPLER_2D] = getSamplerSetter, _a[GL.INT_SAMPLER_3D] = getSamplerSetter, _a[GL.INT_SAMPLER_CUBE] = getSamplerSetter, _a[GL.INT_SAMPLER_2D_ARRAY] = getSamplerSetter, _a[GL.UNSIGNED_INT_SAMPLER_2D] = getSamplerSetter, _a[GL.UNSIGNED_INT_SAMPLER_3D] = getSamplerSetter, _a[GL.UNSIGNED_INT_SAMPLER_CUBE] = getSamplerSetter, _a[GL.UNSIGNED_INT_SAMPLER_2D_ARRAY] = getSamplerSetter, _a);
function getUniformSetter(gl2, location, info) {
  var setter = UNIFORM_SETTERS[info.type];
  if (!setter) {
    throw new Error("Unknown GLSL uniform type ".concat(info.type));
  }
  return setter().bind(null, gl2, location);
}
var dtypes = {
  "[object Int8Array]": 5120,
  "[object Int16Array]": 5122,
  "[object Int32Array]": 5124,
  "[object Uint8Array]": 5121,
  "[object Uint8ClampedArray]": 5121,
  "[object Uint16Array]": 5123,
  "[object Uint32Array]": 5125,
  "[object Float32Array]": 5126,
  "[object Float64Array]": 5121,
  "[object ArrayBuffer]": 5121
};
function isTypedArray(x) {
  return Object.prototype.toString.call(x) in dtypes;
}
function defineStr(k, v2) {
  return "#define ".concat(k, " ").concat(v2);
}
function getDefines(shader) {
  var defines = {};
  shader.replace(/^\s*#define\s*(\S*)\s*(\S*)\s*$/gm, function(_, name, value) {
    var v2 = Number(value);
    defines[name] = isNaN(v2) ? value : v2;
    return "";
  });
  return defines;
}
function getAttributeLocations(vert, defines) {
  var locations = [];
  vert.replace(/^\s*layout\(location\s*=\s*(\S*)\)\s*in\s+\S+\s*(.*);$/gm, function(_, location, name) {
    var l = Number(location);
    locations.push({ location: isNaN(l) ? defines[location] : l, name });
    return "";
  });
  return locations;
}
function parseBinding(layout) {
  if (layout === void 0)
    return null;
  var g = /binding\s*=\s*(\d+)/.exec(layout);
  if (g !== null) {
    var bindingNum = parseInt(g[1], 10);
    if (!Number.isNaN(bindingNum))
      return bindingNum;
  }
  return null;
}
function getSeparateSamplerTypes(combinedSamplerType) {
  var samplerType = "";
  var textureType = combinedSamplerType;
  return [textureType, samplerType];
}
function preprocessShader_GLSL(vendorInfo, type, source, defines, usePrecision) {
  var _a2;
  if (defines === void 0) {
    defines = null;
  }
  if (usePrecision === void 0) {
    usePrecision = true;
  }
  var isGLSL100 = vendorInfo.glslVersion === "#version 100";
  var useMRT = type === "frag" && ((_a2 = source.match(/^\s*layout\(location\s*=\s*\d*\)\s*out\s+vec4\s*(.*);$/gm)) === null || _a2 === void 0 ? void 0 : _a2.length) > 1;
  var lines = source.replace("\r\n", "\n").split("\n").map(function(n) {
    return n.replace(/[/][/].*$/, "");
  }).filter(function(n) {
    var isEmpty = !n || /^\s+$/.test(n);
    return !isEmpty;
  });
  var definesString = "";
  if (defines !== null)
    definesString = Object.keys(defines).map(function(key) {
      return defineStr(key, defines[key]);
    }).join("\n");
  var precision = lines.find(function(line) {
    return line.startsWith("precision");
  }) || "precision mediump float;";
  var rest = usePrecision ? lines.filter(function(line) {
    return !line.startsWith("precision");
  }).join("\n") : lines.join("\n");
  var extraDefines = "";
  if (vendorInfo.viewportOrigin === ViewportOrigin.UPPER_LEFT) {
    extraDefines += "".concat(defineStr("VIEWPORT_ORIGIN_TL", "1"), "\n");
  }
  if (vendorInfo.clipSpaceNearZ === ClipSpaceNearZ.ZERO) {
    extraDefines += "".concat(defineStr("CLIPSPACE_NEAR_ZERO", "1"), "\n");
  }
  if (vendorInfo.explicitBindingLocations) {
    var set_1 = 0, implicitBinding_1 = 0, location_1 = 0;
    rest = rest.replace(/^\s*(layout\((.*)\))?\s*uniform(.+{)$/gm, function(substr, cap, layout, rest2) {
      var layout2 = layout ? "".concat(layout, ", ") : "";
      return "layout(".concat(layout2, "set = ").concat(set_1, ", binding = ").concat(implicitBinding_1++, ") uniform ").concat(rest2);
    });
    set_1++;
    implicitBinding_1 = 0;
    assert(vendorInfo.separateSamplerTextures);
    rest = rest.replace(/^\s*(layout\((.*)\))?\s*uniform sampler(\w+) (.*);/gm, function(substr, cap, layout, combinedSamplerType, samplerName) {
      var binding = parseBinding(layout);
      if (binding === null)
        binding = implicitBinding_1++;
      var _a3 = __read(getSeparateSamplerTypes(combinedSamplerType), 2), textureType = _a3[0], samplerType = _a3[1];
      return type === "frag" ? "\nlayout(set = ".concat(set_1, ", binding = ").concat(binding * 2 + 0, ") uniform texture").concat(textureType, " T_").concat(samplerName, ";\nlayout(set = ").concat(set_1, ", binding = ").concat(binding * 2 + 1, ") uniform sampler").concat(samplerType, " S_").concat(samplerName, ";").trim() : "";
    });
    rest = rest.replace(type === "frag" ? /^\s*\b(varying|in)\b/gm : /^\s*\b(varying|out)\b/gm, function(substr, tok) {
      return "layout(location = ".concat(location_1++, ") ").concat(tok);
    });
    extraDefines += "".concat(defineStr("gl_VertexID", "gl_VertexIndex"), "\n");
    extraDefines += "".concat(defineStr("gl_InstanceID", "gl_InstanceIndex"), "\n");
    precision = precision.replace(/^precision (.*) sampler(.*);$/gm, "");
  } else {
    var implicitBinding_2 = 0;
    rest = rest.replace(/^\s*(layout\((.*)\))?\s*uniform sampler(\w+) (.*);/gm, function(substr, cap, layout, combinedSamplerType, samplerName) {
      var binding = parseBinding(layout);
      if (binding === null)
        binding = implicitBinding_2++;
      return "uniform sampler".concat(combinedSamplerType, " ").concat(samplerName, "; // BINDING=").concat(binding);
    });
  }
  rest = rest.replace(/\bPU_SAMPLER_(\w+)\((.*?)\)/g, function(substr, combinedSamplerType, samplerName) {
    return "SAMPLER_".concat(combinedSamplerType, "(P_").concat(samplerName, ")");
  });
  rest = rest.replace(/\bPF_SAMPLER_(\w+)\((.*?)\)/g, function(substr, combinedSamplerType, samplerName) {
    return "PP_SAMPLER_".concat(combinedSamplerType, "(P_").concat(samplerName, ")");
  });
  rest = rest.replace(/\bPU_TEXTURE\((.*?)\)/g, function(substr, samplerName) {
    return "TEXTURE(P_".concat(samplerName, ")");
  });
  if (vendorInfo.separateSamplerTextures) {
    rest = rest.replace(/\bPD_SAMPLER_(\w+)\((.*?)\)/g, function(substr, combinedSamplerType, samplerName) {
      var _a3 = __read(getSeparateSamplerTypes(combinedSamplerType), 2), textureType = _a3[0], samplerType = _a3[1];
      return "texture".concat(textureType, " T_P_").concat(samplerName, ", sampler").concat(samplerType, " S_P_").concat(samplerName);
    });
    rest = rest.replace(/\bPP_SAMPLER_(\w+)\((.*?)\)/g, function(substr, combinedSamplerType, samplerName) {
      return "T_".concat(samplerName, ", S_").concat(samplerName);
    });
    rest = rest.replace(/\bSAMPLER_(\w+)\((.*?)\)/g, function(substr, combinedSamplerType, samplerName) {
      return "sampler".concat(combinedSamplerType, "(T_").concat(samplerName, ", S_").concat(samplerName, ")");
    });
    rest = rest.replace(/\bTEXTURE\((.*?)\)/g, function(substr, samplerName) {
      return "T_".concat(samplerName);
    });
  } else {
    var samplerNames_1 = [];
    rest = rest.replace(/\bPD_SAMPLER_(\w+)\((.*?)\)/g, function(substr, combinedSamplerType, samplerName) {
      return "sampler".concat(combinedSamplerType, " P_").concat(samplerName);
    });
    rest = rest.replace(/\bPP_SAMPLER_(\w+)\((.*?)\)/g, function(substr, combinedSamplerType, samplerName) {
      return samplerName;
    });
    rest = rest.replace(/\bSAMPLER_(\w+)\((.*?)\)/g, function(substr, combinedSamplerType, samplerName) {
      samplerNames_1.push([samplerName, combinedSamplerType]);
      return samplerName;
    });
    if (isGLSL100) {
      samplerNames_1.forEach(function(_a3) {
        var _b = __read(_a3, 2), samplerName = _b[0], combinedSamplerType = _b[1];
        rest = rest.replace(new RegExp("texture\\(".concat(samplerName), "g"), function() {
          return "texture".concat(combinedSamplerType, "(").concat(samplerName);
        });
      });
    }
    rest = rest.replace(/\bTEXTURE\((.*?)\)/g, function(substr, samplerName) {
      return samplerName;
    });
  }
  var concat = "".concat(isGLSL100 ? "" : vendorInfo.glslVersion, "\n").concat(isGLSL100 && useMRT ? "#extension GL_EXT_draw_buffers : require\n" : "", "\n").concat(isGLSL100 && type === "frag" ? "#extension GL_OES_standard_derivatives : enable\n" : "").concat(usePrecision ? precision : "", "\n").concat(extraDefines ? extraDefines : "").concat(definesString ? definesString + "\n" : "", "\n").concat(rest, "\n").trim();
  if (vendorInfo.explicitBindingLocations && type === "frag") {
    concat = concat.replace(/^\b(out)\b/g, function(substr, tok) {
      return "layout(location = 0) ".concat(tok);
    });
  }
  if (isGLSL100) {
    if (type === "frag") {
      concat = concat.replace(/^\s*in\s+(\S+)\s*(.*);$/gm, function(_, dataType, name) {
        return "varying ".concat(dataType, " ").concat(name, ";\n");
      });
    }
    if (type === "vert") {
      concat = concat.replace(/^\s*out\s+(\S+)\s*(.*);$/gm, function(_, dataType, name) {
        return "varying ".concat(dataType, " ").concat(name, ";\n");
      });
      concat = concat.replace(
        // /^\s*layout\(location\s*=\s*\d*\)\s*in\s*(.*)\s*(.*);$/gm,
        /^\s*layout\(location\s*=\s*\S*\)\s*in\s+(\S+)\s*(.*);$/gm,
        function(_, dataType, name) {
          return "attribute ".concat(dataType, " ").concat(name, ";\n");
        }
      );
    }
    concat = concat.replace(/\s*uniform\s*.*\s*{((?:\s*.*\s*)*?)};/g, function(substr, uniforms) {
      return uniforms.trim().replace(/^.*$/gm, function(uniform) {
        var trimmed = uniform.trim();
        if (trimmed.startsWith("#")) {
          return trimmed;
        }
        return uniform ? "uniform ".concat(trimmed) : "";
      });
    });
    if (type === "frag") {
      if (useMRT) {
        var gBuffers_1 = [];
        concat = concat.replace(/^\s*layout\(location\s*=\s*\d*\)\s*out\s+vec4\s*(.*);$/gm, function(_, buffer) {
          gBuffers_1.push(buffer);
          return "vec4 ".concat(buffer, ";\n");
        });
        var lastIndexOfMain = concat.lastIndexOf("}");
        concat = concat.substring(0, lastIndexOfMain) + "\n    ".concat(gBuffers_1.map(function(gBuffer, i) {
          return "gl_FragData[".concat(i, "] = ").concat(gBuffer, ";\n    ");
        }).join("\n")) + concat.substring(lastIndexOfMain);
      } else {
        var glFragColor_1;
        concat = concat.replace(/^\s*out\s+(\S+)\s*(.*);$/gm, function(_, dataType, name) {
          glFragColor_1 = name;
          return "".concat(dataType, " ").concat(name, ";\n");
        });
        if (glFragColor_1) {
          var lastIndexOfMain = concat.lastIndexOf("}");
          concat = concat.substring(0, lastIndexOfMain) + "\n  gl_FragColor = vec4(".concat(glFragColor_1, ");\n") + concat.substring(lastIndexOfMain);
        }
      }
    }
    concat = concat.replace(/^\s*layout\((.*)\)/gm, "");
  }
  return concat;
}
var ResourceBase_GL = (
  /** @class */
  function(_super) {
    __extends(ResourceBase_GL2, _super);
    function ResourceBase_GL2(_a2) {
      var id = _a2.id, device = _a2.device;
      var _this = _super.call(this) || this;
      _this.id = id;
      _this.device = device;
      if (_this.device["resourceCreationTracker"] !== null) {
        _this.device["resourceCreationTracker"].trackResourceCreated(_this);
      }
      return _this;
    }
    ResourceBase_GL2.prototype.destroy = function() {
      if (this.device["resourceCreationTracker"] !== null) {
        this.device["resourceCreationTracker"].trackResourceDestroyed(this);
      }
    };
    return ResourceBase_GL2;
  }(eventemitter3_default)
);
var Bindings_GL = (
  /** @class */
  function(_super) {
    __extends(Bindings_GL2, _super);
    function Bindings_GL2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.Bindings;
      var uniformBufferBindings = descriptor.uniformBufferBindings, samplerBindings = descriptor.samplerBindings;
      _this.uniformBufferBindings = uniformBufferBindings || [];
      _this.samplerBindings = samplerBindings || [];
      _this.bindingLayouts = _this.createBindingLayouts();
      return _this;
    }
    Bindings_GL2.prototype.createBindingLayouts = function() {
      var firstUniformBuffer = 0;
      var firstSampler = 0;
      var bindingLayoutTables = [];
      var numUniformBuffers = this.uniformBufferBindings.length;
      var numSamplers = this.samplerBindings.length;
      bindingLayoutTables.push({
        firstUniformBuffer,
        numUniformBuffers,
        firstSampler,
        numSamplers
      });
      firstUniformBuffer += numUniformBuffers;
      firstSampler += numSamplers;
      return {
        numUniformBuffers: firstUniformBuffer,
        numSamplers: firstSampler,
        bindingLayoutTables
      };
    };
    return Bindings_GL2;
  }(ResourceBase_GL)
);
var isWebGL2Flag;
function isWebGL2(gl2) {
  if (isWebGL2Flag !== void 0) {
    return isWebGL2Flag;
  }
  if (typeof WebGL2RenderingContext !== "undefined" && gl2 instanceof WebGL2RenderingContext) {
    isWebGL2Flag = true;
    return true;
  }
  isWebGL2Flag = Boolean(gl2 && gl2._version === 2);
  return isWebGL2Flag;
}
function isTextureFormatCompressed(fmt) {
  var typeFlags = getFormatTypeFlags(fmt);
  switch (typeFlags) {
    case FormatTypeFlags.BC1:
    case FormatTypeFlags.BC2:
    case FormatTypeFlags.BC3:
    case FormatTypeFlags.BC4_UNORM:
    case FormatTypeFlags.BC4_SNORM:
    case FormatTypeFlags.BC5_UNORM:
    case FormatTypeFlags.BC5_SNORM:
      return true;
    default:
      return false;
  }
}
function isFormatSizedInteger(fmt) {
  var flags = getFormatFlags(fmt);
  if (flags & FormatFlags.Normalized)
    return false;
  var typeFlags = getFormatTypeFlags(fmt);
  if (typeFlags === FormatTypeFlags.S8 || typeFlags === FormatTypeFlags.S16 || typeFlags === FormatTypeFlags.S32)
    return true;
  if (typeFlags === FormatTypeFlags.U8 || typeFlags === FormatTypeFlags.U16 || typeFlags === FormatTypeFlags.U32)
    return true;
  return false;
}
function translateBufferHint(hint) {
  switch (hint) {
    case BufferFrequencyHint.STATIC:
      return GL.STATIC_DRAW;
    case BufferFrequencyHint.DYNAMIC:
      return GL.DYNAMIC_DRAW;
  }
}
function translateBufferUsageToTarget(usage) {
  if (usage & BufferUsage.INDEX) {
    return GL.ELEMENT_ARRAY_BUFFER;
  } else if (usage & BufferUsage.VERTEX) {
    return GL.ARRAY_BUFFER;
  } else if (usage & BufferUsage.UNIFORM) {
    return GL.UNIFORM_BUFFER;
  }
}
function translatePrimitiveTopology(topology) {
  switch (topology) {
    case PrimitiveTopology.TRIANGLES:
      return GL.TRIANGLES;
    case PrimitiveTopology.POINTS:
      return GL.POINTS;
    case PrimitiveTopology.TRIANGLE_STRIP:
      return GL.TRIANGLE_STRIP;
    case PrimitiveTopology.LINES:
      return GL.LINES;
    case PrimitiveTopology.LINE_STRIP:
      return GL.LINE_STRIP;
    default:
      throw new Error("Unknown primitive topology mode");
  }
}
function translateType(flags) {
  switch (flags) {
    case FormatTypeFlags.U8:
      return GL.UNSIGNED_BYTE;
    case FormatTypeFlags.U16:
      return GL.UNSIGNED_SHORT;
    case FormatTypeFlags.U32:
      return GL.UNSIGNED_INT;
    case FormatTypeFlags.S8:
      return GL.BYTE;
    case FormatTypeFlags.S16:
      return GL.SHORT;
    case FormatTypeFlags.S32:
      return GL.INT;
    case FormatTypeFlags.F16:
      return GL.HALF_FLOAT;
    case FormatTypeFlags.F32:
      return GL.FLOAT;
    default:
      throw new Error("whoops");
  }
}
function translateSize(flags) {
  switch (flags) {
    case FormatCompFlags.R:
      return 1;
    case FormatCompFlags.RG:
      return 2;
    case FormatCompFlags.RGB:
      return 3;
    case FormatCompFlags.RGBA:
      return 4;
    default:
      return 1;
  }
}
function translateVertexFormat$1(fmt) {
  var typeFlags = getFormatTypeFlags(fmt);
  var compFlags = getFormatCompFlags(fmt);
  var flags = getFormatFlags(fmt);
  var type = translateType(typeFlags);
  var size2 = translateSize(compFlags);
  var normalized = !!(flags & FormatFlags.Normalized);
  return { size: size2, type, normalized };
}
function translateIndexFormat$1(format2) {
  switch (format2) {
    case Format.U8_R:
      return GL.UNSIGNED_BYTE;
    case Format.U16_R:
      return GL.UNSIGNED_SHORT;
    case Format.U32_R:
      return GL.UNSIGNED_INT;
    default:
      throw new Error("whoops");
  }
}
function translateAddressMode$1(wrapMode) {
  switch (wrapMode) {
    case AddressMode.CLAMP_TO_EDGE:
      return GL.CLAMP_TO_EDGE;
    case AddressMode.REPEAT:
      return GL.REPEAT;
    case AddressMode.MIRRORED_REPEAT:
      return GL.MIRRORED_REPEAT;
    default:
      throw new Error("whoops");
  }
}
function translateFilterMode(filter3, mipmapFilter) {
  if (mipmapFilter === MipmapFilterMode.LINEAR && filter3 === FilterMode.BILINEAR) {
    return GL.LINEAR_MIPMAP_LINEAR;
  }
  if (mipmapFilter === MipmapFilterMode.LINEAR && filter3 === FilterMode.POINT) {
    return GL.NEAREST_MIPMAP_LINEAR;
  }
  if (mipmapFilter === MipmapFilterMode.NEAREST && filter3 === FilterMode.BILINEAR) {
    return GL.LINEAR_MIPMAP_NEAREST;
  }
  if (mipmapFilter === MipmapFilterMode.NEAREST && filter3 === FilterMode.POINT) {
    return GL.NEAREST_MIPMAP_NEAREST;
  }
  if (mipmapFilter === MipmapFilterMode.NO_MIP && filter3 === FilterMode.BILINEAR) {
    return GL.LINEAR;
  }
  if (mipmapFilter === MipmapFilterMode.NO_MIP && filter3 === FilterMode.POINT) {
    return GL.NEAREST;
  }
  throw new Error("Unknown texture filter mode");
}
function getPlatformBuffer$1(buffer_, byteOffset) {
  if (byteOffset === void 0) {
    byteOffset = 0;
  }
  var buffer = buffer_;
  return buffer.gl_buffer_pages[byteOffset / buffer.pageByteSize | 0];
}
function getPlatformTexture(texture_) {
  var texture = texture_;
  return texture.gl_texture;
}
function getPlatformSampler$1(sampler_) {
  var sampler = sampler_;
  return sampler.gl_sampler;
}
function assignPlatformName(o, name) {
  o.name = name;
  o.__SPECTOR_Metadata = { name };
}
function findall(haystack, needle) {
  var results = [];
  while (true) {
    var result = needle.exec(haystack);
    if (!result)
      break;
    results.push(result);
  }
  return results;
}
function isBlendStateNone(blendState) {
  return blendState.blendMode == BlendMode.ADD && blendState.blendSrcFactor == BlendFactor.ONE && blendState.blendDstFactor === BlendFactor.ZERO;
}
function translateQueryPoolType$1(type) {
  switch (type) {
    case QueryPoolType.OcclusionConservative:
      return GL.ANY_SAMPLES_PASSED_CONSERVATIVE;
    default:
      throw new Error("whoops");
  }
}
function translateTextureDimension$1(dimension) {
  if (dimension === TextureDimension.TEXTURE_2D)
    return GL.TEXTURE_2D;
  else if (dimension === TextureDimension.TEXTURE_2D_ARRAY)
    return GL.TEXTURE_2D_ARRAY;
  else if (dimension === TextureDimension.TEXTURE_CUBE_MAP)
    return GL.TEXTURE_CUBE_MAP;
  else if (dimension === TextureDimension.TEXTURE_3D)
    return GL.TEXTURE_3D;
  else
    throw new Error("whoops");
}
function isBlockCompressSized(w, h, bw, bh) {
  if (w % bw !== 0)
    return false;
  if (h % bh !== 0)
    return false;
  return true;
}
var Buffer_GL = (
  /** @class */
  function(_super) {
    __extends(Buffer_GL2, _super);
    function Buffer_GL2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.Buffer;
      var viewOrSize = descriptor.viewOrSize, usage = descriptor.usage, _b = descriptor.hint, hint = _b === void 0 ? BufferFrequencyHint.STATIC : _b;
      var uniformBufferMaxPageByteSize = device.uniformBufferMaxPageByteSize, gl2 = device.gl;
      var isUBO = usage & BufferUsage.UNIFORM;
      if (!isUBO) {
        if (isWebGL2(gl2)) {
          gl2.bindVertexArray(null);
        } else {
          device.OES_vertex_array_object.bindVertexArrayOES(null);
        }
      }
      var byteSize = isNumber8(viewOrSize) ? align2(viewOrSize, 4) : align2(viewOrSize.byteLength, 4);
      _this.gl_buffer_pages = [];
      var pageByteSize;
      if (isUBO) {
        var byteSizeLeft = byteSize;
        while (byteSizeLeft > 0) {
          _this.gl_buffer_pages.push(_this.createBufferPage(Math.min(byteSizeLeft, uniformBufferMaxPageByteSize), usage, hint));
          byteSizeLeft -= uniformBufferMaxPageByteSize;
        }
        pageByteSize = uniformBufferMaxPageByteSize;
      } else {
        _this.gl_buffer_pages.push(_this.createBufferPage(byteSize, usage, hint));
        pageByteSize = byteSize;
      }
      _this.pageByteSize = pageByteSize;
      _this.byteSize = byteSize;
      _this.usage = usage;
      _this.gl_target = translateBufferUsageToTarget(usage);
      if (!isNumber8(viewOrSize)) {
        _this.setSubData(0, new Uint8Array(viewOrSize.buffer));
      }
      if (!isUBO) {
        if (isWebGL2(gl2)) {
          gl2.bindVertexArray(_this.device["currentBoundVAO"]);
        } else {
          device.OES_vertex_array_object.bindVertexArrayOES(_this.device["currentBoundVAO"]);
        }
      }
      return _this;
    }
    Buffer_GL2.prototype.setSubData = function(dstByteOffset, data, srcByteOffset, byteSize) {
      if (srcByteOffset === void 0) {
        srcByteOffset = 0;
      }
      if (byteSize === void 0) {
        byteSize = data.byteLength - srcByteOffset;
      }
      var gl2 = this.device.gl;
      var dstPageByteSize = this.pageByteSize;
      var virtBufferByteOffsetEnd = dstByteOffset + byteSize;
      var virtBufferByteOffset = dstByteOffset;
      var physBufferByteOffset = dstByteOffset % dstPageByteSize;
      while (virtBufferByteOffset < virtBufferByteOffsetEnd) {
        var target = isWebGL2(gl2) ? gl2.COPY_WRITE_BUFFER : this.gl_target;
        var buffer = getPlatformBuffer$1(this, virtBufferByteOffset);
        if (buffer.ubo) {
          return;
        }
        gl2.bindBuffer(target, buffer);
        if (isWebGL2(gl2)) {
          gl2.bufferSubData(target, physBufferByteOffset, data, srcByteOffset, Math.min(virtBufferByteOffsetEnd - virtBufferByteOffset, dstPageByteSize));
        } else {
          gl2.bufferSubData(target, physBufferByteOffset, data);
        }
        virtBufferByteOffset += dstPageByteSize;
        physBufferByteOffset = 0;
        srcByteOffset += dstPageByteSize;
        this.device["debugGroupStatisticsBufferUpload"]();
      }
    };
    Buffer_GL2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      for (var i = 0; i < this.gl_buffer_pages.length; i++) {
        if (!this.gl_buffer_pages[i].ubo) {
          this.device.gl.deleteBuffer(this.gl_buffer_pages[i]);
        }
      }
      this.gl_buffer_pages = [];
    };
    Buffer_GL2.prototype.createBufferPage = function(byteSize, usage, hint) {
      var gl2 = this.device.gl;
      var isUBO = usage & BufferUsage.UNIFORM;
      if (!isWebGL2(gl2) && isUBO) {
        return {
          ubo: true
        };
      } else {
        var gl_buffer = this.device.ensureResourceExists(gl2.createBuffer());
        var gl_target = translateBufferUsageToTarget(usage);
        var gl_hint = translateBufferHint(hint);
        gl2.bindBuffer(gl_target, gl_buffer);
        gl2.bufferData(gl_target, byteSize, gl_hint);
        return gl_buffer;
      }
    };
    return Buffer_GL2;
  }(ResourceBase_GL)
);
var InputLayout_GL = (
  /** @class */
  function(_super) {
    __extends(InputLayout_GL2, _super);
    function InputLayout_GL2(_a2) {
      var e_1, _b, e_2, _c;
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _d;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.InputLayout;
      var vertexBufferDescriptors = descriptor.vertexBufferDescriptors, indexBufferFormat = descriptor.indexBufferFormat, program = descriptor.program;
      assert(indexBufferFormat === Format.U16_R || indexBufferFormat === Format.U32_R || indexBufferFormat === null);
      var indexBufferType = indexBufferFormat !== null ? translateIndexFormat$1(indexBufferFormat) : null;
      var indexBufferCompByteSize = indexBufferFormat !== null ? getFormatCompByteSize(indexBufferFormat) : null;
      var gl2 = _this.device.gl;
      var vao = _this.device.ensureResourceExists(isWebGL2(gl2) ? gl2.createVertexArray() : device.OES_vertex_array_object.createVertexArrayOES());
      if (isWebGL2(gl2)) {
        gl2.bindVertexArray(vao);
      } else {
        device.OES_vertex_array_object.bindVertexArrayOES(vao);
      }
      gl2.bindBuffer(gl2.ARRAY_BUFFER, getPlatformBuffer$1(_this.device["fallbackVertexBuffer"]));
      try {
        for (var _e = __values(descriptor.vertexBufferDescriptors), _f = _e.next(); !_f.done; _f = _e.next()) {
          var vertexBufferDescriptor = _f.value;
          var stepMode = vertexBufferDescriptor.stepMode, attributes = vertexBufferDescriptor.attributes;
          try {
            for (var attributes_1 = (e_2 = void 0, __values(attributes)), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
              var attribute = attributes_1_1.value;
              var shaderLocation = attribute.shaderLocation, format2 = attribute.format, _g = attribute.divisor, divisor = _g === void 0 ? 1 : _g;
              var location_1 = isWebGL2(gl2) ? shaderLocation : (_d = program.attributes[shaderLocation]) === null || _d === void 0 ? void 0 : _d.location;
              var vertexFormat = translateVertexFormat$1(format2);
              attribute.vertexFormat = vertexFormat;
              if (!isNil2(location_1)) {
                if (isFormatSizedInteger(format2)) {
                }
                var size2 = vertexFormat.size, type = vertexFormat.type, normalized = vertexFormat.normalized;
                gl2.vertexAttribPointer(location_1, size2, type, normalized, 0, 0);
                if (stepMode === VertexStepMode.INSTANCE) {
                  if (isWebGL2(gl2)) {
                    gl2.vertexAttribDivisor(location_1, divisor);
                  } else {
                    device.ANGLE_instanced_arrays.vertexAttribDivisorANGLE(location_1, divisor);
                  }
                }
                gl2.enableVertexAttribArray(location_1);
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (attributes_1_1 && !attributes_1_1.done && (_c = attributes_1.return))
                _c.call(attributes_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_f && !_f.done && (_b = _e.return))
            _b.call(_e);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (isWebGL2(gl2)) {
        gl2.bindVertexArray(null);
      } else {
        device.OES_vertex_array_object.bindVertexArrayOES(null);
      }
      _this.vertexBufferDescriptors = vertexBufferDescriptors;
      _this.vao = vao;
      _this.indexBufferFormat = indexBufferFormat;
      _this.indexBufferType = indexBufferType;
      _this.indexBufferCompByteSize = indexBufferCompByteSize;
      _this.program = program;
      return _this;
    }
    InputLayout_GL2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (this.device["currentBoundVAO"] === this.vao) {
        if (isWebGL2(this.device.gl)) {
          this.device.gl.bindVertexArray(null);
          this.device.gl.deleteVertexArray(this.vao);
        } else {
          this.device.OES_vertex_array_object.bindVertexArrayOES(null);
          this.device.OES_vertex_array_object.deleteVertexArrayOES(this.vao);
        }
        this.device["currentBoundVAO"] = null;
      }
    };
    return InputLayout_GL2;
  }(ResourceBase_GL)
);
var Texture_GL = (
  /** @class */
  function(_super) {
    __extends(Texture_GL2, _super);
    function Texture_GL2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor, fake = _a2.fake;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.Texture;
      descriptor = __assign({ dimension: TextureDimension.TEXTURE_2D, depthOrArrayLayers: 1, mipLevelCount: 1 }, descriptor);
      var gl2 = _this.device.gl;
      var gl_target;
      var gl_texture;
      var mipLevelCount = _this.clampmipLevelCount(descriptor);
      _this.immutable = descriptor.usage === TextureUsage2.RENDER_TARGET;
      _this.pixelStore = descriptor.pixelStore;
      _this.format = descriptor.format;
      _this.dimension = descriptor.dimension;
      _this.formatKind = getFormatSamplerKind(descriptor.format);
      _this.width = descriptor.width;
      _this.height = descriptor.height;
      _this.depthOrArrayLayers = descriptor.depthOrArrayLayers;
      _this.mipmaps = mipLevelCount >= 1;
      if (!fake) {
        gl_texture = _this.device.ensureResourceExists(gl2.createTexture());
        var gl_type = _this.device.translateTextureType(descriptor.format);
        var internalformat = _this.device.translateTextureInternalFormat(descriptor.format);
        _this.device.setActiveTexture(gl2.TEXTURE0);
        _this.device["currentTextures"][0] = null;
        _this.preprocessImage();
        if (descriptor.dimension === TextureDimension.TEXTURE_2D) {
          gl_target = GL.TEXTURE_2D;
          gl2.bindTexture(gl_target, gl_texture);
          if (_this.immutable) {
            if (isWebGL2(gl2)) {
              gl2.texStorage2D(gl_target, mipLevelCount, internalformat, descriptor.width, descriptor.height);
            } else {
              var level = internalformat === GL.DEPTH_COMPONENT || _this.isNPOT() ? 0 : 0;
              if ((_this.format === Format.D32F || _this.format === Format.D24_S8) && !isWebGL2(gl2) && !device.WEBGL_depth_texture)
                ;
              else {
                gl2.texImage2D(gl_target, level, internalformat, descriptor.width, descriptor.height, 0, internalformat, gl_type, null);
                if (_this.mipmaps) {
                  _this.mipmaps = false;
                  gl2.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR);
                  gl2.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
                  gl2.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
                }
              }
            }
          }
          assert(descriptor.depthOrArrayLayers === 1);
        } else if (descriptor.dimension === TextureDimension.TEXTURE_2D_ARRAY) {
          gl_target = GL.TEXTURE_2D_ARRAY;
          gl2.bindTexture(gl_target, gl_texture);
          if (_this.immutable) {
            if (isWebGL2(gl2)) {
              gl2.texStorage3D(gl_target, mipLevelCount, internalformat, descriptor.width, descriptor.height, descriptor.depthOrArrayLayers);
            }
          }
        } else if (descriptor.dimension === TextureDimension.TEXTURE_3D) {
          gl_target = GL.TEXTURE_3D;
          gl2.bindTexture(gl_target, gl_texture);
          if (_this.immutable) {
            if (isWebGL2(gl2)) {
              gl2.texStorage3D(gl_target, mipLevelCount, internalformat, descriptor.width, descriptor.height, descriptor.depthOrArrayLayers);
            }
          }
        } else if (descriptor.dimension === TextureDimension.TEXTURE_CUBE_MAP) {
          gl_target = GL.TEXTURE_CUBE_MAP;
          gl2.bindTexture(gl_target, gl_texture);
          if (_this.immutable) {
            if (isWebGL2(gl2)) {
              gl2.texStorage2D(gl_target, mipLevelCount, internalformat, descriptor.width, descriptor.height);
            }
          }
          assert(descriptor.depthOrArrayLayers === 6);
        } else {
          throw new Error("whoops");
        }
      }
      _this.gl_texture = gl_texture;
      _this.gl_target = gl_target;
      _this.mipLevelCount = mipLevelCount;
      return _this;
    }
    Texture_GL2.prototype.setImageData = function(levelDatas, lod) {
      if (lod === void 0) {
        lod = 0;
      }
      var gl2 = this.device.gl;
      isTextureFormatCompressed(this.format);
      var is3D = this.gl_target === GL.TEXTURE_3D || this.gl_target === GL.TEXTURE_2D_ARRAY;
      var isCube = this.gl_target === GL.TEXTURE_CUBE_MAP;
      var isTA = isTypedArray(levelDatas[0]);
      this.device.setActiveTexture(gl2.TEXTURE0);
      this.device["currentTextures"][0] = null;
      var data = levelDatas[0];
      var width;
      var height;
      if (isTA) {
        width = this.width;
        height = this.height;
      } else {
        width = data.width;
        height = data.height;
        this.width = width;
        this.height = height;
      }
      gl2.bindTexture(this.gl_target, this.gl_texture);
      var gl_format = this.device.translateTextureFormat(this.format);
      var gl_internal_format = isWebGL2(gl2) ? this.device.translateInternalTextureFormat(this.format) : gl_format;
      var gl_type = this.device.translateTextureType(this.format);
      this.preprocessImage();
      for (var z = 0; z < this.depthOrArrayLayers; z++) {
        var levelData = levelDatas[z];
        var gl_target = this.gl_target;
        if (isCube) {
          gl_target = GL.TEXTURE_CUBE_MAP_POSITIVE_X + z % 6;
        }
        if (this.immutable) {
          gl2.texSubImage2D(gl_target, lod, 0, 0, width, height, gl_format, gl_type, levelData);
        } else {
          if (isWebGL2(gl2)) {
            if (is3D) {
              gl2.texImage3D(
                gl_target,
                lod,
                gl_internal_format,
                width,
                height,
                this.depthOrArrayLayers,
                0,
                // border must be 0
                gl_format,
                // TODO: can be different with gl_format
                gl_type,
                levelData
              );
            } else {
              gl2.texImage2D(
                gl_target,
                lod,
                gl_internal_format,
                width,
                height,
                0,
                // border must be 0
                gl_format,
                // TODO: can be different with gl_format
                gl_type,
                levelData
              );
            }
          } else {
            if (isTA) {
              gl2.texImage2D(gl_target, lod, gl_format, width, height, 0, gl_format, gl_type, levelData);
            } else {
              gl2.texImage2D(gl_target, lod, gl_format, gl_format, gl_type, levelData);
            }
          }
        }
      }
      if (this.mipmaps) {
        this.generateMipmap(is3D);
      }
    };
    Texture_GL2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.device.gl.deleteTexture(getPlatformTexture(this));
    };
    Texture_GL2.prototype.clampmipLevelCount = function(descriptor) {
      if (descriptor.dimension === TextureDimension.TEXTURE_2D_ARRAY && descriptor.depthOrArrayLayers > 1) {
        var typeFlags = getFormatTypeFlags(descriptor.format);
        if (typeFlags === FormatTypeFlags.BC1) {
          var w = descriptor.width, h = descriptor.height;
          for (var i = 0; i < descriptor.mipLevelCount; i++) {
            if (w <= 2 || h <= 2)
              return i - 1;
            w = Math.max(w / 2 | 0, 1);
            h = Math.max(h / 2 | 0, 1);
          }
        }
      }
      return descriptor.mipLevelCount;
    };
    Texture_GL2.prototype.preprocessImage = function() {
      var gl2 = this.device.gl;
      if (this.pixelStore) {
        if (this.pixelStore.unpackFlipY) {
          gl2.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, true);
        }
        if (this.pixelStore.packAlignment) {
          gl2.pixelStorei(GL.PACK_ALIGNMENT, this.pixelStore.packAlignment);
        }
        if (this.pixelStore.unpackAlignment) {
          gl2.pixelStorei(GL.UNPACK_ALIGNMENT, this.pixelStore.unpackAlignment);
        }
      }
    };
    Texture_GL2.prototype.generateMipmap = function(is3D) {
      if (is3D === void 0) {
        is3D = false;
      }
      var gl2 = this.device.gl;
      if (!isWebGL2(gl2) && this.isNPOT()) {
        return this;
      }
      if (this.gl_texture && this.gl_target) {
        gl2.bindTexture(this.gl_target, this.gl_texture);
        if (is3D) {
          gl2.texParameteri(this.gl_target, GL.TEXTURE_BASE_LEVEL, 0);
          gl2.texParameteri(this.gl_target, GL.TEXTURE_MAX_LEVEL, Math.log2(this.width));
          gl2.texParameteri(this.gl_target, GL.TEXTURE_MIN_FILTER, GL.LINEAR_MIPMAP_LINEAR);
          gl2.texParameteri(this.gl_target, GL.TEXTURE_MAG_FILTER, GL.LINEAR);
        } else {
          gl2.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST_MIPMAP_LINEAR);
        }
        gl2.generateMipmap(this.gl_target);
        gl2.bindTexture(this.gl_target, null);
      }
      return this;
    };
    Texture_GL2.prototype.isNPOT = function() {
      var gl2 = this.device.gl;
      if (isWebGL2(gl2)) {
        return false;
      }
      return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);
    };
    return Texture_GL2;
  }(ResourceBase_GL)
);
var RenderTarget_GL = (
  /** @class */
  function(_super) {
    __extends(RenderTarget_GL2, _super);
    function RenderTarget_GL2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.RenderTarget;
      _this.gl_renderbuffer = null;
      _this.texture = null;
      var gl2 = _this.device.gl;
      var format2 = descriptor.format, width = descriptor.width, height = descriptor.height, _b = descriptor.sampleCount, sampleCount = _b === void 0 ? 1 : _b, texture = descriptor.texture;
      var useRenderbuffer = false;
      if ((format2 === Format.D32F || format2 === Format.D24_S8) && texture && !isWebGL2(gl2) && !device.WEBGL_depth_texture) {
        texture.destroy();
        _this.texture = null;
        useRenderbuffer = true;
      }
      if (!useRenderbuffer && texture) {
        _this.texture = texture;
      } else {
        _this.gl_renderbuffer = _this.device.ensureResourceExists(gl2.createRenderbuffer());
        gl2.bindRenderbuffer(gl2.RENDERBUFFER, _this.gl_renderbuffer);
        var gl_format = _this.device.translateTextureInternalFormat(format2, true);
        if (isWebGL2(gl2)) {
          if (sampleCount > 1) {
            gl2.renderbufferStorageMultisample(GL.RENDERBUFFER, sampleCount, gl_format, width, height);
          } else {
            gl2.renderbufferStorage(GL.RENDERBUFFER, gl_format, width, height);
          }
        } else {
          gl2.renderbufferStorage(GL.RENDERBUFFER, gl_format, width, height);
        }
      }
      _this.format = format2;
      _this.width = width;
      _this.height = height;
      _this.sampleCount = sampleCount;
      return _this;
    }
    RenderTarget_GL2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (this.gl_renderbuffer !== null) {
        this.device.gl.deleteRenderbuffer(this.gl_renderbuffer);
      }
      if (this.texture) {
        this.texture.destroy();
      }
    };
    return RenderTarget_GL2;
  }(ResourceBase_GL)
);
var ProgramCompileState_GL;
(function(ProgramCompileState_GL2) {
  ProgramCompileState_GL2[ProgramCompileState_GL2["NeedsCompile"] = 0] = "NeedsCompile";
  ProgramCompileState_GL2[ProgramCompileState_GL2["Compiling"] = 1] = "Compiling";
  ProgramCompileState_GL2[ProgramCompileState_GL2["NeedsBind"] = 2] = "NeedsBind";
  ProgramCompileState_GL2[ProgramCompileState_GL2["ReadyToUse"] = 3] = "ReadyToUse";
})(ProgramCompileState_GL || (ProgramCompileState_GL = {}));
var Program_GL = (
  /** @class */
  function(_super) {
    __extends(Program_GL2, _super);
    function Program_GL2(_a2, rawVertexGLSL) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _this = _super.call(this, { id, device }) || this;
      _this.rawVertexGLSL = rawVertexGLSL;
      _this.type = ResourceType.Program;
      _this.uniformSetters = {};
      _this.attributes = [];
      var gl2 = _this.device.gl;
      _this.descriptor = descriptor;
      _this.gl_program = _this.device.ensureResourceExists(gl2.createProgram());
      _this.gl_shader_vert = null;
      _this.gl_shader_frag = null;
      _this.compileState = ProgramCompileState_GL.NeedsCompile;
      _this.tryCompileProgram();
      return _this;
    }
    Program_GL2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.device.gl.deleteProgram(this.gl_program);
      this.device.gl.deleteShader(this.gl_shader_vert);
      this.device.gl.deleteShader(this.gl_shader_frag);
    };
    Program_GL2.prototype.tryCompileProgram = function() {
      assert(this.compileState === ProgramCompileState_GL.NeedsCompile);
      var _a2 = this.descriptor, vertex = _a2.vertex, fragment = _a2.fragment;
      var gl2 = this.device.gl;
      if ((vertex === null || vertex === void 0 ? void 0 : vertex.glsl) && (fragment === null || fragment === void 0 ? void 0 : fragment.glsl)) {
        this.gl_shader_vert = this.compileShader(vertex.postprocess ? vertex.postprocess(vertex.glsl) : vertex.glsl, gl2.VERTEX_SHADER);
        this.gl_shader_frag = this.compileShader(fragment.postprocess ? fragment.postprocess(fragment.glsl) : fragment.glsl, gl2.FRAGMENT_SHADER);
        gl2.attachShader(this.gl_program, this.gl_shader_vert);
        gl2.attachShader(this.gl_program, this.gl_shader_frag);
        gl2.linkProgram(this.gl_program);
        this.compileState = ProgramCompileState_GL.Compiling;
        if (!isWebGL2(gl2)) {
          this.readUniformLocationsFromLinkedProgram();
          this.readAttributesFromLinkedProgram();
        }
      }
    };
    Program_GL2.prototype.readAttributesFromLinkedProgram = function() {
      var _a2;
      var gl2 = this.device.gl;
      var count2 = gl2.getProgramParameter(this.gl_program, gl2.ACTIVE_ATTRIBUTES);
      var defines = getDefines(this.descriptor.vertex.glsl);
      var locations = getAttributeLocations(
        // Use raw GLSL
        this.rawVertexGLSL,
        defines
      );
      var _loop_1 = function(index4) {
        var _b = gl2.getActiveAttrib(this_1.gl_program, index4), name_1 = _b.name, type = _b.type, size2 = _b.size;
        var location_1 = gl2.getAttribLocation(this_1.gl_program, name_1);
        var definedLocation = (_a2 = locations.find(function(l) {
          return l.name === name_1;
        })) === null || _a2 === void 0 ? void 0 : _a2.location;
        if (location_1 >= 0 && !isNil2(definedLocation)) {
          this_1.attributes[definedLocation] = {
            name: name_1,
            location: location_1,
            type,
            size: size2
          };
        }
      };
      var this_1 = this;
      for (var index3 = 0; index3 < count2; index3++) {
        _loop_1(index3);
      }
    };
    Program_GL2.prototype.readUniformLocationsFromLinkedProgram = function() {
      var gl2 = this.device.gl;
      var numUniforms = gl2.getProgramParameter(this.gl_program, gl2.ACTIVE_UNIFORMS);
      for (var i = 0; i < numUniforms; i++) {
        var info = gl2.getActiveUniform(this.gl_program, i);
        var name_2 = parseUniformName(info.name).name;
        var location_2 = gl2.getUniformLocation(this.gl_program, name_2);
        this.uniformSetters[name_2] = getUniformSetter(gl2, location_2, info);
        if (info && info.size > 1) {
          for (var l = 0; l < info.size; l++) {
            location_2 = gl2.getUniformLocation(this.gl_program, "".concat(name_2, "[").concat(l, "]"));
            this.uniformSetters["".concat(name_2, "[").concat(l, "]")] = getUniformSetter(gl2, location_2, info);
          }
        }
      }
    };
    Program_GL2.prototype.compileShader = function(contents, type) {
      var gl2 = this.device.gl;
      var shader = this.device.ensureResourceExists(gl2.createShader(type));
      gl2.shaderSource(shader, contents);
      gl2.compileShader(shader);
      return shader;
    };
    Program_GL2.prototype.setUniformsLegacy = function(uniforms) {
      if (uniforms === void 0) {
        uniforms = {};
      }
      var gl2 = this.device.gl;
      if (!isWebGL2(gl2)) {
        var programUsed = false;
        for (var uniformName in uniforms) {
          if (!programUsed) {
            gl2.useProgram(this.gl_program);
            programUsed = true;
          }
          var uniform = uniforms[uniformName];
          var uniformSetter = this.uniformSetters[uniformName];
          if (uniformSetter) {
            var value = uniform;
            if (value instanceof Texture_GL) {
              value = value.textureIndex;
            }
            uniformSetter(value);
          }
        }
      }
      return this;
    };
    return Program_GL2;
  }(ResourceBase_GL)
);
var QueryPool_GL = (
  /** @class */
  function(_super) {
    __extends(QueryPool_GL2, _super);
    function QueryPool_GL2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.QueryPool;
      var gl2 = _this.device.gl;
      if (isWebGL2(gl2)) {
        var elemCount = descriptor.elemCount, type = descriptor.type;
        _this.gl_query = nArray(elemCount, function() {
          return _this.device.ensureResourceExists(gl2.createQuery());
        });
        _this.gl_query_type = translateQueryPoolType$1(type);
      }
      return _this;
    }
    QueryPool_GL2.prototype.queryResultOcclusion = function(dstOffs) {
      var gl2 = this.device.gl;
      if (isWebGL2(gl2)) {
        var gl_query = this.gl_query[dstOffs];
        if (!gl2.getQueryParameter(gl_query, gl2.QUERY_RESULT_AVAILABLE)) {
          return null;
        }
        return !!gl2.getQueryParameter(gl_query, gl2.QUERY_RESULT);
      }
      return null;
    };
    QueryPool_GL2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      var gl2 = this.device.gl;
      if (isWebGL2(gl2)) {
        for (var i = 0; i < this.gl_query.length; i++) {
          gl2.deleteQuery(this.gl_query[i]);
        }
      }
    };
    return QueryPool_GL2;
  }(ResourceBase_GL)
);
var Readback_GL = (
  /** @class */
  function(_super) {
    __extends(Readback_GL2, _super);
    function Readback_GL2(_a2) {
      var id = _a2.id, device = _a2.device;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.Readback;
      _this.gl_pbo = null;
      _this.gl_sync = null;
      return _this;
    }
    Readback_GL2.prototype.clientWaitAsync = function(sync, flags, interval_ms) {
      if (flags === void 0) {
        flags = 0;
      }
      if (interval_ms === void 0) {
        interval_ms = 10;
      }
      var gl2 = this.device.gl;
      return new Promise(function(resolve, reject) {
        function test() {
          var res = gl2.clientWaitSync(sync, flags, 0);
          if (res == gl2.WAIT_FAILED) {
            reject();
            return;
          }
          if (res == gl2.TIMEOUT_EXPIRED) {
            setTimeout(test, clamp_default(interval_ms, 0, gl2.MAX_CLIENT_WAIT_TIMEOUT_WEBGL));
            return;
          }
          resolve();
        }
        test();
      });
    };
    Readback_GL2.prototype.getBufferSubDataAsync = function(target, buffer, srcByteOffset, dstBuffer, dstOffset, length2) {
      return __awaiter(this, void 0, void 0, function() {
        var gl2;
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              gl2 = this.device.gl;
              if (!isWebGL2(gl2))
                return [3, 2];
              this.gl_sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
              gl2.flush();
              return [4, this.clientWaitAsync(this.gl_sync, 0, 10)];
            case 1:
              _a2.sent();
              gl2.bindBuffer(target, buffer);
              gl2.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length2);
              gl2.bindBuffer(target, null);
              return [2, dstBuffer];
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Readback_GL2.prototype.readTexture = function(t, x, y, width, height, dstBuffer, dstOffset, length2) {
      if (dstOffset === void 0) {
        dstOffset = 0;
      }
      if (length2 === void 0) {
        length2 = dstBuffer.byteLength || 0;
      }
      return __awaiter(this, void 0, void 0, function() {
        var gl2, texture, gl_format, gl_type, formatByteSize;
        return __generator2(this, function(_a2) {
          gl2 = this.device.gl;
          texture = t;
          gl_format = this.device.translateTextureFormat(texture.format);
          gl_type = this.device.translateTextureType(texture.format);
          formatByteSize = getFormatByteSize(texture.format);
          if (isWebGL2(gl2)) {
            this.gl_pbo = this.device.ensureResourceExists(gl2.createBuffer());
            gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, this.gl_pbo);
            gl2.bufferData(gl2.PIXEL_PACK_BUFFER, length2, gl2.STREAM_READ);
            gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
            gl2.bindFramebuffer(GL.READ_FRAMEBUFFER, this.device["readbackFramebuffer"]);
            gl2.framebufferTexture2D(GL.READ_FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, texture.gl_texture, 0);
            gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, this.gl_pbo);
            gl2.readPixels(x, y, width, height, gl_format, gl_type, dstOffset * formatByteSize);
            gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
            return [2, this.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER, this.gl_pbo, 0, dstBuffer, dstOffset, 0)];
          } else {
            return [2, this.readTextureSync(t, x, y, width, height, dstBuffer, dstOffset, length2)];
          }
        });
      });
    };
    Readback_GL2.prototype.readTextureSync = function(t, x, y, width, height, dstBuffer, dstOffset, length2) {
      if (length2 === void 0) {
        length2 = dstBuffer.byteLength || 0;
      }
      var gl2 = this.device.gl;
      var texture = t;
      var gl_type = this.device.translateTextureType(texture.format);
      gl2.bindFramebuffer(GL.FRAMEBUFFER, this.device["readbackFramebuffer"]);
      gl2.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, texture.gl_texture, 0);
      gl2.pixelStorei(gl2.PACK_ALIGNMENT, 4);
      gl2.readPixels(x, y, width, height, gl2.RGBA, gl_type, dstBuffer);
      return dstBuffer;
    };
    Readback_GL2.prototype.readBuffer = function(b, srcByteOffset, dstBuffer, dstOffset, length2) {
      return __awaiter(this, void 0, void 0, function() {
        var gl2;
        return __generator2(this, function(_a2) {
          gl2 = this.device.gl;
          if (isWebGL2(gl2)) {
            return [2, this.getBufferSubDataAsync(gl2.ARRAY_BUFFER, getPlatformBuffer$1(b, srcByteOffset), srcByteOffset, dstBuffer, dstOffset, length2)];
          }
          return [2, Promise.reject()];
        });
      });
    };
    Readback_GL2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (isWebGL2(this.device.gl)) {
        if (this.gl_sync !== null) {
          this.device.gl.deleteSync(this.gl_sync);
        }
        if (this.gl_pbo !== null) {
          this.device.gl.deleteBuffer(this.gl_pbo);
        }
      }
    };
    return Readback_GL2;
  }(ResourceBase_GL)
);
var RenderPipeline_GL = (
  /** @class */
  function(_super) {
    __extends(RenderPipeline_GL2, _super);
    function RenderPipeline_GL2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _b, _c;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.RenderPipeline;
      _this.drawMode = translatePrimitiveTopology((_b = descriptor.topology) !== null && _b !== void 0 ? _b : PrimitiveTopology.TRIANGLES);
      _this.program = descriptor.program;
      _this.inputLayout = descriptor.inputLayout;
      _this.megaState = __assign(__assign({}, copyMegaState(defaultMegaState)), descriptor.megaStateDescriptor);
      _this.colorAttachmentFormats = descriptor.colorAttachmentFormats.slice();
      _this.depthStencilAttachmentFormat = descriptor.depthStencilAttachmentFormat;
      _this.sampleCount = (_c = descriptor.sampleCount) !== null && _c !== void 0 ? _c : 1;
      return _this;
    }
    return RenderPipeline_GL2;
  }(ResourceBase_GL)
);
var ComputePipeline_GL = (
  /** @class */
  function(_super) {
    __extends(ComputePipeline_GL2, _super);
    function ComputePipeline_GL2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.ComputePipeline;
      _this.descriptor = descriptor;
      return _this;
    }
    return ComputePipeline_GL2;
  }(ResourceBase_GL)
);
var ResourceCreationTracker = (
  /** @class */
  function() {
    function ResourceCreationTracker2() {
      this.liveObjects = /* @__PURE__ */ new Set();
      this.creationStacks = /* @__PURE__ */ new Map();
      this.deletionStacks = /* @__PURE__ */ new Map();
    }
    ResourceCreationTracker2.prototype.trackResourceCreated = function(o) {
      this.creationStacks.set(o, new Error().stack);
      this.liveObjects.add(o);
    };
    ResourceCreationTracker2.prototype.trackResourceDestroyed = function(o) {
      if (this.deletionStacks.has(o))
        console.warn("Object double freed:", o, "\n\nCreation stack: ", this.creationStacks.get(o), "\n\nDeletion stack: ", this.deletionStacks.get(o), "\n\nThis stack: ", new Error().stack);
      this.deletionStacks.set(o, new Error().stack);
      this.liveObjects.delete(o);
    };
    ResourceCreationTracker2.prototype.checkForLeaks = function() {
      var e_1, _a2;
      try {
        for (var _b = __values(this.liveObjects.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var o = _c.value;
          console.warn("Object leaked:", o, "Creation stack:", this.creationStacks.get(o));
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    ResourceCreationTracker2.prototype.setResourceLeakCheck = function(o, v2) {
      if (v2) {
        this.liveObjects.add(o);
      } else {
        this.liveObjects.delete(o);
      }
    };
    return ResourceCreationTracker2;
  }()
);
var Sampler_GL = (
  /** @class */
  function(_super) {
    __extends(Sampler_GL2, _super);
    function Sampler_GL2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _b, _c;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.Sampler;
      var gl2 = _this.device.gl;
      if (isWebGL2(gl2)) {
        var gl_sampler = _this.device.ensureResourceExists(gl2.createSampler());
        gl2.samplerParameteri(gl_sampler, GL.TEXTURE_WRAP_S, translateAddressMode$1(descriptor.addressModeU));
        gl2.samplerParameteri(gl_sampler, GL.TEXTURE_WRAP_T, translateAddressMode$1(descriptor.addressModeV));
        gl2.samplerParameteri(gl_sampler, GL.TEXTURE_WRAP_R, translateAddressMode$1((_b = descriptor.addressModeW) !== null && _b !== void 0 ? _b : descriptor.addressModeU));
        gl2.samplerParameteri(gl_sampler, GL.TEXTURE_MIN_FILTER, translateFilterMode(descriptor.minFilter, descriptor.mipmapFilter));
        gl2.samplerParameteri(gl_sampler, GL.TEXTURE_MAG_FILTER, translateFilterMode(descriptor.magFilter, MipmapFilterMode.NO_MIP));
        if (descriptor.lodMinClamp !== void 0) {
          gl2.samplerParameterf(gl_sampler, GL.TEXTURE_MIN_LOD, descriptor.lodMinClamp);
        }
        if (descriptor.lodMaxClamp !== void 0) {
          gl2.samplerParameterf(gl_sampler, GL.TEXTURE_MAX_LOD, descriptor.lodMaxClamp);
        }
        if (descriptor.compareFunction !== void 0) {
          gl2.samplerParameteri(gl_sampler, gl2.TEXTURE_COMPARE_MODE, gl2.COMPARE_REF_TO_TEXTURE);
          gl2.samplerParameteri(gl_sampler, gl2.TEXTURE_COMPARE_FUNC, descriptor.compareFunction);
        }
        var maxAnisotropy = (_c = descriptor.maxAnisotropy) !== null && _c !== void 0 ? _c : 1;
        if (maxAnisotropy > 1 && _this.device.EXT_texture_filter_anisotropic !== null) {
          assert(descriptor.minFilter === FilterMode.BILINEAR && descriptor.magFilter === FilterMode.BILINEAR && descriptor.mipmapFilter === MipmapFilterMode.LINEAR);
          gl2.samplerParameterf(gl_sampler, _this.device.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, maxAnisotropy);
        }
        _this.gl_sampler = gl_sampler;
      } else {
        _this.descriptor = descriptor;
      }
      return _this;
    }
    Sampler_GL2.prototype.setTextureParameters = function(gl_target, width, height) {
      var _a2;
      var gl2 = this.device.gl;
      var descriptor = this.descriptor;
      if (this.isNPOT(width, height)) {
        gl2.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR);
      } else {
        gl2.texParameteri(gl_target, GL.TEXTURE_MIN_FILTER, translateFilterMode(descriptor.minFilter, descriptor.mipmapFilter));
      }
      gl2.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, translateAddressMode$1(descriptor.addressModeU));
      gl2.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, translateAddressMode$1(descriptor.addressModeV));
      gl2.texParameteri(gl_target, GL.TEXTURE_MAG_FILTER, translateFilterMode(descriptor.magFilter, MipmapFilterMode.NO_MIP));
      var maxAnisotropy = (_a2 = descriptor.maxAnisotropy) !== null && _a2 !== void 0 ? _a2 : 1;
      if (maxAnisotropy > 1 && this.device.EXT_texture_filter_anisotropic !== null) {
        assert(descriptor.minFilter === FilterMode.BILINEAR && descriptor.magFilter === FilterMode.BILINEAR && descriptor.mipmapFilter === MipmapFilterMode.LINEAR);
        gl2.texParameteri(gl_target, this.device.EXT_texture_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, maxAnisotropy);
      }
    };
    Sampler_GL2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (isWebGL2(this.device.gl)) {
        this.device.gl.deleteSampler(getPlatformSampler$1(this));
      }
    };
    Sampler_GL2.prototype.isNPOT = function(width, height) {
      return !isPowerOfTwo(width) || !isPowerOfTwo(height);
    };
    return Sampler_GL2;
  }(ResourceBase_GL)
);
var ComputePass_GL = (
  /** @class */
  function() {
    function ComputePass_GL2() {
    }
    ComputePass_GL2.prototype.dispatchWorkgroups = function(workgroupCountX, workgroupCountY, workgroupCountZ) {
    };
    ComputePass_GL2.prototype.dispatchWorkgroupsIndirect = function(indirectBuffer, indirectOffset) {
    };
    ComputePass_GL2.prototype.setPipeline = function(pipeline_) {
    };
    ComputePass_GL2.prototype.setBindings = function(bindings_) {
    };
    ComputePass_GL2.prototype.pushDebugGroup = function(name) {
    };
    ComputePass_GL2.prototype.popDebugGroup = function() {
    };
    ComputePass_GL2.prototype.insertDebugMarker = function(markerLabel) {
    };
    return ComputePass_GL2;
  }()
);
var RenderBundle_GL = (
  /** @class */
  function(_super) {
    __extends(RenderBundle_GL2, _super);
    function RenderBundle_GL2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = ResourceType.RenderBundle;
      _this.commands = [];
      return _this;
    }
    RenderBundle_GL2.prototype.push = function(f) {
      this.commands.push(f);
    };
    RenderBundle_GL2.prototype.replay = function() {
      this.commands.forEach(function(f) {
        return f();
      });
    };
    return RenderBundle_GL2;
  }(ResourceBase_GL)
);
var UBO_PAGE_MAX_BYTE_SIZE = 65536;
var UNIFROM_BLOCK_REGEXP = /uniform(?:\s+)(\w+)(?:\s?){([^]*?)}/g;
var Device_GL = (
  /** @class */
  function() {
    function Device_GL2(gl2, configuration) {
      if (configuration === void 0) {
        configuration = {};
      }
      this.shaderDebug = false;
      this.OES_vertex_array_object = null;
      this.ANGLE_instanced_arrays = null;
      this.OES_texture_float = null;
      this.OES_draw_buffers_indexed = null;
      this.WEBGL_draw_buffers = null;
      this.WEBGL_depth_texture = null;
      this.WEBGL_color_buffer_float = null;
      this.EXT_color_buffer_half_float = null;
      this.WEBGL_compressed_texture_s3tc = null;
      this.WEBGL_compressed_texture_s3tc_srgb = null;
      this.EXT_texture_compression_rgtc = null;
      this.EXT_texture_filter_anisotropic = null;
      this.KHR_parallel_shader_compile = null;
      this.EXT_texture_norm16 = null;
      this.EXT_color_buffer_float = null;
      this.OES_texture_float_linear = null;
      this.OES_texture_half_float_linear = null;
      this.scTexture = null;
      this.scPlatformFramebuffer = null;
      this.currentActiveTexture = null;
      this.currentBoundVAO = null;
      this.currentProgram = null;
      this.resourceCreationTracker = null;
      this.resourceUniqueId = 0;
      this.currentColorAttachments = [];
      this.currentColorAttachmentLevels = [];
      this.currentColorResolveTos = [];
      this.currentColorResolveToLevels = [];
      this.currentSampleCount = -1;
      this.currentIndexBufferByteOffset = null;
      this.currentMegaState = copyMegaState(defaultMegaState);
      this.currentSamplers = [];
      this.currentTextures = [];
      this.currentUniformBuffers = [];
      this.currentUniformBufferByteOffsets = [];
      this.currentUniformBufferByteSizes = [];
      this.currentScissorEnabled = false;
      this.currentStencilRef = null;
      this.currentRenderPassDescriptor = null;
      this.currentRenderPassDescriptorStack = [];
      this.debugGroupStack = [];
      this.resolveColorAttachmentsChanged = false;
      this.resolveDepthStencilAttachmentsChanged = false;
      this.explicitBindingLocations = false;
      this.separateSamplerTextures = false;
      this.viewportOrigin = ViewportOrigin.LOWER_LEFT;
      this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
      this.supportMRT = false;
      this.inBlitRenderPass = false;
      this.supportedSampleCounts = [];
      this.occlusionQueriesRecommended = false;
      this.computeShadersSupported = false;
      this.gl = gl2;
      this.contextAttributes = assertExists(gl2.getContextAttributes());
      if (!isWebGL2(gl2)) {
        this.OES_vertex_array_object = gl2.getExtension("OES_vertex_array_object");
        this.ANGLE_instanced_arrays = gl2.getExtension("ANGLE_instanced_arrays");
        this.OES_texture_float = gl2.getExtension("OES_texture_float");
        this.WEBGL_draw_buffers = gl2.getExtension("WEBGL_draw_buffers");
        this.WEBGL_depth_texture = gl2.getExtension("WEBGL_depth_texture");
        this.WEBGL_color_buffer_float = gl2.getExtension("WEBGL_color_buffer_float");
        this.EXT_color_buffer_half_float = gl2.getExtension("EXT_color_buffer_half_float");
        gl2.getExtension("EXT_frag_depth");
        gl2.getExtension("OES_element_index_uint");
        gl2.getExtension("OES_standard_derivatives");
      } else {
        this.EXT_texture_norm16 = gl2.getExtension("EXT_texture_norm16");
        this.EXT_color_buffer_float = gl2.getExtension("EXT_color_buffer_float");
      }
      this.WEBGL_compressed_texture_s3tc = gl2.getExtension("WEBGL_compressed_texture_s3tc");
      this.WEBGL_compressed_texture_s3tc_srgb = gl2.getExtension("WEBGL_compressed_texture_s3tc_srgb");
      this.EXT_texture_compression_rgtc = gl2.getExtension("EXT_texture_compression_rgtc");
      this.EXT_texture_filter_anisotropic = gl2.getExtension("EXT_texture_filter_anisotropic");
      this.EXT_texture_norm16 = gl2.getExtension("EXT_texture_norm16");
      this.OES_texture_float_linear = gl2.getExtension("OES_texture_float_linear");
      this.OES_texture_half_float_linear = gl2.getExtension("OES_texture_half_float_linear");
      this.KHR_parallel_shader_compile = gl2.getExtension("KHR_parallel_shader_compile");
      if (isWebGL2(gl2)) {
        this.platformString = "WebGL2";
        this.glslVersion = "#version 300 es";
      } else {
        this.platformString = "WebGL1";
        this.glslVersion = "#version 100";
      }
      this.scTexture = new Texture_GL({
        id: this.getNextUniqueId(),
        device: this,
        descriptor: {
          width: 0,
          height: 0,
          depthOrArrayLayers: 1,
          dimension: TextureDimension.TEXTURE_2D,
          mipLevelCount: 1,
          usage: TextureUsage2.RENDER_TARGET,
          format: this.contextAttributes.alpha === false ? Format.U8_RGB_RT : Format.U8_RGBA_RT
        },
        fake: true
      });
      this.scTexture.formatKind = SamplerFormatKind.Float;
      this.scTexture.gl_target = null;
      this.scTexture.gl_texture = null;
      this.resolveColorReadFramebuffer = this.ensureResourceExists(gl2.createFramebuffer());
      this.resolveColorDrawFramebuffer = this.ensureResourceExists(gl2.createFramebuffer());
      this.resolveDepthStencilReadFramebuffer = this.ensureResourceExists(gl2.createFramebuffer());
      this.resolveDepthStencilDrawFramebuffer = this.ensureResourceExists(gl2.createFramebuffer());
      this.renderPassDrawFramebuffer = this.ensureResourceExists(gl2.createFramebuffer());
      this.readbackFramebuffer = this.ensureResourceExists(gl2.createFramebuffer());
      this.fallbackTexture2D = this.createFallbackTexture(TextureDimension.TEXTURE_2D, SamplerFormatKind.Float);
      this.fallbackTexture2DDepth = this.createFallbackTexture(TextureDimension.TEXTURE_2D, SamplerFormatKind.Depth);
      this.fallbackVertexBuffer = this.createBuffer({
        viewOrSize: 1,
        usage: BufferUsage.VERTEX,
        hint: BufferFrequencyHint.STATIC
      });
      if (isWebGL2(gl2)) {
        this.fallbackTexture2DArray = this.createFallbackTexture(TextureDimension.TEXTURE_2D_ARRAY, SamplerFormatKind.Float);
        this.fallbackTexture3D = this.createFallbackTexture(TextureDimension.TEXTURE_3D, SamplerFormatKind.Float);
        this.fallbackTextureCube = this.createFallbackTexture(TextureDimension.TEXTURE_CUBE_MAP, SamplerFormatKind.Float);
      }
      this.currentMegaState.depthCompare = CompareFunction.LESS;
      this.currentMegaState.depthWrite = false;
      this.currentMegaState.attachmentsState[0].channelWriteMask = ChannelWriteMask.ALL;
      gl2.enable(gl2.DEPTH_TEST);
      gl2.enable(gl2.STENCIL_TEST);
      this.checkLimits();
      if (configuration.shaderDebug) {
        this.shaderDebug = true;
      }
      if (configuration.trackResources) {
        this.resourceCreationTracker = new ResourceCreationTracker();
      }
    }
    Device_GL2.prototype.destroy = function() {
      if (this.blitBindings) {
        this.blitBindings.destroy();
      }
      if (this.blitInputLayout) {
        this.blitInputLayout.destroy();
      }
      if (this.blitRenderPipeline) {
        this.blitRenderPipeline.destroy();
      }
      if (this.blitVertexBuffer) {
        this.blitVertexBuffer.destroy();
      }
      if (this.blitProgram) {
        this.blitProgram.destroy();
      }
    };
    Device_GL2.prototype.createFallbackTexture = function(dimension, formatKind) {
      var depthOrArrayLayers = dimension === TextureDimension.TEXTURE_CUBE_MAP ? 6 : 1;
      var format2 = formatKind === SamplerFormatKind.Depth ? Format.D32F : Format.U8_RGBA_NORM;
      var texture = this.createTexture({
        dimension,
        format: format2,
        usage: TextureUsage2.SAMPLED,
        width: 1,
        height: 1,
        depthOrArrayLayers,
        mipLevelCount: 1
      });
      if (formatKind === SamplerFormatKind.Float) {
        texture.setImageData([new Uint8Array(4 * depthOrArrayLayers)]);
      }
      return getPlatformTexture(texture);
    };
    Device_GL2.prototype.getNextUniqueId = function() {
      return ++this.resourceUniqueId;
    };
    Device_GL2.prototype.checkLimits = function() {
      var gl2 = this.gl;
      this.maxVertexAttribs = gl2.getParameter(GL.MAX_VERTEX_ATTRIBS);
      if (isWebGL2(gl2)) {
        this.uniformBufferMaxPageByteSize = Math.min(gl2.getParameter(GL.MAX_UNIFORM_BLOCK_SIZE), UBO_PAGE_MAX_BYTE_SIZE);
        this.uniformBufferWordAlignment = gl2.getParameter(gl2.UNIFORM_BUFFER_OFFSET_ALIGNMENT) / 4;
        var supportedSampleCounts = gl2.getInternalformatParameter(gl2.RENDERBUFFER, gl2.DEPTH32F_STENCIL8, gl2.SAMPLES);
        this.supportedSampleCounts = supportedSampleCounts ? __spreadArray([], __read(supportedSampleCounts), false) : [];
        this.occlusionQueriesRecommended = true;
      } else {
        this.uniformBufferWordAlignment = 64;
        this.uniformBufferMaxPageByteSize = UBO_PAGE_MAX_BYTE_SIZE;
      }
      this.uniformBufferMaxPageWordSize = this.uniformBufferMaxPageByteSize / 4;
      if (!this.supportedSampleCounts.includes(1)) {
        this.supportedSampleCounts.push(1);
      }
      this.supportedSampleCounts.sort(function(a, b) {
        return a - b;
      });
    };
    Device_GL2.prototype.configureSwapChain = function(width, height, platformFramebuffer) {
      var texture = this.scTexture;
      texture.width = width;
      texture.height = height;
      this.scPlatformFramebuffer = nullify(platformFramebuffer);
    };
    Device_GL2.prototype.getDevice = function() {
      return this;
    };
    Device_GL2.prototype.getCanvas = function() {
      return this.gl.canvas;
    };
    Device_GL2.prototype.getOnscreenTexture = function() {
      return this.scTexture;
    };
    Device_GL2.prototype.beginFrame = function() {
    };
    Device_GL2.prototype.endFrame = function() {
    };
    Device_GL2.prototype.translateTextureInternalFormat = function(fmt, isRenderbufferStorage) {
      if (isRenderbufferStorage === void 0) {
        isRenderbufferStorage = false;
      }
      switch (fmt) {
        case Format.ALPHA:
          return GL.ALPHA;
        case Format.U8_LUMINANCE:
        case Format.F16_LUMINANCE:
        case Format.F32_LUMINANCE:
          return GL.LUMINANCE;
        case Format.F16_R:
          return GL.R16F;
        case Format.F16_RG:
          return GL.RG16F;
        case Format.F16_RGB:
          return GL.RGB16F;
        case Format.F16_RGBA:
          return GL.RGBA16F;
        case Format.F32_R:
          return GL.R32F;
        case Format.F32_RG:
          return GL.RG32F;
        case Format.F32_RGB:
          return GL.RGB32F;
        case Format.F32_RGBA:
          return isWebGL2(this.gl) ? GL.RGBA32F : isRenderbufferStorage ? this.WEBGL_color_buffer_float.RGBA32F_EXT : GL.RGBA;
        case Format.U8_R_NORM:
          return GL.R8;
        case Format.U8_RG_NORM:
          return GL.RG8;
        case Format.U8_RGB_NORM:
        case Format.U8_RGB_RT:
          return GL.RGB8;
        case Format.U8_RGB_SRGB:
          return GL.SRGB8;
        case Format.U8_RGBA_NORM:
        case Format.U8_RGBA_RT:
          return isWebGL2(this.gl) ? GL.RGBA8 : isRenderbufferStorage ? GL.RGBA4 : GL.RGBA;
        case Format.U8_RGBA:
          return GL.RGBA;
        case Format.U8_RGBA_SRGB:
        case Format.U8_RGBA_RT_SRGB:
          return GL.SRGB8_ALPHA8;
        case Format.U16_R:
          return GL.R16UI;
        case Format.U16_R_NORM:
          return this.EXT_texture_norm16.R16_EXT;
        case Format.U16_RG_NORM:
          return this.EXT_texture_norm16.RG16_EXT;
        case Format.U16_RGBA_NORM:
          return this.EXT_texture_norm16.RGBA16_EXT;
        case Format.U16_RGBA_5551:
          return GL.RGB5_A1;
        case Format.U16_RGB_565:
          return GL.RGB565;
        case Format.U32_R:
          return GL.R32UI;
        case Format.S8_RGBA_NORM:
          return GL.RGBA8_SNORM;
        case Format.S8_RG_NORM:
          return GL.RG8_SNORM;
        case Format.BC1:
          return this.WEBGL_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        case Format.BC1_SRGB:
          return this.WEBGL_compressed_texture_s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
        case Format.BC2:
          return this.WEBGL_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        case Format.BC2_SRGB:
          return this.WEBGL_compressed_texture_s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
        case Format.BC3:
          return this.WEBGL_compressed_texture_s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        case Format.BC3_SRGB:
          return this.WEBGL_compressed_texture_s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        case Format.BC4_UNORM:
          return this.EXT_texture_compression_rgtc.COMPRESSED_RED_RGTC1_EXT;
        case Format.BC4_SNORM:
          return this.EXT_texture_compression_rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        case Format.BC5_UNORM:
          return this.EXT_texture_compression_rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT;
        case Format.BC5_SNORM:
          return this.EXT_texture_compression_rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
        case Format.D32F_S8:
          return isWebGL2(this.gl) ? GL.DEPTH32F_STENCIL8 : this.WEBGL_depth_texture ? GL.DEPTH_STENCIL : GL.DEPTH_COMPONENT16;
        case Format.D24_S8:
          return isWebGL2(this.gl) ? GL.DEPTH24_STENCIL8 : this.WEBGL_depth_texture ? GL.DEPTH_STENCIL : GL.DEPTH_COMPONENT16;
        case Format.D32F:
          return isWebGL2(this.gl) ? GL.DEPTH_COMPONENT32F : this.WEBGL_depth_texture ? GL.DEPTH_COMPONENT : GL.DEPTH_COMPONENT16;
        case Format.D24:
          return isWebGL2(this.gl) ? GL.DEPTH_COMPONENT24 : this.WEBGL_depth_texture ? GL.DEPTH_COMPONENT : GL.DEPTH_COMPONENT16;
        default:
          throw new Error("whoops");
      }
    };
    Device_GL2.prototype.translateTextureType = function(fmt) {
      var typeFlags = getFormatTypeFlags(fmt);
      switch (typeFlags) {
        case FormatTypeFlags.U8:
          return GL.UNSIGNED_BYTE;
        case FormatTypeFlags.U16:
          return GL.UNSIGNED_SHORT;
        case FormatTypeFlags.U32:
          return GL.UNSIGNED_INT;
        case FormatTypeFlags.S8:
          return GL.BYTE;
        case FormatTypeFlags.F16:
          return GL.HALF_FLOAT;
        case FormatTypeFlags.F32:
          return GL.FLOAT;
        case FormatTypeFlags.U16_PACKED_5551:
          return GL.UNSIGNED_SHORT_5_5_5_1;
        case FormatTypeFlags.D32F:
          return isWebGL2(this.gl) ? GL.FLOAT : this.WEBGL_depth_texture ? GL.UNSIGNED_INT : GL.UNSIGNED_BYTE;
        case FormatTypeFlags.D24:
          return isWebGL2(this.gl) ? GL.UNSIGNED_INT_24_8 : this.WEBGL_depth_texture ? GL.UNSIGNED_SHORT : GL.UNSIGNED_BYTE;
        case FormatTypeFlags.D24S8:
          return isWebGL2(this.gl) ? GL.UNSIGNED_INT_24_8 : this.WEBGL_depth_texture ? GL.UNSIGNED_INT_24_8_WEBGL : GL.UNSIGNED_BYTE;
        case FormatTypeFlags.D32FS8:
          return GL.FLOAT_32_UNSIGNED_INT_24_8_REV;
        default:
          throw new Error("whoops");
      }
    };
    Device_GL2.prototype.translateInternalTextureFormat = function(fmt) {
      switch (fmt) {
        case Format.F32_R:
          return GL.R32F;
        case Format.F32_RG:
          return GL.RG32F;
        case Format.F32_RGB:
          return GL.RGB32F;
        case Format.F32_RGBA:
          return GL.RGBA32F;
        case Format.F16_R:
          return GL.R16F;
        case Format.F16_RG:
          return GL.RG16F;
        case Format.F16_RGB:
          return GL.RGB16F;
        case Format.F16_RGBA:
          return GL.RGBA16F;
      }
      return this.translateTextureFormat(fmt);
    };
    Device_GL2.prototype.translateTextureFormat = function(fmt) {
      if (isTextureFormatCompressed(fmt) || fmt === Format.F32_LUMINANCE || fmt === Format.U8_LUMINANCE) {
        return this.translateTextureInternalFormat(fmt);
      }
      var supportDepthTexture = isWebGL2(this.gl) || !isWebGL2(this.gl) && !!this.WEBGL_depth_texture;
      switch (fmt) {
        case Format.D24_S8:
        case Format.D32F_S8:
          return supportDepthTexture ? GL.DEPTH_STENCIL : GL.RGBA;
        case Format.D24:
        case Format.D32F:
          return supportDepthTexture ? GL.DEPTH_COMPONENT : GL.RGBA;
      }
      var isInteger2 = isFormatSizedInteger(fmt);
      var compFlags = getFormatCompFlags(fmt);
      switch (compFlags) {
        case FormatCompFlags.A:
          return GL.ALPHA;
        case FormatCompFlags.R:
          return isInteger2 ? GL.RED_INTEGER : GL.RED;
        case FormatCompFlags.RG:
          return isInteger2 ? GL.RG_INTEGER : GL.RG;
        case FormatCompFlags.RGB:
          return isInteger2 ? GL.RGB_INTEGER : GL.RGB;
        case FormatCompFlags.RGBA:
          return GL.RGBA;
      }
    };
    Device_GL2.prototype.setActiveTexture = function(texture) {
      if (this.currentActiveTexture !== texture) {
        this.gl.activeTexture(texture);
        this.currentActiveTexture = texture;
      }
    };
    Device_GL2.prototype.bindVAO = function(vao) {
      if (this.currentBoundVAO !== vao) {
        if (isWebGL2(this.gl)) {
          this.gl.bindVertexArray(vao);
        } else {
          this.OES_vertex_array_object.bindVertexArrayOES(vao);
        }
        this.currentBoundVAO = vao;
      }
    };
    Device_GL2.prototype.programCompiled = function(program) {
      assert(program.compileState !== ProgramCompileState_GL.NeedsCompile);
      if (program.compileState === ProgramCompileState_GL.Compiling) {
        program.compileState = ProgramCompileState_GL.NeedsBind;
        if (this.shaderDebug) {
          this.checkProgramCompilationForErrors(program);
        }
      }
    };
    Device_GL2.prototype.useProgram = function(program) {
      if (this.currentProgram === program)
        return;
      this.programCompiled(program);
      this.gl.useProgram(program.gl_program);
      this.currentProgram = program;
    };
    Device_GL2.prototype.ensureResourceExists = function(resource) {
      if (resource === null) {
        var error = this.gl.getError();
        throw new Error("Created resource is null; GL error encountered: ".concat(error));
      } else {
        return resource;
      }
    };
    Device_GL2.prototype.createBuffer = function(descriptor) {
      return new Buffer_GL({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_GL2.prototype.createTexture = function(descriptor) {
      return new Texture_GL({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_GL2.prototype.createSampler = function(descriptor) {
      return new Sampler_GL({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_GL2.prototype.createRenderTarget = function(descriptor) {
      return new RenderTarget_GL({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_GL2.prototype.createRenderTargetFromTexture = function(texture) {
      var _a2 = texture, format2 = _a2.format, width = _a2.width, height = _a2.height, mipLevelCount = _a2.mipLevelCount;
      assert(mipLevelCount === 1);
      return this.createRenderTarget({
        format: format2,
        width,
        height,
        sampleCount: 1,
        texture
      });
    };
    Device_GL2.prototype.createProgram = function(descriptor) {
      var _a2, _b, _c;
      var rawVertexGLSL = (_a2 = descriptor.vertex) === null || _a2 === void 0 ? void 0 : _a2.glsl;
      if ((_b = descriptor.vertex) === null || _b === void 0 ? void 0 : _b.glsl) {
        descriptor.vertex.glsl = preprocessShader_GLSL(this.queryVendorInfo(), "vert", descriptor.vertex.glsl);
      }
      if ((_c = descriptor.fragment) === null || _c === void 0 ? void 0 : _c.glsl) {
        descriptor.fragment.glsl = preprocessShader_GLSL(this.queryVendorInfo(), "frag", descriptor.fragment.glsl);
      }
      return this.createProgramSimple(descriptor, rawVertexGLSL);
    };
    Device_GL2.prototype.createProgramSimple = function(descriptor, rawVertexGLSL) {
      var program = new Program_GL({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      }, rawVertexGLSL);
      return program;
    };
    Device_GL2.prototype.createBindings = function(descriptor) {
      return new Bindings_GL({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_GL2.prototype.createInputLayout = function(descriptor) {
      return new InputLayout_GL({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_GL2.prototype.createRenderPipeline = function(descriptor) {
      return new RenderPipeline_GL({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_GL2.prototype.createComputePass = function() {
      return new ComputePass_GL();
    };
    Device_GL2.prototype.createComputePipeline = function(descriptor) {
      return new ComputePipeline_GL({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_GL2.prototype.createReadback = function() {
      return new Readback_GL({
        id: this.getNextUniqueId(),
        device: this
      });
    };
    Device_GL2.prototype.createQueryPool = function(type, elemCount) {
      return new QueryPool_GL({
        id: this.getNextUniqueId(),
        device: this,
        descriptor: {
          type,
          elemCount
        }
      });
    };
    Device_GL2.prototype.formatRenderPassDescriptor = function(descriptor) {
      var _a2, _b, _c, _d, _e, _f;
      var colorAttachment = descriptor.colorAttachment;
      descriptor.depthClearValue = (_a2 = descriptor.depthClearValue) !== null && _a2 !== void 0 ? _a2 : "load";
      descriptor.stencilClearValue = (_b = descriptor.stencilClearValue) !== null && _b !== void 0 ? _b : "load";
      for (var i = 0; i < colorAttachment.length; i++) {
        if (!descriptor.colorAttachmentLevel) {
          descriptor.colorAttachmentLevel = [];
        }
        descriptor.colorAttachmentLevel[i] = (_c = descriptor.colorAttachmentLevel[i]) !== null && _c !== void 0 ? _c : 0;
        if (!descriptor.colorResolveToLevel) {
          descriptor.colorResolveToLevel = [];
        }
        descriptor.colorResolveToLevel[i] = (_d = descriptor.colorResolveToLevel[i]) !== null && _d !== void 0 ? _d : 0;
        if (!descriptor.colorClearColor) {
          descriptor.colorClearColor = [];
        }
        descriptor.colorClearColor[i] = (_e = descriptor.colorClearColor[i]) !== null && _e !== void 0 ? _e : "load";
        if (!descriptor.colorStore) {
          descriptor.colorStore = [];
        }
        descriptor.colorStore[i] = (_f = descriptor.colorStore[i]) !== null && _f !== void 0 ? _f : false;
      }
    };
    Device_GL2.prototype.createRenderBundle = function() {
      return new RenderBundle_GL({
        id: this.getNextUniqueId(),
        device: this
      });
    };
    Device_GL2.prototype.beginBundle = function(bundle) {
      this.renderBundle = bundle;
    };
    Device_GL2.prototype.endBundle = function() {
      this.renderBundle = void 0;
    };
    Device_GL2.prototype.executeBundles = function(renderBundles) {
      renderBundles.forEach(function(renderBundle) {
        renderBundle.replay();
      });
    };
    Device_GL2.prototype.createRenderPass = function(descriptor) {
      if (this.currentRenderPassDescriptor !== null) {
        this.currentRenderPassDescriptorStack.push(this.currentRenderPassDescriptor);
      }
      this.currentRenderPassDescriptor = descriptor;
      this.formatRenderPassDescriptor(descriptor);
      var colorAttachment = descriptor.colorAttachment, colorAttachmentLevel = descriptor.colorAttachmentLevel, colorClearColor = descriptor.colorClearColor, colorResolveTo = descriptor.colorResolveTo, colorResolveToLevel = descriptor.colorResolveToLevel, depthStencilAttachment = descriptor.depthStencilAttachment, depthClearValue = descriptor.depthClearValue, stencilClearValue = descriptor.stencilClearValue, depthStencilResolveTo = descriptor.depthStencilResolveTo;
      var skipBlit = colorResolveTo && colorResolveTo.length === 1 && colorResolveTo[0] === this.scTexture;
      this.setRenderPassParametersBegin(colorAttachment.length, skipBlit);
      for (var i = 0; i < colorAttachment.length; i++) {
        this.setRenderPassParametersColor(i, colorAttachment[i], colorAttachmentLevel[i], colorResolveTo[i], colorResolveToLevel[i], skipBlit);
      }
      this.setRenderPassParametersDepthStencil(depthStencilAttachment, depthStencilResolveTo, skipBlit);
      this.validateCurrentAttachments();
      for (var i = 0; i < colorAttachment.length; i++) {
        var clearColor = colorClearColor[i];
        if (clearColor === "load")
          continue;
        this.setRenderPassParametersClearColor(i, clearColor.r, clearColor.g, clearColor.b, clearColor.a);
      }
      this.setRenderPassParametersClearDepthStencil(depthClearValue, stencilClearValue);
      return this;
    };
    Device_GL2.prototype.submitPass = function(pass) {
      assert(this.currentRenderPassDescriptor !== null);
      this.endPass();
      if (this.currentRenderPassDescriptorStack.length) {
        this.currentRenderPassDescriptor = this.currentRenderPassDescriptorStack.pop();
      } else {
        this.currentRenderPassDescriptor = null;
      }
    };
    Device_GL2.prototype.copySubTexture2D = function(dst_, dstX, dstY, src_, srcX, srcY) {
      var gl2 = this.gl;
      var dst = dst_;
      var src = src_;
      assert(src.mipLevelCount === 1);
      assert(dst.mipLevelCount === 1);
      if (isWebGL2(gl2)) {
        if (dst === this.scTexture) {
          gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, this.scPlatformFramebuffer);
        } else {
          gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, this.resolveColorDrawFramebuffer);
          this.bindFramebufferAttachment(gl2.DRAW_FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, dst, 0);
        }
        gl2.bindFramebuffer(gl2.READ_FRAMEBUFFER, this.resolveColorReadFramebuffer);
        this.bindFramebufferAttachment(gl2.READ_FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, src, 0);
        gl2.blitFramebuffer(srcX, srcY, srcX + src.width, srcY + src.height, dstX, dstY, dstX + src.width, dstY + src.height, gl2.COLOR_BUFFER_BIT, gl2.LINEAR);
        gl2.bindFramebuffer(gl2.READ_FRAMEBUFFER, null);
        gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, null);
      } else {
        if (dst === this.scTexture) {
          var rt = this.createRenderTargetFromTexture(src_);
          this.submitBlitRenderPass(rt, dst);
        }
      }
    };
    Device_GL2.prototype.queryLimits = function() {
      return this;
    };
    Device_GL2.prototype.queryTextureFormatSupported = function(format2, width, height) {
      switch (format2) {
        case Format.BC1_SRGB:
        case Format.BC2_SRGB:
        case Format.BC3_SRGB:
          if (this.WEBGL_compressed_texture_s3tc_srgb !== null)
            return isBlockCompressSized(width, height, 4, 4);
          return false;
        case Format.BC1:
        case Format.BC2:
        case Format.BC3:
          if (this.WEBGL_compressed_texture_s3tc !== null)
            return isBlockCompressSized(width, height, 4, 4);
          return false;
        case Format.BC4_UNORM:
        case Format.BC4_SNORM:
        case Format.BC5_UNORM:
        case Format.BC5_SNORM:
          if (this.EXT_texture_compression_rgtc !== null)
            return isBlockCompressSized(width, height, 4, 4);
          return false;
        case Format.U16_R_NORM:
        case Format.U16_RG_NORM:
        case Format.U16_RGBA_NORM:
          return this.EXT_texture_norm16 !== null;
        case Format.F32_R:
        case Format.F32_RG:
        case Format.F32_RGB:
        case Format.F32_RGBA:
          return this.OES_texture_float_linear !== null;
        case Format.F16_R:
        case Format.F16_RG:
        case Format.F16_RGB:
        case Format.F16_RGBA:
          return this.OES_texture_half_float_linear !== null;
        default:
          return true;
      }
    };
    Device_GL2.prototype.queryProgramReady = function(program) {
      var gl2 = this.gl;
      if (program.compileState === ProgramCompileState_GL.NeedsCompile) {
        throw new Error("whoops");
      }
      if (program.compileState === ProgramCompileState_GL.Compiling) {
        var complete = void 0;
        if (this.KHR_parallel_shader_compile !== null) {
          complete = gl2.getProgramParameter(program.gl_program, this.KHR_parallel_shader_compile.COMPLETION_STATUS_KHR);
        } else {
          complete = true;
        }
        if (complete) {
          this.programCompiled(program);
        }
        return complete;
      }
      return program.compileState === ProgramCompileState_GL.NeedsBind || program.compileState === ProgramCompileState_GL.ReadyToUse;
    };
    Device_GL2.prototype.queryPlatformAvailable = function() {
      return this.gl.isContextLost();
    };
    Device_GL2.prototype.queryVendorInfo = function() {
      return this;
    };
    Device_GL2.prototype.queryRenderPass = function(o) {
      return this.currentRenderPassDescriptor;
    };
    Device_GL2.prototype.queryRenderTarget = function(o) {
      var renderTarget = o;
      return renderTarget;
    };
    Device_GL2.prototype.setResourceName = function(o, name) {
      o.name = name;
      if (o.type === ResourceType.Buffer) {
        var gl_buffer_pages = o.gl_buffer_pages;
        for (var i = 0; i < gl_buffer_pages.length; i++)
          assignPlatformName(gl_buffer_pages[i], "".concat(name, " Page ").concat(i));
      } else if (o.type === ResourceType.Texture) {
        assignPlatformName(getPlatformTexture(o), name);
      } else if (o.type === ResourceType.Sampler) {
        assignPlatformName(getPlatformSampler$1(o), name);
      } else if (o.type === ResourceType.RenderTarget) {
        var gl_renderbuffer = o.gl_renderbuffer;
        if (gl_renderbuffer !== null)
          assignPlatformName(gl_renderbuffer, name);
      } else if (o.type === ResourceType.InputLayout) {
        assignPlatformName(o.vao, name);
      }
    };
    Device_GL2.prototype.setResourceLeakCheck = function(o, v2) {
      if (this.resourceCreationTracker !== null)
        this.resourceCreationTracker.setResourceLeakCheck(o, v2);
    };
    Device_GL2.prototype.checkForLeaks = function() {
      if (this.resourceCreationTracker !== null)
        this.resourceCreationTracker.checkForLeaks();
    };
    Device_GL2.prototype.pushDebugGroup = function(name) {
    };
    Device_GL2.prototype.popDebugGroup = function() {
    };
    Device_GL2.prototype.insertDebugMarker = function(markerLabel) {
    };
    Device_GL2.prototype.programPatched = function(o, descriptor) {
      assert(this.shaderDebug);
    };
    Device_GL2.prototype.getBufferData = function(buffer, dstBuffer, wordOffset) {
      if (wordOffset === void 0) {
        wordOffset = 0;
      }
      var gl2 = this.gl;
      if (isWebGL2(gl2)) {
        gl2.bindBuffer(gl2.COPY_READ_BUFFER, getPlatformBuffer$1(buffer, wordOffset * 4));
        gl2.getBufferSubData(gl2.COPY_READ_BUFFER, wordOffset * 4, dstBuffer);
      }
    };
    Device_GL2.prototype.debugGroupStatisticsDrawCall = function(count2) {
      if (count2 === void 0) {
        count2 = 1;
      }
      for (var i = this.debugGroupStack.length - 1; i >= 0; i--)
        this.debugGroupStack[i].drawCallCount += count2;
    };
    Device_GL2.prototype.debugGroupStatisticsBufferUpload = function(count2) {
      if (count2 === void 0) {
        count2 = 1;
      }
      for (var i = this.debugGroupStack.length - 1; i >= 0; i--)
        this.debugGroupStack[i].bufferUploadCount += count2;
    };
    Device_GL2.prototype.debugGroupStatisticsTextureBind = function(count2) {
      if (count2 === void 0) {
        count2 = 1;
      }
      for (var i = this.debugGroupStack.length - 1; i >= 0; i--)
        this.debugGroupStack[i].textureBindCount += count2;
    };
    Device_GL2.prototype.debugGroupStatisticsTriangles = function(count2) {
      for (var i = this.debugGroupStack.length - 1; i >= 0; i--)
        this.debugGroupStack[i].triangleCount += count2;
    };
    Device_GL2.prototype.reportShaderError = function(shader, str) {
      var gl2 = this.gl;
      var status = gl2.getShaderParameter(shader, gl2.COMPILE_STATUS);
      if (!status) {
        console.error(prependLineNo(str));
        var debug_shaders = gl2.getExtension("WEBGL_debug_shaders");
        if (debug_shaders)
          console.error(debug_shaders.getTranslatedShaderSource(shader));
        console.error(gl2.getShaderInfoLog(shader));
      }
      return status;
    };
    Device_GL2.prototype.checkProgramCompilationForErrors = function(program) {
      var gl2 = this.gl;
      var prog = program.gl_program;
      if (!gl2.getProgramParameter(prog, gl2.LINK_STATUS)) {
        var descriptor = program.descriptor;
        if (!this.reportShaderError(program.gl_shader_vert, descriptor.vertex.glsl))
          return;
        if (!this.reportShaderError(program.gl_shader_frag, descriptor.fragment.glsl))
          return;
        console.error(gl2.getProgramInfoLog(program.gl_program));
      }
    };
    Device_GL2.prototype.bindFramebufferAttachment = function(framebuffer, binding, attachment, level) {
      var gl2 = this.gl;
      if (isNil2(attachment)) {
        gl2.framebufferRenderbuffer(framebuffer, binding, gl2.RENDERBUFFER, null);
      } else if (attachment.type === ResourceType.RenderTarget) {
        if (attachment.gl_renderbuffer !== null) {
          gl2.framebufferRenderbuffer(framebuffer, binding, gl2.RENDERBUFFER, attachment.gl_renderbuffer);
        } else if (attachment.texture !== null) {
          gl2.framebufferTexture2D(framebuffer, binding, GL.TEXTURE_2D, getPlatformTexture(attachment.texture), level);
        }
      } else if (attachment.type === ResourceType.Texture) {
        var texture = getPlatformTexture(attachment);
        if (attachment.dimension === TextureDimension.TEXTURE_2D) {
          gl2.framebufferTexture2D(framebuffer, binding, GL.TEXTURE_2D, texture, level);
        } else if (isWebGL2(gl2) && attachment.dimension === TextureDimension.TEXTURE_2D_ARRAY)
          ;
      }
    };
    Device_GL2.prototype.bindFramebufferDepthStencilAttachment = function(framebuffer, attachment) {
      var gl2 = this.gl;
      var flags = !isNil2(attachment) ? getFormatFlags(attachment.format) : FormatFlags.Depth | FormatFlags.Stencil;
      var depth = !!(flags & FormatFlags.Depth);
      var stencil = !!(flags & FormatFlags.Stencil);
      if (depth && stencil) {
        var supportDepthTexture = isWebGL2(this.gl) || !isWebGL2(this.gl) && !!this.WEBGL_depth_texture;
        if (supportDepthTexture) {
          this.bindFramebufferAttachment(framebuffer, gl2.DEPTH_STENCIL_ATTACHMENT, attachment, 0);
        } else {
          this.bindFramebufferAttachment(framebuffer, gl2.DEPTH_ATTACHMENT, attachment, 0);
        }
      } else if (depth) {
        this.bindFramebufferAttachment(framebuffer, gl2.DEPTH_ATTACHMENT, attachment, 0);
        this.bindFramebufferAttachment(framebuffer, gl2.STENCIL_ATTACHMENT, null, 0);
      } else if (stencil) {
        this.bindFramebufferAttachment(framebuffer, gl2.STENCIL_ATTACHMENT, attachment, 0);
        this.bindFramebufferAttachment(framebuffer, gl2.DEPTH_ATTACHMENT, null, 0);
      }
    };
    Device_GL2.prototype.validateCurrentAttachments = function() {
      var sampleCount = -1, width = -1, height = -1;
      for (var i = 0; i < this.currentColorAttachments.length; i++) {
        var attachment = this.currentColorAttachments[i];
        if (attachment === null)
          continue;
        if (sampleCount === -1) {
          sampleCount = attachment.sampleCount;
          width = attachment.width;
          height = attachment.height;
        } else {
          assert(sampleCount === attachment.sampleCount);
          assert(width === attachment.width);
          assert(height === attachment.height);
        }
      }
      if (this.currentDepthStencilAttachment) {
        if (sampleCount === -1) {
          sampleCount = this.currentDepthStencilAttachment.sampleCount;
        } else {
          assert(sampleCount === this.currentDepthStencilAttachment.sampleCount);
          assert(width === this.currentDepthStencilAttachment.width);
          assert(height === this.currentDepthStencilAttachment.height);
        }
      }
      this.currentSampleCount = sampleCount;
    };
    Device_GL2.prototype.setRenderPassParametersBegin = function(numColorAttachments, toScreen) {
      if (toScreen === void 0) {
        toScreen = false;
      }
      var gl2 = this.gl;
      if (!toScreen) {
        if (isWebGL2(gl2)) {
          gl2.bindFramebuffer(GL.DRAW_FRAMEBUFFER, this.renderPassDrawFramebuffer);
        } else {
          if (!this.inBlitRenderPass) {
            gl2.bindFramebuffer(GL.FRAMEBUFFER, this.renderPassDrawFramebuffer);
          }
        }
        if (isWebGL2(gl2)) {
          gl2.drawBuffers([
            GL.COLOR_ATTACHMENT0,
            GL.COLOR_ATTACHMENT1,
            GL.COLOR_ATTACHMENT2,
            GL.COLOR_ATTACHMENT3
          ]);
        } else {
          if (!this.inBlitRenderPass && this.WEBGL_draw_buffers) {
            this.WEBGL_draw_buffers.drawBuffersWEBGL([
              GL.COLOR_ATTACHMENT0_WEBGL,
              GL.COLOR_ATTACHMENT1_WEBGL,
              GL.COLOR_ATTACHMENT2_WEBGL,
              GL.COLOR_ATTACHMENT3_WEBGL
              // gl_FragData[3]
            ]);
          }
        }
        if (!this.inBlitRenderPass) {
          for (var i = numColorAttachments; i < this.currentColorAttachments.length; i++) {
            var target = isWebGL2(gl2) ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER;
            var attachment = isWebGL2(gl2) ? GL.COLOR_ATTACHMENT0 : GL.COLOR_ATTACHMENT0_WEBGL;
            gl2.framebufferRenderbuffer(target, attachment + i, GL.RENDERBUFFER, null);
            gl2.framebufferTexture2D(target, attachment + i, GL.TEXTURE_2D, null, 0);
          }
        }
      } else {
        gl2.bindFramebuffer(GL.FRAMEBUFFER, null);
      }
      this.currentColorAttachments.length = numColorAttachments;
    };
    Device_GL2.prototype.setRenderPassParametersColor = function(i, colorAttachment, attachmentLevel, colorResolveTo, resolveToLevel, skipBlit) {
      if (skipBlit === void 0) {
        skipBlit = false;
      }
      var gl2 = this.gl;
      var gl22 = isWebGL2(gl2);
      if (this.currentColorAttachments[i] !== colorAttachment || this.currentColorAttachmentLevels[i] !== attachmentLevel) {
        this.currentColorAttachments[i] = colorAttachment;
        this.currentColorAttachmentLevels[i] = attachmentLevel;
        if (!skipBlit && (gl22 || !gl22 && this.WEBGL_draw_buffers)) {
          this.bindFramebufferAttachment(gl22 ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, (gl22 ? GL.COLOR_ATTACHMENT0 : GL.COLOR_ATTACHMENT0_WEBGL) + i, colorAttachment, attachmentLevel);
        }
        this.resolveColorAttachmentsChanged = true;
      }
      if (this.currentColorResolveTos[i] !== colorResolveTo || this.currentColorResolveToLevels[i] !== resolveToLevel) {
        this.currentColorResolveTos[i] = colorResolveTo;
        this.currentColorResolveToLevels[i] = resolveToLevel;
        if (colorResolveTo !== null) {
          this.resolveColorAttachmentsChanged = true;
        }
      }
    };
    Device_GL2.prototype.setRenderPassParametersDepthStencil = function(depthStencilAttachment, depthStencilResolveTo, skipBlit) {
      if (skipBlit === void 0) {
        skipBlit = false;
      }
      var gl2 = this.gl;
      if (this.currentDepthStencilAttachment !== depthStencilAttachment) {
        this.currentDepthStencilAttachment = depthStencilAttachment;
        if (!skipBlit && !this.inBlitRenderPass) {
          this.bindFramebufferDepthStencilAttachment(isWebGL2(gl2) ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, this.currentDepthStencilAttachment);
        }
        this.resolveDepthStencilAttachmentsChanged = true;
      }
      if (this.currentDepthStencilResolveTo !== depthStencilResolveTo) {
        this.currentDepthStencilResolveTo = depthStencilResolveTo;
        if (depthStencilResolveTo) {
          this.resolveDepthStencilAttachmentsChanged = true;
        }
      }
    };
    Device_GL2.prototype.setRenderPassParametersClearColor = function(slot, r, g, b, a) {
      var gl2 = this.gl;
      if (this.OES_draw_buffers_indexed !== null) {
        var attachment = this.currentMegaState.attachmentsState[slot];
        if (attachment && attachment.channelWriteMask !== ChannelWriteMask.ALL) {
          this.OES_draw_buffers_indexed.colorMaskiOES(slot, true, true, true, true);
          attachment.channelWriteMask = ChannelWriteMask.ALL;
        }
      } else {
        var attachment = this.currentMegaState.attachmentsState[0];
        if (attachment && attachment.channelWriteMask !== ChannelWriteMask.ALL) {
          gl2.colorMask(true, true, true, true);
          attachment.channelWriteMask = ChannelWriteMask.ALL;
        }
      }
      this.setScissorRectEnabled(false);
      if (isWebGL2(gl2)) {
        gl2.clearBufferfv(gl2.COLOR, slot, [r, g, b, a]);
      } else {
        gl2.clearColor(r, g, b, a);
        gl2.clear(gl2.COLOR_BUFFER_BIT);
      }
    };
    Device_GL2.prototype.setRenderPassParametersClearDepthStencil = function(depthClearValue, stencilClearValue) {
      if (depthClearValue === void 0) {
        depthClearValue = "load";
      }
      if (stencilClearValue === void 0) {
        stencilClearValue = "load";
      }
      var gl2 = this.gl;
      if (depthClearValue !== "load") {
        assert(!!this.currentDepthStencilAttachment);
        if (!this.currentMegaState.depthWrite) {
          gl2.depthMask(true);
          this.currentMegaState.depthWrite = true;
        }
        if (isWebGL2(gl2)) {
          gl2.clearBufferfv(gl2.DEPTH, 0, [depthClearValue]);
        } else {
          gl2.clearDepth(depthClearValue);
          gl2.clear(gl2.DEPTH_BUFFER_BIT);
        }
      }
      if (stencilClearValue !== "load") {
        assert(!!this.currentDepthStencilAttachment);
        if (!this.currentMegaState.stencilWrite) {
          gl2.enable(gl2.STENCIL_TEST);
          gl2.stencilMask(255);
          this.currentMegaState.stencilWrite = true;
        }
        if (isWebGL2(gl2)) {
          gl2.clearBufferiv(gl2.STENCIL, 0, [stencilClearValue]);
        } else {
          gl2.clearStencil(stencilClearValue);
          gl2.clear(gl2.STENCIL_BUFFER_BIT);
        }
      }
    };
    Device_GL2.prototype.setBindings = function(bindings_) {
      var _this = this;
      var _a2;
      if (this.renderBundle) {
        this.renderBundle.push(function() {
          return _this.setBindings(bindings_);
        });
        return;
      }
      var gl2 = this.gl;
      var _b = bindings_, uniformBufferBindings = _b.uniformBufferBindings, samplerBindings = _b.samplerBindings, bindingLayouts = _b.bindingLayouts;
      assert(0 < bindingLayouts.bindingLayoutTables.length);
      var bindingLayoutTable = bindingLayouts.bindingLayoutTables[0];
      assert(uniformBufferBindings.length >= bindingLayoutTable.numUniformBuffers);
      assert(samplerBindings.length >= bindingLayoutTable.numSamplers);
      for (var i = 0; i < uniformBufferBindings.length; i++) {
        var binding = uniformBufferBindings[i];
        if (binding.size === 0)
          continue;
        var index3 = bindingLayoutTable.firstUniformBuffer + i;
        var buffer = binding.buffer;
        var byteOffset = binding.offset || 0;
        var byteSize = binding.size || buffer.byteSize;
        if (buffer !== this.currentUniformBuffers[index3] || byteOffset !== this.currentUniformBufferByteOffsets[index3] || byteSize !== this.currentUniformBufferByteSizes[index3]) {
          var platformBufferByteOffset = byteOffset % buffer.pageByteSize;
          var platformBuffer = buffer.gl_buffer_pages[byteOffset / buffer.pageByteSize | 0];
          assert(platformBufferByteOffset + byteSize <= buffer.pageByteSize);
          if (isWebGL2(gl2)) {
            gl2.bindBufferRange(gl2.UNIFORM_BUFFER, index3, platformBuffer, platformBufferByteOffset, byteSize);
          }
          this.currentUniformBuffers[index3] = buffer;
          this.currentUniformBufferByteOffsets[index3] = byteOffset;
          this.currentUniformBufferByteSizes[index3] = byteSize;
        }
      }
      for (var i = 0; i < bindingLayoutTable.numSamplers; i++) {
        var binding = samplerBindings[i];
        var samplerIndex = bindingLayoutTable.firstSampler + i;
        var gl_sampler = binding !== null && binding.sampler !== null ? getPlatformSampler$1(binding.sampler) : null;
        var gl_texture = binding !== null && binding.texture !== null ? getPlatformTexture(binding.texture) : null;
        if (this.currentSamplers[samplerIndex] !== gl_sampler) {
          if (isWebGL2(gl2)) {
            gl2.bindSampler(samplerIndex, gl_sampler);
          }
          this.currentSamplers[samplerIndex] = gl_sampler;
        }
        if (this.currentTextures[samplerIndex] !== gl_texture) {
          this.setActiveTexture(gl2.TEXTURE0 + samplerIndex);
          if (gl_texture !== null) {
            var _c = assertExists(binding).texture, gl_target = _c.gl_target, width = _c.width, height = _c.height;
            binding.texture.textureIndex = samplerIndex;
            gl2.bindTexture(gl_target, gl_texture);
            if (!isWebGL2(gl2)) {
              (_a2 = binding.sampler) === null || _a2 === void 0 ? void 0 : _a2.setTextureParameters(gl_target, width, height);
            }
            this.debugGroupStatisticsTextureBind();
          } else {
            var samplerEntry = __assign(__assign({}, binding), defaultBindingLayoutSamplerDescriptor);
            var dimension = samplerEntry.dimension, formatKind = samplerEntry.formatKind;
            var gl_target = translateTextureDimension$1(dimension);
            gl2.bindTexture(gl_target, this.getFallbackTexture(__assign({ gl_target, formatKind }, samplerEntry)));
          }
          this.currentTextures[samplerIndex] = gl_texture;
        }
      }
    };
    Device_GL2.prototype.setViewport = function(x, y, w, h) {
      var gl2 = this.gl;
      gl2.viewport(x, y, w, h);
    };
    Device_GL2.prototype.setScissorRect = function(x, y, w, h) {
      var gl2 = this.gl;
      this.setScissorRectEnabled(true);
      gl2.scissor(x, y, w, h);
    };
    Device_GL2.prototype.applyAttachmentStateIndexed = function(i, currentAttachmentState, newAttachmentState) {
      var gl2 = this.gl;
      var dbi = this.OES_draw_buffers_indexed;
      if (currentAttachmentState.channelWriteMask !== newAttachmentState.channelWriteMask) {
        dbi.colorMaskiOES(i, !!(newAttachmentState.channelWriteMask & ChannelWriteMask.RED), !!(newAttachmentState.channelWriteMask & ChannelWriteMask.GREEN), !!(newAttachmentState.channelWriteMask & ChannelWriteMask.BLUE), !!(newAttachmentState.channelWriteMask & ChannelWriteMask.ALPHA));
        currentAttachmentState.channelWriteMask = newAttachmentState.channelWriteMask;
      }
      var blendModeChanged = currentAttachmentState.rgbBlendState.blendMode !== newAttachmentState.rgbBlendState.blendMode || currentAttachmentState.alphaBlendState.blendMode !== newAttachmentState.alphaBlendState.blendMode;
      var blendFuncChanged = currentAttachmentState.rgbBlendState.blendSrcFactor !== newAttachmentState.rgbBlendState.blendSrcFactor || currentAttachmentState.alphaBlendState.blendSrcFactor !== newAttachmentState.alphaBlendState.blendSrcFactor || currentAttachmentState.rgbBlendState.blendDstFactor !== newAttachmentState.rgbBlendState.blendDstFactor || currentAttachmentState.alphaBlendState.blendDstFactor !== newAttachmentState.alphaBlendState.blendDstFactor;
      if (blendFuncChanged || blendModeChanged) {
        if (isBlendStateNone(currentAttachmentState.rgbBlendState) && isBlendStateNone(currentAttachmentState.alphaBlendState))
          dbi.enableiOES(i, gl2.BLEND);
        else if (isBlendStateNone(newAttachmentState.rgbBlendState) && isBlendStateNone(newAttachmentState.alphaBlendState))
          dbi.disableiOES(i, gl2.BLEND);
      }
      if (blendModeChanged) {
        dbi.blendEquationSeparateiOES(i, newAttachmentState.rgbBlendState.blendMode, newAttachmentState.alphaBlendState.blendMode);
        currentAttachmentState.rgbBlendState.blendMode = newAttachmentState.rgbBlendState.blendMode;
        currentAttachmentState.alphaBlendState.blendMode = newAttachmentState.alphaBlendState.blendMode;
      }
      if (blendFuncChanged) {
        dbi.blendFuncSeparateiOES(i, newAttachmentState.rgbBlendState.blendSrcFactor, newAttachmentState.rgbBlendState.blendDstFactor, newAttachmentState.alphaBlendState.blendSrcFactor, newAttachmentState.alphaBlendState.blendDstFactor);
        currentAttachmentState.rgbBlendState.blendSrcFactor = newAttachmentState.rgbBlendState.blendSrcFactor;
        currentAttachmentState.alphaBlendState.blendSrcFactor = newAttachmentState.alphaBlendState.blendSrcFactor;
        currentAttachmentState.rgbBlendState.blendDstFactor = newAttachmentState.rgbBlendState.blendDstFactor;
        currentAttachmentState.alphaBlendState.blendDstFactor = newAttachmentState.alphaBlendState.blendDstFactor;
      }
    };
    Device_GL2.prototype.applyAttachmentState = function(currentAttachmentState, newAttachmentState) {
      var gl2 = this.gl;
      if (currentAttachmentState.channelWriteMask !== newAttachmentState.channelWriteMask) {
        gl2.colorMask(!!(newAttachmentState.channelWriteMask & ChannelWriteMask.RED), !!(newAttachmentState.channelWriteMask & ChannelWriteMask.GREEN), !!(newAttachmentState.channelWriteMask & ChannelWriteMask.BLUE), !!(newAttachmentState.channelWriteMask & ChannelWriteMask.ALPHA));
        currentAttachmentState.channelWriteMask = newAttachmentState.channelWriteMask;
      }
      var blendModeChanged = currentAttachmentState.rgbBlendState.blendMode !== newAttachmentState.rgbBlendState.blendMode || currentAttachmentState.alphaBlendState.blendMode !== newAttachmentState.alphaBlendState.blendMode;
      var blendFuncChanged = currentAttachmentState.rgbBlendState.blendSrcFactor !== newAttachmentState.rgbBlendState.blendSrcFactor || currentAttachmentState.alphaBlendState.blendSrcFactor !== newAttachmentState.alphaBlendState.blendSrcFactor || currentAttachmentState.rgbBlendState.blendDstFactor !== newAttachmentState.rgbBlendState.blendDstFactor || currentAttachmentState.alphaBlendState.blendDstFactor !== newAttachmentState.alphaBlendState.blendDstFactor;
      if (blendFuncChanged || blendModeChanged) {
        if (isBlendStateNone(currentAttachmentState.rgbBlendState) && isBlendStateNone(currentAttachmentState.alphaBlendState)) {
          gl2.enable(gl2.BLEND);
        } else if (isBlendStateNone(newAttachmentState.rgbBlendState) && isBlendStateNone(newAttachmentState.alphaBlendState)) {
          gl2.disable(gl2.BLEND);
        }
      }
      if (blendModeChanged) {
        gl2.blendEquationSeparate(newAttachmentState.rgbBlendState.blendMode, newAttachmentState.alphaBlendState.blendMode);
        currentAttachmentState.rgbBlendState.blendMode = newAttachmentState.rgbBlendState.blendMode;
        currentAttachmentState.alphaBlendState.blendMode = newAttachmentState.alphaBlendState.blendMode;
      }
      if (blendFuncChanged) {
        gl2.blendFuncSeparate(newAttachmentState.rgbBlendState.blendSrcFactor, newAttachmentState.rgbBlendState.blendDstFactor, newAttachmentState.alphaBlendState.blendSrcFactor, newAttachmentState.alphaBlendState.blendDstFactor);
        currentAttachmentState.rgbBlendState.blendSrcFactor = newAttachmentState.rgbBlendState.blendSrcFactor;
        currentAttachmentState.alphaBlendState.blendSrcFactor = newAttachmentState.alphaBlendState.blendSrcFactor;
        currentAttachmentState.rgbBlendState.blendDstFactor = newAttachmentState.rgbBlendState.blendDstFactor;
        currentAttachmentState.alphaBlendState.blendDstFactor = newAttachmentState.alphaBlendState.blendDstFactor;
      }
    };
    Device_GL2.prototype.setMegaState = function(newMegaState) {
      var gl2 = this.gl;
      var currentMegaState = this.currentMegaState;
      if (this.OES_draw_buffers_indexed !== null) {
        for (var i = 0; i < newMegaState.attachmentsState.length; i++)
          this.applyAttachmentStateIndexed(i, currentMegaState.attachmentsState[0], newMegaState.attachmentsState[0]);
      } else {
        assert(newMegaState.attachmentsState.length === 1);
        this.applyAttachmentState(currentMegaState.attachmentsState[0], newMegaState.attachmentsState[0]);
      }
      if (!colorEqual(currentMegaState.blendConstant, newMegaState.blendConstant)) {
        gl2.blendColor(newMegaState.blendConstant.r, newMegaState.blendConstant.g, newMegaState.blendConstant.b, newMegaState.blendConstant.a);
        colorCopy(currentMegaState.blendConstant, newMegaState.blendConstant);
      }
      if (currentMegaState.depthCompare !== newMegaState.depthCompare) {
        gl2.depthFunc(newMegaState.depthCompare);
        currentMegaState.depthCompare = newMegaState.depthCompare;
      }
      if (!!currentMegaState.depthWrite !== !!newMegaState.depthWrite) {
        gl2.depthMask(newMegaState.depthWrite);
        currentMegaState.depthWrite = newMegaState.depthWrite;
      }
      if (!!currentMegaState.stencilWrite !== !!newMegaState.stencilWrite) {
        gl2.stencilMask(newMegaState.stencilWrite ? 255 : 0);
        currentMegaState.stencilWrite = newMegaState.stencilWrite;
      }
      var shouldApplyStencil = false;
      if (!stencilFaceStateEquals(currentMegaState.stencilFront, newMegaState.stencilFront)) {
        shouldApplyStencil = true;
        var _a2 = newMegaState.stencilFront, passOp = _a2.passOp, failOp = _a2.failOp, depthFailOp = _a2.depthFailOp, compare = _a2.compare;
        if (currentMegaState.stencilFront.passOp !== passOp || currentMegaState.stencilFront.failOp !== failOp || currentMegaState.stencilFront.depthFailOp !== depthFailOp) {
          gl2.stencilOpSeparate(gl2.FRONT, failOp, depthFailOp, passOp);
          currentMegaState.stencilFront.passOp = passOp;
          currentMegaState.stencilFront.failOp = failOp;
          currentMegaState.stencilFront.depthFailOp = depthFailOp;
        }
        if (currentMegaState.stencilFront.compare !== compare) {
          this.setStencilReference(0);
          currentMegaState.stencilFront.compare = compare;
        }
      }
      if (!stencilFaceStateEquals(currentMegaState.stencilBack, newMegaState.stencilBack)) {
        shouldApplyStencil = true;
        var _b = newMegaState.stencilBack, passOp = _b.passOp, failOp = _b.failOp, depthFailOp = _b.depthFailOp, compare = _b.compare;
        if (currentMegaState.stencilBack.passOp !== passOp || currentMegaState.stencilBack.failOp !== failOp || currentMegaState.stencilBack.depthFailOp !== depthFailOp) {
          gl2.stencilOpSeparate(gl2.BACK, failOp, depthFailOp, passOp);
          currentMegaState.stencilBack.passOp = passOp;
          currentMegaState.stencilBack.failOp = failOp;
          currentMegaState.stencilBack.depthFailOp = depthFailOp;
        }
        if (currentMegaState.stencilBack.compare !== compare) {
          this.setStencilReference(0);
          currentMegaState.stencilBack.compare = compare;
        }
      }
      if (currentMegaState.stencilFront.mask !== newMegaState.stencilFront.mask || currentMegaState.stencilBack.mask !== newMegaState.stencilBack.mask) {
        shouldApplyStencil = true;
        currentMegaState.stencilFront.mask = newMegaState.stencilFront.mask;
        currentMegaState.stencilBack.mask = newMegaState.stencilBack.mask;
      }
      if (shouldApplyStencil) {
        this.applyStencil();
      }
      if (currentMegaState.cullMode !== newMegaState.cullMode) {
        if (currentMegaState.cullMode === CullMode.NONE) {
          gl2.enable(gl2.CULL_FACE);
        } else if (newMegaState.cullMode === CullMode.NONE) {
          gl2.disable(gl2.CULL_FACE);
        }
        if (newMegaState.cullMode === CullMode.BACK) {
          gl2.cullFace(gl2.BACK);
        } else if (newMegaState.cullMode === CullMode.FRONT) {
          gl2.cullFace(gl2.FRONT);
        } else if (newMegaState.cullMode === CullMode.FRONT_AND_BACK) {
          gl2.cullFace(gl2.FRONT_AND_BACK);
        }
        currentMegaState.cullMode = newMegaState.cullMode;
      }
      if (currentMegaState.frontFace !== newMegaState.frontFace) {
        gl2.frontFace(newMegaState.frontFace);
        currentMegaState.frontFace = newMegaState.frontFace;
      }
      if (currentMegaState.polygonOffset !== newMegaState.polygonOffset) {
        if (newMegaState.polygonOffset) {
          gl2.enable(gl2.POLYGON_OFFSET_FILL);
        } else {
          gl2.disable(gl2.POLYGON_OFFSET_FILL);
        }
        currentMegaState.polygonOffset = newMegaState.polygonOffset;
      }
      if (currentMegaState.polygonOffsetFactor !== newMegaState.polygonOffsetFactor || currentMegaState.polygonOffsetUnits !== newMegaState.polygonOffsetUnits) {
        gl2.polygonOffset(newMegaState.polygonOffsetFactor, newMegaState.polygonOffsetUnits);
        currentMegaState.polygonOffsetFactor = newMegaState.polygonOffsetFactor;
        currentMegaState.polygonOffsetUnits = newMegaState.polygonOffsetUnits;
      }
    };
    Device_GL2.prototype.validatePipelineFormats = function(pipeline) {
      for (var i = 0; i < this.currentColorAttachments.length; i++) {
        var attachment = this.currentColorAttachments[i];
        if (attachment === null)
          continue;
      }
      if (this.currentDepthStencilAttachment) {
        assert(this.currentDepthStencilAttachment.format === pipeline.depthStencilAttachmentFormat);
      }
      if (this.currentSampleCount !== -1) {
        assert(this.currentSampleCount === pipeline.sampleCount);
      }
    };
    Device_GL2.prototype.setPipeline = function(o) {
      var _this = this;
      if (this.renderBundle) {
        this.renderBundle.push(function() {
          return _this.setPipeline(o);
        });
        return;
      }
      this.currentPipeline = o;
      this.validatePipelineFormats(this.currentPipeline);
      this.setMegaState(this.currentPipeline.megaState);
      var program = this.currentPipeline.program;
      this.useProgram(program);
      if (program.compileState === ProgramCompileState_GL.NeedsBind) {
        var gl2 = this.gl;
        var prog = program.gl_program;
        var deviceProgram = program.descriptor;
        var uniformBlocks = findall(deviceProgram.vertex.glsl, UNIFROM_BLOCK_REGEXP);
        if (isWebGL2(gl2)) {
          for (var i = 0; i < uniformBlocks.length; i++) {
            var _a2 = __read(uniformBlocks[i], 2), blockName = _a2[1];
            var blockIdx = gl2.getUniformBlockIndex(prog, blockName);
            if (blockIdx !== -1 && blockIdx !== 4294967295) {
              gl2.uniformBlockBinding(prog, blockIdx, i);
            }
          }
        }
        var samplers = findall(deviceProgram.fragment.glsl, /^uniform .*sampler\S+ (\w+);\s* \/\/ BINDING=(\d+)$/gm);
        for (var i = 0; i < samplers.length; i++) {
          var _b = __read(samplers[i], 3), name_1 = _b[1], location_1 = _b[2];
          var samplerUniformLocation = gl2.getUniformLocation(prog, name_1);
          gl2.uniform1i(samplerUniformLocation, parseInt(location_1));
        }
        program.compileState = ProgramCompileState_GL.ReadyToUse;
      }
    };
    Device_GL2.prototype.setVertexInput = function(inputLayout_, vertexBuffers, indexBuffer) {
      var e_1, _a2;
      var _this = this;
      var _b;
      if (this.renderBundle) {
        this.renderBundle.push(function() {
          return _this.setVertexInput(inputLayout_, vertexBuffers, indexBuffer);
        });
        return;
      }
      if (inputLayout_ !== null) {
        assert(this.currentPipeline.inputLayout === inputLayout_);
        var inputLayout = inputLayout_;
        this.bindVAO(inputLayout.vao);
        var gl2 = this.gl;
        for (var i = 0; i < inputLayout.vertexBufferDescriptors.length; i++) {
          var vertexBufferDescriptor = inputLayout.vertexBufferDescriptors[i];
          var arrayStride = vertexBufferDescriptor.arrayStride, attributes = vertexBufferDescriptor.attributes;
          try {
            for (var attributes_1 = (e_1 = void 0, __values(attributes)), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
              var attribute = attributes_1_1.value;
              var shaderLocation = attribute.shaderLocation, offset = attribute.offset;
              var location_2 = isWebGL2(gl2) ? shaderLocation : (_b = inputLayout.program.attributes[shaderLocation]) === null || _b === void 0 ? void 0 : _b.location;
              if (!isNil2(location_2)) {
                var vertexBuffer = vertexBuffers[i];
                if (vertexBuffer === null)
                  continue;
                var format2 = attribute.vertexFormat;
                gl2.bindBuffer(gl2.ARRAY_BUFFER, getPlatformBuffer$1(vertexBuffer.buffer));
                var bufferOffset = (vertexBuffer.offset || 0) + offset;
                gl2.vertexAttribPointer(location_2, format2.size, format2.type, format2.normalized, arrayStride, bufferOffset);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (attributes_1_1 && !attributes_1_1.done && (_a2 = attributes_1.return))
                _a2.call(attributes_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
        assert(indexBuffer !== null === (inputLayout.indexBufferFormat !== null));
        if (indexBuffer !== null) {
          var buffer = indexBuffer.buffer;
          assert(buffer.usage === BufferUsage.INDEX);
          gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, getPlatformBuffer$1(buffer));
          this.currentIndexBufferByteOffset = indexBuffer.offset || 0;
        } else {
          this.currentIndexBufferByteOffset = null;
        }
      } else {
        assert(this.currentPipeline.inputLayout === null);
        assert(indexBuffer === null);
        this.bindVAO(null);
        this.currentIndexBufferByteOffset = 0;
      }
    };
    Device_GL2.prototype.setStencilReference = function(value) {
      if (this.currentStencilRef === value) {
        return;
      }
      this.currentStencilRef = value;
      this.applyStencil();
    };
    Device_GL2.prototype.draw = function(vertexCount, instanceCount, firstVertex, firstInstance) {
      var _a2;
      var _this = this;
      if (this.renderBundle) {
        this.renderBundle.push(function() {
          return _this.draw(vertexCount, instanceCount, firstVertex, firstInstance);
        });
        return;
      }
      var gl2 = this.gl;
      var pipeline = this.currentPipeline;
      if (instanceCount) {
        var params = [
          pipeline.drawMode,
          firstVertex || 0,
          vertexCount,
          instanceCount
        ];
        if (isWebGL2(gl2)) {
          gl2.drawArraysInstanced.apply(gl2, __spreadArray([], __read(params), false));
        } else {
          (_a2 = this.ANGLE_instanced_arrays).drawArraysInstancedANGLE.apply(_a2, __spreadArray([], __read(params), false));
        }
      } else {
        gl2.drawArrays(pipeline.drawMode, firstVertex, vertexCount);
      }
      this.debugGroupStatisticsDrawCall();
      this.debugGroupStatisticsTriangles(vertexCount / 3 * Math.max(instanceCount, 1));
    };
    Device_GL2.prototype.drawIndexed = function(indexCount, instanceCount, firstIndex, baseVertex, firstInstance) {
      var _a2;
      var _this = this;
      if (this.renderBundle) {
        this.renderBundle.push(function() {
          return _this.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
        });
        return;
      }
      var gl2 = this.gl;
      var pipeline = this.currentPipeline, inputLayout = assertExists(pipeline.inputLayout);
      var byteOffset = assertExists(this.currentIndexBufferByteOffset) + firstIndex * inputLayout.indexBufferCompByteSize;
      if (instanceCount) {
        var params = [
          pipeline.drawMode,
          indexCount,
          inputLayout.indexBufferType,
          byteOffset,
          instanceCount
        ];
        if (isWebGL2(gl2)) {
          gl2.drawElementsInstanced.apply(gl2, __spreadArray([], __read(params), false));
        } else {
          (_a2 = this.ANGLE_instanced_arrays).drawElementsInstancedANGLE.apply(_a2, __spreadArray([], __read(params), false));
        }
      } else {
        gl2.drawElements(pipeline.drawMode, indexCount, inputLayout.indexBufferType, byteOffset);
      }
      this.debugGroupStatisticsDrawCall();
      this.debugGroupStatisticsTriangles(indexCount / 3 * Math.max(instanceCount, 1));
    };
    Device_GL2.prototype.drawIndirect = function(indirectBuffer, indirectOffset) {
    };
    Device_GL2.prototype.drawIndexedIndirect = function(indirectBuffer, indirectOffset) {
    };
    Device_GL2.prototype.beginOcclusionQuery = function(queryIndex) {
      var gl2 = this.gl;
      if (isWebGL2(gl2)) {
        var queryPool = this.currentRenderPassDescriptor.occlusionQueryPool;
        gl2.beginQuery(queryPool.gl_query_type, queryPool.gl_query[queryIndex]);
      }
    };
    Device_GL2.prototype.endOcclusionQuery = function() {
      var gl2 = this.gl;
      if (isWebGL2(gl2)) {
        var queryPool = this.currentRenderPassDescriptor.occlusionQueryPool;
        gl2.endQuery(queryPool.gl_query_type);
      }
    };
    Device_GL2.prototype.pipelineQueryReady = function(o) {
      var pipeline = o;
      return this.queryProgramReady(pipeline.program);
    };
    Device_GL2.prototype.pipelineForceReady = function(o) {
    };
    Device_GL2.prototype.endPass = function() {
      var gl2 = this.gl;
      var gl22 = isWebGL2(gl2);
      var skipBlit = this.currentColorResolveTos.length === 1 && this.currentColorResolveTos[0] === this.scTexture;
      var didUnbindDraw = false;
      for (var i = 0; i < this.currentColorAttachments.length; i++) {
        var colorResolveFrom = this.currentColorAttachments[i];
        if (colorResolveFrom !== null) {
          var colorResolveTo = this.currentColorResolveTos[i];
          var didBindRead = false;
          if (colorResolveTo !== null) {
            assert(colorResolveFrom.width === colorResolveTo.width && colorResolveFrom.height === colorResolveTo.height);
            this.setScissorRectEnabled(false);
            if (!skipBlit) {
              if (gl22) {
                gl2.bindFramebuffer(gl2.READ_FRAMEBUFFER, this.resolveColorReadFramebuffer);
              }
              if (this.resolveColorAttachmentsChanged) {
                if (gl22) {
                  this.bindFramebufferAttachment(gl2.READ_FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, colorResolveFrom, this.currentColorAttachmentLevels[i]);
                }
              }
            }
            didBindRead = true;
            if (!skipBlit) {
              if (colorResolveTo === this.scTexture) {
                gl2.bindFramebuffer(gl22 ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, this.scPlatformFramebuffer);
              } else {
                gl2.bindFramebuffer(gl22 ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, this.resolveColorDrawFramebuffer);
                if (this.resolveColorAttachmentsChanged)
                  gl2.framebufferTexture2D(gl22 ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, colorResolveTo.gl_texture, this.currentColorResolveToLevels[i]);
              }
            }
            if (!skipBlit) {
              if (gl22) {
                gl2.blitFramebuffer(0, 0, colorResolveFrom.width, colorResolveFrom.height, 0, 0, colorResolveTo.width, colorResolveTo.height, gl2.COLOR_BUFFER_BIT, gl2.LINEAR);
                gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, null);
              } else {
                this.submitBlitRenderPass(colorResolveFrom, colorResolveTo);
              }
            }
            didUnbindDraw = true;
          }
          if (!this.currentRenderPassDescriptor.colorStore[i]) {
            if (!skipBlit && !didBindRead) {
              gl2.bindFramebuffer(gl22 ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, this.resolveColorReadFramebuffer);
              if (this.resolveColorAttachmentsChanged)
                this.bindFramebufferAttachment(gl22 ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, colorResolveFrom, this.currentColorAttachmentLevels[i]);
            }
          }
          if (!skipBlit) {
            gl2.bindFramebuffer(gl22 ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, null);
          }
        }
      }
      this.resolveColorAttachmentsChanged = false;
      var depthStencilResolveFrom = this.currentDepthStencilAttachment;
      if (depthStencilResolveFrom) {
        var depthStencilResolveTo = this.currentDepthStencilResolveTo;
        var didBindRead = false;
        if (depthStencilResolveTo) {
          assert(depthStencilResolveFrom.width === depthStencilResolveTo.width && depthStencilResolveFrom.height === depthStencilResolveTo.height);
          this.setScissorRectEnabled(false);
          if (!skipBlit) {
            gl2.bindFramebuffer(gl22 ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, this.resolveDepthStencilReadFramebuffer);
            gl2.bindFramebuffer(gl22 ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, this.resolveDepthStencilDrawFramebuffer);
            if (this.resolveDepthStencilAttachmentsChanged) {
              this.bindFramebufferDepthStencilAttachment(gl22 ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, depthStencilResolveFrom);
              this.bindFramebufferDepthStencilAttachment(gl22 ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, depthStencilResolveTo);
            }
          }
          didBindRead = true;
          if (!skipBlit) {
            if (gl22) {
              gl2.blitFramebuffer(0, 0, depthStencilResolveFrom.width, depthStencilResolveFrom.height, 0, 0, depthStencilResolveTo.width, depthStencilResolveTo.height, gl2.DEPTH_BUFFER_BIT, gl2.NEAREST);
            }
            gl2.bindFramebuffer(gl22 ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, null);
          }
          didUnbindDraw = true;
        }
        if (!skipBlit && !this.currentRenderPassDescriptor.depthStencilStore) {
          if (!didBindRead) {
            gl2.bindFramebuffer(gl22 ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, this.resolveDepthStencilReadFramebuffer);
            if (this.resolveDepthStencilAttachmentsChanged)
              this.bindFramebufferDepthStencilAttachment(gl22 ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, depthStencilResolveFrom);
            didBindRead = true;
          }
          if (gl22) {
            gl2.invalidateFramebuffer(gl2.READ_FRAMEBUFFER, [
              gl2.DEPTH_STENCIL_ATTACHMENT
            ]);
          }
        }
        if (!skipBlit && didBindRead)
          gl2.bindFramebuffer(gl22 ? GL.READ_FRAMEBUFFER : GL.FRAMEBUFFER, null);
        this.resolveDepthStencilAttachmentsChanged = false;
      }
      if (!skipBlit && !didUnbindDraw) {
        gl2.bindFramebuffer(gl22 ? GL.DRAW_FRAMEBUFFER : GL.FRAMEBUFFER, null);
      }
    };
    Device_GL2.prototype.setScissorRectEnabled = function(v2) {
      if (this.currentScissorEnabled === v2) {
        return;
      }
      var gl2 = this.gl;
      if (v2) {
        gl2.enable(gl2.SCISSOR_TEST);
      } else {
        gl2.disable(gl2.SCISSOR_TEST);
      }
      this.currentScissorEnabled = v2;
    };
    Device_GL2.prototype.applyStencil = function() {
      if (isNil2(this.currentStencilRef)) {
        return;
      }
      this.gl.stencilFuncSeparate(GL.FRONT, this.currentMegaState.stencilFront.compare, this.currentStencilRef, this.currentMegaState.stencilFront.mask || 255);
      this.gl.stencilFuncSeparate(GL.BACK, this.currentMegaState.stencilBack.compare, this.currentStencilRef, this.currentMegaState.stencilBack.mask || 255);
    };
    Device_GL2.prototype.getFallbackTexture = function(samplerEntry) {
      var gl_target = samplerEntry.gl_target, formatKind = samplerEntry.formatKind;
      if (gl_target === GL.TEXTURE_2D)
        return formatKind === SamplerFormatKind.Depth ? this.fallbackTexture2DDepth : this.fallbackTexture2D;
      else if (gl_target === GL.TEXTURE_2D_ARRAY)
        return this.fallbackTexture2DArray;
      else if (gl_target === GL.TEXTURE_3D)
        return this.fallbackTexture3D;
      else if (gl_target === GL.TEXTURE_CUBE_MAP)
        return this.fallbackTextureCube;
      else
        throw new Error("whoops");
    };
    Device_GL2.prototype.submitBlitRenderPass = function(resolveFrom, resolveTo) {
      if (!this.blitRenderPipeline) {
        this.blitProgram = this.createProgram({
          vertex: {
            glsl: "layout(location = 0) in vec2 a_Position;\nout vec2 v_TexCoord;\nvoid main() {\n  v_TexCoord = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n\n  #ifdef VIEWPORT_ORIGIN_TL\n    v_TexCoord.y = 1.0 - v_TexCoord.y;\n  #endif\n}"
          },
          fragment: {
            glsl: "uniform sampler2D u_Texture;\nin vec2 v_TexCoord;\nout vec4 outputColor;\nvoid main() {\n  outputColor = texture(SAMPLER_2D(u_Texture), v_TexCoord);\n}"
          }
        });
        this.blitVertexBuffer = this.createBuffer({
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
          viewOrSize: new Float32Array([-4, -4, 4, -4, 0, 4])
        });
        this.blitInputLayout = this.createInputLayout({
          vertexBufferDescriptors: [
            {
              arrayStride: 4 * 2,
              stepMode: VertexStepMode.VERTEX,
              attributes: [
                {
                  format: Format.F32_RG,
                  offset: 4 * 0,
                  shaderLocation: 0
                }
              ]
            }
          ],
          indexBufferFormat: null,
          program: this.blitProgram
        });
        this.blitRenderPipeline = this.createRenderPipeline({
          topology: PrimitiveTopology.TRIANGLES,
          sampleCount: 1,
          program: this.blitProgram,
          colorAttachmentFormats: [Format.U8_RGBA_RT],
          depthStencilAttachmentFormat: null,
          inputLayout: this.blitInputLayout,
          megaStateDescriptor: copyMegaState(defaultMegaState)
        });
        this.blitBindings = this.createBindings({
          samplerBindings: [
            {
              sampler: null,
              texture: resolveFrom.texture
            }
          ],
          uniformBufferBindings: []
        });
        this.blitProgram.setUniformsLegacy({
          u_Texture: resolveFrom
        });
      }
      var currentRenderPassDescriptor = this.currentRenderPassDescriptor;
      this.currentRenderPassDescriptor = null;
      this.inBlitRenderPass = true;
      var blitRenderPass = this.createRenderPass({
        colorAttachment: [resolveFrom],
        colorResolveTo: [resolveTo],
        colorClearColor: [TransparentWhite]
      });
      var _a2 = this.getCanvas(), width = _a2.width, height = _a2.height;
      blitRenderPass.setPipeline(this.blitRenderPipeline);
      blitRenderPass.setBindings(this.blitBindings);
      blitRenderPass.setVertexInput(this.blitInputLayout, [{ buffer: this.blitVertexBuffer }], null);
      blitRenderPass.setViewport(0, 0, width, height);
      this.gl.disable(this.gl.BLEND);
      blitRenderPass.draw(3, 0);
      this.gl.enable(this.gl.BLEND);
      this.currentRenderPassDescriptor = currentRenderPassDescriptor;
      this.inBlitRenderPass = false;
    };
    return Device_GL2;
  }()
);
var WebGLDeviceContribution = (
  /** @class */
  function() {
    function WebGLDeviceContribution2(pluginOptions) {
      this.pluginOptions = pluginOptions;
    }
    WebGLDeviceContribution2.prototype.createSwapChain = function($canvas) {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, targets, xrCompatible, _b, antialias, _c, preserveDrawingBuffer, _d, premultipliedAlpha, shaderDebug, trackResources, options, gl2;
        return __generator2(this, function(_e) {
          _a2 = this.pluginOptions, targets = _a2.targets, xrCompatible = _a2.xrCompatible, _b = _a2.antialias, antialias = _b === void 0 ? false : _b, _c = _a2.preserveDrawingBuffer, preserveDrawingBuffer = _c === void 0 ? false : _c, _d = _a2.premultipliedAlpha, premultipliedAlpha = _d === void 0 ? true : _d, shaderDebug = _a2.shaderDebug, trackResources = _a2.trackResources;
          options = {
            // alpha: true,
            antialias,
            // @see https://stackoverflow.com/questions/27746091/preservedrawingbuffer-false-is-it-worth-the-effort
            preserveDrawingBuffer,
            // @see https://webglfundamentals.org/webgl/lessons/webgl-qna-how-to-use-the-stencil-buffer.html
            stencil: true,
            // @see https://webglfundamentals.org/webgl/lessons/webgl-and-alpha.html
            premultipliedAlpha,
            xrCompatible
          };
          this.handleContextEvents($canvas);
          if (targets.includes("webgl2")) {
            gl2 = $canvas.getContext("webgl2", options) || $canvas.getContext("experimental-webgl2", options);
          }
          if (!gl2 && targets.includes("webgl1")) {
            gl2 = $canvas.getContext("webgl", options) || $canvas.getContext("experimental-webgl", options);
          }
          return [2, new Device_GL(gl2, {
            shaderDebug,
            trackResources
          })];
        });
      });
    };
    WebGLDeviceContribution2.prototype.handleContextEvents = function($canvas) {
      var _a2 = this.pluginOptions, onContextLost = _a2.onContextLost, onContextRestored = _a2.onContextRestored, onContextCreationError = _a2.onContextCreationError;
      if (onContextCreationError) {
        $canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
      }
      if (onContextLost) {
        $canvas.addEventListener("webglcontextlost", onContextLost, false);
      }
      if (onContextRestored) {
        $canvas.addEventListener("webglcontextrestored", onContextRestored, false);
      }
    };
    return WebGLDeviceContribution2;
  }()
);
var wasm;
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : {
  decode: () => {
    throw Error("TextDecoder not available");
  }
};
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
var cachedUint8Memory0 = null;
function getUint8Memory0() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
var heap = new Array(128).fill(void 0);
heap.push(void 0, null, true, false);
var heap_next = heap.length;
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function getObject(idx) {
  return heap[idx];
}
function dropObject(idx) {
  if (idx < 132)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : {
  encode: () => {
    throw Error("TextEncoder not available");
  }
};
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachedInt32Memory0 = null;
function getInt32Memory0() {
  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
function glsl_compile(source, stage, validation_enabled) {
  let deferred3_0;
  let deferred3_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(
      source,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(
      stage,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    const len1 = WASM_VECTOR_LEN;
    wasm.glsl_compile(retptr, ptr0, len0, ptr1, len1, validation_enabled);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    deferred3_0 = r0;
    deferred3_1 = r1;
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
  }
}
var WGSLComposer = class _WGSLComposer {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_WGSLComposer.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_wgslcomposer_free(ptr);
  }
  /**
   */
  constructor() {
    const ret = wasm.wgslcomposer_new();
    return _WGSLComposer.__wrap(ret);
  }
  /**
   * @param {string} source
   */
  load_composable(source) {
    const ptr0 = passStringToWasm0(
      source,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    const len0 = WASM_VECTOR_LEN;
    wasm.wgslcomposer_load_composable(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @param {string} source
   * @returns {string}
   */
  wgsl_compile(source) {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        source,
        wasm.__wbindgen_malloc,
        wasm.__wbindgen_realloc
      );
      const len0 = WASM_VECTOR_LEN;
      wasm.wgslcomposer_wgsl_compile(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      deferred2_0 = r0;
      deferred2_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
};
async function __wbg_load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn(
            "`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
            e
          );
        } else {
          throw e;
        }
      }
    }
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbg_log_1d3ae0273d8f4f8a = function(arg0) {
    console.log(getObject(arg0));
  };
  imports.wbg.__wbg_log_576ca876af0d4a77 = function(arg0, arg1) {
    console.log(getObject(arg0), getObject(arg1));
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  return imports;
}
function __wbg_finalize_init(instance, module) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedInt32Memory0 = null;
  cachedUint8Memory0 = null;
  return wasm;
}
async function __wbg_init(input) {
  if (wasm !== void 0)
    return wasm;
  const imports = __wbg_get_imports();
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  const { instance, module } = await __wbg_load(await input, imports);
  return __wbg_finalize_init(instance, module);
}
var GPUTextureUsage$1;
(function(GPUTextureUsage2) {
  GPUTextureUsage2[GPUTextureUsage2["COPY_SRC"] = 1] = "COPY_SRC";
  GPUTextureUsage2[GPUTextureUsage2["COPY_DST"] = 2] = "COPY_DST";
  GPUTextureUsage2[GPUTextureUsage2["TEXTURE_BINDING"] = 4] = "TEXTURE_BINDING";
  GPUTextureUsage2[GPUTextureUsage2["STORAGE_BINDING"] = 8] = "STORAGE_BINDING";
  GPUTextureUsage2[GPUTextureUsage2["STORAGE"] = 8] = "STORAGE";
  GPUTextureUsage2[GPUTextureUsage2["RENDER_ATTACHMENT"] = 16] = "RENDER_ATTACHMENT";
})(GPUTextureUsage$1 || (GPUTextureUsage$1 = {}));
var GPUMapMode;
(function(GPUMapMode2) {
  GPUMapMode2[GPUMapMode2["READ"] = 1] = "READ";
  GPUMapMode2[GPUMapMode2["WRITE"] = 2] = "WRITE";
})(GPUMapMode || (GPUMapMode = {}));
function translateTextureUsage(usage) {
  var gpuUsage = 0;
  if (usage & TextureUsage2.SAMPLED)
    gpuUsage |= GPUTextureUsage$1.TEXTURE_BINDING | GPUTextureUsage$1.COPY_DST | GPUTextureUsage$1.COPY_SRC;
  if (usage & TextureUsage2.STORAGE)
    gpuUsage |= GPUTextureUsage$1.TEXTURE_BINDING | GPUTextureUsage$1.STORAGE_BINDING | GPUTextureUsage$1.COPY_SRC | GPUTextureUsage$1.COPY_DST;
  if (usage & TextureUsage2.RENDER_TARGET)
    gpuUsage |= GPUTextureUsage$1.RENDER_ATTACHMENT | GPUTextureUsage$1.TEXTURE_BINDING | GPUTextureUsage$1.COPY_SRC | GPUTextureUsage$1.COPY_DST;
  return gpuUsage;
}
function translateTextureFormat(format2) {
  if (format2 === Format.U8_R_NORM)
    return "r8unorm";
  else if (format2 === Format.S8_R_NORM)
    return "r8snorm";
  else if (format2 === Format.U8_RG_NORM)
    return "rg8unorm";
  else if (format2 === Format.S8_RG_NORM)
    return "rg8snorm";
  else if (format2 === Format.U32_R)
    return "r32uint";
  else if (format2 === Format.S32_R)
    return "r32sint";
  else if (format2 === Format.F32_R)
    return "r32float";
  else if (format2 === Format.U16_RG)
    return "rg16uint";
  else if (format2 === Format.S16_RG)
    return "rg16sint";
  else if (format2 === Format.F16_RG)
    return "rg16float";
  else if (format2 === Format.U8_RGBA_RT)
    return "bgra8unorm";
  else if (format2 === Format.U8_RGBA_RT_SRGB)
    return "bgra8unorm-srgb";
  else if (format2 === Format.U8_RGBA_NORM)
    return "rgba8unorm";
  else if (format2 === Format.U8_RGBA_SRGB)
    return "rgba8unorm-srgb";
  else if (format2 === Format.S8_RGBA_NORM)
    return "rgba8snorm";
  else if (format2 === Format.U32_RG)
    return "rg32uint";
  else if (format2 === Format.S32_RG)
    return "rg32sint";
  else if (format2 === Format.F32_RG)
    return "rg32float";
  else if (format2 === Format.U16_RGBA)
    return "rgba16uint";
  else if (format2 === Format.S16_RGBA)
    return "rgba16sint";
  else if (format2 === Format.F16_RGBA)
    return "rgba16float";
  else if (format2 === Format.F32_RGBA)
    return "rgba32float";
  else if (format2 === Format.U32_RGBA)
    return "rgba32uint";
  else if (format2 === Format.S32_RGBA)
    return "rgba32sint";
  else if (format2 === Format.D24)
    return "depth24plus";
  else if (format2 === Format.D24_S8)
    return "depth24plus-stencil8";
  else if (format2 === Format.D32F)
    return "depth32float";
  else if (format2 === Format.D32F_S8)
    return "depth32float-stencil8";
  else if (format2 === Format.BC1)
    return "bc1-rgba-unorm";
  else if (format2 === Format.BC1_SRGB)
    return "bc1-rgba-unorm-srgb";
  else if (format2 === Format.BC2)
    return "bc2-rgba-unorm";
  else if (format2 === Format.BC2_SRGB)
    return "bc2-rgba-unorm-srgb";
  else if (format2 === Format.BC3)
    return "bc3-rgba-unorm";
  else if (format2 === Format.BC3_SRGB)
    return "bc3-rgba-unorm-srgb";
  else if (format2 === Format.BC4_SNORM)
    return "bc4-r-snorm";
  else if (format2 === Format.BC4_UNORM)
    return "bc4-r-unorm";
  else if (format2 === Format.BC5_SNORM)
    return "bc5-rg-snorm";
  else if (format2 === Format.BC5_UNORM)
    return "bc5-rg-unorm";
  else
    throw "whoops";
}
function translateTextureDimension(dimension) {
  if (dimension === TextureDimension.TEXTURE_2D)
    return "2d";
  else if (dimension === TextureDimension.TEXTURE_CUBE_MAP)
    return "2d";
  else if (dimension === TextureDimension.TEXTURE_2D_ARRAY)
    return "2d";
  else if (dimension === TextureDimension.TEXTURE_3D)
    return "3d";
  else
    throw new Error("whoops");
}
function translateTextureViewDimension(dimension) {
  if (dimension === TextureDimension.TEXTURE_2D)
    return "2d";
  else if (dimension === TextureDimension.TEXTURE_CUBE_MAP)
    return "cube";
  else if (dimension === TextureDimension.TEXTURE_2D_ARRAY)
    return "2d-array";
  else if (dimension === TextureDimension.TEXTURE_3D)
    return "3d";
  else
    throw new Error("whoops");
}
function translateBufferUsage(usage_) {
  var usage = 0;
  if (usage_ & BufferUsage.INDEX)
    usage |= GPUBufferUsage.INDEX;
  if (usage_ & BufferUsage.VERTEX)
    usage |= GPUBufferUsage.VERTEX;
  if (usage_ & BufferUsage.UNIFORM)
    usage |= GPUBufferUsage.UNIFORM;
  if (usage_ & BufferUsage.STORAGE)
    usage |= GPUBufferUsage.STORAGE;
  if (usage_ & BufferUsage.COPY_SRC)
    usage |= GPUBufferUsage.COPY_SRC;
  if (usage_ & BufferUsage.INDIRECT)
    usage |= GPUBufferUsage.INDIRECT;
  usage |= GPUBufferUsage.COPY_DST;
  return usage;
}
function translateAddressMode(wrapMode) {
  if (wrapMode === AddressMode.CLAMP_TO_EDGE)
    return "clamp-to-edge";
  else if (wrapMode === AddressMode.REPEAT)
    return "repeat";
  else if (wrapMode === AddressMode.MIRRORED_REPEAT)
    return "mirror-repeat";
  else
    throw new Error("whoops");
}
function translateMinMagFilter(texFilter) {
  if (texFilter === FilterMode.BILINEAR)
    return "linear";
  else if (texFilter === FilterMode.POINT)
    return "nearest";
  else
    throw new Error("whoops");
}
function translateMipFilter(mipmapFilter) {
  if (mipmapFilter === MipmapFilterMode.LINEAR)
    return "linear";
  else if (mipmapFilter === MipmapFilterMode.NEAREST)
    return "nearest";
  else if (mipmapFilter === MipmapFilterMode.NO_MIP)
    return "nearest";
  else
    throw new Error("whoops");
}
function getPlatformBuffer(buffer_) {
  var buffer = buffer_;
  return buffer.gpuBuffer;
}
function getPlatformSampler(sampler_) {
  var sampler = sampler_;
  return sampler.gpuSampler;
}
function getPlatformQuerySet(queryPool_) {
  var queryPool = queryPool_;
  return queryPool.querySet;
}
function translateQueryPoolType(type) {
  if (type === QueryPoolType.OcclusionConservative)
    return "occlusion";
  else
    throw new Error("whoops");
}
function translateTopology(topology) {
  switch (topology) {
    case PrimitiveTopology.TRIANGLES:
      return "triangle-list";
    case PrimitiveTopology.POINTS:
      return "point-list";
    case PrimitiveTopology.TRIANGLE_STRIP:
      return "triangle-strip";
    case PrimitiveTopology.LINES:
      return "line-list";
    case PrimitiveTopology.LINE_STRIP:
      return "line-strip";
    default:
      throw new Error("Unknown primitive topology mode");
  }
}
function translateCullMode(cullMode) {
  if (cullMode === CullMode.NONE)
    return "none";
  else if (cullMode === CullMode.FRONT)
    return "front";
  else if (cullMode === CullMode.BACK)
    return "back";
  else
    throw new Error("whoops");
}
function translateFrontFace(frontFaceMode) {
  if (frontFaceMode === FrontFace.CCW)
    return "ccw";
  else if (frontFaceMode === FrontFace.CW)
    return "cw";
  else
    throw new Error("whoops");
}
function translatePrimitiveState(topology, megaStateDescriptor) {
  return {
    topology: translateTopology(topology),
    cullMode: translateCullMode(megaStateDescriptor.cullMode),
    frontFace: translateFrontFace(megaStateDescriptor.frontFace)
  };
}
function translateBlendFactor(factor) {
  if (factor === BlendFactor.ZERO)
    return "zero";
  else if (factor === BlendFactor.ONE)
    return "one";
  else if (factor === BlendFactor.SRC)
    return "src";
  else if (factor === BlendFactor.ONE_MINUS_SRC)
    return "one-minus-src";
  else if (factor === BlendFactor.DST)
    return "dst";
  else if (factor === BlendFactor.ONE_MINUS_DST)
    return "one-minus-dst";
  else if (factor === BlendFactor.SRC_ALPHA)
    return "src-alpha";
  else if (factor === BlendFactor.ONE_MINUS_SRC_ALPHA)
    return "one-minus-src-alpha";
  else if (factor === BlendFactor.DST_ALPHA)
    return "dst-alpha";
  else if (factor === BlendFactor.ONE_MINUS_DST_ALPHA)
    return "one-minus-dst-alpha";
  else if (factor === BlendFactor.CONST)
    return "constant";
  else if (factor === BlendFactor.ONE_MINUS_CONSTANT)
    return "one-minus-constant";
  else if (factor === BlendFactor.SRC_ALPHA_SATURATE)
    return "src-alpha-saturated";
  else
    throw new Error("whoops");
}
function translateBlendMode(mode) {
  if (mode === BlendMode.ADD)
    return "add";
  else if (mode === BlendMode.SUBSTRACT)
    return "subtract";
  else if (mode === BlendMode.REVERSE_SUBSTRACT)
    return "reverse-subtract";
  else if (mode === BlendMode.MIN)
    return "min";
  else if (mode === BlendMode.MAX)
    return "max";
  else
    throw new Error("whoops");
}
function translateBlendComponent(ch) {
  return {
    operation: translateBlendMode(ch.blendMode),
    srcFactor: translateBlendFactor(ch.blendSrcFactor),
    dstFactor: translateBlendFactor(ch.blendDstFactor)
  };
}
function blendComponentIsNil(ch) {
  return ch.blendMode === BlendMode.ADD && ch.blendSrcFactor === BlendFactor.ONE && ch.blendDstFactor === BlendFactor.ZERO;
}
function translateBlendState(attachmentState) {
  if (blendComponentIsNil(attachmentState.rgbBlendState) && blendComponentIsNil(attachmentState.alphaBlendState)) {
    return void 0;
  } else {
    return {
      color: translateBlendComponent(attachmentState.rgbBlendState),
      alpha: translateBlendComponent(attachmentState.alphaBlendState)
    };
  }
}
function translateColorState(attachmentState, format2) {
  return {
    format: translateTextureFormat(format2),
    blend: translateBlendState(attachmentState),
    writeMask: attachmentState.channelWriteMask
  };
}
function translateTargets(colorAttachmentFormats, megaStateDescriptor) {
  return megaStateDescriptor.attachmentsState.map(function(attachmentState, i) {
    return translateColorState(attachmentState, colorAttachmentFormats[i]);
  });
}
function translateCompareFunction(compareFunction) {
  if (compareFunction === CompareFunction.NEVER)
    return "never";
  else if (compareFunction === CompareFunction.LESS)
    return "less";
  else if (compareFunction === CompareFunction.EQUAL)
    return "equal";
  else if (compareFunction === CompareFunction.LEQUAL)
    return "less-equal";
  else if (compareFunction === CompareFunction.GREATER)
    return "greater";
  else if (compareFunction === CompareFunction.NOTEQUAL)
    return "not-equal";
  else if (compareFunction === CompareFunction.GEQUAL)
    return "greater-equal";
  else if (compareFunction === CompareFunction.ALWAYS)
    return "always";
  else
    throw new Error("whoops");
}
function translateStencilOperation(stencilOp) {
  if (stencilOp === StencilOp.KEEP)
    return "keep";
  else if (stencilOp === StencilOp.REPLACE)
    return "replace";
  else if (stencilOp === StencilOp.ZERO)
    return "zero";
  else if (stencilOp === StencilOp.DECREMENT_CLAMP)
    return "decrement-clamp";
  else if (stencilOp === StencilOp.DECREMENT_WRAP)
    return "decrement-wrap";
  else if (stencilOp === StencilOp.INCREMENT_CLAMP)
    return "increment-clamp";
  else if (stencilOp === StencilOp.INCREMENT_WRAP)
    return "increment-wrap";
  else if (stencilOp === StencilOp.INVERT)
    return "invert";
  else
    throw new Error("whoops");
}
function translateDepthStencilState(format2, megaStateDescriptor) {
  if (isNil2(format2))
    return void 0;
  return {
    /**
     * @see https://www.w3.org/TR/webgpu/#dom-gpudepthstencilstate-format
     */
    format: translateTextureFormat(format2),
    depthWriteEnabled: !!megaStateDescriptor.depthWrite,
    depthCompare: translateCompareFunction(megaStateDescriptor.depthCompare),
    depthBias: megaStateDescriptor.polygonOffset ? megaStateDescriptor.polygonOffsetUnits : 0,
    depthBiasSlopeScale: megaStateDescriptor.polygonOffset ? megaStateDescriptor.polygonOffsetFactor : 0,
    stencilFront: {
      compare: translateCompareFunction(megaStateDescriptor.stencilFront.compare),
      passOp: translateStencilOperation(megaStateDescriptor.stencilFront.passOp),
      failOp: translateStencilOperation(megaStateDescriptor.stencilFront.failOp),
      depthFailOp: translateStencilOperation(megaStateDescriptor.stencilFront.depthFailOp)
    },
    stencilBack: {
      compare: translateCompareFunction(megaStateDescriptor.stencilBack.compare),
      passOp: translateStencilOperation(megaStateDescriptor.stencilBack.passOp),
      failOp: translateStencilOperation(megaStateDescriptor.stencilBack.failOp),
      depthFailOp: translateStencilOperation(megaStateDescriptor.stencilBack.depthFailOp)
    },
    stencilReadMask: 4294967295,
    stencilWriteMask: 4294967295
    // stencilReadMask: 0xffffffff,
    // stencilWriteMask: megaStateDescriptor.stencilWrite ? 0xff : 0x00,
  };
}
function translateIndexFormat(format2) {
  if (format2 === null)
    return void 0;
  else if (format2 === Format.U16_R)
    return "uint16";
  else if (format2 === Format.U32_R)
    return "uint32";
  else
    throw new Error("whoops");
}
function translateVertexStepMode(stepMode) {
  if (stepMode === VertexStepMode.VERTEX)
    return "vertex";
  else if (stepMode === VertexStepMode.INSTANCE)
    return "instance";
  else
    throw new Error("whoops");
}
function translateVertexFormat(format2) {
  if (format2 === Format.U8_R)
    return "uint8x2";
  else if (format2 === Format.U8_RG)
    return "uint8x2";
  else if (format2 === Format.U8_RGB)
    return "uint8x4";
  else if (format2 === Format.U8_RGBA)
    return "uint8x4";
  else if (format2 === Format.U8_RG_NORM)
    return "unorm8x2";
  else if (format2 === Format.U8_RGBA_NORM)
    return "unorm8x4";
  else if (format2 === Format.S8_RGB_NORM)
    return "snorm8x4";
  else if (format2 === Format.S8_RGBA_NORM)
    return "snorm8x4";
  else if (format2 === Format.U16_RG_NORM)
    return "unorm16x2";
  else if (format2 === Format.U16_RGBA_NORM)
    return "unorm16x4";
  else if (format2 === Format.S16_RG_NORM)
    return "snorm16x2";
  else if (format2 === Format.S16_RGBA_NORM)
    return "snorm16x4";
  else if (format2 === Format.S16_RG)
    return "uint16x2";
  else if (format2 === Format.F16_RG)
    return "float16x2";
  else if (format2 === Format.F16_RGBA)
    return "float16x4";
  else if (format2 === Format.F32_R)
    return "float32";
  else if (format2 === Format.F32_RG)
    return "float32x2";
  else if (format2 === Format.F32_RGB)
    return "float32x3";
  else if (format2 === Format.F32_RGBA)
    return "float32x4";
  else
    throw "whoops";
}
function isFormatTextureCompressionBC(format2) {
  var formatTypeFlags = getFormatTypeFlags(format2);
  switch (formatTypeFlags) {
    case FormatTypeFlags.BC1:
    case FormatTypeFlags.BC2:
    case FormatTypeFlags.BC3:
    case FormatTypeFlags.BC4_SNORM:
    case FormatTypeFlags.BC4_UNORM:
    case FormatTypeFlags.BC5_SNORM:
    case FormatTypeFlags.BC5_UNORM:
      return true;
    default:
      return false;
  }
}
function getFormatBlockSize(format2) {
  var formatTypeFlags = getFormatTypeFlags(format2);
  switch (formatTypeFlags) {
    case FormatTypeFlags.BC1:
    case FormatTypeFlags.BC2:
    case FormatTypeFlags.BC3:
    case FormatTypeFlags.BC4_SNORM:
    case FormatTypeFlags.BC4_UNORM:
    case FormatTypeFlags.BC5_SNORM:
    case FormatTypeFlags.BC5_UNORM:
      return 4;
    default:
      return 1;
  }
}
function allocateAndCopyTypedBuffer(type, sizeOrDstBuffer, sizeInBytes, copyBuffer) {
  if (sizeInBytes === void 0) {
    sizeInBytes = false;
  }
  switch (type) {
    case Format.S8_R:
    case Format.S8_R_NORM:
    case Format.S8_RG_NORM:
    case Format.S8_RGB_NORM:
    case Format.S8_RGBA_NORM: {
      var buffer_1 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int8Array(sizeOrDstBuffer) : new Int8Array(sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_1.set(new Int8Array(copyBuffer));
      }
      return buffer_1;
    }
    case Format.U8_R:
    case Format.U8_R_NORM:
    case Format.U8_RG:
    case Format.U8_RG_NORM:
    case Format.U8_RGB:
    case Format.U8_RGB_NORM:
    case Format.U8_RGB_SRGB:
    case Format.U8_RGBA:
    case Format.U8_RGBA_NORM:
    case Format.U8_RGBA_SRGB: {
      var buffer_2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_2.set(new Uint8Array(copyBuffer));
      }
      return buffer_2;
    }
    case Format.S16_R:
    case Format.S16_RG:
    case Format.S16_RG_NORM:
    case Format.S16_RGB_NORM:
    case Format.S16_RGBA:
    case Format.S16_RGBA_NORM: {
      var buffer_3 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int16Array(sizeOrDstBuffer) : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_3.set(new Int16Array(copyBuffer));
      }
      return buffer_3;
    }
    case Format.U16_R:
    case Format.U16_RGB:
    case Format.U16_RGBA_5551:
    case Format.U16_RGBA_NORM:
    case Format.U16_RG_NORM:
    case Format.U16_R_NORM: {
      var buffer_4 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint16Array(sizeOrDstBuffer) : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_4.set(new Uint16Array(copyBuffer));
      }
      return buffer_4;
    }
    case Format.S32_R: {
      var buffer_5 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int32Array(sizeOrDstBuffer) : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_5.set(new Int32Array(copyBuffer));
      }
      return buffer_5;
    }
    case Format.U32_R:
    case Format.U32_RG: {
      var buffer_6 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint32Array(sizeOrDstBuffer) : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_6.set(new Uint32Array(copyBuffer));
      }
      return buffer_6;
    }
    case Format.F32_R:
    case Format.F32_RG:
    case Format.F32_RGB:
    case Format.F32_RGBA: {
      var buffer_7 = sizeOrDstBuffer instanceof ArrayBuffer ? new Float32Array(sizeOrDstBuffer) : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_7.set(new Float32Array(copyBuffer));
      }
      return buffer_7;
    }
  }
  var buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);
  if (copyBuffer) {
    buffer.set(new Uint8Array(copyBuffer));
  }
  return buffer;
}
function halfFloat2Number(value) {
  var s = (value & 32768) >> 15;
  var e = (value & 31744) >> 10;
  var f = value & 1023;
  if (e === 0) {
    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
  } else if (e == 31) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
}
function getBlockInformationFromFormat(format2) {
  switch (format2) {
    case "r8unorm":
    case "r8snorm":
    case "r8uint":
    case "r8sint":
      return { width: 1, height: 1, length: 1 };
    case "r16uint":
    case "r16sint":
    case "r16float":
    case "rg8unorm":
    case "rg8snorm":
    case "rg8uint":
    case "rg8sint":
      return { width: 1, height: 1, length: 2 };
    case "r32uint":
    case "r32sint":
    case "r32float":
    case "rg16uint":
    case "rg16sint":
    case "rg16float":
    case "rgba8unorm":
    case "rgba8unorm-srgb":
    case "rgba8snorm":
    case "rgba8uint":
    case "rgba8sint":
    case "bgra8unorm":
    case "bgra8unorm-srgb":
    case "rgb9e5ufloat":
    case "rgb10a2unorm":
    case "rg11b10ufloat":
      return { width: 1, height: 1, length: 4 };
    case "rg32uint":
    case "rg32sint":
    case "rg32float":
    case "rgba16uint":
    case "rgba16sint":
    case "rgba16float":
      return { width: 1, height: 1, length: 8 };
    case "rgba32uint":
    case "rgba32sint":
    case "rgba32float":
      return { width: 1, height: 1, length: 16 };
    case "stencil8":
      throw new Error("No fixed size for Stencil8 format!");
    case "depth16unorm":
      return { width: 1, height: 1, length: 2 };
    case "depth24plus":
      throw new Error("No fixed size for Depth24Plus format!");
    case "depth24plus-stencil8":
      throw new Error("No fixed size for Depth24PlusStencil8 format!");
    case "depth32float":
      return { width: 1, height: 1, length: 4 };
    case "depth32float-stencil8":
      return { width: 1, height: 1, length: 5 };
    case "bc7-rgba-unorm":
    case "bc7-rgba-unorm-srgb":
    case "bc6h-rgb-ufloat":
    case "bc6h-rgb-float":
    case "bc2-rgba-unorm":
    case "bc2-rgba-unorm-srgb":
    case "bc3-rgba-unorm":
    case "bc3-rgba-unorm-srgb":
    case "bc5-rg-unorm":
    case "bc5-rg-snorm":
      return { width: 4, height: 4, length: 16 };
    case "bc4-r-unorm":
    case "bc4-r-snorm":
    case "bc1-rgba-unorm":
    case "bc1-rgba-unorm-srgb":
      return { width: 4, height: 4, length: 8 };
    default:
      return { width: 1, height: 1, length: 4 };
  }
}
var ResourceBase_WebGPU = (
  /** @class */
  function(_super) {
    __extends(ResourceBase_WebGPU2, _super);
    function ResourceBase_WebGPU2(_a2) {
      var id = _a2.id, device = _a2.device;
      var _this = _super.call(this) || this;
      _this.id = id;
      _this.device = device;
      return _this;
    }
    ResourceBase_WebGPU2.prototype.destroy = function() {
    };
    return ResourceBase_WebGPU2;
  }(eventemitter3_default)
);
var Bindings_WebGPU = (
  /** @class */
  function(_super) {
    __extends(Bindings_WebGPU2, _super);
    function Bindings_WebGPU2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _b, _c;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.Bindings;
      var pipeline = descriptor.pipeline;
      assert(!!pipeline);
      var uniformBufferBindings = descriptor.uniformBufferBindings, storageBufferBindings = descriptor.storageBufferBindings, samplerBindings = descriptor.samplerBindings, storageTextureBindings = descriptor.storageTextureBindings;
      _this.numUniformBuffers = (uniformBufferBindings === null || uniformBufferBindings === void 0 ? void 0 : uniformBufferBindings.length) || 0;
      var gpuBindGroupEntries = [[], [], [], []];
      var numBindings = 0;
      if (uniformBufferBindings && uniformBufferBindings.length) {
        for (var i = 0; i < uniformBufferBindings.length; i++) {
          var _d = descriptor.uniformBufferBindings[i], binding = _d.binding, size2 = _d.size, offset = _d.offset, buffer = _d.buffer;
          var gpuBufferBinding = {
            buffer: getPlatformBuffer(buffer),
            offset: offset !== null && offset !== void 0 ? offset : 0,
            size: size2
          };
          gpuBindGroupEntries[0].push({
            binding: binding !== null && binding !== void 0 ? binding : numBindings++,
            resource: gpuBufferBinding
          });
        }
      }
      if (samplerBindings && samplerBindings.length) {
        numBindings = 0;
        for (var i = 0; i < samplerBindings.length; i++) {
          var samplerEntry = __assign(__assign({}, samplerBindings[i]), defaultBindingLayoutSamplerDescriptor);
          var binding = descriptor.samplerBindings[i];
          var texture = binding.texture !== null ? binding.texture : _this.device["getFallbackTexture"](samplerEntry);
          samplerEntry.dimension = texture.dimension;
          samplerEntry.formatKind = getFormatSamplerKind(texture.format);
          var gpuTextureView = texture.gpuTextureView;
          gpuBindGroupEntries[1].push({
            binding: (_b = binding.textureBinding) !== null && _b !== void 0 ? _b : numBindings++,
            resource: gpuTextureView
          });
          if (binding.samplerBinding !== -1) {
            var sampler = binding.sampler !== null ? binding.sampler : _this.device["getFallbackSampler"](samplerEntry);
            var gpuSampler = getPlatformSampler(sampler);
            gpuBindGroupEntries[1].push({
              binding: (_c = binding.samplerBinding) !== null && _c !== void 0 ? _c : numBindings++,
              resource: gpuSampler
            });
          }
        }
      }
      if (storageBufferBindings && storageBufferBindings.length) {
        numBindings = 0;
        for (var i = 0; i < storageBufferBindings.length; i++) {
          var _e = descriptor.storageBufferBindings[i], binding = _e.binding, size2 = _e.size, offset = _e.offset, buffer = _e.buffer;
          var gpuBufferBinding = {
            buffer: getPlatformBuffer(buffer),
            offset: offset !== null && offset !== void 0 ? offset : 0,
            size: size2
          };
          gpuBindGroupEntries[2].push({
            binding: binding !== null && binding !== void 0 ? binding : numBindings++,
            resource: gpuBufferBinding
          });
        }
      }
      if (storageTextureBindings && storageTextureBindings.length) {
        numBindings = 0;
        for (var i = 0; i < storageTextureBindings.length; i++) {
          var _f = descriptor.storageTextureBindings[i], binding = _f.binding, texture = _f.texture;
          var gpuTextureView = texture.gpuTextureView;
          gpuBindGroupEntries[3].push({
            binding: binding !== null && binding !== void 0 ? binding : numBindings++,
            resource: gpuTextureView
          });
        }
      }
      var lastGroupIndex = gpuBindGroupEntries.findLastIndex(function(group2) {
        return !!group2.length;
      });
      _this.gpuBindGroup = gpuBindGroupEntries.map(function(gpuBindGroupEntries2, i2) {
        return i2 <= lastGroupIndex && _this.device.device.createBindGroup({
          layout: pipeline.getBindGroupLayout(i2),
          entries: gpuBindGroupEntries2
        });
      });
      return _this;
    }
    return Bindings_WebGPU2;
  }(ResourceBase_WebGPU)
);
var Buffer_WebGPU = (
  /** @class */
  function(_super) {
    __extends(Buffer_WebGPU2, _super);
    function Buffer_WebGPU2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.Buffer;
      var usage = descriptor.usage, viewOrSize = descriptor.viewOrSize;
      var useMapRead = !!(usage & BufferUsage.MAP_READ);
      _this.usage = translateBufferUsage(usage);
      if (useMapRead) {
        _this.usage = BufferUsage.MAP_READ | BufferUsage.COPY_DST;
      }
      var mapBuffer = !isNumber8(viewOrSize);
      _this.view = !isNumber8(viewOrSize) ? viewOrSize : null;
      _this.size = isNumber8(viewOrSize) ? align2(viewOrSize, 4) : align2(viewOrSize.byteLength, 4);
      if (!isNumber8(viewOrSize)) {
        _this.gpuBuffer = _this.device.device.createBuffer({
          usage: _this.usage,
          size: _this.size,
          mappedAtCreation: true
        });
        var ctor = viewOrSize && viewOrSize.constructor || Float32Array;
        new ctor(_this.gpuBuffer.getMappedRange()).set(viewOrSize);
        _this.gpuBuffer.unmap();
      } else {
        _this.gpuBuffer = _this.device.device.createBuffer({
          usage: _this.usage,
          size: _this.size,
          mappedAtCreation: useMapRead ? mapBuffer : false
        });
      }
      return _this;
    }
    Buffer_WebGPU2.prototype.setSubData = function(dstByteOffset, src, srcByteOffset, byteLength) {
      if (srcByteOffset === void 0) {
        srcByteOffset = 0;
      }
      if (byteLength === void 0) {
        byteLength = 0;
      }
      var buffer = this.gpuBuffer;
      byteLength = byteLength || src.byteLength;
      byteLength = Math.min(byteLength, this.size - dstByteOffset);
      var chunkStart = src.byteOffset + srcByteOffset;
      var chunkEnd = chunkStart + byteLength;
      var alignedLength = byteLength + 3 & ~3;
      if (alignedLength !== byteLength) {
        var tempView = new Uint8Array(src.buffer.slice(chunkStart, chunkEnd));
        src = new Uint8Array(alignedLength);
        src.set(tempView);
        srcByteOffset = 0;
        chunkStart = 0;
        chunkEnd = alignedLength;
        byteLength = alignedLength;
      }
      var maxChunk = 1024 * 1024 * 15;
      var offset = 0;
      while (chunkEnd - (chunkStart + offset) > maxChunk) {
        this.device.device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, maxChunk);
        offset += maxChunk;
      }
      this.device.device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, byteLength - offset);
    };
    Buffer_WebGPU2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.gpuBuffer.destroy();
    };
    return Buffer_WebGPU2;
  }(ResourceBase_WebGPU)
);
var ComputePass_WebGPU = (
  /** @class */
  function() {
    function ComputePass_WebGPU2() {
      this.gpuComputePassEncoder = null;
    }
    ComputePass_WebGPU2.prototype.dispatchWorkgroups = function(workgroupCountX, workgroupCountY, workgroupCountZ) {
      this.gpuComputePassEncoder.dispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ);
    };
    ComputePass_WebGPU2.prototype.dispatchWorkgroupsIndirect = function(indirectBuffer, indirectOffset) {
      this.gpuComputePassEncoder.dispatchWorkgroupsIndirect(indirectBuffer.gpuBuffer, indirectOffset);
    };
    ComputePass_WebGPU2.prototype.finish = function() {
      this.gpuComputePassEncoder.end();
      this.gpuComputePassEncoder = null;
      this.frameCommandEncoder = null;
    };
    ComputePass_WebGPU2.prototype.beginComputePass = function(commandEncoder) {
      assert(this.gpuComputePassEncoder === null);
      this.frameCommandEncoder = commandEncoder;
      this.gpuComputePassEncoder = this.frameCommandEncoder.beginComputePass(this.gpuComputePassDescriptor);
    };
    ComputePass_WebGPU2.prototype.setPipeline = function(pipeline_) {
      var pipeline = pipeline_;
      var gpuComputePipeline = assertExists(pipeline.gpuComputePipeline);
      this.gpuComputePassEncoder.setPipeline(gpuComputePipeline);
    };
    ComputePass_WebGPU2.prototype.setBindings = function(bindings_) {
      var _this = this;
      var bindings = bindings_;
      bindings.gpuBindGroup.forEach(function(gpuBindGroup, i) {
        if (gpuBindGroup) {
          _this.gpuComputePassEncoder.setBindGroup(i, bindings.gpuBindGroup[i]);
        }
      });
    };
    ComputePass_WebGPU2.prototype.pushDebugGroup = function(name) {
      this.gpuComputePassEncoder.pushDebugGroup(name);
    };
    ComputePass_WebGPU2.prototype.popDebugGroup = function() {
      this.gpuComputePassEncoder.popDebugGroup();
    };
    ComputePass_WebGPU2.prototype.insertDebugMarker = function(markerLabel) {
      this.gpuComputePassEncoder.insertDebugMarker(markerLabel);
    };
    return ComputePass_WebGPU2;
  }()
);
var ComputePipeline_WebGPU = (
  /** @class */
  function(_super) {
    __extends(ComputePipeline_WebGPU2, _super);
    function ComputePipeline_WebGPU2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.ComputePipeline;
      _this.gpuComputePipeline = null;
      _this.descriptor = descriptor;
      var program = descriptor.program;
      var computeStage = program.computeStage;
      if (computeStage === null)
        return _this;
      var gpuComputePipeline = {
        layout: "auto",
        compute: __assign({}, computeStage)
      };
      _this.gpuComputePipeline = _this.device.device.createComputePipeline(gpuComputePipeline);
      if (_this.name !== void 0) {
        _this.gpuComputePipeline.label = _this.name;
      }
      return _this;
    }
    ComputePipeline_WebGPU2.prototype.getBindGroupLayout = function(index3) {
      return this.gpuComputePipeline.getBindGroupLayout(index3);
    };
    return ComputePipeline_WebGPU2;
  }(ResourceBase_WebGPU)
);
var InputLayout_WebGPU = (
  /** @class */
  function(_super) {
    __extends(InputLayout_WebGPU2, _super);
    function InputLayout_WebGPU2(_a2) {
      var e_1, _b, e_2, _c;
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.InputLayout;
      var buffers = [];
      try {
        for (var _d = __values(descriptor.vertexBufferDescriptors), _e = _d.next(); !_e.done; _e = _d.next()) {
          var vertexBufferDescriptor = _e.value;
          var arrayStride = vertexBufferDescriptor.arrayStride, stepMode = vertexBufferDescriptor.stepMode, attributes = vertexBufferDescriptor.attributes;
          buffers.push({
            arrayStride,
            stepMode: translateVertexStepMode(stepMode),
            attributes: []
          });
          try {
            for (var attributes_1 = (e_2 = void 0, __values(attributes)), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
              var attribute = attributes_1_1.value;
              var shaderLocation = attribute.shaderLocation, format2 = attribute.format, offset = attribute.offset;
              buffers[buffers.length - 1].attributes.push({
                shaderLocation,
                format: translateVertexFormat(format2),
                offset
              });
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (attributes_1_1 && !attributes_1_1.done && (_c = attributes_1.return))
                _c.call(attributes_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_e && !_e.done && (_b = _d.return))
            _b.call(_d);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      _this.indexFormat = translateIndexFormat(descriptor.indexBufferFormat);
      _this.buffers = buffers;
      return _this;
    }
    return InputLayout_WebGPU2;
  }(ResourceBase_WebGPU)
);
var Program_WebGPU = (
  /** @class */
  function(_super) {
    __extends(Program_WebGPU2, _super);
    function Program_WebGPU2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.Program;
      _this.vertexStage = null;
      _this.fragmentStage = null;
      _this.computeStage = null;
      _this.descriptor = descriptor;
      if (descriptor.vertex) {
        _this.vertexStage = _this.createShaderStage(descriptor.vertex, "vertex");
      }
      if (descriptor.fragment) {
        _this.fragmentStage = _this.createShaderStage(descriptor.fragment, "fragment");
      }
      if (descriptor.compute) {
        _this.computeStage = _this.createShaderStage(descriptor.compute, "compute");
      }
      return _this;
    }
    Program_WebGPU2.prototype.setUniformsLegacy = function(uniforms) {
    };
    Program_WebGPU2.prototype.createShaderStage = function(_a2, shaderStage) {
      var e_1, _b;
      var glsl = _a2.glsl, wgsl = _a2.wgsl, entryPoint = _a2.entryPoint, postprocess = _a2.postprocess;
      var validationEnabled = false;
      var code = wgsl;
      if (!code) {
        try {
          code = this.device["glsl_compile"](glsl, shaderStage, validationEnabled);
        } catch (e) {
          console.error(e, glsl);
          throw new Error("whoops");
        }
      }
      var _loop_1 = function(depthTextureName2) {
        if (!code.includes(depthTextureName2))
          return "continue";
        code = code.replace("var T_".concat(depthTextureName2, ": texture_2d<f32>;"), "var T_".concat(depthTextureName2, ": texture_depth_2d;"));
        code = code.replace(new RegExp("textureSample\\(T_".concat(depthTextureName2, "(.*)\\);$"), "gm"), function(sub, cap) {
          return "vec4<f32>(textureSample(T_".concat(depthTextureName2).concat(cap, "), 0.0, 0.0, 0.0);");
        });
      };
      try {
        for (var _c = __values(["u_TextureFramebufferDepth"]), _d = _c.next(); !_d.done; _d = _c.next()) {
          var depthTextureName = _d.value;
          _loop_1(depthTextureName);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_b = _c.return))
            _b.call(_c);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (postprocess) {
        code = postprocess(code);
      }
      var shaderModule = this.device.device.createShaderModule({ code });
      return { module: shaderModule, entryPoint: entryPoint || "main" };
    };
    return Program_WebGPU2;
  }(ResourceBase_WebGPU)
);
var QueryPool_WebGPU = (
  /** @class */
  function(_super) {
    __extends(QueryPool_WebGPU2, _super);
    function QueryPool_WebGPU2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.QueryPool;
      var elemCount = descriptor.elemCount, type = descriptor.type;
      _this.querySet = _this.device.device.createQuerySet({
        type: translateQueryPoolType(type),
        count: elemCount
      });
      _this.resolveBuffer = _this.device.device.createBuffer({
        size: elemCount * 8,
        usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
      });
      _this.cpuBuffer = _this.device.device.createBuffer({
        size: elemCount * 8,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      });
      _this.results = null;
      return _this;
    }
    QueryPool_WebGPU2.prototype.queryResultOcclusion = function(dstOffs) {
      if (this.results === null)
        return null;
      return this.results[dstOffs] !== BigInt(0);
    };
    QueryPool_WebGPU2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.querySet.destroy();
      this.resolveBuffer.destroy();
      this.cpuBuffer.destroy();
    };
    return QueryPool_WebGPU2;
  }(ResourceBase_WebGPU)
);
var Readback_WebGPU = (
  /** @class */
  function(_super) {
    __extends(Readback_WebGPU2, _super);
    function Readback_WebGPU2(_a2) {
      var id = _a2.id, device = _a2.device;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.Readback;
      return _this;
    }
    Readback_WebGPU2.prototype.readTexture = function(t, x, y, width, height, dst, dstOffset, length2) {
      if (dstOffset === void 0) {
        dstOffset = 0;
      }
      return __awaiter(this, void 0, void 0, function() {
        var texture, faceIndex, blockInformation, bytesPerRow, bytesPerRowAligned, size2, buffer, commandEncoder;
        return __generator2(this, function(_a2) {
          texture = t;
          faceIndex = 0;
          blockInformation = getBlockInformationFromFormat(texture.gpuTextureformat);
          bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;
          bytesPerRowAligned = Math.ceil(bytesPerRow / 256) * 256;
          size2 = bytesPerRowAligned * height;
          buffer = this.device.createBuffer({
            usage: BufferUsage.STORAGE | BufferUsage.MAP_READ | BufferUsage.COPY_DST,
            hint: BufferFrequencyHint.STATIC,
            viewOrSize: size2
          });
          commandEncoder = this.device.device.createCommandEncoder();
          commandEncoder.copyTextureToBuffer({
            texture: texture.gpuTexture,
            mipLevel: 0,
            origin: {
              x,
              y,
              z: Math.max(faceIndex, 0)
            }
          }, {
            buffer: buffer.gpuBuffer,
            offset: 0,
            bytesPerRow: bytesPerRowAligned
          }, {
            width,
            height,
            depthOrArrayLayers: 1
          });
          this.device.device.queue.submit([commandEncoder.finish()]);
          return [2, this.readBuffer(buffer, 0, dst.byteLength === size2 ? dst : null, dstOffset, size2, texture.format, true, false, bytesPerRow, bytesPerRowAligned, height)];
        });
      });
    };
    Readback_WebGPU2.prototype.readTextureSync = function(t, x, y, width, height, dst, dstOffset, length2) {
      throw new Error("ERROR_MSG_METHOD_NOT_IMPLEMENTED");
    };
    Readback_WebGPU2.prototype.readBuffer = function(b, srcByteOffset, dstArrayBufferView, dstOffset, _size, type, noDataConversion, destroy, bytesPerRow, bytesPerRowAligned, height) {
      var _this = this;
      if (srcByteOffset === void 0) {
        srcByteOffset = 0;
      }
      if (dstArrayBufferView === void 0) {
        dstArrayBufferView = null;
      }
      if (_size === void 0) {
        _size = 0;
      }
      if (type === void 0) {
        type = Format.U8_RGB;
      }
      if (noDataConversion === void 0) {
        noDataConversion = false;
      }
      if (bytesPerRow === void 0) {
        bytesPerRow = 0;
      }
      if (bytesPerRowAligned === void 0) {
        bytesPerRowAligned = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      var buffer = b;
      var size2 = _size || buffer.size;
      var dst = dstArrayBufferView || buffer.view;
      var floatFormat = (
        // @ts-ignore
        dst && dst.constructor && dst.constructor.BYTES_PER_ELEMENT || getFormatCompByteSize(type)
      );
      var gpuReadBuffer = buffer;
      if (!(buffer.usage & BufferUsage.MAP_READ && buffer.usage & BufferUsage.COPY_DST)) {
        var commandEncoder = this.device.device.createCommandEncoder();
        gpuReadBuffer = this.device.createBuffer({
          usage: BufferUsage.STORAGE | BufferUsage.MAP_READ | BufferUsage.COPY_DST,
          hint: BufferFrequencyHint.STATIC,
          viewOrSize: size2
        });
        commandEncoder.copyBufferToBuffer(
          buffer.gpuBuffer,
          srcByteOffset,
          gpuReadBuffer.gpuBuffer,
          0,
          size2
          /* size */
        );
        this.device.device.queue.submit([commandEncoder.finish()]);
      }
      return new Promise(function(resolve, reject) {
        gpuReadBuffer.gpuBuffer.mapAsync(GPUMapMode.READ, srcByteOffset, size2).then(function() {
          var copyArrayBuffer = gpuReadBuffer.gpuBuffer.getMappedRange(srcByteOffset, size2);
          var data = dst;
          if (noDataConversion) {
            if (data === null) {
              data = allocateAndCopyTypedBuffer(type, size2, true, copyArrayBuffer);
            } else {
              data = allocateAndCopyTypedBuffer(type, data.buffer, void 0, copyArrayBuffer);
            }
          } else {
            if (data === null) {
              switch (floatFormat) {
                case 1:
                  data = new Uint8Array(size2);
                  data.set(new Uint8Array(copyArrayBuffer));
                  break;
                case 2:
                  data = _this.getHalfFloatAsFloatRGBAArrayBuffer(size2 / 2, copyArrayBuffer);
                  break;
                case 4:
                  data = new Float32Array(size2 / 4);
                  data.set(new Float32Array(copyArrayBuffer));
                  break;
              }
            } else {
              switch (floatFormat) {
                case 1:
                  data = new Uint8Array(data.buffer);
                  data.set(new Uint8Array(copyArrayBuffer));
                  break;
                case 2:
                  data = _this.getHalfFloatAsFloatRGBAArrayBuffer(size2 / 2, copyArrayBuffer, dst);
                  break;
                case 4:
                  var ctor = dst && dst.constructor || Float32Array;
                  data = new ctor(data.buffer);
                  data.set(new ctor(copyArrayBuffer));
                  break;
              }
            }
          }
          if (bytesPerRow !== bytesPerRowAligned) {
            if (floatFormat === 1 && !noDataConversion) {
              bytesPerRow *= 2;
              bytesPerRowAligned *= 2;
            }
            var data2 = new Uint8Array(data.buffer);
            var offset = bytesPerRow, offset2 = 0;
            for (var y = 1; y < height; ++y) {
              offset2 = y * bytesPerRowAligned;
              for (var x = 0; x < bytesPerRow; ++x) {
                data2[offset++] = data2[offset2++];
              }
            }
            if (floatFormat !== 0 && !noDataConversion) {
              data = new Float32Array(data2.buffer, 0, offset / 4);
            } else {
              data = new Uint8Array(data2.buffer, 0, offset);
            }
          }
          gpuReadBuffer.gpuBuffer.unmap();
          resolve(data);
        }, function(reason) {
          return reject(reason);
        });
      });
    };
    Readback_WebGPU2.prototype.getHalfFloatAsFloatRGBAArrayBuffer = function(dataLength, arrayBuffer, destArray) {
      if (!destArray) {
        destArray = new Float32Array(dataLength);
      }
      var srcData = new Uint16Array(arrayBuffer);
      while (dataLength--) {
        destArray[dataLength] = halfFloat2Number(srcData[dataLength]);
      }
      return destArray;
    };
    return Readback_WebGPU2;
  }(ResourceBase_WebGPU)
);
var RenderPass_WebGPU = (
  /** @class */
  function() {
    function RenderPass_WebGPU2(device) {
      this.device = device;
      this.gpuRenderPassEncoder = null;
      this.gfxColorAttachment = [];
      this.gfxColorAttachmentLevel = [];
      this.gfxColorResolveTo = [];
      this.gfxColorResolveToLevel = [];
      this.gfxDepthStencilAttachment = null;
      this.gfxDepthStencilResolveTo = null;
      this.gpuColorAttachments = [];
      this.gpuDepthStencilAttachment = {
        view: null,
        depthLoadOp: "load",
        depthStoreOp: "store",
        stencilLoadOp: "load",
        stencilStoreOp: "store"
      };
      this.gpuRenderPassDescriptor = {
        colorAttachments: this.gpuColorAttachments,
        depthStencilAttachment: this.gpuDepthStencilAttachment
      };
    }
    RenderPass_WebGPU2.prototype.getEncoder = function() {
      var _a2;
      return ((_a2 = this.renderBundle) === null || _a2 === void 0 ? void 0 : _a2["renderBundleEncoder"]) || this.gpuRenderPassEncoder;
    };
    RenderPass_WebGPU2.prototype.getTextureView = function(target, level) {
      assert(level < target.mipLevelCount);
      if (target.mipLevelCount === 1)
        return target.gpuTextureView;
      else
        return target.gpuTexture.createView({
          baseMipLevel: level,
          mipLevelCount: 1
        });
    };
    RenderPass_WebGPU2.prototype.setRenderPassDescriptor = function(descriptor) {
      var _a2, _b, _c, _d, _e, _f;
      this.descriptor = descriptor;
      this.gpuRenderPassDescriptor.colorAttachments = this.gpuColorAttachments;
      var numColorAttachments = descriptor.colorAttachment.length;
      this.gfxColorAttachment.length = numColorAttachments;
      this.gfxColorResolveTo.length = numColorAttachments;
      for (var i = 0; i < descriptor.colorAttachment.length; i++) {
        var colorAttachment = descriptor.colorAttachment[i];
        var colorResolveTo = descriptor.colorResolveTo[i];
        if (colorAttachment === null && colorResolveTo !== null) {
          colorAttachment = colorResolveTo;
          colorResolveTo = null;
        }
        this.gfxColorAttachment[i] = colorAttachment;
        this.gfxColorResolveTo[i] = colorResolveTo;
        this.gfxColorAttachmentLevel[i] = ((_a2 = descriptor.colorAttachmentLevel) === null || _a2 === void 0 ? void 0 : _a2[i]) || 0;
        this.gfxColorResolveToLevel[i] = ((_b = descriptor.colorResolveToLevel) === null || _b === void 0 ? void 0 : _b[i]) || 0;
        if (colorAttachment !== null) {
          if (this.gpuColorAttachments[i] === void 0) {
            this.gpuColorAttachments[i] = {};
          }
          var dstAttachment = this.gpuColorAttachments[i];
          dstAttachment.view = this.getTextureView(colorAttachment, ((_c = this.gfxColorAttachmentLevel) === null || _c === void 0 ? void 0 : _c[i]) || 0);
          var clearColor = (_e = (_d = descriptor.colorClearColor) === null || _d === void 0 ? void 0 : _d[i]) !== null && _e !== void 0 ? _e : "load";
          if (clearColor === "load") {
            dstAttachment.loadOp = "load";
          } else {
            dstAttachment.loadOp = "clear";
            dstAttachment.clearValue = clearColor;
          }
          dstAttachment.storeOp = ((_f = descriptor.colorStore) === null || _f === void 0 ? void 0 : _f[i]) ? "store" : "discard";
          dstAttachment.resolveTarget = void 0;
          if (colorResolveTo !== null) {
            if (colorAttachment.sampleCount > 1) {
              dstAttachment.resolveTarget = this.getTextureView(colorResolveTo, this.gfxColorResolveToLevel[i]);
            } else {
              dstAttachment.storeOp = "store";
            }
          }
        } else {
          this.gpuColorAttachments.length = i;
          this.gfxColorAttachment.length = i;
          this.gfxColorResolveTo.length = i;
          break;
        }
      }
      this.gfxDepthStencilAttachment = descriptor.depthStencilAttachment;
      this.gfxDepthStencilResolveTo = descriptor.depthStencilResolveTo;
      if (descriptor.depthStencilAttachment) {
        var dsAttachment = descriptor.depthStencilAttachment;
        var dstAttachment = this.gpuDepthStencilAttachment;
        dstAttachment.view = dsAttachment.gpuTextureView;
        var hasDepth = !!(getFormatFlags(dsAttachment.format) & FormatFlags.Depth);
        if (hasDepth) {
          if (descriptor.depthClearValue === "load") {
            dstAttachment.depthLoadOp = "load";
          } else {
            dstAttachment.depthLoadOp = "clear";
            dstAttachment.depthClearValue = descriptor.depthClearValue;
          }
          if (descriptor.depthStencilStore || this.gfxDepthStencilResolveTo !== null)
            dstAttachment.depthStoreOp = "store";
          else
            dstAttachment.depthStoreOp = "discard";
        } else {
          dstAttachment.depthLoadOp = void 0;
          dstAttachment.depthStoreOp = void 0;
        }
        var hasStencil = !!(getFormatFlags(dsAttachment.format) & FormatFlags.Stencil);
        if (hasStencil) {
          if (descriptor.stencilClearValue === "load") {
            dstAttachment.stencilLoadOp = "load";
          } else {
            dstAttachment.stencilLoadOp = "clear";
            dstAttachment.stencilClearValue = descriptor.stencilClearValue;
          }
          if (descriptor.depthStencilStore || this.gfxDepthStencilResolveTo !== null)
            dstAttachment.stencilStoreOp = "store";
          else
            dstAttachment.stencilStoreOp = "discard";
        } else {
          dstAttachment.stencilLoadOp = void 0;
          dstAttachment.stencilStoreOp = void 0;
        }
        this.gpuRenderPassDescriptor.depthStencilAttachment = this.gpuDepthStencilAttachment;
      } else {
        this.gpuRenderPassDescriptor.depthStencilAttachment = void 0;
      }
      this.gpuRenderPassDescriptor.occlusionQuerySet = !isNil2(descriptor.occlusionQueryPool) ? getPlatformQuerySet(descriptor.occlusionQueryPool) : void 0;
    };
    RenderPass_WebGPU2.prototype.beginRenderPass = function(commandEncoder, renderPassDescriptor) {
      assert(this.gpuRenderPassEncoder === null);
      this.setRenderPassDescriptor(renderPassDescriptor);
      this.frameCommandEncoder = commandEncoder;
      this.gpuRenderPassEncoder = this.frameCommandEncoder.beginRenderPass(this.gpuRenderPassDescriptor);
    };
    RenderPass_WebGPU2.prototype.flipY = function(y, h) {
      var height = this.device["swapChainHeight"];
      return height - y - h;
    };
    RenderPass_WebGPU2.prototype.setViewport = function(x, y, w, h, minDepth, maxDepth) {
      if (minDepth === void 0) {
        minDepth = 0;
      }
      if (maxDepth === void 0) {
        maxDepth = 1;
      }
      this.gpuRenderPassEncoder.setViewport(x, this.flipY(y, h), w, h, minDepth, maxDepth);
    };
    RenderPass_WebGPU2.prototype.setScissorRect = function(x, y, w, h) {
      this.gpuRenderPassEncoder.setScissorRect(x, this.flipY(y, h), w, h);
    };
    RenderPass_WebGPU2.prototype.setPipeline = function(pipeline_) {
      var pipeline = pipeline_;
      var gpuRenderPipeline = assertExists(pipeline.gpuRenderPipeline);
      this.getEncoder().setPipeline(gpuRenderPipeline);
    };
    RenderPass_WebGPU2.prototype.setVertexInput = function(inputLayout_, vertexBuffers, indexBuffer) {
      if (inputLayout_ === null)
        return;
      var encoder = this.getEncoder();
      var inputLayout = inputLayout_;
      if (indexBuffer !== null)
        encoder.setIndexBuffer(getPlatformBuffer(indexBuffer.buffer), assertExists(inputLayout.indexFormat), indexBuffer.offset);
      for (var i = 0; i < vertexBuffers.length; i++) {
        var b = vertexBuffers[i];
        if (b === null)
          continue;
        encoder.setVertexBuffer(i, getPlatformBuffer(b.buffer), b.offset);
      }
    };
    RenderPass_WebGPU2.prototype.setBindings = function(bindings_) {
      var bindings = bindings_;
      var encoder = this.getEncoder();
      bindings.gpuBindGroup.forEach(function(gpuBindGroup, i) {
        if (gpuBindGroup) {
          encoder.setBindGroup(i, bindings.gpuBindGroup[i]);
        }
      });
    };
    RenderPass_WebGPU2.prototype.setStencilReference = function(ref) {
      this.gpuRenderPassEncoder.setStencilReference(ref);
    };
    RenderPass_WebGPU2.prototype.draw = function(vertexCount, instanceCount, firstVertex, firstInstance) {
      this.getEncoder().draw(vertexCount, instanceCount, firstVertex, firstInstance);
    };
    RenderPass_WebGPU2.prototype.drawIndexed = function(indexCount, instanceCount, firstIndex, baseVertex, firstInstance) {
      this.getEncoder().drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
    };
    RenderPass_WebGPU2.prototype.drawIndirect = function(indirectBuffer, indirectOffset) {
      this.getEncoder().drawIndirect(getPlatformBuffer(indirectBuffer), indirectOffset);
    };
    RenderPass_WebGPU2.prototype.drawIndexedIndirect = function(indirectBuffer, indirectOffset) {
      this.getEncoder().drawIndexedIndirect(getPlatformBuffer(indirectBuffer), indirectOffset);
    };
    RenderPass_WebGPU2.prototype.beginOcclusionQuery = function(queryIndex) {
      this.gpuRenderPassEncoder.beginOcclusionQuery(queryIndex);
    };
    RenderPass_WebGPU2.prototype.endOcclusionQuery = function() {
      this.gpuRenderPassEncoder.endOcclusionQuery();
    };
    RenderPass_WebGPU2.prototype.pushDebugGroup = function(name) {
      this.gpuRenderPassEncoder.pushDebugGroup(name);
    };
    RenderPass_WebGPU2.prototype.popDebugGroup = function() {
      this.gpuRenderPassEncoder.popDebugGroup();
    };
    RenderPass_WebGPU2.prototype.insertDebugMarker = function(markerLabel) {
      this.gpuRenderPassEncoder.insertDebugMarker(markerLabel);
    };
    RenderPass_WebGPU2.prototype.beginBundle = function(renderBundle) {
      this.renderBundle = renderBundle;
    };
    RenderPass_WebGPU2.prototype.endBundle = function() {
      this.renderBundle.finish();
    };
    RenderPass_WebGPU2.prototype.executeBundles = function(renderBundles) {
      this.gpuRenderPassEncoder.executeBundles(renderBundles.map(function(bundle) {
        return bundle.renderBundle;
      }));
    };
    RenderPass_WebGPU2.prototype.finish = function() {
      var _a2;
      (_a2 = this.gpuRenderPassEncoder) === null || _a2 === void 0 ? void 0 : _a2.end();
      this.gpuRenderPassEncoder = null;
      for (var i = 0; i < this.gfxColorAttachment.length; i++) {
        var colorAttachment = this.gfxColorAttachment[i];
        var colorResolveTo = this.gfxColorResolveTo[i];
        if (colorAttachment !== null && colorResolveTo !== null && colorAttachment.sampleCount === 1) {
          this.copyAttachment(colorResolveTo, this.gfxColorAttachmentLevel[i], colorAttachment, this.gfxColorResolveToLevel[i]);
        }
      }
      if (this.gfxDepthStencilAttachment && this.gfxDepthStencilResolveTo) {
        if (this.gfxDepthStencilAttachment.sampleCount > 1)
          ;
        else {
          this.copyAttachment(this.gfxDepthStencilResolveTo, 0, this.gfxDepthStencilAttachment, 0);
        }
      }
      this.frameCommandEncoder = null;
    };
    RenderPass_WebGPU2.prototype.copyAttachment = function(dst, dstLevel, src, srcLevel) {
      assert(src.sampleCount === 1);
      var srcCopy = {
        texture: src.gpuTexture,
        mipLevel: srcLevel
      };
      var dstCopy = {
        texture: dst.gpuTexture,
        mipLevel: dstLevel
      };
      assert(src.width >>> srcLevel === dst.width >>> dstLevel);
      assert(src.height >>> srcLevel === dst.height >>> dstLevel);
      assert(!!(src.usage & GPUTextureUsage$1.COPY_SRC));
      assert(!!(dst.usage & GPUTextureUsage$1.COPY_DST));
      this.frameCommandEncoder.copyTextureToTexture(srcCopy, dstCopy, [
        dst.width,
        dst.height,
        1
      ]);
    };
    return RenderPass_WebGPU2;
  }()
);
var RenderPipeline_WebGPU = (
  /** @class */
  function(_super) {
    __extends(RenderPipeline_WebGPU2, _super);
    function RenderPipeline_WebGPU2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.RenderPipeline;
      _this.isCreatingAsync = false;
      _this.gpuRenderPipeline = null;
      _this.descriptor = descriptor;
      _this.device["createRenderPipelineInternal"](_this, false);
      return _this;
    }
    RenderPipeline_WebGPU2.prototype.getBindGroupLayout = function(index3) {
      return this.gpuRenderPipeline.getBindGroupLayout(index3);
    };
    return RenderPipeline_WebGPU2;
  }(ResourceBase_WebGPU)
);
var Sampler_WebGPU = (
  /** @class */
  function(_super) {
    __extends(Sampler_WebGPU2, _super);
    function Sampler_WebGPU2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor;
      var _b, _c;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.Sampler;
      var lodMinClamp = descriptor.lodMinClamp;
      var lodMaxClamp = descriptor.mipmapFilter === MipmapFilterMode.NO_MIP ? descriptor.lodMinClamp : descriptor.lodMaxClamp;
      var maxAnisotropy = (_b = descriptor.maxAnisotropy) !== null && _b !== void 0 ? _b : 1;
      if (maxAnisotropy > 1)
        assert(descriptor.minFilter === FilterMode.BILINEAR && descriptor.magFilter === FilterMode.BILINEAR && descriptor.mipmapFilter === MipmapFilterMode.LINEAR);
      _this.gpuSampler = _this.device.device.createSampler({
        addressModeU: translateAddressMode(descriptor.addressModeU),
        addressModeV: translateAddressMode(descriptor.addressModeV),
        addressModeW: translateAddressMode((_c = descriptor.addressModeW) !== null && _c !== void 0 ? _c : descriptor.addressModeU),
        lodMinClamp,
        lodMaxClamp,
        minFilter: translateMinMagFilter(descriptor.minFilter),
        magFilter: translateMinMagFilter(descriptor.magFilter),
        mipmapFilter: translateMipFilter(descriptor.mipmapFilter),
        compare: descriptor.compareFunction !== void 0 ? translateCompareFunction(descriptor.compareFunction) : void 0,
        maxAnisotropy
      });
      return _this;
    }
    return Sampler_WebGPU2;
  }(ResourceBase_WebGPU)
);
var Texture_WebGPU = (
  /** @class */
  function(_super) {
    __extends(Texture_WebGPU2, _super);
    function Texture_WebGPU2(_a2) {
      var id = _a2.id, device = _a2.device, descriptor = _a2.descriptor, skipCreate = _a2.skipCreate, sampleCount = _a2.sampleCount;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.Texture;
      _this.flipY = false;
      var format2 = descriptor.format, dimension = descriptor.dimension, width = descriptor.width, height = descriptor.height, depthOrArrayLayers = descriptor.depthOrArrayLayers, mipLevelCount = descriptor.mipLevelCount, usage = descriptor.usage, pixelStore = descriptor.pixelStore;
      _this.flipY = !!(pixelStore === null || pixelStore === void 0 ? void 0 : pixelStore.unpackFlipY);
      _this.device.createTextureShared({
        format: format2,
        dimension: dimension !== null && dimension !== void 0 ? dimension : TextureDimension.TEXTURE_2D,
        width,
        height,
        depthOrArrayLayers: depthOrArrayLayers !== null && depthOrArrayLayers !== void 0 ? depthOrArrayLayers : 1,
        mipLevelCount: mipLevelCount !== null && mipLevelCount !== void 0 ? mipLevelCount : 1,
        usage,
        sampleCount: sampleCount !== null && sampleCount !== void 0 ? sampleCount : 1
      }, _this, skipCreate);
      return _this;
    }
    Texture_WebGPU2.prototype.textureFromImageBitmapOrCanvas = function(device, sources, depthOrArrayLayers) {
      var width = sources[0].width;
      var height = sources[0].height;
      var textureDescriptor = {
        // Unlike in WebGL, the size of our texture must be set at texture creation time.
        // This means we have to wait until the image is loaded to create the texture, since we won't
        // know the size until then.
        size: { width, height, depthOrArrayLayers },
        format: "rgba8unorm",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
      };
      var texture = device.createTexture(textureDescriptor);
      for (var i = 0; i < sources.length; i++) {
        device.queue.copyExternalImageToTexture({ source: sources[i], flipY: this.flipY }, { texture, origin: [0, 0, i] }, [width, height]);
      }
      return [texture, width, height];
    };
    Texture_WebGPU2.prototype.isImageBitmapOrCanvases = function(datas) {
      var data = datas[0];
      return data instanceof ImageBitmap || data instanceof HTMLCanvasElement || data instanceof OffscreenCanvas;
    };
    Texture_WebGPU2.prototype.isVideo = function(datas) {
      var data = datas[0];
      return data instanceof HTMLVideoElement;
    };
    Texture_WebGPU2.prototype.setImageData = function(datas, lod) {
      var _a2;
      var _this = this;
      var device = this.device.device;
      var texture;
      var width;
      var height;
      if (this.isImageBitmapOrCanvases(datas)) {
        _a2 = __read(this.textureFromImageBitmapOrCanvas(device, datas, this.depthOrArrayLayers), 3), texture = _a2[0], width = _a2[1], height = _a2[2];
      } else if (this.isVideo(datas)) {
        texture = device.importExternalTexture({
          source: datas[0]
        });
      } else {
        var blockInformation = getBlockInformationFromFormat(this.gpuTextureformat);
        var bytesPerRow_1 = Math.ceil(this.width / blockInformation.width) * blockInformation.length;
        datas.forEach(function(data) {
          device.queue.writeTexture({ texture: _this.gpuTexture }, data, {
            bytesPerRow: bytesPerRow_1
          }, {
            width: _this.width,
            height: _this.height
          });
        });
      }
      this.width = width;
      this.height = height;
      if (texture) {
        this.gpuTexture = texture;
      }
      this.gpuTextureView = this.gpuTexture.createView({
        dimension: translateTextureViewDimension(this.dimension)
      });
    };
    Texture_WebGPU2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.gpuTexture.destroy();
    };
    return Texture_WebGPU2;
  }(ResourceBase_WebGPU)
);
var RenderBundle_WebGPU = (
  /** @class */
  function(_super) {
    __extends(RenderBundle_WebGPU2, _super);
    function RenderBundle_WebGPU2(_a2) {
      var id = _a2.id, device = _a2.device;
      var _this = _super.call(this, { id, device }) || this;
      _this.type = ResourceType.RenderBundle;
      _this.renderBundleEncoder = _this.device.device.createRenderBundleEncoder({
        colorFormats: [_this.device["swapChainFormat"]]
      });
      return _this;
    }
    RenderBundle_WebGPU2.prototype.finish = function() {
      this.renderBundle = this.renderBundleEncoder.finish();
    };
    return RenderBundle_WebGPU2;
  }(ResourceBase_WebGPU)
);
var Device_WebGPU = (
  /** @class */
  function() {
    function Device_WebGPU2(adapter, device, canvas, canvasContext, glsl_compile2, wGSLComposer) {
      this.swapChainWidth = 0;
      this.swapChainHeight = 0;
      this.swapChainTextureUsage = GPUTextureUsage$1.RENDER_ATTACHMENT | GPUTextureUsage$1.COPY_DST;
      this._resourceUniqueId = 0;
      this.renderPassPool = [];
      this.computePassPool = [];
      this.frameCommandEncoderPool = [];
      this.featureTextureCompressionBC = false;
      this.platformString = "WebGPU";
      this.glslVersion = "#version 440";
      this.explicitBindingLocations = true;
      this.separateSamplerTextures = true;
      this.viewportOrigin = ViewportOrigin.UPPER_LEFT;
      this.clipSpaceNearZ = ClipSpaceNearZ.ZERO;
      this.supportsSyncPipelineCompilation = false;
      this.supportMRT = true;
      this.device = device;
      this.canvas = canvas;
      this.canvasContext = canvasContext;
      this.glsl_compile = glsl_compile2;
      this.WGSLComposer = wGSLComposer;
      this.fallbackTexture2D = this.createFallbackTexture(TextureDimension.TEXTURE_2D, SamplerFormatKind.Float);
      this.setResourceName(this.fallbackTexture2D, "Fallback Texture2D");
      this.fallbackTexture2DDepth = this.createFallbackTexture(TextureDimension.TEXTURE_2D, SamplerFormatKind.Depth);
      this.setResourceName(this.fallbackTexture2DDepth, "Fallback Depth Texture2D");
      this.fallbackTexture2DArray = this.createFallbackTexture(TextureDimension.TEXTURE_2D_ARRAY, SamplerFormatKind.Float);
      this.setResourceName(this.fallbackTexture2DArray, "Fallback Texture2DArray");
      this.fallbackTexture3D = this.createFallbackTexture(TextureDimension.TEXTURE_3D, SamplerFormatKind.Float);
      this.setResourceName(this.fallbackTexture3D, "Fallback Texture3D");
      this.fallbackTextureCube = this.createFallbackTexture(TextureDimension.TEXTURE_CUBE_MAP, SamplerFormatKind.Float);
      this.setResourceName(this.fallbackTextureCube, "Fallback TextureCube");
      this.fallbackSamplerFiltering = this.createSampler({
        addressModeU: AddressMode.REPEAT,
        addressModeV: AddressMode.REPEAT,
        minFilter: FilterMode.POINT,
        magFilter: FilterMode.POINT,
        mipmapFilter: MipmapFilterMode.NEAREST
      });
      this.setResourceName(this.fallbackSamplerFiltering, "Fallback Sampler Filtering");
      this.fallbackSamplerComparison = this.createSampler({
        addressModeU: AddressMode.REPEAT,
        addressModeV: AddressMode.REPEAT,
        minFilter: FilterMode.POINT,
        magFilter: FilterMode.POINT,
        mipmapFilter: MipmapFilterMode.NEAREST,
        compareFunction: CompareFunction.ALWAYS
      });
      this.setResourceName(this.fallbackSamplerComparison, "Fallback Sampler Comparison Filtering");
      if (this.device.features) {
        this.featureTextureCompressionBC = this.device.features.has("texture-compression-bc");
      }
      this.device.onuncapturederror = function(event) {
        console.error(event.error);
      };
      this.swapChainFormat = navigator.gpu.getPreferredCanvasFormat();
      this.canvasContext.configure({
        device: this.device,
        format: this.swapChainFormat,
        usage: this.swapChainTextureUsage,
        // @see https://www.w3.org/TR/webgpu/#gpucanvasalphamode
        // alphaMode: 'opaque',
        alphaMode: "premultiplied"
      });
    }
    Device_WebGPU2.prototype.destroy = function() {
    };
    Device_WebGPU2.prototype.configureSwapChain = function(width, height) {
      if (this.swapChainWidth === width && this.swapChainHeight === height)
        return;
      this.swapChainWidth = width;
      this.swapChainHeight = height;
    };
    Device_WebGPU2.prototype.getOnscreenTexture = function() {
      var gpuTexture = this.canvasContext.getCurrentTexture();
      var gpuTextureView = gpuTexture.createView();
      var texture = new Texture_WebGPU({
        id: 0,
        device: this,
        descriptor: {
          format: Format.U8_RGBA_RT,
          width: this.swapChainWidth,
          height: this.swapChainHeight,
          depthOrArrayLayers: 0,
          dimension: TextureDimension.TEXTURE_2D,
          mipLevelCount: 1,
          usage: this.swapChainTextureUsage
        },
        skipCreate: true
      });
      texture.depthOrArrayLayers = 1;
      texture.sampleCount = 1;
      texture.gpuTexture = gpuTexture;
      texture.gpuTextureView = gpuTextureView;
      texture.name = "Onscreen";
      this.setResourceName(texture, "Onscreen Texture");
      return texture;
    };
    Device_WebGPU2.prototype.getDevice = function() {
      return this;
    };
    Device_WebGPU2.prototype.getCanvas = function() {
      return this.canvas;
    };
    Device_WebGPU2.prototype.beginFrame = function() {
      assert(this.frameCommandEncoderPool.length === 0);
    };
    Device_WebGPU2.prototype.endFrame = function() {
      assert(this.frameCommandEncoderPool.every(function(frameCommandEncoder) {
        return frameCommandEncoder !== null;
      }));
      this.device.queue.submit(this.frameCommandEncoderPool.map(function(frameCommandEncoder) {
        return frameCommandEncoder.finish();
      }));
      this.frameCommandEncoderPool = [];
    };
    Device_WebGPU2.prototype.getNextUniqueId = function() {
      return ++this._resourceUniqueId;
    };
    Device_WebGPU2.prototype.createBuffer = function(descriptor) {
      return new Buffer_WebGPU({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_WebGPU2.prototype.createTexture = function(descriptor) {
      return new Texture_WebGPU({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_WebGPU2.prototype.createSampler = function(descriptor) {
      return new Sampler_WebGPU({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_WebGPU2.prototype.createRenderTarget = function(descriptor) {
      var texture = new Texture_WebGPU({
        id: this.getNextUniqueId(),
        device: this,
        descriptor: __assign(__assign({}, descriptor), { dimension: TextureDimension.TEXTURE_2D, mipLevelCount: 1, depthOrArrayLayers: 1, usage: TextureUsage2.RENDER_TARGET }),
        sampleCount: descriptor.sampleCount
      });
      texture.depthOrArrayLayers = 1;
      texture.type = ResourceType.RenderTarget;
      return texture;
    };
    Device_WebGPU2.prototype.createRenderTargetFromTexture = function(texture) {
      var _a2 = texture, format2 = _a2.format, width = _a2.width, height = _a2.height, depthOrArrayLayers = _a2.depthOrArrayLayers, sampleCount = _a2.sampleCount, mipLevelCount = _a2.mipLevelCount, gpuTexture = _a2.gpuTexture, gpuTextureView = _a2.gpuTextureView, usage = _a2.usage;
      assert(!!(usage & GPUTextureUsage$1.RENDER_ATTACHMENT));
      var attachment = new Texture_WebGPU({
        id: this.getNextUniqueId(),
        device: this,
        descriptor: {
          format: format2,
          width,
          height,
          depthOrArrayLayers,
          dimension: TextureDimension.TEXTURE_2D,
          mipLevelCount,
          usage
        },
        skipCreate: true
      });
      attachment.depthOrArrayLayers = depthOrArrayLayers;
      attachment.sampleCount = sampleCount;
      attachment.gpuTexture = gpuTexture;
      attachment.gpuTextureView = gpuTextureView;
      return attachment;
    };
    Device_WebGPU2.prototype.createProgram = function(descriptor) {
      var _a2, _b;
      if ((_a2 = descriptor.vertex) === null || _a2 === void 0 ? void 0 : _a2.glsl) {
        descriptor.vertex.glsl = preprocessShader_GLSL(this.queryVendorInfo(), "vert", descriptor.vertex.glsl);
      }
      if ((_b = descriptor.fragment) === null || _b === void 0 ? void 0 : _b.glsl) {
        descriptor.fragment.glsl = preprocessShader_GLSL(this.queryVendorInfo(), "frag", descriptor.fragment.glsl);
      }
      return new Program_WebGPU({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_WebGPU2.prototype.createProgramSimple = function(descriptor) {
      return new Program_WebGPU({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_WebGPU2.prototype.createTextureShared = function(descriptor, texture, skipCreate) {
      var size2 = {
        width: descriptor.width,
        height: descriptor.height,
        depthOrArrayLayers: descriptor.depthOrArrayLayers
      };
      var mipLevelCount = descriptor.mipLevelCount;
      var format2 = translateTextureFormat(descriptor.format);
      var dimension = translateTextureDimension(descriptor.dimension);
      var usage = translateTextureUsage(descriptor.usage);
      texture.gpuTextureformat = format2;
      texture.dimension = descriptor.dimension;
      texture.format = descriptor.format;
      texture.width = descriptor.width;
      texture.height = descriptor.height;
      texture.depthOrArrayLayers = descriptor.depthOrArrayLayers;
      texture.mipLevelCount = mipLevelCount;
      texture.usage = usage;
      texture.sampleCount = descriptor.sampleCount;
      if (!skipCreate) {
        var gpuTexture = this.device.createTexture({
          size: size2,
          mipLevelCount,
          format: format2,
          dimension,
          sampleCount: descriptor.sampleCount,
          usage
        });
        var gpuTextureView = gpuTexture.createView();
        texture.gpuTexture = gpuTexture;
        texture.gpuTextureView = gpuTextureView;
      }
    };
    Device_WebGPU2.prototype.getFallbackSampler = function(samplerEntry) {
      var formatKind = samplerEntry.formatKind;
      if (formatKind === SamplerFormatKind.Depth && samplerEntry.comparison) {
        return this.fallbackSamplerComparison;
      } else {
        return this.fallbackSamplerFiltering;
      }
    };
    Device_WebGPU2.prototype.getFallbackTexture = function(samplerEntry) {
      var dimension = samplerEntry.dimension, formatKind = samplerEntry.formatKind;
      if (dimension === TextureDimension.TEXTURE_2D)
        return formatKind === SamplerFormatKind.Depth ? this.fallbackTexture2DDepth : this.fallbackTexture2D;
      else if (dimension === TextureDimension.TEXTURE_2D_ARRAY)
        return this.fallbackTexture2DArray;
      else if (dimension === TextureDimension.TEXTURE_3D)
        return this.fallbackTexture3D;
      else if (dimension === TextureDimension.TEXTURE_CUBE_MAP)
        return this.fallbackTextureCube;
      else
        throw new Error("whoops");
    };
    Device_WebGPU2.prototype.createFallbackTexture = function(dimension, formatKind) {
      var depthOrArrayLayers = dimension === TextureDimension.TEXTURE_CUBE_MAP ? 6 : 1;
      var format2 = formatKind === SamplerFormatKind.Float ? Format.U8_RGBA_NORM : Format.D24;
      return this.createTexture({
        dimension,
        format: format2,
        usage: TextureUsage2.SAMPLED,
        width: 1,
        height: 1,
        depthOrArrayLayers,
        mipLevelCount: 1
      });
    };
    Device_WebGPU2.prototype.createBindings = function(descriptor) {
      return new Bindings_WebGPU({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_WebGPU2.prototype.createInputLayout = function(descriptor) {
      return new InputLayout_WebGPU({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_WebGPU2.prototype.createComputePipeline = function(descriptor) {
      return new ComputePipeline_WebGPU({
        id: this.getNextUniqueId(),
        device: this,
        descriptor
      });
    };
    Device_WebGPU2.prototype.createRenderPipeline = function(descriptor) {
      return new RenderPipeline_WebGPU({
        id: this.getNextUniqueId(),
        device: this,
        descriptor: __assign({}, descriptor)
      });
    };
    Device_WebGPU2.prototype.createQueryPool = function(type, elemCount) {
      return new QueryPool_WebGPU({
        id: this.getNextUniqueId(),
        device: this,
        descriptor: {
          type,
          elemCount
        }
      });
    };
    Device_WebGPU2.prototype.createRenderPipelineInternal = function(renderPipeline, async) {
      var _a2;
      if (renderPipeline.gpuRenderPipeline !== null) {
        return;
      }
      var descriptor = renderPipeline.descriptor;
      var program = descriptor.program;
      var vertexStage = program.vertexStage, fragmentStage = program.fragmentStage;
      if (vertexStage === null || fragmentStage === null)
        return;
      var _b = descriptor.megaStateDescriptor || {}, stencilBack = _b.stencilBack, stencilFront = _b.stencilFront, rest = __rest(_b, ["stencilBack", "stencilFront"]);
      var copied = copyMegaState(defaultMegaState);
      descriptor.megaStateDescriptor = __assign(__assign(__assign({}, copied), { stencilBack: __assign(__assign({}, copied.stencilBack), stencilBack), stencilFront: __assign(__assign({}, copied.stencilFront), stencilFront) }), rest);
      var defaultAttachmentState = descriptor.megaStateDescriptor.attachmentsState[0];
      descriptor.colorAttachmentFormats.forEach(function(format2, i) {
        if (!descriptor.megaStateDescriptor.attachmentsState[i]) {
          descriptor.megaStateDescriptor.attachmentsState[i] = copyAttachmentState(void 0, defaultAttachmentState);
        }
      });
      var primitive = translatePrimitiveState((_a2 = descriptor.topology) !== null && _a2 !== void 0 ? _a2 : PrimitiveTopology.TRIANGLES, descriptor.megaStateDescriptor);
      var targets = translateTargets(descriptor.colorAttachmentFormats, descriptor.megaStateDescriptor);
      var depthStencil = translateDepthStencilState(descriptor.depthStencilAttachmentFormat, descriptor.megaStateDescriptor);
      var buffers = void 0;
      if (descriptor.inputLayout !== null)
        buffers = descriptor.inputLayout.buffers;
      var sampleCount = descriptor.sampleCount;
      var gpuRenderPipelineDescriptor = {
        // layout,
        layout: "auto",
        vertex: __assign(__assign({}, vertexStage), { buffers }),
        primitive,
        depthStencil,
        multisample: {
          count: sampleCount
        },
        fragment: __assign(__assign({}, fragmentStage), { targets })
      };
      renderPipeline.gpuRenderPipeline = this.device.createRenderPipeline(gpuRenderPipelineDescriptor);
    };
    Device_WebGPU2.prototype.createReadback = function() {
      return new Readback_WebGPU({
        id: this.getNextUniqueId(),
        device: this
      });
    };
    Device_WebGPU2.prototype.createRenderBundle = function() {
      return new RenderBundle_WebGPU({
        id: this.getNextUniqueId(),
        device: this
      });
    };
    Device_WebGPU2.prototype.createRenderPass = function(renderPassDescriptor) {
      var pass = this.renderPassPool.pop();
      if (pass === void 0) {
        pass = new RenderPass_WebGPU(this);
      }
      var frameCommandEncoder = this.frameCommandEncoderPool.pop();
      if (frameCommandEncoder === void 0) {
        frameCommandEncoder = this.device.createCommandEncoder();
      }
      pass.beginRenderPass(frameCommandEncoder, renderPassDescriptor);
      return pass;
    };
    Device_WebGPU2.prototype.createComputePass = function() {
      var pass = this.computePassPool.pop();
      if (pass === void 0)
        pass = new ComputePass_WebGPU();
      var frameCommandEncoder = this.frameCommandEncoderPool.pop();
      if (frameCommandEncoder === void 0) {
        frameCommandEncoder = this.device.createCommandEncoder();
      }
      pass.beginComputePass(frameCommandEncoder);
      return pass;
    };
    Device_WebGPU2.prototype.submitPass = function(_pass) {
      var pass = _pass;
      if (pass instanceof RenderPass_WebGPU) {
        this.frameCommandEncoderPool.push(pass.frameCommandEncoder);
        pass.finish();
        this.renderPassPool.push(pass);
      } else if (pass instanceof ComputePass_WebGPU) {
        this.frameCommandEncoderPool.push(pass.frameCommandEncoder);
        pass.finish();
        this.computePassPool.push(pass);
      }
    };
    Device_WebGPU2.prototype.copySubTexture2D = function(dst_, dstX, dstY, src_, srcX, srcY, depthOrArrayLayers) {
      var cmd = this.device.createCommandEncoder();
      var dst = dst_;
      var src = src_;
      var srcCopy = {
        texture: src.gpuTexture,
        origin: [srcX, srcY, 0],
        mipLevel: 0,
        aspect: "all"
      };
      var dstCopy = {
        texture: dst.gpuTexture,
        origin: [dstX, dstY, 0],
        mipLevel: 0,
        aspect: "all"
      };
      assert(!!(src.usage & GPUTextureUsage$1.COPY_SRC));
      assert(!!(dst.usage & GPUTextureUsage$1.COPY_DST));
      cmd.copyTextureToTexture(srcCopy, dstCopy, [
        src.width,
        src.height,
        depthOrArrayLayers || 1
      ]);
      this.device.queue.submit([cmd.finish()]);
    };
    Device_WebGPU2.prototype.queryLimits = function() {
      return {
        uniformBufferMaxPageWordSize: this.device.limits.maxUniformBufferBindingSize >>> 2,
        uniformBufferWordAlignment: this.device.limits.minUniformBufferOffsetAlignment >>> 2,
        supportedSampleCounts: [1],
        occlusionQueriesRecommended: true,
        computeShadersSupported: true
      };
    };
    Device_WebGPU2.prototype.queryTextureFormatSupported = function(format2, width, height) {
      if (isFormatTextureCompressionBC(format2)) {
        if (!this.featureTextureCompressionBC)
          return false;
        var bb2 = getFormatBlockSize(format2);
        if (width % bb2 !== 0 || height % bb2 !== 0)
          return false;
        return this.featureTextureCompressionBC;
      }
      switch (format2) {
        case Format.U16_RGBA_NORM:
          return false;
        case Format.F32_RGBA:
          return false;
      }
      return true;
    };
    Device_WebGPU2.prototype.queryPlatformAvailable = function() {
      return true;
    };
    Device_WebGPU2.prototype.queryVendorInfo = function() {
      return this;
    };
    Device_WebGPU2.prototype.queryRenderPass = function(o) {
      var pass = o;
      return pass.descriptor;
    };
    Device_WebGPU2.prototype.queryRenderTarget = function(o) {
      var attachment = o;
      return attachment;
    };
    Device_WebGPU2.prototype.setResourceName = function(o, s) {
      o.name = s;
      if (o.type === ResourceType.Buffer) {
        var r = o;
        r.gpuBuffer.label = s;
      } else if (o.type === ResourceType.Texture) {
        var r = o;
        r.gpuTexture.label = s;
        r.gpuTextureView.label = s;
      } else if (o.type === ResourceType.RenderTarget) {
        var r = o;
        r.gpuTexture.label = s;
        r.gpuTextureView.label = s;
      } else if (o.type === ResourceType.Sampler) {
        var r = o;
        r.gpuSampler.label = s;
      } else if (o.type === ResourceType.RenderPipeline) {
        var r = o;
        if (r.gpuRenderPipeline !== null)
          r.gpuRenderPipeline.label = s;
      }
    };
    Device_WebGPU2.prototype.setResourceLeakCheck = function(o, v2) {
    };
    Device_WebGPU2.prototype.checkForLeaks = function() {
    };
    Device_WebGPU2.prototype.programPatched = function(o) {
    };
    Device_WebGPU2.prototype.pipelineQueryReady = function(o) {
      var renderPipeline = o;
      return renderPipeline.gpuRenderPipeline !== null;
    };
    Device_WebGPU2.prototype.pipelineForceReady = function(o) {
      var renderPipeline = o;
      this.createRenderPipelineInternal(renderPipeline, false);
    };
    return Device_WebGPU2;
  }()
);
var WebGPUDeviceContribution = (
  /** @class */
  function() {
    function WebGPUDeviceContribution2(pluginOptions) {
      this.pluginOptions = pluginOptions;
    }
    WebGPUDeviceContribution2.prototype.createSwapChain = function($canvas) {
      return __awaiter(this, void 0, void 0, function() {
        var adapter, xrCompatible, e_1, optionalFeatures, requiredFeatures, device, onContextLost_1, context;
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (globalThis.navigator.gpu === void 0)
                return [2, null];
              adapter = null;
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 3, , 4]);
              xrCompatible = this.pluginOptions.xrCompatible;
              return [4, globalThis.navigator.gpu.requestAdapter({
                xrCompatible
              })];
            case 2:
              adapter = _a2.sent();
              return [3, 4];
            case 3:
              e_1 = _a2.sent();
              console.log(e_1);
              return [3, 4];
            case 4:
              if (adapter === null)
                return [2, null];
              optionalFeatures = [
                // 'depth24unorm-stencil8',
                "depth32float-stencil8",
                "texture-compression-bc",
                "float32-filterable"
              ];
              requiredFeatures = optionalFeatures.filter(function(feature) {
                return adapter.features.has(feature);
              });
              return [4, adapter.requestDevice({ requiredFeatures })];
            case 5:
              device = _a2.sent();
              if (device) {
                onContextLost_1 = this.pluginOptions.onContextLost;
                device.lost.then(function() {
                  if (onContextLost_1) {
                    onContextLost_1();
                  }
                });
              }
              if (device === null)
                return [2, null];
              context = $canvas.getContext("webgpu");
              if (!context)
                return [2, null];
              _a2.label = 6;
            case 6:
              _a2.trys.push([6, 8, , 9]);
              return [4, __wbg_init(this.pluginOptions.shaderCompilerPath)];
            case 7:
              _a2.sent();
              return [3, 9];
            case 8:
              _a2.sent();
              return [3, 9];
            case 9:
              return [2, new Device_WebGPU(adapter, device, $canvas, context, glsl_compile, WGSLComposer && new WGSLComposer())];
          }
        });
      });
    };
    return WebGPUDeviceContribution2;
  }()
);

// node_modules/@antv/l7-renderer/es/device/DeviceAttribute.js
var DeviceAttribute = class {
  constructor(device, options) {
    const { buffer, offset, stride, normalized, size: size2, divisor, shaderLocation } = options;
    this.buffer = buffer;
    this.attribute = {
      shaderLocation,
      buffer: buffer.get(),
      offset: offset || 0,
      stride: stride || 0,
      normalized: normalized || false,
      divisor: divisor || 0
    };
    if (size2) {
      this.attribute.size = size2;
    }
  }
  get() {
    return this.buffer;
  }
  updateBuffer(options) {
    this.buffer.subData(options);
  }
  destroy() {
    this.buffer.destroy();
  }
};

// node_modules/@antv/l7-renderer/es/device/constants.js
var typedArrayCtorMap = {
  [gl.FLOAT]: Float32Array,
  [gl.UNSIGNED_BYTE]: Uint8Array,
  [gl.SHORT]: Int16Array,
  [gl.UNSIGNED_SHORT]: Uint16Array,
  [gl.INT]: Int32Array,
  [gl.UNSIGNED_INT]: Uint32Array
};
var primitiveMap = {
  [gl.POINTS]: PrimitiveTopology.POINTS,
  [gl.LINES]: PrimitiveTopology.LINES,
  [gl.LINE_LOOP]: PrimitiveTopology.LINES,
  [gl.LINE_STRIP]: PrimitiveTopology.LINE_STRIP,
  [gl.TRIANGLES]: PrimitiveTopology.TRIANGLES,
  [gl.TRIANGLE_FAN]: PrimitiveTopology.TRIANGLES,
  [gl.TRIANGLE_STRIP]: PrimitiveTopology.TRIANGLE_STRIP
};
var sizeFormatMap = {
  [1]: Format.F32_R,
  [2]: Format.F32_RG,
  [3]: Format.F32_RGB,
  [4]: Format.F32_RGBA
};
var hintMap = {
  [gl.STATIC_DRAW]: BufferFrequencyHint.STATIC,
  [gl.DYNAMIC_DRAW]: BufferFrequencyHint.DYNAMIC,
  [gl.STREAM_DRAW]: BufferFrequencyHint.DYNAMIC
};
var wrapModeMap = {
  [gl.REPEAT]: AddressMode.REPEAT,
  [gl.CLAMP_TO_EDGE]: AddressMode.CLAMP_TO_EDGE,
  [gl.MIRRORED_REPEAT]: AddressMode.MIRRORED_REPEAT
};
var depthFuncMap = {
  [gl.NEVER]: CompareFunction.NEVER,
  [gl.ALWAYS]: CompareFunction.ALWAYS,
  [gl.LESS]: CompareFunction.LESS,
  [gl.LEQUAL]: CompareFunction.LEQUAL,
  [gl.GREATER]: CompareFunction.GREATER,
  [gl.GEQUAL]: CompareFunction.GEQUAL,
  [gl.EQUAL]: CompareFunction.EQUAL,
  [gl.NOTEQUAL]: CompareFunction.NOTEQUAL
};
var cullFaceMap = {
  [gl.FRONT]: CullMode.FRONT,
  [gl.BACK]: CullMode.BACK
};
var blendEquationMap = {
  [gl.FUNC_ADD]: BlendMode.ADD,
  [gl.MIN_EXT]: BlendMode.MIN,
  [gl.MAX_EXT]: BlendMode.MAX,
  [gl.FUNC_SUBTRACT]: BlendMode.SUBSTRACT,
  [gl.FUNC_REVERSE_SUBTRACT]: BlendMode.REVERSE_SUBSTRACT
};
var blendFuncMap = {
  [gl.ZERO]: BlendFactor.ZERO,
  [gl.ONE]: BlendFactor.ONE,
  [gl.SRC_COLOR]: BlendFactor.SRC,
  [gl.ONE_MINUS_SRC_COLOR]: BlendFactor.ONE_MINUS_SRC,
  [gl.SRC_ALPHA]: BlendFactor.SRC_ALPHA,
  [gl.ONE_MINUS_SRC_ALPHA]: BlendFactor.ONE_MINUS_SRC_ALPHA,
  [gl.DST_COLOR]: BlendFactor.DST,
  [gl.ONE_MINUS_DST_COLOR]: BlendFactor.ONE_MINUS_DST,
  [gl.DST_ALPHA]: BlendFactor.DST_ALPHA,
  [gl.ONE_MINUS_DST_ALPHA]: BlendFactor.ONE_MINUS_DST_ALPHA,
  [gl.CONSTANT_COLOR]: BlendFactor.CONST,
  [gl.ONE_MINUS_CONSTANT_COLOR]: BlendFactor.ONE_MINUS_CONSTANT,
  [gl.CONSTANT_ALPHA]: BlendFactor.CONST,
  [gl.ONE_MINUS_CONSTANT_ALPHA]: BlendFactor.ONE_MINUS_CONSTANT,
  [gl.SRC_ALPHA_SATURATE]: BlendFactor.SRC_ALPHA_SATURATE
};
var stencilOpMap = {
  [gl.REPLACE]: StencilOp.REPLACE,
  [gl.KEEP]: StencilOp.KEEP,
  [gl.ZERO]: StencilOp.ZERO,
  [gl.INVERT]: StencilOp.INVERT,
  [gl.INCR]: StencilOp.INCREMENT_CLAMP,
  [gl.DECR]: StencilOp.DECREMENT_CLAMP,
  [gl.INCR_WRAP]: StencilOp.INCREMENT_WRAP,
  [gl.DECR_WRAP]: StencilOp.DECREMENT_WRAP
};
var stencilFuncMap = {
  [gl.ALWAYS]: CompareFunction.ALWAYS,
  [gl.EQUAL]: CompareFunction.EQUAL,
  [gl.GEQUAL]: CompareFunction.GEQUAL,
  [gl.GREATER]: CompareFunction.GREATER,
  [gl.LEQUAL]: CompareFunction.LEQUAL,
  [gl.LESS]: CompareFunction.LESS,
  [gl.NEVER]: CompareFunction.NEVER,
  [gl.NOTEQUAL]: CompareFunction.NOTEQUAL
};

// node_modules/@antv/l7-renderer/es/device/utils/typedarray.js
var dtypes2 = {
  "[object Int8Array]": 5120,
  "[object Int16Array]": 5122,
  "[object Int32Array]": 5124,
  "[object Uint8Array]": 5121,
  "[object Uint8ClampedArray]": 5121,
  "[object Uint16Array]": 5123,
  "[object Uint32Array]": 5125,
  "[object Float32Array]": 5126,
  "[object Float64Array]": 5121,
  "[object ArrayBuffer]": 5121
};
function isTypedArray2(x) {
  return Object.prototype.toString.call(x) in dtypes2;
}
function extend3ChannelsTo4(array4, valueToInsert) {
  const originalLength = array4.length;
  const insertCount = Math.ceil(originalLength / 3);
  const newLength = originalLength + insertCount;
  const newArray = new Float32Array(newLength);
  for (let i = 0; i < newLength; i += 4) {
    newArray[i] = array4[i / 4 * 3];
    newArray[i + 1] = array4[i / 4 * 3 + 1];
    newArray[i + 2] = array4[i / 4 * 3 + 2];
    newArray[i + 3] = valueToInsert;
  }
  return newArray;
}

// node_modules/@antv/l7-renderer/es/device/DeviceBuffer.js
var DeviceBuffer = class {
  constructor(device, options) {
    this.isDestroyed = false;
    const { data, usage, type, isUBO, label } = options;
    let typed;
    if (isTypedArray2(data)) {
      typed = data;
    } else {
      typed = new typedArrayCtorMap[this.type || gl.FLOAT](data);
    }
    this.type = type;
    this.size = typed.byteLength;
    this.buffer = device.createBuffer({
      viewOrSize: typed,
      usage: isUBO ? BufferUsage.UNIFORM : BufferUsage.VERTEX,
      hint: hintMap[usage || gl.STATIC_DRAW]
    });
    if (label) {
      device.setResourceName(this.buffer, label);
    }
  }
  get() {
    return this.buffer;
  }
  destroy() {
    if (!this.isDestroyed) {
      this.buffer.destroy();
    }
    this.isDestroyed = true;
  }
  subData({
    data,
    offset
  }) {
    let typed;
    if (isTypedArray2(data)) {
      typed = data;
    } else {
      typed = new typedArrayCtorMap[this.type || gl.FLOAT](data);
    }
    this.buffer.setSubData(offset, new Uint8Array(typed.buffer));
  }
};

// node_modules/@antv/l7-renderer/es/device/utils/HashMap.js
function hashCodeNumberUpdate(hash, v2 = 0) {
  hash += v2;
  hash += hash << 10;
  hash += hash >>> 6;
  return hash >>> 0;
}
function hashCodeNumberFinish(hash) {
  hash += hash << 3;
  hash ^= hash >>> 11;
  hash += hash << 15;
  return hash >>> 0;
}
function nullHashFunc() {
  return 0;
}
var HashBucket = class {
  constructor() {
    this.keys = [];
    this.values = [];
  }
};
var HashMap = class {
  constructor(keyEqualFunc, keyHashFunc) {
    this.keyEqualFunc = keyEqualFunc;
    this.keyHashFunc = keyHashFunc;
    this.buckets = /* @__PURE__ */ new Map();
  }
  findBucketIndex(bucket, k) {
    for (let i = 0; i < bucket.keys.length; i++)
      if (this.keyEqualFunc(k, bucket.keys[i]))
        return i;
    return -1;
  }
  findBucket(k) {
    const bw = this.keyHashFunc(k);
    return this.buckets.get(bw);
  }
  get(k) {
    const bucket = this.findBucket(k);
    if (bucket === void 0)
      return null;
    const bi = this.findBucketIndex(bucket, k);
    if (bi < 0)
      return null;
    return bucket.values[bi];
  }
  add(k, v2) {
    const bw = this.keyHashFunc(k);
    if (this.buckets.get(bw) === void 0)
      this.buckets.set(bw, new HashBucket());
    const bucket = this.buckets.get(bw);
    bucket.keys.push(k);
    bucket.values.push(v2);
  }
  delete(k) {
    const bucket = this.findBucket(k);
    if (bucket === void 0)
      return;
    const bi = this.findBucketIndex(bucket, k);
    if (bi === -1)
      return;
    bucket.keys.splice(bi, 1);
    bucket.values.splice(bi, 1);
  }
  clear() {
    this.buckets.clear();
  }
  size() {
    let acc = 0;
    for (const bucket of this.buckets.values())
      acc += bucket.values.length;
    return acc;
  }
  *values() {
    for (const bucket of this.buckets.values())
      for (let j = bucket.values.length - 1; j >= 0; j--)
        yield bucket.values[j];
  }
};

// node_modules/@antv/l7-renderer/es/device/DeviceCache.js
function blendStateHash(hash, a) {
  hash = hashCodeNumberUpdate(hash, a.blendMode);
  hash = hashCodeNumberUpdate(hash, a.blendSrcFactor);
  hash = hashCodeNumberUpdate(hash, a.blendDstFactor);
  return hash;
}
function attachmentStateHash(hash, a) {
  hash = blendStateHash(hash, a.rgbBlendState);
  hash = blendStateHash(hash, a.alphaBlendState);
  hash = hashCodeNumberUpdate(hash, a.channelWriteMask);
  return hash;
}
function colorHash(hash, a) {
  hash = hashCodeNumberUpdate(hash, a.r << 24 | a.g << 16 | a.b << 8 | a.a);
  return hash;
}
function megaStateDescriptorHash(hash, a) {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  for (let i = 0; i < a.attachmentsState.length; i++)
    hash = attachmentStateHash(hash, a.attachmentsState[i]);
  hash = colorHash(hash, a.blendConstant || TransparentBlack);
  hash = hashCodeNumberUpdate(hash, a.depthCompare);
  hash = hashCodeNumberUpdate(hash, a.depthWrite ? 1 : 0);
  hash = hashCodeNumberUpdate(hash, (_a2 = a.stencilFront) == null ? void 0 : _a2.compare);
  hash = hashCodeNumberUpdate(hash, (_b = a.stencilFront) == null ? void 0 : _b.passOp);
  hash = hashCodeNumberUpdate(hash, (_c = a.stencilFront) == null ? void 0 : _c.failOp);
  hash = hashCodeNumberUpdate(hash, (_d = a.stencilFront) == null ? void 0 : _d.depthFailOp);
  hash = hashCodeNumberUpdate(hash, (_e = a.stencilBack) == null ? void 0 : _e.compare);
  hash = hashCodeNumberUpdate(hash, (_f = a.stencilBack) == null ? void 0 : _f.passOp);
  hash = hashCodeNumberUpdate(hash, (_g = a.stencilBack) == null ? void 0 : _g.failOp);
  hash = hashCodeNumberUpdate(hash, (_h = a.stencilBack) == null ? void 0 : _h.depthFailOp);
  hash = hashCodeNumberUpdate(hash, a.stencilWrite ? 1 : 0);
  hash = hashCodeNumberUpdate(hash, a.cullMode);
  hash = hashCodeNumberUpdate(hash, a.frontFace ? 1 : 0);
  hash = hashCodeNumberUpdate(hash, a.polygonOffset ? 1 : 0);
  return hash;
}
function renderPipelineDescriptorHash(a) {
  let hash = 0;
  hash = hashCodeNumberUpdate(hash, a.program.id);
  if (a.inputLayout !== null)
    hash = hashCodeNumberUpdate(hash, a.inputLayout.id);
  hash = megaStateDescriptorHash(hash, a.megaStateDescriptor);
  for (let i = 0; i < a.colorAttachmentFormats.length; i++)
    hash = hashCodeNumberUpdate(hash, a.colorAttachmentFormats[i] || 0);
  hash = hashCodeNumberUpdate(hash, a.depthStencilAttachmentFormat || 0);
  return hashCodeNumberFinish(hash);
}
function bindingsDescriptorHash(a) {
  let hash = 0;
  if (a.samplerBindings) {
    for (let i = 0; i < a.samplerBindings.length; i++) {
      const binding = a.samplerBindings[i];
      if (binding !== null && binding.texture !== null)
        hash = hashCodeNumberUpdate(hash, binding.texture.id);
    }
  }
  if (a.uniformBufferBindings) {
    for (let i = 0; i < a.uniformBufferBindings.length; i++) {
      const binding = a.uniformBufferBindings[i];
      if (binding !== null && binding.buffer !== null) {
        hash = hashCodeNumberUpdate(hash, binding.buffer.id);
        hash = hashCodeNumberUpdate(hash, binding.binding);
        hash = hashCodeNumberUpdate(hash, binding.offset);
        hash = hashCodeNumberUpdate(hash, binding.size);
      }
    }
  }
  if (a.storageBufferBindings) {
    for (let i = 0; i < a.storageBufferBindings.length; i++) {
      const binding = a.storageBufferBindings[i];
      if (binding !== null && binding.buffer !== null) {
        hash = hashCodeNumberUpdate(hash, binding.buffer.id);
        hash = hashCodeNumberUpdate(hash, binding.binding);
        hash = hashCodeNumberUpdate(hash, binding.offset);
        hash = hashCodeNumberUpdate(hash, binding.size);
      }
    }
  }
  if (a.storageTextureBindings) {
    for (let i = 0; i < a.storageTextureBindings.length; i++) {
      const binding = a.storageTextureBindings[i];
      if (binding !== null && binding.texture !== null) {
        hash = hashCodeNumberUpdate(hash, binding.texture.id);
        hash = hashCodeNumberUpdate(hash, binding.binding);
      }
    }
  }
  return hashCodeNumberFinish(hash);
}
function programDescriptorEquals(a, b) {
  var _a2, _b, _c, _d;
  return ((_a2 = a.vertex) == null ? void 0 : _a2.glsl) === ((_b = b.vertex) == null ? void 0 : _b.glsl) && ((_c = a.fragment) == null ? void 0 : _c.glsl) === ((_d = b.fragment) == null ? void 0 : _d.glsl);
}
function programDescriptorCopy(a) {
  var _a2, _b;
  return {
    vertex: {
      glsl: (_a2 = a.vertex) == null ? void 0 : _a2.glsl
    },
    fragment: {
      glsl: (_b = a.fragment) == null ? void 0 : _b.glsl
    }
  };
}
var RenderCache = class {
  constructor(device) {
    this.device = device;
    this.bindingsCache = new HashMap(
      bindingsDescriptorEquals,
      bindingsDescriptorHash
    );
    this.renderPipelinesCache = new HashMap(
      renderPipelineDescriptorEquals,
      renderPipelineDescriptorHash
    );
    this.inputLayoutsCache = new HashMap(
      inputLayoutDescriptorEquals,
      nullHashFunc
    );
    this.programCache = new HashMap(
      programDescriptorEquals,
      nullHashFunc
    );
  }
  createBindings(descriptor) {
    var _a2;
    let bindings = this.bindingsCache.get(descriptor);
    if (bindings === null) {
      const descriptorCopy = bindingsDescriptorCopy(descriptor);
      descriptorCopy.uniformBufferBindings = (_a2 = descriptorCopy.uniformBufferBindings) == null ? void 0 : _a2.filter(
        ({ size: size2 }) => size2 && size2 > 0
      );
      bindings = this.device.createBindings(descriptorCopy);
      this.bindingsCache.add(descriptorCopy, bindings);
    }
    return bindings;
  }
  createRenderPipeline(descriptor) {
    let renderPipeline = this.renderPipelinesCache.get(descriptor);
    if (renderPipeline === null) {
      const descriptorCopy = renderPipelineDescriptorCopy(descriptor);
      descriptorCopy.colorAttachmentFormats = descriptorCopy.colorAttachmentFormats.filter(
        (f) => f
      );
      renderPipeline = this.device.createRenderPipeline(descriptorCopy);
      this.renderPipelinesCache.add(descriptorCopy, renderPipeline);
    }
    return renderPipeline;
  }
  createInputLayout(descriptor) {
    descriptor.vertexBufferDescriptors = descriptor.vertexBufferDescriptors.filter((d) => !!d);
    let inputLayout = this.inputLayoutsCache.get(descriptor);
    if (inputLayout === null) {
      const descriptorCopy = inputLayoutDescriptorCopy(descriptor);
      inputLayout = this.device.createInputLayout(descriptorCopy);
      this.inputLayoutsCache.add(descriptorCopy, inputLayout);
    }
    return inputLayout;
  }
  createProgram(descriptor) {
    let program = this.programCache.get(descriptor);
    if (program === null) {
      const descriptorCopy = programDescriptorCopy(descriptor);
      program = this.device.createProgram(descriptor);
      this.programCache.add(descriptorCopy, program);
    }
    return program;
  }
  destroy() {
    for (const bindings of this.bindingsCache.values())
      bindings.destroy();
    for (const renderPipeline of this.renderPipelinesCache.values())
      renderPipeline.destroy();
    for (const inputLayout of this.inputLayoutsCache.values())
      inputLayout.destroy();
    for (const program of this.programCache.values())
      program.destroy();
    this.bindingsCache.clear();
    this.renderPipelinesCache.clear();
    this.inputLayoutsCache.clear();
    this.programCache.clear();
  }
};

// node_modules/@antv/l7-renderer/es/device/DeviceElements.js
var DeviceElements = class {
  constructor(device, options) {
    const { data, type, count: count2 = 0 } = options;
    let typed;
    if (isTypedArray2(data)) {
      typed = data;
    } else {
      typed = new typedArrayCtorMap[this.type || gl.UNSIGNED_INT](data);
    }
    this.type = type;
    this.count = count2;
    this.indexBuffer = device.createBuffer({
      viewOrSize: typed,
      usage: BufferUsage.INDEX
    });
  }
  get() {
    return this.indexBuffer;
  }
  subData({
    data
  }) {
    let typed;
    if (isTypedArray2(data)) {
      typed = data;
    } else {
      typed = new typedArrayCtorMap[this.type || gl.UNSIGNED_INT](data);
    }
    this.indexBuffer.setSubData(0, new Uint8Array(typed.buffer));
  }
  destroy() {
    this.indexBuffer.destroy();
  }
};

// node_modules/@antv/l7-renderer/es/device/DeviceTexture2D.js
function isTexture2D(t) {
  return !!(t && t["texture"]);
}
var DeviceTexture2D = class {
  constructor(device, options) {
    this.device = device;
    this.options = options;
    this.isDestroy = false;
    const {
      wrapS = gl.CLAMP_TO_EDGE,
      wrapT = gl.CLAMP_TO_EDGE,
      aniso,
      mag = gl.NEAREST,
      min: min3 = gl.NEAREST
    } = options;
    this.createTexture(options);
    this.sampler = device.createSampler({
      addressModeU: wrapModeMap[wrapS],
      addressModeV: wrapModeMap[wrapT],
      minFilter: min3 === gl.NEAREST ? FilterMode.POINT : FilterMode.BILINEAR,
      magFilter: mag === gl.NEAREST ? FilterMode.POINT : FilterMode.BILINEAR,
      mipmapFilter: MipmapFilterMode.NO_MIP,
      // lodMinClamp: 0,
      // lodMaxClamp: 0,
      maxAnisotropy: aniso
    });
  }
  createTexture(options) {
    const {
      type = gl.UNSIGNED_BYTE,
      width,
      height,
      flipY = false,
      format: format2 = gl.RGBA,
      alignment = 1,
      usage = TextureUsage.SAMPLED,
      // premultiplyAlpha = false,
      unorm = false,
      // colorSpace = gl.BROWSER_DEFAULT_WEBGL,
      // x = 0,
      // y = 0,
      // copy = false,
      label
    } = options;
    let { data } = options;
    this.width = width;
    this.height = height;
    let pixelFormat = Format.U8_RGBA_RT;
    if (type === gl.UNSIGNED_BYTE && format2 === gl.RGBA) {
      pixelFormat = unorm ? Format.U8_RGBA_NORM : Format.U8_RGBA_RT;
    } else if (type === gl.UNSIGNED_BYTE && format2 === gl.LUMINANCE) {
      pixelFormat = Format.U8_LUMINANCE;
    } else if (type === gl.FLOAT && format2 === gl.LUMINANCE) {
      pixelFormat = Format.F32_LUMINANCE;
    } else if (type === gl.FLOAT && format2 === gl.RGB) {
      if (this.device.queryVendorInfo().platformString === "WebGPU") {
        if (data) {
          data = extend3ChannelsTo4(data, 0);
        }
        pixelFormat = Format.F32_RGBA;
      } else {
        pixelFormat = Format.F32_RGB;
      }
    } else if (type === gl.FLOAT && format2 === gl.RGBA) {
      pixelFormat = Format.F32_RGBA;
    } else if (type === gl.FLOAT && format2 === gl.RED) {
      pixelFormat = Format.F32_R;
    } else {
      throw new Error(`create texture error, type: ${type}, format: ${format2}`);
    }
    this.texture = this.device.createTexture({
      format: pixelFormat,
      width,
      height,
      usage: usage === TextureUsage.SAMPLED ? TextureUsage2.SAMPLED : TextureUsage2.RENDER_TARGET,
      pixelStore: {
        unpackFlipY: flipY,
        packAlignment: alignment
      },
      // mipLevelCount: usage === TextureUsage.RENDER_TARGET ? 1 : mipmap ? 1 : 0,
      mipLevelCount: 1
    });
    if (label) {
      this.device.setResourceName(this.texture, label);
    }
    if (data) {
      this.texture.setImageData([data]);
    }
  }
  get() {
    return this.texture;
  }
  update(props) {
    const { data } = props;
    this.texture.setImageData([data]);
  }
  bind() {
  }
  resize({ width, height }) {
    if (this.width !== width || this.height !== height) {
      this.destroy();
    }
    this.options.width = width;
    this.options.height = height;
    this.createTexture(this.options);
    this.isDestroy = false;
  }
  getSize() {
    return [this.width, this.height];
  }
  destroy() {
    var _a2;
    if (!this.isDestroy && !this.texture.destroyed) {
      (_a2 = this.texture) == null ? void 0 : _a2.destroy();
    }
    this.isDestroy = true;
  }
};

// node_modules/@antv/l7-renderer/es/device/DeviceFramebuffer.js
var DeviceFramebuffer = class {
  constructor(device, options) {
    this.device = device;
    this.options = options;
    this.createColorRenderTarget();
    this.createDepthRenderTarget();
  }
  createColorRenderTarget(resize = false) {
    const { width, height, color: color2 } = this.options;
    if (color2) {
      if (isTexture2D(color2)) {
        if (resize) {
          color2.resize({ width, height });
        }
        this.colorTexture = color2.get();
        this.colorRenderTarget = this.device.createRenderTargetFromTexture(this.colorTexture);
        this.width = color2["width"];
        this.height = color2["height"];
      } else if (width && height) {
        this.colorTexture = this.device.createTexture({
          format: Format.U8_RGBA_RT,
          usage: TextureUsage2.RENDER_TARGET,
          width,
          height
        });
        this.colorRenderTarget = this.device.createRenderTargetFromTexture(this.colorTexture);
        this.width = width;
        this.height = height;
      }
    }
  }
  createDepthRenderTarget(resize = false) {
    const { width, height, depth } = this.options;
    if (depth) {
      if (isTexture2D(depth)) {
        if (resize) {
          depth.resize({ width, height });
        }
        this.depthTexture = depth.get();
        this.depthRenderTarget = this.device.createRenderTargetFromTexture(this.depthTexture);
        this.width = depth["width"];
        this.height = depth["height"];
      } else if (width && height) {
        this.depthTexture = this.device.createTexture({
          format: Format.D24_S8,
          usage: TextureUsage2.RENDER_TARGET,
          width,
          height
        });
        this.depthRenderTarget = this.device.createRenderTargetFromTexture(this.depthTexture);
        this.width = width;
        this.height = height;
      }
    }
  }
  get() {
    return this.colorRenderTarget;
  }
  destroy() {
    var _a2, _b;
    (_a2 = this.colorRenderTarget) == null ? void 0 : _a2.destroy();
    (_b = this.depthRenderTarget) == null ? void 0 : _b.destroy();
  }
  resize({ width, height }) {
    if (this.width !== width || this.height !== height) {
      this.destroy();
      this.colorTexture.destroyed = true;
      this.depthTexture.destroyed = true;
      this.options.width = width;
      this.options.height = height;
      this.createColorRenderTarget(true);
      this.createDepthRenderTarget(true);
    }
  }
};

// node_modules/@antv/l7-renderer/es/device/DeviceModel.js
var __defProp20 = Object.defineProperty;
var __defProps17 = Object.defineProperties;
var __getOwnPropDescs17 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols20 = Object.getOwnPropertySymbols;
var __hasOwnProp20 = Object.prototype.hasOwnProperty;
var __propIsEnum20 = Object.prototype.propertyIsEnumerable;
var __defNormalProp20 = (obj, key, value) => key in obj ? __defProp20(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues20 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp20.call(b, prop))
      __defNormalProp20(a, prop, b[prop]);
  if (__getOwnPropSymbols20)
    for (var prop of __getOwnPropSymbols20(b)) {
      if (__propIsEnum20.call(b, prop))
        __defNormalProp20(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps17 = (a, b) => __defProps17(a, __getOwnPropDescs17(b));
var { isPlainObject: isPlainObject2, isTypedArray: isTypedArray3, isNil: isNil3 } = lodashUtil;
var DeviceModel = class {
  constructor(device, options, service) {
    this.device = device;
    this.options = options;
    this.service = service;
    this.destroyed = false;
    this.uniforms = {};
    this.vertexBuffers = [];
    const { vs, fs, attributes, uniforms, count: count2, elements, diagnosticDerivativeUniformityEnabled } = options;
    this.options = options;
    const diagnosticDerivativeUniformityHeader = diagnosticDerivativeUniformityEnabled ? "" : this.service["viewportOrigin"] === ViewportOrigin.UPPER_LEFT ? "diagnostic(off,derivative_uniformity);" : "";
    this.program = service.renderCache.createProgram({
      vertex: {
        glsl: vs
      },
      fragment: {
        glsl: fs,
        postprocess: (fs2) => diagnosticDerivativeUniformityHeader + fs2
      }
    });
    if (uniforms) {
      this.uniforms = this.extractUniforms(uniforms);
    }
    const vertexBufferDescriptors = [];
    let inferredCount = 0;
    Object.keys(attributes).forEach((name) => {
      const attribute = attributes[name];
      const buffer = attribute.get();
      this.vertexBuffers.push(buffer.get());
      const {
        offset = 0,
        stride = 0,
        // TODO: normalized
        size: size2 = 1,
        divisor = 0,
        shaderLocation = 0
      } = attribute["attribute"];
      vertexBufferDescriptors.push({
        arrayStride: stride || size2 * 4,
        // TODO: L7 hasn't use instanced array for now.
        stepMode: VertexStepMode.VERTEX,
        attributes: [
          {
            format: sizeFormatMap[size2],
            shaderLocation,
            offset,
            divisor
          }
        ]
      });
      inferredCount = buffer["size"] / size2;
    });
    if (!count2) {
      this.options.count = inferredCount;
    }
    if (elements) {
      this.indexBuffer = elements.get();
    }
    const inputLayout = service.renderCache.createInputLayout({
      vertexBufferDescriptors,
      indexBufferFormat: elements ? Format.U32_R : null,
      program: this.program
    });
    this.inputLayout = inputLayout;
    this.pipeline = this.createPipeline(options);
  }
  createPipeline(options, pick) {
    var _a2;
    const { primitive = gl.TRIANGLES, depth, cull, blend, stencil } = options;
    const depthParams = this.initDepthDrawParams({ depth });
    const depthEnabled = !!(depthParams && depthParams.enable);
    const cullParams = this.initCullDrawParams({ cull });
    const cullEnabled = !!(cullParams && cullParams.enable);
    const blendParams = this.getBlendDrawParams({ blend });
    const blendEnabled = !!(blendParams && blendParams.enable);
    const stencilParams = this.getStencilDrawParams({ stencil });
    const stencilEnabled = !!(stencilParams && stencilParams.enable);
    const pipeline = this.device.createRenderPipeline({
      inputLayout: this.inputLayout,
      program: this.program,
      topology: primitiveMap[primitive],
      colorAttachmentFormats: [Format.U8_RGBA_RT],
      depthStencilAttachmentFormat: Format.D24_S8,
      megaStateDescriptor: {
        attachmentsState: [
          pick ? {
            channelWriteMask: ChannelWriteMask.ALL,
            rgbBlendState: {
              blendMode: BlendMode.ADD,
              blendSrcFactor: BlendFactor.ONE,
              blendDstFactor: BlendFactor.ZERO
            },
            alphaBlendState: {
              blendMode: BlendMode.ADD,
              blendSrcFactor: BlendFactor.ONE,
              blendDstFactor: BlendFactor.ZERO
            }
          } : {
            channelWriteMask: stencilEnabled && stencilParams.opFront.zpass === StencilOp.REPLACE ? ChannelWriteMask.NONE : ChannelWriteMask.ALL,
            rgbBlendState: {
              blendMode: blendEnabled && blendParams.equation.rgb || BlendMode.ADD,
              blendSrcFactor: blendEnabled && blendParams.func.srcRGB || BlendFactor.SRC_ALPHA,
              blendDstFactor: blendEnabled && blendParams.func.dstRGB || BlendFactor.ONE_MINUS_SRC_ALPHA
            },
            alphaBlendState: {
              blendMode: blendEnabled && blendParams.equation.alpha || BlendMode.ADD,
              blendSrcFactor: blendEnabled && blendParams.func.srcAlpha || BlendFactor.ONE,
              blendDstFactor: blendEnabled && blendParams.func.dstAlpha || BlendFactor.ONE
            }
          }
        ],
        blendConstant: blendEnabled ? TransparentBlack : void 0,
        depthWrite: depthEnabled,
        depthCompare: depthEnabled && depthParams.func || CompareFunction.LESS,
        cullMode: cullEnabled && cullParams.face || CullMode.NONE,
        stencilWrite: stencilEnabled,
        stencilFront: {
          compare: stencilEnabled ? stencilParams.func.cmp : CompareFunction.ALWAYS,
          passOp: stencilParams.opFront.zpass,
          failOp: stencilParams.opFront.fail,
          depthFailOp: stencilParams.opFront.zfail,
          mask: stencilParams.opFront.mask
        },
        stencilBack: {
          compare: stencilEnabled ? stencilParams.func.cmp : CompareFunction.ALWAYS,
          passOp: stencilParams.opBack.zpass,
          failOp: stencilParams.opBack.fail,
          depthFailOp: stencilParams.opBack.zfail,
          mask: stencilParams.opBack.mask
        }
      }
    });
    if (stencilEnabled && !isNil3((_a2 = stencil == null ? void 0 : stencil.func) == null ? void 0 : _a2.ref)) {
      pipeline.stencilFuncReference = stencil.func.ref;
    }
    return pipeline;
  }
  updateAttributesAndElements() {
  }
  /**
   * No need to implement this method, you should update data on `Attribute` like this:
   *
   * @example
   * ```ts
   * attribute.updateBuffer({
   *   data: [],
   *   offset: 0,
   * });
   * ```
   */
  updateAttributes() {
  }
  addUniforms(uniforms) {
    this.uniforms = __spreadValues20(__spreadValues20({}, this.uniforms), this.extractUniforms(uniforms));
  }
  draw(options, pick) {
    const mergedOptions = __spreadValues20(__spreadValues20({}, this.options), options);
    const {
      count: count2 = 0,
      instances,
      elements,
      uniforms = {},
      uniformBuffers,
      textures
    } = mergedOptions;
    this.uniforms = __spreadValues20(__spreadValues20({}, this.uniforms), this.extractUniforms(uniforms));
    const { renderPass, currentFramebuffer, width, height } = this.service;
    this.pipeline = this.createPipeline(mergedOptions, pick);
    const device = this.service["device"];
    const tmpHeight = device["swapChainHeight"];
    device["swapChainHeight"] = (currentFramebuffer == null ? void 0 : currentFramebuffer["height"]) || height;
    renderPass.setViewport(
      0,
      0,
      (currentFramebuffer == null ? void 0 : currentFramebuffer["width"]) || width,
      (currentFramebuffer == null ? void 0 : currentFramebuffer["height"]) || height
    );
    device["swapChainHeight"] = tmpHeight;
    renderPass.setPipeline(this.pipeline);
    if (!isNil3(this.pipeline.stencilFuncReference)) {
      renderPass.setStencilReference(this.pipeline.stencilFuncReference);
    }
    renderPass.setVertexInput(
      this.inputLayout,
      this.vertexBuffers.map((buffer) => ({
        buffer
      })),
      elements ? {
        buffer: this.indexBuffer,
        offset: 0
      } : null
    );
    if (uniformBuffers) {
      this.bindings = device.createBindings({
        pipeline: this.pipeline,
        uniformBufferBindings: uniformBuffers.map((uniformBuffer, i) => {
          const buffer = uniformBuffer;
          return {
            binding: i,
            buffer: buffer.get(),
            size: buffer["size"]
          };
        }),
        samplerBindings: textures == null ? void 0 : textures.map((t) => ({
          texture: t["texture"],
          sampler: t["sampler"]
        }))
      });
    }
    if (this.bindings) {
      renderPass.setBindings(this.bindings);
      Object.keys(this.uniforms).forEach((uniformName) => {
        const uniform = this.uniforms[uniformName];
        if (uniform instanceof DeviceTexture2D) {
          this.uniforms[uniformName] = uniform.get();
        } else if (uniform instanceof DeviceFramebuffer) {
          this.uniforms[uniformName] = uniform.get()["texture"];
        }
      });
      this.program.setUniformsLegacy(this.uniforms);
    }
    if (elements) {
      const indexCount = elements["count"];
      if (indexCount === 0) {
        renderPass.draw(count2, instances);
      } else {
        renderPass.drawIndexed(indexCount, instances);
      }
    } else {
      renderPass.draw(count2, instances);
    }
  }
  destroy() {
    var _a2, _b, _c;
    (_a2 = this.vertexBuffers) == null ? void 0 : _a2.forEach((buffer) => buffer.destroy());
    (_b = this.indexBuffer) == null ? void 0 : _b.destroy();
    (_c = this.bindings) == null ? void 0 : _c.destroy();
    this.pipeline.destroy();
    this.destroyed = true;
  }
  initDepthDrawParams({ depth }) {
    if (depth) {
      return {
        enable: depth.enable === void 0 ? true : !!depth.enable,
        mask: depth.mask === void 0 ? true : !!depth.mask,
        func: depthFuncMap[depth.func || gl.LESS],
        range: depth.range || [0, 1]
      };
    }
  }
  getBlendDrawParams({ blend }) {
    const { enable, func, equation, color: color2 = [0, 0, 0, 0] } = blend || {};
    return {
      enable: !!enable,
      func: {
        srcRGB: blendFuncMap[func && func.srcRGB || gl.SRC_ALPHA],
        srcAlpha: blendFuncMap[func && func.srcAlpha || gl.SRC_ALPHA],
        dstRGB: blendFuncMap[func && func.dstRGB || gl.ONE_MINUS_SRC_ALPHA],
        dstAlpha: blendFuncMap[func && func.dstAlpha || gl.ONE_MINUS_SRC_ALPHA]
      },
      equation: {
        rgb: blendEquationMap[equation && equation.rgb || gl.FUNC_ADD],
        alpha: blendEquationMap[equation && equation.alpha || gl.FUNC_ADD]
      },
      color: color2
    };
  }
  /**
   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#stencil
   */
  getStencilDrawParams({ stencil }) {
    const {
      enable,
      mask = 4294967295,
      func = {
        cmp: gl.ALWAYS,
        ref: 0,
        mask: 4294967295
      },
      opFront = {
        fail: gl.KEEP,
        zfail: gl.KEEP,
        zpass: gl.KEEP
      },
      opBack = {
        fail: gl.KEEP,
        zfail: gl.KEEP,
        zpass: gl.KEEP
      }
    } = stencil || {};
    return {
      enable: !!enable,
      mask,
      func: __spreadProps17(__spreadValues20({}, func), {
        cmp: stencilFuncMap[func.cmp]
      }),
      opFront: {
        fail: stencilOpMap[opFront.fail],
        zfail: stencilOpMap[opFront.zfail],
        zpass: stencilOpMap[opFront.zpass],
        mask: func.mask
      },
      opBack: {
        fail: stencilOpMap[opBack.fail],
        zfail: stencilOpMap[opBack.zfail],
        zpass: stencilOpMap[opBack.zpass],
        mask: func.mask
      }
    };
  }
  /**
   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#culling
   */
  initCullDrawParams({ cull }) {
    if (cull) {
      const { enable, face = gl.BACK } = cull;
      return {
        enable: !!enable,
        face: cullFaceMap[face]
      };
    }
  }
  /**
   * 考虑结构体命名, eg:
   * a: { b: 1 }  ->  'a.b'
   * a: [ { b: 1 } ] -> 'a[0].b'
   */
  extractUniforms(uniforms) {
    const extractedUniforms = {};
    Object.keys(uniforms).forEach((uniformName) => {
      this.extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, "");
    });
    return extractedUniforms;
  }
  extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix2) {
    if (uniformValue === null || typeof uniformValue === "number" || // u_A: 1
    typeof uniformValue === "boolean" || // u_A: false
    Array.isArray(uniformValue) && typeof uniformValue[0] === "number" || // u_A: [1, 2, 3]
    isTypedArray3(uniformValue) || // u_A: Float32Array
    // @ts-ignore
    uniformValue === "" || "resize" in uniformValue) {
      uniforms[`${prefix2 && prefix2 + "."}${uniformName}`] = uniformValue;
      return;
    }
    if (isPlainObject2(uniformValue)) {
      Object.keys(uniformValue).forEach((childName) => {
        this.extractUniformsRecursively(
          childName,
          // @ts-ignore
          uniformValue[childName],
          uniforms,
          `${prefix2 && prefix2 + "."}${uniformName}`
        );
      });
    }
    if (Array.isArray(uniformValue)) {
      uniformValue.forEach((child, idx) => {
        Object.keys(child).forEach((childName) => {
          this.extractUniformsRecursively(
            childName,
            // @ts-ignore
            child[childName],
            uniforms,
            `${prefix2 && prefix2 + "."}${uniformName}[${idx}]`
          );
        });
      });
    }
  }
};

// node_modules/@antv/l7-renderer/es/device/utils/webgl.js
function isWebGL22(gl2) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl2 instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl2 && gl2._version === 2);
}

// node_modules/@antv/l7-renderer/es/device/index.js
var __async10 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var { isUndefined: isUndefined2 } = lodashUtil;
var DeviceRendererService = class {
  constructor() {
    this.uniformBuffers = [];
    this.queryVerdorInfo = () => {
      return this.device.queryVendorInfo().platformString;
    };
    this.createModel = (options) => new DeviceModel(this.device, options, this);
    this.createAttribute = (options) => new DeviceAttribute(this.device, options);
    this.createBuffer = (options) => new DeviceBuffer(this.device, options);
    this.createElements = (options) => new DeviceElements(this.device, options);
    this.createTexture2D = (options) => new DeviceTexture2D(this.device, options);
    this.createFramebuffer = (options) => new DeviceFramebuffer(this.device, options);
    this.useFramebuffer = (framebuffer, drawCommands) => {
      this.currentFramebuffer = framebuffer;
      this.beginFrame();
      drawCommands();
      this.endFrame();
      this.currentFramebuffer = null;
    };
    this.useFramebufferAsync = (framebuffer, drawCommands) => __async10(this, null, function* () {
      this.currentFramebuffer = framebuffer;
      this.preRenderPass = this.renderPass;
      this.beginFrame();
      yield drawCommands();
      this.endFrame();
      this.currentFramebuffer = null;
      this.renderPass = this.preRenderPass;
    });
    this.clear = (options) => {
      const { color: color2, depth, stencil, framebuffer = null } = options;
      if (framebuffer) {
        framebuffer.clearOptions = { color: color2, depth, stencil };
      } else {
        const platformString = this.queryVerdorInfo();
        if (platformString === "WebGL1") {
          const gl2 = this.getGLContext();
          if (!isUndefined2(stencil)) {
            gl2.clearStencil(stencil);
            gl2.clear(gl2.STENCIL_BUFFER_BIT);
          } else if (!isUndefined2(depth)) {
            gl2.clearDepth(depth);
            gl2.clear(gl2.DEPTH_BUFFER_BIT);
          }
        } else if (platformString === "WebGL2") {
          const gl2 = this.getGLContext();
          if (!isUndefined2(stencil)) {
            gl2.clearBufferiv(gl2.STENCIL, 0, [stencil]);
          } else if (!isUndefined2(depth)) {
            gl2.clearBufferfv(gl2.DEPTH, 0, [depth]);
          }
        }
      }
    };
    this.viewport = ({
      // x,
      // y,
      width,
      height
    }) => {
      this.swapChain.configureSwapChain(width, height);
      this.createMainColorDepthRT(width, height);
      this.width = width;
      this.height = height;
    };
    this.readPixels = (options) => {
      const { framebuffer, x, y, width, height } = options;
      const readback = this.device.createReadback();
      const texture = framebuffer["colorTexture"];
      const result = readback.readTextureSync(
        texture,
        x,
        /**
         * Origin is at lower-left corner. Width / height is already multiplied by dpr.
         * WebGPU needs flipY
         */
        this.viewportOrigin === ViewportOrigin.LOWER_LEFT ? y : this.height - y,
        width,
        height,
        new Uint8Array(width * height * 4)
      );
      if (this.viewportOrigin !== ViewportOrigin.LOWER_LEFT) {
        for (let j = 0; j < result.length; j += 4) {
          const t = result[j];
          result[j] = result[j + 2];
          result[j + 2] = t;
        }
      }
      readback.destroy();
      return result;
    };
    this.readPixelsAsync = (options) => __async10(this, null, function* () {
      const { framebuffer, x, y, width, height } = options;
      const readback = this.device.createReadback();
      const texture = framebuffer["colorTexture"];
      const result = yield readback.readTexture(
        texture,
        x,
        /**
         * Origin is at lower-left corner. Width / height is already multiplied by dpr.
         * WebGPU needs flipY
         */
        this.viewportOrigin === ViewportOrigin.LOWER_LEFT ? y : this.height - y,
        width,
        height,
        new Uint8Array(width * height * 4)
      );
      if (this.viewportOrigin !== ViewportOrigin.LOWER_LEFT) {
        for (let j = 0; j < result.length; j += 4) {
          const t = result[j];
          result[j] = result[j + 2];
          result[j + 2] = t;
        }
      }
      readback.destroy();
      return result;
    });
    this.getViewportSize = () => {
      return {
        width: this.width,
        height: this.height
      };
    };
    this.getContainer = () => {
      var _a2;
      return (_a2 = this.canvas) == null ? void 0 : _a2.parentElement;
    };
    this.getCanvas = () => {
      return this.canvas;
    };
    this.getGLContext = () => {
      return this.device["gl"];
    };
    this.destroy = () => {
      var _a2;
      this.canvas = null;
      (_a2 = this.uniformBuffers) == null ? void 0 : _a2.forEach((buffer) => {
        buffer.destroy();
      });
      this.device.destroy();
      this.renderCache.destroy();
    };
  }
  init(canvas, cfg) {
    return __async10(this, null, function* () {
      const { enableWebGPU, shaderCompilerPath, antialias } = cfg;
      this.canvas = canvas;
      const deviceContribution = enableWebGPU ? new WebGPUDeviceContribution({
        shaderCompilerPath
      }) : new WebGLDeviceContribution({
        // Use WebGL2 first and downgrade to WebGL1 if WebGL2 is not supported.
        targets: ["webgl2", "webgl1"],
        antialias,
        onContextLost(e) {
          console.warn("context lost", e);
        },
        onContextCreationError(e) {
          console.warn("context creation error", e);
        },
        onContextRestored(e) {
          console.warn("context restored", e);
        }
      });
      const swapChain = yield deviceContribution.createSwapChain(canvas);
      swapChain.configureSwapChain(canvas.width, canvas.height);
      this.device = swapChain.getDevice();
      this.swapChain = swapChain;
      this.renderCache = new RenderCache(this.device);
      this.currentFramebuffer = null;
      this.viewportOrigin = this.device.queryVendorInfo().viewportOrigin;
      const gl2 = this.device["gl"];
      this.extensionObject = {
        // @ts-ignore
        OES_texture_float: !isWebGL22(gl2) && this.device["OES_texture_float"]
      };
      this.createMainColorDepthRT(canvas.width, canvas.height);
    });
  }
  createMainColorDepthRT(width, height) {
    if (this.mainColorRT) {
      this.mainColorRT.destroy();
    }
    if (this.mainDepthRT) {
      this.mainDepthRT.destroy();
    }
    this.mainColorRT = this.device.createRenderTargetFromTexture(
      this.device.createTexture({
        format: Format.U8_RGBA_RT,
        width,
        height,
        usage: TextureUsage2.RENDER_TARGET
      })
    );
    this.mainDepthRT = this.device.createRenderTargetFromTexture(
      this.device.createTexture({
        format: Format.D24_S8,
        width,
        height,
        usage: TextureUsage2.RENDER_TARGET
      })
    );
  }
  beginFrame() {
    this.device.beginFrame();
    const { currentFramebuffer, swapChain, mainColorRT, mainDepthRT } = this;
    const colorAttachment = currentFramebuffer ? currentFramebuffer["colorRenderTarget"] : mainColorRT;
    const colorResolveTo = currentFramebuffer ? null : swapChain.getOnscreenTexture();
    const depthStencilAttachment = currentFramebuffer ? currentFramebuffer["depthRenderTarget"] : mainDepthRT;
    const { color: color2 = [0, 0, 0, 0], depth = 1, stencil = 0 } = (
      // @ts-ignore
      (currentFramebuffer == null ? void 0 : currentFramebuffer.clearOptions) || {}
    );
    const colorClearColor = colorAttachment ? colorNewFromRGBA(color2[0] * 255, color2[1] * 255, color2[2] * 255, color2[3]) : TransparentBlack;
    const depthClearValue = depthStencilAttachment ? depth : void 0;
    const stencilClearValue = depthStencilAttachment ? stencil : void 0;
    const renderPass = this.device.createRenderPass({
      colorAttachment: [colorAttachment],
      colorResolveTo: [colorResolveTo],
      colorClearColor: [colorClearColor],
      // colorStore: [!!currentFramebuffer],
      colorStore: [true],
      depthStencilAttachment,
      depthClearValue,
      stencilClearValue
    });
    this.renderPass = renderPass;
  }
  endFrame() {
    this.device.submitPass(this.renderPass);
    this.device.endFrame();
  }
  getPointSizeRange() {
    const gl2 = this.device["gl"];
    return gl2.getParameter(gl2.ALIASED_POINT_SIZE_RANGE);
  }
  testExtension(name) {
    return !!this.getGLContext().getExtension(name);
  }
  // TODO: 临时方法
  setState() {
  }
  setBaseState() {
  }
  setCustomLayerDefaults() {
  }
  setDirty(flag) {
    this.isDirty = flag;
  }
  getDirty() {
    return this.isDirty;
  }
};

// node_modules/@antv/l7-renderer/es/regl/index.js
var import_regl = __toESM(require_regl());

// node_modules/@antv/l7-renderer/es/regl/ReglAttribute.js
var ReglAttribute = class {
  constructor(gl2, options) {
    const { buffer, offset, stride, normalized, size: size2, divisor } = options;
    this.buffer = buffer;
    this.attribute = {
      buffer: buffer.get(),
      offset: offset || 0,
      stride: stride || 0,
      normalized: normalized || false,
      divisor: divisor || 0
    };
    if (size2) {
      this.attribute.size = size2;
    }
  }
  get() {
    return this.attribute;
  }
  updateBuffer(options) {
    this.buffer.subData(options);
  }
  destroy() {
    this.buffer.destroy();
  }
};

// node_modules/@antv/l7-renderer/es/regl/constants.js
var primitiveMap2 = {
  [gl.POINTS]: "points",
  [gl.LINES]: "lines",
  [gl.LINE_LOOP]: "line loop",
  [gl.LINE_STRIP]: "line strip",
  [gl.TRIANGLES]: "triangles",
  [gl.TRIANGLE_FAN]: "triangle fan",
  [gl.TRIANGLE_STRIP]: "triangle strip"
};
var usageMap = {
  [gl.STATIC_DRAW]: "static",
  [gl.DYNAMIC_DRAW]: "dynamic",
  [gl.STREAM_DRAW]: "stream"
};
var dataTypeMap = {
  [gl.BYTE]: "int8",
  // [gl.UNSIGNED_INT]: 'int16',
  [gl.INT]: "int32",
  [gl.UNSIGNED_BYTE]: "uint8",
  [gl.UNSIGNED_SHORT]: "uint16",
  [gl.UNSIGNED_INT]: "uint32",
  [gl.FLOAT]: "float"
};
var formatMap = {
  [gl.ALPHA]: "alpha",
  [gl.LUMINANCE]: "luminance",
  [gl.LUMINANCE_ALPHA]: "luminance alpha",
  [gl.RGB]: "rgb",
  [gl.RGBA]: "rgba",
  [gl.RGBA4]: "rgba4",
  [gl.RGB5_A1]: "rgb5 a1",
  [gl.RGB565]: "rgb565",
  [gl.DEPTH_COMPONENT]: "depth",
  [gl.DEPTH_STENCIL]: "depth stencil"
};
var mipmapMap = {
  [gl.DONT_CARE]: "dont care",
  [gl.NICEST]: "nice",
  [gl.FASTEST]: "fast"
};
var filterMap = {
  [gl.NEAREST]: "nearest",
  [gl.LINEAR]: "linear",
  [gl.LINEAR_MIPMAP_LINEAR]: "mipmap",
  [gl.NEAREST_MIPMAP_LINEAR]: "nearest mipmap linear",
  [gl.LINEAR_MIPMAP_NEAREST]: "linear mipmap nearest",
  [gl.NEAREST_MIPMAP_NEAREST]: "nearest mipmap nearest"
};
var wrapModeMap2 = {
  [gl.REPEAT]: "repeat",
  [gl.CLAMP_TO_EDGE]: "clamp",
  [gl.MIRRORED_REPEAT]: "mirror"
};
var colorSpaceMap = {
  [gl.NONE]: "none",
  [gl.BROWSER_DEFAULT_WEBGL]: "browser"
};
var depthFuncMap2 = {
  [gl.NEVER]: "never",
  [gl.ALWAYS]: "always",
  [gl.LESS]: "less",
  [gl.LEQUAL]: "lequal",
  [gl.GREATER]: "greater",
  [gl.GEQUAL]: "gequal",
  [gl.EQUAL]: "equal",
  [gl.NOTEQUAL]: "notequal"
};
var blendEquationMap2 = {
  [gl.FUNC_ADD]: "add",
  [gl.MIN_EXT]: "min",
  [gl.MAX_EXT]: "max",
  [gl.FUNC_SUBTRACT]: "subtract",
  [gl.FUNC_REVERSE_SUBTRACT]: "reverse subtract"
};
var blendFuncMap2 = {
  [gl.ZERO]: "zero",
  [gl.ONE]: "one",
  [gl.SRC_COLOR]: "src color",
  [gl.ONE_MINUS_SRC_COLOR]: "one minus src color",
  [gl.SRC_ALPHA]: "src alpha",
  [gl.ONE_MINUS_SRC_ALPHA]: "one minus src alpha",
  [gl.DST_COLOR]: "dst color",
  [gl.ONE_MINUS_DST_COLOR]: "one minus dst color",
  [gl.DST_ALPHA]: "dst alpha",
  [gl.ONE_MINUS_DST_ALPHA]: "one minus dst alpha",
  [gl.CONSTANT_COLOR]: "constant color",
  [gl.ONE_MINUS_CONSTANT_COLOR]: "one minus constant color",
  [gl.CONSTANT_ALPHA]: "constant alpha",
  [gl.ONE_MINUS_CONSTANT_ALPHA]: "one minus constant alpha",
  [gl.SRC_ALPHA_SATURATE]: "src alpha saturate"
};
var stencilFuncMap2 = {
  [gl.NEVER]: "never",
  [gl.ALWAYS]: "always",
  [gl.LESS]: "less",
  [gl.LEQUAL]: "lequal",
  [gl.GREATER]: "greater",
  [gl.GEQUAL]: "gequal",
  [gl.EQUAL]: "equal",
  [gl.NOTEQUAL]: "notequal"
};
var stencilOpMap2 = {
  [gl.ZERO]: "zero",
  [gl.KEEP]: "keep",
  [gl.REPLACE]: "replace",
  [gl.INVERT]: "invert",
  [gl.INCR]: "increment",
  [gl.DECR]: "decrement",
  [gl.INCR_WRAP]: "increment wrap",
  [gl.DECR_WRAP]: "decrement wrap"
};
var cullFaceMap2 = {
  [gl.FRONT]: "front",
  [gl.BACK]: "back"
};

// node_modules/@antv/l7-renderer/es/regl/ReglBuffer.js
var ReglBuffer = class {
  constructor(reGl, options) {
    this.isDestroyed = false;
    const { data, usage, type } = options;
    this.buffer = reGl.buffer({
      data,
      usage: usageMap[usage || gl.STATIC_DRAW],
      type: dataTypeMap[type || gl.UNSIGNED_BYTE]
      // length: 0,
    });
  }
  get() {
    return this.buffer;
  }
  destroy() {
    if (!this.isDestroyed) {
      this.buffer.destroy();
    }
    this.isDestroyed = true;
  }
  subData({
    data,
    offset
  }) {
    this.buffer.subdata(data, offset);
  }
};

// node_modules/@antv/l7-renderer/es/regl/ReglElements.js
var ReglElements = class {
  constructor(reGl, options) {
    const { data, usage, type, count: count2 } = options;
    this.elements = reGl.elements({
      data,
      usage: usageMap[usage || gl.STATIC_DRAW],
      type: dataTypeMap[type || gl.UNSIGNED_BYTE],
      count: count2
    });
  }
  get() {
    return this.elements;
  }
  subData({
    data
  }) {
    this.elements.subdata(data);
  }
  destroy() {
  }
};

// node_modules/@antv/l7-renderer/es/regl/ReglFramebuffer.js
var ReglFramebuffer = class {
  constructor(reGl, options) {
    const { width, height, color: color2, colors } = options;
    const framebufferOptions = {
      width,
      height
    };
    if (Array.isArray(colors)) {
      framebufferOptions.colors = colors.map(
        (c) => c.get()
      );
    }
    if (color2 && typeof color2 !== "boolean") {
      framebufferOptions.color = color2.get();
    }
    this.framebuffer = reGl.framebuffer(framebufferOptions);
  }
  get() {
    return this.framebuffer;
  }
  destroy() {
    this.framebuffer.destroy();
  }
  resize({ width, height }) {
    this.framebuffer.resize(width, height);
  }
};

// node_modules/@antv/l7-renderer/es/regl/ReglModel.js
var __defProp21 = Object.defineProperty;
var __defProps18 = Object.defineProperties;
var __getOwnPropDescs18 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols21 = Object.getOwnPropertySymbols;
var __hasOwnProp21 = Object.prototype.hasOwnProperty;
var __propIsEnum21 = Object.prototype.propertyIsEnumerable;
var __defNormalProp21 = (obj, key, value) => key in obj ? __defProp21(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues21 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp21.call(b, prop))
      __defNormalProp21(a, prop, b[prop]);
  if (__getOwnPropSymbols21)
    for (var prop of __getOwnPropSymbols21(b)) {
      if (__propIsEnum21.call(b, prop))
        __defNormalProp21(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps18 = (a, b) => __defProps18(a, __getOwnPropDescs18(b));
var { isPlainObject: isPlainObject3, isTypedArray: isTypedArray4 } = lodashUtil;
var ReglModel = class {
  constructor(reGl, options) {
    this.destroyed = false;
    this.uniforms = {};
    this.reGl = reGl;
    const { vs, fs, attributes, uniforms, primitive, count: count2, elements, depth, cull, instances } = options;
    const vendorInfo = {
      platformString: "WebGL1",
      glslVersion: "#version 100",
      explicitBindingLocations: false,
      separateSamplerTextures: false,
      viewportOrigin: ViewportOrigin.LOWER_LEFT,
      clipSpaceNearZ: ClipSpaceNearZ.NEGATIVE_ONE,
      supportMRT: false
    };
    const reglUniforms = {};
    this.options = options;
    if (uniforms) {
      this.uniforms = this.extractUniforms(uniforms);
      Object.keys(uniforms).forEach((uniformName) => {
        reglUniforms[uniformName] = reGl.prop(uniformName);
      });
    }
    const reglAttributes = {};
    Object.keys(attributes).forEach((name) => {
      reglAttributes[name] = attributes[name].get();
    });
    const frag = removeDuplicateUniforms(
      preprocessShader_GLSL(vendorInfo, "frag", fs, null, false)
    );
    const vert = removeDuplicateUniforms(
      preprocessShader_GLSL(vendorInfo, "vert", vs, null, false)
    );
    const drawParams = {
      attributes: reglAttributes,
      frag,
      uniforms: reglUniforms,
      vert,
      // @ts-ignore
      colorMask: reGl.prop("colorMask"),
      lineWidth: 1,
      blend: {
        // @ts-ignore
        enable: reGl.prop("blend.enable"),
        // @ts-ignore
        func: reGl.prop("blend.func"),
        // @ts-ignore
        equation: reGl.prop("blend.equation"),
        // @ts-ignore
        color: reGl.prop("blend.color")
      },
      stencil: {
        // @ts-ignore
        enable: reGl.prop("stencil.enable"),
        // @ts-ignore
        mask: reGl.prop("stencil.mask"),
        // @ts-ignore
        func: reGl.prop("stencil.func"),
        // @ts-ignore
        opFront: reGl.prop("stencil.opFront"),
        // @ts-ignore
        opBack: reGl.prop("stencil.opBack")
      },
      primitive: primitiveMap2[primitive === void 0 ? gl.TRIANGLES : primitive]
    };
    if (instances) {
      drawParams.instances = instances;
    }
    if (count2) {
      drawParams.count = count2;
    } else if (elements) {
      drawParams.elements = elements.get();
    }
    this.initDepthDrawParams({ depth }, drawParams);
    this.initCullDrawParams({ cull }, drawParams);
    this.drawCommand = reGl(drawParams);
    this.drawParams = drawParams;
  }
  updateAttributesAndElements(attributes, elements) {
    const reglAttributes = {};
    Object.keys(attributes).forEach((name) => {
      reglAttributes[name] = attributes[name].get();
    });
    this.drawParams.attributes = reglAttributes;
    this.drawParams.elements = elements.get();
    this.drawCommand = this.reGl(this.drawParams);
  }
  updateAttributes(attributes) {
    const reglAttributes = {};
    Object.keys(attributes).forEach((name) => {
      reglAttributes[name] = attributes[name].get();
    });
    this.drawParams.attributes = reglAttributes;
    this.drawCommand = this.reGl(this.drawParams);
  }
  addUniforms(uniforms) {
    this.uniforms = __spreadValues21(__spreadValues21({}, this.uniforms), this.extractUniforms(uniforms));
  }
  draw(options, pick) {
    if (this.drawParams.attributes && Object.keys(this.drawParams.attributes).length === 0) {
      return;
    }
    const uniforms = __spreadValues21(__spreadValues21({}, this.uniforms), this.extractUniforms(options.uniforms || {}));
    const reglDrawProps = {};
    Object.keys(uniforms).forEach((uniformName) => {
      const type = typeof uniforms[uniformName];
      if (type === "boolean" || type === "number" || Array.isArray(uniforms[uniformName]) || // @ts-ignore
      uniforms[uniformName].BYTES_PER_ELEMENT) {
        reglDrawProps[uniformName] = uniforms[uniformName];
      } else {
        reglDrawProps[uniformName] = uniforms[uniformName].get();
      }
    });
    reglDrawProps.blend = pick ? this.getBlendDrawParams({
      blend: { enable: false }
    }) : this.getBlendDrawParams(options);
    reglDrawProps.stencil = this.getStencilDrawParams(options);
    reglDrawProps.colorMask = this.getColorMaskDrawParams(options, pick);
    this.drawCommand(reglDrawProps);
  }
  destroy() {
    var _a2, _b;
    (_b = (_a2 = this.drawParams) == null ? void 0 : _a2.elements) == null ? void 0 : _b.destroy();
    if (this.options.attributes) {
      Object.values(this.options.attributes).forEach((attr) => {
        attr == null ? void 0 : attr.destroy();
      });
    }
    this.destroyed = true;
  }
  /**
   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#depth-buffer
   */
  initDepthDrawParams({ depth }, drawParams) {
    if (depth) {
      drawParams.depth = {
        enable: depth.enable === void 0 ? true : !!depth.enable,
        mask: depth.mask === void 0 ? true : !!depth.mask,
        func: depthFuncMap2[depth.func || gl.LESS],
        range: depth.range || [0, 1]
      };
    }
  }
  getBlendDrawParams({ blend }) {
    const { enable, func, equation, color: color2 = [0, 0, 0, 0] } = blend || {};
    return {
      enable: !!enable,
      func: {
        srcRGB: blendFuncMap2[func && func.srcRGB || gl.SRC_ALPHA],
        srcAlpha: blendFuncMap2[func && func.srcAlpha || gl.SRC_ALPHA],
        dstRGB: blendFuncMap2[func && func.dstRGB || gl.ONE_MINUS_SRC_ALPHA],
        dstAlpha: blendFuncMap2[func && func.dstAlpha || gl.ONE_MINUS_SRC_ALPHA]
      },
      equation: {
        rgb: blendEquationMap2[equation && equation.rgb || gl.FUNC_ADD],
        alpha: blendEquationMap2[equation && equation.alpha || gl.FUNC_ADD]
      },
      color: color2
    };
  }
  /**
   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#stencil
   */
  getStencilDrawParams({ stencil }) {
    const {
      enable,
      mask = -1,
      func = {
        cmp: gl.ALWAYS,
        ref: 0,
        mask: -1
      },
      opFront = {
        fail: gl.KEEP,
        zfail: gl.KEEP,
        zpass: gl.KEEP
      },
      opBack = {
        fail: gl.KEEP,
        zfail: gl.KEEP,
        zpass: gl.KEEP
      }
    } = stencil || {};
    return {
      enable: !!enable,
      mask,
      func: __spreadProps18(__spreadValues21({}, func), {
        cmp: stencilFuncMap2[func.cmp]
      }),
      opFront: {
        fail: stencilOpMap2[opFront.fail],
        zfail: stencilOpMap2[opFront.zfail],
        zpass: stencilOpMap2[opFront.zpass]
      },
      opBack: {
        fail: stencilOpMap2[opBack.fail],
        zfail: stencilOpMap2[opBack.zfail],
        zpass: stencilOpMap2[opBack.zpass]
      }
    };
  }
  getColorMaskDrawParams({ stencil }, pick) {
    const colorMask = (stencil == null ? void 0 : stencil.enable) && stencil.opFront && !pick ? [false, false, false, false] : [true, true, true, true];
    return colorMask;
  }
  /**
   * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#culling
   */
  initCullDrawParams({ cull }, drawParams) {
    if (cull) {
      const { enable, face = gl.BACK } = cull;
      drawParams.cull = {
        enable: !!enable,
        face: cullFaceMap2[face]
      };
    }
  }
  /**
   * 考虑结构体命名, eg:
   * a: { b: 1 }  ->  'a.b'
   * a: [ { b: 1 } ] -> 'a[0].b'
   */
  extractUniforms(uniforms) {
    const extractedUniforms = {};
    Object.keys(uniforms).forEach((uniformName) => {
      this.extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, "");
    });
    return extractedUniforms;
  }
  extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix2) {
    if (uniformValue === null || typeof uniformValue === "number" || // u_A: 1
    typeof uniformValue === "boolean" || // u_A: false
    Array.isArray(uniformValue) && typeof uniformValue[0] === "number" || // u_A: [1, 2, 3]
    isTypedArray4(uniformValue) || // u_A: Float32Array
    // @ts-ignore
    uniformValue === "" || "resize" in uniformValue) {
      uniforms[`${prefix2 && prefix2 + "."}${uniformName}`] = uniformValue;
      return;
    }
    if (isPlainObject3(uniformValue)) {
      Object.keys(uniformValue).forEach((childName) => {
        this.extractUniformsRecursively(
          childName,
          // @ts-ignore
          uniformValue[childName],
          uniforms,
          `${prefix2 && prefix2 + "."}${uniformName}`
        );
      });
    }
    if (Array.isArray(uniformValue)) {
      uniformValue.forEach((child, idx) => {
        Object.keys(child).forEach((childName) => {
          this.extractUniformsRecursively(
            childName,
            // @ts-ignore
            child[childName],
            uniforms,
            `${prefix2 && prefix2 + "."}${uniformName}[${idx}]`
          );
        });
      });
    }
  }
};

// node_modules/@antv/l7-renderer/es/regl/ReglTexture2D.js
var ReglTexture2D = class {
  constructor(reGl, options) {
    this.isDestroy = false;
    const {
      data,
      type = gl.UNSIGNED_BYTE,
      width,
      height,
      flipY = false,
      format: format2 = gl.RGBA,
      mipmap = false,
      wrapS = gl.CLAMP_TO_EDGE,
      wrapT = gl.CLAMP_TO_EDGE,
      aniso = 0,
      alignment = 1,
      premultiplyAlpha = false,
      mag = gl.NEAREST,
      min: min3 = gl.NEAREST,
      colorSpace = gl.BROWSER_DEFAULT_WEBGL,
      x = 0,
      y = 0,
      copy: copy3 = false
    } = options;
    this.width = width;
    this.height = height;
    const textureOptions = {
      width,
      height,
      // @ts-ignore
      type: dataTypeMap[type],
      format: formatMap[format2],
      wrapS: wrapModeMap2[wrapS],
      wrapT: wrapModeMap2[wrapT],
      // @ts-ignore
      mag: filterMap[mag],
      min: filterMap[min3],
      alignment,
      flipY,
      colorSpace: colorSpaceMap[colorSpace],
      premultiplyAlpha,
      aniso,
      // copy pixels from current bind framebuffer
      x,
      y,
      copy: copy3
    };
    if (data) {
      textureOptions.data = data;
    }
    if (typeof mipmap === "number") {
      textureOptions.mipmap = mipmapMap[mipmap];
    } else if (typeof mipmap === "boolean") {
      textureOptions.mipmap = mipmap;
    }
    this.texture = reGl.texture(textureOptions);
  }
  get() {
    return this.texture;
  }
  update(props = {}) {
    this.texture(props);
  }
  bind() {
    this.texture._texture.bind();
  }
  resize({ width, height }) {
    this.texture.resize(width, height);
    this.width = width;
    this.height = height;
  }
  getSize() {
    return [this.width, this.height];
  }
  destroy() {
    var _a2;
    if (!this.isDestroy) {
      (_a2 = this.texture) == null ? void 0 : _a2.destroy();
    }
    this.isDestroy = true;
  }
};

// node_modules/@antv/l7-renderer/es/regl/index.js
var __async11 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var ReglRendererService = class {
  constructor() {
    this.uniformBuffers = [];
    this.queryVerdorInfo = () => {
      return "WebGL1";
    };
    this.createModel = (options) => new ReglModel(this.gl, options);
    this.createAttribute = (options) => new ReglAttribute(this.gl, options);
    this.createBuffer = (options) => new ReglBuffer(this.gl, options);
    this.createElements = (options) => new ReglElements(this.gl, options);
    this.createTexture2D = (options) => new ReglTexture2D(this.gl, options);
    this.createFramebuffer = (options) => new ReglFramebuffer(this.gl, options);
    this.useFramebuffer = (framebuffer, drawCommands) => {
      this.gl({
        framebuffer: framebuffer ? framebuffer.get() : null
      })(drawCommands);
    };
    this.useFramebufferAsync = (framebuffer, drawCommands) => __async11(this, null, function* () {
      this.gl({
        framebuffer: framebuffer ? framebuffer.get() : null
      })(drawCommands);
    });
    this.clear = (options) => {
      var _a2;
      const { color: color2, depth, stencil, framebuffer = null } = options;
      const reglClearOptions = {
        color: color2,
        depth,
        stencil
      };
      reglClearOptions.framebuffer = framebuffer === null ? framebuffer : framebuffer.get();
      (_a2 = this.gl) == null ? void 0 : _a2.clear(reglClearOptions);
    };
    this.viewport = ({
      x,
      y,
      width,
      height
    }) => {
      this.gl._gl.viewport(x, y, width, height);
      this.width = width;
      this.height = height;
      this.gl._refresh();
    };
    this.readPixels = (options) => {
      const { framebuffer, x, y, width, height } = options;
      const readPixelsOptions = {
        x,
        y,
        width,
        height
      };
      if (framebuffer) {
        readPixelsOptions.framebuffer = framebuffer.get();
      }
      return this.gl.read(readPixelsOptions);
    };
    this.readPixelsAsync = (options) => __async11(this, null, function* () {
      return this.readPixels(options);
    });
    this.getViewportSize = () => {
      return {
        width: this.gl._gl.drawingBufferWidth,
        height: this.gl._gl.drawingBufferHeight
      };
    };
    this.getContainer = () => {
      var _a2;
      return (_a2 = this.canvas) == null ? void 0 : _a2.parentElement;
    };
    this.getCanvas = () => {
      return this.canvas;
    };
    this.getGLContext = () => {
      return this.gl._gl;
    };
    this.destroy = () => {
      var _a2, _b, _c;
      this.canvas = null;
      (_c = (_b = (_a2 = this.gl) == null ? void 0 : _a2._gl) == null ? void 0 : _b.getExtension("WEBGL_lose_context")) == null ? void 0 : _c.loseContext();
      this.gl.destroy();
      this.gl = null;
    };
  }
  init(canvas, cfg, gl2) {
    return __async11(this, null, function* () {
      this.canvas = canvas;
      if (gl2) {
        this.gl = gl2;
      } else {
        this.gl = yield new Promise((resolve, reject) => {
          (0, import_regl.default)({
            canvas: this.canvas,
            attributes: {
              alpha: true,
              // use TAA instead of MSAA
              // @see https://www.khronos.org/registry/webgl/specs/1.0/#5.2.1
              antialias: cfg.antialias,
              premultipliedAlpha: true,
              preserveDrawingBuffer: cfg.preserveDrawingBuffer,
              stencil: cfg.stencil
            },
            // TODO: use extensions
            extensions: [
              "OES_element_index_uint",
              "OES_standard_derivatives",
              // wireframe
              "ANGLE_instanced_arrays"
              // VSM shadow map
            ],
            optionalExtensions: [
              "oes_texture_float_linear",
              "OES_texture_float",
              "EXT_texture_filter_anisotropic",
              "EXT_blend_minmax",
              "WEBGL_depth_texture",
              "WEBGL_lose_context"
            ],
            profile: true,
            onDone: (err, r) => {
              if (err || !r) {
                reject(err);
              }
              resolve(r);
            }
          });
        });
      }
      this.extensionObject = {
        OES_texture_float: this.testExtension("OES_texture_float")
      };
    });
  }
  getPointSizeRange() {
    return this.gl._gl.getParameter(this.gl._gl.ALIASED_POINT_SIZE_RANGE);
  }
  testExtension(name) {
    return !!this.getGLContext().getExtension(name);
  }
  // TODO: 临时方法
  setState() {
    this.gl({
      cull: {
        enable: false,
        face: "back"
      },
      viewport: {
        x: 0,
        y: 0,
        height: this.width,
        width: this.height
      },
      blend: {
        enable: true,
        equation: "add"
      },
      framebuffer: null
    });
    this.gl._refresh();
  }
  setBaseState() {
    this.gl({
      cull: {
        enable: false,
        face: "back"
      },
      viewport: {
        x: 0,
        y: 0,
        height: this.width,
        width: this.height
      },
      blend: {
        enable: false,
        equation: "add"
      },
      framebuffer: null
    });
    this.gl._refresh();
  }
  setCustomLayerDefaults() {
    const gl2 = this.getGLContext();
    gl2.disable(gl2.CULL_FACE);
  }
  setDirty(flag) {
    this.isDirty = flag;
  }
  getDirty() {
    return this.isDirty;
  }
  beginFrame() {
  }
  endFrame() {
  }
};

// node_modules/@antv/l7-scene/es/boxSelect.js
var import_eventemitter310 = __toESM(require_eventemitter3());
var BoxSelectEventList = ["selectstart", "selecting", "selectend"];
var BoxSelect = class extends import_eventemitter310.EventEmitter {
  constructor(scene, options = {}) {
    super();
    this.isEnable = false;
    this.onDragStart = (e) => {
      this.box.style.display = "block";
      this.startEvent = this.endEvent = e;
      this.syncBoxBound();
      this.emit("selectstart", this.getLngLatBox(), this.startEvent, this.endEvent);
    };
    this.onDragging = (e) => {
      this.endEvent = e;
      this.syncBoxBound();
      this.emit("selecting", this.getLngLatBox(), this.startEvent, this.endEvent);
    };
    this.onDragEnd = (e) => {
      this.endEvent = e;
      this.box.style.display = "none";
      this.emit("selectend", this.getLngLatBox(), this.startEvent, this.endEvent);
    };
    this.scene = scene;
    this.options = options;
  }
  get container() {
    return this.scene.getMapService().getMarkerContainer();
  }
  enable() {
    if (this.isEnable) {
      return;
    }
    const { className } = this.options;
    this.scene.setMapStatus({
      dragEnable: false
    });
    this.container.style.cursor = "crosshair";
    if (!this.box) {
      const box = dom_exports.create("div", void 0, this.container);
      box.classList.add("l7-select-box");
      if (className) {
        box.classList.add(className);
      }
      box.style.display = "none";
      this.box = box;
    }
    this.scene.on("dragstart", this.onDragStart);
    this.scene.on("dragging", this.onDragging);
    this.scene.on("dragend", this.onDragEnd);
    this.isEnable = true;
  }
  disable() {
    if (!this.isEnable) {
      return;
    }
    this.scene.setMapStatus({
      dragEnable: true
    });
    this.container.style.cursor = "auto";
    this.scene.off("dragstart", this.onDragStart);
    this.scene.off("dragging", this.onDragging);
    this.scene.off("dragend", this.onDragEnd);
    this.isEnable = false;
  }
  syncBoxBound() {
    const { x: x1, y: y1 } = this.startEvent;
    const { x: x2, y: y2 } = this.endEvent;
    const left = Math.min(x1, x2);
    const top = Math.min(y1, y2);
    const width = Math.abs(x1 - x2);
    const height = Math.abs(y1 - y2);
    this.box.style.top = `${top}px`;
    this.box.style.left = `${left}px`;
    this.box.style.width = `${width}px`;
    this.box.style.height = `${height}px`;
  }
  getLngLatBox() {
    const {
      lngLat: { lng: lng1, lat: lat1 }
    } = this.startEvent;
    const {
      lngLat: { lng: lng2, lat: lat2 }
    } = this.endEvent;
    return getBBoxFromPoints([
      [lng1, lat1],
      [lng2, lat2]
    ]);
  }
};

// node_modules/@antv/l7-scene/es/index.js
var __defProp22 = Object.defineProperty;
var __defProps19 = Object.defineProperties;
var __getOwnPropDescs19 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols22 = Object.getOwnPropertySymbols;
var __hasOwnProp22 = Object.prototype.hasOwnProperty;
var __propIsEnum22 = Object.prototype.propertyIsEnumerable;
var __defNormalProp22 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues22 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp22.call(b, prop))
      __defNormalProp22(a, prop, b[prop]);
  if (__getOwnPropSymbols22)
    for (var prop of __getOwnPropSymbols22(b)) {
      if (__propIsEnum22.call(b, prop))
        __defNormalProp22(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps19 = (a, b) => __defProps19(a, __getOwnPropDescs19(b));
var __async12 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var Scene = class {
  constructor(config) {
    const { id, map: map8, renderer = "device" } = config;
    const sceneContainer = createSceneContainer();
    this.container = sceneContainer;
    map8.setContainer(sceneContainer, id);
    if (renderer === "regl") {
      sceneContainer.rendererService = new ReglRendererService();
    } else {
      sceneContainer.rendererService = new DeviceRendererService();
    }
    this.sceneService = sceneContainer.sceneService;
    this.mapService = sceneContainer.mapService;
    this.iconService = sceneContainer.iconService;
    this.fontService = sceneContainer.fontService;
    this.controlService = sceneContainer.controlService;
    this.layerService = sceneContainer.layerService;
    this.debugService = sceneContainer.debugService;
    this.debugService.setEnable(config.debug);
    this.markerService = sceneContainer.markerService;
    this.interactionService = sceneContainer.interactionService;
    this.popupService = sceneContainer.popupService;
    this.boxSelect = new BoxSelect(this, {});
    this.initComponent(id);
    this.sceneService.init(config);
    this.initControl();
  }
  get map() {
    return this.mapService.map;
  }
  get loaded() {
    return this.sceneService.loaded;
  }
  getServiceContainer() {
    return this.container;
  }
  getSize() {
    return this.mapService.getSize();
  }
  getMinZoom() {
    return this.mapService.getMinZoom();
  }
  getMaxZoom() {
    return this.mapService.getMaxZoom();
  }
  getType() {
    return this.mapService.getType();
  }
  getMapContainer() {
    return this.mapService.getMapContainer();
  }
  getMapCanvasContainer() {
    return this.mapService.getMapCanvasContainer();
  }
  getMapService() {
    return this.mapService;
  }
  /**
   * 对外暴露 debugService
   * @returns
   */
  getDebugService() {
    return this.debugService;
  }
  exportPng(type) {
    return __async12(this, null, function* () {
      return this.sceneService.exportPng(type);
    });
  }
  exportMap(type) {
    return __async12(this, null, function* () {
      return this.sceneService.exportPng(type);
    });
  }
  registerRenderService(render) {
    if (this.sceneService.loaded) {
      const renderSerivce = new render(this);
      renderSerivce.init();
    } else {
      this.on("loaded", () => {
        const renderSerivce = new render(this);
        renderSerivce.init();
      });
    }
  }
  setBgColor(color2) {
    this.mapService.setBgColor(color2);
  }
  addLayer(layer) {
    if (this.loaded) {
      this.preAddLayer(layer);
    } else {
      this.once("loaded", () => {
        this.preAddLayer(layer);
      });
    }
  }
  // layer 管理
  preAddLayer(layer) {
    const layerContainer = createLayerContainer(this.container);
    layer.setContainer(layerContainer);
    this.sceneService.addLayer(layer);
    if (layer.inited) {
      this.initTileLayer(layer);
      const maskInstance = this.initMask(layer);
      this.addMask(maskInstance, layer.id);
    } else {
      layer.on("inited", () => {
        this.initTileLayer(layer);
        const maskInstance = this.initMask(layer);
        this.addMask(maskInstance, layer.id);
      });
    }
  }
  // 兼容历史接口
  initMask(layer) {
    const { mask, maskfence, maskColor = "#000", maskOpacity = 0 } = layer.getLayerConfig();
    if (!mask || !maskfence) {
      return void 0;
    }
    const maskInstance = new MaskLayer().source(maskfence).shape("fill").style({
      color: maskColor,
      opacity: maskOpacity
    });
    return maskInstance;
  }
  addMask(mask, layerId) {
    if (!mask) {
      return;
    }
    const parent = this.getLayer(layerId);
    if (parent) {
      const layerContainer = createLayerContainer(this.container);
      mask.setContainer(layerContainer);
      parent.addMaskLayer(mask);
      this.sceneService.addMask(mask);
    } else {
      console.warn("parent layer not find!");
    }
  }
  getPickedLayer() {
    return this.layerService.pickedLayerId;
  }
  getLayers() {
    return this.layerService.getLayers();
  }
  getLayer(id) {
    return this.layerService.getLayer(id);
  }
  getLayerByName(name) {
    return this.layerService.getLayerByName(name);
  }
  removeLayer(layer, parentLayer) {
    return __async12(this, null, function* () {
      yield this.layerService.remove(layer, parentLayer);
    });
  }
  removeAllLayer() {
    return __async12(this, null, function* () {
      yield this.layerService.removeAllLayers();
    });
  }
  render() {
    this.sceneService.render();
  }
  setEnableRender(flag) {
    this.layerService.setEnableRender(flag);
  }
  // asset method
  /**
   * 为 layer/point/text 支持 iconfont 模式支持
   * @param fontUnicode
   * @param name
   */
  addIconFont(name, fontUnicode) {
    this.fontService.addIconFont(name, fontUnicode);
  }
  addIconFonts(options) {
    options.forEach(([name, fontUnicode]) => {
      this.fontService.addIconFont(name, fontUnicode);
    });
  }
  /**
   * 用户自定义添加第三方字体
   * @param fontFamily
   * @param fontPath
   */
  addFontFace(fontFamily, fontPath) {
    this.fontService.once("fontloaded", (e) => {
      this.emit("fontloaded", e);
    });
    this.fontService.addFontFace(fontFamily, fontPath);
  }
  addImage(id, img) {
    return __async12(this, null, function* () {
      yield this.iconService.addImage(id, img);
    });
  }
  hasImage(id) {
    return this.iconService.hasImage(id);
  }
  removeImage(id) {
    this.iconService.removeImage(id);
  }
  addIconFontGlyphs(fontFamily, glyphs) {
    this.fontService.addIconGlyphs(glyphs);
  }
  // map control method
  addControl(ctr) {
    this.controlService.addControl(ctr, this.container);
  }
  removeControl(ctr) {
    this.controlService.removeControl(ctr);
  }
  getControlByName(name) {
    return this.controlService.getControlByName(name);
  }
  // marker
  addMarker(marker) {
    this.markerService.addMarker(marker);
  }
  addMarkerLayer(layer) {
    this.markerService.addMarkerLayer(layer);
  }
  removeMarkerLayer(layer) {
    this.markerService.removeMarkerLayer(layer);
  }
  removeAllMarkers() {
    this.markerService.removeAllMarkers();
  }
  removeAllMakers() {
    console.warn("removeAllMakers 已废弃，请使用 removeAllMarkers");
    this.markerService.removeAllMarkers();
  }
  addPopup(popup) {
    this.popupService.addPopup(popup);
  }
  removePopup(popup) {
    this.popupService.removePopup(popup);
  }
  on(type, handle) {
    var _a2;
    if (BoxSelectEventList.includes(type)) {
      (_a2 = this.boxSelect) == null ? void 0 : _a2.on(type, handle);
    } else if (SceneEventList.includes(type)) {
      this.sceneService.on(type, handle);
    } else {
      this.mapService.on(type, handle);
    }
  }
  once(type, handle) {
    var _a2;
    if (BoxSelectEventList.includes(type)) {
      (_a2 = this.boxSelect) == null ? void 0 : _a2.once(type, handle);
    } else if (SceneEventList.includes(type)) {
      this.sceneService.once(type, handle);
    } else {
      this.mapService.once(type, handle);
    }
  }
  emit(type, handle) {
    SceneEventList.indexOf(type) === -1 ? this.mapService.on(type, handle) : this.sceneService.emit(type, handle);
  }
  off(type, handle) {
    var _a2;
    if (BoxSelectEventList.includes(type)) {
      (_a2 = this.boxSelect) == null ? void 0 : _a2.off(type, handle);
    } else if (SceneEventList.includes(type)) {
      this.sceneService.off(type, handle);
    } else {
      this.mapService.off(type, handle);
    }
  }
  // implements IMapController
  getZoom() {
    return this.mapService.getZoom();
  }
  getCenter(options) {
    return this.mapService.getCenter(options);
  }
  setCenter(center, options) {
    return this.mapService.setCenter(center, options);
  }
  getPitch() {
    return this.mapService.getPitch();
  }
  setPitch(pitch) {
    return this.mapService.setPitch(pitch);
  }
  getRotation() {
    return this.mapService.getRotation();
  }
  getBounds() {
    return this.mapService.getBounds();
  }
  setRotation(rotation) {
    this.mapService.setRotation(rotation);
  }
  zoomIn() {
    this.mapService.zoomIn();
  }
  zoomOut() {
    this.mapService.zoomOut();
  }
  panTo(p) {
    this.mapService.panTo(p);
  }
  panBy(x, y) {
    this.mapService.panBy(x, y);
  }
  getContainer() {
    return this.mapService.getContainer();
  }
  setZoom(zoom) {
    this.mapService.setZoom(zoom);
  }
  fitBounds(bound, options) {
    const { fitBoundsOptions, animate } = this.sceneService.getSceneConfig();
    this.mapService.fitBounds(
      bound,
      // 选项优先级：用户传入，覆盖animate直接配置，覆盖Scene配置项传入
      options || __spreadProps19(__spreadValues22({}, fitBoundsOptions), {
        animate
      })
    );
  }
  setZoomAndCenter(zoom, center) {
    this.mapService.setZoomAndCenter(zoom, center);
  }
  setMapStyle(style) {
    this.mapService.setMapStyle(style);
  }
  setMapStatus(options) {
    this.mapService.setMapStatus(options);
  }
  // conversion Method
  pixelToLngLat(pixel) {
    return this.mapService.pixelToLngLat(pixel);
  }
  lngLatToPixel(lnglat) {
    return this.mapService.lngLatToPixel(lnglat);
  }
  containerToLngLat(pixel) {
    return this.mapService.containerToLngLat(pixel);
  }
  lngLatToContainer(lnglat) {
    return this.mapService.lngLatToContainer(lnglat);
  }
  destroy() {
    this.sceneService.destroy();
  }
  registerPostProcessingPass(constructor) {
    this.container.postProcessingPass.name = new constructor();
  }
  // 控制 shader pick 计算
  enableShaderPick() {
    this.layerService.enableShaderPick();
  }
  diasbleShaderPick() {
    this.layerService.disableShaderPick();
  }
  enableBoxSelect(once = true) {
    this.boxSelect.enable();
    if (once) {
      this.boxSelect.once("selectend", () => {
        this.disableBoxSelect();
      });
    }
  }
  disableBoxSelect() {
    this.boxSelect.disable();
  }
  // 数据协议
  static addProtocol(protocol, handler) {
    SceneConifg.REGISTERED_PROTOCOLS[protocol] = handler;
  }
  static removeProtocol(protocol) {
    delete SceneConifg.REGISTERED_PROTOCOLS[protocol];
  }
  getProtocol(protocol) {
    return SceneConifg.REGISTERED_PROTOCOLS[protocol];
  }
  startAnimate() {
    this.layerService.startAnimate();
  }
  stopAnimate() {
    this.layerService.stopAnimate();
  }
  // get current point size info
  getPointSizeRange() {
    return this.sceneService.getPointSizeRange();
  }
  initComponent(id) {
    this.controlService.init(
      {
        container: dom_exports.getContainer(id)
      },
      this.container
    );
    this.markerService.init(this.container);
    this.popupService.init(this.container);
  }
  initControl() {
    const { logoVisible, logoPosition } = this.sceneService.getSceneConfig();
    if (logoVisible) {
      this.addControl(new Logo({ position: logoPosition }));
    }
  }
  initTileLayer(layer) {
    if (layer.getSource().isTile) {
      layer.tileLayer = new BaseTileLayer(layer);
    }
  }
};

// node_modules/@antv/l7/es/version.js
var version = "2.22.5";
export {
  AJAXError,
  AttributeType,
  BKDRHash,
  MapboxWrapper as BaiduMap,
  BaseLayer,
  BaseMapService,
  BaseMapWrapper,
  BaseModel,
  BasePostProcessingPass,
  BlendType,
  ButtonControl,
  CameraUniform,
  CanvasLayer,
  CanvasUpdateType,
  CityBuildingLayer,
  Control,
  CoordinateSystem,
  CoordinateUniform,
  dom_exports as DOM,
  EarthWrapper as Earth,
  EarthLayer,
  ExportImage,
  FrequencyController,
  Fullscreen,
  GaodeMap,
  GaodeMapV1,
  GaodeMapV2,
  GeoLocate,
  GeometryLayer,
  GMapWrapper as GoogleMap,
  HeatMapLayer as HeatmapLayer,
  IDebugLog,
  ILayerStage,
  ImageLayer,
  InteractionEvent,
  LRUCache,
  LayerPopup,
  LayerSwitch,
  LineLayer,
  LinearDir,
  LoadTileDataStatus,
  Logo,
  MapboxWrapper2 as Map,
  MapboxWrapper4 as MapLibre,
  MapServiceEvent,
  MapTheme,
  MapboxWrapper3 as Mapbox,
  Marker,
  MarkerLayer,
  MaskLayer,
  MaskOperation,
  MouseLocation,
  PassType,
  PointLayer,
  PolygonLayer,
  PopperControl,
  Popup,
  PositionType,
  RasterLayer,
  RasterTileType,
  statistics_exports as Satistics,
  Scale,
  ScaleTypes,
  Scene,
  SceneConifg,
  SceneEventList,
  SelectControl,
  SizeUnitType,
  src_default as Source,
  SourceTile,
  StencilType,
  StyleScaleType,
  Swipe,
  TdtMapWrapper as TMap,
  TMapWrapper as TencentMap,
  TextureBlend,
  TextureUsage,
  TileDebugLayer,
  BaseTileLayer as TileLayer,
  TilesetManager,
  UpdateTileStrategy,
  WindLayer,
  Zoom,
  aProjectFlat,
  amap2Project,
  amap2UnProject,
  anchorTranslate,
  anchorType,
  applyAnchorClass,
  bBoxToBounds,
  bindAll,
  boundsContains,
  calAngle,
  calDistance,
  calculateCentroid,
  calculatePointsCenterAndRadius,
  createLayerContainer,
  createSceneContainer,
  decodePickingColor,
  defaultValue,
  djb2hash,
  encodePickingColor,
  expandUrl,
  extent,
  flow,
  formatImage,
  fp64LowPart,
  generateCatRamp,
  generateColorRamp,
  generateCustomRamp,
  generateLinearRamp,
  generateQuantizeRamp,
  getAngle,
  getArrayBuffer,
  getBBoxFromPoints,
  getData,
  getDefaultDomain,
  getImage,
  getJSON,
  getProtocolAction,
  getReferrer,
  getTileIndices,
  getTileWarpXY,
  getURLFromTemplate,
  getWMTSURLFromTemplate,
  gl,
  globalConfigService,
  guid,
  isAndroid,
  isColor,
  isImageBitmap,
  isNumber,
  isPC,
  isURLTemplate,
  isWorker,
  isiOS,
  latitude,
  lineAtOffset,
  lineAtOffsetAsyc,
  lineStyleType,
  lngLatInExtent,
  lngLatToMeters,
  lnglatDistance,
  lodashUtil,
  longitude,
  makeXMLHttpRequestPromise,
  metersToLngLat,
  normalize,
  osmLonLat2TileXY,
  osmTileXY2LonLat,
  packCircleVertex,
  padBounds,
  postData,
  project,
  removeDuplicateUniforms,
  rgb2arr,
  sameOrigin,
  tileToBounds,
  tranfrormCoord,
  unProjectFlat,
  validateLngLat,
  version
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

splaytree/dist/splay.esm.js:
  (**
   * splaytree v3.1.2
   * Fast Splay tree for Node and browser
   *
   * @author Alexander Milevski <info@w8r.name>
   * @license MIT
   * @preserve
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@antv_l7.js.map
