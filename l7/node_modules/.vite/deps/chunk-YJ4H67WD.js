var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// node_modules/@amap/amap-jsapi-loader/dist/index.js
var require_dist = __commonJS({
  "node_modules/@amap/amap-jsapi-loader/dist/index.js"(exports, module) {
    "use strict";
    (function(m, p) {
      "object" === typeof exports && "undefined" !== typeof module ? module.exports = p() : "function" === typeof define && define.amd ? define(p) : (m = m || self, m.AMapLoader = p());
    })(exports, function() {
      function m(a) {
        var b2 = [];
        a.AMapUI && b2.push(p(a.AMapUI));
        a.Loca && b2.push(r(a.Loca));
        return Promise.all(b2);
      }
      function p(a) {
        return new Promise(function(h, c) {
          var f = [];
          if (a.plugins)
            for (var e = 0; e < a.plugins.length; e += 1)
              -1 == d.AMapUI.plugins.indexOf(a.plugins[e]) && f.push(a.plugins[e]);
          if (g.AMapUI === b.failed)
            c("前次请求 AMapUI 失败");
          else if (g.AMapUI === b.notload) {
            g.AMapUI = b.loading;
            d.AMapUI.version = a.version || d.AMapUI.version;
            e = d.AMapUI.version;
            var l = document.body || document.head, k = document.createElement("script");
            k.type = "text/javascript";
            k.src = "https://webapi.amap.com/ui/" + e + "/main.js";
            k.onerror = function(a2) {
              g.AMapUI = b.failed;
              c("请求 AMapUI 失败");
            };
            k.onload = function() {
              g.AMapUI = b.loaded;
              if (f.length)
                window.AMapUI.loadUI(f, function() {
                  for (var a2 = 0, b2 = f.length; a2 < b2; a2++) {
                    var c2 = f[a2].split("/").slice(-1)[0];
                    window.AMapUI[c2] = arguments[a2];
                  }
                  for (h(); n.AMapUI.length; )
                    n.AMapUI.splice(0, 1)[0]();
                });
              else
                for (h(); n.AMapUI.length; )
                  n.AMapUI.splice(0, 1)[0]();
            };
            l.appendChild(k);
          } else
            g.AMapUI === b.loaded ? a.version && a.version !== d.AMapUI.version ? c("不允许多个版本 AMapUI 混用") : f.length ? window.AMapUI.loadUI(f, function() {
              for (var a2 = 0, b2 = f.length; a2 < b2; a2++) {
                var c2 = f[a2].split("/").slice(-1)[0];
                window.AMapUI[c2] = arguments[a2];
              }
              h();
            }) : h() : a.version && a.version !== d.AMapUI.version ? c("不允许多个版本 AMapUI 混用") : n.AMapUI.push(function(a2) {
              a2 ? c(a2) : f.length ? window.AMapUI.loadUI(f, function() {
                for (var a3 = 0, b2 = f.length; a3 < b2; a3++) {
                  var c2 = f[a3].split("/").slice(-1)[0];
                  window.AMapUI[c2] = arguments[a3];
                }
                h();
              }) : h();
            });
        });
      }
      function r(a) {
        return new Promise(function(h, c) {
          if (g.Loca === b.failed)
            c("前次请求 Loca 失败");
          else if (g.Loca === b.notload) {
            g.Loca = b.loading;
            d.Loca.version = a.version || d.Loca.version;
            var f = d.Loca.version, e = d.AMap.version.startsWith("2"), l = f.startsWith("2");
            if (e && !l || !e && l)
              c("JSAPI 与 Loca 版本不对应！！");
            else {
              e = d.key;
              l = document.body || document.head;
              var k = document.createElement("script");
              k.type = "text/javascript";
              k.src = "https://webapi.amap.com/loca?v=" + f + "&key=" + e;
              k.onerror = function(a2) {
                g.Loca = b.failed;
                c("请求 AMapUI 失败");
              };
              k.onload = function() {
                g.Loca = b.loaded;
                for (h(); n.Loca.length; )
                  n.Loca.splice(0, 1)[0]();
              };
              l.appendChild(k);
            }
          } else
            g.Loca === b.loaded ? a.version && a.version !== d.Loca.version ? c("不允许多个版本 Loca 混用") : h() : a.version && a.version !== d.Loca.version ? c("不允许多个版本 Loca 混用") : n.Loca.push(function(a2) {
              a2 ? c(a2) : c();
            });
        });
      }
      if (!window)
        throw Error("AMap JSAPI can only be used in Browser.");
      var b;
      (function(a) {
        a.notload = "notload";
        a.loading = "loading";
        a.loaded = "loaded";
        a.failed = "failed";
      })(b || (b = {}));
      var d = { key: "", AMap: { version: "1.4.15", plugins: [] }, AMapUI: { version: "1.1", plugins: [] }, Loca: { version: "1.3.2" } }, g = { AMap: b.notload, AMapUI: b.notload, Loca: b.notload }, n = { AMap: [], AMapUI: [], Loca: [] }, q = [], t = function(a) {
        "function" == typeof a && (g.AMap === b.loaded ? a(window.AMap) : q.push(a));
      };
      return { load: function(a) {
        return new Promise(function(h, c) {
          if (g.AMap == b.failed)
            c("");
          else if (g.AMap == b.notload) {
            var f = a.key, e = a.version, l = a.plugins;
            f ? (window.AMap && "lbs.amap.com" !== location.host && c("禁止多种API加载方式混用"), d.key = f, d.AMap.version = e || d.AMap.version, d.AMap.plugins = l || d.AMap.plugins, g.AMap = b.loading, e = document.body || document.head, window.___onAPILoaded = function(d2) {
              delete window.___onAPILoaded;
              if (d2)
                g.AMap = b.failed, c(d2);
              else
                for (g.AMap = b.loaded, m(a).then(function() {
                  h(window.AMap);
                })["catch"](c); q.length; )
                  q.splice(0, 1)[0]();
            }, l = document.createElement("script"), l.type = "text/javascript", l.src = "https://webapi.amap.com/maps?callback=___onAPILoaded&v=" + d.AMap.version + "&key=" + f + "&plugin=" + d.AMap.plugins.join(","), l.onerror = function(a2) {
              g.AMap = b.failed;
              c(a2);
            }, e.appendChild(l)) : c("请填写key");
          } else if (g.AMap == b.loaded)
            if (a.key && a.key !== d.key)
              c("多个不一致的 key");
            else if (a.version && a.version !== d.AMap.version)
              c("不允许多个版本 JSAPI 混用");
            else {
              f = [];
              if (a.plugins)
                for (e = 0; e < a.plugins.length; e += 1)
                  -1 == d.AMap.plugins.indexOf(a.plugins[e]) && f.push(a.plugins[e]);
              if (f.length)
                window.AMap.plugin(f, function() {
                  m(a).then(function() {
                    h(window.AMap);
                  })["catch"](c);
                });
              else
                m(a).then(function() {
                  h(window.AMap);
                })["catch"](c);
            }
          else if (a.key && a.key !== d.key)
            c("多个不一致的 key");
          else if (a.version && a.version !== d.AMap.version)
            c("不允许多个版本 JSAPI 混用");
          else {
            var k = [];
            if (a.plugins)
              for (e = 0; e < a.plugins.length; e += 1)
                -1 == d.AMap.plugins.indexOf(a.plugins[e]) && k.push(a.plugins[e]);
            t(function() {
              if (k.length)
                window.AMap.plugin(k, function() {
                  m(a).then(function() {
                    h(window.AMap);
                  })["catch"](c);
                });
              else
                m(a).then(function() {
                  h(window.AMap);
                })["catch"](c);
            });
          }
        });
      }, reset: function() {
        delete window.AMap;
        delete window.AMapUI;
        delete window.Loca;
        d = { key: "", AMap: { version: "1.4.15", plugins: [] }, AMapUI: { version: "1.1", plugins: [] }, Loca: { version: "1.3.2" } };
        g = {
          AMap: b.notload,
          AMapUI: b.notload,
          Loca: b.notload
        };
        n = { AMap: [], AMapUI: [], Loca: [] };
      } };
    });
  }
});

// node_modules/lodash/_baseClamp.js
var require_baseClamp = __commonJS({
  "node_modules/lodash/_baseClamp.js"(exports, module) {
    function baseClamp(number2, lower, upper) {
      if (number2 === number2) {
        if (upper !== void 0) {
          number2 = number2 <= upper ? number2 : upper;
        }
        if (lower !== void 0) {
          number2 = number2 >= lower ? number2 : lower;
        }
      }
      return number2;
    }
    module.exports = baseClamp;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports, module) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module.exports = baseTrim;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject3(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject3;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports, module) {
    var baseTrim = require_baseTrim();
    var isObject3 = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = toNumber;
  }
});

// node_modules/lodash/clamp.js
var require_clamp = __commonJS({
  "node_modules/lodash/clamp.js"(exports, module) {
    var baseClamp = require_baseClamp();
    var toNumber = require_toNumber();
    function clamp4(number2, lower, upper) {
      if (upper === void 0) {
        upper = lower;
        lower = void 0;
      }
      if (upper !== void 0) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== void 0) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number2), lower, upper);
    }
    module.exports = clamp4;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length5 = array.length;
      while (length5--) {
        if (eq(array[length5][0], key)) {
          return length5;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length5 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length5) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports, module) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports, module) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports, module) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports, module) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module.exports = stackHas;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject3 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction2(value) {
      if (!isObject3(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction2;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction2 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject3 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject3(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map3 = getNative(root, "Map");
    module.exports = Map3;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length5 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length5) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map3 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map3 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length5 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length5) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports, module) {
    var ListCache = require_ListCache();
    var Map3 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map3 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports, module) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports, module) {
    function arrayEach(array, iteratee) {
      var index = -1, length5 = array == null ? 0 : array.length;
      while (++index < length5) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module.exports = arrayEach;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports, module) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module.exports = defineProperty;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports, module) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports, module) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length5 = props.length;
      while (++index < length5) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module.exports = copyObject;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length5) {
      var type = typeof value;
      length5 = length5 == null ? MAX_SAFE_INTEGER : length5;
      return !!length5 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length5);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray2;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray2 = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length5 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length5)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    var isFunction2 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    module.exports = isArrayLike2;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike2 = require_isArrayLike();
    function keys(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports, module) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module.exports = baseAssign;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports, module) {
    var isObject3 = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject3(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike2 = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module.exports = keysIn;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module.exports = baseAssignIn;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports, module) {
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length5 = buffer.length, result = allocUnsafe ? allocUnsafe(length5) : new buffer.constructor(length5);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports, module) {
    function copyArray(source, array) {
      var index = -1, length5 = source.length;
      array || (array = Array(length5));
      while (++index < length5) {
        array[index] = source[index];
      }
      return array;
    }
    module.exports = copyArray;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports, module) {
    function arrayFilter(array, predicate) {
      var index = -1, length5 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length5) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports, module) {
    function stubArray() {
      return [];
    }
    module.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module.exports = getSymbols;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module.exports = copySymbols;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports, module) {
    function arrayPush(array, values) {
      var index = -1, length5 = values.length, offset = array.length;
      while (++index < length5) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module.exports = arrayPush;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports, module) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module.exports = getAllKeys;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module.exports = DataView2;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports, module) {
    var DataView2 = require_DataView();
    var Map3 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map3);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map3 && getTag(new Map3()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module.exports = getTag;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports, module) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length5 = array.length, result = new array.constructor(length5);
      if (length5 && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module.exports = initCloneArray;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports, module) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module.exports = Uint8Array2;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports, module) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module.exports = cloneSymbol;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports, module) {
    var isObject3 = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject3(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module.exports = baseCreate;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module.exports = initCloneObject;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports, module) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports, module) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports, module) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject3 = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject3(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module.exports = baseClone;
  }
});

// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/lodash/cloneDeep.js"(exports, module) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep2(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module.exports = cloneDeep2;
  }
});

// node_modules/lodash/now.js
var require_now = __commonJS({
  "node_modules/lodash/now.js"(exports, module) {
    var root = require_root();
    var now2 = function() {
      return root.Date.now();
    };
    module.exports = now2;
  }
});

// node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "node_modules/lodash/debounce.js"(exports, module) {
    var isObject3 = require_isObject();
    var now2 = require_now();
    var toNumber = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject3(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now2();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now2());
      }
      function debounced() {
        var time = now2(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    module.exports = debounce2;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports, module) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module.exports = isKey;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module.exports = memoize;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports, module) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports, module) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
      });
      return result;
    });
    module.exports = stringToPath;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array, iteratee) {
      var index = -1, length5 = array == null ? 0 : array.length, result = Array(length5);
      while (++index < length5) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module.exports = toString;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports, module) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports, module) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports, module) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length5 = path.length;
      while (object != null && index < length5) {
        object = object[toKey(path[index++])];
      }
      return index && index == length5 ? object : void 0;
    }
    module.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports, module) {
    var baseGet = require_baseGet();
    function get2(object, path, defaultValue2) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue2 : result;
    }
    module.exports = get2;
  }
});

// node_modules/lodash/isBoolean.js
var require_isBoolean = __commonJS({
  "node_modules/lodash/isBoolean.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var boolTag = "[object Boolean]";
    function isBoolean2(value) {
      return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
    }
    module.exports = isBoolean2;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports, module) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports, module) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports, module) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length5 = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length5) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports, module) {
    function arraySome(array, predicate) {
      var index = -1, length5 = array == null ? 0 : array.length;
      while (++index < length5) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module.exports = arraySome;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports, module) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module.exports = cacheHas;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports, module) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module.exports = equalArrays;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports, module) {
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports, module) {
    function setToArray(set6) {
      var index = -1, result = Array(set6.size);
      set6.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module.exports = equalByTag;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports, module) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module.exports = equalObjects;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray2 = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports, module) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module.exports = baseIsEqual;
  }
});

// node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/lodash/isEqual.js"(exports, module) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual2(value, other) {
      return baseIsEqual(value, other);
    }
    module.exports = isEqual2;
  }
});

// node_modules/lodash/isNil.js
var require_isNil = __commonJS({
  "node_modules/lodash/isNil.js"(exports, module) {
    function isNil7(value) {
      return value == null;
    }
    module.exports = isNil7;
  }
});

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/lodash/isNumber.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber3(value) {
      return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
    }
    module.exports = isNumber3;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject2(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject2;
  }
});

// node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/lodash/isString.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString2(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module.exports = isString2;
  }
});

// node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "node_modules/lodash/_assignMergeValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignMergeValue;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports, module) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length5 = props.length;
        while (length5--) {
          var key = props[fromRight ? length5 : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports, module) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module.exports = baseFor;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    var isArrayLike2 = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike2(value);
    }
    module.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "node_modules/lodash/_safeGet.js"(exports, module) {
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    module.exports = safeGet;
  }
});

// node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "node_modules/lodash/toPlainObject.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module.exports = toPlainObject;
  }
});

// node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction2 = require_isFunction();
    var isObject3 = require_isObject();
    var isPlainObject2 = require_isPlainObject();
    var isTypedArray2 = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject3(objValue) || isFunction2(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    module.exports = baseMergeDeep;
  }
});

// node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "node_modules/lodash/_baseMerge.js"(exports, module) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject3 = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject3(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    module.exports = baseMerge;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports, module) {
    function identity3(value) {
      return value;
    }
    module.exports = identity3;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports, module) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module.exports = apply;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports, module) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform2) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length5 = nativeMax(args.length - start, 0), array = Array(length5);
        while (++index < length5) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform2(array);
        return apply(func, this, otherArgs);
      };
    }
    module.exports = overRest;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports, module) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module.exports = constant;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports, module) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity3 = require_identity();
    var baseSetToString = !defineProperty ? identity3 : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module.exports = baseSetToString;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports, module) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module.exports = shortOut;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports, module) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module.exports = setToString;
  }
});

// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/lodash/_baseRest.js"(exports, module) {
    var identity3 = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity3), func + "");
    }
    module.exports = baseRest;
  }
});

// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/lodash/_isIterateeCall.js"(exports, module) {
    var eq = require_eq();
    var isArrayLike2 = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject3 = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject3(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike2(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module.exports = isIterateeCall;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length5 = sources.length, customizer = length5 > 1 ? sources[length5 - 1] : void 0, guard = length5 > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length5--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length5 < 3 ? void 0 : customizer;
          length5 = 1;
        }
        object = Object(object);
        while (++index < length5) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module.exports = createAssigner;
  }
});

// node_modules/lodash/merge.js
var require_merge = __commonJS({
  "node_modules/lodash/merge.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge3 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    module.exports = merge3;
  }
});

// node_modules/lodash/mergeWith.js
var require_mergeWith = __commonJS({
  "node_modules/lodash/mergeWith.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var mergeWith2 = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    module.exports = mergeWith2;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports, module) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length5 = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length5) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports, module) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports, module) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length5 = array.length;
      while (++index < length5) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  }
});

// node_modules/lodash/_baseIndexOfWith.js
var require_baseIndexOfWith = __commonJS({
  "node_modules/lodash/_baseIndexOfWith.js"(exports, module) {
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length5 = array.length;
      while (++index < length5) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    module.exports = baseIndexOfWith;
  }
});

// node_modules/lodash/_basePullAll.js
var require_basePullAll = __commonJS({
  "node_modules/lodash/_basePullAll.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseIndexOf = require_baseIndexOf();
    var baseIndexOfWith = require_baseIndexOfWith();
    var baseUnary = require_baseUnary();
    var copyArray = require_copyArray();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length5 = values.length, seen = array;
      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length5) {
        var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }
    module.exports = basePullAll;
  }
});

// node_modules/lodash/pullAll.js
var require_pullAll = __commonJS({
  "node_modules/lodash/pullAll.js"(exports, module) {
    var basePullAll = require_basePullAll();
    function pullAll(array, values) {
      return array && array.length && values && values.length ? basePullAll(array, values) : array;
    }
    module.exports = pullAll;
  }
});

// node_modules/lodash/pull.js
var require_pull = __commonJS({
  "node_modules/lodash/pull.js"(exports, module) {
    var baseRest = require_baseRest();
    var pullAll = require_pullAll();
    var pull3 = baseRest(pullAll);
    module.exports = pull3;
  }
});

// node_modules/lodash/throttle.js
var require_throttle = __commonJS({
  "node_modules/lodash/throttle.js"(exports, module) {
    var debounce2 = require_debounce();
    var isObject3 = require_isObject();
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle4(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject3(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    module.exports = throttle4;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports, module) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length5 = array == null ? 0 : array.length;
      return !!length5 && baseIndexOf(array, value, 0) > -1;
    }
    module.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length5 = array == null ? 0 : array.length;
      while (++index < length5) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    function noop() {
    }
    module.exports = noop;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports, module) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length5 = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length5 >= LARGE_ARRAY_SIZE) {
        var set6 = iteratee ? null : createSet(array);
        if (set6) {
          return setToArray(set6);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length5) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseUniq;
  }
});

// node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/lodash/uniq.js"(exports, module) {
    var baseUniq = require_baseUniq();
    function uniq3(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module.exports = uniq3;
  }
});

// node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/lodash/_baseSlice.js"(exports, module) {
    function baseSlice(array, start, end) {
      var index = -1, length5 = array.length;
      if (start < 0) {
        start = -start > length5 ? 0 : length5 + start;
      }
      end = end > length5 ? length5 : end;
      if (end < 0) {
        end += length5;
      }
      length5 = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length5);
      while (++index < length5) {
        result[index] = array[index + start];
      }
      return result;
    }
    module.exports = baseSlice;
  }
});

// node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "node_modules/lodash/_castSlice.js"(exports, module) {
    var baseSlice = require_baseSlice();
    function castSlice(array, start, end) {
      var length5 = array.length;
      end = end === void 0 ? length5 : end;
      return !start && end >= length5 ? array : baseSlice(array, start, end);
    }
    module.exports = castSlice;
  }
});

// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/lodash/_hasUnicode.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module.exports = hasUnicode;
  }
});

// node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "node_modules/lodash/_asciiToArray.js"(exports, module) {
    function asciiToArray(string) {
      return string.split("");
    }
    module.exports = asciiToArray;
  }
});

// node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "node_modules/lodash/_unicodeToArray.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    module.exports = unicodeToArray;
  }
});

// node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "node_modules/lodash/_stringToArray.js"(exports, module) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    module.exports = stringToArray;
  }
});

// node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "node_modules/lodash/_createCaseFirst.js"(exports, module) {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString = require_toString();
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module.exports = createCaseFirst;
  }
});

// node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "node_modules/lodash/upperFirst.js"(exports, module) {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst3 = createCaseFirst("toUpperCase");
    module.exports = upperFirst3;
  }
});

// node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/lodash/isUndefined.js"(exports, module) {
    function isUndefined2(value) {
      return value === void 0;
    }
    module.exports = isUndefined2;
  }
});

// node_modules/lodash/capitalize.js
var require_capitalize = __commonJS({
  "node_modules/lodash/capitalize.js"(exports, module) {
    var toString = require_toString();
    var upperFirst3 = require_upperFirst();
    function capitalize(string) {
      return upperFirst3(toString(string).toLowerCase());
    }
    module.exports = capitalize;
  }
});

// node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "node_modules/lodash/_arrayReduce.js"(exports, module) {
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length5 = array == null ? 0 : array.length;
      if (initAccum && length5) {
        accumulator = array[++index];
      }
      while (++index < length5) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    module.exports = arrayReduce;
  }
});

// node_modules/lodash/_basePropertyOf.js
var require_basePropertyOf = __commonJS({
  "node_modules/lodash/_basePropertyOf.js"(exports, module) {
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    module.exports = basePropertyOf;
  }
});

// node_modules/lodash/_deburrLetter.js
var require_deburrLetter = __commonJS({
  "node_modules/lodash/_deburrLetter.js"(exports, module) {
    var basePropertyOf = require_basePropertyOf();
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    module.exports = deburrLetter;
  }
});

// node_modules/lodash/deburr.js
var require_deburr = __commonJS({
  "node_modules/lodash/deburr.js"(exports, module) {
    var deburrLetter = require_deburrLetter();
    var toString = require_toString();
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsCombo = "[" + rsComboRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module.exports = deburr;
  }
});

// node_modules/lodash/_asciiWords.js
var require_asciiWords = __commonJS({
  "node_modules/lodash/_asciiWords.js"(exports, module) {
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    module.exports = asciiWords;
  }
});

// node_modules/lodash/_hasUnicodeWord.js
var require_hasUnicodeWord = __commonJS({
  "node_modules/lodash/_hasUnicodeWord.js"(exports, module) {
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    module.exports = hasUnicodeWord;
  }
});

// node_modules/lodash/_unicodeWords.js
var require_unicodeWords = __commonJS({
  "node_modules/lodash/_unicodeWords.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
    var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    module.exports = unicodeWords;
  }
});

// node_modules/lodash/words.js
var require_words = __commonJS({
  "node_modules/lodash/words.js"(exports, module) {
    var asciiWords = require_asciiWords();
    var hasUnicodeWord = require_hasUnicodeWord();
    var toString = require_toString();
    var unicodeWords = require_unicodeWords();
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module.exports = words;
  }
});

// node_modules/lodash/_createCompounder.js
var require_createCompounder = __commonJS({
  "node_modules/lodash/_createCompounder.js"(exports, module) {
    var arrayReduce = require_arrayReduce();
    var deburr = require_deburr();
    var words = require_words();
    var rsApos = "['’]";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    module.exports = createCompounder;
  }
});

// node_modules/lodash/camelCase.js
var require_camelCase = __commonJS({
  "node_modules/lodash/camelCase.js"(exports, module) {
    var capitalize = require_capitalize();
    var createCompounder = require_createCompounder();
    var camelCase3 = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    module.exports = camelCase3;
  }
});

// node_modules/lodash/uniqueId.js
var require_uniqueId = __commonJS({
  "node_modules/lodash/uniqueId.js"(exports, module) {
    var toString = require_toString();
    var idCounter = 0;
    function uniqueId3(prefix) {
      var id2 = ++idCounter;
      return toString(prefix) + id2;
    }
    module.exports = uniqueId3;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once2) {
      this.fn = fn;
      this.context = context;
      this.once = once2 || false;
    }
    function addListener(emitter, event, fn, context, once2) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once2), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter11() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter11.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter11.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i2 = 0, l = handlers.length, ee = new Array(l); i2 < l; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter11.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter11.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len4 = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len4) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len4 - 1); i2 < len4; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length5 = listeners.length, j;
        for (i2 = 0; i2 < length5; i2++) {
          if (listeners[i2].once)
            this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len4) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len4 - 1); j < len4; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter11.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter11.prototype.once = function once2(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter11.prototype.removeListener = function removeListener(event, fn, context, once2) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length5 = listeners.length; i2 < length5; i2++) {
          if (listeners[i2].fn !== fn || once2 && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter11.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter11.prototype.off = EventEmitter11.prototype.removeListener;
    EventEmitter11.prototype.addListener = EventEmitter11.prototype.on;
    EventEmitter11.prefixed = prefix;
    EventEmitter11.EventEmitter = EventEmitter11;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter11;
    }
  }
});

// node_modules/@mapbox/tiny-sdf/index.js
var require_tiny_sdf = __commonJS({
  "node_modules/@mapbox/tiny-sdf/index.js"(exports, module) {
    "use strict";
    module.exports = TinySDF2;
    module.exports.default = TinySDF2;
    var INF = 1e20;
    function TinySDF2(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {
      this.fontSize = fontSize || 24;
      this.buffer = buffer === void 0 ? 3 : buffer;
      this.cutoff = cutoff || 0.25;
      this.fontFamily = fontFamily || "sans-serif";
      this.fontWeight = fontWeight || "normal";
      this.radius = radius || 8;
      var size = this.size = this.fontSize + this.buffer * 2;
      var gridSize = size + this.buffer * 2;
      this.canvas = document.createElement("canvas");
      this.canvas.width = this.canvas.height = size;
      this.ctx = this.canvas.getContext("2d");
      this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily;
      this.ctx.textAlign = "left";
      this.ctx.fillStyle = "black";
      this.gridOuter = new Float64Array(gridSize * gridSize);
      this.gridInner = new Float64Array(gridSize * gridSize);
      this.f = new Float64Array(gridSize);
      this.z = new Float64Array(gridSize + 1);
      this.v = new Uint16Array(gridSize);
      this.useMetrics = this.ctx.measureText("A").actualBoundingBoxLeft !== void 0;
      this.middle = Math.round(size / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
    }
    function prepareGrids(imgData, width, height, glyphWidth, glyphHeight, gridOuter, gridInner) {
      gridOuter.fill(INF, 0, width * height);
      gridInner.fill(0, 0, width * height);
      var offset = (width - glyphWidth) / 2;
      for (var y = 0; y < glyphHeight; y++) {
        for (var x2 = 0; x2 < glyphWidth; x2++) {
          var j = (y + offset) * width + x2 + offset;
          var a = imgData.data[4 * (y * glyphWidth + x2) + 3] / 255;
          if (a === 1) {
            gridOuter[j] = 0;
            gridInner[j] = INF;
          } else if (a === 0) {
            gridOuter[j] = INF;
            gridInner[j] = 0;
          } else {
            var b = Math.max(0, 0.5 - a);
            var c = Math.max(0, a - 0.5);
            gridOuter[j] = b * b;
            gridInner[j] = c * c;
          }
        }
      }
    }
    function extractAlpha(alphaChannel, width, height, gridOuter, gridInner, radius, cutoff) {
      for (var i2 = 0; i2 < width * height; i2++) {
        var d = Math.sqrt(gridOuter[i2]) - Math.sqrt(gridInner[i2]);
        alphaChannel[i2] = Math.round(255 - 255 * (d / radius + cutoff));
      }
    }
    TinySDF2.prototype._draw = function(char, getMetrics) {
      var textMetrics = this.ctx.measureText(char);
      var advance = textMetrics.width;
      var doubleBuffer = 2 * this.buffer;
      var width, glyphWidth, height, glyphHeight, top;
      var imgTop, imgLeft, baselinePosition;
      if (getMetrics && this.useMetrics) {
        top = Math.floor(textMetrics.actualBoundingBoxAscent);
        baselinePosition = this.buffer + Math.ceil(textMetrics.actualBoundingBoxAscent);
        imgTop = this.buffer;
        imgLeft = this.buffer;
        glyphWidth = Math.min(
          this.size,
          Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft)
        );
        glyphHeight = Math.min(
          this.size - imgTop,
          Math.ceil(textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent)
        );
        width = glyphWidth + doubleBuffer;
        height = glyphHeight + doubleBuffer;
        this.ctx.textBaseline = "alphabetic";
      } else {
        width = glyphWidth = this.size;
        height = glyphHeight = this.size;
        top = 19 * this.fontSize / 24;
        imgTop = imgLeft = 0;
        baselinePosition = this.middle;
        this.ctx.textBaseline = "middle";
      }
      var imgData;
      if (glyphWidth && glyphHeight) {
        this.ctx.clearRect(imgLeft, imgTop, glyphWidth, glyphHeight);
        this.ctx.fillText(char, this.buffer, baselinePosition);
        imgData = this.ctx.getImageData(imgLeft, imgTop, glyphWidth, glyphHeight);
      }
      var alphaChannel = new Uint8ClampedArray(width * height);
      prepareGrids(imgData, width, height, glyphWidth, glyphHeight, this.gridOuter, this.gridInner);
      edt(this.gridOuter, width, height, this.f, this.v, this.z);
      edt(this.gridInner, width, height, this.f, this.v, this.z);
      extractAlpha(alphaChannel, width, height, this.gridOuter, this.gridInner, this.radius, this.cutoff);
      return {
        data: alphaChannel,
        metrics: {
          width: glyphWidth,
          height: glyphHeight,
          sdfWidth: width,
          sdfHeight: height,
          top,
          left: 0,
          advance
        }
      };
    };
    TinySDF2.prototype.draw = function(char) {
      return this._draw(char, false).data;
    };
    TinySDF2.prototype.drawWithMetrics = function(char) {
      return this._draw(char, true);
    };
    function edt(data, width, height, f, v, z) {
      for (var x2 = 0; x2 < width; x2++)
        edt1d(data, x2, width, height, f, v, z);
      for (var y = 0; y < height; y++)
        edt1d(data, y * width, 1, width, f, v, z);
    }
    function edt1d(grid, offset, stride, length5, f, v, z) {
      var q, k, s, r;
      v[0] = 0;
      z[0] = -INF;
      z[1] = INF;
      for (q = 0; q < length5; q++)
        f[q] = grid[offset + q * stride];
      for (q = 1, k = 0, s = 0; q < length5; q++) {
        do {
          r = v[k];
          s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;
        } while (s <= z[k] && --k > -1);
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = INF;
      }
      for (q = 0, k = 0; q < length5; q++) {
        while (z[k + 1] < q)
          k++;
        r = v[k];
        grid[offset + q * stride] = f[r] + (q - r) * (q - r);
      }
    }
  }
});

// node_modules/hammerjs/hammer.js
var require_hammer = __commonJS({
  "node_modules/hammerjs/hammer.js"(exports, module) {
    (function(window2, document2, exportName, undefined2) {
      "use strict";
      var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
      var TEST_ELEMENT = document2.createElement("div");
      var TYPE_FUNCTION = "function";
      var round4 = Math.round;
      var abs = Math.abs;
      var now2 = Date.now;
      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }
      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
        }
        return false;
      }
      function each(obj, iterator2, context) {
        var i2;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator2, context);
        } else if (obj.length !== undefined2) {
          i2 = 0;
          while (i2 < obj.length) {
            iterator2.call(context, obj[i2], i2, obj);
            i2++;
          }
        } else {
          for (i2 in obj) {
            obj.hasOwnProperty(i2) && iterator2.call(context, obj[i2], i2, obj);
          }
        }
      }
      function deprecate(method, name, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
        return function() {
          var e = new Error("get-stack-trace");
          var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
          var log = window2.console && (window2.console.warn || window2.console.log);
          if (log) {
            log.call(window2.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
        };
      }
      var assign;
      if (typeof Object.assign !== "function") {
        assign = function assign2(target) {
          if (target === undefined2 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined2 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }
          return output;
        };
      } else {
        assign = Object.assign;
      }
      var extend3 = deprecate(function extend4(dest, src, merge4) {
        var keys = Object.keys(src);
        var i2 = 0;
        while (i2 < keys.length) {
          if (!merge4 || merge4 && dest[keys[i2]] === undefined2) {
            dest[keys[i2]] = src[keys[i2]];
          }
          i2++;
        }
        return dest;
      }, "extend", "Use `assign`.");
      var merge3 = deprecate(function merge4(dest, src) {
        return extend3(dest, src, true);
      }, "merge", "Use `assign`.");
      function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          assign(childP, properties);
        }
      }
      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }
      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined2 : undefined2, args);
        }
        return val;
      }
      function ifUndefined(val1, val2) {
        return val1 === undefined2 ? val2 : val1;
      }
      function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
        });
      }
      function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
        });
      }
      function hasParent(node, parent) {
        while (node) {
          if (node == parent) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      }
      function inStr(str6, find) {
        return str6.indexOf(find) > -1;
      }
      function splitStr(str6) {
        return str6.trim().split(/\s+/g);
      }
      function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find);
        } else {
          var i2 = 0;
          while (i2 < src.length) {
            if (findByKey && src[i2][findByKey] == find || !findByKey && src[i2] === find) {
              return i2;
            }
            i2++;
          }
          return -1;
        }
      }
      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i2 = 0;
        while (i2 < src.length) {
          var val = key ? src[i2][key] : src[i2];
          if (inArray(values, val) < 0) {
            results.push(src[i2]);
          }
          values[i2] = val;
          i2++;
        }
        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a, b) {
              return a[key] > b[key];
            });
          }
        }
        return results;
      }
      function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i2 = 0;
        while (i2 < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i2];
          prop = prefix ? prefix + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i2++;
        }
        return undefined2;
      }
      var _uniqueId = 1;
      function uniqueId3() {
        return _uniqueId++;
      }
      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window2;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = "ontouchstart" in window2;
      var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = "touch";
      var INPUT_TYPE_PEN = "pen";
      var INPUT_TYPE_MOUSE = "mouse";
      var INPUT_TYPE_KINECT = "kinect";
      var COMPUTE_INTERVAL = 25;
      var INPUT_START = 1;
      var INPUT_MOVE = 2;
      var INPUT_END = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ["x", "y"];
      var PROPS_CLIENT_XY = ["clientX", "clientY"];
      function Input(manager, callback) {
        var self2 = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self2.handler(ev);
          }
        };
        this.init();
      }
      Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {
        },
        /**
         * bind the events
         */
        init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
        } else {
          Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
      }
      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }
      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now2();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle2(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation2(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }
        input.target = target;
      }
      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
      }
      function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }
      function simpleCloneInputData(input) {
        var pointers = [];
        var i2 = 0;
        while (i2 < input.pointers.length) {
          pointers[i2] = {
            clientX: round4(input.pointers[i2].clientX),
            clientY: round4(input.pointers[i2].clientY)
          };
          i2++;
        }
        return {
          timeStamp: now2(),
          pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }
      function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
          return {
            x: round4(pointers[0].clientX),
            y: round4(pointers[0].clientY)
          };
        }
        var x2 = 0, y = 0, i2 = 0;
        while (i2 < pointersLength) {
          x2 += pointers[i2].clientX;
          y += pointers[i2].clientY;
          i2++;
        }
        return {
          x: round4(x2 / pointersLength),
          y: round4(y / pointersLength)
        };
      }
      function getVelocity(deltaTime, x2, y) {
        return {
          x: x2 / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }
      function getDirection(x2, y) {
        if (x2 === y) {
          return DIRECTION_NONE;
        }
        if (abs(x2) >= abs(y)) {
          return x2 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x2 = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x2 * x2 + y * y);
      }
      function getAngle2(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x2 = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x2) * 180 / Math.PI;
      }
      function getRotation2(start, end) {
        return getAngle2(end[1], end[0], PROPS_CLIENT_XY) + getAngle2(start[1], start[0], PROPS_CLIENT_XY);
      }
      function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
      };
      var MOUSE_ELEMENT_EVENTS = "mousedown";
      var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
      function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false;
        Input.apply(this, arguments);
      }
      inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];
          if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
          }
          if (!this.pressed) {
            return;
          }
          if (eventType & INPUT_END) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
        // see https://twitter.com/jacobrossi/status/480596438489890816
      };
      var POINTER_ELEMENT_EVENTS = "pointerdown";
      var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
      if (window2.MSPointerEvent && !window2.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
      }
      function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH;
          var storeIndex = inArray(store, ev.pointerId, "pointerId");
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
          }
          if (storeIndex < 0) {
            return;
          }
          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
      var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
          if (type === INPUT_START) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), "identifier", true);
        }
        return [all, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
      }
      inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i2, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
        });
        if (type === INPUT_START) {
          i2 = 0;
          while (i2 < targetTouches.length) {
            targetIds[targetTouches[i2].identifier] = true;
            i2++;
          }
        }
        i2 = 0;
        while (i2 < changedTouches.length) {
          if (targetIds[changedTouches[i2].identifier]) {
            changedTargetTouches.push(changedTouches[i2]);
          }
          if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i2].identifier];
          }
          i2++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
          changedTargetTouches
        ];
      }
      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;
      function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }
      inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          }
          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }
          this.callback(manager, inputEvent, inputData);
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }
      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
          var lastTouch = { x: touch.clientX, y: touch.clientY };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
            var i2 = lts.indexOf(lastTouch);
            if (i2 > -1) {
              lts.splice(i2, 1);
            }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }
      function isSyntheticEvent(eventData) {
        var x2 = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i2 = 0; i2 < this.lastTouches.length; i2++) {
          var t = this.lastTouches[i2];
          var dx = Math.abs(x2 - t.x), dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }
        return false;
      }
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
      var TOUCH_ACTION_COMPUTE = "compute";
      var TOUCH_ACTION_AUTO = "auto";
      var TOUCH_ACTION_MANIPULATION = "manipulation";
      var TOUCH_ACTION_NONE = "none";
      var TOUCH_ACTION_PAN_X = "pan-x";
      var TOUCH_ACTION_PAN_Y = "pan-y";
      var TOUCH_ACTION_MAP = getTouchActionProps();
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }
          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(" "));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
          if (hasNone) {
            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }
          if (hasPanX && hasPanY) {
            return;
          }
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        }
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }
        var touchMap = {};
        var cssSupports = window2.CSS && window2.CSS.supports;
        ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
          touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
      }
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId3();
        this.manager = null;
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
          assign(this.options, options);
          this.manager && this.manager.touchAction.update();
          return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
            this.requireFail.splice(index, 1);
          }
          return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
          var self2 = this;
          var state = this.state;
          function emit(event) {
            self2.manager.emit(event, input);
          }
          if (state < STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
          emit(self2.options.event);
          if (input.additionalEvent) {
            emit(input.additionalEvent);
          }
          if (state >= STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
          if (this.canEmit()) {
            return this.emit(input);
          }
          this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
          var i2 = 0;
          while (i2 < this.requireFail.length) {
            if (!(this.requireFail[i2].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i2++;
          }
          return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var inputDataClone = assign({}, inputData);
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) {
        },
        // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {
        },
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {
        }
      };
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return "cancel";
        } else if (state & STATE_ENDED) {
          return "end";
        } else if (state & STATE_CHANGED) {
          return "move";
        } else if (state & STATE_BEGAN) {
          return "start";
        }
        return "";
      }
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return "down";
        } else if (direction == DIRECTION_UP) {
          return "up";
        } else if (direction == DIRECTION_LEFT) {
          return "left";
        } else if (direction == DIRECTION_RIGHT) {
          return "right";
        }
        return "";
      }
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance4 = input.distance;
          var direction = input.direction;
          var x2 = input.deltaX;
          var y = input.deltaY;
          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x2 === 0 ? DIRECTION_NONE : x2 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x2 != this.pX;
              distance4 = Math.abs(input.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance4 = Math.abs(input.deltaY);
            }
          }
          input.direction = direction;
          return hasMoved && distance4 > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);
          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
        }
      });
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? "in" : "out";
            input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
        }
      });
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9
          // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;
          this._input = input;
          if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input && input.eventType & INPUT_END) {
            this.manager.emit(this.options.event + "up", input);
          } else {
            this._input.timeStamp = now2();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }
          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this.manager.emit(this.options.event, input);
        }
      });
      function TapRecognizer2() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer2, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
          // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;
          this.reset();
          if (input.eventType & INPUT_START && this.count === 0) {
            return this.failTimeout();
          }
          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input;
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function() {
          this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function Hammer2(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer2.defaults.preset);
        return new Manager(element, options);
      }
      Hammer2.VERSION = "2.0.7";
      Hammer2.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, { enable: false }],
          [PinchRecognizer, { enable: false }, ["rotate"]],
          [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
          [TapRecognizer2],
          [TapRecognizer2, { event: "doubletap", taps: 2 }, ["tap"]],
          [PressRecognizer]
        ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: "none",
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: "none",
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: "none",
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: "none",
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: "none",
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      function Manager(element, options) {
        this.options = assign({}, Hammer2.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
          assign(this.options, options);
          if (options.touchAction) {
            this.touchAction.update();
          }
          if (options.inputTarget) {
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }
          return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;
          var curRecognizer = session.curRecognizer;
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i2 = 0;
          while (i2 < recognizers.length) {
            recognizer = recognizers[i2];
            if (session.stopped !== FORCED_STOP && // 1
            (!curRecognizer || recognizer == curRecognizer || // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i2++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i2 = 0; i2 < recognizers.length; i2++) {
            if (recognizers[i2].options.event == recognizer) {
              return recognizers[i2];
            }
          }
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
          if (invokeArrayArg(recognizer, "add", this)) {
            return this;
          }
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
          if (invokeArrayArg(recognizer, "remove", this)) {
            return this;
          }
          recognizer = this.get(recognizer);
          if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);
            if (index !== -1) {
              recognizers.splice(index, 1);
              this.touchAction.update();
            }
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          if (handler === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
          });
          return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          }
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data.type = event;
          data.preventDefault = function() {
            data.srcEvent.preventDefault();
          };
          var i2 = 0;
          while (i2 < handlers.length) {
            handlers[i2](data);
            i2++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      function toggleCssProps(manager, add6) {
        var element = manager.element;
        if (!element.style) {
          return;
        }
        var prop;
        each(manager.options.cssProps, function(value, name) {
          prop = prefixed(element.style, name);
          if (add6) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || "";
          }
        });
        if (!add6) {
          manager.oldCssProps = {};
        }
      }
      function triggerDomEvent(event, data) {
        var gestureEvent = document2.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }
      assign(Hammer2, {
        INPUT_START,
        INPUT_MOVE,
        INPUT_END,
        INPUT_CANCEL,
        STATE_POSSIBLE,
        STATE_BEGAN,
        STATE_CHANGED,
        STATE_ENDED,
        STATE_RECOGNIZED,
        STATE_CANCELLED,
        STATE_FAILED,
        DIRECTION_NONE,
        DIRECTION_LEFT,
        DIRECTION_RIGHT,
        DIRECTION_UP,
        DIRECTION_DOWN,
        DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL,
        DIRECTION_ALL,
        Manager,
        Input,
        TouchAction,
        TouchInput,
        MouseInput,
        PointerEventInput,
        TouchMouseInput,
        SingleTouchInput,
        Recognizer,
        AttrRecognizer,
        Tap: TapRecognizer2,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each,
        merge: merge3,
        extend: extend3,
        assign,
        inherit,
        bindFn,
        prefixed
      });
      var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
      freeGlobal.Hammer = Hammer2;
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Hammer2;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = Hammer2;
      } else {
        window2[exportName] = Hammer2;
      }
    })(window, document, "Hammer");
  }
});

// node_modules/element-resize-detector/src/collection-utils.js
var require_collection_utils = __commonJS({
  "node_modules/element-resize-detector/src/collection-utils.js"(exports, module) {
    "use strict";
    var utils = module.exports = {};
    utils.forEach = function(collection, callback) {
      for (var i2 = 0; i2 < collection.length; i2++) {
        var result = callback(collection[i2]);
        if (result) {
          return result;
        }
      }
    };
  }
});

// node_modules/element-resize-detector/src/element-utils.js
var require_element_utils = __commonJS({
  "node_modules/element-resize-detector/src/element-utils.js"(exports, module) {
    "use strict";
    module.exports = function(options) {
      var getState = options.stateHandler.getState;
      function isDetectable(element) {
        var state = getState(element);
        return state && !!state.isDetectable;
      }
      function markAsDetectable(element) {
        getState(element).isDetectable = true;
      }
      function isBusy(element) {
        return !!getState(element).busy;
      }
      function markBusy(element, busy) {
        getState(element).busy = !!busy;
      }
      return {
        isDetectable,
        markAsDetectable,
        isBusy,
        markBusy
      };
    };
  }
});

// node_modules/element-resize-detector/src/listener-handler.js
var require_listener_handler = __commonJS({
  "node_modules/element-resize-detector/src/listener-handler.js"(exports, module) {
    "use strict";
    module.exports = function(idHandler) {
      var eventListeners = {};
      function getListeners(element) {
        var id2 = idHandler.get(element);
        if (id2 === void 0) {
          return [];
        }
        return eventListeners[id2] || [];
      }
      function addListener(element, listener) {
        var id2 = idHandler.get(element);
        if (!eventListeners[id2]) {
          eventListeners[id2] = [];
        }
        eventListeners[id2].push(listener);
      }
      function removeListener(element, listener) {
        var listeners = getListeners(element);
        for (var i2 = 0, len4 = listeners.length; i2 < len4; ++i2) {
          if (listeners[i2] === listener) {
            listeners.splice(i2, 1);
            break;
          }
        }
      }
      function removeAllListeners(element) {
        var listeners = getListeners(element);
        if (!listeners) {
          return;
        }
        listeners.length = 0;
      }
      return {
        get: getListeners,
        add: addListener,
        removeListener,
        removeAllListeners
      };
    };
  }
});

// node_modules/element-resize-detector/src/id-generator.js
var require_id_generator = __commonJS({
  "node_modules/element-resize-detector/src/id-generator.js"(exports, module) {
    "use strict";
    module.exports = function() {
      var idCount = 1;
      function generate() {
        return idCount++;
      }
      return {
        generate
      };
    };
  }
});

// node_modules/element-resize-detector/src/id-handler.js
var require_id_handler = __commonJS({
  "node_modules/element-resize-detector/src/id-handler.js"(exports, module) {
    "use strict";
    module.exports = function(options) {
      var idGenerator = options.idGenerator;
      var getState = options.stateHandler.getState;
      function getId(element) {
        var state = getState(element);
        if (state && state.id !== void 0) {
          return state.id;
        }
        return null;
      }
      function setId(element) {
        var state = getState(element);
        if (!state) {
          throw new Error("setId required the element to have a resize detection state.");
        }
        var id2 = idGenerator.generate();
        state.id = id2;
        return id2;
      }
      return {
        get: getId,
        set: setId
      };
    };
  }
});

// node_modules/element-resize-detector/src/reporter.js
var require_reporter = __commonJS({
  "node_modules/element-resize-detector/src/reporter.js"(exports, module) {
    "use strict";
    module.exports = function(quiet) {
      function noop() {
      }
      var reporter = {
        log: noop,
        warn: noop,
        error: noop
      };
      if (!quiet && window.console) {
        var attachFunction = function(reporter2, name) {
          reporter2[name] = function reporterProxy() {
            var f = console[name];
            if (f.apply) {
              f.apply(console, arguments);
            } else {
              for (var i2 = 0; i2 < arguments.length; i2++) {
                f(arguments[i2]);
              }
            }
          };
        };
        attachFunction(reporter, "log");
        attachFunction(reporter, "warn");
        attachFunction(reporter, "error");
      }
      return reporter;
    };
  }
});

// node_modules/element-resize-detector/src/browser-detector.js
var require_browser_detector = __commonJS({
  "node_modules/element-resize-detector/src/browser-detector.js"(exports, module) {
    "use strict";
    var detector = module.exports = {};
    detector.isIE = function(version) {
      function isAnyIeVersion() {
        var agent = navigator.userAgent.toLowerCase();
        return agent.indexOf("msie") !== -1 || agent.indexOf("trident") !== -1 || agent.indexOf(" edge/") !== -1;
      }
      if (!isAnyIeVersion()) {
        return false;
      }
      if (!version) {
        return true;
      }
      var ieVersion = function() {
        var undef, v = 3, div4 = document.createElement("div"), all = div4.getElementsByTagName("i");
        do {
          div4.innerHTML = "<!--[if gt IE " + ++v + "]><i></i><![endif]-->";
        } while (all[0]);
        return v > 4 ? v : undef;
      }();
      return version === ieVersion;
    };
    detector.isLegacyOpera = function() {
      return !!window.opera;
    };
  }
});

// node_modules/batch-processor/src/utils.js
var require_utils = __commonJS({
  "node_modules/batch-processor/src/utils.js"(exports, module) {
    "use strict";
    var utils = module.exports = {};
    utils.getOption = getOption;
    function getOption(options, name, defaultValue2) {
      var value = options[name];
      if ((value === void 0 || value === null) && defaultValue2 !== void 0) {
        return defaultValue2;
      }
      return value;
    }
  }
});

// node_modules/batch-processor/src/batch-processor.js
var require_batch_processor = __commonJS({
  "node_modules/batch-processor/src/batch-processor.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function batchProcessorMaker(options) {
      options = options || {};
      var reporter = options.reporter;
      var asyncProcess = utils.getOption(options, "async", true);
      var autoProcess = utils.getOption(options, "auto", true);
      if (autoProcess && !asyncProcess) {
        reporter && reporter.warn("Invalid options combination. auto=true and async=false is invalid. Setting async=true.");
        asyncProcess = true;
      }
      var batch = Batch();
      var asyncFrameHandler;
      var isProcessing = false;
      function addFunction(level, fn) {
        if (!isProcessing && autoProcess && asyncProcess && batch.size() === 0) {
          processBatchAsync();
        }
        batch.add(level, fn);
      }
      function processBatch() {
        isProcessing = true;
        while (batch.size()) {
          var processingBatch = batch;
          batch = Batch();
          processingBatch.process();
        }
        isProcessing = false;
      }
      function forceProcessBatch(localAsyncProcess) {
        if (isProcessing) {
          return;
        }
        if (localAsyncProcess === void 0) {
          localAsyncProcess = asyncProcess;
        }
        if (asyncFrameHandler) {
          cancelFrame(asyncFrameHandler);
          asyncFrameHandler = null;
        }
        if (localAsyncProcess) {
          processBatchAsync();
        } else {
          processBatch();
        }
      }
      function processBatchAsync() {
        asyncFrameHandler = requestFrame(processBatch);
      }
      function clearBatch() {
        batch = {};
        batchSize = 0;
        topLevel = 0;
        bottomLevel = 0;
      }
      function cancelFrame(listener) {
        var cancel = clearTimeout;
        return cancel(listener);
      }
      function requestFrame(callback) {
        var raf = function(fn) {
          return setTimeout(fn, 0);
        };
        return raf(callback);
      }
      return {
        add: addFunction,
        force: forceProcessBatch
      };
    };
    function Batch() {
      var batch = {};
      var size = 0;
      var topLevel2 = 0;
      var bottomLevel2 = 0;
      function add6(level, fn) {
        if (!fn) {
          fn = level;
          level = 0;
        }
        if (level > topLevel2) {
          topLevel2 = level;
        } else if (level < bottomLevel2) {
          bottomLevel2 = level;
        }
        if (!batch[level]) {
          batch[level] = [];
        }
        batch[level].push(fn);
        size++;
      }
      function process2() {
        for (var level = bottomLevel2; level <= topLevel2; level++) {
          var fns = batch[level];
          for (var i2 = 0; i2 < fns.length; i2++) {
            var fn = fns[i2];
            fn();
          }
        }
      }
      function getSize() {
        return size;
      }
      return {
        add: add6,
        process: process2,
        size: getSize
      };
    }
  }
});

// node_modules/element-resize-detector/src/state-handler.js
var require_state_handler = __commonJS({
  "node_modules/element-resize-detector/src/state-handler.js"(exports, module) {
    "use strict";
    var prop = "_erd";
    function initState(element) {
      element[prop] = {};
      return getState(element);
    }
    function getState(element) {
      return element[prop];
    }
    function cleanState(element) {
      delete element[prop];
    }
    module.exports = {
      initState,
      getState,
      cleanState
    };
  }
});

// node_modules/element-resize-detector/src/detection-strategy/object.js
var require_object = __commonJS({
  "node_modules/element-resize-detector/src/detection-strategy/object.js"(exports, module) {
    "use strict";
    var browserDetector = require_browser_detector();
    module.exports = function(options) {
      options = options || {};
      var reporter = options.reporter;
      var batchProcessor = options.batchProcessor;
      var getState = options.stateHandler.getState;
      if (!reporter) {
        throw new Error("Missing required dependency: reporter.");
      }
      function addListener(element, listener) {
        function listenerProxy() {
          listener(element);
        }
        if (browserDetector.isIE(8)) {
          getState(element).object = {
            proxy: listenerProxy
          };
          element.attachEvent("onresize", listenerProxy);
        } else {
          var object = getObject(element);
          if (!object) {
            throw new Error("Element is not detectable by this strategy.");
          }
          object.contentDocument.defaultView.addEventListener("resize", listenerProxy);
        }
      }
      function buildCssTextString(rules) {
        var seperator = options.important ? " !important; " : "; ";
        return (rules.join(seperator) + seperator).trim();
      }
      function makeDetectable(options2, element, callback) {
        if (!callback) {
          callback = element;
          element = options2;
          options2 = null;
        }
        options2 = options2 || {};
        var debug = options2.debug;
        function injectObject(element2, callback2) {
          var OBJECT_STYLE = buildCssTextString(["display: block", "position: absolute", "top: 0", "left: 0", "width: 100%", "height: 100%", "border: none", "padding: 0", "margin: 0", "opacity: 0", "z-index: -1000", "pointer-events: none"]);
          var positionCheckPerformed = false;
          var style = window.getComputedStyle(element2);
          var width = element2.offsetWidth;
          var height = element2.offsetHeight;
          getState(element2).startSize = {
            width,
            height
          };
          function mutateDom() {
            function alterPositionStyles() {
              if (style.position === "static") {
                element2.style.setProperty("position", "relative", options2.important ? "important" : "");
                var removeRelativeStyles = function(reporter2, element3, style2, property) {
                  function getNumericalValue(value2) {
                    return value2.replace(/[^-\d\.]/g, "");
                  }
                  var value = style2[property];
                  if (value !== "auto" && getNumericalValue(value) !== "0") {
                    reporter2.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element3);
                    element3.style.setProperty(property, "0", options2.important ? "important" : "");
                  }
                };
                removeRelativeStyles(reporter, element2, style, "top");
                removeRelativeStyles(reporter, element2, style, "right");
                removeRelativeStyles(reporter, element2, style, "bottom");
                removeRelativeStyles(reporter, element2, style, "left");
              }
            }
            function onObjectLoad() {
              if (!positionCheckPerformed) {
                alterPositionStyles();
              }
              function getDocument(element3, callback3) {
                if (!element3.contentDocument) {
                  var state = getState(element3);
                  if (state.checkForObjectDocumentTimeoutId) {
                    window.clearTimeout(state.checkForObjectDocumentTimeoutId);
                  }
                  state.checkForObjectDocumentTimeoutId = setTimeout(function checkForObjectDocument() {
                    state.checkForObjectDocumentTimeoutId = 0;
                    getDocument(element3, callback3);
                  }, 100);
                  return;
                }
                callback3(element3.contentDocument);
              }
              var objectElement = this;
              getDocument(objectElement, function onObjectDocumentReady(objectDocument) {
                callback2(element2);
              });
            }
            if (style.position !== "") {
              alterPositionStyles(style);
              positionCheckPerformed = true;
            }
            var object = document.createElement("object");
            object.style.cssText = OBJECT_STYLE;
            object.tabIndex = -1;
            object.type = "text/html";
            object.setAttribute("aria-hidden", "true");
            object.onload = onObjectLoad;
            if (!browserDetector.isIE()) {
              object.data = "about:blank";
            }
            if (!getState(element2)) {
              return;
            }
            element2.appendChild(object);
            getState(element2).object = object;
            if (browserDetector.isIE()) {
              object.data = "about:blank";
            }
          }
          if (batchProcessor) {
            batchProcessor.add(mutateDom);
          } else {
            mutateDom();
          }
        }
        if (browserDetector.isIE(8)) {
          callback(element);
        } else {
          injectObject(element, callback);
        }
      }
      function getObject(element) {
        return getState(element).object;
      }
      function uninstall(element) {
        if (!getState(element)) {
          return;
        }
        var object = getObject(element);
        if (!object) {
          return;
        }
        if (browserDetector.isIE(8)) {
          element.detachEvent("onresize", object.proxy);
        } else {
          element.removeChild(object);
        }
        if (getState(element).checkForObjectDocumentTimeoutId) {
          window.clearTimeout(getState(element).checkForObjectDocumentTimeoutId);
        }
        delete getState(element).object;
      }
      return {
        makeDetectable,
        addListener,
        uninstall
      };
    };
  }
});

// node_modules/element-resize-detector/src/detection-strategy/scroll.js
var require_scroll = __commonJS({
  "node_modules/element-resize-detector/src/detection-strategy/scroll.js"(exports, module) {
    "use strict";
    var forEach4 = require_collection_utils().forEach;
    module.exports = function(options) {
      options = options || {};
      var reporter = options.reporter;
      var batchProcessor = options.batchProcessor;
      var getState = options.stateHandler.getState;
      var hasState = options.stateHandler.hasState;
      var idHandler = options.idHandler;
      if (!batchProcessor) {
        throw new Error("Missing required dependency: batchProcessor");
      }
      if (!reporter) {
        throw new Error("Missing required dependency: reporter.");
      }
      var scrollbarSizes = getScrollbarSizes();
      var styleId = "erd_scroll_detection_scrollbar_style";
      var detectionContainerClass = "erd_scroll_detection_container";
      function initDocument(targetDocument) {
        injectScrollStyle(targetDocument, styleId, detectionContainerClass);
      }
      initDocument(window.document);
      function buildCssTextString(rules) {
        var seperator = options.important ? " !important; " : "; ";
        return (rules.join(seperator) + seperator).trim();
      }
      function getScrollbarSizes() {
        var width = 500;
        var height = 500;
        var child = document.createElement("div");
        child.style.cssText = buildCssTextString(["position: absolute", "width: " + width * 2 + "px", "height: " + height * 2 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);
        var container = document.createElement("div");
        container.style.cssText = buildCssTextString(["position: absolute", "width: " + width + "px", "height: " + height + "px", "overflow: scroll", "visibility: none", "top: " + -width * 3 + "px", "left: " + -height * 3 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);
        container.appendChild(child);
        document.body.insertBefore(container, document.body.firstChild);
        var widthSize = width - container.clientWidth;
        var heightSize = height - container.clientHeight;
        document.body.removeChild(container);
        return {
          width: widthSize,
          height: heightSize
        };
      }
      function injectScrollStyle(targetDocument, styleId2, containerClass) {
        function injectStyle(style2, method) {
          method = method || function(element) {
            targetDocument.head.appendChild(element);
          };
          var styleElement = targetDocument.createElement("style");
          styleElement.innerHTML = style2;
          styleElement.id = styleId2;
          method(styleElement);
          return styleElement;
        }
        if (!targetDocument.getElementById(styleId2)) {
          var containerAnimationClass = containerClass + "_animation";
          var containerAnimationActiveClass = containerClass + "_animation_active";
          var style = "/* Created by the element-resize-detector library. */\n";
          style += "." + containerClass + " > div::-webkit-scrollbar { " + buildCssTextString(["display: none"]) + " }\n\n";
          style += "." + containerAnimationActiveClass + " { " + buildCssTextString(["-webkit-animation-duration: 0.1s", "animation-duration: 0.1s", "-webkit-animation-name: " + containerAnimationClass, "animation-name: " + containerAnimationClass]) + " }\n";
          style += "@-webkit-keyframes " + containerAnimationClass + " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\n";
          style += "@keyframes " + containerAnimationClass + " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }";
          injectStyle(style);
        }
      }
      function addAnimationClass(element) {
        element.className += " " + detectionContainerClass + "_animation_active";
      }
      function addEvent(el, name, cb) {
        if (el.addEventListener) {
          el.addEventListener(name, cb);
        } else if (el.attachEvent) {
          el.attachEvent("on" + name, cb);
        } else {
          return reporter.error("[scroll] Don't know how to add event listeners.");
        }
      }
      function removeEvent(el, name, cb) {
        if (el.removeEventListener) {
          el.removeEventListener(name, cb);
        } else if (el.detachEvent) {
          el.detachEvent("on" + name, cb);
        } else {
          return reporter.error("[scroll] Don't know how to remove event listeners.");
        }
      }
      function getExpandElement(element) {
        return getState(element).container.childNodes[0].childNodes[0].childNodes[0];
      }
      function getShrinkElement(element) {
        return getState(element).container.childNodes[0].childNodes[0].childNodes[1];
      }
      function addListener(element, listener) {
        var listeners = getState(element).listeners;
        if (!listeners.push) {
          throw new Error("Cannot add listener to an element that is not detectable.");
        }
        getState(element).listeners.push(listener);
      }
      function makeDetectable(options2, element, callback) {
        if (!callback) {
          callback = element;
          element = options2;
          options2 = null;
        }
        options2 = options2 || {};
        function debug() {
          if (options2.debug) {
            var args = Array.prototype.slice.call(arguments);
            args.unshift(idHandler.get(element), "Scroll: ");
            if (reporter.log.apply) {
              reporter.log.apply(null, args);
            } else {
              for (var i2 = 0; i2 < args.length; i2++) {
                reporter.log(args[i2]);
              }
            }
          }
        }
        function isDetached(element2) {
          function isInDocument(element3) {
            var isInShadowRoot = element3.getRootNode && element3.getRootNode().contains(element3);
            return element3 === element3.ownerDocument.body || element3.ownerDocument.body.contains(element3) || isInShadowRoot;
          }
          if (!isInDocument(element2)) {
            return true;
          }
          if (window.getComputedStyle(element2) === null) {
            return true;
          }
          return false;
        }
        function isUnrendered(element2) {
          var container = getState(element2).container.childNodes[0];
          var style = window.getComputedStyle(container);
          return !style.width || style.width.indexOf("px") === -1;
        }
        function getStyle() {
          var elementStyle = window.getComputedStyle(element);
          var style = {};
          style.position = elementStyle.position;
          style.width = element.offsetWidth;
          style.height = element.offsetHeight;
          style.top = elementStyle.top;
          style.right = elementStyle.right;
          style.bottom = elementStyle.bottom;
          style.left = elementStyle.left;
          style.widthCSS = elementStyle.width;
          style.heightCSS = elementStyle.height;
          return style;
        }
        function storeStartSize() {
          var style = getStyle();
          getState(element).startSize = {
            width: style.width,
            height: style.height
          };
          debug("Element start size", getState(element).startSize);
        }
        function initListeners() {
          getState(element).listeners = [];
        }
        function storeStyle() {
          debug("storeStyle invoked.");
          if (!getState(element)) {
            debug("Aborting because element has been uninstalled");
            return;
          }
          var style = getStyle();
          getState(element).style = style;
        }
        function storeCurrentSize(element2, width, height) {
          getState(element2).lastWidth = width;
          getState(element2).lastHeight = height;
        }
        function getExpandChildElement(element2) {
          return getExpandElement(element2).childNodes[0];
        }
        function getWidthOffset() {
          return 2 * scrollbarSizes.width + 1;
        }
        function getHeightOffset() {
          return 2 * scrollbarSizes.height + 1;
        }
        function getExpandWidth(width) {
          return width + 10 + getWidthOffset();
        }
        function getExpandHeight(height) {
          return height + 10 + getHeightOffset();
        }
        function getShrinkWidth(width) {
          return width * 2 + getWidthOffset();
        }
        function getShrinkHeight(height) {
          return height * 2 + getHeightOffset();
        }
        function positionScrollbars(element2, width, height) {
          var expand = getExpandElement(element2);
          var shrink = getShrinkElement(element2);
          var expandWidth = getExpandWidth(width);
          var expandHeight = getExpandHeight(height);
          var shrinkWidth = getShrinkWidth(width);
          var shrinkHeight = getShrinkHeight(height);
          expand.scrollLeft = expandWidth;
          expand.scrollTop = expandHeight;
          shrink.scrollLeft = shrinkWidth;
          shrink.scrollTop = shrinkHeight;
        }
        function injectContainerElement() {
          var container = getState(element).container;
          if (!container) {
            container = document.createElement("div");
            container.className = detectionContainerClass;
            container.style.cssText = buildCssTextString(["visibility: hidden", "display: inline", "width: 0px", "height: 0px", "z-index: -1", "overflow: hidden", "margin: 0", "padding: 0"]);
            getState(element).container = container;
            addAnimationClass(container);
            element.appendChild(container);
            var onAnimationStart = function() {
              getState(element).onRendered && getState(element).onRendered();
            };
            addEvent(container, "animationstart", onAnimationStart);
            getState(element).onAnimationStart = onAnimationStart;
          }
          return container;
        }
        function injectScrollElements() {
          function alterPositionStyles() {
            var style = getState(element).style;
            if (style.position === "static") {
              element.style.setProperty("position", "relative", options2.important ? "important" : "");
              var removeRelativeStyles = function(reporter2, element2, style2, property) {
                function getNumericalValue(value2) {
                  return value2.replace(/[^-\d\.]/g, "");
                }
                var value = style2[property];
                if (value !== "auto" && getNumericalValue(value) !== "0") {
                  reporter2.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element2);
                  element2.style[property] = 0;
                }
              };
              removeRelativeStyles(reporter, element, style, "top");
              removeRelativeStyles(reporter, element, style, "right");
              removeRelativeStyles(reporter, element, style, "bottom");
              removeRelativeStyles(reporter, element, style, "left");
            }
          }
          function getLeftTopBottomRightCssText(left, top, bottom, right) {
            left = !left ? "0" : left + "px";
            top = !top ? "0" : top + "px";
            bottom = !bottom ? "0" : bottom + "px";
            right = !right ? "0" : right + "px";
            return ["left: " + left, "top: " + top, "right: " + right, "bottom: " + bottom];
          }
          debug("Injecting elements");
          if (!getState(element)) {
            debug("Aborting because element has been uninstalled");
            return;
          }
          alterPositionStyles();
          var rootContainer = getState(element).container;
          if (!rootContainer) {
            rootContainer = injectContainerElement();
          }
          var scrollbarWidth = scrollbarSizes.width;
          var scrollbarHeight = scrollbarSizes.height;
          var containerContainerStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%", "left: 0px", "top: 0px"]);
          var containerStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden"].concat(getLeftTopBottomRightCssText(-(1 + scrollbarWidth), -(1 + scrollbarHeight), -scrollbarHeight, -scrollbarWidth)));
          var expandStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]);
          var shrinkStyle = buildCssTextString(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]);
          var expandChildStyle = buildCssTextString(["position: absolute", "left: 0", "top: 0"]);
          var shrinkChildStyle = buildCssTextString(["position: absolute", "width: 200%", "height: 200%"]);
          var containerContainer = document.createElement("div");
          var container = document.createElement("div");
          var expand = document.createElement("div");
          var expandChild = document.createElement("div");
          var shrink = document.createElement("div");
          var shrinkChild = document.createElement("div");
          containerContainer.dir = "ltr";
          containerContainer.style.cssText = containerContainerStyle;
          containerContainer.className = detectionContainerClass;
          container.className = detectionContainerClass;
          container.style.cssText = containerStyle;
          expand.style.cssText = expandStyle;
          expandChild.style.cssText = expandChildStyle;
          shrink.style.cssText = shrinkStyle;
          shrinkChild.style.cssText = shrinkChildStyle;
          expand.appendChild(expandChild);
          shrink.appendChild(shrinkChild);
          container.appendChild(expand);
          container.appendChild(shrink);
          containerContainer.appendChild(container);
          rootContainer.appendChild(containerContainer);
          function onExpandScroll() {
            var state = getState(element);
            if (state && state.onExpand) {
              state.onExpand();
            } else {
              debug("Aborting expand scroll handler: element has been uninstalled");
            }
          }
          function onShrinkScroll() {
            var state = getState(element);
            if (state && state.onShrink) {
              state.onShrink();
            } else {
              debug("Aborting shrink scroll handler: element has been uninstalled");
            }
          }
          addEvent(expand, "scroll", onExpandScroll);
          addEvent(shrink, "scroll", onShrinkScroll);
          getState(element).onExpandScroll = onExpandScroll;
          getState(element).onShrinkScroll = onShrinkScroll;
        }
        function registerListenersAndPositionElements() {
          function updateChildSizes(element2, width, height) {
            var expandChild = getExpandChildElement(element2);
            var expandWidth = getExpandWidth(width);
            var expandHeight = getExpandHeight(height);
            expandChild.style.setProperty("width", expandWidth + "px", options2.important ? "important" : "");
            expandChild.style.setProperty("height", expandHeight + "px", options2.important ? "important" : "");
          }
          function updateDetectorElements(done) {
            var width = element.offsetWidth;
            var height = element.offsetHeight;
            var sizeChanged = width !== getState(element).lastWidth || height !== getState(element).lastHeight;
            debug("Storing current size", width, height);
            storeCurrentSize(element, width, height);
            batchProcessor.add(0, function performUpdateChildSizes() {
              if (!sizeChanged) {
                return;
              }
              if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
              }
              if (!areElementsInjected()) {
                debug("Aborting because element container has not been initialized");
                return;
              }
              if (options2.debug) {
                var w = element.offsetWidth;
                var h = element.offsetHeight;
                if (w !== width || h !== height) {
                  reporter.warn(idHandler.get(element), "Scroll: Size changed before updating detector elements.");
                }
              }
              updateChildSizes(element, width, height);
            });
            batchProcessor.add(1, function updateScrollbars() {
              if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
              }
              if (!areElementsInjected()) {
                debug("Aborting because element container has not been initialized");
                return;
              }
              positionScrollbars(element, width, height);
            });
            if (sizeChanged && done) {
              batchProcessor.add(2, function() {
                if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
                }
                if (!areElementsInjected()) {
                  debug("Aborting because element container has not been initialized");
                  return;
                }
                done();
              });
            }
          }
          function areElementsInjected() {
            return !!getState(element).container;
          }
          function notifyListenersIfNeeded() {
            function isFirstNotify() {
              return getState(element).lastNotifiedWidth === void 0;
            }
            debug("notifyListenersIfNeeded invoked");
            var state = getState(element);
            if (isFirstNotify() && state.lastWidth === state.startSize.width && state.lastHeight === state.startSize.height) {
              return debug("Not notifying: Size is the same as the start size, and there has been no notification yet.");
            }
            if (state.lastWidth === state.lastNotifiedWidth && state.lastHeight === state.lastNotifiedHeight) {
              return debug("Not notifying: Size already notified");
            }
            debug("Current size not notified, notifying...");
            state.lastNotifiedWidth = state.lastWidth;
            state.lastNotifiedHeight = state.lastHeight;
            forEach4(getState(element).listeners, function(listener) {
              listener(element);
            });
          }
          function handleRender() {
            debug("startanimation triggered.");
            if (isUnrendered(element)) {
              debug("Ignoring since element is still unrendered...");
              return;
            }
            debug("Element rendered.");
            var expand = getExpandElement(element);
            var shrink = getShrinkElement(element);
            if (expand.scrollLeft === 0 || expand.scrollTop === 0 || shrink.scrollLeft === 0 || shrink.scrollTop === 0) {
              debug("Scrollbars out of sync. Updating detector elements...");
              updateDetectorElements(notifyListenersIfNeeded);
            }
          }
          function handleScroll() {
            debug("Scroll detected.");
            if (isUnrendered(element)) {
              debug("Scroll event fired while unrendered. Ignoring...");
              return;
            }
            updateDetectorElements(notifyListenersIfNeeded);
          }
          debug("registerListenersAndPositionElements invoked.");
          if (!getState(element)) {
            debug("Aborting because element has been uninstalled");
            return;
          }
          getState(element).onRendered = handleRender;
          getState(element).onExpand = handleScroll;
          getState(element).onShrink = handleScroll;
          var style = getState(element).style;
          updateChildSizes(element, style.width, style.height);
        }
        function finalizeDomMutation() {
          debug("finalizeDomMutation invoked.");
          if (!getState(element)) {
            debug("Aborting because element has been uninstalled");
            return;
          }
          var style = getState(element).style;
          storeCurrentSize(element, style.width, style.height);
          positionScrollbars(element, style.width, style.height);
        }
        function ready() {
          callback(element);
        }
        function install() {
          debug("Installing...");
          initListeners();
          storeStartSize();
          batchProcessor.add(0, storeStyle);
          batchProcessor.add(1, injectScrollElements);
          batchProcessor.add(2, registerListenersAndPositionElements);
          batchProcessor.add(3, finalizeDomMutation);
          batchProcessor.add(4, ready);
        }
        debug("Making detectable...");
        if (isDetached(element)) {
          debug("Element is detached");
          injectContainerElement();
          debug("Waiting until element is attached...");
          getState(element).onRendered = function() {
            debug("Element is now attached");
            install();
          };
        } else {
          install();
        }
      }
      function uninstall(element) {
        var state = getState(element);
        if (!state) {
          return;
        }
        state.onExpandScroll && removeEvent(getExpandElement(element), "scroll", state.onExpandScroll);
        state.onShrinkScroll && removeEvent(getShrinkElement(element), "scroll", state.onShrinkScroll);
        state.onAnimationStart && removeEvent(state.container, "animationstart", state.onAnimationStart);
        state.container && element.removeChild(state.container);
      }
      return {
        makeDetectable,
        addListener,
        uninstall,
        initDocument
      };
    };
  }
});

// node_modules/element-resize-detector/src/element-resize-detector.js
var require_element_resize_detector = __commonJS({
  "node_modules/element-resize-detector/src/element-resize-detector.js"(exports, module) {
    "use strict";
    var forEach4 = require_collection_utils().forEach;
    var elementUtilsMaker = require_element_utils();
    var listenerHandlerMaker = require_listener_handler();
    var idGeneratorMaker = require_id_generator();
    var idHandlerMaker = require_id_handler();
    var reporterMaker = require_reporter();
    var browserDetector = require_browser_detector();
    var batchProcessorMaker = require_batch_processor();
    var stateHandler = require_state_handler();
    var objectStrategyMaker = require_object();
    var scrollStrategyMaker = require_scroll();
    function isCollection(obj) {
      return Array.isArray(obj) || obj.length !== void 0;
    }
    function toArray(collection) {
      if (!Array.isArray(collection)) {
        var array = [];
        forEach4(collection, function(obj) {
          array.push(obj);
        });
        return array;
      } else {
        return collection;
      }
    }
    function isElement(obj) {
      return obj && obj.nodeType === 1;
    }
    module.exports = function(options) {
      options = options || {};
      var idHandler;
      if (options.idHandler) {
        idHandler = {
          get: function(element) {
            return options.idHandler.get(element, true);
          },
          set: options.idHandler.set
        };
      } else {
        var idGenerator = idGeneratorMaker();
        var defaultIdHandler = idHandlerMaker({
          idGenerator,
          stateHandler
        });
        idHandler = defaultIdHandler;
      }
      var reporter = options.reporter;
      if (!reporter) {
        var quiet = reporter === false;
        reporter = reporterMaker(quiet);
      }
      var batchProcessor = getOption(options, "batchProcessor", batchProcessorMaker({ reporter }));
      var globalOptions = {};
      globalOptions.callOnAdd = !!getOption(options, "callOnAdd", true);
      globalOptions.debug = !!getOption(options, "debug", false);
      var eventListenerHandler = listenerHandlerMaker(idHandler);
      var elementUtils = elementUtilsMaker({
        stateHandler
      });
      var detectionStrategy;
      var desiredStrategy = getOption(options, "strategy", "object");
      var importantCssRules = getOption(options, "important", false);
      var strategyOptions = {
        reporter,
        batchProcessor,
        stateHandler,
        idHandler,
        important: importantCssRules
      };
      if (desiredStrategy === "scroll") {
        if (browserDetector.isLegacyOpera()) {
          reporter.warn("Scroll strategy is not supported on legacy Opera. Changing to object strategy.");
          desiredStrategy = "object";
        } else if (browserDetector.isIE(9)) {
          reporter.warn("Scroll strategy is not supported on IE9. Changing to object strategy.");
          desiredStrategy = "object";
        }
      }
      if (desiredStrategy === "scroll") {
        detectionStrategy = scrollStrategyMaker(strategyOptions);
      } else if (desiredStrategy === "object") {
        detectionStrategy = objectStrategyMaker(strategyOptions);
      } else {
        throw new Error("Invalid strategy name: " + desiredStrategy);
      }
      var onReadyCallbacks = {};
      function listenTo(options2, elements, listener) {
        function onResizeCallback(element) {
          var listeners = eventListenerHandler.get(element);
          forEach4(listeners, function callListenerProxy(listener2) {
            listener2(element);
          });
        }
        function addListener(callOnAdd2, element, listener2) {
          eventListenerHandler.add(element, listener2);
          if (callOnAdd2) {
            listener2(element);
          }
        }
        if (!listener) {
          listener = elements;
          elements = options2;
          options2 = {};
        }
        if (!elements) {
          throw new Error("At least one element required.");
        }
        if (!listener) {
          throw new Error("Listener required.");
        }
        if (isElement(elements)) {
          elements = [elements];
        } else if (isCollection(elements)) {
          elements = toArray(elements);
        } else {
          return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
        }
        var elementsReady = 0;
        var callOnAdd = getOption(options2, "callOnAdd", globalOptions.callOnAdd);
        var onReadyCallback = getOption(options2, "onReady", function noop() {
        });
        var debug = getOption(options2, "debug", globalOptions.debug);
        forEach4(elements, function attachListenerToElement(element) {
          if (!stateHandler.getState(element)) {
            stateHandler.initState(element);
            idHandler.set(element);
          }
          var id2 = idHandler.get(element);
          debug && reporter.log("Attaching listener to element", id2, element);
          if (!elementUtils.isDetectable(element)) {
            debug && reporter.log(id2, "Not detectable.");
            if (elementUtils.isBusy(element)) {
              debug && reporter.log(id2, "System busy making it detectable");
              addListener(callOnAdd, element, listener);
              onReadyCallbacks[id2] = onReadyCallbacks[id2] || [];
              onReadyCallbacks[id2].push(function onReady() {
                elementsReady++;
                if (elementsReady === elements.length) {
                  onReadyCallback();
                }
              });
              return;
            }
            debug && reporter.log(id2, "Making detectable...");
            elementUtils.markBusy(element, true);
            return detectionStrategy.makeDetectable({ debug, important: importantCssRules }, element, function onElementDetectable(element2) {
              debug && reporter.log(id2, "onElementDetectable");
              if (stateHandler.getState(element2)) {
                elementUtils.markAsDetectable(element2);
                elementUtils.markBusy(element2, false);
                detectionStrategy.addListener(element2, onResizeCallback);
                addListener(callOnAdd, element2, listener);
                var state = stateHandler.getState(element2);
                if (state && state.startSize) {
                  var width = element2.offsetWidth;
                  var height = element2.offsetHeight;
                  if (state.startSize.width !== width || state.startSize.height !== height) {
                    onResizeCallback(element2);
                  }
                }
                if (onReadyCallbacks[id2]) {
                  forEach4(onReadyCallbacks[id2], function(callback) {
                    callback();
                  });
                }
              } else {
                debug && reporter.log(id2, "Element uninstalled before being detectable.");
              }
              delete onReadyCallbacks[id2];
              elementsReady++;
              if (elementsReady === elements.length) {
                onReadyCallback();
              }
            });
          }
          debug && reporter.log(id2, "Already detecable, adding listener.");
          addListener(callOnAdd, element, listener);
          elementsReady++;
        });
        if (elementsReady === elements.length) {
          onReadyCallback();
        }
      }
      function uninstall(elements) {
        if (!elements) {
          return reporter.error("At least one element is required.");
        }
        if (isElement(elements)) {
          elements = [elements];
        } else if (isCollection(elements)) {
          elements = toArray(elements);
        } else {
          return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
        }
        forEach4(elements, function(element) {
          eventListenerHandler.removeAllListeners(element);
          detectionStrategy.uninstall(element);
          stateHandler.cleanState(element);
        });
      }
      function initDocument(targetDocument) {
        detectionStrategy.initDocument && detectionStrategy.initDocument(targetDocument);
      }
      return {
        listenTo,
        removeListener: eventListenerHandler.removeListener,
        removeAllListeners: eventListenerHandler.removeAllListeners,
        uninstall,
        initDocument
      };
    };
    function getOption(options, name, defaultValue2) {
      var value = options[name];
      if ((value === void 0 || value === null) && defaultValue2 !== void 0) {
        return defaultValue2;
      }
      return value;
    }
  }
});

// node_modules/@mapbox/unitbezier/index.js
var require_unitbezier = __commonJS({
  "node_modules/@mapbox/unitbezier/index.js"(exports, module) {
    "use strict";
    module.exports = UnitBezier2;
    function UnitBezier2(p1x, p1y, p2x, p2y) {
      this.cx = 3 * p1x;
      this.bx = 3 * (p2x - p1x) - this.cx;
      this.ax = 1 - this.cx - this.bx;
      this.cy = 3 * p1y;
      this.by = 3 * (p2y - p1y) - this.cy;
      this.ay = 1 - this.cy - this.by;
      this.p1x = p1x;
      this.p1y = p1y;
      this.p2x = p2x;
      this.p2y = p2y;
    }
    UnitBezier2.prototype = {
      sampleCurveX: function(t) {
        return ((this.ax * t + this.bx) * t + this.cx) * t;
      },
      sampleCurveY: function(t) {
        return ((this.ay * t + this.by) * t + this.cy) * t;
      },
      sampleCurveDerivativeX: function(t) {
        return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
      },
      solveCurveX: function(x2, epsilon) {
        if (epsilon === void 0)
          epsilon = 1e-6;
        if (x2 < 0)
          return 0;
        if (x2 > 1)
          return 1;
        var t = x2;
        for (var i2 = 0; i2 < 8; i2++) {
          var x22 = this.sampleCurveX(t) - x2;
          if (Math.abs(x22) < epsilon)
            return t;
          var d2 = this.sampleCurveDerivativeX(t);
          if (Math.abs(d2) < 1e-6)
            break;
          t = t - x22 / d2;
        }
        var t02 = 0;
        var t12 = 1;
        t = x2;
        for (i2 = 0; i2 < 20; i2++) {
          x22 = this.sampleCurveX(t);
          if (Math.abs(x22 - x2) < epsilon)
            break;
          if (x2 > x22) {
            t02 = t;
          } else {
            t12 = t;
          }
          t = (t12 - t02) * 0.5 + t02;
        }
        return t;
      },
      solve: function(x2, epsilon) {
        return this.sampleCurveY(this.solveCurveX(x2, epsilon));
      }
    };
  }
});

// node_modules/@mapbox/point-geometry/index.js
var require_point_geometry = __commonJS({
  "node_modules/@mapbox/point-geometry/index.js"(exports, module) {
    "use strict";
    module.exports = Point12;
    function Point12(x2, y) {
      this.x = x2;
      this.y = y;
    }
    Point12.prototype = {
      /**
       * Clone this point, returning a new point that can be modified
       * without affecting the old one.
       * @return {Point} the clone
       */
      clone: function() {
        return new Point12(this.x, this.y);
      },
      /**
       * Add this point's x & y coordinates to another point,
       * yielding a new point.
       * @param {Point} p the other point
       * @return {Point} output point
       */
      add: function(p) {
        return this.clone()._add(p);
      },
      /**
       * Subtract this point's x & y coordinates to from point,
       * yielding a new point.
       * @param {Point} p the other point
       * @return {Point} output point
       */
      sub: function(p) {
        return this.clone()._sub(p);
      },
      /**
       * Multiply this point's x & y coordinates by point,
       * yielding a new point.
       * @param {Point} p the other point
       * @return {Point} output point
       */
      multByPoint: function(p) {
        return this.clone()._multByPoint(p);
      },
      /**
       * Divide this point's x & y coordinates by point,
       * yielding a new point.
       * @param {Point} p the other point
       * @return {Point} output point
       */
      divByPoint: function(p) {
        return this.clone()._divByPoint(p);
      },
      /**
       * Multiply this point's x & y coordinates by a factor,
       * yielding a new point.
       * @param {Point} k factor
       * @return {Point} output point
       */
      mult: function(k) {
        return this.clone()._mult(k);
      },
      /**
       * Divide this point's x & y coordinates by a factor,
       * yielding a new point.
       * @param {Point} k factor
       * @return {Point} output point
       */
      div: function(k) {
        return this.clone()._div(k);
      },
      /**
       * Rotate this point around the 0, 0 origin by an angle a,
       * given in radians
       * @param {Number} a angle to rotate around, in radians
       * @return {Point} output point
       */
      rotate: function(a) {
        return this.clone()._rotate(a);
      },
      /**
       * Rotate this point around p point by an angle a,
       * given in radians
       * @param {Number} a angle to rotate around, in radians
       * @param {Point} p Point to rotate around
       * @return {Point} output point
       */
      rotateAround: function(a, p) {
        return this.clone()._rotateAround(a, p);
      },
      /**
       * Multiply this point by a 4x1 transformation matrix
       * @param {Array<Number>} m transformation matrix
       * @return {Point} output point
       */
      matMult: function(m) {
        return this.clone()._matMult(m);
      },
      /**
       * Calculate this point but as a unit vector from 0, 0, meaning
       * that the distance from the resulting point to the 0, 0
       * coordinate will be equal to 1 and the angle from the resulting
       * point to the 0, 0 coordinate will be the same as before.
       * @return {Point} unit vector point
       */
      unit: function() {
        return this.clone()._unit();
      },
      /**
       * Compute a perpendicular point, where the new y coordinate
       * is the old x coordinate and the new x coordinate is the old y
       * coordinate multiplied by -1
       * @return {Point} perpendicular point
       */
      perp: function() {
        return this.clone()._perp();
      },
      /**
       * Return a version of this point with the x & y coordinates
       * rounded to integers.
       * @return {Point} rounded point
       */
      round: function() {
        return this.clone()._round();
      },
      /**
       * Return the magitude of this point: this is the Euclidean
       * distance from the 0, 0 coordinate to this point's x and y
       * coordinates.
       * @return {Number} magnitude
       */
      mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      /**
       * Judge whether this point is equal to another point, returning
       * true or false.
       * @param {Point} other the other point
       * @return {boolean} whether the points are equal
       */
      equals: function(other) {
        return this.x === other.x && this.y === other.y;
      },
      /**
       * Calculate the distance from this point to another point
       * @param {Point} p the other point
       * @return {Number} distance
       */
      dist: function(p) {
        return Math.sqrt(this.distSqr(p));
      },
      /**
       * Calculate the distance from this point to another point,
       * without the square root step. Useful if you're comparing
       * relative distances.
       * @param {Point} p the other point
       * @return {Number} distance
       */
      distSqr: function(p) {
        var dx = p.x - this.x, dy = p.y - this.y;
        return dx * dx + dy * dy;
      },
      /**
       * Get the angle from the 0, 0 coordinate to this point, in radians
       * coordinates.
       * @return {Number} angle
       */
      angle: function() {
        return Math.atan2(this.y, this.x);
      },
      /**
       * Get the angle from this point to another point, in radians
       * @param {Point} b the other point
       * @return {Number} angle
       */
      angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
      },
      /**
       * Get the angle between this point and another point, in radians
       * @param {Point} b the other point
       * @return {Number} angle
       */
      angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
      },
      /*
       * Find the angle of the two vectors, solving the formula for
       * the cross product a x b = |a||b|sin(θ) for θ.
       * @param {Number} x the x-coordinate
       * @param {Number} y the y-coordinate
       * @return {Number} the angle in radians
       */
      angleWithSep: function(x2, y) {
        return Math.atan2(
          this.x * y - this.y * x2,
          this.x * x2 + this.y * y
        );
      },
      _matMult: function(m) {
        var x2 = m[0] * this.x + m[1] * this.y, y = m[2] * this.x + m[3] * this.y;
        this.x = x2;
        this.y = y;
        return this;
      },
      _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
      },
      _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
      },
      _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
      },
      _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
      },
      _multByPoint: function(p) {
        this.x *= p.x;
        this.y *= p.y;
        return this;
      },
      _divByPoint: function(p) {
        this.x /= p.x;
        this.y /= p.y;
        return this;
      },
      _unit: function() {
        this._div(this.mag());
        return this;
      },
      _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
      },
      _rotate: function(angle3) {
        var cos = Math.cos(angle3), sin = Math.sin(angle3), x2 = cos * this.x - sin * this.y, y = sin * this.x + cos * this.y;
        this.x = x2;
        this.y = y;
        return this;
      },
      _rotateAround: function(angle3, p) {
        var cos = Math.cos(angle3), sin = Math.sin(angle3), x2 = p.x + cos * (this.x - p.x) - sin * (this.y - p.y), y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
        this.x = x2;
        this.y = y;
        return this;
      },
      _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      }
    };
    Point12.convert = function(a) {
      if (a instanceof Point12) {
        return a;
      }
      if (Array.isArray(a)) {
        return new Point12(a[0], a[1]);
      }
      return a;
    };
  }
});

// node_modules/mapbox-gl/dist/mapbox-gl.js
var require_mapbox_gl = __commonJS({
  "node_modules/mapbox-gl/dist/mapbox-gl.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.mapboxgl = factory());
    })(exports, function() {
      "use strict";
      var shared, worker, mapboxgl2;
      function define2(_, chunk) {
        if (!shared) {
          shared = chunk;
        } else if (!worker) {
          worker = chunk;
        } else {
          var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
          var sharedChunk = {};
          shared(sharedChunk);
          mapboxgl2 = chunk(sharedChunk);
          if (typeof window !== "undefined") {
            mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
          }
        }
      }
      define2(["exports"], function(t) {
        "use strict";
        function e(t4, e2) {
          return t4(e2 = { exports: {} }, e2.exports), e2.exports;
        }
        var r = n;
        function n(t4, e2, r2, n2) {
          this.cx = 3 * t4, this.bx = 3 * (r2 - t4) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t4, this.p1y = n2, this.p2x = r2, this.p2y = n2;
        }
        n.prototype.sampleCurveX = function(t4) {
          return ((this.ax * t4 + this.bx) * t4 + this.cx) * t4;
        }, n.prototype.sampleCurveY = function(t4) {
          return ((this.ay * t4 + this.by) * t4 + this.cy) * t4;
        }, n.prototype.sampleCurveDerivativeX = function(t4) {
          return (3 * this.ax * t4 + 2 * this.bx) * t4 + this.cx;
        }, n.prototype.solveCurveX = function(t4, e2) {
          var r2, n2, i3, a2, o2;
          for (void 0 === e2 && (e2 = 1e-6), i3 = t4, o2 = 0; o2 < 8; o2++) {
            if (a2 = this.sampleCurveX(i3) - t4, Math.abs(a2) < e2)
              return i3;
            var s2 = this.sampleCurveDerivativeX(i3);
            if (Math.abs(s2) < 1e-6)
              break;
            i3 -= a2 / s2;
          }
          if ((i3 = t4) < (r2 = 0))
            return r2;
          if (i3 > (n2 = 1))
            return n2;
          for (; r2 < n2; ) {
            if (a2 = this.sampleCurveX(i3), Math.abs(a2 - t4) < e2)
              return i3;
            t4 > a2 ? r2 = i3 : n2 = i3, i3 = 0.5 * (n2 - r2) + r2;
          }
          return i3;
        }, n.prototype.solve = function(t4, e2) {
          return this.sampleCurveY(this.solveCurveX(t4, e2));
        };
        var i2 = a;
        function a(t4, e2) {
          this.x = t4, this.y = e2;
        }
        a.prototype = { clone: function() {
          return new a(this.x, this.y);
        }, add: function(t4) {
          return this.clone()._add(t4);
        }, sub: function(t4) {
          return this.clone()._sub(t4);
        }, multByPoint: function(t4) {
          return this.clone()._multByPoint(t4);
        }, divByPoint: function(t4) {
          return this.clone()._divByPoint(t4);
        }, mult: function(t4) {
          return this.clone()._mult(t4);
        }, div: function(t4) {
          return this.clone()._div(t4);
        }, rotate: function(t4) {
          return this.clone()._rotate(t4);
        }, rotateAround: function(t4, e2) {
          return this.clone()._rotateAround(t4, e2);
        }, matMult: function(t4) {
          return this.clone()._matMult(t4);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t4) {
          return this.x === t4.x && this.y === t4.y;
        }, dist: function(t4) {
          return Math.sqrt(this.distSqr(t4));
        }, distSqr: function(t4) {
          var e2 = t4.x - this.x, r2 = t4.y - this.y;
          return e2 * e2 + r2 * r2;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t4) {
          return Math.atan2(this.y - t4.y, this.x - t4.x);
        }, angleWith: function(t4) {
          return this.angleWithSep(t4.x, t4.y);
        }, angleWithSep: function(t4, e2) {
          return Math.atan2(this.x * e2 - this.y * t4, this.x * t4 + this.y * e2);
        }, _matMult: function(t4) {
          var e2 = t4[2] * this.x + t4[3] * this.y;
          return this.x = t4[0] * this.x + t4[1] * this.y, this.y = e2, this;
        }, _add: function(t4) {
          return this.x += t4.x, this.y += t4.y, this;
        }, _sub: function(t4) {
          return this.x -= t4.x, this.y -= t4.y, this;
        }, _mult: function(t4) {
          return this.x *= t4, this.y *= t4, this;
        }, _div: function(t4) {
          return this.x /= t4, this.y /= t4, this;
        }, _multByPoint: function(t4) {
          return this.x *= t4.x, this.y *= t4.y, this;
        }, _divByPoint: function(t4) {
          return this.x /= t4.x, this.y /= t4.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t4 = this.y;
          return this.y = this.x, this.x = -t4, this;
        }, _rotate: function(t4) {
          var e2 = Math.cos(t4), r2 = Math.sin(t4), n2 = r2 * this.x + e2 * this.y;
          return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
        }, _rotateAround: function(t4, e2) {
          var r2 = Math.cos(t4), n2 = Math.sin(t4), i3 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
          return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i3, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, a.convert = function(t4) {
          return t4 instanceof a ? t4 : Array.isArray(t4) ? new a(t4[0], t4[1]) : t4;
        };
        var o = "undefined" != typeof self ? self : {}, s = Math.pow(2, 53) - 1;
        function u(t4, e2, n2, i3) {
          var a2 = new r(t4, e2, n2, i3);
          return function(t5) {
            return a2.solve(t5);
          };
        }
        var l = u(0.25, 0.1, 0.25, 1);
        function p(t4, e2, r2) {
          return Math.min(r2, Math.max(e2, t4));
        }
        function c(t4, e2, r2) {
          var n2 = r2 - e2, i3 = ((t4 - e2) % n2 + n2) % n2 + e2;
          return i3 === e2 ? r2 : i3;
        }
        function h(t4) {
          for (var e2 = [], r2 = arguments.length - 1; r2-- > 0; )
            e2[r2] = arguments[r2 + 1];
          for (var n2 = 0, i3 = e2; n2 < i3.length; n2 += 1) {
            var a2 = i3[n2];
            for (var o2 in a2)
              t4[o2] = a2[o2];
          }
          return t4;
        }
        var f = 1;
        function y() {
          return f++;
        }
        function d() {
          return function t4(e2) {
            return e2 ? (e2 ^ 16 * Math.random() >> e2 / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t4);
          }();
        }
        function m(t4) {
          return !!t4 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t4);
        }
        function v(t4, e2) {
          t4.forEach(function(t5) {
            e2[t5] && (e2[t5] = e2[t5].bind(e2));
          });
        }
        function g(t4, e2) {
          return -1 !== t4.indexOf(e2, t4.length - e2.length);
        }
        function x2(t4, e2, r2) {
          var n2 = {};
          for (var i3 in t4)
            n2[i3] = e2.call(r2 || this, t4[i3], i3, t4);
          return n2;
        }
        function b(t4, e2, r2) {
          var n2 = {};
          for (var i3 in t4)
            e2.call(r2 || this, t4[i3], i3, t4) && (n2[i3] = t4[i3]);
          return n2;
        }
        function w(t4) {
          return Array.isArray(t4) ? t4.map(w) : "object" == typeof t4 && t4 ? x2(t4, w) : t4;
        }
        var _ = {};
        function A2(t4) {
          _[t4] || ("undefined" != typeof console && console.warn(t4), _[t4] = true);
        }
        function S(t4, e2, r2) {
          return (r2.y - t4.y) * (e2.x - t4.x) > (e2.y - t4.y) * (r2.x - t4.x);
        }
        function k(t4) {
          for (var e2 = 0, r2 = 0, n2 = t4.length, i3 = n2 - 1, a2 = void 0, o2 = void 0; r2 < n2; i3 = r2++)
            e2 += ((o2 = t4[i3]).x - (a2 = t4[r2]).x) * (a2.y + o2.y);
          return e2;
        }
        function I() {
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function z(t4) {
          var e2 = {};
          if (t4.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, function(t5, r3, n2, i3) {
            var a2 = n2 || i3;
            return e2[r3] = !a2 || a2.toLowerCase(), "";
          }), e2["max-age"]) {
            var r2 = parseInt(e2["max-age"], 10);
            isNaN(r2) ? delete e2["max-age"] : e2["max-age"] = r2;
          }
          return e2;
        }
        var C2 = null;
        function E2(t4) {
          if (null == C2) {
            var e2 = t4.navigator ? t4.navigator.userAgent : null;
            C2 = !!t4.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
          }
          return C2;
        }
        function P(t4) {
          try {
            var e2 = o[t4];
            return e2.setItem("_mapbox_test_", 1), e2.removeItem("_mapbox_test_"), true;
          } catch (t5) {
            return false;
          }
        }
        var M, B2, T2, V, F = o.performance && o.performance.now ? o.performance.now.bind(o.performance) : Date.now.bind(Date), D2 = o.requestAnimationFrame || o.mozRequestAnimationFrame || o.webkitRequestAnimationFrame || o.msRequestAnimationFrame, L2 = o.cancelAnimationFrame || o.mozCancelAnimationFrame || o.webkitCancelAnimationFrame || o.msCancelAnimationFrame, O = { now: F, frame: function(t4) {
          var e2 = D2(t4);
          return { cancel: function() {
            return L2(e2);
          } };
        }, getImageData: function(t4, e2) {
          void 0 === e2 && (e2 = 0);
          var r2 = o.document.createElement("canvas"), n2 = r2.getContext("2d");
          if (!n2)
            throw new Error("failed to create canvas 2d context");
          return r2.width = t4.width, r2.height = t4.height, n2.drawImage(t4, 0, 0, t4.width, t4.height), n2.getImageData(-e2, -e2, t4.width + 2 * e2, t4.height + 2 * e2);
        }, resolveURL: function(t4) {
          return M || (M = o.document.createElement("a")), M.href = t4, M.href;
        }, hardwareConcurrency: o.navigator && o.navigator.hardwareConcurrency || 4, get devicePixelRatio() {
          return o.devicePixelRatio;
        }, get prefersReducedMotion() {
          return !!o.matchMedia && (null == B2 && (B2 = o.matchMedia("(prefers-reduced-motion: reduce)")), B2.matches);
        } }, R = { API_URL: "https://api.mapbox.com", get EVENTS_URL() {
          return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;
        }, FEEDBACK_URL: "https://apps.mapbox.com/feedback", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, U = { supported: false, testSupport: function(t4) {
          !j && V && (q ? N(t4) : T2 = t4);
        } }, j = false, q = false;
        function N(t4) {
          var e2 = t4.createTexture();
          t4.bindTexture(t4.TEXTURE_2D, e2);
          try {
            if (t4.texImage2D(t4.TEXTURE_2D, 0, t4.RGBA, t4.RGBA, t4.UNSIGNED_BYTE, V), t4.isContextLost())
              return;
            U.supported = true;
          } catch (t5) {
          }
          t4.deleteTexture(e2), j = true;
        }
        o.document && ((V = o.document.createElement("img")).onload = function() {
          T2 && N(T2), T2 = null, q = true;
        }, V.onerror = function() {
          j = true, T2 = null;
        }, V.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        var K2 = "01", G = function(t4, e2) {
          this._transformRequestFn = t4, this._customAccessToken = e2, this._createSkuToken();
        };
        function Z(t4) {
          return 0 === t4.indexOf("mapbox:");
        }
        G.prototype._createSkuToken = function() {
          var t4 = function() {
            for (var t5 = "", e2 = 0; e2 < 10; e2++)
              t5 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", K2, t5].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = t4.token, this._skuTokenExpiresAt = t4.tokenExpiresAt;
        }, G.prototype._isSkuTokenExpired = function() {
          return Date.now() > this._skuTokenExpiresAt;
        }, G.prototype.transformRequest = function(t4, e2) {
          return this._transformRequestFn && this._transformRequestFn(t4, e2) || { url: t4 };
        }, G.prototype.normalizeStyleURL = function(t4, e2) {
          if (!Z(t4))
            return t4;
          var r2 = Y(t4);
          return r2.path = "/styles/v1" + r2.path, this._makeAPIURL(r2, this._customAccessToken || e2);
        }, G.prototype.normalizeGlyphsURL = function(t4, e2) {
          if (!Z(t4))
            return t4;
          var r2 = Y(t4);
          return r2.path = "/fonts/v1" + r2.path, this._makeAPIURL(r2, this._customAccessToken || e2);
        }, G.prototype.normalizeSourceURL = function(t4, e2) {
          if (!Z(t4))
            return t4;
          var r2 = Y(t4);
          return r2.path = "/v4/" + r2.authority + ".json", r2.params.push("secure"), this._makeAPIURL(r2, this._customAccessToken || e2);
        }, G.prototype.normalizeSpriteURL = function(t4, e2, r2, n2) {
          var i3 = Y(t4);
          return Z(t4) ? (i3.path = "/styles/v1" + i3.path + "/sprite" + e2 + r2, this._makeAPIURL(i3, this._customAccessToken || n2)) : (i3.path += "" + e2 + r2, $(i3));
        }, G.prototype.normalizeTileURL = function(t4, e2) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), t4 && !Z(t4))
            return t4;
          var r2 = Y(t4);
          r2.path = r2.path.replace(/(\.(png|jpg)\d*)(?=$)/, (O.devicePixelRatio >= 2 || 512 === e2 ? "@2x" : "") + (U.supported ? ".webp" : "$1")), r2.path = r2.path.replace(/^.+\/v4\//, "/"), r2.path = "/v4" + r2.path;
          var n2 = this._customAccessToken || function(t5) {
            for (var e3 = 0, r3 = t5; e3 < r3.length; e3 += 1) {
              var n3 = r3[e3].match(/^access_token=(.*)$/);
              if (n3)
                return n3[1];
            }
            return null;
          }(r2.params) || R.ACCESS_TOKEN;
          return R.REQUIRE_ACCESS_TOKEN && n2 && this._skuToken && r2.params.push("sku=" + this._skuToken), this._makeAPIURL(r2, n2);
        }, G.prototype.canonicalizeTileURL = function(t4, e2) {
          var r2 = Y(t4);
          if (!r2.path.match(/(^\/v4\/)/) || !r2.path.match(/\.[\w]+$/))
            return t4;
          var n2 = "mapbox://tiles/";
          n2 += r2.path.replace("/v4/", "");
          var i3 = r2.params;
          return e2 && (i3 = i3.filter(function(t5) {
            return !t5.match(/^access_token=/);
          })), i3.length && (n2 += "?" + i3.join("&")), n2;
        }, G.prototype.canonicalizeTileset = function(t4, e2) {
          for (var r2 = !!e2 && Z(e2), n2 = [], i3 = 0, a2 = t4.tiles || []; i3 < a2.length; i3 += 1) {
            var o2 = a2[i3];
            J(o2) ? n2.push(this.canonicalizeTileURL(o2, r2)) : n2.push(o2);
          }
          return n2;
        }, G.prototype._makeAPIURL = function(t4, e2) {
          var r2 = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", n2 = Y(R.API_URL);
          if (t4.protocol = n2.protocol, t4.authority = n2.authority, "http" === t4.protocol) {
            var i3 = t4.params.indexOf("secure");
            i3 >= 0 && t4.params.splice(i3, 1);
          }
          if ("/" !== n2.path && (t4.path = "" + n2.path + t4.path), !R.REQUIRE_ACCESS_TOKEN)
            return $(t4);
          if (!(e2 = e2 || R.ACCESS_TOKEN))
            throw new Error("An API access token is required to use Mapbox GL. " + r2);
          if ("s" === e2[0])
            throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + r2);
          return t4.params = t4.params.filter(function(t5) {
            return -1 === t5.indexOf("access_token");
          }), t4.params.push("access_token=" + e2), $(t4);
        };
        var X = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
        function J(t4) {
          return X.test(t4);
        }
        var H = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function Y(t4) {
          var e2 = t4.match(H);
          if (!e2)
            throw new Error("Unable to parse URL object");
          return { protocol: e2[1], authority: e2[2], path: e2[3] || "/", params: e2[4] ? e2[4].split("&") : [] };
        }
        function $(t4) {
          var e2 = t4.params.length ? "?" + t4.params.join("&") : "";
          return t4.protocol + "://" + t4.authority + t4.path + e2;
        }
        function W(t4) {
          if (!t4)
            return null;
          var e2 = t4.split(".");
          if (!e2 || 3 !== e2.length)
            return null;
          try {
            return JSON.parse(decodeURIComponent(o.atob(e2[1]).split("").map(function(t5) {
              return "%" + ("00" + t5.charCodeAt(0).toString(16)).slice(-2);
            }).join("")));
          } catch (t5) {
            return null;
          }
        }
        var Q = function(t4) {
          this.type = t4, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        };
        Q.prototype.getStorageKey = function(t4) {
          var e2, r2 = W(R.ACCESS_TOKEN);
          return e2 = r2 && r2.u ? o.btoa(encodeURIComponent(r2.u).replace(/%([0-9A-F]{2})/g, function(t5, e3) {
            return String.fromCharCode(Number("0x" + e3));
          })) : R.ACCESS_TOKEN || "", t4 ? "mapbox.eventData." + t4 + ":" + e2 : "mapbox.eventData:" + e2;
        }, Q.prototype.fetchEventData = function() {
          var t4 = P("localStorage"), e2 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
          if (t4)
            try {
              var n2 = o.localStorage.getItem(e2);
              n2 && (this.eventData = JSON.parse(n2));
              var i3 = o.localStorage.getItem(r2);
              i3 && (this.anonId = i3);
            } catch (t5) {
              A2("Unable to read from LocalStorage");
            }
        }, Q.prototype.saveEventData = function() {
          var t4 = P("localStorage"), e2 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
          if (t4)
            try {
              o.localStorage.setItem(r2, this.anonId), Object.keys(this.eventData).length >= 1 && o.localStorage.setItem(e2, JSON.stringify(this.eventData));
            } catch (t5) {
              A2("Unable to write to LocalStorage");
            }
        }, Q.prototype.processRequests = function(t4) {
        }, Q.prototype.postEvent = function(t4, e2, r2, n2) {
          var i3 = this;
          if (R.EVENTS_URL) {
            var a2 = Y(R.EVENTS_URL);
            a2.params.push("access_token=" + (n2 || R.ACCESS_TOKEN || ""));
            var o2 = { event: this.type, created: new Date(t4).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: "1.13.3", skuId: K2, userId: this.anonId }, s2 = e2 ? h(o2, e2) : o2, u2 = { url: $(a2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([s2]) };
            this.pendingRequest = wt(u2, function(t5) {
              i3.pendingRequest = null, r2(t5), i3.saveEventData(), i3.processRequests(n2);
            });
          }
        }, Q.prototype.queueRequest = function(t4, e2) {
          this.queue.push(t4), this.processRequests(e2);
        };
        var tt, et2, rt = function(t4) {
          function e2() {
            t4.call(this, "map.load"), this.success = {}, this.skuToken = "";
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.postMapLoadEvent = function(t5, e3, r2, n2) {
            this.skuToken = r2;
            var i3 = !(!n2 && !R.ACCESS_TOKEN), a2 = Array.isArray(t5) && t5.some(function(t6) {
              return Z(t6) || J(t6);
            });
            R.EVENTS_URL && i3 && a2 && this.queueRequest({ id: e3, timestamp: Date.now() }, n2);
          }, e2.prototype.processRequests = function(t5) {
            var e3 = this;
            if (!this.pendingRequest && 0 !== this.queue.length) {
              var r2 = this.queue.shift(), n2 = r2.id, i3 = r2.timestamp;
              n2 && this.success[n2] || (this.anonId || this.fetchEventData(), m(this.anonId) || (this.anonId = d()), this.postEvent(i3, { skuToken: this.skuToken }, function(t6) {
                t6 || n2 && (e3.success[n2] = true);
              }, t5));
            }
          }, e2;
        }(Q), nt = new (function(t4) {
          function e2(e3) {
            t4.call(this, "appUserTurnstile"), this._customAccessToken = e3;
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.postTurnstileEvent = function(t5, e3) {
            R.EVENTS_URL && R.ACCESS_TOKEN && Array.isArray(t5) && t5.some(function(t6) {
              return Z(t6) || J(t6);
            }) && this.queueRequest(Date.now(), e3);
          }, e2.prototype.processRequests = function(t5) {
            var e3 = this;
            if (!this.pendingRequest && 0 !== this.queue.length) {
              this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
              var r2 = W(R.ACCESS_TOKEN), n2 = r2 ? r2.u : R.ACCESS_TOKEN, i3 = n2 !== this.eventData.tokenU;
              m(this.anonId) || (this.anonId = d(), i3 = true);
              var a2 = this.queue.shift();
              if (this.eventData.lastSuccess) {
                var o2 = new Date(this.eventData.lastSuccess), s2 = new Date(a2), u2 = (a2 - this.eventData.lastSuccess) / 864e5;
                i3 = i3 || u2 >= 1 || u2 < -1 || o2.getDate() !== s2.getDate();
              } else
                i3 = true;
              if (!i3)
                return this.processRequests();
              this.postEvent(a2, { "enabled.telemetry": false }, function(t6) {
                t6 || (e3.eventData.lastSuccess = a2, e3.eventData.tokenU = n2);
              }, t5);
            }
          }, e2;
        }(Q))(), it = nt.postTurnstileEvent.bind(nt), at = new rt(), ot = at.postMapLoadEvent.bind(at), st = 500, ut = 50;
        function lt() {
          o.caches && !tt && (tt = o.caches.open("mapbox-tiles"));
        }
        function pt(t4) {
          var e2 = t4.indexOf("?");
          return e2 < 0 ? t4 : t4.slice(0, e2);
        }
        var ct, ht = 1 / 0;
        function ft() {
          return null == ct && (ct = o.OffscreenCanvas && new o.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof o.createImageBitmap), ct;
        }
        var yt = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
        "function" == typeof Object.freeze && Object.freeze(yt);
        var dt = function(t4) {
          function e2(e3, r2, n2) {
            401 === r2 && J(n2) && (e3 += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), t4.call(this, e3), this.status = r2, this.url = n2, this.name = this.constructor.name, this.message = e3;
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.toString = function() {
            return this.name + ": " + this.message + " (" + this.status + "): " + this.url;
          }, e2;
        }(Error), mt = I() ? function() {
          return self.worker && self.worker.referrer;
        } : function() {
          return ("blob:" === o.location.protocol ? o.parent : o).location.href;
        };
        var vt, gt, xt = function(t4, e2) {
          if (!(/^file:/.test(r2 = t4.url) || /^file:/.test(mt()) && !/^\w+:/.test(r2))) {
            if (o.fetch && o.Request && o.AbortController && o.Request.prototype.hasOwnProperty("signal"))
              return function(t5, e3) {
                var r3, n2 = new o.AbortController(), i3 = new o.Request(t5.url, { method: t5.method || "GET", body: t5.body, credentials: t5.credentials, headers: t5.headers, referrer: mt(), signal: n2.signal }), a2 = false, s2 = false, u2 = (r3 = i3.url).indexOf("sku=") > 0 && J(r3);
                "json" === t5.type && i3.headers.set("Accept", "application/json");
                var l2 = function(r4, n3, a3) {
                  if (!s2) {
                    if (r4 && "SecurityError" !== r4.message && A2(r4), n3 && a3)
                      return p2(n3);
                    var l3 = Date.now();
                    o.fetch(i3).then(function(r5) {
                      if (r5.ok) {
                        var n4 = u2 ? r5.clone() : null;
                        return p2(r5, n4, l3);
                      }
                      return e3(new dt(r5.statusText, r5.status, t5.url));
                    }).catch(function(t6) {
                      20 !== t6.code && e3(new Error(t6.message));
                    });
                  }
                }, p2 = function(r4, n3, u3) {
                  ("arrayBuffer" === t5.type ? r4.arrayBuffer() : "json" === t5.type ? r4.json() : r4.text()).then(function(t6) {
                    s2 || (n3 && u3 && function(t7, e4, r5) {
                      if (lt(), tt) {
                        var n4 = { status: e4.status, statusText: e4.statusText, headers: new o.Headers() };
                        e4.headers.forEach(function(t8, e5) {
                          return n4.headers.set(e5, t8);
                        });
                        var i4 = z(e4.headers.get("Cache-Control") || "");
                        i4["no-store"] || (i4["max-age"] && n4.headers.set("Expires", new Date(r5 + 1e3 * i4["max-age"]).toUTCString()), new Date(n4.headers.get("Expires")).getTime() - r5 < 42e4 || function(t8, e5) {
                          if (void 0 === et2)
                            try {
                              new Response(new ReadableStream()), et2 = true;
                            } catch (t9) {
                              et2 = false;
                            }
                          et2 ? e5(t8.body) : t8.blob().then(e5);
                        }(e4, function(e5) {
                          var r6 = new o.Response(e5, n4);
                          lt(), tt && tt.then(function(e6) {
                            return e6.put(pt(t7.url), r6);
                          }).catch(function(t8) {
                            return A2(t8.message);
                          });
                        }));
                      }
                    }(i3, n3, u3), a2 = true, e3(null, t6, r4.headers.get("Cache-Control"), r4.headers.get("Expires")));
                  }).catch(function(t6) {
                    s2 || e3(new Error(t6.message));
                  });
                };
                return u2 ? function(t6, e4) {
                  if (lt(), !tt)
                    return e4(null);
                  var r4 = pt(t6.url);
                  tt.then(function(t7) {
                    t7.match(r4).then(function(n3) {
                      var i4 = function(t8) {
                        if (!t8)
                          return false;
                        var e5 = new Date(t8.headers.get("Expires") || 0), r5 = z(t8.headers.get("Cache-Control") || "");
                        return e5 > Date.now() && !r5["no-cache"];
                      }(n3);
                      t7.delete(r4), i4 && t7.put(r4, n3.clone()), e4(null, n3, i4);
                    }).catch(e4);
                  }).catch(e4);
                }(i3, l2) : l2(null, null), { cancel: function() {
                  s2 = true, a2 || n2.abort();
                } };
              }(t4, e2);
            if (I() && self.worker && self.worker.actor)
              return self.worker.actor.send("getResource", t4, e2, void 0, true);
          }
          var r2;
          return function(t5, e3) {
            var r3 = new o.XMLHttpRequest();
            for (var n2 in r3.open(t5.method || "GET", t5.url, true), "arrayBuffer" === t5.type && (r3.responseType = "arraybuffer"), t5.headers)
              r3.setRequestHeader(n2, t5.headers[n2]);
            return "json" === t5.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t5.credentials, r3.onerror = function() {
              e3(new Error(r3.statusText));
            }, r3.onload = function() {
              if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
                var n3 = r3.response;
                if ("json" === t5.type)
                  try {
                    n3 = JSON.parse(r3.response);
                  } catch (t6) {
                    return e3(t6);
                  }
                e3(null, n3, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
              } else
                e3(new dt(r3.statusText, r3.status, t5.url));
            }, r3.send(t5.body), { cancel: function() {
              return r3.abort();
            } };
          }(t4, e2);
        }, bt = function(t4, e2) {
          return xt(h(t4, { type: "arrayBuffer" }), e2);
        }, wt = function(t4, e2) {
          return xt(h(t4, { method: "POST" }), e2);
        }, _t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        vt = [], gt = 0;
        var At = function(t4, e2) {
          if (U.supported && (t4.headers || (t4.headers = {}), t4.headers.accept = "image/webp,*/*"), gt >= R.MAX_PARALLEL_IMAGE_REQUESTS) {
            var r2 = { requestParameters: t4, callback: e2, cancelled: false, cancel: function() {
              this.cancelled = true;
            } };
            return vt.push(r2), r2;
          }
          gt++;
          var n2 = false, i3 = function() {
            if (!n2)
              for (n2 = true, gt--; vt.length && gt < R.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                var t5 = vt.shift();
                t5.cancelled || (t5.cancel = At(t5.requestParameters, t5.callback).cancel);
              }
          }, a2 = bt(t4, function(t5, r3, n3, a3) {
            i3(), t5 ? e2(t5) : r3 && (ft() ? function(t6, e3) {
              var r4 = new o.Blob([new Uint8Array(t6)], { type: "image/png" });
              o.createImageBitmap(r4).then(function(t7) {
                e3(null, t7);
              }).catch(function(t7) {
                e3(new Error("Could not load image because of " + t7.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              });
            }(r3, e2) : function(t6, e3, r4, n4) {
              var i4 = new o.Image(), a4 = o.URL;
              i4.onload = function() {
                e3(null, i4), a4.revokeObjectURL(i4.src), i4.onload = null, o.requestAnimationFrame(function() {
                  i4.src = _t;
                });
              }, i4.onerror = function() {
                return e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              };
              var s2 = new o.Blob([new Uint8Array(t6)], { type: "image/png" });
              i4.cacheControl = r4, i4.expires = n4, i4.src = t6.byteLength ? a4.createObjectURL(s2) : _t;
            }(r3, e2, n3, a3));
          });
          return { cancel: function() {
            a2.cancel(), i3();
          } };
        };
        function St(t4, e2, r2) {
          r2[t4] && -1 !== r2[t4].indexOf(e2) || (r2[t4] = r2[t4] || [], r2[t4].push(e2));
        }
        function kt(t4, e2, r2) {
          if (r2 && r2[t4]) {
            var n2 = r2[t4].indexOf(e2);
            -1 !== n2 && r2[t4].splice(n2, 1);
          }
        }
        var It = function(t4, e2) {
          void 0 === e2 && (e2 = {}), h(this, e2), this.type = t4;
        }, zt = function(t4) {
          function e2(e3, r2) {
            void 0 === r2 && (r2 = {}), t4.call(this, "error", h({ error: e3 }, r2));
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2;
        }(It), Ct = function() {
        };
        Ct.prototype.on = function(t4, e2) {
          return this._listeners = this._listeners || {}, St(t4, e2, this._listeners), this;
        }, Ct.prototype.off = function(t4, e2) {
          return kt(t4, e2, this._listeners), kt(t4, e2, this._oneTimeListeners), this;
        }, Ct.prototype.once = function(t4, e2) {
          return this._oneTimeListeners = this._oneTimeListeners || {}, St(t4, e2, this._oneTimeListeners), this;
        }, Ct.prototype.fire = function(t4, e2) {
          "string" == typeof t4 && (t4 = new It(t4, e2 || {}));
          var r2 = t4.type;
          if (this.listens(r2)) {
            t4.target = this;
            for (var n2 = 0, i3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : []; n2 < i3.length; n2 += 1)
              i3[n2].call(this, t4);
            for (var a2 = 0, o2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : []; a2 < o2.length; a2 += 1) {
              var s2 = o2[a2];
              kt(r2, s2, this._oneTimeListeners), s2.call(this, t4);
            }
            var u2 = this._eventedParent;
            u2 && (h(t4, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), u2.fire(t4));
          } else
            t4 instanceof zt && console.error(t4.error);
          return this;
        }, Ct.prototype.listens = function(t4) {
          return this._listeners && this._listeners[t4] && this._listeners[t4].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t4] && this._oneTimeListeners[t4].length > 0 || this._eventedParent && this._eventedParent.listens(t4);
        }, Ct.prototype.setEventedParent = function(t4, e2) {
          return this._eventedParent = t4, this._eventedParentData = e2, this;
        };
        var Et = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: true, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } }, Pt = function(t4, e2, r2, n2) {
          this.message = (t4 ? t4 + ": " : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
        };
        function Mt(t4) {
          var e2 = t4.value;
          return e2 ? [new Pt(t4.key, e2, "constants have been deprecated as of v8")] : [];
        }
        function Bt(t4) {
          for (var e2 = [], r2 = arguments.length - 1; r2-- > 0; )
            e2[r2] = arguments[r2 + 1];
          for (var n2 = 0, i3 = e2; n2 < i3.length; n2 += 1) {
            var a2 = i3[n2];
            for (var o2 in a2)
              t4[o2] = a2[o2];
          }
          return t4;
        }
        function Tt(t4) {
          return t4 instanceof Number || t4 instanceof String || t4 instanceof Boolean ? t4.valueOf() : t4;
        }
        function Vt(t4) {
          if (Array.isArray(t4))
            return t4.map(Vt);
          if (t4 instanceof Object && !(t4 instanceof Number || t4 instanceof String || t4 instanceof Boolean)) {
            var e2 = {};
            for (var r2 in t4)
              e2[r2] = Vt(t4[r2]);
            return e2;
          }
          return Tt(t4);
        }
        var Ft = function(t4) {
          function e2(e3, r2) {
            t4.call(this, r2), this.message = r2, this.key = e3;
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2;
        }(Error), Dt = function(t4, e2) {
          void 0 === e2 && (e2 = []), this.parent = t4, this.bindings = {};
          for (var r2 = 0, n2 = e2; r2 < n2.length; r2 += 1) {
            var i3 = n2[r2];
            this.bindings[i3[0]] = i3[1];
          }
        };
        Dt.prototype.concat = function(t4) {
          return new Dt(this, t4);
        }, Dt.prototype.get = function(t4) {
          if (this.bindings[t4])
            return this.bindings[t4];
          if (this.parent)
            return this.parent.get(t4);
          throw new Error(t4 + " not found in scope.");
        }, Dt.prototype.has = function(t4) {
          return !!this.bindings[t4] || !!this.parent && this.parent.has(t4);
        };
        var Lt = { kind: "null" }, Ot = { kind: "number" }, Rt = { kind: "string" }, Ut = { kind: "boolean" }, jt = { kind: "color" }, qt = { kind: "object" }, Nt = { kind: "value" }, Kt = { kind: "collator" }, Gt = { kind: "formatted" }, Zt = { kind: "resolvedImage" };
        function Xt(t4, e2) {
          return { kind: "array", itemType: t4, N: e2 };
        }
        function Jt(t4) {
          if ("array" === t4.kind) {
            var e2 = Jt(t4.itemType);
            return "number" == typeof t4.N ? "array<" + e2 + ", " + t4.N + ">" : "value" === t4.itemType.kind ? "array" : "array<" + e2 + ">";
          }
          return t4.kind;
        }
        var Ht = [Lt, Ot, Rt, Ut, jt, Gt, qt, Xt(Nt), Zt];
        function Yt(t4, e2) {
          if ("error" === e2.kind)
            return null;
          if ("array" === t4.kind) {
            if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !Yt(t4.itemType, e2.itemType)) && ("number" != typeof t4.N || t4.N === e2.N))
              return null;
          } else {
            if (t4.kind === e2.kind)
              return null;
            if ("value" === t4.kind) {
              for (var r2 = 0, n2 = Ht; r2 < n2.length; r2 += 1)
                if (!Yt(n2[r2], e2))
                  return null;
            }
          }
          return "Expected " + Jt(t4) + " but found " + Jt(e2) + " instead.";
        }
        function $t(t4, e2) {
          return e2.some(function(e3) {
            return e3.kind === t4.kind;
          });
        }
        function Wt(t4, e2) {
          return e2.some(function(e3) {
            return "null" === e3 ? null === t4 : "array" === e3 ? Array.isArray(t4) : "object" === e3 ? t4 && !Array.isArray(t4) && "object" == typeof t4 : e3 === typeof t4;
          });
        }
        var Qt = e(function(t4, e2) {
          var r2 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
          function n2(t5) {
            return (t5 = Math.round(t5)) < 0 ? 0 : t5 > 255 ? 255 : t5;
          }
          function i3(t5) {
            return n2("%" === t5[t5.length - 1] ? parseFloat(t5) / 100 * 255 : parseInt(t5));
          }
          function a2(t5) {
            return (e3 = "%" === t5[t5.length - 1] ? parseFloat(t5) / 100 : parseFloat(t5)) < 0 ? 0 : e3 > 1 ? 1 : e3;
            var e3;
          }
          function o2(t5, e3, r3) {
            return r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1), 6 * r3 < 1 ? t5 + (e3 - t5) * r3 * 6 : 2 * r3 < 1 ? e3 : 3 * r3 < 2 ? t5 + (e3 - t5) * (2 / 3 - r3) * 6 : t5;
          }
          try {
            e2.parseCSSColor = function(t5) {
              var e3, s2 = t5.replace(/ /g, "").toLowerCase();
              if (s2 in r2)
                return r2[s2].slice();
              if ("#" === s2[0])
                return 4 === s2.length ? (e3 = parseInt(s2.substr(1), 16)) >= 0 && e3 <= 4095 ? [(3840 & e3) >> 4 | (3840 & e3) >> 8, 240 & e3 | (240 & e3) >> 4, 15 & e3 | (15 & e3) << 4, 1] : null : 7 === s2.length && (e3 = parseInt(s2.substr(1), 16)) >= 0 && e3 <= 16777215 ? [(16711680 & e3) >> 16, (65280 & e3) >> 8, 255 & e3, 1] : null;
              var u2 = s2.indexOf("("), l2 = s2.indexOf(")");
              if (-1 !== u2 && l2 + 1 === s2.length) {
                var p2 = s2.substr(0, u2), c2 = s2.substr(u2 + 1, l2 - (u2 + 1)).split(","), h2 = 1;
                switch (p2) {
                  case "rgba":
                    if (4 !== c2.length)
                      return null;
                    h2 = a2(c2.pop());
                  case "rgb":
                    return 3 !== c2.length ? null : [i3(c2[0]), i3(c2[1]), i3(c2[2]), h2];
                  case "hsla":
                    if (4 !== c2.length)
                      return null;
                    h2 = a2(c2.pop());
                  case "hsl":
                    if (3 !== c2.length)
                      return null;
                    var f2 = (parseFloat(c2[0]) % 360 + 360) % 360 / 360, y2 = a2(c2[1]), d2 = a2(c2[2]), m2 = d2 <= 0.5 ? d2 * (y2 + 1) : d2 + y2 - d2 * y2, v2 = 2 * d2 - m2;
                    return [n2(255 * o2(v2, m2, f2 + 1 / 3)), n2(255 * o2(v2, m2, f2)), n2(255 * o2(v2, m2, f2 - 1 / 3)), h2];
                  default:
                    return null;
                }
              }
              return null;
            };
          } catch (t5) {
          }
        }).parseCSSColor, te = function(t4, e2, r2, n2) {
          void 0 === n2 && (n2 = 1), this.r = t4, this.g = e2, this.b = r2, this.a = n2;
        };
        te.parse = function(t4) {
          if (t4) {
            if (t4 instanceof te)
              return t4;
            if ("string" == typeof t4) {
              var e2 = Qt(t4);
              if (e2)
                return new te(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]);
            }
          }
        }, te.prototype.toString = function() {
          var t4 = this.toArray(), e2 = t4[1], r2 = t4[2], n2 = t4[3];
          return "rgba(" + Math.round(t4[0]) + "," + Math.round(e2) + "," + Math.round(r2) + "," + n2 + ")";
        }, te.prototype.toArray = function() {
          var t4 = this.a;
          return 0 === t4 ? [0, 0, 0, 0] : [255 * this.r / t4, 255 * this.g / t4, 255 * this.b / t4, t4];
        }, te.black = new te(0, 0, 0, 1), te.white = new te(1, 1, 1, 1), te.transparent = new te(0, 0, 0, 0), te.red = new te(1, 0, 0, 1);
        var ee = function(t4, e2, r2) {
          this.sensitivity = t4 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        };
        ee.prototype.compare = function(t4, e2) {
          return this.collator.compare(t4, e2);
        }, ee.prototype.resolvedLocale = function() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        };
        var re = function(t4, e2, r2, n2, i3) {
          this.text = t4, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i3;
        }, ne = function(t4) {
          this.sections = t4;
        };
        ne.fromString = function(t4) {
          return new ne([new re(t4, null, null, null, null)]);
        }, ne.prototype.isEmpty = function() {
          return 0 === this.sections.length || !this.sections.some(function(t4) {
            return 0 !== t4.text.length || t4.image && 0 !== t4.image.name.length;
          });
        }, ne.factory = function(t4) {
          return t4 instanceof ne ? t4 : ne.fromString(t4);
        }, ne.prototype.toString = function() {
          return 0 === this.sections.length ? "" : this.sections.map(function(t4) {
            return t4.text;
          }).join("");
        }, ne.prototype.serialize = function() {
          for (var t4 = ["format"], e2 = 0, r2 = this.sections; e2 < r2.length; e2 += 1) {
            var n2 = r2[e2];
            if (n2.image)
              t4.push(["image", n2.image.name]);
            else {
              t4.push(n2.text);
              var i3 = {};
              n2.fontStack && (i3["text-font"] = ["literal", n2.fontStack.split(",")]), n2.scale && (i3["font-scale"] = n2.scale), n2.textColor && (i3["text-color"] = ["rgba"].concat(n2.textColor.toArray())), t4.push(i3);
            }
          }
          return t4;
        };
        var ie = function(t4) {
          this.name = t4.name, this.available = t4.available;
        };
        function ae(t4, e2, r2, n2) {
          return "number" == typeof t4 && t4 >= 0 && t4 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : "Invalid rgba value [" + [t4, e2, r2, n2].join(", ") + "]: 'a' must be between 0 and 1." : "Invalid rgba value [" + ("number" == typeof n2 ? [t4, e2, r2, n2] : [t4, e2, r2]).join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255.";
        }
        function oe(t4) {
          if (null === t4)
            return true;
          if ("string" == typeof t4)
            return true;
          if ("boolean" == typeof t4)
            return true;
          if ("number" == typeof t4)
            return true;
          if (t4 instanceof te)
            return true;
          if (t4 instanceof ee)
            return true;
          if (t4 instanceof ne)
            return true;
          if (t4 instanceof ie)
            return true;
          if (Array.isArray(t4)) {
            for (var e2 = 0, r2 = t4; e2 < r2.length; e2 += 1)
              if (!oe(r2[e2]))
                return false;
            return true;
          }
          if ("object" == typeof t4) {
            for (var n2 in t4)
              if (!oe(t4[n2]))
                return false;
            return true;
          }
          return false;
        }
        function se(t4) {
          if (null === t4)
            return Lt;
          if ("string" == typeof t4)
            return Rt;
          if ("boolean" == typeof t4)
            return Ut;
          if ("number" == typeof t4)
            return Ot;
          if (t4 instanceof te)
            return jt;
          if (t4 instanceof ee)
            return Kt;
          if (t4 instanceof ne)
            return Gt;
          if (t4 instanceof ie)
            return Zt;
          if (Array.isArray(t4)) {
            for (var e2, r2 = t4.length, n2 = 0, i3 = t4; n2 < i3.length; n2 += 1) {
              var a2 = se(i3[n2]);
              if (e2) {
                if (e2 === a2)
                  continue;
                e2 = Nt;
                break;
              }
              e2 = a2;
            }
            return Xt(e2 || Nt, r2);
          }
          return qt;
        }
        function ue(t4) {
          var e2 = typeof t4;
          return null === t4 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t4) : t4 instanceof te || t4 instanceof ne || t4 instanceof ie ? t4.toString() : JSON.stringify(t4);
        }
        ie.prototype.toString = function() {
          return this.name;
        }, ie.fromString = function(t4) {
          return t4 ? new ie({ name: t4, available: false }) : null;
        }, ie.prototype.serialize = function() {
          return ["image", this.name];
        };
        var le = function(t4, e2) {
          this.type = t4, this.value = e2;
        };
        le.parse = function(t4, e2) {
          if (2 !== t4.length)
            return e2.error("'literal' expression requires exactly one argument, but found " + (t4.length - 1) + " instead.");
          if (!oe(t4[1]))
            return e2.error("invalid value");
          var r2 = t4[1], n2 = se(r2), i3 = e2.expectedType;
          return "array" !== n2.kind || 0 !== n2.N || !i3 || "array" !== i3.kind || "number" == typeof i3.N && 0 !== i3.N || (n2 = i3), new le(n2, r2);
        }, le.prototype.evaluate = function() {
          return this.value;
        }, le.prototype.eachChild = function() {
        }, le.prototype.outputDefined = function() {
          return true;
        }, le.prototype.serialize = function() {
          return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof te ? ["rgba"].concat(this.value.toArray()) : this.value instanceof ne ? this.value.serialize() : this.value;
        };
        var pe = function(t4) {
          this.name = "ExpressionEvaluationError", this.message = t4;
        };
        pe.prototype.toJSON = function() {
          return this.message;
        };
        var ce = { string: Rt, number: Ot, boolean: Ut, object: qt }, he = function(t4, e2) {
          this.type = t4, this.args = e2;
        };
        he.parse = function(t4, e2) {
          if (t4.length < 2)
            return e2.error("Expected at least one argument.");
          var r2, n2 = 1, i3 = t4[0];
          if ("array" === i3) {
            var a2, o2;
            if (t4.length > 2) {
              var s2 = t4[1];
              if ("string" != typeof s2 || !(s2 in ce) || "object" === s2)
                return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
              a2 = ce[s2], n2++;
            } else
              a2 = Nt;
            if (t4.length > 3) {
              if (null !== t4[2] && ("number" != typeof t4[2] || t4[2] < 0 || t4[2] !== Math.floor(t4[2])))
                return e2.error('The length argument to "array" must be a positive integer literal', 2);
              o2 = t4[2], n2++;
            }
            r2 = Xt(a2, o2);
          } else
            r2 = ce[i3];
          for (var u2 = []; n2 < t4.length; n2++) {
            var l2 = e2.parse(t4[n2], n2, Nt);
            if (!l2)
              return null;
            u2.push(l2);
          }
          return new he(r2, u2);
        }, he.prototype.evaluate = function(t4) {
          for (var e2 = 0; e2 < this.args.length; e2++) {
            var r2 = this.args[e2].evaluate(t4);
            if (!Yt(this.type, se(r2)))
              return r2;
            if (e2 === this.args.length - 1)
              throw new pe("Expected value to be of type " + Jt(this.type) + ", but found " + Jt(se(r2)) + " instead.");
          }
          return null;
        }, he.prototype.eachChild = function(t4) {
          this.args.forEach(t4);
        }, he.prototype.outputDefined = function() {
          return this.args.every(function(t4) {
            return t4.outputDefined();
          });
        }, he.prototype.serialize = function() {
          var t4 = this.type, e2 = [t4.kind];
          if ("array" === t4.kind) {
            var r2 = t4.itemType;
            if ("string" === r2.kind || "number" === r2.kind || "boolean" === r2.kind) {
              e2.push(r2.kind);
              var n2 = t4.N;
              ("number" == typeof n2 || this.args.length > 1) && e2.push(n2);
            }
          }
          return e2.concat(this.args.map(function(t5) {
            return t5.serialize();
          }));
        };
        var fe = function(t4) {
          this.type = Gt, this.sections = t4;
        };
        fe.parse = function(t4, e2) {
          if (t4.length < 2)
            return e2.error("Expected at least one argument.");
          var r2 = t4[1];
          if (!Array.isArray(r2) && "object" == typeof r2)
            return e2.error("First argument must be an image or text section.");
          for (var n2 = [], i3 = false, a2 = 1; a2 <= t4.length - 1; ++a2) {
            var o2 = t4[a2];
            if (i3 && "object" == typeof o2 && !Array.isArray(o2)) {
              i3 = false;
              var s2 = null;
              if (o2["font-scale"] && !(s2 = e2.parse(o2["font-scale"], 1, Ot)))
                return null;
              var u2 = null;
              if (o2["text-font"] && !(u2 = e2.parse(o2["text-font"], 1, Xt(Rt))))
                return null;
              var l2 = null;
              if (o2["text-color"] && !(l2 = e2.parse(o2["text-color"], 1, jt)))
                return null;
              var p2 = n2[n2.length - 1];
              p2.scale = s2, p2.font = u2, p2.textColor = l2;
            } else {
              var c2 = e2.parse(t4[a2], 1, Nt);
              if (!c2)
                return null;
              var h2 = c2.type.kind;
              if ("string" !== h2 && "value" !== h2 && "null" !== h2 && "resolvedImage" !== h2)
                return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              i3 = true, n2.push({ content: c2, scale: null, font: null, textColor: null });
            }
          }
          return new fe(n2);
        }, fe.prototype.evaluate = function(t4) {
          return new ne(this.sections.map(function(e2) {
            var r2 = e2.content.evaluate(t4);
            return se(r2) === Zt ? new re("", r2, null, null, null) : new re(ue(r2), null, e2.scale ? e2.scale.evaluate(t4) : null, e2.font ? e2.font.evaluate(t4).join(",") : null, e2.textColor ? e2.textColor.evaluate(t4) : null);
          }));
        }, fe.prototype.eachChild = function(t4) {
          for (var e2 = 0, r2 = this.sections; e2 < r2.length; e2 += 1) {
            var n2 = r2[e2];
            t4(n2.content), n2.scale && t4(n2.scale), n2.font && t4(n2.font), n2.textColor && t4(n2.textColor);
          }
        }, fe.prototype.outputDefined = function() {
          return false;
        }, fe.prototype.serialize = function() {
          for (var t4 = ["format"], e2 = 0, r2 = this.sections; e2 < r2.length; e2 += 1) {
            var n2 = r2[e2];
            t4.push(n2.content.serialize());
            var i3 = {};
            n2.scale && (i3["font-scale"] = n2.scale.serialize()), n2.font && (i3["text-font"] = n2.font.serialize()), n2.textColor && (i3["text-color"] = n2.textColor.serialize()), t4.push(i3);
          }
          return t4;
        };
        var ye = function(t4) {
          this.type = Zt, this.input = t4;
        };
        ye.parse = function(t4, e2) {
          if (2 !== t4.length)
            return e2.error("Expected two arguments.");
          var r2 = e2.parse(t4[1], 1, Rt);
          return r2 ? new ye(r2) : e2.error("No image name provided.");
        }, ye.prototype.evaluate = function(t4) {
          var e2 = this.input.evaluate(t4), r2 = ie.fromString(e2);
          return r2 && t4.availableImages && (r2.available = t4.availableImages.indexOf(e2) > -1), r2;
        }, ye.prototype.eachChild = function(t4) {
          t4(this.input);
        }, ye.prototype.outputDefined = function() {
          return false;
        }, ye.prototype.serialize = function() {
          return ["image", this.input.serialize()];
        };
        var de = { "to-boolean": Ut, "to-color": jt, "to-number": Ot, "to-string": Rt }, me = function(t4, e2) {
          this.type = t4, this.args = e2;
        };
        me.parse = function(t4, e2) {
          if (t4.length < 2)
            return e2.error("Expected at least one argument.");
          var r2 = t4[0];
          if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t4.length)
            return e2.error("Expected one argument.");
          for (var n2 = de[r2], i3 = [], a2 = 1; a2 < t4.length; a2++) {
            var o2 = e2.parse(t4[a2], a2, Nt);
            if (!o2)
              return null;
            i3.push(o2);
          }
          return new me(n2, i3);
        }, me.prototype.evaluate = function(t4) {
          if ("boolean" === this.type.kind)
            return Boolean(this.args[0].evaluate(t4));
          if ("color" === this.type.kind) {
            for (var e2, r2, n2 = 0, i3 = this.args; n2 < i3.length; n2 += 1) {
              if (r2 = null, (e2 = i3[n2].evaluate(t4)) instanceof te)
                return e2;
              if ("string" == typeof e2) {
                var a2 = t4.parseColor(e2);
                if (a2)
                  return a2;
              } else if (Array.isArray(e2) && !(r2 = e2.length < 3 || e2.length > 4 ? "Invalid rbga value " + JSON.stringify(e2) + ": expected an array containing either three or four numeric values." : ae(e2[0], e2[1], e2[2], e2[3])))
                return new te(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
            }
            throw new pe(r2 || "Could not parse color from value '" + ("string" == typeof e2 ? e2 : String(JSON.stringify(e2))) + "'");
          }
          if ("number" === this.type.kind) {
            for (var o2 = null, s2 = 0, u2 = this.args; s2 < u2.length; s2 += 1) {
              if (null === (o2 = u2[s2].evaluate(t4)))
                return 0;
              var l2 = Number(o2);
              if (!isNaN(l2))
                return l2;
            }
            throw new pe("Could not convert " + JSON.stringify(o2) + " to number.");
          }
          return "formatted" === this.type.kind ? ne.fromString(ue(this.args[0].evaluate(t4))) : "resolvedImage" === this.type.kind ? ie.fromString(ue(this.args[0].evaluate(t4))) : ue(this.args[0].evaluate(t4));
        }, me.prototype.eachChild = function(t4) {
          this.args.forEach(t4);
        }, me.prototype.outputDefined = function() {
          return this.args.every(function(t4) {
            return t4.outputDefined();
          });
        }, me.prototype.serialize = function() {
          if ("formatted" === this.type.kind)
            return new fe([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if ("resolvedImage" === this.type.kind)
            return new ye(this.args[0]).serialize();
          var t4 = ["to-" + this.type.kind];
          return this.eachChild(function(e2) {
            t4.push(e2.serialize());
          }), t4;
        };
        var ve = ["Unknown", "Point", "LineString", "Polygon"], ge = function() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        };
        ge.prototype.id = function() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }, ge.prototype.geometryType = function() {
          return this.feature ? "number" == typeof this.feature.type ? ve[this.feature.type] : this.feature.type : null;
        }, ge.prototype.geometry = function() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }, ge.prototype.canonicalID = function() {
          return this.canonical;
        }, ge.prototype.properties = function() {
          return this.feature && this.feature.properties || {};
        }, ge.prototype.parseColor = function(t4) {
          var e2 = this._parseColorCache[t4];
          return e2 || (e2 = this._parseColorCache[t4] = te.parse(t4)), e2;
        };
        var xe = function(t4, e2, r2, n2) {
          this.name = t4, this.type = e2, this._evaluate = r2, this.args = n2;
        };
        xe.prototype.evaluate = function(t4) {
          return this._evaluate(t4, this.args);
        }, xe.prototype.eachChild = function(t4) {
          this.args.forEach(t4);
        }, xe.prototype.outputDefined = function() {
          return false;
        }, xe.prototype.serialize = function() {
          return [this.name].concat(this.args.map(function(t4) {
            return t4.serialize();
          }));
        }, xe.parse = function(t4, e2) {
          var r2, n2 = t4[0], i3 = xe.definitions[n2];
          if (!i3)
            return e2.error('Unknown expression "' + n2 + '". If you wanted a literal array, use ["literal", [...]].', 0);
          for (var a2 = Array.isArray(i3) ? i3[0] : i3.type, o2 = Array.isArray(i3) ? [[i3[1], i3[2]]] : i3.overloads, s2 = o2.filter(function(e3) {
            var r3 = e3[0];
            return !Array.isArray(r3) || r3.length === t4.length - 1;
          }), u2 = null, l2 = 0, p2 = s2; l2 < p2.length; l2 += 1) {
            var c2 = p2[l2], h2 = c2[0], f2 = c2[1];
            u2 = new je(e2.registry, e2.path, null, e2.scope);
            for (var y2 = [], d2 = false, m2 = 1; m2 < t4.length; m2++) {
              var v2 = t4[m2], g2 = Array.isArray(h2) ? h2[m2 - 1] : h2.type, x3 = u2.parse(v2, 1 + y2.length, g2);
              if (!x3) {
                d2 = true;
                break;
              }
              y2.push(x3);
            }
            if (!d2)
              if (Array.isArray(h2) && h2.length !== y2.length)
                u2.error("Expected " + h2.length + " arguments, but found " + y2.length + " instead.");
              else {
                for (var b2 = 0; b2 < y2.length; b2++) {
                  var w2 = Array.isArray(h2) ? h2[b2] : h2.type, _2 = y2[b2];
                  u2.concat(b2 + 1).checkSubtype(w2, _2.type);
                }
                if (0 === u2.errors.length)
                  return new xe(n2, a2, f2, y2);
              }
          }
          if (1 === s2.length)
            (r2 = e2.errors).push.apply(r2, u2.errors);
          else {
            for (var A3 = (s2.length ? s2 : o2).map(function(t5) {
              var e3;
              return e3 = t5[0], Array.isArray(e3) ? "(" + e3.map(Jt).join(", ") + ")" : "(" + Jt(e3.type) + "...)";
            }).join(" | "), S2 = [], k2 = 1; k2 < t4.length; k2++) {
              var I2 = e2.parse(t4[k2], 1 + S2.length);
              if (!I2)
                return null;
              S2.push(Jt(I2.type));
            }
            e2.error("Expected arguments of type " + A3 + ", but found (" + S2.join(", ") + ") instead.");
          }
          return null;
        }, xe.register = function(t4, e2) {
          for (var r2 in xe.definitions = e2, e2)
            t4[r2] = xe;
        };
        var be = function(t4, e2, r2) {
          this.type = Kt, this.locale = r2, this.caseSensitive = t4, this.diacriticSensitive = e2;
        };
        function we(t4, e2) {
          t4[0] = Math.min(t4[0], e2[0]), t4[1] = Math.min(t4[1], e2[1]), t4[2] = Math.max(t4[2], e2[0]), t4[3] = Math.max(t4[3], e2[1]);
        }
        function _e(t4, e2) {
          return !(t4[0] <= e2[0] || t4[2] >= e2[2] || t4[1] <= e2[1] || t4[3] >= e2[3]);
        }
        function Ae(t4, e2) {
          var r2 = (180 + t4[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t4[1] * Math.PI / 360))) / 360, i3 = Math.pow(2, e2.z);
          return [Math.round(r2 * i3 * 8192), Math.round(n2 * i3 * 8192)];
        }
        function Se(t4, e2, r2) {
          return e2[1] > t4[1] != r2[1] > t4[1] && t4[0] < (r2[0] - e2[0]) * (t4[1] - e2[1]) / (r2[1] - e2[1]) + e2[0];
        }
        function ke(t4, e2) {
          for (var r2, n2, i3, a2, o2, s2, u2, l2 = false, p2 = 0, c2 = e2.length; p2 < c2; p2++)
            for (var h2 = e2[p2], f2 = 0, y2 = h2.length; f2 < y2 - 1; f2++) {
              if ((a2 = (r2 = t4)[0] - (n2 = h2[f2])[0]) * (u2 = r2[1] - (i3 = h2[f2 + 1])[1]) - (s2 = r2[0] - i3[0]) * (o2 = r2[1] - n2[1]) == 0 && a2 * s2 <= 0 && o2 * u2 <= 0)
                return false;
              Se(t4, h2[f2], h2[f2 + 1]) && (l2 = !l2);
            }
          return l2;
        }
        function Ie(t4, e2) {
          for (var r2 = 0; r2 < e2.length; r2++)
            if (ke(t4, e2[r2]))
              return true;
          return false;
        }
        function ze(t4, e2, r2, n2) {
          var i3 = n2[0] - r2[0], a2 = n2[1] - r2[1], o2 = (t4[0] - r2[0]) * a2 - i3 * (t4[1] - r2[1]), s2 = (e2[0] - r2[0]) * a2 - i3 * (e2[1] - r2[1]);
          return o2 > 0 && s2 < 0 || o2 < 0 && s2 > 0;
        }
        function Ce(t4, e2, r2) {
          for (var n2 = 0, i3 = r2; n2 < i3.length; n2 += 1)
            for (var a2 = i3[n2], o2 = 0; o2 < a2.length - 1; ++o2)
              if (0 != (c2 = [(p2 = a2[o2 + 1])[0] - (l2 = a2[o2])[0], p2[1] - l2[1]])[0] * (h2 = [(u2 = e2)[0] - (s2 = t4)[0], u2[1] - s2[1]])[1] - c2[1] * h2[0] && ze(s2, u2, l2, p2) && ze(l2, p2, s2, u2))
                return true;
          var s2, u2, l2, p2, c2, h2;
          return false;
        }
        function Ee(t4, e2) {
          for (var r2 = 0; r2 < t4.length; ++r2)
            if (!ke(t4[r2], e2))
              return false;
          for (var n2 = 0; n2 < t4.length - 1; ++n2)
            if (Ce(t4[n2], t4[n2 + 1], e2))
              return false;
          return true;
        }
        function Pe(t4, e2) {
          for (var r2 = 0; r2 < e2.length; r2++)
            if (Ee(t4, e2[r2]))
              return true;
          return false;
        }
        function Me(t4, e2, r2) {
          for (var n2 = [], i3 = 0; i3 < t4.length; i3++) {
            for (var a2 = [], o2 = 0; o2 < t4[i3].length; o2++) {
              var s2 = Ae(t4[i3][o2], r2);
              we(e2, s2), a2.push(s2);
            }
            n2.push(a2);
          }
          return n2;
        }
        function Be(t4, e2, r2) {
          for (var n2 = [], i3 = 0; i3 < t4.length; i3++) {
            var a2 = Me(t4[i3], e2, r2);
            n2.push(a2);
          }
          return n2;
        }
        function Te(t4, e2, r2, n2) {
          if (t4[0] < r2[0] || t4[0] > r2[2]) {
            var i3 = 0.5 * n2, a2 = t4[0] - r2[0] > i3 ? -n2 : r2[0] - t4[0] > i3 ? n2 : 0;
            0 === a2 && (a2 = t4[0] - r2[2] > i3 ? -n2 : r2[2] - t4[0] > i3 ? n2 : 0), t4[0] += a2;
          }
          we(e2, t4);
        }
        function Ve(t4, e2, r2, n2) {
          for (var i3 = 8192 * Math.pow(2, n2.z), a2 = [8192 * n2.x, 8192 * n2.y], o2 = [], s2 = 0, u2 = t4; s2 < u2.length; s2 += 1)
            for (var l2 = 0, p2 = u2[s2]; l2 < p2.length; l2 += 1) {
              var c2 = p2[l2], h2 = [c2.x + a2[0], c2.y + a2[1]];
              Te(h2, e2, r2, i3), o2.push(h2);
            }
          return o2;
        }
        function Fe(t4, e2, r2, n2) {
          for (var i3, a2 = 8192 * Math.pow(2, n2.z), o2 = [8192 * n2.x, 8192 * n2.y], s2 = [], u2 = 0, l2 = t4; u2 < l2.length; u2 += 1) {
            for (var p2 = [], c2 = 0, h2 = l2[u2]; c2 < h2.length; c2 += 1) {
              var f2 = h2[c2], y2 = [f2.x + o2[0], f2.y + o2[1]];
              we(e2, y2), p2.push(y2);
            }
            s2.push(p2);
          }
          if (e2[2] - e2[0] <= a2 / 2) {
            (i3 = e2)[0] = i3[1] = 1 / 0, i3[2] = i3[3] = -1 / 0;
            for (var d2 = 0, m2 = s2; d2 < m2.length; d2 += 1)
              for (var v2 = 0, g2 = m2[d2]; v2 < g2.length; v2 += 1)
                Te(g2[v2], e2, r2, a2);
          }
          return s2;
        }
        be.parse = function(t4, e2) {
          if (2 !== t4.length)
            return e2.error("Expected one argument.");
          var r2 = t4[1];
          if ("object" != typeof r2 || Array.isArray(r2))
            return e2.error("Collator options argument must be an object.");
          var n2 = e2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, Ut);
          if (!n2)
            return null;
          var i3 = e2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, Ut);
          if (!i3)
            return null;
          var a2 = null;
          return r2.locale && !(a2 = e2.parse(r2.locale, 1, Rt)) ? null : new be(n2, i3, a2);
        }, be.prototype.evaluate = function(t4) {
          return new ee(this.caseSensitive.evaluate(t4), this.diacriticSensitive.evaluate(t4), this.locale ? this.locale.evaluate(t4) : null);
        }, be.prototype.eachChild = function(t4) {
          t4(this.caseSensitive), t4(this.diacriticSensitive), this.locale && t4(this.locale);
        }, be.prototype.outputDefined = function() {
          return false;
        }, be.prototype.serialize = function() {
          var t4 = {};
          return t4["case-sensitive"] = this.caseSensitive.serialize(), t4["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t4.locale = this.locale.serialize()), ["collator", t4];
        };
        var De = function(t4, e2) {
          this.type = Ut, this.geojson = t4, this.geometries = e2;
        };
        function Le(t4) {
          if (t4 instanceof xe) {
            if ("get" === t4.name && 1 === t4.args.length)
              return false;
            if ("feature-state" === t4.name)
              return false;
            if ("has" === t4.name && 1 === t4.args.length)
              return false;
            if ("properties" === t4.name || "geometry-type" === t4.name || "id" === t4.name)
              return false;
            if (/^filter-/.test(t4.name))
              return false;
          }
          if (t4 instanceof De)
            return false;
          var e2 = true;
          return t4.eachChild(function(t5) {
            e2 && !Le(t5) && (e2 = false);
          }), e2;
        }
        function Oe(t4) {
          if (t4 instanceof xe && "feature-state" === t4.name)
            return false;
          var e2 = true;
          return t4.eachChild(function(t5) {
            e2 && !Oe(t5) && (e2 = false);
          }), e2;
        }
        function Re(t4, e2) {
          if (t4 instanceof xe && e2.indexOf(t4.name) >= 0)
            return false;
          var r2 = true;
          return t4.eachChild(function(t5) {
            r2 && !Re(t5, e2) && (r2 = false);
          }), r2;
        }
        De.parse = function(t4, e2) {
          if (2 !== t4.length)
            return e2.error("'within' expression requires exactly one argument, but found " + (t4.length - 1) + " instead.");
          if (oe(t4[1])) {
            var r2 = t4[1];
            if ("FeatureCollection" === r2.type)
              for (var n2 = 0; n2 < r2.features.length; ++n2) {
                var i3 = r2.features[n2].geometry.type;
                if ("Polygon" === i3 || "MultiPolygon" === i3)
                  return new De(r2, r2.features[n2].geometry);
              }
            else if ("Feature" === r2.type) {
              var a2 = r2.geometry.type;
              if ("Polygon" === a2 || "MultiPolygon" === a2)
                return new De(r2, r2.geometry);
            } else if ("Polygon" === r2.type || "MultiPolygon" === r2.type)
              return new De(r2, r2);
          }
          return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }, De.prototype.evaluate = function(t4) {
          if (null != t4.geometry() && null != t4.canonicalID()) {
            if ("Point" === t4.geometryType())
              return function(t5, e2) {
                var r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t5.canonicalID();
                if ("Polygon" === e2.type) {
                  var a2 = Me(e2.coordinates, n2, i3), o2 = Ve(t5.geometry(), r2, n2, i3);
                  if (!_e(r2, n2))
                    return false;
                  for (var s2 = 0, u2 = o2; s2 < u2.length; s2 += 1)
                    if (!ke(u2[s2], a2))
                      return false;
                }
                if ("MultiPolygon" === e2.type) {
                  var l2 = Be(e2.coordinates, n2, i3), p2 = Ve(t5.geometry(), r2, n2, i3);
                  if (!_e(r2, n2))
                    return false;
                  for (var c2 = 0, h2 = p2; c2 < h2.length; c2 += 1)
                    if (!Ie(h2[c2], l2))
                      return false;
                }
                return true;
              }(t4, this.geometries);
            if ("LineString" === t4.geometryType())
              return function(t5, e2) {
                var r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t5.canonicalID();
                if ("Polygon" === e2.type) {
                  var a2 = Me(e2.coordinates, n2, i3), o2 = Fe(t5.geometry(), r2, n2, i3);
                  if (!_e(r2, n2))
                    return false;
                  for (var s2 = 0, u2 = o2; s2 < u2.length; s2 += 1)
                    if (!Ee(u2[s2], a2))
                      return false;
                }
                if ("MultiPolygon" === e2.type) {
                  var l2 = Be(e2.coordinates, n2, i3), p2 = Fe(t5.geometry(), r2, n2, i3);
                  if (!_e(r2, n2))
                    return false;
                  for (var c2 = 0, h2 = p2; c2 < h2.length; c2 += 1)
                    if (!Pe(h2[c2], l2))
                      return false;
                }
                return true;
              }(t4, this.geometries);
          }
          return false;
        }, De.prototype.eachChild = function() {
        }, De.prototype.outputDefined = function() {
          return true;
        }, De.prototype.serialize = function() {
          return ["within", this.geojson];
        };
        var Ue = function(t4, e2) {
          this.type = e2.type, this.name = t4, this.boundExpression = e2;
        };
        Ue.parse = function(t4, e2) {
          if (2 !== t4.length || "string" != typeof t4[1])
            return e2.error("'var' expression requires exactly one string literal argument.");
          var r2 = t4[1];
          return e2.scope.has(r2) ? new Ue(r2, e2.scope.get(r2)) : e2.error('Unknown variable "' + r2 + '". Make sure "' + r2 + '" has been bound in an enclosing "let" expression before using it.', 1);
        }, Ue.prototype.evaluate = function(t4) {
          return this.boundExpression.evaluate(t4);
        }, Ue.prototype.eachChild = function() {
        }, Ue.prototype.outputDefined = function() {
          return false;
        }, Ue.prototype.serialize = function() {
          return ["var", this.name];
        };
        var je = function(t4, e2, r2, n2, i3) {
          void 0 === e2 && (e2 = []), void 0 === n2 && (n2 = new Dt()), void 0 === i3 && (i3 = []), this.registry = t4, this.path = e2, this.key = e2.map(function(t5) {
            return "[" + t5 + "]";
          }).join(""), this.scope = n2, this.errors = i3, this.expectedType = r2;
        };
        function qe(t4, e2) {
          for (var r2, n2 = t4.length - 1, i3 = 0, a2 = n2, o2 = 0; i3 <= a2; )
            if ((r2 = t4[o2 = Math.floor((i3 + a2) / 2)]) <= e2) {
              if (o2 === n2 || e2 < t4[o2 + 1])
                return o2;
              i3 = o2 + 1;
            } else {
              if (!(r2 > e2))
                throw new pe("Input is not a number.");
              a2 = o2 - 1;
            }
          return 0;
        }
        je.prototype.parse = function(t4, e2, r2, n2, i3) {
          return void 0 === i3 && (i3 = {}), e2 ? this.concat(e2, r2, n2)._parse(t4, i3) : this._parse(t4, i3);
        }, je.prototype._parse = function(t4, e2) {
          function r2(t5, e3, r3) {
            return "assert" === r3 ? new he(e3, [t5]) : "coerce" === r3 ? new me(e3, [t5]) : t5;
          }
          if (null !== t4 && "string" != typeof t4 && "boolean" != typeof t4 && "number" != typeof t4 || (t4 = ["literal", t4]), Array.isArray(t4)) {
            if (0 === t4.length)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            var n2 = t4[0];
            if ("string" != typeof n2)
              return this.error("Expression name must be a string, but found " + typeof n2 + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null;
            var i3 = this.registry[n2];
            if (i3) {
              var a2 = i3.parse(t4, this);
              if (!a2)
                return null;
              if (this.expectedType) {
                var o2 = this.expectedType, s2 = a2.type;
                if ("string" !== o2.kind && "number" !== o2.kind && "boolean" !== o2.kind && "object" !== o2.kind && "array" !== o2.kind || "value" !== s2.kind)
                  if ("color" !== o2.kind && "formatted" !== o2.kind && "resolvedImage" !== o2.kind || "value" !== s2.kind && "string" !== s2.kind) {
                    if (this.checkSubtype(o2, s2))
                      return null;
                  } else
                    a2 = r2(a2, o2, e2.typeAnnotation || "coerce");
                else
                  a2 = r2(a2, o2, e2.typeAnnotation || "assert");
              }
              if (!(a2 instanceof le) && "resolvedImage" !== a2.type.kind && function t5(e3) {
                if (e3 instanceof Ue)
                  return t5(e3.boundExpression);
                if (e3 instanceof xe && "error" === e3.name)
                  return false;
                if (e3 instanceof be)
                  return false;
                if (e3 instanceof De)
                  return false;
                var r3 = e3 instanceof me || e3 instanceof he, n3 = true;
                return e3.eachChild(function(e4) {
                  n3 = r3 ? n3 && t5(e4) : n3 && e4 instanceof le;
                }), !!n3 && Le(e3) && Re(e3, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
              }(a2)) {
                var u2 = new ge();
                try {
                  a2 = new le(a2.type, a2.evaluate(u2));
                } catch (t5) {
                  return this.error(t5.message), null;
                }
              }
              return a2;
            }
            return this.error('Unknown expression "' + n2 + '". If you wanted a literal array, use ["literal", [...]].', 0);
          }
          return this.error(void 0 === t4 ? "'undefined' value invalid. Use null instead." : "object" == typeof t4 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found " + typeof t4 + " instead.");
        }, je.prototype.concat = function(t4, e2, r2) {
          var n2 = "number" == typeof t4 ? this.path.concat(t4) : this.path, i3 = r2 ? this.scope.concat(r2) : this.scope;
          return new je(this.registry, n2, e2 || null, i3, this.errors);
        }, je.prototype.error = function(t4) {
          for (var e2 = [], r2 = arguments.length - 1; r2-- > 0; )
            e2[r2] = arguments[r2 + 1];
          var n2 = "" + this.key + e2.map(function(t5) {
            return "[" + t5 + "]";
          }).join("");
          this.errors.push(new Ft(n2, t4));
        }, je.prototype.checkSubtype = function(t4, e2) {
          var r2 = Yt(t4, e2);
          return r2 && this.error(r2), r2;
        };
        var Ne = function(t4, e2, r2) {
          this.type = t4, this.input = e2, this.labels = [], this.outputs = [];
          for (var n2 = 0, i3 = r2; n2 < i3.length; n2 += 1) {
            var a2 = i3[n2], o2 = a2[1];
            this.labels.push(a2[0]), this.outputs.push(o2);
          }
        };
        function Ke(t4, e2, r2) {
          return t4 * (1 - r2) + e2 * r2;
        }
        Ne.parse = function(t4, e2) {
          if (t4.length - 1 < 4)
            return e2.error("Expected at least 4 arguments, but found only " + (t4.length - 1) + ".");
          if ((t4.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          var r2 = e2.parse(t4[1], 1, Ot);
          if (!r2)
            return null;
          var n2 = [], i3 = null;
          e2.expectedType && "value" !== e2.expectedType.kind && (i3 = e2.expectedType);
          for (var a2 = 1; a2 < t4.length; a2 += 2) {
            var o2 = 1 === a2 ? -1 / 0 : t4[a2], s2 = t4[a2 + 1], u2 = a2, l2 = a2 + 1;
            if ("number" != typeof o2)
              return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u2);
            if (n2.length && n2[n2.length - 1][0] >= o2)
              return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', u2);
            var p2 = e2.parse(s2, l2, i3);
            if (!p2)
              return null;
            i3 = i3 || p2.type, n2.push([o2, p2]);
          }
          return new Ne(i3, r2, n2);
        }, Ne.prototype.evaluate = function(t4) {
          var e2 = this.labels, r2 = this.outputs;
          if (1 === e2.length)
            return r2[0].evaluate(t4);
          var n2 = this.input.evaluate(t4);
          if (n2 <= e2[0])
            return r2[0].evaluate(t4);
          var i3 = e2.length;
          return n2 >= e2[i3 - 1] ? r2[i3 - 1].evaluate(t4) : r2[qe(e2, n2)].evaluate(t4);
        }, Ne.prototype.eachChild = function(t4) {
          t4(this.input);
          for (var e2 = 0, r2 = this.outputs; e2 < r2.length; e2 += 1)
            t4(r2[e2]);
        }, Ne.prototype.outputDefined = function() {
          return this.outputs.every(function(t4) {
            return t4.outputDefined();
          });
        }, Ne.prototype.serialize = function() {
          for (var t4 = ["step", this.input.serialize()], e2 = 0; e2 < this.labels.length; e2++)
            e2 > 0 && t4.push(this.labels[e2]), t4.push(this.outputs[e2].serialize());
          return t4;
        };
        var Ge = Object.freeze({ __proto__: null, number: Ke, color: function(t4, e2, r2) {
          return new te(Ke(t4.r, e2.r, r2), Ke(t4.g, e2.g, r2), Ke(t4.b, e2.b, r2), Ke(t4.a, e2.a, r2));
        }, array: function(t4, e2, r2) {
          return t4.map(function(t5, n2) {
            return Ke(t5, e2[n2], r2);
          });
        } }), Ze = 6 / 29 * 3 * (6 / 29), Xe = Math.PI / 180, Je = 180 / Math.PI;
        function He(t4) {
          return t4 > 0.008856451679035631 ? Math.pow(t4, 1 / 3) : t4 / Ze + 4 / 29;
        }
        function Ye(t4) {
          return t4 > 6 / 29 ? t4 * t4 * t4 : Ze * (t4 - 4 / 29);
        }
        function $e(t4) {
          return 255 * (t4 <= 31308e-7 ? 12.92 * t4 : 1.055 * Math.pow(t4, 1 / 2.4) - 0.055);
        }
        function We(t4) {
          return (t4 /= 255) <= 0.04045 ? t4 / 12.92 : Math.pow((t4 + 0.055) / 1.055, 2.4);
        }
        function Qe(t4) {
          var e2 = We(t4.r), r2 = We(t4.g), n2 = We(t4.b), i3 = He((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n2) / 0.95047), a2 = He((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n2) / 1);
          return { l: 116 * a2 - 16, a: 500 * (i3 - a2), b: 200 * (a2 - He((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n2) / 1.08883)), alpha: t4.a };
        }
        function tr(t4) {
          var e2 = (t4.l + 16) / 116, r2 = isNaN(t4.a) ? e2 : e2 + t4.a / 500, n2 = isNaN(t4.b) ? e2 : e2 - t4.b / 200;
          return e2 = 1 * Ye(e2), r2 = 0.95047 * Ye(r2), n2 = 1.08883 * Ye(n2), new te($e(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n2), $e(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n2), $e(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n2), t4.alpha);
        }
        function er(t4, e2, r2) {
          var n2 = e2 - t4;
          return t4 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
        }
        var rr = { forward: Qe, reverse: tr, interpolate: function(t4, e2, r2) {
          return { l: Ke(t4.l, e2.l, r2), a: Ke(t4.a, e2.a, r2), b: Ke(t4.b, e2.b, r2), alpha: Ke(t4.alpha, e2.alpha, r2) };
        } }, nr = { forward: function(t4) {
          var e2 = Qe(t4), r2 = e2.l, n2 = e2.a, i3 = e2.b, a2 = Math.atan2(i3, n2) * Je;
          return { h: a2 < 0 ? a2 + 360 : a2, c: Math.sqrt(n2 * n2 + i3 * i3), l: r2, alpha: t4.a };
        }, reverse: function(t4) {
          var e2 = t4.h * Xe, r2 = t4.c;
          return tr({ l: t4.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t4.alpha });
        }, interpolate: function(t4, e2, r2) {
          return { h: er(t4.h, e2.h, r2), c: Ke(t4.c, e2.c, r2), l: Ke(t4.l, e2.l, r2), alpha: Ke(t4.alpha, e2.alpha, r2) };
        } }, ir = Object.freeze({ __proto__: null, lab: rr, hcl: nr }), ar = function(t4, e2, r2, n2, i3) {
          this.type = t4, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
          for (var a2 = 0, o2 = i3; a2 < o2.length; a2 += 1) {
            var s2 = o2[a2], u2 = s2[1];
            this.labels.push(s2[0]), this.outputs.push(u2);
          }
        };
        function or(t4, e2, r2, n2) {
          var i3 = n2 - r2, a2 = t4 - r2;
          return 0 === i3 ? 0 : 1 === e2 ? a2 / i3 : (Math.pow(e2, a2) - 1) / (Math.pow(e2, i3) - 1);
        }
        ar.interpolationFactor = function(t4, e2, n2, i3) {
          var a2 = 0;
          if ("exponential" === t4.name)
            a2 = or(e2, t4.base, n2, i3);
          else if ("linear" === t4.name)
            a2 = or(e2, 1, n2, i3);
          else if ("cubic-bezier" === t4.name) {
            var o2 = t4.controlPoints;
            a2 = new r(o2[0], o2[1], o2[2], o2[3]).solve(or(e2, 1, n2, i3));
          }
          return a2;
        }, ar.parse = function(t4, e2) {
          var r2 = t4[0], n2 = t4[1], i3 = t4[2], a2 = t4.slice(3);
          if (!Array.isArray(n2) || 0 === n2.length)
            return e2.error("Expected an interpolation type expression.", 1);
          if ("linear" === n2[0])
            n2 = { name: "linear" };
          else if ("exponential" === n2[0]) {
            var o2 = n2[1];
            if ("number" != typeof o2)
              return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
            n2 = { name: "exponential", base: o2 };
          } else {
            if ("cubic-bezier" !== n2[0])
              return e2.error("Unknown interpolation type " + String(n2[0]), 1, 0);
            var s2 = n2.slice(1);
            if (4 !== s2.length || s2.some(function(t5) {
              return "number" != typeof t5 || t5 < 0 || t5 > 1;
            }))
              return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
            n2 = { name: "cubic-bezier", controlPoints: s2 };
          }
          if (t4.length - 1 < 4)
            return e2.error("Expected at least 4 arguments, but found only " + (t4.length - 1) + ".");
          if ((t4.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          if (!(i3 = e2.parse(i3, 2, Ot)))
            return null;
          var u2 = [], l2 = null;
          "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? l2 = jt : e2.expectedType && "value" !== e2.expectedType.kind && (l2 = e2.expectedType);
          for (var p2 = 0; p2 < a2.length; p2 += 2) {
            var c2 = a2[p2], h2 = a2[p2 + 1], f2 = p2 + 3, y2 = p2 + 4;
            if ("number" != typeof c2)
              return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f2);
            if (u2.length && u2[u2.length - 1][0] >= c2)
              return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', f2);
            var d2 = e2.parse(h2, y2, l2);
            if (!d2)
              return null;
            l2 = l2 || d2.type, u2.push([c2, d2]);
          }
          return "number" === l2.kind || "color" === l2.kind || "array" === l2.kind && "number" === l2.itemType.kind && "number" == typeof l2.N ? new ar(l2, r2, n2, i3, u2) : e2.error("Type " + Jt(l2) + " is not interpolatable.");
        }, ar.prototype.evaluate = function(t4) {
          var e2 = this.labels, r2 = this.outputs;
          if (1 === e2.length)
            return r2[0].evaluate(t4);
          var n2 = this.input.evaluate(t4);
          if (n2 <= e2[0])
            return r2[0].evaluate(t4);
          var i3 = e2.length;
          if (n2 >= e2[i3 - 1])
            return r2[i3 - 1].evaluate(t4);
          var a2 = qe(e2, n2), o2 = ar.interpolationFactor(this.interpolation, n2, e2[a2], e2[a2 + 1]), s2 = r2[a2].evaluate(t4), u2 = r2[a2 + 1].evaluate(t4);
          return "interpolate" === this.operator ? Ge[this.type.kind.toLowerCase()](s2, u2, o2) : "interpolate-hcl" === this.operator ? nr.reverse(nr.interpolate(nr.forward(s2), nr.forward(u2), o2)) : rr.reverse(rr.interpolate(rr.forward(s2), rr.forward(u2), o2));
        }, ar.prototype.eachChild = function(t4) {
          t4(this.input);
          for (var e2 = 0, r2 = this.outputs; e2 < r2.length; e2 += 1)
            t4(r2[e2]);
        }, ar.prototype.outputDefined = function() {
          return this.outputs.every(function(t4) {
            return t4.outputDefined();
          });
        }, ar.prototype.serialize = function() {
          var t4;
          t4 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          for (var e2 = [this.operator, t4, this.input.serialize()], r2 = 0; r2 < this.labels.length; r2++)
            e2.push(this.labels[r2], this.outputs[r2].serialize());
          return e2;
        };
        var sr = function(t4, e2) {
          this.type = t4, this.args = e2;
        };
        sr.parse = function(t4, e2) {
          if (t4.length < 2)
            return e2.error("Expectected at least one argument.");
          var r2 = null, n2 = e2.expectedType;
          n2 && "value" !== n2.kind && (r2 = n2);
          for (var i3 = [], a2 = 0, o2 = t4.slice(1); a2 < o2.length; a2 += 1) {
            var s2 = e2.parse(o2[a2], 1 + i3.length, r2, void 0, { typeAnnotation: "omit" });
            if (!s2)
              return null;
            r2 = r2 || s2.type, i3.push(s2);
          }
          var u2 = n2 && i3.some(function(t5) {
            return Yt(n2, t5.type);
          });
          return new sr(u2 ? Nt : r2, i3);
        }, sr.prototype.evaluate = function(t4) {
          for (var e2, r2 = null, n2 = 0, i3 = 0, a2 = this.args; i3 < a2.length && (n2++, (r2 = a2[i3].evaluate(t4)) && r2 instanceof ie && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), null === r2); i3 += 1)
            ;
          return r2;
        }, sr.prototype.eachChild = function(t4) {
          this.args.forEach(t4);
        }, sr.prototype.outputDefined = function() {
          return this.args.every(function(t4) {
            return t4.outputDefined();
          });
        }, sr.prototype.serialize = function() {
          var t4 = ["coalesce"];
          return this.eachChild(function(e2) {
            t4.push(e2.serialize());
          }), t4;
        };
        var ur = function(t4, e2) {
          this.type = e2.type, this.bindings = [].concat(t4), this.result = e2;
        };
        ur.prototype.evaluate = function(t4) {
          return this.result.evaluate(t4);
        }, ur.prototype.eachChild = function(t4) {
          for (var e2 = 0, r2 = this.bindings; e2 < r2.length; e2 += 1)
            t4(r2[e2][1]);
          t4(this.result);
        }, ur.parse = function(t4, e2) {
          if (t4.length < 4)
            return e2.error("Expected at least 3 arguments, but found " + (t4.length - 1) + " instead.");
          for (var r2 = [], n2 = 1; n2 < t4.length - 1; n2 += 2) {
            var i3 = t4[n2];
            if ("string" != typeof i3)
              return e2.error("Expected string, but found " + typeof i3 + " instead.", n2);
            if (/[^a-zA-Z0-9_]/.test(i3))
              return e2.error("Variable names must contain only alphanumeric characters or '_'.", n2);
            var a2 = e2.parse(t4[n2 + 1], n2 + 1);
            if (!a2)
              return null;
            r2.push([i3, a2]);
          }
          var o2 = e2.parse(t4[t4.length - 1], t4.length - 1, e2.expectedType, r2);
          return o2 ? new ur(r2, o2) : null;
        }, ur.prototype.outputDefined = function() {
          return this.result.outputDefined();
        }, ur.prototype.serialize = function() {
          for (var t4 = ["let"], e2 = 0, r2 = this.bindings; e2 < r2.length; e2 += 1) {
            var n2 = r2[e2];
            t4.push(n2[0], n2[1].serialize());
          }
          return t4.push(this.result.serialize()), t4;
        };
        var lr = function(t4, e2, r2) {
          this.type = t4, this.index = e2, this.input = r2;
        };
        lr.parse = function(t4, e2) {
          if (3 !== t4.length)
            return e2.error("Expected 2 arguments, but found " + (t4.length - 1) + " instead.");
          var r2 = e2.parse(t4[1], 1, Ot), n2 = e2.parse(t4[2], 2, Xt(e2.expectedType || Nt));
          return r2 && n2 ? new lr(n2.type.itemType, r2, n2) : null;
        }, lr.prototype.evaluate = function(t4) {
          var e2 = this.index.evaluate(t4), r2 = this.input.evaluate(t4);
          if (e2 < 0)
            throw new pe("Array index out of bounds: " + e2 + " < 0.");
          if (e2 >= r2.length)
            throw new pe("Array index out of bounds: " + e2 + " > " + (r2.length - 1) + ".");
          if (e2 !== Math.floor(e2))
            throw new pe("Array index must be an integer, but found " + e2 + " instead.");
          return r2[e2];
        }, lr.prototype.eachChild = function(t4) {
          t4(this.index), t4(this.input);
        }, lr.prototype.outputDefined = function() {
          return false;
        }, lr.prototype.serialize = function() {
          return ["at", this.index.serialize(), this.input.serialize()];
        };
        var pr = function(t4, e2) {
          this.type = Ut, this.needle = t4, this.haystack = e2;
        };
        pr.parse = function(t4, e2) {
          if (3 !== t4.length)
            return e2.error("Expected 2 arguments, but found " + (t4.length - 1) + " instead.");
          var r2 = e2.parse(t4[1], 1, Nt), n2 = e2.parse(t4[2], 2, Nt);
          return r2 && n2 ? $t(r2.type, [Ut, Rt, Ot, Lt, Nt]) ? new pr(r2, n2) : e2.error("Expected first argument to be of type boolean, string, number or null, but found " + Jt(r2.type) + " instead") : null;
        }, pr.prototype.evaluate = function(t4) {
          var e2 = this.needle.evaluate(t4), r2 = this.haystack.evaluate(t4);
          if (!r2)
            return false;
          if (!Wt(e2, ["boolean", "string", "number", "null"]))
            throw new pe("Expected first argument to be of type boolean, string, number or null, but found " + Jt(se(e2)) + " instead.");
          if (!Wt(r2, ["string", "array"]))
            throw new pe("Expected second argument to be of type array or string, but found " + Jt(se(r2)) + " instead.");
          return r2.indexOf(e2) >= 0;
        }, pr.prototype.eachChild = function(t4) {
          t4(this.needle), t4(this.haystack);
        }, pr.prototype.outputDefined = function() {
          return true;
        }, pr.prototype.serialize = function() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        };
        var cr = function(t4, e2, r2) {
          this.type = Ot, this.needle = t4, this.haystack = e2, this.fromIndex = r2;
        };
        cr.parse = function(t4, e2) {
          if (t4.length <= 2 || t4.length >= 5)
            return e2.error("Expected 3 or 4 arguments, but found " + (t4.length - 1) + " instead.");
          var r2 = e2.parse(t4[1], 1, Nt), n2 = e2.parse(t4[2], 2, Nt);
          if (!r2 || !n2)
            return null;
          if (!$t(r2.type, [Ut, Rt, Ot, Lt, Nt]))
            return e2.error("Expected first argument to be of type boolean, string, number or null, but found " + Jt(r2.type) + " instead");
          if (4 === t4.length) {
            var i3 = e2.parse(t4[3], 3, Ot);
            return i3 ? new cr(r2, n2, i3) : null;
          }
          return new cr(r2, n2);
        }, cr.prototype.evaluate = function(t4) {
          var e2 = this.needle.evaluate(t4), r2 = this.haystack.evaluate(t4);
          if (!Wt(e2, ["boolean", "string", "number", "null"]))
            throw new pe("Expected first argument to be of type boolean, string, number or null, but found " + Jt(se(e2)) + " instead.");
          if (!Wt(r2, ["string", "array"]))
            throw new pe("Expected second argument to be of type array or string, but found " + Jt(se(r2)) + " instead.");
          if (this.fromIndex) {
            var n2 = this.fromIndex.evaluate(t4);
            return r2.indexOf(e2, n2);
          }
          return r2.indexOf(e2);
        }, cr.prototype.eachChild = function(t4) {
          t4(this.needle), t4(this.haystack), this.fromIndex && t4(this.fromIndex);
        }, cr.prototype.outputDefined = function() {
          return false;
        }, cr.prototype.serialize = function() {
          if (null != this.fromIndex && void 0 !== this.fromIndex) {
            var t4 = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), t4];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        };
        var hr = function(t4, e2, r2, n2, i3, a2) {
          this.inputType = t4, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i3, this.otherwise = a2;
        };
        hr.parse = function(t4, e2) {
          if (t4.length < 5)
            return e2.error("Expected at least 4 arguments, but found only " + (t4.length - 1) + ".");
          if (t4.length % 2 != 1)
            return e2.error("Expected an even number of arguments.");
          var r2, n2;
          e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
          for (var i3 = {}, a2 = [], o2 = 2; o2 < t4.length - 1; o2 += 2) {
            var s2 = t4[o2], u2 = t4[o2 + 1];
            Array.isArray(s2) || (s2 = [s2]);
            var l2 = e2.concat(o2);
            if (0 === s2.length)
              return l2.error("Expected at least one branch label.");
            for (var p2 = 0, c2 = s2; p2 < c2.length; p2 += 1) {
              var h2 = c2[p2];
              if ("number" != typeof h2 && "string" != typeof h2)
                return l2.error("Branch labels must be numbers or strings.");
              if ("number" == typeof h2 && Math.abs(h2) > Number.MAX_SAFE_INTEGER)
                return l2.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
              if ("number" == typeof h2 && Math.floor(h2) !== h2)
                return l2.error("Numeric branch labels must be integer values.");
              if (r2) {
                if (l2.checkSubtype(r2, se(h2)))
                  return null;
              } else
                r2 = se(h2);
              if (void 0 !== i3[String(h2)])
                return l2.error("Branch labels must be unique.");
              i3[String(h2)] = a2.length;
            }
            var f2 = e2.parse(u2, o2, n2);
            if (!f2)
              return null;
            n2 = n2 || f2.type, a2.push(f2);
          }
          var y2 = e2.parse(t4[1], 1, Nt);
          if (!y2)
            return null;
          var d2 = e2.parse(t4[t4.length - 1], t4.length - 1, n2);
          return d2 ? "value" !== y2.type.kind && e2.concat(1).checkSubtype(r2, y2.type) ? null : new hr(r2, n2, y2, i3, a2, d2) : null;
        }, hr.prototype.evaluate = function(t4) {
          var e2 = this.input.evaluate(t4);
          return (se(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t4);
        }, hr.prototype.eachChild = function(t4) {
          t4(this.input), this.outputs.forEach(t4), t4(this.otherwise);
        }, hr.prototype.outputDefined = function() {
          return this.outputs.every(function(t4) {
            return t4.outputDefined();
          }) && this.otherwise.outputDefined();
        }, hr.prototype.serialize = function() {
          for (var t4 = this, e2 = ["match", this.input.serialize()], r2 = [], n2 = {}, i3 = 0, a2 = Object.keys(this.cases).sort(); i3 < a2.length; i3 += 1) {
            var o2 = a2[i3];
            void 0 === (c2 = n2[this.cases[o2]]) ? (n2[this.cases[o2]] = r2.length, r2.push([this.cases[o2], [o2]])) : r2[c2][1].push(o2);
          }
          for (var s2 = function(e3) {
            return "number" === t4.inputType.kind ? Number(e3) : e3;
          }, u2 = 0, l2 = r2; u2 < l2.length; u2 += 1) {
            var p2 = l2[u2], c2 = p2[0], h2 = p2[1];
            e2.push(1 === h2.length ? s2(h2[0]) : h2.map(s2)), e2.push(this.outputs[outputIndex$1].serialize());
          }
          return e2.push(this.otherwise.serialize()), e2;
        };
        var fr = function(t4, e2, r2) {
          this.type = t4, this.branches = e2, this.otherwise = r2;
        };
        fr.parse = function(t4, e2) {
          if (t4.length < 4)
            return e2.error("Expected at least 3 arguments, but found only " + (t4.length - 1) + ".");
          if (t4.length % 2 != 0)
            return e2.error("Expected an odd number of arguments.");
          var r2;
          e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
          for (var n2 = [], i3 = 1; i3 < t4.length - 1; i3 += 2) {
            var a2 = e2.parse(t4[i3], i3, Ut);
            if (!a2)
              return null;
            var o2 = e2.parse(t4[i3 + 1], i3 + 1, r2);
            if (!o2)
              return null;
            n2.push([a2, o2]), r2 = r2 || o2.type;
          }
          var s2 = e2.parse(t4[t4.length - 1], t4.length - 1, r2);
          return s2 ? new fr(r2, n2, s2) : null;
        }, fr.prototype.evaluate = function(t4) {
          for (var e2 = 0, r2 = this.branches; e2 < r2.length; e2 += 1) {
            var n2 = r2[e2], i3 = n2[1];
            if (n2[0].evaluate(t4))
              return i3.evaluate(t4);
          }
          return this.otherwise.evaluate(t4);
        }, fr.prototype.eachChild = function(t4) {
          for (var e2 = 0, r2 = this.branches; e2 < r2.length; e2 += 1) {
            var n2 = r2[e2], i3 = n2[1];
            t4(n2[0]), t4(i3);
          }
          t4(this.otherwise);
        }, fr.prototype.outputDefined = function() {
          return this.branches.every(function(t4) {
            return t4[1].outputDefined();
          }) && this.otherwise.outputDefined();
        }, fr.prototype.serialize = function() {
          var t4 = ["case"];
          return this.eachChild(function(e2) {
            t4.push(e2.serialize());
          }), t4;
        };
        var yr = function(t4, e2, r2, n2) {
          this.type = t4, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
        };
        function dr(t4, e2) {
          return "==" === t4 || "!=" === t4 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
        }
        function mr(t4, e2, r2, n2) {
          return 0 === n2.compare(e2, r2);
        }
        function vr(t4, e2, r2) {
          var n2 = "==" !== t4 && "!=" !== t4;
          return function() {
            function i3(t5, e3, r3) {
              this.type = Ut, this.lhs = t5, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t5.type.kind || "value" === e3.type.kind;
            }
            return i3.parse = function(t5, e3) {
              if (3 !== t5.length && 4 !== t5.length)
                return e3.error("Expected two or three arguments.");
              var r3 = t5[0], a2 = e3.parse(t5[1], 1, Nt);
              if (!a2)
                return null;
              if (!dr(r3, a2.type))
                return e3.concat(1).error('"' + r3 + `" comparisons are not supported for type '` + Jt(a2.type) + "'.");
              var o2 = e3.parse(t5[2], 2, Nt);
              if (!o2)
                return null;
              if (!dr(r3, o2.type))
                return e3.concat(2).error('"' + r3 + `" comparisons are not supported for type '` + Jt(o2.type) + "'.");
              if (a2.type.kind !== o2.type.kind && "value" !== a2.type.kind && "value" !== o2.type.kind)
                return e3.error("Cannot compare types '" + Jt(a2.type) + "' and '" + Jt(o2.type) + "'.");
              n2 && ("value" === a2.type.kind && "value" !== o2.type.kind ? a2 = new he(o2.type, [a2]) : "value" !== a2.type.kind && "value" === o2.type.kind && (o2 = new he(a2.type, [o2])));
              var s2 = null;
              if (4 === t5.length) {
                if ("string" !== a2.type.kind && "string" !== o2.type.kind && "value" !== a2.type.kind && "value" !== o2.type.kind)
                  return e3.error("Cannot use collator to compare non-string types.");
                if (!(s2 = e3.parse(t5[3], 3, Kt)))
                  return null;
              }
              return new i3(a2, o2, s2);
            }, i3.prototype.evaluate = function(i4) {
              var a2 = this.lhs.evaluate(i4), o2 = this.rhs.evaluate(i4);
              if (n2 && this.hasUntypedArgument) {
                var s2 = se(a2), u2 = se(o2);
                if (s2.kind !== u2.kind || "string" !== s2.kind && "number" !== s2.kind)
                  throw new pe('Expected arguments for "' + t4 + '" to be (string, string) or (number, number), but found (' + s2.kind + ", " + u2.kind + ") instead.");
              }
              if (this.collator && !n2 && this.hasUntypedArgument) {
                var l2 = se(a2), p2 = se(o2);
                if ("string" !== l2.kind || "string" !== p2.kind)
                  return e2(i4, a2, o2);
              }
              return this.collator ? r2(i4, a2, o2, this.collator.evaluate(i4)) : e2(i4, a2, o2);
            }, i3.prototype.eachChild = function(t5) {
              t5(this.lhs), t5(this.rhs), this.collator && t5(this.collator);
            }, i3.prototype.outputDefined = function() {
              return true;
            }, i3.prototype.serialize = function() {
              var e3 = [t4];
              return this.eachChild(function(t5) {
                e3.push(t5.serialize());
              }), e3;
            }, i3;
          }();
        }
        yr.parse = function(t4, e2) {
          if (t4.length <= 2 || t4.length >= 5)
            return e2.error("Expected 3 or 4 arguments, but found " + (t4.length - 1) + " instead.");
          var r2 = e2.parse(t4[1], 1, Nt), n2 = e2.parse(t4[2], 2, Ot);
          if (!r2 || !n2)
            return null;
          if (!$t(r2.type, [Xt(Nt), Rt, Nt]))
            return e2.error("Expected first argument to be of type array or string, but found " + Jt(r2.type) + " instead");
          if (4 === t4.length) {
            var i3 = e2.parse(t4[3], 3, Ot);
            return i3 ? new yr(r2.type, r2, n2, i3) : null;
          }
          return new yr(r2.type, r2, n2);
        }, yr.prototype.evaluate = function(t4) {
          var e2 = this.input.evaluate(t4), r2 = this.beginIndex.evaluate(t4);
          if (!Wt(e2, ["string", "array"]))
            throw new pe("Expected first argument to be of type array or string, but found " + Jt(se(e2)) + " instead.");
          if (this.endIndex) {
            var n2 = this.endIndex.evaluate(t4);
            return e2.slice(r2, n2);
          }
          return e2.slice(r2);
        }, yr.prototype.eachChild = function(t4) {
          t4(this.input), t4(this.beginIndex), this.endIndex && t4(this.endIndex);
        }, yr.prototype.outputDefined = function() {
          return false;
        }, yr.prototype.serialize = function() {
          if (null != this.endIndex && void 0 !== this.endIndex) {
            var t4 = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), t4];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        };
        var gr = vr("==", function(t4, e2, r2) {
          return e2 === r2;
        }, mr), xr = vr("!=", function(t4, e2, r2) {
          return e2 !== r2;
        }, function(t4, e2, r2, n2) {
          return !mr(0, e2, r2, n2);
        }), br = vr("<", function(t4, e2, r2) {
          return e2 < r2;
        }, function(t4, e2, r2, n2) {
          return n2.compare(e2, r2) < 0;
        }), wr = vr(">", function(t4, e2, r2) {
          return e2 > r2;
        }, function(t4, e2, r2, n2) {
          return n2.compare(e2, r2) > 0;
        }), _r = vr("<=", function(t4, e2, r2) {
          return e2 <= r2;
        }, function(t4, e2, r2, n2) {
          return n2.compare(e2, r2) <= 0;
        }), Ar = vr(">=", function(t4, e2, r2) {
          return e2 >= r2;
        }, function(t4, e2, r2, n2) {
          return n2.compare(e2, r2) >= 0;
        }), Sr = function(t4, e2, r2, n2, i3) {
          this.type = Rt, this.number = t4, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i3;
        };
        Sr.parse = function(t4, e2) {
          if (3 !== t4.length)
            return e2.error("Expected two arguments.");
          var r2 = e2.parse(t4[1], 1, Ot);
          if (!r2)
            return null;
          var n2 = t4[2];
          if ("object" != typeof n2 || Array.isArray(n2))
            return e2.error("NumberFormat options argument must be an object.");
          var i3 = null;
          if (n2.locale && !(i3 = e2.parse(n2.locale, 1, Rt)))
            return null;
          var a2 = null;
          if (n2.currency && !(a2 = e2.parse(n2.currency, 1, Rt)))
            return null;
          var o2 = null;
          if (n2["min-fraction-digits"] && !(o2 = e2.parse(n2["min-fraction-digits"], 1, Ot)))
            return null;
          var s2 = null;
          return n2["max-fraction-digits"] && !(s2 = e2.parse(n2["max-fraction-digits"], 1, Ot)) ? null : new Sr(r2, i3, a2, o2, s2);
        }, Sr.prototype.evaluate = function(t4) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t4) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t4) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t4) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t4) : void 0 }).format(this.number.evaluate(t4));
        }, Sr.prototype.eachChild = function(t4) {
          t4(this.number), this.locale && t4(this.locale), this.currency && t4(this.currency), this.minFractionDigits && t4(this.minFractionDigits), this.maxFractionDigits && t4(this.maxFractionDigits);
        }, Sr.prototype.outputDefined = function() {
          return false;
        }, Sr.prototype.serialize = function() {
          var t4 = {};
          return this.locale && (t4.locale = this.locale.serialize()), this.currency && (t4.currency = this.currency.serialize()), this.minFractionDigits && (t4["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t4["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t4];
        };
        var kr = function(t4) {
          this.type = Ot, this.input = t4;
        };
        kr.parse = function(t4, e2) {
          if (2 !== t4.length)
            return e2.error("Expected 1 argument, but found " + (t4.length - 1) + " instead.");
          var r2 = e2.parse(t4[1], 1);
          return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error("Expected argument of type string or array, but found " + Jt(r2.type) + " instead.") : new kr(r2) : null;
        }, kr.prototype.evaluate = function(t4) {
          var e2 = this.input.evaluate(t4);
          if ("string" == typeof e2)
            return e2.length;
          if (Array.isArray(e2))
            return e2.length;
          throw new pe("Expected value to be of type string or array, but found " + Jt(se(e2)) + " instead.");
        }, kr.prototype.eachChild = function(t4) {
          t4(this.input);
        }, kr.prototype.outputDefined = function() {
          return false;
        }, kr.prototype.serialize = function() {
          var t4 = ["length"];
          return this.eachChild(function(e2) {
            t4.push(e2.serialize());
          }), t4;
        };
        var Ir = { "==": gr, "!=": xr, ">": wr, "<": br, ">=": Ar, "<=": _r, array: he, at: lr, boolean: he, case: fr, coalesce: sr, collator: be, format: fe, image: ye, in: pr, "index-of": cr, interpolate: ar, "interpolate-hcl": ar, "interpolate-lab": ar, length: kr, let: ur, literal: le, match: hr, number: he, "number-format": Sr, object: he, slice: yr, step: Ne, string: he, "to-boolean": me, "to-color": me, "to-number": me, "to-string": me, var: Ue, within: De };
        function zr(t4, e2) {
          var r2 = e2[0], n2 = e2[1], i3 = e2[2], a2 = e2[3];
          r2 = r2.evaluate(t4), n2 = n2.evaluate(t4), i3 = i3.evaluate(t4);
          var o2 = a2 ? a2.evaluate(t4) : 1, s2 = ae(r2, n2, i3, o2);
          if (s2)
            throw new pe(s2);
          return new te(r2 / 255 * o2, n2 / 255 * o2, i3 / 255 * o2, o2);
        }
        function Cr(t4, e2) {
          return t4 in e2;
        }
        function Er(t4, e2) {
          var r2 = e2[t4];
          return void 0 === r2 ? null : r2;
        }
        function Pr(t4) {
          return { type: t4 };
        }
        function Mr(t4) {
          return { result: "success", value: t4 };
        }
        function Br(t4) {
          return { result: "error", value: t4 };
        }
        function Tr(t4) {
          return "data-driven" === t4["property-type"] || "cross-faded-data-driven" === t4["property-type"];
        }
        function Vr(t4) {
          return !!t4.expression && t4.expression.parameters.indexOf("zoom") > -1;
        }
        function Fr(t4) {
          return !!t4.expression && t4.expression.interpolated;
        }
        function Dr(t4) {
          return t4 instanceof Number ? "number" : t4 instanceof String ? "string" : t4 instanceof Boolean ? "boolean" : Array.isArray(t4) ? "array" : null === t4 ? "null" : typeof t4;
        }
        function Lr(t4) {
          return "object" == typeof t4 && null !== t4 && !Array.isArray(t4);
        }
        function Or(t4) {
          return t4;
        }
        function Rr(t4, e2, r2) {
          return void 0 !== t4 ? t4 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
        }
        function Ur(t4, e2, r2, n2, i3) {
          return Rr(typeof r2 === i3 ? n2[r2] : void 0, t4.default, e2.default);
        }
        function jr(t4, e2, r2) {
          if ("number" !== Dr(r2))
            return Rr(t4.default, e2.default);
          var n2 = t4.stops.length;
          if (1 === n2)
            return t4.stops[0][1];
          if (r2 <= t4.stops[0][0])
            return t4.stops[0][1];
          if (r2 >= t4.stops[n2 - 1][0])
            return t4.stops[n2 - 1][1];
          var i3 = qe(t4.stops.map(function(t5) {
            return t5[0];
          }), r2);
          return t4.stops[i3][1];
        }
        function qr(t4, e2, r2) {
          var n2 = void 0 !== t4.base ? t4.base : 1;
          if ("number" !== Dr(r2))
            return Rr(t4.default, e2.default);
          var i3 = t4.stops.length;
          if (1 === i3)
            return t4.stops[0][1];
          if (r2 <= t4.stops[0][0])
            return t4.stops[0][1];
          if (r2 >= t4.stops[i3 - 1][0])
            return t4.stops[i3 - 1][1];
          var a2 = qe(t4.stops.map(function(t5) {
            return t5[0];
          }), r2), o2 = function(t5, e3, r3, n3) {
            var i4 = n3 - r3, a3 = t5 - r3;
            return 0 === i4 ? 0 : 1 === e3 ? a3 / i4 : (Math.pow(e3, a3) - 1) / (Math.pow(e3, i4) - 1);
          }(r2, n2, t4.stops[a2][0], t4.stops[a2 + 1][0]), s2 = t4.stops[a2][1], u2 = t4.stops[a2 + 1][1], l2 = Ge[e2.type] || Or;
          if (t4.colorSpace && "rgb" !== t4.colorSpace) {
            var p2 = ir[t4.colorSpace];
            l2 = function(t5, e3) {
              return p2.reverse(p2.interpolate(p2.forward(t5), p2.forward(e3), o2));
            };
          }
          return "function" == typeof s2.evaluate ? { evaluate: function() {
            for (var t5 = [], e3 = arguments.length; e3--; )
              t5[e3] = arguments[e3];
            var r3 = s2.evaluate.apply(void 0, t5), n3 = u2.evaluate.apply(void 0, t5);
            if (void 0 !== r3 && void 0 !== n3)
              return l2(r3, n3, o2);
          } } : l2(s2, u2, o2);
        }
        function Nr(t4, e2, r2) {
          return "color" === e2.type ? r2 = te.parse(r2) : "formatted" === e2.type ? r2 = ne.fromString(r2.toString()) : "resolvedImage" === e2.type ? r2 = ie.fromString(r2.toString()) : Dr(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0), Rr(r2, t4.default, e2.default);
        }
        xe.register(Ir, { error: [{ kind: "error" }, [Rt], function(t4, e2) {
          throw new pe(e2[0].evaluate(t4));
        }], typeof: [Rt, [Nt], function(t4, e2) {
          return Jt(se(e2[0].evaluate(t4)));
        }], "to-rgba": [Xt(Ot, 4), [jt], function(t4, e2) {
          return e2[0].evaluate(t4).toArray();
        }], rgb: [jt, [Ot, Ot, Ot], zr], rgba: [jt, [Ot, Ot, Ot, Ot], zr], has: { type: Ut, overloads: [[[Rt], function(t4, e2) {
          return Cr(e2[0].evaluate(t4), t4.properties());
        }], [[Rt, qt], function(t4, e2) {
          var r2 = e2[1];
          return Cr(e2[0].evaluate(t4), r2.evaluate(t4));
        }]] }, get: { type: Nt, overloads: [[[Rt], function(t4, e2) {
          return Er(e2[0].evaluate(t4), t4.properties());
        }], [[Rt, qt], function(t4, e2) {
          var r2 = e2[1];
          return Er(e2[0].evaluate(t4), r2.evaluate(t4));
        }]] }, "feature-state": [Nt, [Rt], function(t4, e2) {
          return Er(e2[0].evaluate(t4), t4.featureState || {});
        }], properties: [qt, [], function(t4) {
          return t4.properties();
        }], "geometry-type": [Rt, [], function(t4) {
          return t4.geometryType();
        }], id: [Nt, [], function(t4) {
          return t4.id();
        }], zoom: [Ot, [], function(t4) {
          return t4.globals.zoom;
        }], "heatmap-density": [Ot, [], function(t4) {
          return t4.globals.heatmapDensity || 0;
        }], "line-progress": [Ot, [], function(t4) {
          return t4.globals.lineProgress || 0;
        }], accumulated: [Nt, [], function(t4) {
          return void 0 === t4.globals.accumulated ? null : t4.globals.accumulated;
        }], "+": [Ot, Pr(Ot), function(t4, e2) {
          for (var r2 = 0, n2 = 0, i3 = e2; n2 < i3.length; n2 += 1)
            r2 += i3[n2].evaluate(t4);
          return r2;
        }], "*": [Ot, Pr(Ot), function(t4, e2) {
          for (var r2 = 1, n2 = 0, i3 = e2; n2 < i3.length; n2 += 1)
            r2 *= i3[n2].evaluate(t4);
          return r2;
        }], "-": { type: Ot, overloads: [[[Ot, Ot], function(t4, e2) {
          var r2 = e2[1];
          return e2[0].evaluate(t4) - r2.evaluate(t4);
        }], [[Ot], function(t4, e2) {
          return -e2[0].evaluate(t4);
        }]] }, "/": [Ot, [Ot, Ot], function(t4, e2) {
          var r2 = e2[1];
          return e2[0].evaluate(t4) / r2.evaluate(t4);
        }], "%": [Ot, [Ot, Ot], function(t4, e2) {
          var r2 = e2[1];
          return e2[0].evaluate(t4) % r2.evaluate(t4);
        }], ln2: [Ot, [], function() {
          return Math.LN2;
        }], pi: [Ot, [], function() {
          return Math.PI;
        }], e: [Ot, [], function() {
          return Math.E;
        }], "^": [Ot, [Ot, Ot], function(t4, e2) {
          var r2 = e2[1];
          return Math.pow(e2[0].evaluate(t4), r2.evaluate(t4));
        }], sqrt: [Ot, [Ot], function(t4, e2) {
          return Math.sqrt(e2[0].evaluate(t4));
        }], log10: [Ot, [Ot], function(t4, e2) {
          return Math.log(e2[0].evaluate(t4)) / Math.LN10;
        }], ln: [Ot, [Ot], function(t4, e2) {
          return Math.log(e2[0].evaluate(t4));
        }], log2: [Ot, [Ot], function(t4, e2) {
          return Math.log(e2[0].evaluate(t4)) / Math.LN2;
        }], sin: [Ot, [Ot], function(t4, e2) {
          return Math.sin(e2[0].evaluate(t4));
        }], cos: [Ot, [Ot], function(t4, e2) {
          return Math.cos(e2[0].evaluate(t4));
        }], tan: [Ot, [Ot], function(t4, e2) {
          return Math.tan(e2[0].evaluate(t4));
        }], asin: [Ot, [Ot], function(t4, e2) {
          return Math.asin(e2[0].evaluate(t4));
        }], acos: [Ot, [Ot], function(t4, e2) {
          return Math.acos(e2[0].evaluate(t4));
        }], atan: [Ot, [Ot], function(t4, e2) {
          return Math.atan(e2[0].evaluate(t4));
        }], min: [Ot, Pr(Ot), function(t4, e2) {
          return Math.min.apply(Math, e2.map(function(e3) {
            return e3.evaluate(t4);
          }));
        }], max: [Ot, Pr(Ot), function(t4, e2) {
          return Math.max.apply(Math, e2.map(function(e3) {
            return e3.evaluate(t4);
          }));
        }], abs: [Ot, [Ot], function(t4, e2) {
          return Math.abs(e2[0].evaluate(t4));
        }], round: [Ot, [Ot], function(t4, e2) {
          var r2 = e2[0].evaluate(t4);
          return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
        }], floor: [Ot, [Ot], function(t4, e2) {
          return Math.floor(e2[0].evaluate(t4));
        }], ceil: [Ot, [Ot], function(t4, e2) {
          return Math.ceil(e2[0].evaluate(t4));
        }], "filter-==": [Ut, [Rt, Nt], function(t4, e2) {
          var r2 = e2[0], n2 = e2[1];
          return t4.properties()[r2.value] === n2.value;
        }], "filter-id-==": [Ut, [Nt], function(t4, e2) {
          var r2 = e2[0];
          return t4.id() === r2.value;
        }], "filter-type-==": [Ut, [Rt], function(t4, e2) {
          var r2 = e2[0];
          return t4.geometryType() === r2.value;
        }], "filter-<": [Ut, [Rt, Nt], function(t4, e2) {
          var r2 = e2[0], n2 = e2[1], i3 = t4.properties()[r2.value], a2 = n2.value;
          return typeof i3 == typeof a2 && i3 < a2;
        }], "filter-id-<": [Ut, [Nt], function(t4, e2) {
          var r2 = e2[0], n2 = t4.id(), i3 = r2.value;
          return typeof n2 == typeof i3 && n2 < i3;
        }], "filter->": [Ut, [Rt, Nt], function(t4, e2) {
          var r2 = e2[0], n2 = e2[1], i3 = t4.properties()[r2.value], a2 = n2.value;
          return typeof i3 == typeof a2 && i3 > a2;
        }], "filter-id->": [Ut, [Nt], function(t4, e2) {
          var r2 = e2[0], n2 = t4.id(), i3 = r2.value;
          return typeof n2 == typeof i3 && n2 > i3;
        }], "filter-<=": [Ut, [Rt, Nt], function(t4, e2) {
          var r2 = e2[0], n2 = e2[1], i3 = t4.properties()[r2.value], a2 = n2.value;
          return typeof i3 == typeof a2 && i3 <= a2;
        }], "filter-id-<=": [Ut, [Nt], function(t4, e2) {
          var r2 = e2[0], n2 = t4.id(), i3 = r2.value;
          return typeof n2 == typeof i3 && n2 <= i3;
        }], "filter->=": [Ut, [Rt, Nt], function(t4, e2) {
          var r2 = e2[0], n2 = e2[1], i3 = t4.properties()[r2.value], a2 = n2.value;
          return typeof i3 == typeof a2 && i3 >= a2;
        }], "filter-id->=": [Ut, [Nt], function(t4, e2) {
          var r2 = e2[0], n2 = t4.id(), i3 = r2.value;
          return typeof n2 == typeof i3 && n2 >= i3;
        }], "filter-has": [Ut, [Nt], function(t4, e2) {
          return e2[0].value in t4.properties();
        }], "filter-has-id": [Ut, [], function(t4) {
          return null !== t4.id() && void 0 !== t4.id();
        }], "filter-type-in": [Ut, [Xt(Rt)], function(t4, e2) {
          return e2[0].value.indexOf(t4.geometryType()) >= 0;
        }], "filter-id-in": [Ut, [Xt(Nt)], function(t4, e2) {
          return e2[0].value.indexOf(t4.id()) >= 0;
        }], "filter-in-small": [Ut, [Rt, Xt(Nt)], function(t4, e2) {
          var r2 = e2[0];
          return e2[1].value.indexOf(t4.properties()[r2.value]) >= 0;
        }], "filter-in-large": [Ut, [Rt, Xt(Nt)], function(t4, e2) {
          var r2 = e2[0], n2 = e2[1];
          return function(t5, e3, r3, n3) {
            for (; r3 <= n3; ) {
              var i3 = r3 + n3 >> 1;
              if (e3[i3] === t5)
                return true;
              e3[i3] > t5 ? n3 = i3 - 1 : r3 = i3 + 1;
            }
            return false;
          }(t4.properties()[r2.value], n2.value, 0, n2.value.length - 1);
        }], all: { type: Ut, overloads: [[[Ut, Ut], function(t4, e2) {
          var r2 = e2[1];
          return e2[0].evaluate(t4) && r2.evaluate(t4);
        }], [Pr(Ut), function(t4, e2) {
          for (var r2 = 0, n2 = e2; r2 < n2.length; r2 += 1)
            if (!n2[r2].evaluate(t4))
              return false;
          return true;
        }]] }, any: { type: Ut, overloads: [[[Ut, Ut], function(t4, e2) {
          var r2 = e2[1];
          return e2[0].evaluate(t4) || r2.evaluate(t4);
        }], [Pr(Ut), function(t4, e2) {
          for (var r2 = 0, n2 = e2; r2 < n2.length; r2 += 1)
            if (n2[r2].evaluate(t4))
              return true;
          return false;
        }]] }, "!": [Ut, [Ut], function(t4, e2) {
          return !e2[0].evaluate(t4);
        }], "is-supported-script": [Ut, [Rt], function(t4, e2) {
          var r2 = t4.globals && t4.globals.isSupportedScript;
          return !r2 || r2(e2[0].evaluate(t4));
        }], upcase: [Rt, [Rt], function(t4, e2) {
          return e2[0].evaluate(t4).toUpperCase();
        }], downcase: [Rt, [Rt], function(t4, e2) {
          return e2[0].evaluate(t4).toLowerCase();
        }], concat: [Rt, Pr(Nt), function(t4, e2) {
          return e2.map(function(e3) {
            return ue(e3.evaluate(t4));
          }).join("");
        }], "resolved-locale": [Rt, [Kt], function(t4, e2) {
          return e2[0].evaluate(t4).resolvedLocale();
        }] });
        var Kr = function(t4, e2) {
          this.expression = t4, this._warningHistory = {}, this._evaluator = new ge(), this._defaultValue = e2 ? function(t5) {
            return "color" === t5.type && Lr(t5.default) ? new te(0, 0, 0, 0) : "color" === t5.type ? te.parse(t5.default) || null : void 0 === t5.default ? null : t5.default;
          }(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
        };
        function Gr(t4) {
          return Array.isArray(t4) && t4.length > 0 && "string" == typeof t4[0] && t4[0] in Ir;
        }
        function Zr(t4, e2) {
          var r2 = new je(Ir, [], e2 ? function(t5) {
            var e3 = { color: jt, string: Rt, number: Ot, enum: Rt, boolean: Ut, formatted: Gt, resolvedImage: Zt };
            return "array" === t5.type ? Xt(e3[t5.value] || Nt, t5.length) : e3[t5.type];
          }(e2) : void 0), n2 = r2.parse(t4, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
          return n2 ? Mr(new Kr(n2, e2)) : Br(r2.errors);
        }
        Kr.prototype.evaluateWithoutErrorHandling = function(t4, e2, r2, n2, i3, a2) {
          return this._evaluator.globals = t4, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = a2, this.expression.evaluate(this._evaluator);
        }, Kr.prototype.evaluate = function(t4, e2, r2, n2, i3, a2) {
          this._evaluator.globals = t4, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = a2 || null;
          try {
            var o2 = this.expression.evaluate(this._evaluator);
            if (null == o2 || "number" == typeof o2 && o2 != o2)
              return this._defaultValue;
            if (this._enumValues && !(o2 in this._enumValues))
              throw new pe("Expected value to be one of " + Object.keys(this._enumValues).map(function(t5) {
                return JSON.stringify(t5);
              }).join(", ") + ", but found " + JSON.stringify(o2) + " instead.");
            return o2;
          } catch (t5) {
            return this._warningHistory[t5.message] || (this._warningHistory[t5.message] = true, "undefined" != typeof console && console.warn(t5.message)), this._defaultValue;
          }
        };
        var Xr = function(t4, e2) {
          this.kind = t4, this._styleExpression = e2, this.isStateDependent = "constant" !== t4 && !Oe(e2.expression);
        };
        Xr.prototype.evaluateWithoutErrorHandling = function(t4, e2, r2, n2, i3, a2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t4, e2, r2, n2, i3, a2);
        }, Xr.prototype.evaluate = function(t4, e2, r2, n2, i3, a2) {
          return this._styleExpression.evaluate(t4, e2, r2, n2, i3, a2);
        };
        var Jr = function(t4, e2, r2, n2) {
          this.kind = t4, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t4 && !Oe(e2.expression), this.interpolationType = n2;
        };
        function Hr(t4, e2) {
          if ("error" === (t4 = Zr(t4, e2)).result)
            return t4;
          var r2 = t4.value.expression, n2 = Le(r2);
          if (!n2 && !Tr(e2))
            return Br([new Ft("", "data expressions not supported")]);
          var i3 = Re(r2, ["zoom"]);
          if (!i3 && !Vr(e2))
            return Br([new Ft("", "zoom expressions not supported")]);
          var a2 = function t5(e3) {
            var r3 = null;
            if (e3 instanceof ur)
              r3 = t5(e3.result);
            else if (e3 instanceof sr)
              for (var n3 = 0, i4 = e3.args; n3 < i4.length && !(r3 = t5(i4[n3])); n3 += 1)
                ;
            else
              (e3 instanceof Ne || e3 instanceof ar) && e3.input instanceof xe && "zoom" === e3.input.name && (r3 = e3);
            return r3 instanceof Ft || e3.eachChild(function(e4) {
              var n4 = t5(e4);
              n4 instanceof Ft ? r3 = n4 : !r3 && n4 ? r3 = new Ft("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : r3 && n4 && r3 !== n4 && (r3 = new Ft("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), r3;
          }(r2);
          return a2 || i3 ? a2 instanceof Ft ? Br([a2]) : a2 instanceof ar && !Fr(e2) ? Br([new Ft("", '"interpolate" expressions cannot be used with this property')]) : Mr(a2 ? new Jr(n2 ? "camera" : "composite", t4.value, a2.labels, a2 instanceof ar ? a2.interpolation : void 0) : new Xr(n2 ? "constant" : "source", t4.value)) : Br([new Ft("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        Jr.prototype.evaluateWithoutErrorHandling = function(t4, e2, r2, n2, i3, a2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t4, e2, r2, n2, i3, a2);
        }, Jr.prototype.evaluate = function(t4, e2, r2, n2, i3, a2) {
          return this._styleExpression.evaluate(t4, e2, r2, n2, i3, a2);
        }, Jr.prototype.interpolationFactor = function(t4, e2, r2) {
          return this.interpolationType ? ar.interpolationFactor(this.interpolationType, t4, e2, r2) : 0;
        };
        var Yr = function(t4, e2) {
          this._parameters = t4, this._specification = e2, Bt(this, function t5(e3, r2) {
            var n2, i3, a2, o2 = "color" === r2.type, s2 = e3.stops && "object" == typeof e3.stops[0][0], u2 = s2 || !(s2 || void 0 !== e3.property), l2 = e3.type || (Fr(r2) ? "exponential" : "interval");
            if (o2 && ((e3 = Bt({}, e3)).stops && (e3.stops = e3.stops.map(function(t6) {
              return [t6[0], te.parse(t6[1])];
            })), e3.default = te.parse(e3.default ? e3.default : r2.default)), e3.colorSpace && "rgb" !== e3.colorSpace && !ir[e3.colorSpace])
              throw new Error("Unknown color space: " + e3.colorSpace);
            if ("exponential" === l2)
              n2 = qr;
            else if ("interval" === l2)
              n2 = jr;
            else if ("categorical" === l2) {
              n2 = Ur, i3 = /* @__PURE__ */ Object.create(null);
              for (var p2 = 0, c2 = e3.stops; p2 < c2.length; p2 += 1) {
                var h2 = c2[p2];
                i3[h2[0]] = h2[1];
              }
              a2 = typeof e3.stops[0][0];
            } else {
              if ("identity" !== l2)
                throw new Error('Unknown function type "' + l2 + '"');
              n2 = Nr;
            }
            if (s2) {
              for (var f2 = {}, y2 = [], d2 = 0; d2 < e3.stops.length; d2++) {
                var m2 = e3.stops[d2], v2 = m2[0].zoom;
                void 0 === f2[v2] && (f2[v2] = { zoom: v2, type: e3.type, property: e3.property, default: e3.default, stops: [] }, y2.push(v2)), f2[v2].stops.push([m2[0].value, m2[1]]);
              }
              for (var g2 = [], x3 = 0, b2 = y2; x3 < b2.length; x3 += 1) {
                var w2 = b2[x3];
                g2.push([f2[w2].zoom, t5(f2[w2], r2)]);
              }
              var _2 = { name: "linear" };
              return { kind: "composite", interpolationType: _2, interpolationFactor: ar.interpolationFactor.bind(void 0, _2), zoomStops: g2.map(function(t6) {
                return t6[0];
              }), evaluate: function(t6, n3) {
                var i4 = t6.zoom;
                return qr({ stops: g2, base: e3.base }, r2, i4).evaluate(i4, n3);
              } };
            }
            if (u2) {
              var A3 = "exponential" === l2 ? { name: "exponential", base: void 0 !== e3.base ? e3.base : 1 } : null;
              return { kind: "camera", interpolationType: A3, interpolationFactor: ar.interpolationFactor.bind(void 0, A3), zoomStops: e3.stops.map(function(t6) {
                return t6[0];
              }), evaluate: function(t6) {
                return n2(e3, r2, t6.zoom, i3, a2);
              } };
            }
            return { kind: "source", evaluate: function(t6, o3) {
              var s3 = o3 && o3.properties ? o3.properties[e3.property] : void 0;
              return void 0 === s3 ? Rr(e3.default, r2.default) : n2(e3, r2, s3, i3, a2);
            } };
          }(this._parameters, this._specification));
        };
        function $r(t4) {
          var e2 = t4.key, r2 = t4.value, n2 = t4.valueSpec || {}, i3 = t4.objectElementValidators || {}, a2 = t4.style, o2 = t4.styleSpec, s2 = [], u2 = Dr(r2);
          if ("object" !== u2)
            return [new Pt(e2, r2, "object expected, " + u2 + " found")];
          for (var l2 in r2) {
            var p2 = l2.split(".")[0], c2 = n2[p2] || n2["*"], h2 = void 0;
            if (i3[p2])
              h2 = i3[p2];
            else if (n2[p2])
              h2 = An;
            else if (i3["*"])
              h2 = i3["*"];
            else {
              if (!n2["*"]) {
                s2.push(new Pt(e2, r2[l2], 'unknown property "' + l2 + '"'));
                continue;
              }
              h2 = An;
            }
            s2 = s2.concat(h2({ key: (e2 ? e2 + "." : e2) + l2, value: r2[l2], valueSpec: c2, style: a2, styleSpec: o2, object: r2, objectKey: l2 }, r2));
          }
          for (var f2 in n2)
            i3[f2] || n2[f2].required && void 0 === n2[f2].default && void 0 === r2[f2] && s2.push(new Pt(e2, r2, 'missing required property "' + f2 + '"'));
          return s2;
        }
        function Wr(t4) {
          var e2 = t4.value, r2 = t4.valueSpec, n2 = t4.style, i3 = t4.styleSpec, a2 = t4.key, o2 = t4.arrayElementValidator || An;
          if ("array" !== Dr(e2))
            return [new Pt(a2, e2, "array expected, " + Dr(e2) + " found")];
          if (r2.length && e2.length !== r2.length)
            return [new Pt(a2, e2, "array length " + r2.length + " expected, length " + e2.length + " found")];
          if (r2["min-length"] && e2.length < r2["min-length"])
            return [new Pt(a2, e2, "array length at least " + r2["min-length"] + " expected, length " + e2.length + " found")];
          var s2 = { type: r2.value, values: r2.values };
          i3.$version < 7 && (s2.function = r2.function), "object" === Dr(r2.value) && (s2 = r2.value);
          for (var u2 = [], l2 = 0; l2 < e2.length; l2++)
            u2 = u2.concat(o2({ array: e2, arrayIndex: l2, value: e2[l2], valueSpec: s2, style: n2, styleSpec: i3, key: a2 + "[" + l2 + "]" }));
          return u2;
        }
        function Qr(t4) {
          var e2 = t4.key, r2 = t4.value, n2 = t4.valueSpec, i3 = Dr(r2);
          return "number" === i3 && r2 != r2 && (i3 = "NaN"), "number" !== i3 ? [new Pt(e2, r2, "number expected, " + i3 + " found")] : "minimum" in n2 && r2 < n2.minimum ? [new Pt(e2, r2, r2 + " is less than the minimum value " + n2.minimum)] : "maximum" in n2 && r2 > n2.maximum ? [new Pt(e2, r2, r2 + " is greater than the maximum value " + n2.maximum)] : [];
        }
        function tn(t4) {
          var e2, r2, n2, i3 = t4.valueSpec, a2 = Tt(t4.value.type), o2 = {}, s2 = "categorical" !== a2 && void 0 === t4.value.property, u2 = !s2, l2 = "array" === Dr(t4.value.stops) && "array" === Dr(t4.value.stops[0]) && "object" === Dr(t4.value.stops[0][0]), p2 = $r({ key: t4.key, value: t4.value, valueSpec: t4.styleSpec.function, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { stops: function(t5) {
            if ("identity" === a2)
              return [new Pt(t5.key, t5.value, 'identity function may not have a "stops" property')];
            var e3 = [], r3 = t5.value;
            return e3 = e3.concat(Wr({ key: t5.key, value: r3, valueSpec: t5.valueSpec, style: t5.style, styleSpec: t5.styleSpec, arrayElementValidator: c2 })), "array" === Dr(r3) && 0 === r3.length && e3.push(new Pt(t5.key, r3, "array must have at least one stop")), e3;
          }, default: function(t5) {
            return An({ key: t5.key, value: t5.value, valueSpec: i3, style: t5.style, styleSpec: t5.styleSpec });
          } } });
          return "identity" === a2 && s2 && p2.push(new Pt(t4.key, t4.value, 'missing required property "property"')), "identity" === a2 || t4.value.stops || p2.push(new Pt(t4.key, t4.value, 'missing required property "stops"')), "exponential" === a2 && t4.valueSpec.expression && !Fr(t4.valueSpec) && p2.push(new Pt(t4.key, t4.value, "exponential functions not supported")), t4.styleSpec.$version >= 8 && (u2 && !Tr(t4.valueSpec) ? p2.push(new Pt(t4.key, t4.value, "property functions not supported")) : s2 && !Vr(t4.valueSpec) && p2.push(new Pt(t4.key, t4.value, "zoom functions not supported"))), "categorical" !== a2 && !l2 || void 0 !== t4.value.property || p2.push(new Pt(t4.key, t4.value, '"property" property is required')), p2;
          function c2(t5) {
            var e3 = [], a3 = t5.value, s3 = t5.key;
            if ("array" !== Dr(a3))
              return [new Pt(s3, a3, "array expected, " + Dr(a3) + " found")];
            if (2 !== a3.length)
              return [new Pt(s3, a3, "array length 2 expected, length " + a3.length + " found")];
            if (l2) {
              if ("object" !== Dr(a3[0]))
                return [new Pt(s3, a3, "object expected, " + Dr(a3[0]) + " found")];
              if (void 0 === a3[0].zoom)
                return [new Pt(s3, a3, "object stop key must have zoom")];
              if (void 0 === a3[0].value)
                return [new Pt(s3, a3, "object stop key must have value")];
              if (n2 && n2 > Tt(a3[0].zoom))
                return [new Pt(s3, a3[0].zoom, "stop zoom values must appear in ascending order")];
              Tt(a3[0].zoom) !== n2 && (n2 = Tt(a3[0].zoom), r2 = void 0, o2 = {}), e3 = e3.concat($r({ key: s3 + "[0]", value: a3[0], valueSpec: { zoom: {} }, style: t5.style, styleSpec: t5.styleSpec, objectElementValidators: { zoom: Qr, value: h2 } }));
            } else
              e3 = e3.concat(h2({ key: s3 + "[0]", value: a3[0], valueSpec: {}, style: t5.style, styleSpec: t5.styleSpec }, a3));
            return Gr(Vt(a3[1])) ? e3.concat([new Pt(s3 + "[1]", a3[1], "expressions are not allowed in function stops.")]) : e3.concat(An({ key: s3 + "[1]", value: a3[1], valueSpec: i3, style: t5.style, styleSpec: t5.styleSpec }));
          }
          function h2(t5, n3) {
            var s3 = Dr(t5.value), u3 = Tt(t5.value), l3 = null !== t5.value ? t5.value : n3;
            if (e2) {
              if (s3 !== e2)
                return [new Pt(t5.key, l3, s3 + " stop domain type must match previous stop domain type " + e2)];
            } else
              e2 = s3;
            if ("number" !== s3 && "string" !== s3 && "boolean" !== s3)
              return [new Pt(t5.key, l3, "stop domain value must be a number, string, or boolean")];
            if ("number" !== s3 && "categorical" !== a2) {
              var p3 = "number expected, " + s3 + " found";
              return Tr(i3) && void 0 === a2 && (p3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Pt(t5.key, l3, p3)];
            }
            return "categorical" !== a2 || "number" !== s3 || isFinite(u3) && Math.floor(u3) === u3 ? "categorical" !== a2 && "number" === s3 && void 0 !== r2 && u3 < r2 ? [new Pt(t5.key, l3, "stop domain values must appear in ascending order")] : (r2 = u3, "categorical" === a2 && u3 in o2 ? [new Pt(t5.key, l3, "stop domain values must be unique")] : (o2[u3] = true, [])) : [new Pt(t5.key, l3, "integer expected, found " + u3)];
          }
        }
        function en(t4) {
          var e2 = ("property" === t4.expressionContext ? Hr : Zr)(Vt(t4.value), t4.valueSpec);
          if ("error" === e2.result)
            return e2.value.map(function(e3) {
              return new Pt("" + t4.key + e3.key, t4.value, e3.message);
            });
          var r2 = e2.value.expression || e2.value._styleExpression.expression;
          if ("property" === t4.expressionContext && "text-font" === t4.propertyKey && !r2.outputDefined())
            return [new Pt(t4.key, t4.value, 'Invalid data expression for "' + t4.propertyKey + '". Output values must be contained as literals within the expression.')];
          if ("property" === t4.expressionContext && "layout" === t4.propertyType && !Oe(r2))
            return [new Pt(t4.key, t4.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t4.expressionContext && !Oe(r2))
            return [new Pt(t4.key, t4.value, '"feature-state" data expressions are not supported with filters.')];
          if (t4.expressionContext && 0 === t4.expressionContext.indexOf("cluster")) {
            if (!Re(r2, ["zoom", "feature-state"]))
              return [new Pt(t4.key, t4.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t4.expressionContext && !Le(r2))
              return [new Pt(t4.key, t4.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function rn(t4) {
          var e2 = t4.key, r2 = t4.value, n2 = t4.valueSpec, i3 = [];
          return Array.isArray(n2.values) ? -1 === n2.values.indexOf(Tt(r2)) && i3.push(new Pt(e2, r2, "expected one of [" + n2.values.join(", ") + "], " + JSON.stringify(r2) + " found")) : -1 === Object.keys(n2.values).indexOf(Tt(r2)) && i3.push(new Pt(e2, r2, "expected one of [" + Object.keys(n2.values).join(", ") + "], " + JSON.stringify(r2) + " found")), i3;
        }
        function nn(t4) {
          if (true === t4 || false === t4)
            return true;
          if (!Array.isArray(t4) || 0 === t4.length)
            return false;
          switch (t4[0]) {
            case "has":
              return t4.length >= 2 && "$id" !== t4[1] && "$type" !== t4[1];
            case "in":
              return t4.length >= 3 && ("string" != typeof t4[1] || Array.isArray(t4[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t4.length || Array.isArray(t4[1]) || Array.isArray(t4[2]);
            case "any":
            case "all":
              for (var e2 = 0, r2 = t4.slice(1); e2 < r2.length; e2 += 1) {
                var n2 = r2[e2];
                if (!nn(n2) && "boolean" != typeof n2)
                  return false;
              }
              return true;
            default:
              return true;
          }
        }
        Yr.deserialize = function(t4) {
          return new Yr(t4._parameters, t4._specification);
        }, Yr.serialize = function(t4) {
          return { _parameters: t4._parameters, _specification: t4._specification };
        };
        var an = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function on(t4) {
          if (null == t4)
            return { filter: function() {
              return true;
            }, needGeometry: false };
          nn(t4) || (t4 = un(t4));
          var e2 = Zr(t4, an);
          if ("error" === e2.result)
            throw new Error(e2.value.map(function(t5) {
              return t5.key + ": " + t5.message;
            }).join(", "));
          return { filter: function(t5, r2, n2) {
            return e2.value.evaluate(t5, r2, {}, n2);
          }, needGeometry: function t5(e3) {
            if (!Array.isArray(e3))
              return false;
            if ("within" === e3[0])
              return true;
            for (var r2 = 1; r2 < e3.length; r2++)
              if (t5(e3[r2]))
                return true;
            return false;
          }(t4) };
        }
        function sn(t4, e2) {
          return t4 < e2 ? -1 : t4 > e2 ? 1 : 0;
        }
        function un(t4) {
          if (!t4)
            return true;
          var e2, r2 = t4[0];
          return t4.length <= 1 ? "any" !== r2 : "==" === r2 ? ln(t4[1], t4[2], "==") : "!=" === r2 ? hn(ln(t4[1], t4[2], "==")) : "<" === r2 || ">" === r2 || "<=" === r2 || ">=" === r2 ? ln(t4[1], t4[2], r2) : "any" === r2 ? (e2 = t4.slice(1), ["any"].concat(e2.map(un))) : "all" === r2 ? ["all"].concat(t4.slice(1).map(un)) : "none" === r2 ? ["all"].concat(t4.slice(1).map(un).map(hn)) : "in" === r2 ? pn(t4[1], t4.slice(2)) : "!in" === r2 ? hn(pn(t4[1], t4.slice(2))) : "has" === r2 ? cn(t4[1]) : "!has" === r2 ? hn(cn(t4[1])) : "within" !== r2 || t4;
        }
        function ln(t4, e2, r2) {
          switch (t4) {
            case "$type":
              return ["filter-type-" + r2, e2];
            case "$id":
              return ["filter-id-" + r2, e2];
            default:
              return ["filter-" + r2, t4, e2];
          }
        }
        function pn(t4, e2) {
          if (0 === e2.length)
            return false;
          switch (t4) {
            case "$type":
              return ["filter-type-in", ["literal", e2]];
            case "$id":
              return ["filter-id-in", ["literal", e2]];
            default:
              return e2.length > 200 && !e2.some(function(t5) {
                return typeof t5 != typeof e2[0];
              }) ? ["filter-in-large", t4, ["literal", e2.sort(sn)]] : ["filter-in-small", t4, ["literal", e2]];
          }
        }
        function cn(t4) {
          switch (t4) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t4];
          }
        }
        function hn(t4) {
          return ["!", t4];
        }
        function fn(t4) {
          return nn(Vt(t4.value)) ? en(Bt({}, t4, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : function t5(e2) {
            var r2 = e2.value, n2 = e2.key;
            if ("array" !== Dr(r2))
              return [new Pt(n2, r2, "array expected, " + Dr(r2) + " found")];
            var i3, a2 = e2.styleSpec, o2 = [];
            if (r2.length < 1)
              return [new Pt(n2, r2, "filter array must have at least 1 element")];
            switch (o2 = o2.concat(rn({ key: n2 + "[0]", value: r2[0], valueSpec: a2.filter_operator, style: e2.style, styleSpec: e2.styleSpec })), Tt(r2[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                r2.length >= 2 && "$type" === Tt(r2[1]) && o2.push(new Pt(n2, r2, '"$type" cannot be use with operator "' + r2[0] + '"'));
              case "==":
              case "!=":
                3 !== r2.length && o2.push(new Pt(n2, r2, 'filter array for operator "' + r2[0] + '" must have 3 elements'));
              case "in":
              case "!in":
                r2.length >= 2 && "string" !== (i3 = Dr(r2[1])) && o2.push(new Pt(n2 + "[1]", r2[1], "string expected, " + i3 + " found"));
                for (var s2 = 2; s2 < r2.length; s2++)
                  i3 = Dr(r2[s2]), "$type" === Tt(r2[1]) ? o2 = o2.concat(rn({ key: n2 + "[" + s2 + "]", value: r2[s2], valueSpec: a2.geometry_type, style: e2.style, styleSpec: e2.styleSpec })) : "string" !== i3 && "number" !== i3 && "boolean" !== i3 && o2.push(new Pt(n2 + "[" + s2 + "]", r2[s2], "string, number, or boolean expected, " + i3 + " found"));
                break;
              case "any":
              case "all":
              case "none":
                for (var u2 = 1; u2 < r2.length; u2++)
                  o2 = o2.concat(t5({ key: n2 + "[" + u2 + "]", value: r2[u2], style: e2.style, styleSpec: e2.styleSpec }));
                break;
              case "has":
              case "!has":
                i3 = Dr(r2[1]), 2 !== r2.length ? o2.push(new Pt(n2, r2, 'filter array for "' + r2[0] + '" operator must have 2 elements')) : "string" !== i3 && o2.push(new Pt(n2 + "[1]", r2[1], "string expected, " + i3 + " found"));
                break;
              case "within":
                i3 = Dr(r2[1]), 2 !== r2.length ? o2.push(new Pt(n2, r2, 'filter array for "' + r2[0] + '" operator must have 2 elements')) : "object" !== i3 && o2.push(new Pt(n2 + "[1]", r2[1], "object expected, " + i3 + " found"));
            }
            return o2;
          }(t4);
        }
        function yn(t4, e2) {
          var r2 = t4.key, n2 = t4.style, i3 = t4.styleSpec, a2 = t4.value, o2 = t4.objectKey, s2 = i3[e2 + "_" + t4.layerType];
          if (!s2)
            return [];
          var u2 = o2.match(/^(.*)-transition$/);
          if ("paint" === e2 && u2 && s2[u2[1]] && s2[u2[1]].transition)
            return An({ key: r2, value: a2, valueSpec: i3.transition, style: n2, styleSpec: i3 });
          var l2, p2 = t4.valueSpec || s2[o2];
          if (!p2)
            return [new Pt(r2, a2, 'unknown property "' + o2 + '"')];
          if ("string" === Dr(a2) && Tr(p2) && !p2.tokens && (l2 = /^{([^}]+)}$/.exec(a2)))
            return [new Pt(r2, a2, '"' + o2 + '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(l2[1]) + " }`.")];
          var c2 = [];
          return "symbol" === t4.layerType && ("text-field" === o2 && n2 && !n2.glyphs && c2.push(new Pt(r2, a2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o2 && Lr(Vt(a2)) && "identity" === Tt(a2.type) && c2.push(new Pt(r2, a2, '"text-font" does not support identity functions'))), c2.concat(An({ key: t4.key, value: a2, valueSpec: p2, style: n2, styleSpec: i3, expressionContext: "property", propertyType: e2, propertyKey: o2 }));
        }
        function dn(t4) {
          return yn(t4, "paint");
        }
        function mn(t4) {
          return yn(t4, "layout");
        }
        function vn(t4) {
          var e2 = [], r2 = t4.value, n2 = t4.key, i3 = t4.style, a2 = t4.styleSpec;
          r2.type || r2.ref || e2.push(new Pt(n2, r2, 'either "type" or "ref" is required'));
          var o2, s2 = Tt(r2.type), u2 = Tt(r2.ref);
          if (r2.id)
            for (var l2 = Tt(r2.id), p2 = 0; p2 < t4.arrayIndex; p2++) {
              var c2 = i3.layers[p2];
              Tt(c2.id) === l2 && e2.push(new Pt(n2, r2.id, 'duplicate layer id "' + r2.id + '", previously used at line ' + c2.id.__line__));
            }
          if ("ref" in r2)
            ["type", "source", "source-layer", "filter", "layout"].forEach(function(t5) {
              t5 in r2 && e2.push(new Pt(n2, r2[t5], '"' + t5 + '" is prohibited for ref layers'));
            }), i3.layers.forEach(function(t5) {
              Tt(t5.id) === u2 && (o2 = t5);
            }), o2 ? o2.ref ? e2.push(new Pt(n2, r2.ref, "ref cannot reference another ref layer")) : s2 = Tt(o2.type) : e2.push(new Pt(n2, r2.ref, 'ref layer "' + u2 + '" not found'));
          else if ("background" !== s2)
            if (r2.source) {
              var h2 = i3.sources && i3.sources[r2.source], f2 = h2 && Tt(h2.type);
              h2 ? "vector" === f2 && "raster" === s2 ? e2.push(new Pt(n2, r2.source, 'layer "' + r2.id + '" requires a raster source')) : "raster" === f2 && "raster" !== s2 ? e2.push(new Pt(n2, r2.source, 'layer "' + r2.id + '" requires a vector source')) : "vector" !== f2 || r2["source-layer"] ? "raster-dem" === f2 && "hillshade" !== s2 ? e2.push(new Pt(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === f2 && h2.lineMetrics || e2.push(new Pt(n2, r2, 'layer "' + r2.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')) : e2.push(new Pt(n2, r2, 'layer "' + r2.id + '" must specify a "source-layer"')) : e2.push(new Pt(n2, r2.source, 'source "' + r2.source + '" not found'));
            } else
              e2.push(new Pt(n2, r2, 'missing required property "source"'));
          return e2 = e2.concat($r({ key: n2, value: r2, valueSpec: a2.layer, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { "*": function() {
            return [];
          }, type: function() {
            return An({ key: n2 + ".type", value: r2.type, valueSpec: a2.layer.type, style: t4.style, styleSpec: t4.styleSpec, object: r2, objectKey: "type" });
          }, filter: fn, layout: function(t5) {
            return $r({ layer: r2, key: t5.key, value: t5.value, style: t5.style, styleSpec: t5.styleSpec, objectElementValidators: { "*": function(t6) {
              return mn(Bt({ layerType: s2 }, t6));
            } } });
          }, paint: function(t5) {
            return $r({ layer: r2, key: t5.key, value: t5.value, style: t5.style, styleSpec: t5.styleSpec, objectElementValidators: { "*": function(t6) {
              return dn(Bt({ layerType: s2 }, t6));
            } } });
          } } }));
        }
        function gn(t4) {
          var e2 = t4.value, r2 = t4.key, n2 = Dr(e2);
          return "string" !== n2 ? [new Pt(r2, e2, "string expected, " + n2 + " found")] : [];
        }
        var xn = { promoteId: function(t4) {
          var e2 = t4.key, r2 = t4.value;
          if ("string" === Dr(r2))
            return gn({ key: e2, value: r2 });
          var n2 = [];
          for (var i3 in r2)
            n2.push.apply(n2, gn({ key: e2 + "." + i3, value: r2[i3] }));
          return n2;
        } };
        function bn(t4) {
          var e2 = t4.value, r2 = t4.key, n2 = t4.styleSpec, i3 = t4.style;
          if (!e2.type)
            return [new Pt(r2, e2, '"type" is required')];
          var a2, o2 = Tt(e2.type);
          switch (o2) {
            case "vector":
            case "raster":
            case "raster-dem":
              return $r({ key: r2, value: e2, valueSpec: n2["source_" + o2.replace("-", "_")], style: t4.style, styleSpec: n2, objectElementValidators: xn });
            case "geojson":
              if (a2 = $r({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i3, styleSpec: n2, objectElementValidators: xn }), e2.cluster)
                for (var s2 in e2.clusterProperties) {
                  var u2 = e2.clusterProperties[s2], l2 = u2[0], p2 = "string" == typeof l2 ? [l2, ["accumulated"], ["get", s2]] : l2;
                  a2.push.apply(a2, en({ key: r2 + "." + s2 + ".map", value: u2[1], expressionContext: "cluster-map" })), a2.push.apply(a2, en({ key: r2 + "." + s2 + ".reduce", value: p2, expressionContext: "cluster-reduce" }));
                }
              return a2;
            case "video":
              return $r({ key: r2, value: e2, valueSpec: n2.source_video, style: i3, styleSpec: n2 });
            case "image":
              return $r({ key: r2, value: e2, valueSpec: n2.source_image, style: i3, styleSpec: n2 });
            case "canvas":
              return [new Pt(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return rn({ key: r2 + ".type", value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i3, styleSpec: n2 });
          }
        }
        function wn(t4) {
          var e2 = t4.value, r2 = t4.styleSpec, n2 = r2.light, i3 = t4.style, a2 = [], o2 = Dr(e2);
          if (void 0 === e2)
            return a2;
          if ("object" !== o2)
            return a2.concat([new Pt("light", e2, "object expected, " + o2 + " found")]);
          for (var s2 in e2) {
            var u2 = s2.match(/^(.*)-transition$/);
            a2 = a2.concat(u2 && n2[u2[1]] && n2[u2[1]].transition ? An({ key: s2, value: e2[s2], valueSpec: r2.transition, style: i3, styleSpec: r2 }) : n2[s2] ? An({ key: s2, value: e2[s2], valueSpec: n2[s2], style: i3, styleSpec: r2 }) : [new Pt(s2, e2[s2], 'unknown property "' + s2 + '"')]);
          }
          return a2;
        }
        var _n = { "*": function() {
          return [];
        }, array: Wr, boolean: function(t4) {
          var e2 = t4.value, r2 = t4.key, n2 = Dr(e2);
          return "boolean" !== n2 ? [new Pt(r2, e2, "boolean expected, " + n2 + " found")] : [];
        }, number: Qr, color: function(t4) {
          var e2 = t4.key, r2 = t4.value, n2 = Dr(r2);
          return "string" !== n2 ? [new Pt(e2, r2, "color expected, " + n2 + " found")] : null === Qt(r2) ? [new Pt(e2, r2, 'color expected, "' + r2 + '" found')] : [];
        }, constants: Mt, enum: rn, filter: fn, function: tn, layer: vn, object: $r, source: bn, light: wn, string: gn, formatted: function(t4) {
          return 0 === gn(t4).length ? [] : en(t4);
        }, resolvedImage: function(t4) {
          return 0 === gn(t4).length ? [] : en(t4);
        } };
        function An(t4) {
          var e2 = t4.value, r2 = t4.valueSpec, n2 = t4.styleSpec;
          return r2.expression && Lr(Tt(e2)) ? tn(t4) : r2.expression && Gr(Vt(e2)) ? en(t4) : r2.type && _n[r2.type] ? _n[r2.type](t4) : $r(Bt({}, t4, { valueSpec: r2.type ? n2[r2.type] : r2 }));
        }
        function Sn(t4) {
          var e2 = t4.value, r2 = t4.key, n2 = gn(t4);
          return n2.length || (-1 === e2.indexOf("{fontstack}") && n2.push(new Pt(r2, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n2.push(new Pt(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
        }
        function kn(t4, e2) {
          void 0 === e2 && (e2 = Et);
          var r2 = [];
          return r2 = r2.concat(An({ key: "", value: t4, valueSpec: e2.$root, styleSpec: e2, style: t4, objectElementValidators: { glyphs: Sn, "*": function() {
            return [];
          } } })), t4.constants && (r2 = r2.concat(Mt({ key: "constants", value: t4.constants, style: t4, styleSpec: e2 }))), In(r2);
        }
        function In(t4) {
          return [].concat(t4).sort(function(t5, e2) {
            return t5.line - e2.line;
          });
        }
        function zn(t4) {
          return function() {
            for (var e2 = [], r2 = arguments.length; r2--; )
              e2[r2] = arguments[r2];
            return In(t4.apply(this, e2));
          };
        }
        kn.source = zn(bn), kn.light = zn(wn), kn.layer = zn(vn), kn.filter = zn(fn), kn.paintProperty = zn(dn), kn.layoutProperty = zn(mn);
        var Cn = kn, En = Cn.light, Pn = Cn.paintProperty, Mn = Cn.layoutProperty;
        function Bn(t4, e2) {
          var r2 = false;
          if (e2 && e2.length)
            for (var n2 = 0, i3 = e2; n2 < i3.length; n2 += 1)
              t4.fire(new zt(new Error(i3[n2].message))), r2 = true;
          return r2;
        }
        var Tn = Vn;
        function Vn(t4, e2, r2) {
          var n2 = this.cells = [];
          if (t4 instanceof ArrayBuffer) {
            this.arrayBuffer = t4;
            var i3 = new Int32Array(this.arrayBuffer);
            t4 = i3[0], this.d = (e2 = i3[1]) + 2 * (r2 = i3[2]);
            for (var a2 = 0; a2 < this.d * this.d; a2++) {
              var o2 = i3[3 + a2], s2 = i3[3 + a2 + 1];
              n2.push(o2 === s2 ? null : i3.subarray(o2, s2));
            }
            var u2 = i3[3 + n2.length + 1];
            this.keys = i3.subarray(i3[3 + n2.length], u2), this.bboxes = i3.subarray(u2), this.insert = this._insertReadonly;
          } else {
            this.d = e2 + 2 * r2;
            for (var l2 = 0; l2 < this.d * this.d; l2++)
              n2.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = e2, this.extent = t4, this.padding = r2, this.scale = e2 / t4, this.uid = 0;
          var p2 = r2 / e2 * t4;
          this.min = -p2, this.max = t4 + p2;
        }
        Vn.prototype.insert = function(t4, e2, r2, n2, i3) {
          this._forEachCell(e2, r2, n2, i3, this._insertCell, this.uid++), this.keys.push(t4), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i3);
        }, Vn.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, Vn.prototype._insertCell = function(t4, e2, r2, n2, i3, a2) {
          this.cells[i3].push(a2);
        }, Vn.prototype.query = function(t4, e2, r2, n2, i3) {
          var a2 = this.min, o2 = this.max;
          if (t4 <= a2 && e2 <= a2 && o2 <= r2 && o2 <= n2 && !i3)
            return Array.prototype.slice.call(this.keys);
          var s2 = [];
          return this._forEachCell(t4, e2, r2, n2, this._queryCell, s2, {}, i3), s2;
        }, Vn.prototype._queryCell = function(t4, e2, r2, n2, i3, a2, o2, s2) {
          var u2 = this.cells[i3];
          if (null !== u2)
            for (var l2 = this.keys, p2 = this.bboxes, c2 = 0; c2 < u2.length; c2++) {
              var h2 = u2[c2];
              if (void 0 === o2[h2]) {
                var f2 = 4 * h2;
                (s2 ? s2(p2[f2 + 0], p2[f2 + 1], p2[f2 + 2], p2[f2 + 3]) : t4 <= p2[f2 + 2] && e2 <= p2[f2 + 3] && r2 >= p2[f2 + 0] && n2 >= p2[f2 + 1]) ? (o2[h2] = true, a2.push(l2[h2])) : o2[h2] = false;
              }
            }
        }, Vn.prototype._forEachCell = function(t4, e2, r2, n2, i3, a2, o2, s2) {
          for (var u2 = this._convertToCellCoord(t4), l2 = this._convertToCellCoord(e2), p2 = this._convertToCellCoord(r2), c2 = this._convertToCellCoord(n2), h2 = u2; h2 <= p2; h2++)
            for (var f2 = l2; f2 <= c2; f2++) {
              var y2 = this.d * f2 + h2;
              if ((!s2 || s2(this._convertFromCellCoord(h2), this._convertFromCellCoord(f2), this._convertFromCellCoord(h2 + 1), this._convertFromCellCoord(f2 + 1))) && i3.call(this, t4, e2, r2, n2, y2, a2, o2, s2))
                return;
            }
        }, Vn.prototype._convertFromCellCoord = function(t4) {
          return (t4 - this.padding) / this.scale;
        }, Vn.prototype._convertToCellCoord = function(t4) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t4 * this.scale) + this.padding));
        }, Vn.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          for (var t4 = this.cells, e2 = 3 + this.cells.length + 1 + 1, r2 = 0, n2 = 0; n2 < this.cells.length; n2++)
            r2 += this.cells[n2].length;
          var i3 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
          i3[0] = this.extent, i3[1] = this.n, i3[2] = this.padding;
          for (var a2 = e2, o2 = 0; o2 < t4.length; o2++) {
            var s2 = t4[o2];
            i3[3 + o2] = a2, i3.set(s2, a2), a2 += s2.length;
          }
          return i3[3 + t4.length] = a2, i3.set(this.keys, a2), i3[3 + t4.length + 1] = a2 += this.keys.length, i3.set(this.bboxes, a2), a2 += this.bboxes.length, i3.buffer;
        };
        var Fn = o.ImageData, Dn = o.ImageBitmap, Ln = {};
        function On(t4, e2, r2) {
          void 0 === r2 && (r2 = {}), Object.defineProperty(e2, "_classRegistryKey", { value: t4, writeable: false }), Ln[t4] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
        }
        for (var Rn in On("Object", Object), Tn.serialize = function(t4, e2) {
          var r2 = t4.toArrayBuffer();
          return e2 && e2.push(r2), { buffer: r2 };
        }, Tn.deserialize = function(t4) {
          return new Tn(t4.buffer);
        }, On("Grid", Tn), On("Color", te), On("Error", Error), On("ResolvedImage", ie), On("StylePropertyFunction", Yr), On("StyleExpression", Kr, { omit: ["_evaluator"] }), On("ZoomDependentExpression", Jr), On("ZoomConstantExpression", Xr), On("CompoundExpression", xe, { omit: ["_evaluate"] }), Ir)
          Ir[Rn]._classRegistryKey || On("Expression_" + Rn, Ir[Rn]);
        function Un(t4) {
          return t4 && "undefined" != typeof ArrayBuffer && (t4 instanceof ArrayBuffer || t4.constructor && "ArrayBuffer" === t4.constructor.name);
        }
        function jn(t4) {
          return Dn && t4 instanceof Dn;
        }
        function qn(t4, e2) {
          if (null == t4 || "boolean" == typeof t4 || "number" == typeof t4 || "string" == typeof t4 || t4 instanceof Boolean || t4 instanceof Number || t4 instanceof String || t4 instanceof Date || t4 instanceof RegExp)
            return t4;
          if (Un(t4) || jn(t4))
            return e2 && e2.push(t4), t4;
          if (ArrayBuffer.isView(t4)) {
            var r2 = t4;
            return e2 && e2.push(r2.buffer), r2;
          }
          if (t4 instanceof Fn)
            return e2 && e2.push(t4.data.buffer), t4;
          if (Array.isArray(t4)) {
            for (var n2 = [], i3 = 0, a2 = t4; i3 < a2.length; i3 += 1)
              n2.push(qn(a2[i3], e2));
            return n2;
          }
          if ("object" == typeof t4) {
            var o2 = t4.constructor, s2 = o2._classRegistryKey;
            if (!s2)
              throw new Error("can't serialize object of unregistered class");
            var u2 = o2.serialize ? o2.serialize(t4, e2) : {};
            if (!o2.serialize) {
              for (var l2 in t4)
                if (t4.hasOwnProperty(l2) && !(Ln[s2].omit.indexOf(l2) >= 0)) {
                  var p2 = t4[l2];
                  u2[l2] = Ln[s2].shallow.indexOf(l2) >= 0 ? p2 : qn(p2, e2);
                }
              t4 instanceof Error && (u2.message = t4.message);
            }
            if (u2.$name)
              throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== s2 && (u2.$name = s2), u2;
          }
          throw new Error("can't serialize object of type " + typeof t4);
        }
        function Nn(t4) {
          if (null == t4 || "boolean" == typeof t4 || "number" == typeof t4 || "string" == typeof t4 || t4 instanceof Boolean || t4 instanceof Number || t4 instanceof String || t4 instanceof Date || t4 instanceof RegExp || Un(t4) || jn(t4) || ArrayBuffer.isView(t4) || t4 instanceof Fn)
            return t4;
          if (Array.isArray(t4))
            return t4.map(Nn);
          if ("object" == typeof t4) {
            var e2 = t4.$name || "Object", r2 = Ln[e2].klass;
            if (!r2)
              throw new Error("can't deserialize unregistered class " + e2);
            if (r2.deserialize)
              return r2.deserialize(t4);
            for (var n2 = Object.create(r2.prototype), i3 = 0, a2 = Object.keys(t4); i3 < a2.length; i3 += 1) {
              var o2 = a2[i3];
              if ("$name" !== o2) {
                var s2 = t4[o2];
                n2[o2] = Ln[e2].shallow.indexOf(o2) >= 0 ? s2 : Nn(s2);
              }
            }
            return n2;
          }
          throw new Error("can't deserialize object of type " + typeof t4);
        }
        var Kn = function() {
          this.first = true;
        };
        Kn.prototype.update = function(t4, e2) {
          var r2 = Math.floor(t4);
          return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t4, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t4 !== this.lastZoom && (this.lastZoom = t4, this.lastFloorZoom = r2, true));
        };
        var Gn = { "Latin-1 Supplement": function(t4) {
          return t4 >= 128 && t4 <= 255;
        }, Arabic: function(t4) {
          return t4 >= 1536 && t4 <= 1791;
        }, "Arabic Supplement": function(t4) {
          return t4 >= 1872 && t4 <= 1919;
        }, "Arabic Extended-A": function(t4) {
          return t4 >= 2208 && t4 <= 2303;
        }, "Hangul Jamo": function(t4) {
          return t4 >= 4352 && t4 <= 4607;
        }, "Unified Canadian Aboriginal Syllabics": function(t4) {
          return t4 >= 5120 && t4 <= 5759;
        }, Khmer: function(t4) {
          return t4 >= 6016 && t4 <= 6143;
        }, "Unified Canadian Aboriginal Syllabics Extended": function(t4) {
          return t4 >= 6320 && t4 <= 6399;
        }, "General Punctuation": function(t4) {
          return t4 >= 8192 && t4 <= 8303;
        }, "Letterlike Symbols": function(t4) {
          return t4 >= 8448 && t4 <= 8527;
        }, "Number Forms": function(t4) {
          return t4 >= 8528 && t4 <= 8591;
        }, "Miscellaneous Technical": function(t4) {
          return t4 >= 8960 && t4 <= 9215;
        }, "Control Pictures": function(t4) {
          return t4 >= 9216 && t4 <= 9279;
        }, "Optical Character Recognition": function(t4) {
          return t4 >= 9280 && t4 <= 9311;
        }, "Enclosed Alphanumerics": function(t4) {
          return t4 >= 9312 && t4 <= 9471;
        }, "Geometric Shapes": function(t4) {
          return t4 >= 9632 && t4 <= 9727;
        }, "Miscellaneous Symbols": function(t4) {
          return t4 >= 9728 && t4 <= 9983;
        }, "Miscellaneous Symbols and Arrows": function(t4) {
          return t4 >= 11008 && t4 <= 11263;
        }, "CJK Radicals Supplement": function(t4) {
          return t4 >= 11904 && t4 <= 12031;
        }, "Kangxi Radicals": function(t4) {
          return t4 >= 12032 && t4 <= 12255;
        }, "Ideographic Description Characters": function(t4) {
          return t4 >= 12272 && t4 <= 12287;
        }, "CJK Symbols and Punctuation": function(t4) {
          return t4 >= 12288 && t4 <= 12351;
        }, Hiragana: function(t4) {
          return t4 >= 12352 && t4 <= 12447;
        }, Katakana: function(t4) {
          return t4 >= 12448 && t4 <= 12543;
        }, Bopomofo: function(t4) {
          return t4 >= 12544 && t4 <= 12591;
        }, "Hangul Compatibility Jamo": function(t4) {
          return t4 >= 12592 && t4 <= 12687;
        }, Kanbun: function(t4) {
          return t4 >= 12688 && t4 <= 12703;
        }, "Bopomofo Extended": function(t4) {
          return t4 >= 12704 && t4 <= 12735;
        }, "CJK Strokes": function(t4) {
          return t4 >= 12736 && t4 <= 12783;
        }, "Katakana Phonetic Extensions": function(t4) {
          return t4 >= 12784 && t4 <= 12799;
        }, "Enclosed CJK Letters and Months": function(t4) {
          return t4 >= 12800 && t4 <= 13055;
        }, "CJK Compatibility": function(t4) {
          return t4 >= 13056 && t4 <= 13311;
        }, "CJK Unified Ideographs Extension A": function(t4) {
          return t4 >= 13312 && t4 <= 19903;
        }, "Yijing Hexagram Symbols": function(t4) {
          return t4 >= 19904 && t4 <= 19967;
        }, "CJK Unified Ideographs": function(t4) {
          return t4 >= 19968 && t4 <= 40959;
        }, "Yi Syllables": function(t4) {
          return t4 >= 40960 && t4 <= 42127;
        }, "Yi Radicals": function(t4) {
          return t4 >= 42128 && t4 <= 42191;
        }, "Hangul Jamo Extended-A": function(t4) {
          return t4 >= 43360 && t4 <= 43391;
        }, "Hangul Syllables": function(t4) {
          return t4 >= 44032 && t4 <= 55215;
        }, "Hangul Jamo Extended-B": function(t4) {
          return t4 >= 55216 && t4 <= 55295;
        }, "Private Use Area": function(t4) {
          return t4 >= 57344 && t4 <= 63743;
        }, "CJK Compatibility Ideographs": function(t4) {
          return t4 >= 63744 && t4 <= 64255;
        }, "Arabic Presentation Forms-A": function(t4) {
          return t4 >= 64336 && t4 <= 65023;
        }, "Vertical Forms": function(t4) {
          return t4 >= 65040 && t4 <= 65055;
        }, "CJK Compatibility Forms": function(t4) {
          return t4 >= 65072 && t4 <= 65103;
        }, "Small Form Variants": function(t4) {
          return t4 >= 65104 && t4 <= 65135;
        }, "Arabic Presentation Forms-B": function(t4) {
          return t4 >= 65136 && t4 <= 65279;
        }, "Halfwidth and Fullwidth Forms": function(t4) {
          return t4 >= 65280 && t4 <= 65519;
        } };
        function Zn2(t4) {
          for (var e2 = 0, r2 = t4; e2 < r2.length; e2 += 1)
            if (Xn2(r2[e2].charCodeAt(0)))
              return true;
          return false;
        }
        function Xn2(t4) {
          return !(746 !== t4 && 747 !== t4 && (t4 < 4352 || !(Gn["Bopomofo Extended"](t4) || Gn.Bopomofo(t4) || Gn["CJK Compatibility Forms"](t4) && !(t4 >= 65097 && t4 <= 65103) || Gn["CJK Compatibility Ideographs"](t4) || Gn["CJK Compatibility"](t4) || Gn["CJK Radicals Supplement"](t4) || Gn["CJK Strokes"](t4) || !(!Gn["CJK Symbols and Punctuation"](t4) || t4 >= 12296 && t4 <= 12305 || t4 >= 12308 && t4 <= 12319 || 12336 === t4) || Gn["CJK Unified Ideographs Extension A"](t4) || Gn["CJK Unified Ideographs"](t4) || Gn["Enclosed CJK Letters and Months"](t4) || Gn["Hangul Compatibility Jamo"](t4) || Gn["Hangul Jamo Extended-A"](t4) || Gn["Hangul Jamo Extended-B"](t4) || Gn["Hangul Jamo"](t4) || Gn["Hangul Syllables"](t4) || Gn.Hiragana(t4) || Gn["Ideographic Description Characters"](t4) || Gn.Kanbun(t4) || Gn["Kangxi Radicals"](t4) || Gn["Katakana Phonetic Extensions"](t4) || Gn.Katakana(t4) && 12540 !== t4 || !(!Gn["Halfwidth and Fullwidth Forms"](t4) || 65288 === t4 || 65289 === t4 || 65293 === t4 || t4 >= 65306 && t4 <= 65310 || 65339 === t4 || 65341 === t4 || 65343 === t4 || t4 >= 65371 && t4 <= 65503 || 65507 === t4 || t4 >= 65512 && t4 <= 65519) || !(!Gn["Small Form Variants"](t4) || t4 >= 65112 && t4 <= 65118 || t4 >= 65123 && t4 <= 65126) || Gn["Unified Canadian Aboriginal Syllabics"](t4) || Gn["Unified Canadian Aboriginal Syllabics Extended"](t4) || Gn["Vertical Forms"](t4) || Gn["Yijing Hexagram Symbols"](t4) || Gn["Yi Syllables"](t4) || Gn["Yi Radicals"](t4))));
        }
        function Jn(t4) {
          return !(Xn2(t4) || function(t5) {
            return !!(Gn["Latin-1 Supplement"](t5) && (167 === t5 || 169 === t5 || 174 === t5 || 177 === t5 || 188 === t5 || 189 === t5 || 190 === t5 || 215 === t5 || 247 === t5) || Gn["General Punctuation"](t5) && (8214 === t5 || 8224 === t5 || 8225 === t5 || 8240 === t5 || 8241 === t5 || 8251 === t5 || 8252 === t5 || 8258 === t5 || 8263 === t5 || 8264 === t5 || 8265 === t5 || 8273 === t5) || Gn["Letterlike Symbols"](t5) || Gn["Number Forms"](t5) || Gn["Miscellaneous Technical"](t5) && (t5 >= 8960 && t5 <= 8967 || t5 >= 8972 && t5 <= 8991 || t5 >= 8996 && t5 <= 9e3 || 9003 === t5 || t5 >= 9085 && t5 <= 9114 || t5 >= 9150 && t5 <= 9165 || 9167 === t5 || t5 >= 9169 && t5 <= 9179 || t5 >= 9186 && t5 <= 9215) || Gn["Control Pictures"](t5) && 9251 !== t5 || Gn["Optical Character Recognition"](t5) || Gn["Enclosed Alphanumerics"](t5) || Gn["Geometric Shapes"](t5) || Gn["Miscellaneous Symbols"](t5) && !(t5 >= 9754 && t5 <= 9759) || Gn["Miscellaneous Symbols and Arrows"](t5) && (t5 >= 11026 && t5 <= 11055 || t5 >= 11088 && t5 <= 11097 || t5 >= 11192 && t5 <= 11243) || Gn["CJK Symbols and Punctuation"](t5) || Gn.Katakana(t5) || Gn["Private Use Area"](t5) || Gn["CJK Compatibility Forms"](t5) || Gn["Small Form Variants"](t5) || Gn["Halfwidth and Fullwidth Forms"](t5) || 8734 === t5 || 8756 === t5 || 8757 === t5 || t5 >= 9984 && t5 <= 10087 || t5 >= 10102 && t5 <= 10131 || 65532 === t5 || 65533 === t5);
          }(t4));
        }
        function Hn(t4) {
          return t4 >= 1424 && t4 <= 2303 || Gn["Arabic Presentation Forms-A"](t4) || Gn["Arabic Presentation Forms-B"](t4);
        }
        function Yn2(t4, e2) {
          return !(!e2 && Hn(t4) || t4 >= 2304 && t4 <= 3583 || t4 >= 3840 && t4 <= 4255 || Gn.Khmer(t4));
        }
        function $n(t4) {
          for (var e2 = 0, r2 = t4; e2 < r2.length; e2 += 1)
            if (Hn(r2[e2].charCodeAt(0)))
              return true;
          return false;
        }
        var Wn = null, Qn = "unavailable", ti = null, ei = function(t4) {
          t4 && "string" == typeof t4 && t4.indexOf("NetworkError") > -1 && (Qn = "error"), Wn && Wn(t4);
        };
        function ri() {
          ni.fire(new It("pluginStateChange", { pluginStatus: Qn, pluginURL: ti }));
        }
        var ni = new Ct(), ii = function() {
          return Qn;
        }, ai = function() {
          if ("deferred" !== Qn || !ti)
            throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          Qn = "loading", ri(), ti && bt({ url: ti }, function(t4) {
            t4 ? ei(t4) : (Qn = "loaded", ri());
          });
        }, oi = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: function() {
          return "loaded" === Qn || null != oi.applyArabicShaping;
        }, isLoading: function() {
          return "loading" === Qn;
        }, setState: function(t4) {
          Qn = t4.pluginStatus, ti = t4.pluginURL;
        }, isParsed: function() {
          return null != oi.applyArabicShaping && null != oi.processBidirectionalText && null != oi.processStyledBidirectionalText;
        }, getPluginURL: function() {
          return ti;
        } }, si = function(t4, e2) {
          this.zoom = t4, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Kn(), this.transition = {});
        };
        si.prototype.isSupportedScript = function(t4) {
          return function(t5, e2) {
            for (var r2 = 0, n2 = t5; r2 < n2.length; r2 += 1)
              if (!Yn2(n2[r2].charCodeAt(0), e2))
                return false;
            return true;
          }(t4, oi.isLoaded());
        }, si.prototype.crossFadingFactor = function() {
          return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }, si.prototype.getCrossfadeParameters = function() {
          var t4 = this.zoom, e2 = t4 - Math.floor(t4), r2 = this.crossFadingFactor();
          return t4 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
        };
        var ui = function(t4, e2) {
          this.property = t4, this.value = e2, this.expression = function(t5, e3) {
            if (Lr(t5))
              return new Yr(t5, e3);
            if (Gr(t5)) {
              var r2 = Hr(t5, e3);
              if ("error" === r2.result)
                throw new Error(r2.value.map(function(t6) {
                  return t6.key + ": " + t6.message;
                }).join(", "));
              return r2.value;
            }
            var n2 = t5;
            return "string" == typeof t5 && "color" === e3.type && (n2 = te.parse(t5)), { kind: "constant", evaluate: function() {
              return n2;
            } };
          }(void 0 === e2 ? t4.specification.default : e2, t4.specification);
        };
        ui.prototype.isDataDriven = function() {
          return "source" === this.expression.kind || "composite" === this.expression.kind;
        }, ui.prototype.possiblyEvaluate = function(t4, e2, r2) {
          return this.property.possiblyEvaluate(this, t4, e2, r2);
        };
        var li = function(t4) {
          this.property = t4, this.value = new ui(t4, void 0);
        };
        li.prototype.transitioned = function(t4, e2) {
          return new ci(this.property, this.value, e2, h({}, t4.transition, this.transition), t4.now);
        }, li.prototype.untransitioned = function() {
          return new ci(this.property, this.value, null, {}, 0);
        };
        var pi = function(t4) {
          this._properties = t4, this._values = Object.create(t4.defaultTransitionablePropertyValues);
        };
        pi.prototype.getValue = function(t4) {
          return w(this._values[t4].value.value);
        }, pi.prototype.setValue = function(t4, e2) {
          this._values.hasOwnProperty(t4) || (this._values[t4] = new li(this._values[t4].property)), this._values[t4].value = new ui(this._values[t4].property, null === e2 ? void 0 : w(e2));
        }, pi.prototype.getTransition = function(t4) {
          return w(this._values[t4].transition);
        }, pi.prototype.setTransition = function(t4, e2) {
          this._values.hasOwnProperty(t4) || (this._values[t4] = new li(this._values[t4].property)), this._values[t4].transition = w(e2) || void 0;
        }, pi.prototype.serialize = function() {
          for (var t4 = {}, e2 = 0, r2 = Object.keys(this._values); e2 < r2.length; e2 += 1) {
            var n2 = r2[e2], i3 = this.getValue(n2);
            void 0 !== i3 && (t4[n2] = i3);
            var a2 = this.getTransition(n2);
            void 0 !== a2 && (t4[n2 + "-transition"] = a2);
          }
          return t4;
        }, pi.prototype.transitioned = function(t4, e2) {
          for (var r2 = new hi(this._properties), n2 = 0, i3 = Object.keys(this._values); n2 < i3.length; n2 += 1) {
            var a2 = i3[n2];
            r2._values[a2] = this._values[a2].transitioned(t4, e2._values[a2]);
          }
          return r2;
        }, pi.prototype.untransitioned = function() {
          for (var t4 = new hi(this._properties), e2 = 0, r2 = Object.keys(this._values); e2 < r2.length; e2 += 1) {
            var n2 = r2[e2];
            t4._values[n2] = this._values[n2].untransitioned();
          }
          return t4;
        };
        var ci = function(t4, e2, r2, n2, i3) {
          this.property = t4, this.value = e2, this.begin = i3 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t4.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
        };
        ci.prototype.possiblyEvaluate = function(t4, e2, r2) {
          var n2 = t4.now || 0, i3 = this.value.possiblyEvaluate(t4, e2, r2), a2 = this.prior;
          if (a2) {
            if (n2 > this.end)
              return this.prior = null, i3;
            if (this.value.isDataDriven())
              return this.prior = null, i3;
            if (n2 < this.begin)
              return a2.possiblyEvaluate(t4, e2, r2);
            var o2 = (n2 - this.begin) / (this.end - this.begin);
            return this.property.interpolate(a2.possiblyEvaluate(t4, e2, r2), i3, function(t5) {
              if (t5 <= 0)
                return 0;
              if (t5 >= 1)
                return 1;
              var e3 = t5 * t5, r3 = e3 * t5;
              return 4 * (t5 < 0.5 ? r3 : 3 * (t5 - e3) + r3 - 0.75);
            }(o2));
          }
          return i3;
        };
        var hi = function(t4) {
          this._properties = t4, this._values = Object.create(t4.defaultTransitioningPropertyValues);
        };
        hi.prototype.possiblyEvaluate = function(t4, e2, r2) {
          for (var n2 = new di(this._properties), i3 = 0, a2 = Object.keys(this._values); i3 < a2.length; i3 += 1) {
            var o2 = a2[i3];
            n2._values[o2] = this._values[o2].possiblyEvaluate(t4, e2, r2);
          }
          return n2;
        }, hi.prototype.hasTransition = function() {
          for (var t4 = 0, e2 = Object.keys(this._values); t4 < e2.length; t4 += 1)
            if (this._values[e2[t4]].prior)
              return true;
          return false;
        };
        var fi = function(t4) {
          this._properties = t4, this._values = Object.create(t4.defaultPropertyValues);
        };
        fi.prototype.getValue = function(t4) {
          return w(this._values[t4].value);
        }, fi.prototype.setValue = function(t4, e2) {
          this._values[t4] = new ui(this._values[t4].property, null === e2 ? void 0 : w(e2));
        }, fi.prototype.serialize = function() {
          for (var t4 = {}, e2 = 0, r2 = Object.keys(this._values); e2 < r2.length; e2 += 1) {
            var n2 = r2[e2], i3 = this.getValue(n2);
            void 0 !== i3 && (t4[n2] = i3);
          }
          return t4;
        }, fi.prototype.possiblyEvaluate = function(t4, e2, r2) {
          for (var n2 = new di(this._properties), i3 = 0, a2 = Object.keys(this._values); i3 < a2.length; i3 += 1) {
            var o2 = a2[i3];
            n2._values[o2] = this._values[o2].possiblyEvaluate(t4, e2, r2);
          }
          return n2;
        };
        var yi = function(t4, e2, r2) {
          this.property = t4, this.value = e2, this.parameters = r2;
        };
        yi.prototype.isConstant = function() {
          return "constant" === this.value.kind;
        }, yi.prototype.constantOr = function(t4) {
          return "constant" === this.value.kind ? this.value.value : t4;
        }, yi.prototype.evaluate = function(t4, e2, r2, n2) {
          return this.property.evaluate(this.value, this.parameters, t4, e2, r2, n2);
        };
        var di = function(t4) {
          this._properties = t4, this._values = Object.create(t4.defaultPossiblyEvaluatedValues);
        };
        di.prototype.get = function(t4) {
          return this._values[t4];
        };
        var mi = function(t4) {
          this.specification = t4;
        };
        mi.prototype.possiblyEvaluate = function(t4, e2) {
          return t4.expression.evaluate(e2);
        }, mi.prototype.interpolate = function(t4, e2, r2) {
          var n2 = Ge[this.specification.type];
          return n2 ? n2(t4, e2, r2) : t4;
        };
        var vi = function(t4, e2) {
          this.specification = t4, this.overrides = e2;
        };
        vi.prototype.possiblyEvaluate = function(t4, e2, r2, n2) {
          return new yi(this, "constant" === t4.expression.kind || "camera" === t4.expression.kind ? { kind: "constant", value: t4.expression.evaluate(e2, null, {}, r2, n2) } : t4.expression, e2);
        }, vi.prototype.interpolate = function(t4, e2, r2) {
          if ("constant" !== t4.value.kind || "constant" !== e2.value.kind)
            return t4;
          if (void 0 === t4.value.value || void 0 === e2.value.value)
            return new yi(this, { kind: "constant", value: void 0 }, t4.parameters);
          var n2 = Ge[this.specification.type];
          return n2 ? new yi(this, { kind: "constant", value: n2(t4.value.value, e2.value.value, r2) }, t4.parameters) : t4;
        }, vi.prototype.evaluate = function(t4, e2, r2, n2, i3, a2) {
          return "constant" === t4.kind ? t4.value : t4.evaluate(e2, r2, n2, i3, a2);
        };
        var gi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.possiblyEvaluate = function(t5, e3, r2, n2) {
            if (void 0 === t5.value)
              return new yi(this, { kind: "constant", value: void 0 }, e3);
            if ("constant" === t5.expression.kind) {
              var i3 = t5.expression.evaluate(e3, null, {}, r2, n2), a2 = "resolvedImage" === t5.property.specification.type && "string" != typeof i3 ? i3.name : i3, o2 = this._calculate(a2, a2, a2, e3);
              return new yi(this, { kind: "constant", value: o2 }, e3);
            }
            if ("camera" === t5.expression.kind) {
              var s2 = this._calculate(t5.expression.evaluate({ zoom: e3.zoom - 1 }), t5.expression.evaluate({ zoom: e3.zoom }), t5.expression.evaluate({ zoom: e3.zoom + 1 }), e3);
              return new yi(this, { kind: "constant", value: s2 }, e3);
            }
            return new yi(this, t5.expression, e3);
          }, e2.prototype.evaluate = function(t5, e3, r2, n2, i3, a2) {
            if ("source" === t5.kind) {
              var o2 = t5.evaluate(e3, r2, n2, i3, a2);
              return this._calculate(o2, o2, o2, e3);
            }
            return "composite" === t5.kind ? this._calculate(t5.evaluate({ zoom: Math.floor(e3.zoom) - 1 }, r2, n2), t5.evaluate({ zoom: Math.floor(e3.zoom) }, r2, n2), t5.evaluate({ zoom: Math.floor(e3.zoom) + 1 }, r2, n2), e3) : t5.value;
          }, e2.prototype._calculate = function(t5, e3, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t5, to: e3 } : { from: r2, to: e3 };
          }, e2.prototype.interpolate = function(t5) {
            return t5;
          }, e2;
        }(vi), xi = function(t4) {
          this.specification = t4;
        };
        xi.prototype.possiblyEvaluate = function(t4, e2, r2, n2) {
          if (void 0 !== t4.value) {
            if ("constant" === t4.expression.kind) {
              var i3 = t4.expression.evaluate(e2, null, {}, r2, n2);
              return this._calculate(i3, i3, i3, e2);
            }
            return this._calculate(t4.expression.evaluate(new si(Math.floor(e2.zoom - 1), e2)), t4.expression.evaluate(new si(Math.floor(e2.zoom), e2)), t4.expression.evaluate(new si(Math.floor(e2.zoom + 1), e2)), e2);
          }
        }, xi.prototype._calculate = function(t4, e2, r2, n2) {
          return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t4, to: e2 } : { from: r2, to: e2 };
        }, xi.prototype.interpolate = function(t4) {
          return t4;
        };
        var bi = function(t4) {
          this.specification = t4;
        };
        bi.prototype.possiblyEvaluate = function(t4, e2, r2, n2) {
          return !!t4.expression.evaluate(e2, null, {}, r2, n2);
        }, bi.prototype.interpolate = function() {
          return false;
        };
        var wi = function(t4) {
          for (var e2 in this.properties = t4, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], t4) {
            var r2 = t4[e2];
            r2.specification.overridable && this.overridableProperties.push(e2);
            var n2 = this.defaultPropertyValues[e2] = new ui(r2, void 0), i3 = this.defaultTransitionablePropertyValues[e2] = new li(r2);
            this.defaultTransitioningPropertyValues[e2] = i3.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
          }
        };
        On("DataDrivenProperty", vi), On("DataConstantProperty", mi), On("CrossFadedDataDrivenProperty", gi), On("CrossFadedProperty", xi), On("ColorRampProperty", bi);
        var _i = function(t4) {
          function e2(e3, r2) {
            if (t4.call(this), this.id = e3.id, this.type = e3.type, this._featureFilter = { filter: function() {
              return true;
            }, needGeometry: false }, "custom" !== e3.type && (this.metadata = (e3 = e3).metadata, this.minzoom = e3.minzoom, this.maxzoom = e3.maxzoom, "background" !== e3.type && (this.source = e3.source, this.sourceLayer = e3["source-layer"], this.filter = e3.filter), r2.layout && (this._unevaluatedLayout = new fi(r2.layout)), r2.paint)) {
              for (var n2 in this._transitionablePaint = new pi(r2.paint), e3.paint)
                this.setPaintProperty(n2, e3.paint[n2], { validate: false });
              for (var i3 in e3.layout)
                this.setLayoutProperty(i3, e3.layout[i3], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new di(r2.paint);
            }
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getCrossfadeParameters = function() {
            return this._crossfadeParameters;
          }, e2.prototype.getLayoutProperty = function(t5) {
            return "visibility" === t5 ? this.visibility : this._unevaluatedLayout.getValue(t5);
          }, e2.prototype.setLayoutProperty = function(t5, e3, r2) {
            void 0 === r2 && (r2 = {}), null != e3 && this._validate(Mn, "layers." + this.id + ".layout." + t5, t5, e3, r2) || ("visibility" !== t5 ? this._unevaluatedLayout.setValue(t5, e3) : this.visibility = e3);
          }, e2.prototype.getPaintProperty = function(t5) {
            return g(t5, "-transition") ? this._transitionablePaint.getTransition(t5.slice(0, -"-transition".length)) : this._transitionablePaint.getValue(t5);
          }, e2.prototype.setPaintProperty = function(t5, e3, r2) {
            if (void 0 === r2 && (r2 = {}), null != e3 && this._validate(Pn, "layers." + this.id + ".paint." + t5, t5, e3, r2))
              return false;
            if (g(t5, "-transition"))
              return this._transitionablePaint.setTransition(t5.slice(0, -"-transition".length), e3 || void 0), false;
            var n2 = this._transitionablePaint._values[t5], i3 = "cross-faded-data-driven" === n2.property.specification["property-type"], a2 = n2.value.isDataDriven(), o2 = n2.value;
            this._transitionablePaint.setValue(t5, e3), this._handleSpecialPaintPropertyUpdate(t5);
            var s2 = this._transitionablePaint._values[t5].value;
            return s2.isDataDriven() || a2 || i3 || this._handleOverridablePaintPropertyUpdate(t5, o2, s2);
          }, e2.prototype._handleSpecialPaintPropertyUpdate = function(t5) {
          }, e2.prototype._handleOverridablePaintPropertyUpdate = function(t5, e3, r2) {
            return false;
          }, e2.prototype.isHidden = function(t5) {
            return !!(this.minzoom && t5 < this.minzoom) || !!(this.maxzoom && t5 >= this.maxzoom) || "none" === this.visibility;
          }, e2.prototype.updateTransitions = function(t5) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t5, this._transitioningPaint);
          }, e2.prototype.hasTransition = function() {
            return this._transitioningPaint.hasTransition();
          }, e2.prototype.recalculate = function(t5, e3) {
            t5.getCrossfadeParameters && (this._crossfadeParameters = t5.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t5, void 0, e3)), this.paint = this._transitioningPaint.possiblyEvaluate(t5, void 0, e3);
          }, e2.prototype.serialize = function() {
            var t5 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t5.layout = t5.layout || {}, t5.layout.visibility = this.visibility), b(t5, function(t6, e3) {
              return !(void 0 === t6 || "layout" === e3 && !Object.keys(t6).length || "paint" === e3 && !Object.keys(t6).length);
            });
          }, e2.prototype._validate = function(t5, e3, r2, n2, i3) {
            return void 0 === i3 && (i3 = {}), (!i3 || false !== i3.validate) && Bn(this, t5.call(Cn, { key: e3, layerType: this.type, objectKey: r2, value: n2, styleSpec: Et, style: { glyphs: true, sprite: true } }));
          }, e2.prototype.is3D = function() {
            return false;
          }, e2.prototype.isTileClipped = function() {
            return false;
          }, e2.prototype.hasOffscreenPass = function() {
            return false;
          }, e2.prototype.resize = function() {
          }, e2.prototype.isStateDependent = function() {
            for (var t5 in this.paint._values) {
              var e3 = this.paint.get(t5);
              if (e3 instanceof yi && Tr(e3.property.specification) && ("source" === e3.value.kind || "composite" === e3.value.kind) && e3.value.isStateDependent)
                return true;
            }
            return false;
          }, e2;
        }(Ct), Ai = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, Si = function(t4, e2) {
          this._structArray = t4, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }, ki = function() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        };
        function Ii(t4, e2) {
          void 0 === e2 && (e2 = 1);
          var r2 = 0, n2 = 0;
          return { members: t4.map(function(t5) {
            var i3 = Ai[t5.type].BYTES_PER_ELEMENT, a2 = r2 = zi(r2, Math.max(e2, i3)), o2 = t5.components || 1;
            return n2 = Math.max(n2, i3), r2 += i3 * o2, { name: t5.name, type: t5.type, components: o2, offset: a2 };
          }), size: zi(r2, Math.max(n2, e2)), alignment: e2 };
        }
        function zi(t4, e2) {
          return Math.ceil(t4 / e2) * e2;
        }
        ki.serialize = function(t4, e2) {
          return t4._trim(), e2 && (t4.isTransferred = true, e2.push(t4.arrayBuffer)), { length: t4.length, arrayBuffer: t4.arrayBuffer };
        }, ki.deserialize = function(t4) {
          var e2 = Object.create(this.prototype);
          return e2.arrayBuffer = t4.arrayBuffer, e2.length = t4.length, e2.capacity = t4.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
        }, ki.prototype._trim = function() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }, ki.prototype.clear = function() {
          this.length = 0;
        }, ki.prototype.resize = function(t4) {
          this.reserve(t4), this.length = t4;
        }, ki.prototype.reserve = function(t4) {
          if (t4 > this.capacity) {
            this.capacity = Math.max(t4, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            var e2 = this.uint8;
            this._refreshViews(), e2 && this.uint8.set(e2);
          }
        }, ki.prototype._refreshViews = function() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        };
        var Ci = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3) {
            var r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t5, e3);
          }, e2.prototype.emplace = function(t5, e3, r2) {
            var n2 = 2 * t5;
            return this.int16[n2 + 0] = e3, this.int16[n2 + 1] = r2, t5;
          }, e2;
        }(ki);
        Ci.prototype.bytesPerElement = 4, On("StructArrayLayout2i4", Ci);
        var Ei = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2, n2) {
            var i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t5, e3, r2, n2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2, i3) {
            var a2 = 4 * t5;
            return this.int16[a2 + 0] = e3, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i3, t5;
          }, e2;
        }(ki);
        Ei.prototype.bytesPerElement = 8, On("StructArrayLayout4i8", Ei);
        var Pi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2, n2, i3, a2) {
            var o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t5, e3, r2, n2, i3, a2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2, i3, a2, o2) {
            var s2 = 6 * t5;
            return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i3, this.int16[s2 + 4] = a2, this.int16[s2 + 5] = o2, t5;
          }, e2;
        }(ki);
        Pi.prototype.bytesPerElement = 12, On("StructArrayLayout2i4i12", Pi);
        var Mi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2, n2, i3, a2) {
            var o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t5, e3, r2, n2, i3, a2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2, i3, a2, o2) {
            var s2 = 4 * t5, u2 = 8 * t5;
            return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i3, this.uint8[u2 + 6] = a2, this.uint8[u2 + 7] = o2, t5;
          }, e2;
        }(ki);
        Mi.prototype.bytesPerElement = 8, On("StructArrayLayout2i4ub8", Mi);
        var Bi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3) {
            var r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t5, e3);
          }, e2.prototype.emplace = function(t5, e3, r2) {
            var n2 = 2 * t5;
            return this.float32[n2 + 0] = e3, this.float32[n2 + 1] = r2, t5;
          }, e2;
        }(ki);
        Bi.prototype.bytesPerElement = 8, On("StructArrayLayout2f8", Bi);
        var Ti = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2, n2, i3, a2, o2, s2, u2, l2) {
            var p2 = this.length;
            return this.resize(p2 + 1), this.emplace(p2, t5, e3, r2, n2, i3, a2, o2, s2, u2, l2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2, i3, a2, o2, s2, u2, l2, p2) {
            var c2 = 10 * t5;
            return this.uint16[c2 + 0] = e3, this.uint16[c2 + 1] = r2, this.uint16[c2 + 2] = n2, this.uint16[c2 + 3] = i3, this.uint16[c2 + 4] = a2, this.uint16[c2 + 5] = o2, this.uint16[c2 + 6] = s2, this.uint16[c2 + 7] = u2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = p2, t5;
          }, e2;
        }(ki);
        Ti.prototype.bytesPerElement = 20, On("StructArrayLayout10ui20", Ti);
        var Vi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2, n2, i3, a2, o2, s2, u2, l2, p2, c2) {
            var h2 = this.length;
            return this.resize(h2 + 1), this.emplace(h2, t5, e3, r2, n2, i3, a2, o2, s2, u2, l2, p2, c2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2, i3, a2, o2, s2, u2, l2, p2, c2, h2) {
            var f2 = 12 * t5;
            return this.int16[f2 + 0] = e3, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i3, this.uint16[f2 + 4] = a2, this.uint16[f2 + 5] = o2, this.uint16[f2 + 6] = s2, this.uint16[f2 + 7] = u2, this.int16[f2 + 8] = l2, this.int16[f2 + 9] = p2, this.int16[f2 + 10] = c2, this.int16[f2 + 11] = h2, t5;
          }, e2;
        }(ki);
        Vi.prototype.bytesPerElement = 24, On("StructArrayLayout4i4ui4i24", Vi);
        var Fi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2) {
            var n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t5, e3, r2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2) {
            var i3 = 3 * t5;
            return this.float32[i3 + 0] = e3, this.float32[i3 + 1] = r2, this.float32[i3 + 2] = n2, t5;
          }, e2;
        }(ki);
        Fi.prototype.bytesPerElement = 12, On("StructArrayLayout3f12", Fi);
        var Di = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5) {
            var e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t5);
          }, e2.prototype.emplace = function(t5, e3) {
            return this.uint32[1 * t5 + 0] = e3, t5;
          }, e2;
        }(ki);
        Di.prototype.bytesPerElement = 4, On("StructArrayLayout1ul4", Di);
        var Li = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2, n2, i3, a2, o2, s2, u2) {
            var l2 = this.length;
            return this.resize(l2 + 1), this.emplace(l2, t5, e3, r2, n2, i3, a2, o2, s2, u2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2, i3, a2, o2, s2, u2, l2) {
            var p2 = 10 * t5, c2 = 5 * t5;
            return this.int16[p2 + 0] = e3, this.int16[p2 + 1] = r2, this.int16[p2 + 2] = n2, this.int16[p2 + 3] = i3, this.int16[p2 + 4] = a2, this.int16[p2 + 5] = o2, this.uint32[c2 + 3] = s2, this.uint16[p2 + 8] = u2, this.uint16[p2 + 9] = l2, t5;
          }, e2;
        }(ki);
        Li.prototype.bytesPerElement = 20, On("StructArrayLayout6i1ul2ui20", Li);
        var Oi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2, n2, i3, a2) {
            var o2 = this.length;
            return this.resize(o2 + 1), this.emplace(o2, t5, e3, r2, n2, i3, a2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2, i3, a2, o2) {
            var s2 = 6 * t5;
            return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i3, this.int16[s2 + 4] = a2, this.int16[s2 + 5] = o2, t5;
          }, e2;
        }(ki);
        Oi.prototype.bytesPerElement = 12, On("StructArrayLayout2i2i2i12", Oi);
        var Ri = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2, n2, i3) {
            var a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t5, e3, r2, n2, i3);
          }, e2.prototype.emplace = function(t5, e3, r2, n2, i3, a2) {
            var o2 = 4 * t5, s2 = 8 * t5;
            return this.float32[o2 + 0] = e3, this.float32[o2 + 1] = r2, this.float32[o2 + 2] = n2, this.int16[s2 + 6] = i3, this.int16[s2 + 7] = a2, t5;
          }, e2;
        }(ki);
        Ri.prototype.bytesPerElement = 16, On("StructArrayLayout2f1f2i16", Ri);
        var Ui = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2, n2) {
            var i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t5, e3, r2, n2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2, i3) {
            var a2 = 12 * t5, o2 = 3 * t5;
            return this.uint8[a2 + 0] = e3, this.uint8[a2 + 1] = r2, this.float32[o2 + 1] = n2, this.float32[o2 + 2] = i3, t5;
          }, e2;
        }(ki);
        Ui.prototype.bytesPerElement = 12, On("StructArrayLayout2ub2f12", Ui);
        var ji = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2) {
            var n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t5, e3, r2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2) {
            var i3 = 3 * t5;
            return this.uint16[i3 + 0] = e3, this.uint16[i3 + 1] = r2, this.uint16[i3 + 2] = n2, t5;
          }, e2;
        }(ki);
        ji.prototype.bytesPerElement = 6, On("StructArrayLayout3ui6", ji);
        var qi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2, n2, i3, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2) {
            var v2 = this.length;
            return this.resize(v2 + 1), this.emplace(v2, t5, e3, r2, n2, i3, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2, i3, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2, v2) {
            var g2 = 24 * t5, x3 = 12 * t5, b2 = 48 * t5;
            return this.int16[g2 + 0] = e3, this.int16[g2 + 1] = r2, this.uint16[g2 + 2] = n2, this.uint16[g2 + 3] = i3, this.uint32[x3 + 2] = a2, this.uint32[x3 + 3] = o2, this.uint32[x3 + 4] = s2, this.uint16[g2 + 10] = u2, this.uint16[g2 + 11] = l2, this.uint16[g2 + 12] = p2, this.float32[x3 + 7] = c2, this.float32[x3 + 8] = h2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = y2, this.uint8[b2 + 38] = d2, this.uint32[x3 + 10] = m2, this.int16[g2 + 22] = v2, t5;
          }, e2;
        }(ki);
        qi.prototype.bytesPerElement = 48, On("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", qi);
        var Ni = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2, n2, i3, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2, v2, g2, x3, b2, w2, _2, A3, S2, k2, I2, z2) {
            var C3 = this.length;
            return this.resize(C3 + 1), this.emplace(C3, t5, e3, r2, n2, i3, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2, v2, g2, x3, b2, w2, _2, A3, S2, k2, I2, z2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2, i3, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2, v2, g2, x3, b2, w2, _2, A3, S2, k2, I2, z2, C3) {
            var E3 = 34 * t5, P2 = 17 * t5;
            return this.int16[E3 + 0] = e3, this.int16[E3 + 1] = r2, this.int16[E3 + 2] = n2, this.int16[E3 + 3] = i3, this.int16[E3 + 4] = a2, this.int16[E3 + 5] = o2, this.int16[E3 + 6] = s2, this.int16[E3 + 7] = u2, this.uint16[E3 + 8] = l2, this.uint16[E3 + 9] = p2, this.uint16[E3 + 10] = c2, this.uint16[E3 + 11] = h2, this.uint16[E3 + 12] = f2, this.uint16[E3 + 13] = y2, this.uint16[E3 + 14] = d2, this.uint16[E3 + 15] = m2, this.uint16[E3 + 16] = v2, this.uint16[E3 + 17] = g2, this.uint16[E3 + 18] = x3, this.uint16[E3 + 19] = b2, this.uint16[E3 + 20] = w2, this.uint16[E3 + 21] = _2, this.uint16[E3 + 22] = A3, this.uint32[P2 + 12] = S2, this.float32[P2 + 13] = k2, this.float32[P2 + 14] = I2, this.float32[P2 + 15] = z2, this.float32[P2 + 16] = C3, t5;
          }, e2;
        }(ki);
        Ni.prototype.bytesPerElement = 68, On("StructArrayLayout8i15ui1ul4f68", Ni);
        var Ki = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5) {
            var e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t5);
          }, e2.prototype.emplace = function(t5, e3) {
            return this.float32[1 * t5 + 0] = e3, t5;
          }, e2;
        }(ki);
        Ki.prototype.bytesPerElement = 4, On("StructArrayLayout1f4", Ki);
        var Gi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2) {
            var n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t5, e3, r2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2) {
            var i3 = 3 * t5;
            return this.int16[i3 + 0] = e3, this.int16[i3 + 1] = r2, this.int16[i3 + 2] = n2, t5;
          }, e2;
        }(ki);
        Gi.prototype.bytesPerElement = 6, On("StructArrayLayout3i6", Gi);
        var Zi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2) {
            var n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t5, e3, r2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2) {
            var i3 = 4 * t5;
            return this.uint32[2 * t5 + 0] = e3, this.uint16[i3 + 2] = r2, this.uint16[i3 + 3] = n2, t5;
          }, e2;
        }(ki);
        Zi.prototype.bytesPerElement = 8, On("StructArrayLayout1ul2ui8", Zi);
        var Xi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3) {
            var r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t5, e3);
          }, e2.prototype.emplace = function(t5, e3, r2) {
            var n2 = 2 * t5;
            return this.uint16[n2 + 0] = e3, this.uint16[n2 + 1] = r2, t5;
          }, e2;
        }(ki);
        Xi.prototype.bytesPerElement = 4, On("StructArrayLayout2ui4", Xi);
        var Ji = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5) {
            var e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t5);
          }, e2.prototype.emplace = function(t5, e3) {
            return this.uint16[1 * t5 + 0] = e3, t5;
          }, e2;
        }(ki);
        Ji.prototype.bytesPerElement = 2, On("StructArrayLayout1ui2", Ji);
        var Hi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }, e2.prototype.emplaceBack = function(t5, e3, r2, n2) {
            var i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t5, e3, r2, n2);
          }, e2.prototype.emplace = function(t5, e3, r2, n2, i3) {
            var a2 = 4 * t5;
            return this.float32[a2 + 0] = e3, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i3, t5;
          }, e2;
        }(ki);
        Hi.prototype.bytesPerElement = 16, On("StructArrayLayout4f16", Hi);
        var Yi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2;
          var r2 = { anchorPointX: { configurable: true }, anchorPointY: { configurable: true }, x1: { configurable: true }, y1: { configurable: true }, x2: { configurable: true }, y2: { configurable: true }, featureIndex: { configurable: true }, sourceLayerIndex: { configurable: true }, bucketIndex: { configurable: true }, anchorPoint: { configurable: true } };
          return r2.anchorPointX.get = function() {
            return this._structArray.int16[this._pos2 + 0];
          }, r2.anchorPointY.get = function() {
            return this._structArray.int16[this._pos2 + 1];
          }, r2.x1.get = function() {
            return this._structArray.int16[this._pos2 + 2];
          }, r2.y1.get = function() {
            return this._structArray.int16[this._pos2 + 3];
          }, r2.x2.get = function() {
            return this._structArray.int16[this._pos2 + 4];
          }, r2.y2.get = function() {
            return this._structArray.int16[this._pos2 + 5];
          }, r2.featureIndex.get = function() {
            return this._structArray.uint32[this._pos4 + 3];
          }, r2.sourceLayerIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 8];
          }, r2.bucketIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 9];
          }, r2.anchorPoint.get = function() {
            return new i2(this.anchorPointX, this.anchorPointY);
          }, Object.defineProperties(e2.prototype, r2), e2;
        }(Si);
        Yi.prototype.size = 20;
        var $i = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.get = function(t5) {
            return new Yi(this, t5);
          }, e2;
        }(Li);
        On("CollisionBoxArray", $i);
        var Wi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2;
          var r2 = { anchorX: { configurable: true }, anchorY: { configurable: true }, glyphStartIndex: { configurable: true }, numGlyphs: { configurable: true }, vertexStartIndex: { configurable: true }, lineStartIndex: { configurable: true }, lineLength: { configurable: true }, segment: { configurable: true }, lowerSize: { configurable: true }, upperSize: { configurable: true }, lineOffsetX: { configurable: true }, lineOffsetY: { configurable: true }, writingMode: { configurable: true }, placedOrientation: { configurable: true }, hidden: { configurable: true }, crossTileID: { configurable: true }, associatedIconIndex: { configurable: true } };
          return r2.anchorX.get = function() {
            return this._structArray.int16[this._pos2 + 0];
          }, r2.anchorY.get = function() {
            return this._structArray.int16[this._pos2 + 1];
          }, r2.glyphStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 2];
          }, r2.numGlyphs.get = function() {
            return this._structArray.uint16[this._pos2 + 3];
          }, r2.vertexStartIndex.get = function() {
            return this._structArray.uint32[this._pos4 + 2];
          }, r2.lineStartIndex.get = function() {
            return this._structArray.uint32[this._pos4 + 3];
          }, r2.lineLength.get = function() {
            return this._structArray.uint32[this._pos4 + 4];
          }, r2.segment.get = function() {
            return this._structArray.uint16[this._pos2 + 10];
          }, r2.lowerSize.get = function() {
            return this._structArray.uint16[this._pos2 + 11];
          }, r2.upperSize.get = function() {
            return this._structArray.uint16[this._pos2 + 12];
          }, r2.lineOffsetX.get = function() {
            return this._structArray.float32[this._pos4 + 7];
          }, r2.lineOffsetY.get = function() {
            return this._structArray.float32[this._pos4 + 8];
          }, r2.writingMode.get = function() {
            return this._structArray.uint8[this._pos1 + 36];
          }, r2.placedOrientation.get = function() {
            return this._structArray.uint8[this._pos1 + 37];
          }, r2.placedOrientation.set = function(t5) {
            this._structArray.uint8[this._pos1 + 37] = t5;
          }, r2.hidden.get = function() {
            return this._structArray.uint8[this._pos1 + 38];
          }, r2.hidden.set = function(t5) {
            this._structArray.uint8[this._pos1 + 38] = t5;
          }, r2.crossTileID.get = function() {
            return this._structArray.uint32[this._pos4 + 10];
          }, r2.crossTileID.set = function(t5) {
            this._structArray.uint32[this._pos4 + 10] = t5;
          }, r2.associatedIconIndex.get = function() {
            return this._structArray.int16[this._pos2 + 22];
          }, Object.defineProperties(e2.prototype, r2), e2;
        }(Si);
        Wi.prototype.size = 48;
        var Qi = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.get = function(t5) {
            return new Wi(this, t5);
          }, e2;
        }(qi);
        On("PlacedSymbolArray", Qi);
        var ta = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2;
          var r2 = { anchorX: { configurable: true }, anchorY: { configurable: true }, rightJustifiedTextSymbolIndex: { configurable: true }, centerJustifiedTextSymbolIndex: { configurable: true }, leftJustifiedTextSymbolIndex: { configurable: true }, verticalPlacedTextSymbolIndex: { configurable: true }, placedIconSymbolIndex: { configurable: true }, verticalPlacedIconSymbolIndex: { configurable: true }, key: { configurable: true }, textBoxStartIndex: { configurable: true }, textBoxEndIndex: { configurable: true }, verticalTextBoxStartIndex: { configurable: true }, verticalTextBoxEndIndex: { configurable: true }, iconBoxStartIndex: { configurable: true }, iconBoxEndIndex: { configurable: true }, verticalIconBoxStartIndex: { configurable: true }, verticalIconBoxEndIndex: { configurable: true }, featureIndex: { configurable: true }, numHorizontalGlyphVertices: { configurable: true }, numVerticalGlyphVertices: { configurable: true }, numIconVertices: { configurable: true }, numVerticalIconVertices: { configurable: true }, useRuntimeCollisionCircles: { configurable: true }, crossTileID: { configurable: true }, textBoxScale: { configurable: true }, textOffset0: { configurable: true }, textOffset1: { configurable: true }, collisionCircleDiameter: { configurable: true } };
          return r2.anchorX.get = function() {
            return this._structArray.int16[this._pos2 + 0];
          }, r2.anchorY.get = function() {
            return this._structArray.int16[this._pos2 + 1];
          }, r2.rightJustifiedTextSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 2];
          }, r2.centerJustifiedTextSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 3];
          }, r2.leftJustifiedTextSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 4];
          }, r2.verticalPlacedTextSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 5];
          }, r2.placedIconSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 6];
          }, r2.verticalPlacedIconSymbolIndex.get = function() {
            return this._structArray.int16[this._pos2 + 7];
          }, r2.key.get = function() {
            return this._structArray.uint16[this._pos2 + 8];
          }, r2.textBoxStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 9];
          }, r2.textBoxEndIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 10];
          }, r2.verticalTextBoxStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 11];
          }, r2.verticalTextBoxEndIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 12];
          }, r2.iconBoxStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 13];
          }, r2.iconBoxEndIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 14];
          }, r2.verticalIconBoxStartIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 15];
          }, r2.verticalIconBoxEndIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 16];
          }, r2.featureIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 17];
          }, r2.numHorizontalGlyphVertices.get = function() {
            return this._structArray.uint16[this._pos2 + 18];
          }, r2.numVerticalGlyphVertices.get = function() {
            return this._structArray.uint16[this._pos2 + 19];
          }, r2.numIconVertices.get = function() {
            return this._structArray.uint16[this._pos2 + 20];
          }, r2.numVerticalIconVertices.get = function() {
            return this._structArray.uint16[this._pos2 + 21];
          }, r2.useRuntimeCollisionCircles.get = function() {
            return this._structArray.uint16[this._pos2 + 22];
          }, r2.crossTileID.get = function() {
            return this._structArray.uint32[this._pos4 + 12];
          }, r2.crossTileID.set = function(t5) {
            this._structArray.uint32[this._pos4 + 12] = t5;
          }, r2.textBoxScale.get = function() {
            return this._structArray.float32[this._pos4 + 13];
          }, r2.textOffset0.get = function() {
            return this._structArray.float32[this._pos4 + 14];
          }, r2.textOffset1.get = function() {
            return this._structArray.float32[this._pos4 + 15];
          }, r2.collisionCircleDiameter.get = function() {
            return this._structArray.float32[this._pos4 + 16];
          }, Object.defineProperties(e2.prototype, r2), e2;
        }(Si);
        ta.prototype.size = 68;
        var ea = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.get = function(t5) {
            return new ta(this, t5);
          }, e2;
        }(Ni);
        On("SymbolInstanceArray", ea);
        var ra = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getoffsetX = function(t5) {
            return this.float32[1 * t5 + 0];
          }, e2;
        }(Ki);
        On("GlyphOffsetArray", ra);
        var na = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getx = function(t5) {
            return this.int16[3 * t5 + 0];
          }, e2.prototype.gety = function(t5) {
            return this.int16[3 * t5 + 1];
          }, e2.prototype.gettileUnitDistanceFromAnchor = function(t5) {
            return this.int16[3 * t5 + 2];
          }, e2;
        }(Gi);
        On("SymbolLineVertexArray", na);
        var ia = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2;
          var r2 = { featureIndex: { configurable: true }, sourceLayerIndex: { configurable: true }, bucketIndex: { configurable: true } };
          return r2.featureIndex.get = function() {
            return this._structArray.uint32[this._pos4 + 0];
          }, r2.sourceLayerIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 2];
          }, r2.bucketIndex.get = function() {
            return this._structArray.uint16[this._pos2 + 3];
          }, Object.defineProperties(e2.prototype, r2), e2;
        }(Si);
        ia.prototype.size = 8;
        var aa = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.get = function(t5) {
            return new ia(this, t5);
          }, e2;
        }(Zi);
        On("FeatureIndexArray", aa);
        var oa = Ii([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, sa = function(t4) {
          void 0 === t4 && (t4 = []), this.segments = t4;
        };
        function ua(t4, e2) {
          return 256 * (t4 = p(Math.floor(t4), 0, 255)) + p(Math.floor(e2), 0, 255);
        }
        sa.prototype.prepareSegment = function(t4, e2, r2, n2) {
          var i3 = this.segments[this.segments.length - 1];
          return t4 > sa.MAX_VERTEX_ARRAY_LENGTH && A2("Max vertices per segment is " + sa.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + t4), (!i3 || i3.vertexLength + t4 > sa.MAX_VERTEX_ARRAY_LENGTH || i3.sortKey !== n2) && (i3 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i3.sortKey = n2), this.segments.push(i3)), i3;
        }, sa.prototype.get = function() {
          return this.segments;
        }, sa.prototype.destroy = function() {
          for (var t4 = 0, e2 = this.segments; t4 < e2.length; t4 += 1) {
            var r2 = e2[t4];
            for (var n2 in r2.vaos)
              r2.vaos[n2].destroy();
          }
        }, sa.simpleSegment = function(t4, e2, r2, n2) {
          return new sa([{ vertexOffset: t4, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
        }, sa.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, On("SegmentVector", sa);
        var la = Ii([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), pa = e(function(t4) {
          t4.exports = function(t5, e2) {
            var r2, n2, i3, a2, o2, s2, u2, l2;
            for (n2 = t5.length - (r2 = 3 & t5.length), i3 = e2, o2 = 3432918353, s2 = 461845907, l2 = 0; l2 < n2; )
              u2 = 255 & t5.charCodeAt(l2) | (255 & t5.charCodeAt(++l2)) << 8 | (255 & t5.charCodeAt(++l2)) << 16 | (255 & t5.charCodeAt(++l2)) << 24, ++l2, i3 = 27492 + (65535 & (a2 = 5 * (65535 & (i3 = (i3 ^= u2 = (65535 & (u2 = (u2 = (65535 & u2) * o2 + (((u2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | u2 >>> 17)) * s2 + (((u2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 13 | i3 >>> 19)) + ((5 * (i3 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a2 >>> 16) & 65535) << 16);
            switch (u2 = 0, r2) {
              case 3:
                u2 ^= (255 & t5.charCodeAt(l2 + 2)) << 16;
              case 2:
                u2 ^= (255 & t5.charCodeAt(l2 + 1)) << 8;
              case 1:
                i3 ^= u2 = (65535 & (u2 = (u2 = (65535 & (u2 ^= 255 & t5.charCodeAt(l2))) * o2 + (((u2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | u2 >>> 17)) * s2 + (((u2 >>> 16) * s2 & 65535) << 16) & 4294967295;
            }
            return i3 ^= t5.length, i3 = 2246822507 * (65535 & (i3 ^= i3 >>> 16)) + ((2246822507 * (i3 >>> 16) & 65535) << 16) & 4294967295, i3 = 3266489909 * (65535 & (i3 ^= i3 >>> 13)) + ((3266489909 * (i3 >>> 16) & 65535) << 16) & 4294967295, (i3 ^= i3 >>> 16) >>> 0;
          };
        }), ca = e(function(t4) {
          t4.exports = function(t5, e2) {
            for (var r2, n2 = t5.length, i3 = e2 ^ n2, a2 = 0; n2 >= 4; )
              r2 = 1540483477 * (65535 & (r2 = 255 & t5.charCodeAt(a2) | (255 & t5.charCodeAt(++a2)) << 8 | (255 & t5.charCodeAt(++a2)) << 16 | (255 & t5.charCodeAt(++a2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i3 = 1540483477 * (65535 & i3) + ((1540483477 * (i3 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++a2;
            switch (n2) {
              case 3:
                i3 ^= (255 & t5.charCodeAt(a2 + 2)) << 16;
              case 2:
                i3 ^= (255 & t5.charCodeAt(a2 + 1)) << 8;
              case 1:
                i3 = 1540483477 * (65535 & (i3 ^= 255 & t5.charCodeAt(a2))) + ((1540483477 * (i3 >>> 16) & 65535) << 16);
            }
            return i3 = 1540483477 * (65535 & (i3 ^= i3 >>> 13)) + ((1540483477 * (i3 >>> 16) & 65535) << 16), (i3 ^= i3 >>> 15) >>> 0;
          };
        }), ha = pa, fa = ca;
        ha.murmur3 = pa, ha.murmur2 = fa;
        var ya = function() {
          this.ids = [], this.positions = [], this.indexed = false;
        };
        ya.prototype.add = function(t4, e2, r2, n2) {
          this.ids.push(ma(t4)), this.positions.push(e2, r2, n2);
        }, ya.prototype.getPositions = function(t4) {
          for (var e2 = ma(t4), r2 = 0, n2 = this.ids.length - 1; r2 < n2; ) {
            var i3 = r2 + n2 >> 1;
            this.ids[i3] >= e2 ? n2 = i3 : r2 = i3 + 1;
          }
          for (var a2 = []; this.ids[r2] === e2; )
            a2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
          return a2;
        }, ya.serialize = function(t4, e2) {
          var r2 = new Float64Array(t4.ids), n2 = new Uint32Array(t4.positions);
          return function t5(e3, r3, n3, i3) {
            for (; n3 < i3; ) {
              for (var a2 = e3[n3 + i3 >> 1], o2 = n3 - 1, s2 = i3 + 1; ; ) {
                do {
                  o2++;
                } while (e3[o2] < a2);
                do {
                  s2--;
                } while (e3[s2] > a2);
                if (o2 >= s2)
                  break;
                va(e3, o2, s2), va(r3, 3 * o2, 3 * s2), va(r3, 3 * o2 + 1, 3 * s2 + 1), va(r3, 3 * o2 + 2, 3 * s2 + 2);
              }
              s2 - n3 < i3 - s2 ? (t5(e3, r3, n3, s2), n3 = s2 + 1) : (t5(e3, r3, s2 + 1, i3), i3 = s2);
            }
          }(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
        }, ya.deserialize = function(t4) {
          var e2 = new ya();
          return e2.ids = t4.ids, e2.positions = t4.positions, e2.indexed = true, e2;
        };
        var da = Math.pow(2, 53) - 1;
        function ma(t4) {
          var e2 = +t4;
          return !isNaN(e2) && e2 <= da ? e2 : ha(String(t4));
        }
        function va(t4, e2, r2) {
          var n2 = t4[e2];
          t4[e2] = t4[r2], t4[r2] = n2;
        }
        On("FeaturePositionMap", ya);
        var ga = function(t4, e2) {
          this.gl = t4.gl, this.location = e2;
        }, xa = function(t4) {
          function e2(e3, r2) {
            t4.call(this, e3, r2), this.current = 0;
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.set = function(t5) {
            this.current !== t5 && (this.current = t5, this.gl.uniform1i(this.location, t5));
          }, e2;
        }(ga), ba = function(t4) {
          function e2(e3, r2) {
            t4.call(this, e3, r2), this.current = 0;
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.set = function(t5) {
            this.current !== t5 && (this.current = t5, this.gl.uniform1f(this.location, t5));
          }, e2;
        }(ga), wa = function(t4) {
          function e2(e3, r2) {
            t4.call(this, e3, r2), this.current = [0, 0];
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.set = function(t5) {
            t5[0] === this.current[0] && t5[1] === this.current[1] || (this.current = t5, this.gl.uniform2f(this.location, t5[0], t5[1]));
          }, e2;
        }(ga), _a2 = function(t4) {
          function e2(e3, r2) {
            t4.call(this, e3, r2), this.current = [0, 0, 0];
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.set = function(t5) {
            t5[0] === this.current[0] && t5[1] === this.current[1] && t5[2] === this.current[2] || (this.current = t5, this.gl.uniform3f(this.location, t5[0], t5[1], t5[2]));
          }, e2;
        }(ga), Aa = function(t4) {
          function e2(e3, r2) {
            t4.call(this, e3, r2), this.current = [0, 0, 0, 0];
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.set = function(t5) {
            t5[0] === this.current[0] && t5[1] === this.current[1] && t5[2] === this.current[2] && t5[3] === this.current[3] || (this.current = t5, this.gl.uniform4f(this.location, t5[0], t5[1], t5[2], t5[3]));
          }, e2;
        }(ga), Sa = function(t4) {
          function e2(e3, r2) {
            t4.call(this, e3, r2), this.current = te.transparent;
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.set = function(t5) {
            t5.r === this.current.r && t5.g === this.current.g && t5.b === this.current.b && t5.a === this.current.a || (this.current = t5, this.gl.uniform4f(this.location, t5.r, t5.g, t5.b, t5.a));
          }, e2;
        }(ga), ka = new Float32Array(16), Ia = function(t4) {
          function e2(e3, r2) {
            t4.call(this, e3, r2), this.current = ka;
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.set = function(t5) {
            if (t5[12] !== this.current[12] || t5[0] !== this.current[0])
              return this.current = t5, void this.gl.uniformMatrix4fv(this.location, false, t5);
            for (var e3 = 1; e3 < 16; e3++)
              if (t5[e3] !== this.current[e3]) {
                this.current = t5, this.gl.uniformMatrix4fv(this.location, false, t5);
                break;
              }
          }, e2;
        }(ga);
        function za(t4) {
          return [ua(255 * t4.r, 255 * t4.g), ua(255 * t4.b, 255 * t4.a)];
        }
        var Ca = function(t4, e2, r2) {
          this.value = t4, this.uniformNames = e2.map(function(t5) {
            return "u_" + t5;
          }), this.type = r2;
        };
        Ca.prototype.setUniform = function(t4, e2, r2) {
          t4.set(r2.constantOr(this.value));
        }, Ca.prototype.getBinding = function(t4, e2, r2) {
          return "color" === this.type ? new Sa(t4, e2) : new ba(t4, e2);
        };
        var Ea = function(t4, e2) {
          this.uniformNames = e2.map(function(t5) {
            return "u_" + t5;
          }), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        };
        Ea.prototype.setConstantPatternPositions = function(t4, e2) {
          this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t4.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t4.tlbr;
        }, Ea.prototype.setUniform = function(t4, e2, r2, n2) {
          var i3 = "u_pattern_to" === n2 ? this.patternTo : "u_pattern_from" === n2 ? this.patternFrom : "u_pixel_ratio_to" === n2 ? this.pixelRatioTo : "u_pixel_ratio_from" === n2 ? this.pixelRatioFrom : null;
          i3 && t4.set(i3);
        }, Ea.prototype.getBinding = function(t4, e2, r2) {
          return "u_pattern" === r2.substr(0, 9) ? new Aa(t4, e2) : new ba(t4, e2);
        };
        var Pa = function(t4, e2, r2, n2) {
          this.expression = t4, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map(function(t5) {
            return { name: "a_" + t5, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 };
          }), this.paintVertexArray = new n2();
        };
        Pa.prototype.populatePaintArray = function(t4, e2, r2, n2, i3) {
          var a2 = this.paintVertexArray.length, o2 = this.expression.evaluate(new si(0), e2, {}, n2, [], i3);
          this.paintVertexArray.resize(t4), this._setPaintValue(a2, t4, o2);
        }, Pa.prototype.updatePaintArray = function(t4, e2, r2, n2) {
          var i3 = this.expression.evaluate({ zoom: 0 }, r2, n2);
          this._setPaintValue(t4, e2, i3);
        }, Pa.prototype._setPaintValue = function(t4, e2, r2) {
          if ("color" === this.type)
            for (var n2 = za(r2), i3 = t4; i3 < e2; i3++)
              this.paintVertexArray.emplace(i3, n2[0], n2[1]);
          else {
            for (var a2 = t4; a2 < e2; a2++)
              this.paintVertexArray.emplace(a2, r2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2));
          }
        }, Pa.prototype.upload = function(t4) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t4.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }, Pa.prototype.destroy = function() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        };
        var Ma = function(t4, e2, r2, n2, i3, a2) {
          this.expression = t4, this.uniformNames = e2.map(function(t5) {
            return "u_" + t5 + "_t";
          }), this.type = r2, this.useIntegerZoom = n2, this.zoom = i3, this.maxValue = 0, this.paintVertexAttributes = e2.map(function(t5) {
            return { name: "a_" + t5, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 };
          }), this.paintVertexArray = new a2();
        };
        Ma.prototype.populatePaintArray = function(t4, e2, r2, n2, i3) {
          var a2 = this.expression.evaluate(new si(this.zoom), e2, {}, n2, [], i3), o2 = this.expression.evaluate(new si(this.zoom + 1), e2, {}, n2, [], i3), s2 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t4), this._setPaintValue(s2, t4, a2, o2);
        }, Ma.prototype.updatePaintArray = function(t4, e2, r2, n2) {
          var i3 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), a2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
          this._setPaintValue(t4, e2, i3, a2);
        }, Ma.prototype._setPaintValue = function(t4, e2, r2, n2) {
          if ("color" === this.type)
            for (var i3 = za(r2), a2 = za(n2), o2 = t4; o2 < e2; o2++)
              this.paintVertexArray.emplace(o2, i3[0], i3[1], a2[0], a2[1]);
          else {
            for (var s2 = t4; s2 < e2; s2++)
              this.paintVertexArray.emplace(s2, r2, n2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
          }
        }, Ma.prototype.upload = function(t4) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t4.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }, Ma.prototype.destroy = function() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }, Ma.prototype.setUniform = function(t4, e2) {
          var r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = p(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
          t4.set(n2);
        }, Ma.prototype.getBinding = function(t4, e2, r2) {
          return new ba(t4, e2);
        };
        var Ba = function(t4, e2, r2, n2, i3, a2) {
          this.expression = t4, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = a2, this.zoomInPaintVertexArray = new i3(), this.zoomOutPaintVertexArray = new i3();
        };
        Ba.prototype.populatePaintArray = function(t4, e2, r2) {
          var n2 = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(t4), this.zoomOutPaintVertexArray.resize(t4), this._setPaintValues(n2, t4, e2.patterns && e2.patterns[this.layerId], r2);
        }, Ba.prototype.updatePaintArray = function(t4, e2, r2, n2, i3) {
          this._setPaintValues(t4, e2, r2.patterns && r2.patterns[this.layerId], i3);
        }, Ba.prototype._setPaintValues = function(t4, e2, r2, n2) {
          if (n2 && r2) {
            var i3 = n2[r2.min], a2 = n2[r2.mid], o2 = n2[r2.max];
            if (i3 && a2 && o2)
              for (var s2 = t4; s2 < e2; s2++)
                this.zoomInPaintVertexArray.emplace(s2, a2.tl[0], a2.tl[1], a2.br[0], a2.br[1], i3.tl[0], i3.tl[1], i3.br[0], i3.br[1], a2.pixelRatio, i3.pixelRatio), this.zoomOutPaintVertexArray.emplace(s2, a2.tl[0], a2.tl[1], a2.br[0], a2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], a2.pixelRatio, o2.pixelRatio);
          }
        }, Ba.prototype.upload = function(t4) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t4.createVertexBuffer(this.zoomInPaintVertexArray, la.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t4.createVertexBuffer(this.zoomOutPaintVertexArray, la.members, this.expression.isStateDependent));
        }, Ba.prototype.destroy = function() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        };
        var Ta = function(t4, e2, r2) {
          this.binders = {}, this._buffers = [];
          var n2 = [];
          for (var i3 in t4.paint._values)
            if (r2(i3)) {
              var a2 = t4.paint.get(i3);
              if (a2 instanceof yi && Tr(a2.property.specification)) {
                var o2 = Fa(i3, t4.type), s2 = a2.value, u2 = a2.property.specification.type, l2 = a2.property.useIntegerZoom, p2 = a2.property.specification["property-type"], c2 = "cross-faded" === p2 || "cross-faded-data-driven" === p2;
                if ("constant" === s2.kind)
                  this.binders[i3] = c2 ? new Ea(s2.value, o2) : new Ca(s2.value, o2, u2), n2.push("/u_" + i3);
                else if ("source" === s2.kind || c2) {
                  var h2 = Da(i3, u2, "source");
                  this.binders[i3] = c2 ? new Ba(s2, u2, l2, e2, h2, t4.id) : new Pa(s2, o2, u2, h2), n2.push("/a_" + i3);
                } else {
                  var f2 = Da(i3, u2, "composite");
                  this.binders[i3] = new Ma(s2, o2, u2, l2, e2, f2), n2.push("/z_" + i3);
                }
              }
            }
          this.cacheKey = n2.sort().join("");
        };
        Ta.prototype.getMaxValue = function(t4) {
          var e2 = this.binders[t4];
          return e2 instanceof Pa || e2 instanceof Ma ? e2.maxValue : 0;
        }, Ta.prototype.populatePaintArrays = function(t4, e2, r2, n2, i3) {
          for (var a2 in this.binders) {
            var o2 = this.binders[a2];
            (o2 instanceof Pa || o2 instanceof Ma || o2 instanceof Ba) && o2.populatePaintArray(t4, e2, r2, n2, i3);
          }
        }, Ta.prototype.setConstantPatternPositions = function(t4, e2) {
          for (var r2 in this.binders) {
            var n2 = this.binders[r2];
            n2 instanceof Ea && n2.setConstantPatternPositions(t4, e2);
          }
        }, Ta.prototype.updatePaintArrays = function(t4, e2, r2, n2, i3) {
          var a2 = false;
          for (var o2 in t4)
            for (var s2 = 0, u2 = e2.getPositions(o2); s2 < u2.length; s2 += 1) {
              var l2 = u2[s2], p2 = r2.feature(l2.index);
              for (var c2 in this.binders) {
                var h2 = this.binders[c2];
                if ((h2 instanceof Pa || h2 instanceof Ma || h2 instanceof Ba) && true === h2.expression.isStateDependent) {
                  var f2 = n2.paint.get(c2);
                  h2.expression = f2.value, h2.updatePaintArray(l2.start, l2.end, p2, t4[o2], i3), a2 = true;
                }
              }
            }
          return a2;
        }, Ta.prototype.defines = function() {
          var t4 = [];
          for (var e2 in this.binders) {
            var r2 = this.binders[e2];
            (r2 instanceof Ca || r2 instanceof Ea) && t4.push.apply(t4, r2.uniformNames.map(function(t5) {
              return "#define HAS_UNIFORM_" + t5;
            }));
          }
          return t4;
        }, Ta.prototype.getBinderAttributes = function() {
          var t4 = [];
          for (var e2 in this.binders) {
            var r2 = this.binders[e2];
            if (r2 instanceof Pa || r2 instanceof Ma)
              for (var n2 = 0; n2 < r2.paintVertexAttributes.length; n2++)
                t4.push(r2.paintVertexAttributes[n2].name);
            else if (r2 instanceof Ba)
              for (var i3 = 0; i3 < la.members.length; i3++)
                t4.push(la.members[i3].name);
          }
          return t4;
        }, Ta.prototype.getBinderUniforms = function() {
          var t4 = [];
          for (var e2 in this.binders) {
            var r2 = this.binders[e2];
            if (r2 instanceof Ca || r2 instanceof Ea || r2 instanceof Ma)
              for (var n2 = 0, i3 = r2.uniformNames; n2 < i3.length; n2 += 1)
                t4.push(i3[n2]);
          }
          return t4;
        }, Ta.prototype.getPaintVertexBuffers = function() {
          return this._buffers;
        }, Ta.prototype.getUniforms = function(t4, e2) {
          var r2 = [];
          for (var n2 in this.binders) {
            var i3 = this.binders[n2];
            if (i3 instanceof Ca || i3 instanceof Ea || i3 instanceof Ma)
              for (var a2 = 0, o2 = i3.uniformNames; a2 < o2.length; a2 += 1) {
                var s2 = o2[a2];
                if (e2[s2]) {
                  var u2 = i3.getBinding(t4, e2[s2], s2);
                  r2.push({ name: s2, property: n2, binding: u2 });
                }
              }
          }
          return r2;
        }, Ta.prototype.setUniforms = function(t4, e2, r2, n2) {
          for (var i3 = 0, a2 = e2; i3 < a2.length; i3 += 1) {
            var o2 = a2[i3], s2 = o2.name, u2 = o2.property;
            this.binders[u2].setUniform(o2.binding, n2, r2.get(u2), s2);
          }
        }, Ta.prototype.updatePaintBuffers = function(t4) {
          for (var e2 in this._buffers = [], this.binders) {
            var r2 = this.binders[e2];
            if (t4 && r2 instanceof Ba) {
              var n2 = 2 === t4.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
              n2 && this._buffers.push(n2);
            } else
              (r2 instanceof Pa || r2 instanceof Ma) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
          }
        }, Ta.prototype.upload = function(t4) {
          for (var e2 in this.binders) {
            var r2 = this.binders[e2];
            (r2 instanceof Pa || r2 instanceof Ma || r2 instanceof Ba) && r2.upload(t4);
          }
          this.updatePaintBuffers();
        }, Ta.prototype.destroy = function() {
          for (var t4 in this.binders) {
            var e2 = this.binders[t4];
            (e2 instanceof Pa || e2 instanceof Ma || e2 instanceof Ba) && e2.destroy();
          }
        };
        var Va = function(t4, e2, r2) {
          void 0 === r2 && (r2 = function() {
            return true;
          }), this.programConfigurations = {};
          for (var n2 = 0, i3 = t4; n2 < i3.length; n2 += 1) {
            var a2 = i3[n2];
            this.programConfigurations[a2.id] = new Ta(a2, e2, r2);
          }
          this.needsUpload = false, this._featureMap = new ya(), this._bufferOffset = 0;
        };
        function Fa(t4, e2) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t4] || [t4.replace(e2 + "-", "").replace(/-/g, "_")];
        }
        function Da(t4, e2, r2) {
          var n2 = { color: { source: Bi, composite: Hi }, number: { source: Ki, composite: Bi } }, i3 = function(t5) {
            return { "line-pattern": { source: Ti, composite: Ti }, "fill-pattern": { source: Ti, composite: Ti }, "fill-extrusion-pattern": { source: Ti, composite: Ti } }[t5];
          }(t4);
          return i3 && i3[r2] || n2[e2][r2];
        }
        Va.prototype.populatePaintArrays = function(t4, e2, r2, n2, i3, a2) {
          for (var o2 in this.programConfigurations)
            this.programConfigurations[o2].populatePaintArrays(t4, e2, n2, i3, a2);
          void 0 !== e2.id && this._featureMap.add(e2.id, r2, this._bufferOffset, t4), this._bufferOffset = t4, this.needsUpload = true;
        }, Va.prototype.updatePaintArrays = function(t4, e2, r2, n2) {
          for (var i3 = 0, a2 = r2; i3 < a2.length; i3 += 1) {
            var o2 = a2[i3];
            this.needsUpload = this.programConfigurations[o2.id].updatePaintArrays(t4, this._featureMap, e2, o2, n2) || this.needsUpload;
          }
        }, Va.prototype.get = function(t4) {
          return this.programConfigurations[t4];
        }, Va.prototype.upload = function(t4) {
          if (this.needsUpload) {
            for (var e2 in this.programConfigurations)
              this.programConfigurations[e2].upload(t4);
            this.needsUpload = false;
          }
        }, Va.prototype.destroy = function() {
          for (var t4 in this.programConfigurations)
            this.programConfigurations[t4].destroy();
        }, On("ConstantBinder", Ca), On("CrossFadedConstantBinder", Ea), On("SourceExpressionBinder", Pa), On("CrossFadedCompositeBinder", Ba), On("CompositeExpressionBinder", Ma), On("ProgramConfiguration", Ta, { omit: ["_buffers"] }), On("ProgramConfigurationSet", Va);
        var La = Math.pow(2, 14) - 1, Oa = -La - 1;
        function Ra(t4) {
          for (var e2 = 8192 / t4.extent, r2 = t4.loadGeometry(), n2 = 0; n2 < r2.length; n2++)
            for (var i3 = r2[n2], a2 = 0; a2 < i3.length; a2++) {
              var o2 = i3[a2], s2 = Math.round(o2.x * e2), u2 = Math.round(o2.y * e2);
              o2.x = p(s2, Oa, La), o2.y = p(u2, Oa, La), (s2 < o2.x || s2 > o2.x + 1 || u2 < o2.y || u2 > o2.y + 1) && A2("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          return r2;
        }
        function Ua(t4, e2) {
          return { type: t4.type, id: t4.id, properties: t4.properties, geometry: e2 ? Ra(t4) : [] };
        }
        function ja(t4, e2, r2, n2, i3) {
          t4.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i3 + 1) / 2);
        }
        var qa = function(t4) {
          this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map(function(t5) {
            return t5.id;
          }), this.index = t4.index, this.hasPattern = false, this.layoutVertexArray = new Ci(), this.indexArray = new ji(), this.segments = new sa(), this.programConfigurations = new Va(t4.layers, t4.zoom), this.stateDependentLayerIds = this.layers.filter(function(t5) {
            return t5.isStateDependent();
          }).map(function(t5) {
            return t5.id;
          });
        };
        function Na(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            if (Wa(e2, t4[r2]))
              return true;
          for (var n2 = 0; n2 < e2.length; n2++)
            if (Wa(t4, e2[n2]))
              return true;
          return !!Xa(t4, e2);
        }
        function Ka(t4, e2, r2) {
          return !!Wa(t4, e2) || !!Ha(e2, t4, r2);
        }
        function Ga(t4, e2) {
          if (1 === t4.length)
            return $a(e2, t4[0]);
          for (var r2 = 0; r2 < e2.length; r2++)
            for (var n2 = e2[r2], i3 = 0; i3 < n2.length; i3++)
              if (Wa(t4, n2[i3]))
                return true;
          for (var a2 = 0; a2 < t4.length; a2++)
            if ($a(e2, t4[a2]))
              return true;
          for (var o2 = 0; o2 < e2.length; o2++)
            if (Xa(t4, e2[o2]))
              return true;
          return false;
        }
        function Za(t4, e2, r2) {
          if (t4.length > 1) {
            if (Xa(t4, e2))
              return true;
            for (var n2 = 0; n2 < e2.length; n2++)
              if (Ha(e2[n2], t4, r2))
                return true;
          }
          for (var i3 = 0; i3 < t4.length; i3++)
            if (Ha(t4[i3], e2, r2))
              return true;
          return false;
        }
        function Xa(t4, e2) {
          if (0 === t4.length || 0 === e2.length)
            return false;
          for (var r2 = 0; r2 < t4.length - 1; r2++)
            for (var n2 = t4[r2], i3 = t4[r2 + 1], a2 = 0; a2 < e2.length - 1; a2++)
              if (Ja(n2, i3, e2[a2], e2[a2 + 1]))
                return true;
          return false;
        }
        function Ja(t4, e2, r2, n2) {
          return S(t4, r2, n2) !== S(e2, r2, n2) && S(t4, e2, r2) !== S(t4, e2, n2);
        }
        function Ha(t4, e2, r2) {
          var n2 = r2 * r2;
          if (1 === e2.length)
            return t4.distSqr(e2[0]) < n2;
          for (var i3 = 1; i3 < e2.length; i3++)
            if (Ya(t4, e2[i3 - 1], e2[i3]) < n2)
              return true;
          return false;
        }
        function Ya(t4, e2, r2) {
          var n2 = e2.distSqr(r2);
          if (0 === n2)
            return t4.distSqr(e2);
          var i3 = ((t4.x - e2.x) * (r2.x - e2.x) + (t4.y - e2.y) * (r2.y - e2.y)) / n2;
          return t4.distSqr(i3 < 0 ? e2 : i3 > 1 ? r2 : r2.sub(e2)._mult(i3)._add(e2));
        }
        function $a(t4, e2) {
          for (var r2, n2, i3, a2 = false, o2 = 0; o2 < t4.length; o2++)
            for (var s2 = 0, u2 = (r2 = t4[o2]).length - 1; s2 < r2.length; u2 = s2++)
              (n2 = r2[s2]).y > e2.y != (i3 = r2[u2]).y > e2.y && e2.x < (i3.x - n2.x) * (e2.y - n2.y) / (i3.y - n2.y) + n2.x && (a2 = !a2);
          return a2;
        }
        function Wa(t4, e2) {
          for (var r2 = false, n2 = 0, i3 = t4.length - 1; n2 < t4.length; i3 = n2++) {
            var a2 = t4[n2], o2 = t4[i3];
            a2.y > e2.y != o2.y > e2.y && e2.x < (o2.x - a2.x) * (e2.y - a2.y) / (o2.y - a2.y) + a2.x && (r2 = !r2);
          }
          return r2;
        }
        function Qa(t4, e2, r2) {
          var n2 = r2[0], i3 = r2[2];
          if (t4.x < n2.x && e2.x < n2.x || t4.x > i3.x && e2.x > i3.x || t4.y < n2.y && e2.y < n2.y || t4.y > i3.y && e2.y > i3.y)
            return false;
          var a2 = S(t4, e2, r2[0]);
          return a2 !== S(t4, e2, r2[1]) || a2 !== S(t4, e2, r2[2]) || a2 !== S(t4, e2, r2[3]);
        }
        function to(t4, e2, r2) {
          var n2 = e2.paint.get(t4).value;
          return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t4);
        }
        function eo(t4) {
          return Math.sqrt(t4[0] * t4[0] + t4[1] * t4[1]);
        }
        function ro(t4, e2, r2, n2, a2) {
          if (!e2[0] && !e2[1])
            return t4;
          var o2 = i2.convert(e2)._mult(a2);
          "viewport" === r2 && o2._rotate(-n2);
          for (var s2 = [], u2 = 0; u2 < t4.length; u2++)
            s2.push(t4[u2].sub(o2));
          return s2;
        }
        qa.prototype.populate = function(t4, e2, r2) {
          var n2 = this.layers[0], i3 = [], a2 = null;
          "circle" === n2.type && (a2 = n2.layout.get("circle-sort-key"));
          for (var o2 = 0, s2 = t4; o2 < s2.length; o2 += 1) {
            var u2 = s2[o2], l2 = u2.feature, p2 = u2.id, c2 = u2.index, h2 = u2.sourceLayerIndex, f2 = this.layers[0]._featureFilter.needGeometry, y2 = Ua(l2, f2);
            if (this.layers[0]._featureFilter.filter(new si(this.zoom), y2, r2)) {
              var d2 = a2 ? a2.evaluate(y2, {}, r2) : void 0, m2 = { id: p2, properties: l2.properties, type: l2.type, sourceLayerIndex: h2, index: c2, geometry: f2 ? y2.geometry : Ra(l2), patterns: {}, sortKey: d2 };
              i3.push(m2);
            }
          }
          a2 && i3.sort(function(t5, e3) {
            return t5.sortKey - e3.sortKey;
          });
          for (var v2 = 0, g2 = i3; v2 < g2.length; v2 += 1) {
            var x3 = g2[v2], b2 = x3.geometry, w2 = x3.index, _2 = x3.sourceLayerIndex, A3 = t4[w2].feature;
            this.addFeature(x3, b2, w2, r2), e2.featureIndex.insert(A3, b2, w2, _2, this.index);
          }
        }, qa.prototype.update = function(t4, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t4, e2, this.stateDependentLayers, r2);
        }, qa.prototype.isEmpty = function() {
          return 0 === this.layoutVertexArray.length;
        }, qa.prototype.uploadPending = function() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }, qa.prototype.upload = function(t4) {
          this.uploaded || (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, oa), this.indexBuffer = t4.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t4), this.uploaded = true;
        }, qa.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }, qa.prototype.addFeature = function(t4, e2, r2, n2) {
          for (var i3 = 0, a2 = e2; i3 < a2.length; i3 += 1)
            for (var o2 = 0, s2 = a2[i3]; o2 < s2.length; o2 += 1) {
              var u2 = s2[o2], l2 = u2.x, p2 = u2.y;
              if (!(l2 < 0 || l2 >= 8192 || p2 < 0 || p2 >= 8192)) {
                var c2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t4.sortKey), h2 = c2.vertexLength;
                ja(this.layoutVertexArray, l2, p2, -1, -1), ja(this.layoutVertexArray, l2, p2, 1, -1), ja(this.layoutVertexArray, l2, p2, 1, 1), ja(this.layoutVertexArray, l2, p2, -1, 1), this.indexArray.emplaceBack(h2, h2 + 1, h2 + 2), this.indexArray.emplaceBack(h2, h2 + 3, h2 + 2), c2.vertexLength += 4, c2.primitiveLength += 2;
              }
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r2, {}, n2);
        }, On("CircleBucket", qa, { omit: ["layers"] });
        var no = new wi({ "circle-sort-key": new vi(Et.layout_circle["circle-sort-key"]) }), io = { paint: new wi({ "circle-radius": new vi(Et.paint_circle["circle-radius"]), "circle-color": new vi(Et.paint_circle["circle-color"]), "circle-blur": new vi(Et.paint_circle["circle-blur"]), "circle-opacity": new vi(Et.paint_circle["circle-opacity"]), "circle-translate": new mi(Et.paint_circle["circle-translate"]), "circle-translate-anchor": new mi(Et.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new mi(Et.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new mi(Et.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new vi(Et.paint_circle["circle-stroke-width"]), "circle-stroke-color": new vi(Et.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new vi(Et.paint_circle["circle-stroke-opacity"]) }), layout: no }, ao = "undefined" != typeof Float32Array ? Float32Array : Array;
        function oo(t4) {
          return t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = 1, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = 1, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4;
        }
        function so(t4, e2, r2) {
          var n2 = e2[0], i3 = e2[1], a2 = e2[2], o2 = e2[3], s2 = e2[4], u2 = e2[5], l2 = e2[6], p2 = e2[7], c2 = e2[8], h2 = e2[9], f2 = e2[10], y2 = e2[11], d2 = e2[12], m2 = e2[13], v2 = e2[14], g2 = e2[15], x3 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
          return t4[0] = x3 * n2 + b2 * s2 + w2 * c2 + _2 * d2, t4[1] = x3 * i3 + b2 * u2 + w2 * h2 + _2 * m2, t4[2] = x3 * a2 + b2 * l2 + w2 * f2 + _2 * v2, t4[3] = x3 * o2 + b2 * p2 + w2 * y2 + _2 * g2, t4[4] = (x3 = r2[4]) * n2 + (b2 = r2[5]) * s2 + (w2 = r2[6]) * c2 + (_2 = r2[7]) * d2, t4[5] = x3 * i3 + b2 * u2 + w2 * h2 + _2 * m2, t4[6] = x3 * a2 + b2 * l2 + w2 * f2 + _2 * v2, t4[7] = x3 * o2 + b2 * p2 + w2 * y2 + _2 * g2, t4[8] = (x3 = r2[8]) * n2 + (b2 = r2[9]) * s2 + (w2 = r2[10]) * c2 + (_2 = r2[11]) * d2, t4[9] = x3 * i3 + b2 * u2 + w2 * h2 + _2 * m2, t4[10] = x3 * a2 + b2 * l2 + w2 * f2 + _2 * v2, t4[11] = x3 * o2 + b2 * p2 + w2 * y2 + _2 * g2, t4[12] = (x3 = r2[12]) * n2 + (b2 = r2[13]) * s2 + (w2 = r2[14]) * c2 + (_2 = r2[15]) * d2, t4[13] = x3 * i3 + b2 * u2 + w2 * h2 + _2 * m2, t4[14] = x3 * a2 + b2 * l2 + w2 * f2 + _2 * v2, t4[15] = x3 * o2 + b2 * p2 + w2 * y2 + _2 * g2, t4;
        }
        Math.hypot || (Math.hypot = function() {
          for (var t4 = arguments, e2 = 0, r2 = arguments.length; r2--; )
            e2 += t4[r2] * t4[r2];
          return Math.sqrt(e2);
        });
        var uo, lo = so;
        function po(t4, e2, r2) {
          var n2 = e2[0], i3 = e2[1], a2 = e2[2], o2 = e2[3];
          return t4[0] = r2[0] * n2 + r2[4] * i3 + r2[8] * a2 + r2[12] * o2, t4[1] = r2[1] * n2 + r2[5] * i3 + r2[9] * a2 + r2[13] * o2, t4[2] = r2[2] * n2 + r2[6] * i3 + r2[10] * a2 + r2[14] * o2, t4[3] = r2[3] * n2 + r2[7] * i3 + r2[11] * a2 + r2[15] * o2, t4;
        }
        uo = new ao(3), ao != Float32Array && (uo[0] = 0, uo[1] = 0, uo[2] = 0), function() {
          var t4 = new ao(4);
          ao != Float32Array && (t4[0] = 0, t4[1] = 0, t4[2] = 0, t4[3] = 0);
        }();
        var co = (function() {
          var t4 = new ao(2);
          ao != Float32Array && (t4[0] = 0, t4[1] = 0);
        }(), function(t4) {
          function e2(e3) {
            t4.call(this, e3, io);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.createBucket = function(t5) {
            return new qa(t5);
          }, e2.prototype.queryRadius = function(t5) {
            var e3 = t5;
            return to("circle-radius", this, e3) + to("circle-stroke-width", this, e3) + eo(this.paint.get("circle-translate"));
          }, e2.prototype.queryIntersectsFeature = function(t5, e3, r2, n2, i3, a2, o2, s2) {
            for (var u2 = ro(t5, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a2.angle, o2), l2 = this.paint.get("circle-radius").evaluate(e3, r2) + this.paint.get("circle-stroke-width").evaluate(e3, r2), p2 = "map" === this.paint.get("circle-pitch-alignment"), c2 = p2 ? u2 : function(t6, e4) {
              return t6.map(function(t7) {
                return ho(t7, e4);
              });
            }(u2, s2), h2 = p2 ? l2 * o2 : l2, f2 = 0, y2 = n2; f2 < y2.length; f2 += 1)
              for (var d2 = 0, m2 = y2[f2]; d2 < m2.length; d2 += 1) {
                var v2 = m2[d2], g2 = p2 ? v2 : ho(v2, s2), x3 = h2, b2 = po([], [v2.x, v2.y, 0, 1], s2);
                if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? x3 *= b2[3] / a2.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (x3 *= a2.cameraToCenterDistance / b2[3]), Ka(c2, g2, x3))
                  return true;
              }
            return false;
          }, e2;
        }(_i));
        function ho(t4, e2) {
          var r2 = po([], [t4.x, t4.y, 0, 1], e2);
          return new i2(r2[0] / r2[3], r2[1] / r2[3]);
        }
        var fo = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2;
        }(qa);
        function yo(t4, e2, r2, n2) {
          var i3 = e2.width, a2 = e2.height;
          if (n2) {
            if (n2 instanceof Uint8ClampedArray)
              n2 = new Uint8Array(n2.buffer);
            else if (n2.length !== i3 * a2 * r2)
              throw new RangeError("mismatched image size");
          } else
            n2 = new Uint8Array(i3 * a2 * r2);
          return t4.width = i3, t4.height = a2, t4.data = n2, t4;
        }
        function mo(t4, e2, r2) {
          var n2 = e2.width, i3 = e2.height;
          if (n2 !== t4.width || i3 !== t4.height) {
            var a2 = yo({}, { width: n2, height: i3 }, r2);
            vo(t4, a2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t4.width, n2), height: Math.min(t4.height, i3) }, r2), t4.width = n2, t4.height = i3, t4.data = a2.data;
          }
        }
        function vo(t4, e2, r2, n2, i3, a2) {
          if (0 === i3.width || 0 === i3.height)
            return e2;
          if (i3.width > t4.width || i3.height > t4.height || r2.x > t4.width - i3.width || r2.y > t4.height - i3.height)
            throw new RangeError("out of range source coordinates for image copy");
          if (i3.width > e2.width || i3.height > e2.height || n2.x > e2.width - i3.width || n2.y > e2.height - i3.height)
            throw new RangeError("out of range destination coordinates for image copy");
          for (var o2 = t4.data, s2 = e2.data, u2 = 0; u2 < i3.height; u2++)
            for (var l2 = ((r2.y + u2) * t4.width + r2.x) * a2, p2 = ((n2.y + u2) * e2.width + n2.x) * a2, c2 = 0; c2 < i3.width * a2; c2++)
              s2[p2 + c2] = o2[l2 + c2];
          return e2;
        }
        On("HeatmapBucket", fo, { omit: ["layers"] });
        var go = function(t4, e2) {
          yo(this, t4, 1, e2);
        };
        go.prototype.resize = function(t4) {
          mo(this, t4, 1);
        }, go.prototype.clone = function() {
          return new go({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }, go.copy = function(t4, e2, r2, n2, i3) {
          vo(t4, e2, r2, n2, i3, 1);
        };
        var xo = function(t4, e2) {
          yo(this, t4, 4, e2);
        };
        xo.prototype.resize = function(t4) {
          mo(this, t4, 4);
        }, xo.prototype.replace = function(t4, e2) {
          e2 ? this.data.set(t4) : this.data = t4 instanceof Uint8ClampedArray ? new Uint8Array(t4.buffer) : t4;
        }, xo.prototype.clone = function() {
          return new xo({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }, xo.copy = function(t4, e2, r2, n2, i3) {
          vo(t4, e2, r2, n2, i3, 4);
        }, On("AlphaImage", go), On("RGBAImage", xo);
        var bo = { paint: new wi({ "heatmap-radius": new vi(Et.paint_heatmap["heatmap-radius"]), "heatmap-weight": new vi(Et.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new mi(Et.paint_heatmap["heatmap-intensity"]), "heatmap-color": new bi(Et.paint_heatmap["heatmap-color"]), "heatmap-opacity": new mi(Et.paint_heatmap["heatmap-opacity"]) }) };
        function wo(t4) {
          var e2 = {}, r2 = t4.resolution || 256, n2 = t4.clips ? t4.clips.length : 1, i3 = t4.image || new xo({ width: r2, height: n2 }), a2 = function(r3, n3, a3) {
            e2[t4.evaluationKey] = a3;
            var o3 = t4.expression.evaluate(e2);
            i3.data[r3 + n3 + 0] = Math.floor(255 * o3.r / o3.a), i3.data[r3 + n3 + 1] = Math.floor(255 * o3.g / o3.a), i3.data[r3 + n3 + 2] = Math.floor(255 * o3.b / o3.a), i3.data[r3 + n3 + 3] = Math.floor(255 * o3.a);
          };
          if (t4.clips)
            for (var o2 = 0, s2 = 0; o2 < n2; ++o2, s2 += 4 * r2)
              for (var u2 = 0, l2 = 0; u2 < r2; u2++, l2 += 4) {
                var p2 = u2 / (r2 - 1), c2 = t4.clips[o2];
                a2(s2, l2, c2.start * (1 - p2) + c2.end * p2);
              }
          else
            for (var h2 = 0, f2 = 0; h2 < r2; h2++, f2 += 4)
              a2(0, f2, h2 / (r2 - 1));
          return i3;
        }
        var _o = function(t4) {
          function e2(e3) {
            t4.call(this, e3, bo), this._updateColorRamp();
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.createBucket = function(t5) {
            return new fo(t5);
          }, e2.prototype._handleSpecialPaintPropertyUpdate = function(t5) {
            "heatmap-color" === t5 && this._updateColorRamp();
          }, e2.prototype._updateColorRamp = function() {
            this.colorRamp = wo({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }, e2.prototype.resize = function() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }, e2.prototype.queryRadius = function() {
            return 0;
          }, e2.prototype.queryIntersectsFeature = function() {
            return false;
          }, e2.prototype.hasOffscreenPass = function() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }, e2;
        }(_i), Ao = { paint: new wi({ "hillshade-illumination-direction": new mi(Et.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new mi(Et.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new mi(Et.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new mi(Et.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new mi(Et.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new mi(Et.paint_hillshade["hillshade-accent-color"]) }) }, So = function(t4) {
          function e2(e3) {
            t4.call(this, e3, Ao);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.hasOffscreenPass = function() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }, e2;
        }(_i), ko = Ii([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, Io = Co, zo = Co;
        function Co(t4, e2, r2) {
          r2 = r2 || 2;
          var n2, i3, a2, o2, s2, u2, l2, p2 = e2 && e2.length, c2 = p2 ? e2[0] * r2 : t4.length, h2 = Eo(t4, 0, c2, r2, true), f2 = [];
          if (!h2 || h2.next === h2.prev)
            return f2;
          if (p2 && (h2 = function(t5, e3, r3, n3) {
            var i4, a3, o3, s3 = [];
            for (i4 = 0, a3 = e3.length; i4 < a3; i4++)
              (o3 = Eo(t5, e3[i4] * n3, i4 < a3 - 1 ? e3[i4 + 1] * n3 : t5.length, n3, false)) === o3.next && (o3.steiner = true), s3.push(Uo(o3));
            for (s3.sort(Do), i4 = 0; i4 < s3.length; i4++)
              Lo(s3[i4], r3), r3 = Po(r3, r3.next);
            return r3;
          }(t4, e2, h2, r2)), t4.length > 80 * r2) {
            n2 = a2 = t4[0], i3 = o2 = t4[1];
            for (var y2 = r2; y2 < c2; y2 += r2)
              (s2 = t4[y2]) < n2 && (n2 = s2), (u2 = t4[y2 + 1]) < i3 && (i3 = u2), s2 > a2 && (a2 = s2), u2 > o2 && (o2 = u2);
            l2 = 0 !== (l2 = Math.max(a2 - n2, o2 - i3)) ? 1 / l2 : 0;
          }
          return Mo(h2, f2, r2, n2, i3, l2), f2;
        }
        function Eo(t4, e2, r2, n2, i3) {
          var a2, o2;
          if (i3 === Qo(t4, e2, r2, n2) > 0)
            for (a2 = e2; a2 < r2; a2 += n2)
              o2 = Yo(a2, t4[a2], t4[a2 + 1], o2);
          else
            for (a2 = r2 - n2; a2 >= e2; a2 -= n2)
              o2 = Yo(a2, t4[a2], t4[a2 + 1], o2);
          return o2 && Ko(o2, o2.next) && ($o(o2), o2 = o2.next), o2;
        }
        function Po(t4, e2) {
          if (!t4)
            return t4;
          e2 || (e2 = t4);
          var r2, n2 = t4;
          do {
            if (r2 = false, n2.steiner || !Ko(n2, n2.next) && 0 !== No(n2.prev, n2, n2.next))
              n2 = n2.next;
            else {
              if ($o(n2), (n2 = e2 = n2.prev) === n2.next)
                break;
              r2 = true;
            }
          } while (r2 || n2 !== e2);
          return e2;
        }
        function Mo(t4, e2, r2, n2, i3, a2, o2) {
          if (t4) {
            !o2 && a2 && function(t5, e3, r3, n3) {
              var i4 = t5;
              do {
                null === i4.z && (i4.z = Ro(i4.x, i4.y, e3, r3, n3)), i4.prevZ = i4.prev, i4.nextZ = i4.next, i4 = i4.next;
              } while (i4 !== t5);
              i4.prevZ.nextZ = null, i4.prevZ = null, function(t6) {
                var e4, r4, n4, i5, a3, o3, s3, u3, l3 = 1;
                do {
                  for (r4 = t6, t6 = null, a3 = null, o3 = 0; r4; ) {
                    for (o3++, n4 = r4, s3 = 0, e4 = 0; e4 < l3 && (s3++, n4 = n4.nextZ); e4++)
                      ;
                    for (u3 = l3; s3 > 0 || u3 > 0 && n4; )
                      0 !== s3 && (0 === u3 || !n4 || r4.z <= n4.z) ? (i5 = r4, r4 = r4.nextZ, s3--) : (i5 = n4, n4 = n4.nextZ, u3--), a3 ? a3.nextZ = i5 : t6 = i5, i5.prevZ = a3, a3 = i5;
                    r4 = n4;
                  }
                  a3.nextZ = null, l3 *= 2;
                } while (o3 > 1);
              }(i4);
            }(t4, n2, i3, a2);
            for (var s2, u2, l2 = t4; t4.prev !== t4.next; )
              if (s2 = t4.prev, u2 = t4.next, a2 ? To(t4, n2, i3, a2) : Bo(t4))
                e2.push(s2.i / r2), e2.push(t4.i / r2), e2.push(u2.i / r2), $o(t4), t4 = u2.next, l2 = u2.next;
              else if ((t4 = u2) === l2) {
                o2 ? 1 === o2 ? Mo(t4 = Vo(Po(t4), e2, r2), e2, r2, n2, i3, a2, 2) : 2 === o2 && Fo(t4, e2, r2, n2, i3, a2) : Mo(Po(t4), e2, r2, n2, i3, a2, 1);
                break;
              }
          }
        }
        function Bo(t4) {
          var e2 = t4.prev, r2 = t4, n2 = t4.next;
          if (No(e2, r2, n2) >= 0)
            return false;
          for (var i3 = t4.next.next; i3 !== t4.prev; ) {
            if (jo(e2.x, e2.y, r2.x, r2.y, n2.x, n2.y, i3.x, i3.y) && No(i3.prev, i3, i3.next) >= 0)
              return false;
            i3 = i3.next;
          }
          return true;
        }
        function To(t4, e2, r2, n2) {
          var i3 = t4.prev, a2 = t4, o2 = t4.next;
          if (No(i3, a2, o2) >= 0)
            return false;
          for (var s2 = i3.x > a2.x ? i3.x > o2.x ? i3.x : o2.x : a2.x > o2.x ? a2.x : o2.x, u2 = i3.y > a2.y ? i3.y > o2.y ? i3.y : o2.y : a2.y > o2.y ? a2.y : o2.y, l2 = Ro(i3.x < a2.x ? i3.x < o2.x ? i3.x : o2.x : a2.x < o2.x ? a2.x : o2.x, i3.y < a2.y ? i3.y < o2.y ? i3.y : o2.y : a2.y < o2.y ? a2.y : o2.y, e2, r2, n2), p2 = Ro(s2, u2, e2, r2, n2), c2 = t4.prevZ, h2 = t4.nextZ; c2 && c2.z >= l2 && h2 && h2.z <= p2; ) {
            if (c2 !== t4.prev && c2 !== t4.next && jo(i3.x, i3.y, a2.x, a2.y, o2.x, o2.y, c2.x, c2.y) && No(c2.prev, c2, c2.next) >= 0)
              return false;
            if (c2 = c2.prevZ, h2 !== t4.prev && h2 !== t4.next && jo(i3.x, i3.y, a2.x, a2.y, o2.x, o2.y, h2.x, h2.y) && No(h2.prev, h2, h2.next) >= 0)
              return false;
            h2 = h2.nextZ;
          }
          for (; c2 && c2.z >= l2; ) {
            if (c2 !== t4.prev && c2 !== t4.next && jo(i3.x, i3.y, a2.x, a2.y, o2.x, o2.y, c2.x, c2.y) && No(c2.prev, c2, c2.next) >= 0)
              return false;
            c2 = c2.prevZ;
          }
          for (; h2 && h2.z <= p2; ) {
            if (h2 !== t4.prev && h2 !== t4.next && jo(i3.x, i3.y, a2.x, a2.y, o2.x, o2.y, h2.x, h2.y) && No(h2.prev, h2, h2.next) >= 0)
              return false;
            h2 = h2.nextZ;
          }
          return true;
        }
        function Vo(t4, e2, r2) {
          var n2 = t4;
          do {
            var i3 = n2.prev, a2 = n2.next.next;
            !Ko(i3, a2) && Go(i3, n2, n2.next, a2) && Jo(i3, a2) && Jo(a2, i3) && (e2.push(i3.i / r2), e2.push(n2.i / r2), e2.push(a2.i / r2), $o(n2), $o(n2.next), n2 = t4 = a2), n2 = n2.next;
          } while (n2 !== t4);
          return Po(n2);
        }
        function Fo(t4, e2, r2, n2, i3, a2) {
          var o2 = t4;
          do {
            for (var s2 = o2.next.next; s2 !== o2.prev; ) {
              if (o2.i !== s2.i && qo(o2, s2)) {
                var u2 = Ho(o2, s2);
                return o2 = Po(o2, o2.next), u2 = Po(u2, u2.next), Mo(o2, e2, r2, n2, i3, a2), void Mo(u2, e2, r2, n2, i3, a2);
              }
              s2 = s2.next;
            }
            o2 = o2.next;
          } while (o2 !== t4);
        }
        function Do(t4, e2) {
          return t4.x - e2.x;
        }
        function Lo(t4, e2) {
          if (e2 = function(t5, e3) {
            var r3, n2 = e3, i3 = t5.x, a2 = t5.y, o2 = -1 / 0;
            do {
              if (a2 <= n2.y && a2 >= n2.next.y && n2.next.y !== n2.y) {
                var s2 = n2.x + (a2 - n2.y) * (n2.next.x - n2.x) / (n2.next.y - n2.y);
                if (s2 <= i3 && s2 > o2) {
                  if (o2 = s2, s2 === i3) {
                    if (a2 === n2.y)
                      return n2;
                    if (a2 === n2.next.y)
                      return n2.next;
                  }
                  r3 = n2.x < n2.next.x ? n2 : n2.next;
                }
              }
              n2 = n2.next;
            } while (n2 !== e3);
            if (!r3)
              return null;
            if (i3 === o2)
              return r3;
            var u2, l2 = r3, p2 = r3.x, c2 = r3.y, h2 = 1 / 0;
            n2 = r3;
            do {
              i3 >= n2.x && n2.x >= p2 && i3 !== n2.x && jo(a2 < c2 ? i3 : o2, a2, p2, c2, a2 < c2 ? o2 : i3, a2, n2.x, n2.y) && (u2 = Math.abs(a2 - n2.y) / (i3 - n2.x), Jo(n2, t5) && (u2 < h2 || u2 === h2 && (n2.x > r3.x || n2.x === r3.x && Oo(r3, n2))) && (r3 = n2, h2 = u2)), n2 = n2.next;
            } while (n2 !== l2);
            return r3;
          }(t4, e2)) {
            var r2 = Ho(e2, t4);
            Po(e2, e2.next), Po(r2, r2.next);
          }
        }
        function Oo(t4, e2) {
          return No(t4.prev, t4, e2.prev) < 0 && No(e2.next, t4, t4.next) < 0;
        }
        function Ro(t4, e2, r2, n2, i3) {
          return (t4 = 1431655765 & ((t4 = 858993459 & ((t4 = 252645135 & ((t4 = 16711935 & ((t4 = 32767 * (t4 - r2) * i3) | t4 << 8)) | t4 << 4)) | t4 << 2)) | t4 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - n2) * i3) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
        }
        function Uo(t4) {
          var e2 = t4, r2 = t4;
          do {
            (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
          } while (e2 !== t4);
          return r2;
        }
        function jo(t4, e2, r2, n2, i3, a2, o2, s2) {
          return (i3 - o2) * (e2 - s2) - (t4 - o2) * (a2 - s2) >= 0 && (t4 - o2) * (n2 - s2) - (r2 - o2) * (e2 - s2) >= 0 && (r2 - o2) * (a2 - s2) - (i3 - o2) * (n2 - s2) >= 0;
        }
        function qo(t4, e2) {
          return t4.next.i !== e2.i && t4.prev.i !== e2.i && !function(t5, e3) {
            var r2 = t5;
            do {
              if (r2.i !== t5.i && r2.next.i !== t5.i && r2.i !== e3.i && r2.next.i !== e3.i && Go(r2, r2.next, t5, e3))
                return true;
              r2 = r2.next;
            } while (r2 !== t5);
            return false;
          }(t4, e2) && (Jo(t4, e2) && Jo(e2, t4) && function(t5, e3) {
            var r2 = t5, n2 = false, i3 = (t5.x + e3.x) / 2, a2 = (t5.y + e3.y) / 2;
            do {
              r2.y > a2 != r2.next.y > a2 && r2.next.y !== r2.y && i3 < (r2.next.x - r2.x) * (a2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
            } while (r2 !== t5);
            return n2;
          }(t4, e2) && (No(t4.prev, t4, e2.prev) || No(t4, e2.prev, e2)) || Ko(t4, e2) && No(t4.prev, t4, t4.next) > 0 && No(e2.prev, e2, e2.next) > 0);
        }
        function No(t4, e2, r2) {
          return (e2.y - t4.y) * (r2.x - e2.x) - (e2.x - t4.x) * (r2.y - e2.y);
        }
        function Ko(t4, e2) {
          return t4.x === e2.x && t4.y === e2.y;
        }
        function Go(t4, e2, r2, n2) {
          var i3 = Xo(No(t4, e2, r2)), a2 = Xo(No(t4, e2, n2)), o2 = Xo(No(r2, n2, t4)), s2 = Xo(No(r2, n2, e2));
          return i3 !== a2 && o2 !== s2 || !(0 !== i3 || !Zo(t4, r2, e2)) || !(0 !== a2 || !Zo(t4, n2, e2)) || !(0 !== o2 || !Zo(r2, t4, n2)) || !(0 !== s2 || !Zo(r2, e2, n2));
        }
        function Zo(t4, e2, r2) {
          return e2.x <= Math.max(t4.x, r2.x) && e2.x >= Math.min(t4.x, r2.x) && e2.y <= Math.max(t4.y, r2.y) && e2.y >= Math.min(t4.y, r2.y);
        }
        function Xo(t4) {
          return t4 > 0 ? 1 : t4 < 0 ? -1 : 0;
        }
        function Jo(t4, e2) {
          return No(t4.prev, t4, t4.next) < 0 ? No(t4, e2, t4.next) >= 0 && No(t4, t4.prev, e2) >= 0 : No(t4, e2, t4.prev) < 0 || No(t4, t4.next, e2) < 0;
        }
        function Ho(t4, e2) {
          var r2 = new Wo(t4.i, t4.x, t4.y), n2 = new Wo(e2.i, e2.x, e2.y), i3 = t4.next, a2 = e2.prev;
          return t4.next = e2, e2.prev = t4, r2.next = i3, i3.prev = r2, n2.next = r2, r2.prev = n2, a2.next = n2, n2.prev = a2, n2;
        }
        function Yo(t4, e2, r2, n2) {
          var i3 = new Wo(t4, e2, r2);
          return n2 ? (i3.next = n2.next, i3.prev = n2, n2.next.prev = i3, n2.next = i3) : (i3.prev = i3, i3.next = i3), i3;
        }
        function $o(t4) {
          t4.next.prev = t4.prev, t4.prev.next = t4.next, t4.prevZ && (t4.prevZ.nextZ = t4.nextZ), t4.nextZ && (t4.nextZ.prevZ = t4.prevZ);
        }
        function Wo(t4, e2, r2) {
          this.i = t4, this.x = e2, this.y = r2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function Qo(t4, e2, r2, n2) {
          for (var i3 = 0, a2 = e2, o2 = r2 - n2; a2 < r2; a2 += n2)
            i3 += (t4[o2] - t4[a2]) * (t4[a2 + 1] + t4[o2 + 1]), o2 = a2;
          return i3;
        }
        function ts(t4, e2, r2, n2, i3) {
          !function t5(e3, r3, n3, i4, a2) {
            for (; i4 > n3; ) {
              if (i4 - n3 > 600) {
                var o2 = i4 - n3 + 1, s2 = r3 - n3 + 1, u2 = Math.log(o2), l2 = 0.5 * Math.exp(2 * u2 / 3), p2 = 0.5 * Math.sqrt(u2 * l2 * (o2 - l2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1);
                t5(e3, r3, Math.max(n3, Math.floor(r3 - s2 * l2 / o2 + p2)), Math.min(i4, Math.floor(r3 + (o2 - s2) * l2 / o2 + p2)), a2);
              }
              var c2 = e3[r3], h2 = n3, f2 = i4;
              for (es(e3, n3, r3), a2(e3[i4], c2) > 0 && es(e3, n3, i4); h2 < f2; ) {
                for (es(e3, h2, f2), h2++, f2--; a2(e3[h2], c2) < 0; )
                  h2++;
                for (; a2(e3[f2], c2) > 0; )
                  f2--;
              }
              0 === a2(e3[n3], c2) ? es(e3, n3, f2) : es(e3, ++f2, i4), f2 <= r3 && (n3 = f2 + 1), r3 <= f2 && (i4 = f2 - 1);
            }
          }(t4, e2, r2 || 0, n2 || t4.length - 1, i3 || rs);
        }
        function es(t4, e2, r2) {
          var n2 = t4[e2];
          t4[e2] = t4[r2], t4[r2] = n2;
        }
        function rs(t4, e2) {
          return t4 < e2 ? -1 : t4 > e2 ? 1 : 0;
        }
        function ns(t4, e2) {
          var r2 = t4.length;
          if (r2 <= 1)
            return [t4];
          for (var n2, i3, a2 = [], o2 = 0; o2 < r2; o2++) {
            var s2 = k(t4[o2]);
            0 !== s2 && (t4[o2].area = Math.abs(s2), void 0 === i3 && (i3 = s2 < 0), i3 === s2 < 0 ? (n2 && a2.push(n2), n2 = [t4[o2]]) : n2.push(t4[o2]));
          }
          if (n2 && a2.push(n2), e2 > 1)
            for (var u2 = 0; u2 < a2.length; u2++)
              a2[u2].length <= e2 || (ts(a2[u2], e2, 1, a2[u2].length - 1, is), a2[u2] = a2[u2].slice(0, e2));
          return a2;
        }
        function is(t4, e2) {
          return e2.area - t4.area;
        }
        function as(t4, e2, r2) {
          for (var n2 = r2.patternDependencies, i3 = false, a2 = 0, o2 = e2; a2 < o2.length; a2 += 1) {
            var s2 = o2[a2].paint.get(t4 + "-pattern");
            s2.isConstant() || (i3 = true);
            var u2 = s2.constantOr(null);
            u2 && (i3 = true, n2[u2.to] = true, n2[u2.from] = true);
          }
          return i3;
        }
        function os(t4, e2, r2, n2, i3) {
          for (var a2 = i3.patternDependencies, o2 = 0, s2 = e2; o2 < s2.length; o2 += 1) {
            var u2 = s2[o2], l2 = u2.paint.get(t4 + "-pattern").value;
            if ("constant" !== l2.kind) {
              var p2 = l2.evaluate({ zoom: n2 - 1 }, r2, {}, i3.availableImages), c2 = l2.evaluate({ zoom: n2 }, r2, {}, i3.availableImages), h2 = l2.evaluate({ zoom: n2 + 1 }, r2, {}, i3.availableImages);
              c2 = c2 && c2.name ? c2.name : c2, h2 = h2 && h2.name ? h2.name : h2, a2[p2 = p2 && p2.name ? p2.name : p2] = true, a2[c2] = true, a2[h2] = true, r2.patterns[u2.id] = { min: p2, mid: c2, max: h2 };
            }
          }
          return r2;
        }
        Co.deviation = function(t4, e2, r2, n2) {
          var i3 = e2 && e2.length, a2 = Math.abs(Qo(t4, 0, i3 ? e2[0] * r2 : t4.length, r2));
          if (i3)
            for (var o2 = 0, s2 = e2.length; o2 < s2; o2++)
              a2 -= Math.abs(Qo(t4, e2[o2] * r2, o2 < s2 - 1 ? e2[o2 + 1] * r2 : t4.length, r2));
          var u2 = 0;
          for (o2 = 0; o2 < n2.length; o2 += 3) {
            var l2 = n2[o2] * r2, p2 = n2[o2 + 1] * r2, c2 = n2[o2 + 2] * r2;
            u2 += Math.abs((t4[l2] - t4[c2]) * (t4[p2 + 1] - t4[l2 + 1]) - (t4[l2] - t4[p2]) * (t4[c2 + 1] - t4[l2 + 1]));
          }
          return 0 === a2 && 0 === u2 ? 0 : Math.abs((u2 - a2) / a2);
        }, Co.flatten = function(t4) {
          for (var e2 = t4[0][0].length, r2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i3 = 0; i3 < t4.length; i3++) {
            for (var a2 = 0; a2 < t4[i3].length; a2++)
              for (var o2 = 0; o2 < e2; o2++)
                r2.vertices.push(t4[i3][a2][o2]);
            i3 > 0 && r2.holes.push(n2 += t4[i3 - 1].length);
          }
          return r2;
        }, Io.default = zo;
        var ss = function(t4) {
          this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map(function(t5) {
            return t5.id;
          }), this.index = t4.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Ci(), this.indexArray = new ji(), this.indexArray2 = new Xi(), this.programConfigurations = new Va(t4.layers, t4.zoom), this.segments = new sa(), this.segments2 = new sa(), this.stateDependentLayerIds = this.layers.filter(function(t5) {
            return t5.isStateDependent();
          }).map(function(t5) {
            return t5.id;
          });
        };
        ss.prototype.populate = function(t4, e2, r2) {
          this.hasPattern = as("fill", this.layers, e2);
          for (var n2 = this.layers[0].layout.get("fill-sort-key"), i3 = [], a2 = 0, o2 = t4; a2 < o2.length; a2 += 1) {
            var s2 = o2[a2], u2 = s2.feature, l2 = s2.id, p2 = s2.index, c2 = s2.sourceLayerIndex, h2 = this.layers[0]._featureFilter.needGeometry, f2 = Ua(u2, h2);
            if (this.layers[0]._featureFilter.filter(new si(this.zoom), f2, r2)) {
              var y2 = n2 ? n2.evaluate(f2, {}, r2, e2.availableImages) : void 0, d2 = { id: l2, properties: u2.properties, type: u2.type, sourceLayerIndex: c2, index: p2, geometry: h2 ? f2.geometry : Ra(u2), patterns: {}, sortKey: y2 };
              i3.push(d2);
            }
          }
          n2 && i3.sort(function(t5, e3) {
            return t5.sortKey - e3.sortKey;
          });
          for (var m2 = 0, v2 = i3; m2 < v2.length; m2 += 1) {
            var g2 = v2[m2], x3 = g2.geometry, b2 = g2.index, w2 = g2.sourceLayerIndex;
            if (this.hasPattern) {
              var _2 = os("fill", this.layers, g2, this.zoom, e2);
              this.patternFeatures.push(_2);
            } else
              this.addFeature(g2, x3, b2, r2, {});
            e2.featureIndex.insert(t4[b2].feature, x3, b2, w2, this.index);
          }
        }, ss.prototype.update = function(t4, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t4, e2, this.stateDependentLayers, r2);
        }, ss.prototype.addFeatures = function(t4, e2, r2) {
          for (var n2 = 0, i3 = this.patternFeatures; n2 < i3.length; n2 += 1) {
            var a2 = i3[n2];
            this.addFeature(a2, a2.geometry, a2.index, e2, r2);
          }
        }, ss.prototype.isEmpty = function() {
          return 0 === this.layoutVertexArray.length;
        }, ss.prototype.uploadPending = function() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }, ss.prototype.upload = function(t4) {
          this.uploaded || (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, ko), this.indexBuffer = t4.createIndexBuffer(this.indexArray), this.indexBuffer2 = t4.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t4), this.uploaded = true;
        }, ss.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }, ss.prototype.addFeature = function(t4, e2, r2, n2, i3) {
          for (var a2 = 0, o2 = ns(e2, 500); a2 < o2.length; a2 += 1) {
            for (var s2 = o2[a2], u2 = 0, l2 = 0, p2 = s2; l2 < p2.length; l2 += 1)
              u2 += p2[l2].length;
            for (var c2 = this.segments.prepareSegment(u2, this.layoutVertexArray, this.indexArray), h2 = c2.vertexLength, f2 = [], y2 = [], d2 = 0, m2 = s2; d2 < m2.length; d2 += 1) {
              var v2 = m2[d2];
              if (0 !== v2.length) {
                v2 !== s2[0] && y2.push(f2.length / 2);
                var g2 = this.segments2.prepareSegment(v2.length, this.layoutVertexArray, this.indexArray2), x3 = g2.vertexLength;
                this.layoutVertexArray.emplaceBack(v2[0].x, v2[0].y), this.indexArray2.emplaceBack(x3 + v2.length - 1, x3), f2.push(v2[0].x), f2.push(v2[0].y);
                for (var b2 = 1; b2 < v2.length; b2++)
                  this.layoutVertexArray.emplaceBack(v2[b2].x, v2[b2].y), this.indexArray2.emplaceBack(x3 + b2 - 1, x3 + b2), f2.push(v2[b2].x), f2.push(v2[b2].y);
                g2.vertexLength += v2.length, g2.primitiveLength += v2.length;
              }
            }
            for (var w2 = Io(f2, y2), _2 = 0; _2 < w2.length; _2 += 3)
              this.indexArray.emplaceBack(h2 + w2[_2], h2 + w2[_2 + 1], h2 + w2[_2 + 2]);
            c2.vertexLength += u2, c2.primitiveLength += w2.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r2, i3, n2);
        }, On("FillBucket", ss, { omit: ["layers", "patternFeatures"] });
        var us = new wi({ "fill-sort-key": new vi(Et.layout_fill["fill-sort-key"]) }), ls = { paint: new wi({ "fill-antialias": new mi(Et.paint_fill["fill-antialias"]), "fill-opacity": new vi(Et.paint_fill["fill-opacity"]), "fill-color": new vi(Et.paint_fill["fill-color"]), "fill-outline-color": new vi(Et.paint_fill["fill-outline-color"]), "fill-translate": new mi(Et.paint_fill["fill-translate"]), "fill-translate-anchor": new mi(Et.paint_fill["fill-translate-anchor"]), "fill-pattern": new gi(Et.paint_fill["fill-pattern"]) }), layout: us }, ps = function(t4) {
          function e2(e3) {
            t4.call(this, e3, ls);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.recalculate = function(e3, r2) {
            t4.prototype.recalculate.call(this, e3, r2);
            var n2 = this.paint._values["fill-outline-color"];
            "constant" === n2.value.kind && void 0 === n2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }, e2.prototype.createBucket = function(t5) {
            return new ss(t5);
          }, e2.prototype.queryRadius = function() {
            return eo(this.paint.get("fill-translate"));
          }, e2.prototype.queryIntersectsFeature = function(t5, e3, r2, n2, i3, a2, o2) {
            return Ga(ro(t5, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a2.angle, o2), n2);
          }, e2.prototype.isTileClipped = function() {
            return true;
          }, e2;
        }(_i), cs = Ii([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4).members, hs = fs;
        function fs(t4, e2, r2, n2, i3) {
          this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t4, this._geometry = -1, this._keys = n2, this._values = i3, t4.readFields(ys, this, e2);
        }
        function ys(t4, e2, r2) {
          1 == t4 ? e2.id = r2.readVarint() : 2 == t4 ? function(t5, e3) {
            for (var r3 = t5.readVarint() + t5.pos; t5.pos < r3; ) {
              var n2 = e3._keys[t5.readVarint()], i3 = e3._values[t5.readVarint()];
              e3.properties[n2] = i3;
            }
          }(r2, e2) : 3 == t4 ? e2.type = r2.readVarint() : 4 == t4 && (e2._geometry = r2.pos);
        }
        function ds(t4) {
          for (var e2, r2, n2 = 0, i3 = 0, a2 = t4.length, o2 = a2 - 1; i3 < a2; o2 = i3++)
            n2 += ((r2 = t4[o2]).x - (e2 = t4[i3]).x) * (e2.y + r2.y);
          return n2;
        }
        fs.types = ["Unknown", "Point", "LineString", "Polygon"], fs.prototype.loadGeometry = function() {
          var t4 = this._pbf;
          t4.pos = this._geometry;
          for (var e2, r2 = t4.readVarint() + t4.pos, n2 = 1, a2 = 0, o2 = 0, s2 = 0, u2 = []; t4.pos < r2; ) {
            if (a2 <= 0) {
              var l2 = t4.readVarint();
              n2 = 7 & l2, a2 = l2 >> 3;
            }
            if (a2--, 1 === n2 || 2 === n2)
              o2 += t4.readSVarint(), s2 += t4.readSVarint(), 1 === n2 && (e2 && u2.push(e2), e2 = []), e2.push(new i2(o2, s2));
            else {
              if (7 !== n2)
                throw new Error("unknown command " + n2);
              e2 && e2.push(e2[0].clone());
            }
          }
          return e2 && u2.push(e2), u2;
        }, fs.prototype.bbox = function() {
          var t4 = this._pbf;
          t4.pos = this._geometry;
          for (var e2 = t4.readVarint() + t4.pos, r2 = 1, n2 = 0, i3 = 0, a2 = 0, o2 = 1 / 0, s2 = -1 / 0, u2 = 1 / 0, l2 = -1 / 0; t4.pos < e2; ) {
            if (n2 <= 0) {
              var p2 = t4.readVarint();
              r2 = 7 & p2, n2 = p2 >> 3;
            }
            if (n2--, 1 === r2 || 2 === r2)
              (i3 += t4.readSVarint()) < o2 && (o2 = i3), i3 > s2 && (s2 = i3), (a2 += t4.readSVarint()) < u2 && (u2 = a2), a2 > l2 && (l2 = a2);
            else if (7 !== r2)
              throw new Error("unknown command " + r2);
          }
          return [o2, u2, s2, l2];
        }, fs.prototype.toGeoJSON = function(t4, e2, r2) {
          var n2, i3, a2 = this.extent * Math.pow(2, r2), o2 = this.extent * t4, s2 = this.extent * e2, u2 = this.loadGeometry(), l2 = fs.types[this.type];
          function p2(t5) {
            for (var e3 = 0; e3 < t5.length; e3++) {
              var r3 = t5[e3];
              t5[e3] = [360 * (r3.x + o2) / a2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + s2) / a2) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var c2 = [];
              for (n2 = 0; n2 < u2.length; n2++)
                c2[n2] = u2[n2][0];
              p2(u2 = c2);
              break;
            case 2:
              for (n2 = 0; n2 < u2.length; n2++)
                p2(u2[n2]);
              break;
            case 3:
              for (u2 = function(t5) {
                var e3 = t5.length;
                if (e3 <= 1)
                  return [t5];
                for (var r3, n3, i4 = [], a3 = 0; a3 < e3; a3++) {
                  var o3 = ds(t5[a3]);
                  0 !== o3 && (void 0 === n3 && (n3 = o3 < 0), n3 === o3 < 0 ? (r3 && i4.push(r3), r3 = [t5[a3]]) : r3.push(t5[a3]));
                }
                return r3 && i4.push(r3), i4;
              }(u2), n2 = 0; n2 < u2.length; n2++)
                for (i3 = 0; i3 < u2[n2].length; i3++)
                  p2(u2[n2][i3]);
          }
          1 === u2.length ? u2 = u2[0] : l2 = "Multi" + l2;
          var h2 = { type: "Feature", geometry: { type: l2, coordinates: u2 }, properties: this.properties };
          return "id" in this && (h2.id = this.id), h2;
        };
        var ms = vs;
        function vs(t4, e2) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t4, this._keys = [], this._values = [], this._features = [], t4.readFields(gs, this, e2), this.length = this._features.length;
        }
        function gs(t4, e2, r2) {
          15 === t4 ? e2.version = r2.readVarint() : 1 === t4 ? e2.name = r2.readString() : 5 === t4 ? e2.extent = r2.readVarint() : 2 === t4 ? e2._features.push(r2.pos) : 3 === t4 ? e2._keys.push(r2.readString()) : 4 === t4 && e2._values.push(function(t5) {
            for (var e3 = null, r3 = t5.readVarint() + t5.pos; t5.pos < r3; ) {
              var n2 = t5.readVarint() >> 3;
              e3 = 1 === n2 ? t5.readString() : 2 === n2 ? t5.readFloat() : 3 === n2 ? t5.readDouble() : 4 === n2 ? t5.readVarint64() : 5 === n2 ? t5.readVarint() : 6 === n2 ? t5.readSVarint() : 7 === n2 ? t5.readBoolean() : null;
            }
            return e3;
          }(r2));
        }
        function xs(t4, e2, r2) {
          if (3 === t4) {
            var n2 = new ms(r2, r2.readVarint() + r2.pos);
            n2.length && (e2[n2.name] = n2);
          }
        }
        vs.prototype.feature = function(t4) {
          if (t4 < 0 || t4 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t4];
          var e2 = this._pbf.readVarint() + this._pbf.pos;
          return new hs(this._pbf, e2, this.extent, this._keys, this._values);
        };
        var bs = { VectorTile: function(t4, e2) {
          this.layers = t4.readFields(xs, {}, e2);
        }, VectorTileFeature: hs, VectorTileLayer: ms }, ws = bs.VectorTileFeature.types, _s = Math.pow(2, 13);
        function As(t4, e2, r2, n2, i3, a2, o2, s2) {
          t4.emplaceBack(e2, r2, 2 * Math.floor(n2 * _s) + o2, i3 * _s * 2, a2 * _s * 2, Math.round(s2));
        }
        var Ss = function(t4) {
          this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map(function(t5) {
            return t5.id;
          }), this.index = t4.index, this.hasPattern = false, this.layoutVertexArray = new Pi(), this.indexArray = new ji(), this.programConfigurations = new Va(t4.layers, t4.zoom), this.segments = new sa(), this.stateDependentLayerIds = this.layers.filter(function(t5) {
            return t5.isStateDependent();
          }).map(function(t5) {
            return t5.id;
          });
        };
        function ks(t4, e2) {
          return t4.x === e2.x && (t4.x < 0 || t4.x > 8192) || t4.y === e2.y && (t4.y < 0 || t4.y > 8192);
        }
        Ss.prototype.populate = function(t4, e2, r2) {
          this.features = [], this.hasPattern = as("fill-extrusion", this.layers, e2);
          for (var n2 = 0, i3 = t4; n2 < i3.length; n2 += 1) {
            var a2 = i3[n2], o2 = a2.feature, s2 = a2.id, u2 = a2.index, l2 = a2.sourceLayerIndex, p2 = this.layers[0]._featureFilter.needGeometry, c2 = Ua(o2, p2);
            if (this.layers[0]._featureFilter.filter(new si(this.zoom), c2, r2)) {
              var h2 = { id: s2, sourceLayerIndex: l2, index: u2, geometry: p2 ? c2.geometry : Ra(o2), properties: o2.properties, type: o2.type, patterns: {} };
              this.hasPattern ? this.features.push(os("fill-extrusion", this.layers, h2, this.zoom, e2)) : this.addFeature(h2, h2.geometry, u2, r2, {}), e2.featureIndex.insert(o2, h2.geometry, u2, l2, this.index, true);
            }
          }
        }, Ss.prototype.addFeatures = function(t4, e2, r2) {
          for (var n2 = 0, i3 = this.features; n2 < i3.length; n2 += 1) {
            var a2 = i3[n2];
            this.addFeature(a2, a2.geometry, a2.index, e2, r2);
          }
        }, Ss.prototype.update = function(t4, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t4, e2, this.stateDependentLayers, r2);
        }, Ss.prototype.isEmpty = function() {
          return 0 === this.layoutVertexArray.length;
        }, Ss.prototype.uploadPending = function() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }, Ss.prototype.upload = function(t4) {
          this.uploaded || (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, cs), this.indexBuffer = t4.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t4), this.uploaded = true;
        }, Ss.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }, Ss.prototype.addFeature = function(t4, e2, r2, n2, i3) {
          for (var a2 = 0, o2 = ns(e2, 500); a2 < o2.length; a2 += 1) {
            for (var s2 = o2[a2], u2 = 0, l2 = 0, p2 = s2; l2 < p2.length; l2 += 1)
              u2 += p2[l2].length;
            for (var c2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), h2 = 0, f2 = s2; h2 < f2.length; h2 += 1) {
              var y2 = f2[h2];
              if (0 !== y2.length && !((B3 = y2).every(function(t5) {
                return t5.x < 0;
              }) || B3.every(function(t5) {
                return t5.x > 8192;
              }) || B3.every(function(t5) {
                return t5.y < 0;
              }) || B3.every(function(t5) {
                return t5.y > 8192;
              })))
                for (var d2 = 0, m2 = 0; m2 < y2.length; m2++) {
                  var v2 = y2[m2];
                  if (m2 >= 1) {
                    var g2 = y2[m2 - 1];
                    if (!ks(v2, g2)) {
                      c2.vertexLength + 4 > sa.MAX_VERTEX_ARRAY_LENGTH && (c2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                      var x3 = v2.sub(g2)._perp()._unit(), b2 = g2.dist(v2);
                      d2 + b2 > 32768 && (d2 = 0), As(this.layoutVertexArray, v2.x, v2.y, x3.x, x3.y, 0, 0, d2), As(this.layoutVertexArray, v2.x, v2.y, x3.x, x3.y, 0, 1, d2), As(this.layoutVertexArray, g2.x, g2.y, x3.x, x3.y, 0, 0, d2 += b2), As(this.layoutVertexArray, g2.x, g2.y, x3.x, x3.y, 0, 1, d2);
                      var w2 = c2.vertexLength;
                      this.indexArray.emplaceBack(w2, w2 + 2, w2 + 1), this.indexArray.emplaceBack(w2 + 1, w2 + 2, w2 + 3), c2.vertexLength += 4, c2.primitiveLength += 2;
                    }
                  }
                }
            }
            if (c2.vertexLength + u2 > sa.MAX_VERTEX_ARRAY_LENGTH && (c2 = this.segments.prepareSegment(u2, this.layoutVertexArray, this.indexArray)), "Polygon" === ws[t4.type]) {
              for (var _2 = [], A3 = [], S2 = c2.vertexLength, k2 = 0, I2 = s2; k2 < I2.length; k2 += 1) {
                var z2 = I2[k2];
                if (0 !== z2.length) {
                  z2 !== s2[0] && A3.push(_2.length / 2);
                  for (var C3 = 0; C3 < z2.length; C3++) {
                    var E3 = z2[C3];
                    As(this.layoutVertexArray, E3.x, E3.y, 0, 0, 1, 1, 0), _2.push(E3.x), _2.push(E3.y);
                  }
                }
              }
              for (var P2 = Io(_2, A3), M2 = 0; M2 < P2.length; M2 += 3)
                this.indexArray.emplaceBack(S2 + P2[M2], S2 + P2[M2 + 2], S2 + P2[M2 + 1]);
              c2.primitiveLength += P2.length / 3, c2.vertexLength += u2;
            }
          }
          var B3;
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r2, i3, n2);
        }, On("FillExtrusionBucket", Ss, { omit: ["layers", "features"] });
        var Is = { paint: new wi({ "fill-extrusion-opacity": new mi(Et["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new vi(Et["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new mi(Et["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new mi(Et["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new gi(Et["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new vi(Et["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new vi(Et["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new mi(Et["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) }, zs = function(t4) {
          function e2(e3) {
            t4.call(this, e3, Is);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.createBucket = function(t5) {
            return new Ss(t5);
          }, e2.prototype.queryRadius = function() {
            return eo(this.paint.get("fill-extrusion-translate"));
          }, e2.prototype.is3D = function() {
            return true;
          }, e2.prototype.queryIntersectsFeature = function(t5, e3, r2, n2, a2, o2, s2, u2) {
            var l2 = ro(t5, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o2.angle, s2), p2 = this.paint.get("fill-extrusion-height").evaluate(e3, r2), c2 = this.paint.get("fill-extrusion-base").evaluate(e3, r2), h2 = function(t6, e4, r3, n3) {
              for (var a3 = [], o3 = 0, s3 = t6; o3 < s3.length; o3 += 1) {
                var u3 = s3[o3], l3 = [u3.x, u3.y, 0, 1];
                po(l3, l3, e4), a3.push(new i2(l3[0] / l3[3], l3[1] / l3[3]));
              }
              return a3;
            }(l2, u2), f2 = function(t6, e4, r3, n3) {
              for (var a3 = [], o3 = [], s3 = n3[8] * e4, u3 = n3[9] * e4, l3 = n3[10] * e4, p3 = n3[11] * e4, c3 = n3[8] * r3, h3 = n3[9] * r3, f3 = n3[10] * r3, y2 = n3[11] * r3, d2 = 0, m2 = t6; d2 < m2.length; d2 += 1) {
                for (var v2 = [], g2 = [], x3 = 0, b2 = m2[d2]; x3 < b2.length; x3 += 1) {
                  var w2 = b2[x3], _2 = w2.x, A3 = w2.y, S2 = n3[0] * _2 + n3[4] * A3 + n3[12], k2 = n3[1] * _2 + n3[5] * A3 + n3[13], I2 = n3[2] * _2 + n3[6] * A3 + n3[14], z2 = n3[3] * _2 + n3[7] * A3 + n3[15], C3 = I2 + l3, E3 = z2 + p3, P2 = S2 + c3, M2 = k2 + h3, B3 = I2 + f3, T3 = z2 + y2, V2 = new i2((S2 + s3) / E3, (k2 + u3) / E3);
                  V2.z = C3 / E3, v2.push(V2);
                  var F2 = new i2(P2 / T3, M2 / T3);
                  F2.z = B3 / T3, g2.push(F2);
                }
                a3.push(v2), o3.push(g2);
              }
              return [a3, o3];
            }(n2, c2, p2, u2);
            return function(t6, e4, r3) {
              var n3 = 1 / 0;
              Ga(r3, e4) && (n3 = Es(r3, e4[0]));
              for (var i3 = 0; i3 < e4.length; i3++)
                for (var a3 = e4[i3], o3 = t6[i3], s3 = 0; s3 < a3.length - 1; s3++) {
                  var u3 = a3[s3], l3 = [u3, a3[s3 + 1], o3[s3 + 1], o3[s3], u3];
                  Na(r3, l3) && (n3 = Math.min(n3, Es(r3, l3)));
                }
              return n3 !== 1 / 0 && n3;
            }(f2[0], f2[1], h2);
          }, e2;
        }(_i);
        function Cs(t4, e2) {
          return t4.x * e2.x + t4.y * e2.y;
        }
        function Es(t4, e2) {
          if (1 === t4.length) {
            for (var r2, n2 = 0, i3 = e2[n2++]; !r2 || i3.equals(r2); )
              if (!(r2 = e2[n2++]))
                return 1 / 0;
            for (; n2 < e2.length; n2++) {
              var a2 = e2[n2], o2 = t4[0], s2 = r2.sub(i3), u2 = a2.sub(i3), l2 = o2.sub(i3), p2 = Cs(s2, s2), c2 = Cs(s2, u2), h2 = Cs(u2, u2), f2 = Cs(l2, s2), y2 = Cs(l2, u2), d2 = p2 * h2 - c2 * c2, m2 = (h2 * f2 - c2 * y2) / d2, v2 = (p2 * y2 - c2 * f2) / d2, g2 = i3.z * (1 - m2 - v2) + r2.z * m2 + a2.z * v2;
              if (isFinite(g2))
                return g2;
            }
            return 1 / 0;
          }
          for (var x3 = 1 / 0, b2 = 0, w2 = e2; b2 < w2.length; b2 += 1)
            x3 = Math.min(x3, w2[b2].z);
          return x3;
        }
        var Ps = Ii([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4).members, Ms = Ii([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]).members, Bs = bs.VectorTileFeature.types, Ts = Math.cos(Math.PI / 180 * 37.5), Vs = Math.pow(2, 14) / 0.5, Fs = function(t4) {
          var e2 = this;
          this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map(function(t5) {
            return t5.id;
          }), this.index = t4.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(function(t5) {
            e2.gradients[t5.id] = {};
          }), this.layoutVertexArray = new Mi(), this.layoutVertexArray2 = new Bi(), this.indexArray = new ji(), this.programConfigurations = new Va(t4.layers, t4.zoom), this.segments = new sa(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(function(t5) {
            return t5.isStateDependent();
          }).map(function(t5) {
            return t5.id;
          });
        };
        Fs.prototype.populate = function(t4, e2, r2) {
          this.hasPattern = as("line", this.layers, e2);
          for (var n2 = this.layers[0].layout.get("line-sort-key"), i3 = [], a2 = 0, o2 = t4; a2 < o2.length; a2 += 1) {
            var s2 = o2[a2], u2 = s2.feature, l2 = s2.id, p2 = s2.index, c2 = s2.sourceLayerIndex, h2 = this.layers[0]._featureFilter.needGeometry, f2 = Ua(u2, h2);
            if (this.layers[0]._featureFilter.filter(new si(this.zoom), f2, r2)) {
              var y2 = n2 ? n2.evaluate(f2, {}, r2) : void 0, d2 = { id: l2, properties: u2.properties, type: u2.type, sourceLayerIndex: c2, index: p2, geometry: h2 ? f2.geometry : Ra(u2), patterns: {}, sortKey: y2 };
              i3.push(d2);
            }
          }
          n2 && i3.sort(function(t5, e3) {
            return t5.sortKey - e3.sortKey;
          });
          for (var m2 = 0, v2 = i3; m2 < v2.length; m2 += 1) {
            var g2 = v2[m2], x3 = g2.geometry, b2 = g2.index, w2 = g2.sourceLayerIndex;
            if (this.hasPattern) {
              var _2 = os("line", this.layers, g2, this.zoom, e2);
              this.patternFeatures.push(_2);
            } else
              this.addFeature(g2, x3, b2, r2, {});
            e2.featureIndex.insert(t4[b2].feature, x3, b2, w2, this.index);
          }
        }, Fs.prototype.update = function(t4, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t4, e2, this.stateDependentLayers, r2);
        }, Fs.prototype.addFeatures = function(t4, e2, r2) {
          for (var n2 = 0, i3 = this.patternFeatures; n2 < i3.length; n2 += 1) {
            var a2 = i3[n2];
            this.addFeature(a2, a2.geometry, a2.index, e2, r2);
          }
        }, Fs.prototype.isEmpty = function() {
          return 0 === this.layoutVertexArray.length;
        }, Fs.prototype.uploadPending = function() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }, Fs.prototype.upload = function(t4) {
          this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t4.createVertexBuffer(this.layoutVertexArray2, Ms)), this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, Ps), this.indexBuffer = t4.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t4), this.uploaded = true;
        }, Fs.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }, Fs.prototype.lineFeatureClips = function(t4) {
          if (t4.properties && t4.properties.hasOwnProperty("mapbox_clip_start") && t4.properties.hasOwnProperty("mapbox_clip_end"))
            return { start: +t4.properties.mapbox_clip_start, end: +t4.properties.mapbox_clip_end };
        }, Fs.prototype.addFeature = function(t4, e2, r2, n2, i3) {
          var a2 = this.layers[0].layout, o2 = a2.get("line-join").evaluate(t4, {}), s2 = a2.get("line-cap"), u2 = a2.get("line-miter-limit"), l2 = a2.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t4);
          for (var p2 = 0, c2 = e2; p2 < c2.length; p2 += 1)
            this.addLine(c2[p2], t4, o2, s2, u2, l2);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r2, i3, n2);
        }, Fs.prototype.addLine = function(t4, e2, r2, n2, i3, a2) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (var o2 = 0; o2 < t4.length - 1; o2++)
              this.totalDistance += t4[o2].dist(t4[o2 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          for (var s2 = "Polygon" === Bs[e2.type], u2 = t4.length; u2 >= 2 && t4[u2 - 1].equals(t4[u2 - 2]); )
            u2--;
          for (var l2 = 0; l2 < u2 - 1 && t4[l2].equals(t4[l2 + 1]); )
            l2++;
          if (!(u2 < (s2 ? 3 : 2))) {
            "bevel" === r2 && (i3 = 1.05);
            var p2, c2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, h2 = this.segments.prepareSegment(10 * u2, this.layoutVertexArray, this.indexArray), f2 = void 0, y2 = void 0, d2 = void 0, m2 = void 0;
            this.e1 = this.e2 = -1, s2 && (m2 = t4[l2].sub(p2 = t4[u2 - 2])._unit()._perp());
            for (var v2 = l2; v2 < u2; v2++)
              if (!(y2 = v2 === u2 - 1 ? s2 ? t4[l2 + 1] : void 0 : t4[v2 + 1]) || !t4[v2].equals(y2)) {
                m2 && (d2 = m2), p2 && (f2 = p2), p2 = t4[v2], m2 = y2 ? y2.sub(p2)._unit()._perp() : d2;
                var g2 = (d2 = d2 || m2).add(m2);
                0 === g2.x && 0 === g2.y || g2._unit();
                var x3 = d2.x * m2.x + d2.y * m2.y, b2 = g2.x * m2.x + g2.y * m2.y, w2 = 0 !== b2 ? 1 / b2 : 1 / 0, _2 = 2 * Math.sqrt(2 - 2 * b2), A3 = b2 < Ts && f2 && y2, S2 = d2.x * m2.y - d2.y * m2.x > 0;
                if (A3 && v2 > l2) {
                  var k2 = p2.dist(f2);
                  if (k2 > 2 * c2) {
                    var I2 = p2.sub(p2.sub(f2)._mult(c2 / k2)._round());
                    this.updateDistance(f2, I2), this.addCurrentVertex(I2, d2, 0, 0, h2), f2 = I2;
                  }
                }
                var z2 = f2 && y2, C3 = z2 ? r2 : s2 ? "butt" : n2;
                if (z2 && "round" === C3 && (w2 < a2 ? C3 = "miter" : w2 <= 2 && (C3 = "fakeround")), "miter" === C3 && w2 > i3 && (C3 = "bevel"), "bevel" === C3 && (w2 > 2 && (C3 = "flipbevel"), w2 < i3 && (C3 = "miter")), f2 && this.updateDistance(f2, p2), "miter" === C3)
                  g2._mult(w2), this.addCurrentVertex(p2, g2, 0, 0, h2);
                else if ("flipbevel" === C3) {
                  if (w2 > 100)
                    g2 = m2.mult(-1);
                  else {
                    var E3 = w2 * d2.add(m2).mag() / d2.sub(m2).mag();
                    g2._perp()._mult(E3 * (S2 ? -1 : 1));
                  }
                  this.addCurrentVertex(p2, g2, 0, 0, h2), this.addCurrentVertex(p2, g2.mult(-1), 0, 0, h2);
                } else if ("bevel" === C3 || "fakeround" === C3) {
                  var P2 = -Math.sqrt(w2 * w2 - 1), M2 = S2 ? P2 : 0, B3 = S2 ? 0 : P2;
                  if (f2 && this.addCurrentVertex(p2, d2, M2, B3, h2), "fakeround" === C3)
                    for (var T3 = Math.round(180 * _2 / Math.PI / 20), V2 = 1; V2 < T3; V2++) {
                      var F2 = V2 / T3;
                      if (0.5 !== F2) {
                        var D3 = F2 - 0.5;
                        F2 += F2 * D3 * (F2 - 1) * ((1.0904 + x3 * (x3 * (3.55645 - 1.43519 * x3) - 3.2452)) * D3 * D3 + (0.848013 + x3 * (0.215638 * x3 - 1.06021)));
                      }
                      var L3 = m2.sub(d2)._mult(F2)._add(d2)._unit()._mult(S2 ? -1 : 1);
                      this.addHalfVertex(p2, L3.x, L3.y, false, S2, 0, h2);
                    }
                  y2 && this.addCurrentVertex(p2, m2, -M2, -B3, h2);
                } else if ("butt" === C3)
                  this.addCurrentVertex(p2, g2, 0, 0, h2);
                else if ("square" === C3) {
                  var O2 = f2 ? 1 : -1;
                  this.addCurrentVertex(p2, g2, O2, O2, h2);
                } else
                  "round" === C3 && (f2 && (this.addCurrentVertex(p2, d2, 0, 0, h2), this.addCurrentVertex(p2, d2, 1, 1, h2, true)), y2 && (this.addCurrentVertex(p2, m2, -1, -1, h2, true), this.addCurrentVertex(p2, m2, 0, 0, h2)));
                if (A3 && v2 < u2 - 1) {
                  var R2 = p2.dist(y2);
                  if (R2 > 2 * c2) {
                    var U2 = p2.add(y2.sub(p2)._mult(c2 / R2)._round());
                    this.updateDistance(p2, U2), this.addCurrentVertex(U2, m2, 0, 0, h2), p2 = U2;
                  }
                }
              }
          }
        }, Fs.prototype.addCurrentVertex = function(t4, e2, r2, n2, i3, a2) {
          void 0 === a2 && (a2 = false);
          var o2 = e2.y * n2 - e2.x, s2 = -e2.y - e2.x * n2;
          this.addHalfVertex(t4, e2.x + e2.y * r2, e2.y - e2.x * r2, a2, false, r2, i3), this.addHalfVertex(t4, o2, s2, a2, true, -n2, i3), this.distance > Vs / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t4, e2, r2, n2, i3, a2));
        }, Fs.prototype.addHalfVertex = function(t4, e2, r2, n2, i3, a2, o2) {
          var s2 = 0.5 * (this.lineClips ? this.scaledDistance * (Vs - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((t4.x << 1) + (n2 ? 1 : 0), (t4.y << 1) + (i3 ? 1 : 0), Math.round(63 * e2) + 128, Math.round(63 * r2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1) | (63 & s2) << 2, s2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          var u2 = o2.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), i3 ? this.e2 = u2 : this.e1 = u2;
        }, Fs.prototype.updateScaledDistance = function() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }, Fs.prototype.updateDistance = function(t4, e2) {
          this.distance += t4.dist(e2), this.updateScaledDistance();
        }, On("LineBucket", Fs, { omit: ["layers", "patternFeatures"] });
        var Ds = new wi({ "line-cap": new mi(Et.layout_line["line-cap"]), "line-join": new vi(Et.layout_line["line-join"]), "line-miter-limit": new mi(Et.layout_line["line-miter-limit"]), "line-round-limit": new mi(Et.layout_line["line-round-limit"]), "line-sort-key": new vi(Et.layout_line["line-sort-key"]) }), Ls = { paint: new wi({ "line-opacity": new vi(Et.paint_line["line-opacity"]), "line-color": new vi(Et.paint_line["line-color"]), "line-translate": new mi(Et.paint_line["line-translate"]), "line-translate-anchor": new mi(Et.paint_line["line-translate-anchor"]), "line-width": new vi(Et.paint_line["line-width"]), "line-gap-width": new vi(Et.paint_line["line-gap-width"]), "line-offset": new vi(Et.paint_line["line-offset"]), "line-blur": new vi(Et.paint_line["line-blur"]), "line-dasharray": new xi(Et.paint_line["line-dasharray"]), "line-pattern": new gi(Et.paint_line["line-pattern"]), "line-gradient": new bi(Et.paint_line["line-gradient"]) }), layout: Ds }, Os = new (function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.possiblyEvaluate = function(e3, r2) {
            return r2 = new si(Math.floor(r2.zoom), { now: r2.now, fadeDuration: r2.fadeDuration, zoomHistory: r2.zoomHistory, transition: r2.transition }), t4.prototype.possiblyEvaluate.call(this, e3, r2);
          }, e2.prototype.evaluate = function(e3, r2, n2, i3) {
            return r2 = h({}, r2, { zoom: Math.floor(r2.zoom) }), t4.prototype.evaluate.call(this, e3, r2, n2, i3);
          }, e2;
        }(vi))(Ls.paint.properties["line-width"].specification);
        Os.useIntegerZoom = true;
        var Rs = function(t4) {
          function e2(e3) {
            t4.call(this, e3, Ls), this.gradientVersion = 0;
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._handleSpecialPaintPropertyUpdate = function(t5) {
            "line-gradient" === t5 && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof Ne, this.gradientVersion = (this.gradientVersion + 1) % s);
          }, e2.prototype.gradientExpression = function() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }, e2.prototype.recalculate = function(e3, r2) {
            t4.prototype.recalculate.call(this, e3, r2), this.paint._values["line-floorwidth"] = Os.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e3);
          }, e2.prototype.createBucket = function(t5) {
            return new Fs(t5);
          }, e2.prototype.queryRadius = function(t5) {
            var e3 = t5, r2 = Us(to("line-width", this, e3), to("line-gap-width", this, e3)), n2 = to("line-offset", this, e3);
            return r2 / 2 + Math.abs(n2) + eo(this.paint.get("line-translate"));
          }, e2.prototype.queryIntersectsFeature = function(t5, e3, r2, n2, a2, o2, s2) {
            var u2 = ro(t5, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o2.angle, s2), l2 = s2 / 2 * Us(this.paint.get("line-width").evaluate(e3, r2), this.paint.get("line-gap-width").evaluate(e3, r2)), p2 = this.paint.get("line-offset").evaluate(e3, r2);
            return p2 && (n2 = function(t6, e4) {
              for (var r3 = [], n3 = new i2(0, 0), a3 = 0; a3 < t6.length; a3++) {
                for (var o3 = t6[a3], s3 = [], u3 = 0; u3 < o3.length; u3++) {
                  var l3 = o3[u3], p3 = o3[u3 + 1], c2 = 0 === u3 ? n3 : l3.sub(o3[u3 - 1])._unit()._perp(), h2 = u3 === o3.length - 1 ? n3 : p3.sub(l3)._unit()._perp(), f2 = c2._add(h2)._unit();
                  f2._mult(1 / (f2.x * h2.x + f2.y * h2.y)), s3.push(f2._mult(e4)._add(l3));
                }
                r3.push(s3);
              }
              return r3;
            }(n2, p2 * s2)), function(t6, e4, r3) {
              for (var n3 = 0; n3 < e4.length; n3++) {
                var i3 = e4[n3];
                if (t6.length >= 3) {
                  for (var a3 = 0; a3 < i3.length; a3++)
                    if (Wa(t6, i3[a3]))
                      return true;
                }
                if (Za(t6, i3, r3))
                  return true;
              }
              return false;
            }(u2, n2, l2);
          }, e2.prototype.isTileClipped = function() {
            return true;
          }, e2;
        }(_i);
        function Us(t4, e2) {
          return e2 > 0 ? e2 + 2 * t4 : t4;
        }
        var js = Ii([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), qs = Ii([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4), Ns = (Ii([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4), Ii([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }])), Ks = (Ii([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]), Ii([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4)), Gs = Ii([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function Zs(t4, e2, r2) {
          return t4.sections.forEach(function(t5) {
            t5.text = function(t6, e3, r3) {
              var n2 = e3.layout.get("text-transform").evaluate(r3, {});
              return "uppercase" === n2 ? t6 = t6.toLocaleUpperCase() : "lowercase" === n2 && (t6 = t6.toLocaleLowerCase()), oi.applyArabicShaping && (t6 = oi.applyArabicShaping(t6)), t6;
            }(t5.text, e2, r2);
          }), t4;
        }
        Ii([{ name: "triangle", components: 3, type: "Uint16" }]), Ii([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Ii([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), Ii([{ type: "Float32", name: "offsetX" }]), Ii([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
        var Xs = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" }, Js = function(t4, e2, r2, n2, i3) {
          var a2, o2, s2 = 8 * i3 - n2 - 1, u2 = (1 << s2) - 1, l2 = u2 >> 1, p2 = -7, c2 = r2 ? i3 - 1 : 0, h2 = r2 ? -1 : 1, f2 = t4[e2 + c2];
          for (c2 += h2, a2 = f2 & (1 << -p2) - 1, f2 >>= -p2, p2 += s2; p2 > 0; a2 = 256 * a2 + t4[e2 + c2], c2 += h2, p2 -= 8)
            ;
          for (o2 = a2 & (1 << -p2) - 1, a2 >>= -p2, p2 += n2; p2 > 0; o2 = 256 * o2 + t4[e2 + c2], c2 += h2, p2 -= 8)
            ;
          if (0 === a2)
            a2 = 1 - l2;
          else {
            if (a2 === u2)
              return o2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
            o2 += Math.pow(2, n2), a2 -= l2;
          }
          return (f2 ? -1 : 1) * o2 * Math.pow(2, a2 - n2);
        }, Hs = function(t4, e2, r2, n2, i3, a2) {
          var o2, s2, u2, l2 = 8 * a2 - i3 - 1, p2 = (1 << l2) - 1, c2 = p2 >> 1, h2 = 23 === i3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : a2 - 1, y2 = n2 ? 1 : -1, d2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
          for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (s2 = isNaN(e2) ? 1 : 0, o2 = p2) : (o2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (u2 = Math.pow(2, -o2)) < 1 && (o2--, u2 *= 2), (e2 += o2 + c2 >= 1 ? h2 / u2 : h2 * Math.pow(2, 1 - c2)) * u2 >= 2 && (o2++, u2 /= 2), o2 + c2 >= p2 ? (s2 = 0, o2 = p2) : o2 + c2 >= 1 ? (s2 = (e2 * u2 - 1) * Math.pow(2, i3), o2 += c2) : (s2 = e2 * Math.pow(2, c2 - 1) * Math.pow(2, i3), o2 = 0)); i3 >= 8; t4[r2 + f2] = 255 & s2, f2 += y2, s2 /= 256, i3 -= 8)
            ;
          for (o2 = o2 << i3 | s2, l2 += i3; l2 > 0; t4[r2 + f2] = 255 & o2, f2 += y2, o2 /= 256, l2 -= 8)
            ;
          t4[r2 + f2 - y2] |= 128 * d2;
        }, Ys = $s;
        function $s(t4) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t4) ? t4 : new Uint8Array(t4 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        $s.Varint = 0, $s.Fixed64 = 1, $s.Bytes = 2, $s.Fixed32 = 5;
        var Ws = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function Qs(t4) {
          return t4.type === $s.Bytes ? t4.readVarint() + t4.pos : t4.pos + 1;
        }
        function tu(t4, e2, r2) {
          return r2 ? 4294967296 * e2 + (t4 >>> 0) : 4294967296 * (e2 >>> 0) + (t4 >>> 0);
        }
        function eu(t4, e2, r2) {
          var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
          r2.realloc(n2);
          for (var i3 = r2.pos - 1; i3 >= t4; i3--)
            r2.buf[i3 + n2] = r2.buf[i3];
        }
        function ru(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeVarint(t4[r2]);
        }
        function nu(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeSVarint(t4[r2]);
        }
        function iu(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeFloat(t4[r2]);
        }
        function au(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeDouble(t4[r2]);
        }
        function ou(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeBoolean(t4[r2]);
        }
        function su(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeFixed32(t4[r2]);
        }
        function uu(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeSFixed32(t4[r2]);
        }
        function lu(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeFixed64(t4[r2]);
        }
        function pu(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeSFixed64(t4[r2]);
        }
        function cu(t4, e2) {
          return (t4[e2] | t4[e2 + 1] << 8 | t4[e2 + 2] << 16) + 16777216 * t4[e2 + 3];
        }
        function hu(t4, e2, r2) {
          t4[r2] = e2, t4[r2 + 1] = e2 >>> 8, t4[r2 + 2] = e2 >>> 16, t4[r2 + 3] = e2 >>> 24;
        }
        function fu(t4, e2) {
          return (t4[e2] | t4[e2 + 1] << 8 | t4[e2 + 2] << 16) + (t4[e2 + 3] << 24);
        }
        function yu(t4, e2, r2) {
          1 === t4 && r2.readMessage(du, e2);
        }
        function du(t4, e2, r2) {
          if (3 === t4) {
            var n2 = r2.readMessage(mu, {}), i3 = n2.width, a2 = n2.height, o2 = n2.left, s2 = n2.top, u2 = n2.advance;
            e2.push({ id: n2.id, bitmap: new go({ width: i3 + 6, height: a2 + 6 }, n2.bitmap), metrics: { width: i3, height: a2, left: o2, top: s2, advance: u2 } });
          }
        }
        function mu(t4, e2, r2) {
          1 === t4 ? e2.id = r2.readVarint() : 2 === t4 ? e2.bitmap = r2.readBytes() : 3 === t4 ? e2.width = r2.readVarint() : 4 === t4 ? e2.height = r2.readVarint() : 5 === t4 ? e2.left = r2.readSVarint() : 6 === t4 ? e2.top = r2.readSVarint() : 7 === t4 && (e2.advance = r2.readVarint());
        }
        function vu(t4) {
          for (var e2 = 0, r2 = 0, n2 = 0, i3 = t4; n2 < i3.length; n2 += 1) {
            var a2 = i3[n2];
            e2 += a2.w * a2.h, r2 = Math.max(r2, a2.w);
          }
          t4.sort(function(t5, e3) {
            return e3.h - t5.h;
          });
          for (var o2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }], s2 = 0, u2 = 0, l2 = 0, p2 = t4; l2 < p2.length; l2 += 1)
            for (var c2 = p2[l2], h2 = o2.length - 1; h2 >= 0; h2--) {
              var f2 = o2[h2];
              if (!(c2.w > f2.w || c2.h > f2.h)) {
                if (c2.x = f2.x, c2.y = f2.y, u2 = Math.max(u2, c2.y + c2.h), s2 = Math.max(s2, c2.x + c2.w), c2.w === f2.w && c2.h === f2.h) {
                  var y2 = o2.pop();
                  h2 < o2.length && (o2[h2] = y2);
                } else
                  c2.h === f2.h ? (f2.x += c2.w, f2.w -= c2.w) : c2.w === f2.w ? (f2.y += c2.h, f2.h -= c2.h) : (o2.push({ x: f2.x + c2.w, y: f2.y, w: f2.w - c2.w, h: c2.h }), f2.y += c2.h, f2.h -= c2.h);
                break;
              }
            }
          return { w: s2, h: u2, fill: e2 / (s2 * u2) || 0 };
        }
        $s.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t4, e2, r2) {
          for (r2 = r2 || this.length; this.pos < r2; ) {
            var n2 = this.readVarint(), i3 = n2 >> 3, a2 = this.pos;
            this.type = 7 & n2, t4(i3, e2, this), this.pos === a2 && this.skip(n2);
          }
          return e2;
        }, readMessage: function(t4, e2) {
          return this.readFields(t4, e2, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t4 = cu(this.buf, this.pos);
          return this.pos += 4, t4;
        }, readSFixed32: function() {
          var t4 = fu(this.buf, this.pos);
          return this.pos += 4, t4;
        }, readFixed64: function() {
          var t4 = cu(this.buf, this.pos) + 4294967296 * cu(this.buf, this.pos + 4);
          return this.pos += 8, t4;
        }, readSFixed64: function() {
          var t4 = cu(this.buf, this.pos) + 4294967296 * fu(this.buf, this.pos + 4);
          return this.pos += 8, t4;
        }, readFloat: function() {
          var t4 = Js(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t4;
        }, readDouble: function() {
          var t4 = Js(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t4;
        }, readVarint: function(t4) {
          var e2, r2, n2 = this.buf;
          return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t5, e3, r3) {
            var n3, i3, a2 = r3.buf;
            if (n3 = (112 & (i3 = a2[r3.pos++])) >> 4, i3 < 128)
              return tu(t5, n3, e3);
            if (n3 |= (127 & (i3 = a2[r3.pos++])) << 3, i3 < 128)
              return tu(t5, n3, e3);
            if (n3 |= (127 & (i3 = a2[r3.pos++])) << 10, i3 < 128)
              return tu(t5, n3, e3);
            if (n3 |= (127 & (i3 = a2[r3.pos++])) << 17, i3 < 128)
              return tu(t5, n3, e3);
            if (n3 |= (127 & (i3 = a2[r3.pos++])) << 24, i3 < 128)
              return tu(t5, n3, e3);
            if (n3 |= (1 & (i3 = a2[r3.pos++])) << 31, i3 < 128)
              return tu(t5, n3, e3);
            throw new Error("Expected varint not more than 10 bytes");
          }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t4, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t4 = this.readVarint();
          return t4 % 2 == 1 ? (t4 + 1) / -2 : t4 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t4 = this.readVarint() + this.pos, e2 = this.pos;
          return this.pos = t4, t4 - e2 >= 12 && Ws ? function(t5, e3, r2) {
            return Ws.decode(t5.subarray(e3, r2));
          }(this.buf, e2, t4) : function(t5, e3, r2) {
            for (var n2 = "", i3 = e3; i3 < r2; ) {
              var a2, o2, s2, u2 = t5[i3], l2 = null, p2 = u2 > 239 ? 4 : u2 > 223 ? 3 : u2 > 191 ? 2 : 1;
              if (i3 + p2 > r2)
                break;
              1 === p2 ? u2 < 128 && (l2 = u2) : 2 === p2 ? 128 == (192 & (a2 = t5[i3 + 1])) && (l2 = (31 & u2) << 6 | 63 & a2) <= 127 && (l2 = null) : 3 === p2 ? (o2 = t5[i3 + 2], 128 == (192 & (a2 = t5[i3 + 1])) && 128 == (192 & o2) && ((l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & o2) <= 2047 || l2 >= 55296 && l2 <= 57343) && (l2 = null)) : 4 === p2 && (o2 = t5[i3 + 2], s2 = t5[i3 + 3], 128 == (192 & (a2 = t5[i3 + 1])) && 128 == (192 & o2) && 128 == (192 & s2) && ((l2 = (15 & u2) << 18 | (63 & a2) << 12 | (63 & o2) << 6 | 63 & s2) <= 65535 || l2 >= 1114112) && (l2 = null)), null === l2 ? (l2 = 65533, p2 = 1) : l2 > 65535 && (l2 -= 65536, n2 += String.fromCharCode(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), n2 += String.fromCharCode(l2), i3 += p2;
            }
            return n2;
          }(this.buf, e2, t4);
        }, readBytes: function() {
          var t4 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t4);
          return this.pos = t4, e2;
        }, readPackedVarint: function(t4, e2) {
          if (this.type !== $s.Bytes)
            return t4.push(this.readVarint(e2));
          var r2 = Qs(this);
          for (t4 = t4 || []; this.pos < r2; )
            t4.push(this.readVarint(e2));
          return t4;
        }, readPackedSVarint: function(t4) {
          if (this.type !== $s.Bytes)
            return t4.push(this.readSVarint());
          var e2 = Qs(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readSVarint());
          return t4;
        }, readPackedBoolean: function(t4) {
          if (this.type !== $s.Bytes)
            return t4.push(this.readBoolean());
          var e2 = Qs(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readBoolean());
          return t4;
        }, readPackedFloat: function(t4) {
          if (this.type !== $s.Bytes)
            return t4.push(this.readFloat());
          var e2 = Qs(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readFloat());
          return t4;
        }, readPackedDouble: function(t4) {
          if (this.type !== $s.Bytes)
            return t4.push(this.readDouble());
          var e2 = Qs(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readDouble());
          return t4;
        }, readPackedFixed32: function(t4) {
          if (this.type !== $s.Bytes)
            return t4.push(this.readFixed32());
          var e2 = Qs(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readFixed32());
          return t4;
        }, readPackedSFixed32: function(t4) {
          if (this.type !== $s.Bytes)
            return t4.push(this.readSFixed32());
          var e2 = Qs(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readSFixed32());
          return t4;
        }, readPackedFixed64: function(t4) {
          if (this.type !== $s.Bytes)
            return t4.push(this.readFixed64());
          var e2 = Qs(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readFixed64());
          return t4;
        }, readPackedSFixed64: function(t4) {
          if (this.type !== $s.Bytes)
            return t4.push(this.readSFixed64());
          var e2 = Qs(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readSFixed64());
          return t4;
        }, skip: function(t4) {
          var e2 = 7 & t4;
          if (e2 === $s.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (e2 === $s.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (e2 === $s.Fixed32)
            this.pos += 4;
          else {
            if (e2 !== $s.Fixed64)
              throw new Error("Unimplemented type: " + e2);
            this.pos += 8;
          }
        }, writeTag: function(t4, e2) {
          this.writeVarint(t4 << 3 | e2);
        }, realloc: function(t4) {
          for (var e2 = this.length || 16; e2 < this.pos + t4; )
            e2 *= 2;
          if (e2 !== this.length) {
            var r2 = new Uint8Array(e2);
            r2.set(this.buf), this.buf = r2, this.length = e2;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t4) {
          this.realloc(4), hu(this.buf, t4, this.pos), this.pos += 4;
        }, writeSFixed32: function(t4) {
          this.realloc(4), hu(this.buf, t4, this.pos), this.pos += 4;
        }, writeFixed64: function(t4) {
          this.realloc(8), hu(this.buf, -1 & t4, this.pos), hu(this.buf, Math.floor(t4 * (1 / 4294967296)), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t4) {
          this.realloc(8), hu(this.buf, -1 & t4, this.pos), hu(this.buf, Math.floor(t4 * (1 / 4294967296)), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t4) {
          (t4 = +t4 || 0) > 268435455 || t4 < 0 ? function(t5, e2) {
            var r2, n2;
            if (t5 >= 0 ? (r2 = t5 % 4294967296 | 0, n2 = t5 / 4294967296 | 0) : (n2 = ~(-t5 / 4294967296), 4294967295 ^ (r2 = ~(-t5 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t5 >= 18446744073709552e3 || t5 < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e2.realloc(10), function(t6, e3, r3) {
              r3.buf[r3.pos++] = 127 & t6 | 128, t6 >>>= 7, r3.buf[r3.pos++] = 127 & t6 | 128, t6 >>>= 7, r3.buf[r3.pos++] = 127 & t6 | 128, t6 >>>= 7, r3.buf[r3.pos++] = 127 & t6 | 128, r3.buf[r3.pos] = 127 & (t6 >>>= 7);
            }(r2, 0, e2), function(t6, e3) {
              var r3 = (7 & t6) << 4;
              e3.buf[e3.pos++] |= r3 | ((t6 >>>= 3) ? 128 : 0), t6 && (e3.buf[e3.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e3.buf[e3.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e3.buf[e3.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e3.buf[e3.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e3.buf[e3.pos++] = 127 & t6)))));
            }(n2, e2);
          }(t4, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t4 | (t4 > 127 ? 128 : 0), t4 <= 127 || (this.buf[this.pos++] = 127 & (t4 >>>= 7) | (t4 > 127 ? 128 : 0), t4 <= 127 || (this.buf[this.pos++] = 127 & (t4 >>>= 7) | (t4 > 127 ? 128 : 0), t4 <= 127 || (this.buf[this.pos++] = t4 >>> 7 & 127))));
        }, writeSVarint: function(t4) {
          this.writeVarint(t4 < 0 ? 2 * -t4 - 1 : 2 * t4);
        }, writeBoolean: function(t4) {
          this.writeVarint(Boolean(t4));
        }, writeString: function(t4) {
          t4 = String(t4), this.realloc(4 * t4.length), this.pos++;
          var e2 = this.pos;
          this.pos = function(t5, e3, r3) {
            for (var n2, i3, a2 = 0; a2 < e3.length; a2++) {
              if ((n2 = e3.charCodeAt(a2)) > 55295 && n2 < 57344) {
                if (!i3) {
                  n2 > 56319 || a2 + 1 === e3.length ? (t5[r3++] = 239, t5[r3++] = 191, t5[r3++] = 189) : i3 = n2;
                  continue;
                }
                if (n2 < 56320) {
                  t5[r3++] = 239, t5[r3++] = 191, t5[r3++] = 189, i3 = n2;
                  continue;
                }
                n2 = i3 - 55296 << 10 | n2 - 56320 | 65536, i3 = null;
              } else
                i3 && (t5[r3++] = 239, t5[r3++] = 191, t5[r3++] = 189, i3 = null);
              n2 < 128 ? t5[r3++] = n2 : (n2 < 2048 ? t5[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t5[r3++] = n2 >> 12 | 224 : (t5[r3++] = n2 >> 18 | 240, t5[r3++] = n2 >> 12 & 63 | 128), t5[r3++] = n2 >> 6 & 63 | 128), t5[r3++] = 63 & n2 | 128);
            }
            return r3;
          }(this.buf, t4, this.pos);
          var r2 = this.pos - e2;
          r2 >= 128 && eu(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
        }, writeFloat: function(t4) {
          this.realloc(4), Hs(this.buf, t4, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t4) {
          this.realloc(8), Hs(this.buf, t4, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t4) {
          var e2 = t4.length;
          this.writeVarint(e2), this.realloc(e2);
          for (var r2 = 0; r2 < e2; r2++)
            this.buf[this.pos++] = t4[r2];
        }, writeRawMessage: function(t4, e2) {
          this.pos++;
          var r2 = this.pos;
          t4(e2, this);
          var n2 = this.pos - r2;
          n2 >= 128 && eu(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
        }, writeMessage: function(t4, e2, r2) {
          this.writeTag(t4, $s.Bytes), this.writeRawMessage(e2, r2);
        }, writePackedVarint: function(t4, e2) {
          e2.length && this.writeMessage(t4, ru, e2);
        }, writePackedSVarint: function(t4, e2) {
          e2.length && this.writeMessage(t4, nu, e2);
        }, writePackedBoolean: function(t4, e2) {
          e2.length && this.writeMessage(t4, ou, e2);
        }, writePackedFloat: function(t4, e2) {
          e2.length && this.writeMessage(t4, iu, e2);
        }, writePackedDouble: function(t4, e2) {
          e2.length && this.writeMessage(t4, au, e2);
        }, writePackedFixed32: function(t4, e2) {
          e2.length && this.writeMessage(t4, su, e2);
        }, writePackedSFixed32: function(t4, e2) {
          e2.length && this.writeMessage(t4, uu, e2);
        }, writePackedFixed64: function(t4, e2) {
          e2.length && this.writeMessage(t4, lu, e2);
        }, writePackedSFixed64: function(t4, e2) {
          e2.length && this.writeMessage(t4, pu, e2);
        }, writeBytesField: function(t4, e2) {
          this.writeTag(t4, $s.Bytes), this.writeBytes(e2);
        }, writeFixed32Field: function(t4, e2) {
          this.writeTag(t4, $s.Fixed32), this.writeFixed32(e2);
        }, writeSFixed32Field: function(t4, e2) {
          this.writeTag(t4, $s.Fixed32), this.writeSFixed32(e2);
        }, writeFixed64Field: function(t4, e2) {
          this.writeTag(t4, $s.Fixed64), this.writeFixed64(e2);
        }, writeSFixed64Field: function(t4, e2) {
          this.writeTag(t4, $s.Fixed64), this.writeSFixed64(e2);
        }, writeVarintField: function(t4, e2) {
          this.writeTag(t4, $s.Varint), this.writeVarint(e2);
        }, writeSVarintField: function(t4, e2) {
          this.writeTag(t4, $s.Varint), this.writeSVarint(e2);
        }, writeStringField: function(t4, e2) {
          this.writeTag(t4, $s.Bytes), this.writeString(e2);
        }, writeFloatField: function(t4, e2) {
          this.writeTag(t4, $s.Fixed32), this.writeFloat(e2);
        }, writeDoubleField: function(t4, e2) {
          this.writeTag(t4, $s.Fixed64), this.writeDouble(e2);
        }, writeBooleanField: function(t4, e2) {
          this.writeVarintField(t4, Boolean(e2));
        } };
        var gu = function(t4, e2) {
          var r2 = e2.pixelRatio, n2 = e2.version, i3 = e2.stretchX, a2 = e2.stretchY, o2 = e2.content;
          this.paddedRect = t4, this.pixelRatio = r2, this.stretchX = i3, this.stretchY = a2, this.content = o2, this.version = n2;
        }, xu = { tl: { configurable: true }, br: { configurable: true }, tlbr: { configurable: true }, displaySize: { configurable: true } };
        xu.tl.get = function() {
          return [this.paddedRect.x + 1, this.paddedRect.y + 1];
        }, xu.br.get = function() {
          return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
        }, xu.tlbr.get = function() {
          return this.tl.concat(this.br);
        }, xu.displaySize.get = function() {
          return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
        }, Object.defineProperties(gu.prototype, xu);
        var bu = function(t4, e2) {
          var r2 = {}, n2 = {};
          this.haveRenderCallbacks = [];
          var i3 = [];
          this.addImages(t4, r2, i3), this.addImages(e2, n2, i3);
          var a2 = vu(i3), o2 = new xo({ width: a2.w || 1, height: a2.h || 1 });
          for (var s2 in t4) {
            var u2 = t4[s2], l2 = r2[s2].paddedRect;
            xo.copy(u2.data, o2, { x: 0, y: 0 }, { x: l2.x + 1, y: l2.y + 1 }, u2.data);
          }
          for (var p2 in e2) {
            var c2 = e2[p2], h2 = n2[p2].paddedRect, f2 = h2.x + 1, y2 = h2.y + 1, d2 = c2.data.width, m2 = c2.data.height;
            xo.copy(c2.data, o2, { x: 0, y: 0 }, { x: f2, y: y2 }, c2.data), xo.copy(c2.data, o2, { x: 0, y: m2 - 1 }, { x: f2, y: y2 - 1 }, { width: d2, height: 1 }), xo.copy(c2.data, o2, { x: 0, y: 0 }, { x: f2, y: y2 + m2 }, { width: d2, height: 1 }), xo.copy(c2.data, o2, { x: d2 - 1, y: 0 }, { x: f2 - 1, y: y2 }, { width: 1, height: m2 }), xo.copy(c2.data, o2, { x: 0, y: 0 }, { x: f2 + d2, y: y2 }, { width: 1, height: m2 });
          }
          this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
        };
        bu.prototype.addImages = function(t4, e2, r2) {
          for (var n2 in t4) {
            var i3 = t4[n2], a2 = { x: 0, y: 0, w: i3.data.width + 2, h: i3.data.height + 2 };
            r2.push(a2), e2[n2] = new gu(a2, i3), i3.hasRenderCallback && this.haveRenderCallbacks.push(n2);
          }
        }, bu.prototype.patchUpdatedImages = function(t4, e2) {
          for (var r2 in t4.dispatchRenderCallbacks(this.haveRenderCallbacks), t4.updatedImages)
            this.patchUpdatedImage(this.iconPositions[r2], t4.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t4.getImage(r2), e2);
        }, bu.prototype.patchUpdatedImage = function(t4, e2, r2) {
          if (t4 && e2 && t4.version !== e2.version) {
            t4.version = e2.version;
            var n2 = t4.tl;
            r2.update(e2.data, void 0, { x: n2[0], y: n2[1] });
          }
        }, On("ImagePosition", gu), On("ImageAtlas", bu);
        var wu = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, _u = function() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        };
        _u.forText = function(t4, e2) {
          var r2 = new _u();
          return r2.scale = t4 || 1, r2.fontStack = e2, r2;
        }, _u.forImage = function(t4) {
          var e2 = new _u();
          return e2.imageName = t4, e2;
        };
        var Au = function() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        };
        function Su(t4, e2, r2, n2, i3, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2) {
          var m2, v2 = Au.fromFeature(t4, i3);
          c2 === wu.vertical && v2.verticalizePunctuation();
          var g2 = oi.processBidirectionalText, x3 = oi.processStyledBidirectionalText;
          if (g2 && 1 === v2.sections.length) {
            m2 = [];
            for (var b2 = 0, w2 = g2(v2.toString(), Mu(v2, l2, a2, e2, n2, f2, y2)); b2 < w2.length; b2 += 1) {
              var _2 = w2[b2], A3 = new Au();
              A3.text = _2, A3.sections = v2.sections;
              for (var S2 = 0; S2 < _2.length; S2++)
                A3.sectionIndex.push(0);
              m2.push(A3);
            }
          } else if (x3) {
            m2 = [];
            for (var k2 = 0, I2 = x3(v2.text, v2.sectionIndex, Mu(v2, l2, a2, e2, n2, f2, y2)); k2 < I2.length; k2 += 1) {
              var z2 = I2[k2], C3 = new Au();
              C3.text = z2[0], C3.sectionIndex = z2[1], C3.sections = v2.sections, m2.push(C3);
            }
          } else
            m2 = function(t5, e3) {
              for (var r3 = [], n3 = t5.text, i4 = 0, a3 = 0, o3 = e3; a3 < o3.length; a3 += 1) {
                var s3 = o3[a3];
                r3.push(t5.substring(i4, s3)), i4 = s3;
              }
              return i4 < n3.length && r3.push(t5.substring(i4, n3.length)), r3;
            }(v2, Mu(v2, l2, a2, e2, n2, f2, y2));
          var E3 = [], P2 = { positionedLines: E3, text: v2.toString(), top: p2[1], bottom: p2[1], left: p2[0], right: p2[0], writingMode: c2, iconsInText: false, verticalizable: false };
          return function(t5, e3, r3, n3, i4, a3, o3, s3, u3, l3, p3, c3) {
            for (var h3 = 0, f3 = -17, y3 = 0, d3 = 0, m3 = "right" === s3 ? 1 : "left" === s3 ? 0 : 0.5, v3 = 0, g3 = 0, x4 = i4; g3 < x4.length; g3 += 1) {
              var b3 = x4[g3];
              b3.trim();
              var w3 = b3.getMaxScale(), _3 = 24 * (w3 - 1), A4 = { positionedGlyphs: [], lineOffset: 0 };
              t5.positionedLines[v3] = A4;
              var S3 = A4.positionedGlyphs, k3 = 0;
              if (b3.length()) {
                for (var I3 = 0; I3 < b3.length(); I3++) {
                  var z3 = b3.getSection(I3), C4 = b3.getSectionIndex(I3), E4 = b3.getCharCode(I3), P3 = 0, M2 = null, B3 = null, T3 = null, V2 = 24, F2 = !(u3 === wu.horizontal || !p3 && !Xn2(E4) || p3 && (ku[E4] || (K3 = E4, Gn.Arabic(K3) || Gn["Arabic Supplement"](K3) || Gn["Arabic Extended-A"](K3) || Gn["Arabic Presentation Forms-A"](K3) || Gn["Arabic Presentation Forms-B"](K3))));
                  if (z3.imageName) {
                    var D3 = n3[z3.imageName];
                    if (!D3)
                      continue;
                    T3 = z3.imageName, t5.iconsInText = t5.iconsInText || true, B3 = D3.paddedRect;
                    var L3 = D3.displaySize;
                    z3.scale = 24 * z3.scale / c3, P3 = _3 + (24 - L3[1] * z3.scale), V2 = (M2 = { width: L3[0], height: L3[1], left: 1, top: -3, advance: F2 ? L3[1] : L3[0] }).advance;
                    var O2 = F2 ? L3[0] * z3.scale - 24 * w3 : L3[1] * z3.scale - 24 * w3;
                    O2 > 0 && O2 > k3 && (k3 = O2);
                  } else {
                    var R2 = r3[z3.fontStack], U2 = R2 && R2[E4];
                    if (U2 && U2.rect)
                      B3 = U2.rect, M2 = U2.metrics;
                    else {
                      var j2 = e3[z3.fontStack], q2 = j2 && j2[E4];
                      if (!q2)
                        continue;
                      M2 = q2.metrics;
                    }
                    P3 = 24 * (w3 - z3.scale);
                  }
                  F2 ? (t5.verticalizable = true, S3.push({ glyph: E4, imageName: T3, x: h3, y: f3 + P3, vertical: F2, scale: z3.scale, fontStack: z3.fontStack, sectionIndex: C4, metrics: M2, rect: B3 }), h3 += V2 * z3.scale + l3) : (S3.push({ glyph: E4, imageName: T3, x: h3, y: f3 + P3, vertical: F2, scale: z3.scale, fontStack: z3.fontStack, sectionIndex: C4, metrics: M2, rect: B3 }), h3 += M2.advance * z3.scale + l3);
                }
                0 !== S3.length && (y3 = Math.max(h3 - l3, y3), Tu(S3, 0, S3.length - 1, m3, k3)), h3 = 0;
                var N2 = a3 * w3 + k3;
                A4.lineOffset = Math.max(k3, _3), f3 += N2, d3 = Math.max(N2, d3), ++v3;
              } else
                f3 += a3, ++v3;
            }
            var K3, G2 = f3 - -17, Z2 = Bu(o3), X2 = Z2.horizontalAlign, J2 = Z2.verticalAlign;
            (function(t6, e4, r4, n4, i5, a4, o4, s4, u4) {
              var l4, p4 = (e4 - r4) * i5;
              l4 = a4 !== o4 ? -s4 * n4 - -17 : (-n4 * u4 + 0.5) * o4;
              for (var c4 = 0, h4 = t6; c4 < h4.length; c4 += 1)
                for (var f4 = 0, y4 = h4[c4].positionedGlyphs; f4 < y4.length; f4 += 1) {
                  var d4 = y4[f4];
                  d4.x += p4, d4.y += l4;
                }
            })(t5.positionedLines, m3, X2, J2, y3, d3, a3, G2, i4.length), t5.top += -J2 * G2, t5.bottom = t5.top + G2, t5.left += -X2 * y3, t5.right = t5.left + y3;
          }(P2, e2, r2, n2, m2, o2, s2, u2, c2, l2, h2, d2), !function(t5) {
            for (var e3 = 0, r3 = t5; e3 < r3.length; e3 += 1)
              if (0 !== r3[e3].positionedGlyphs.length)
                return false;
            return true;
          }(E3) && P2;
        }
        Au.fromFeature = function(t4, e2) {
          for (var r2 = new Au(), n2 = 0; n2 < t4.sections.length; n2++) {
            var i3 = t4.sections[n2];
            i3.image ? r2.addImageSection(i3) : r2.addTextSection(i3, e2);
          }
          return r2;
        }, Au.prototype.length = function() {
          return this.text.length;
        }, Au.prototype.getSection = function(t4) {
          return this.sections[this.sectionIndex[t4]];
        }, Au.prototype.getSectionIndex = function(t4) {
          return this.sectionIndex[t4];
        }, Au.prototype.getCharCode = function(t4) {
          return this.text.charCodeAt(t4);
        }, Au.prototype.verticalizePunctuation = function() {
          this.text = function(t4) {
            for (var e2 = "", r2 = 0; r2 < t4.length; r2++) {
              var n2 = t4.charCodeAt(r2 + 1) || null, i3 = t4.charCodeAt(r2 - 1) || null;
              e2 += n2 && Jn(n2) && !Xs[t4[r2 + 1]] || i3 && Jn(i3) && !Xs[t4[r2 - 1]] || !Xs[t4[r2]] ? t4[r2] : Xs[t4[r2]];
            }
            return e2;
          }(this.text);
        }, Au.prototype.trim = function() {
          for (var t4 = 0, e2 = 0; e2 < this.text.length && ku[this.text.charCodeAt(e2)]; e2++)
            t4++;
          for (var r2 = this.text.length, n2 = this.text.length - 1; n2 >= 0 && n2 >= t4 && ku[this.text.charCodeAt(n2)]; n2--)
            r2--;
          this.text = this.text.substring(t4, r2), this.sectionIndex = this.sectionIndex.slice(t4, r2);
        }, Au.prototype.substring = function(t4, e2) {
          var r2 = new Au();
          return r2.text = this.text.substring(t4, e2), r2.sectionIndex = this.sectionIndex.slice(t4, e2), r2.sections = this.sections, r2;
        }, Au.prototype.toString = function() {
          return this.text;
        }, Au.prototype.getMaxScale = function() {
          var t4 = this;
          return this.sectionIndex.reduce(function(e2, r2) {
            return Math.max(e2, t4.sections[r2].scale);
          }, 0);
        }, Au.prototype.addTextSection = function(t4, e2) {
          this.text += t4.text, this.sections.push(_u.forText(t4.scale, t4.fontStack || e2));
          for (var r2 = this.sections.length - 1, n2 = 0; n2 < t4.text.length; ++n2)
            this.sectionIndex.push(r2);
        }, Au.prototype.addImageSection = function(t4) {
          var e2 = t4.image ? t4.image.name : "";
          if (0 !== e2.length) {
            var r2 = this.getNextImageSectionCharCode();
            r2 ? (this.text += String.fromCharCode(r2), this.sections.push(_u.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : A2("Reached maximum number of images 6401");
          } else
            A2("Can't add FormattedSection with an empty image.");
        }, Au.prototype.getNextImageSectionCharCode = function() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        };
        var ku = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Iu = {};
        function zu(t4, e2, r2, n2, i3, a2) {
          if (e2.imageName) {
            var o2 = n2[e2.imageName];
            return o2 ? o2.displaySize[0] * e2.scale * 24 / a2 + i3 : 0;
          }
          var s2 = r2[e2.fontStack], u2 = s2 && s2[t4];
          return u2 ? u2.metrics.advance * e2.scale + i3 : 0;
        }
        function Cu(t4, e2, r2, n2) {
          var i3 = Math.pow(t4 - e2, 2);
          return n2 ? t4 < e2 ? i3 / 2 : 2 * i3 : i3 + Math.abs(r2) * r2;
        }
        function Eu(t4, e2, r2) {
          var n2 = 0;
          return 10 === t4 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t4 && 65288 !== t4 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
        }
        function Pu(t4, e2, r2, n2, i3, a2) {
          for (var o2 = null, s2 = Cu(e2, r2, i3, a2), u2 = 0, l2 = n2; u2 < l2.length; u2 += 1) {
            var p2 = l2[u2], c2 = Cu(e2 - p2.x, r2, i3, a2) + p2.badness;
            c2 <= s2 && (o2 = p2, s2 = c2);
          }
          return { index: t4, x: e2, priorBreak: o2, badness: s2 };
        }
        function Mu(t4, e2, r2, n2, i3, a2, o2) {
          if ("point" !== a2)
            return [];
          if (!t4)
            return [];
          for (var s2, u2 = [], l2 = function(t5, e3, r3, n3, i4, a3) {
            for (var o3 = 0, s3 = 0; s3 < t5.length(); s3++) {
              var u3 = t5.getSection(s3);
              o3 += zu(t5.getCharCode(s3), u3, n3, i4, e3, a3);
            }
            return o3 / Math.max(1, Math.ceil(o3 / r3));
          }(t4, e2, r2, n2, i3, o2), p2 = t4.text.indexOf("​") >= 0, c2 = 0, h2 = 0; h2 < t4.length(); h2++) {
            var f2 = t4.getSection(h2), y2 = t4.getCharCode(h2);
            if (ku[y2] || (c2 += zu(y2, f2, n2, i3, e2, o2)), h2 < t4.length() - 1) {
              var d2 = !((s2 = y2) < 11904 || !(Gn["Bopomofo Extended"](s2) || Gn.Bopomofo(s2) || Gn["CJK Compatibility Forms"](s2) || Gn["CJK Compatibility Ideographs"](s2) || Gn["CJK Compatibility"](s2) || Gn["CJK Radicals Supplement"](s2) || Gn["CJK Strokes"](s2) || Gn["CJK Symbols and Punctuation"](s2) || Gn["CJK Unified Ideographs Extension A"](s2) || Gn["CJK Unified Ideographs"](s2) || Gn["Enclosed CJK Letters and Months"](s2) || Gn["Halfwidth and Fullwidth Forms"](s2) || Gn.Hiragana(s2) || Gn["Ideographic Description Characters"](s2) || Gn["Kangxi Radicals"](s2) || Gn["Katakana Phonetic Extensions"](s2) || Gn.Katakana(s2) || Gn["Vertical Forms"](s2) || Gn["Yi Radicals"](s2) || Gn["Yi Syllables"](s2)));
              (Iu[y2] || d2 || f2.imageName) && u2.push(Pu(h2 + 1, c2, l2, u2, Eu(y2, t4.getCharCode(h2 + 1), d2 && p2), false));
            }
          }
          return function t5(e3) {
            return e3 ? t5(e3.priorBreak).concat(e3.index) : [];
          }(Pu(t4.length(), c2, l2, u2, 0, true));
        }
        function Bu(t4) {
          var e2 = 0.5, r2 = 0.5;
          switch (t4) {
            case "right":
            case "top-right":
            case "bottom-right":
              e2 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e2 = 0;
          }
          switch (t4) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r2 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r2 = 0;
          }
          return { horizontalAlign: e2, verticalAlign: r2 };
        }
        function Tu(t4, e2, r2, n2, i3) {
          if (n2 || i3)
            for (var a2 = t4[r2], o2 = (t4[r2].x + a2.metrics.advance * a2.scale) * n2, s2 = e2; s2 <= r2; s2++)
              t4[s2].x -= o2, t4[s2].y += i3;
        }
        function Vu(t4, e2, r2, n2, i3, a2) {
          var o2, s2 = t4.image;
          if (s2.content) {
            var u2 = s2.content, l2 = s2.pixelRatio || 1;
            o2 = [u2[0] / l2, u2[1] / l2, s2.displaySize[0] - u2[2] / l2, s2.displaySize[1] - u2[3] / l2];
          }
          var p2, c2, h2, f2, y2 = e2.left * a2, d2 = e2.right * a2;
          "width" === r2 || "both" === r2 ? (f2 = i3[0] + y2 - n2[3], c2 = i3[0] + d2 + n2[1]) : c2 = (f2 = i3[0] + (y2 + d2 - s2.displaySize[0]) / 2) + s2.displaySize[0];
          var m2 = e2.top * a2, v2 = e2.bottom * a2;
          return "height" === r2 || "both" === r2 ? (p2 = i3[1] + m2 - n2[0], h2 = i3[1] + v2 + n2[2]) : h2 = (p2 = i3[1] + (m2 + v2 - s2.displaySize[1]) / 2) + s2.displaySize[1], { image: s2, top: p2, right: c2, bottom: h2, left: f2, collisionPadding: o2 };
        }
        Iu[10] = true, Iu[32] = true, Iu[38] = true, Iu[40] = true, Iu[41] = true, Iu[43] = true, Iu[45] = true, Iu[47] = true, Iu[173] = true, Iu[183] = true, Iu[8203] = true, Iu[8208] = true, Iu[8211] = true, Iu[8231] = true;
        var Fu = function(t4) {
          function e2(e3, r2, n2, i3) {
            t4.call(this, e3, r2), this.angle = n2, void 0 !== i3 && (this.segment = i3);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.clone = function() {
            return new e2(this.x, this.y, this.angle, this.segment);
          }, e2;
        }(i2);
        function Du(t4, e2) {
          var r2 = e2.expression;
          if ("constant" === r2.kind)
            return { kind: "constant", layoutSize: r2.evaluate(new si(t4 + 1)) };
          if ("source" === r2.kind)
            return { kind: "source" };
          for (var n2 = r2.zoomStops, i3 = r2.interpolationType, a2 = 0; a2 < n2.length && n2[a2] <= t4; )
            a2++;
          for (var o2 = a2 = Math.max(0, a2 - 1); o2 < n2.length && n2[o2] < t4 + 1; )
            o2++;
          o2 = Math.min(n2.length - 1, o2);
          var s2 = n2[a2], u2 = n2[o2];
          return "composite" === r2.kind ? { kind: "composite", minZoom: s2, maxZoom: u2, interpolationType: i3 } : { kind: "camera", minZoom: s2, maxZoom: u2, minSize: r2.evaluate(new si(s2)), maxSize: r2.evaluate(new si(u2)), interpolationType: i3 };
        }
        function Lu(t4, e2, r2) {
          var n2 = e2.uSize, i3 = r2.lowerSize;
          return "source" === t4.kind ? i3 / 128 : "composite" === t4.kind ? Ke(i3 / 128, r2.upperSize / 128, e2.uSizeT) : n2;
        }
        function Ou(t4, e2) {
          var r2 = 0, n2 = 0;
          if ("constant" === t4.kind)
            n2 = t4.layoutSize;
          else if ("source" !== t4.kind) {
            var i3 = t4.interpolationType, a2 = i3 ? p(ar.interpolationFactor(i3, e2, t4.minZoom, t4.maxZoom), 0, 1) : 0;
            "camera" === t4.kind ? n2 = Ke(t4.minSize, t4.maxSize, a2) : r2 = a2;
          }
          return { uSizeT: r2, uSize: n2 };
        }
        On("Anchor", Fu);
        var Ru = Object.freeze({ __proto__: null, getSizeData: Du, evaluateSizeForFeature: Lu, evaluateSizeForZoom: Ou, SIZE_PACK_FACTOR: 128 });
        function Uu(t4, e2, r2, n2, i3) {
          if (void 0 === e2.segment)
            return true;
          for (var a2 = e2, o2 = e2.segment + 1, s2 = 0; s2 > -r2 / 2; ) {
            if (--o2 < 0)
              return false;
            s2 -= t4[o2].dist(a2), a2 = t4[o2];
          }
          s2 += t4[o2].dist(t4[o2 + 1]), o2++;
          for (var u2 = [], l2 = 0; s2 < r2 / 2; ) {
            var p2 = t4[o2], c2 = t4[o2 + 1];
            if (!c2)
              return false;
            var h2 = t4[o2 - 1].angleTo(p2) - p2.angleTo(c2);
            for (h2 = Math.abs((h2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), u2.push({ distance: s2, angleDelta: h2 }), l2 += h2; s2 - u2[0].distance > n2; )
              l2 -= u2.shift().angleDelta;
            if (l2 > i3)
              return false;
            o2++, s2 += p2.dist(c2);
          }
          return true;
        }
        function ju(t4) {
          for (var e2 = 0, r2 = 0; r2 < t4.length - 1; r2++)
            e2 += t4[r2].dist(t4[r2 + 1]);
          return e2;
        }
        function qu(t4, e2, r2) {
          return t4 ? 0.6 * e2 * r2 : 0;
        }
        function Nu(t4, e2) {
          return Math.max(t4 ? t4.right - t4.left : 0, e2 ? e2.right - e2.left : 0);
        }
        function Ku(t4, e2, r2, n2, i3, a2) {
          for (var o2 = qu(r2, i3, a2), s2 = Nu(r2, n2) * a2, u2 = 0, l2 = ju(t4) / 2, p2 = 0; p2 < t4.length - 1; p2++) {
            var c2 = t4[p2], h2 = t4[p2 + 1], f2 = c2.dist(h2);
            if (u2 + f2 > l2) {
              var y2 = (l2 - u2) / f2, d2 = Ke(c2.x, h2.x, y2), m2 = Ke(c2.y, h2.y, y2), v2 = new Fu(d2, m2, h2.angleTo(c2), p2);
              return v2._round(), !o2 || Uu(t4, v2, s2, o2, e2) ? v2 : void 0;
            }
            u2 += f2;
          }
        }
        function Gu(t4, e2, r2, n2, i3, a2, o2, s2, u2) {
          var l2 = qu(n2, a2, o2), p2 = Nu(n2, i3), c2 = p2 * o2, h2 = 0 === t4[0].x || t4[0].x === u2 || 0 === t4[0].y || t4[0].y === u2;
          return e2 - c2 < e2 / 4 && (e2 = c2 + e2 / 4), function t5(e3, r3, n3, i4, a3, o3, s3, u3, l3) {
            for (var p3 = o3 / 2, c3 = ju(e3), h3 = 0, f2 = r3 - n3, y2 = [], d2 = 0; d2 < e3.length - 1; d2++) {
              for (var m2 = e3[d2], v2 = e3[d2 + 1], g2 = m2.dist(v2), x3 = v2.angleTo(m2); f2 + n3 < h3 + g2; ) {
                var b2 = ((f2 += n3) - h3) / g2, w2 = Ke(m2.x, v2.x, b2), _2 = Ke(m2.y, v2.y, b2);
                if (w2 >= 0 && w2 < l3 && _2 >= 0 && _2 < l3 && f2 - p3 >= 0 && f2 + p3 <= c3) {
                  var A3 = new Fu(w2, _2, x3, d2);
                  A3._round(), i4 && !Uu(e3, A3, o3, i4, a3) || y2.push(A3);
                }
              }
              h3 += g2;
            }
            return u3 || y2.length || s3 || (y2 = t5(e3, h3 / 2, n3, i4, a3, o3, s3, true, l3)), y2;
          }(t4, h2 ? e2 / 2 * s2 % e2 : (p2 / 2 + 2 * a2) * o2 * s2 % e2, e2, l2, r2, c2, h2, false, u2);
        }
        function Zu(t4, e2, r2, n2, a2) {
          for (var o2 = [], s2 = 0; s2 < t4.length; s2++)
            for (var u2 = t4[s2], l2 = void 0, p2 = 0; p2 < u2.length - 1; p2++) {
              var c2 = u2[p2], h2 = u2[p2 + 1];
              c2.x < e2 && h2.x < e2 || (c2.x < e2 ? c2 = new i2(e2, c2.y + (e2 - c2.x) / (h2.x - c2.x) * (h2.y - c2.y))._round() : h2.x < e2 && (h2 = new i2(e2, c2.y + (e2 - c2.x) / (h2.x - c2.x) * (h2.y - c2.y))._round()), c2.y < r2 && h2.y < r2 || (c2.y < r2 ? c2 = new i2(c2.x + (r2 - c2.y) / (h2.y - c2.y) * (h2.x - c2.x), r2)._round() : h2.y < r2 && (h2 = new i2(c2.x + (r2 - c2.y) / (h2.y - c2.y) * (h2.x - c2.x), r2)._round()), c2.x >= n2 && h2.x >= n2 || (c2.x >= n2 ? c2 = new i2(n2, c2.y + (n2 - c2.x) / (h2.x - c2.x) * (h2.y - c2.y))._round() : h2.x >= n2 && (h2 = new i2(n2, c2.y + (n2 - c2.x) / (h2.x - c2.x) * (h2.y - c2.y))._round()), c2.y >= a2 && h2.y >= a2 || (c2.y >= a2 ? c2 = new i2(c2.x + (a2 - c2.y) / (h2.y - c2.y) * (h2.x - c2.x), a2)._round() : h2.y >= a2 && (h2 = new i2(c2.x + (a2 - c2.y) / (h2.y - c2.y) * (h2.x - c2.x), a2)._round()), l2 && c2.equals(l2[l2.length - 1]) || o2.push(l2 = [c2]), l2.push(h2)))));
            }
          return o2;
        }
        function Xu(t4, e2, r2, n2) {
          var a2 = [], o2 = t4.image, s2 = o2.pixelRatio, u2 = o2.paddedRect.w - 2, l2 = o2.paddedRect.h - 2, p2 = t4.right - t4.left, c2 = t4.bottom - t4.top, h2 = o2.stretchX || [[0, u2]], f2 = o2.stretchY || [[0, l2]], y2 = function(t5, e3) {
            return t5 + e3[1] - e3[0];
          }, d2 = h2.reduce(y2, 0), m2 = f2.reduce(y2, 0), v2 = u2 - d2, g2 = l2 - m2, x3 = 0, b2 = d2, w2 = 0, _2 = m2, A3 = 0, S2 = v2, k2 = 0, I2 = g2;
          if (o2.content && n2) {
            var z2 = o2.content;
            x3 = Ju(h2, 0, z2[0]), w2 = Ju(f2, 0, z2[1]), b2 = Ju(h2, z2[0], z2[2]), _2 = Ju(f2, z2[1], z2[3]), A3 = z2[0] - x3, k2 = z2[1] - w2, S2 = z2[2] - z2[0] - b2, I2 = z2[3] - z2[1] - _2;
          }
          var C3 = function(n3, a3, u3, l3) {
            var h3 = Yu(n3.stretch - x3, b2, p2, t4.left), f3 = $u(n3.fixed - A3, S2, n3.stretch, d2), y3 = Yu(a3.stretch - w2, _2, c2, t4.top), v3 = $u(a3.fixed - k2, I2, a3.stretch, m2), g3 = Yu(u3.stretch - x3, b2, p2, t4.left), z3 = $u(u3.fixed - A3, S2, u3.stretch, d2), C4 = Yu(l3.stretch - w2, _2, c2, t4.top), E4 = $u(l3.fixed - k2, I2, l3.stretch, m2), P3 = new i2(h3, y3), M3 = new i2(g3, y3), B4 = new i2(g3, C4), T4 = new i2(h3, C4), V3 = new i2(f3 / s2, v3 / s2), F2 = new i2(z3 / s2, E4 / s2), D3 = e2 * Math.PI / 180;
            if (D3) {
              var L3 = Math.sin(D3), O2 = Math.cos(D3), R2 = [O2, -L3, L3, O2];
              P3._matMult(R2), M3._matMult(R2), T4._matMult(R2), B4._matMult(R2);
            }
            var U2 = n3.stretch + n3.fixed, j2 = a3.stretch + a3.fixed;
            return { tl: P3, tr: M3, bl: T4, br: B4, tex: { x: o2.paddedRect.x + 1 + U2, y: o2.paddedRect.y + 1 + j2, w: u3.stretch + u3.fixed - U2, h: l3.stretch + l3.fixed - j2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: V3, pixelOffsetBR: F2, minFontScaleX: S2 / s2 / p2, minFontScaleY: I2 / s2 / c2, isSDF: r2 };
          };
          if (n2 && (o2.stretchX || o2.stretchY))
            for (var E3 = Hu(h2, v2, d2), P2 = Hu(f2, g2, m2), M2 = 0; M2 < E3.length - 1; M2++)
              for (var B3 = E3[M2], T3 = E3[M2 + 1], V2 = 0; V2 < P2.length - 1; V2++)
                a2.push(C3(B3, P2[V2], T3, P2[V2 + 1]));
          else
            a2.push(C3({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: u2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
          return a2;
        }
        function Ju(t4, e2, r2) {
          for (var n2 = 0, i3 = 0, a2 = t4; i3 < a2.length; i3 += 1) {
            var o2 = a2[i3];
            n2 += Math.max(e2, Math.min(r2, o2[1])) - Math.max(e2, Math.min(r2, o2[0]));
          }
          return n2;
        }
        function Hu(t4, e2, r2) {
          for (var n2 = [{ fixed: -1, stretch: 0 }], i3 = 0, a2 = t4; i3 < a2.length; i3 += 1) {
            var o2 = a2[i3], s2 = o2[0], u2 = o2[1], l2 = n2[n2.length - 1];
            n2.push({ fixed: s2 - l2.stretch, stretch: l2.stretch }), n2.push({ fixed: s2 - l2.stretch, stretch: l2.stretch + (u2 - s2) });
          }
          return n2.push({ fixed: e2 + 1, stretch: r2 }), n2;
        }
        function Yu(t4, e2, r2, n2) {
          return t4 / e2 * r2 + n2;
        }
        function $u(t4, e2, r2, n2) {
          return t4 - e2 * r2 / n2;
        }
        var Wu = function(t4, e2, r2, n2, a2, o2, s2, u2, l2, p2) {
          if (this.boxStartIndex = t4.length, l2) {
            var c2 = o2.top, h2 = o2.bottom, f2 = o2.collisionPadding;
            f2 && (c2 -= f2[1], h2 += f2[3]);
            var y2 = h2 - c2;
            y2 > 0 && (y2 = Math.max(10, y2), this.circleDiameter = y2);
          } else {
            var d2 = o2.top * s2 - u2, m2 = o2.bottom * s2 + u2, v2 = o2.left * s2 - u2, g2 = o2.right * s2 + u2, x3 = o2.collisionPadding;
            if (x3 && (v2 -= x3[0] * s2, d2 -= x3[1] * s2, g2 += x3[2] * s2, m2 += x3[3] * s2), p2) {
              var b2 = new i2(v2, d2), w2 = new i2(g2, d2), _2 = new i2(v2, m2), A3 = new i2(g2, m2), S2 = p2 * Math.PI / 180;
              b2._rotate(S2), w2._rotate(S2), _2._rotate(S2), A3._rotate(S2), v2 = Math.min(b2.x, w2.x, _2.x, A3.x), g2 = Math.max(b2.x, w2.x, _2.x, A3.x), d2 = Math.min(b2.y, w2.y, _2.y, A3.y), m2 = Math.max(b2.y, w2.y, _2.y, A3.y);
            }
            t4.emplaceBack(e2.x, e2.y, v2, d2, g2, m2, r2, n2, a2);
          }
          this.boxEndIndex = t4.length;
        }, Qu = function(t4, e2) {
          if (void 0 === t4 && (t4 = []), void 0 === e2 && (e2 = tl), this.data = t4, this.length = this.data.length, this.compare = e2, this.length > 0)
            for (var r2 = (this.length >> 1) - 1; r2 >= 0; r2--)
              this._down(r2);
        };
        function tl(t4, e2) {
          return t4 < e2 ? -1 : t4 > e2 ? 1 : 0;
        }
        function el(t4, e2, r2) {
          void 0 === e2 && (e2 = 1), void 0 === r2 && (r2 = false);
          for (var n2 = 1 / 0, a2 = 1 / 0, o2 = -1 / 0, s2 = -1 / 0, u2 = t4[0], l2 = 0; l2 < u2.length; l2++) {
            var p2 = u2[l2];
            (!l2 || p2.x < n2) && (n2 = p2.x), (!l2 || p2.y < a2) && (a2 = p2.y), (!l2 || p2.x > o2) && (o2 = p2.x), (!l2 || p2.y > s2) && (s2 = p2.y);
          }
          var c2 = Math.min(o2 - n2, s2 - a2), h2 = c2 / 2, f2 = new Qu([], rl);
          if (0 === c2)
            return new i2(n2, a2);
          for (var y2 = n2; y2 < o2; y2 += c2)
            for (var d2 = a2; d2 < s2; d2 += c2)
              f2.push(new nl(y2 + h2, d2 + h2, h2, t4));
          for (var m2 = function(t5) {
            for (var e3 = 0, r3 = 0, n3 = 0, i3 = t5[0], a3 = 0, o3 = i3.length, s3 = o3 - 1; a3 < o3; s3 = a3++) {
              var u3 = i3[a3], l3 = i3[s3], p3 = u3.x * l3.y - l3.x * u3.y;
              r3 += (u3.x + l3.x) * p3, n3 += (u3.y + l3.y) * p3, e3 += 3 * p3;
            }
            return new nl(r3 / e3, n3 / e3, 0, t5);
          }(t4), v2 = f2.length; f2.length; ) {
            var g2 = f2.pop();
            (g2.d > m2.d || !m2.d) && (m2 = g2, r2 && console.log("found best %d after %d probes", Math.round(1e4 * g2.d) / 1e4, v2)), g2.max - m2.d <= e2 || (f2.push(new nl(g2.p.x - (h2 = g2.h / 2), g2.p.y - h2, h2, t4)), f2.push(new nl(g2.p.x + h2, g2.p.y - h2, h2, t4)), f2.push(new nl(g2.p.x - h2, g2.p.y + h2, h2, t4)), f2.push(new nl(g2.p.x + h2, g2.p.y + h2, h2, t4)), v2 += 4);
          }
          return r2 && (console.log("num probes: " + v2), console.log("best distance: " + m2.d)), m2.p;
        }
        function rl(t4, e2) {
          return e2.max - t4.max;
        }
        function nl(t4, e2, r2, n2) {
          this.p = new i2(t4, e2), this.h = r2, this.d = function(t5, e3) {
            for (var r3 = false, n3 = 1 / 0, i3 = 0; i3 < e3.length; i3++)
              for (var a2 = e3[i3], o2 = 0, s2 = a2.length, u2 = s2 - 1; o2 < s2; u2 = o2++) {
                var l2 = a2[o2], p2 = a2[u2];
                l2.y > t5.y != p2.y > t5.y && t5.x < (p2.x - l2.x) * (t5.y - l2.y) / (p2.y - l2.y) + l2.x && (r3 = !r3), n3 = Math.min(n3, Ya(t5, l2, p2));
              }
            return (r3 ? 1 : -1) * Math.sqrt(n3);
          }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
        }
        Qu.prototype.push = function(t4) {
          this.data.push(t4), this.length++, this._up(this.length - 1);
        }, Qu.prototype.pop = function() {
          if (0 !== this.length) {
            var t4 = this.data[0], e2 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t4;
          }
        }, Qu.prototype.peek = function() {
          return this.data[0];
        }, Qu.prototype._up = function(t4) {
          for (var e2 = this.data, r2 = this.compare, n2 = e2[t4]; t4 > 0; ) {
            var i3 = t4 - 1 >> 1, a2 = e2[i3];
            if (r2(n2, a2) >= 0)
              break;
            e2[t4] = a2, t4 = i3;
          }
          e2[t4] = n2;
        }, Qu.prototype._down = function(t4) {
          for (var e2 = this.data, r2 = this.compare, n2 = this.length >> 1, i3 = e2[t4]; t4 < n2; ) {
            var a2 = 1 + (t4 << 1), o2 = e2[a2], s2 = a2 + 1;
            if (s2 < this.length && r2(e2[s2], o2) < 0 && (a2 = s2, o2 = e2[s2]), r2(o2, i3) >= 0)
              break;
            e2[t4] = o2, t4 = a2;
          }
          e2[t4] = i3;
        };
        var il = Number.POSITIVE_INFINITY;
        function al(t4, e2) {
          return e2[1] !== il ? function(t5, e3, r2) {
            var n2 = 0, i3 = 0;
            switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t5) {
              case "top-right":
              case "top-left":
              case "top":
                i3 = r2 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i3 = 7 - r2;
            }
            switch (t5) {
              case "top-right":
              case "bottom-right":
              case "right":
                n2 = -e3;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n2 = e3;
            }
            return [n2, i3];
          }(t4, e2[0], e2[1]) : function(t5, e3) {
            var r2 = 0, n2 = 0;
            e3 < 0 && (e3 = 0);
            var i3 = e3 / Math.sqrt(2);
            switch (t5) {
              case "top-right":
              case "top-left":
                n2 = i3 - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                n2 = 7 - i3;
                break;
              case "bottom":
                n2 = 7 - e3;
                break;
              case "top":
                n2 = e3 - 7;
            }
            switch (t5) {
              case "top-right":
              case "bottom-right":
                r2 = -i3;
                break;
              case "top-left":
              case "bottom-left":
                r2 = i3;
                break;
              case "left":
                r2 = e3;
                break;
              case "right":
                r2 = -e3;
            }
            return [r2, n2];
          }(t4, e2[0]);
        }
        function ol(t4) {
          switch (t4) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function sl(t4, e2, r2, n2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2) {
          var m2 = function(t5, e3, r3, n3, a3, o3, s3, u3) {
            for (var l3 = n3.layout.get("text-rotate").evaluate(o3, {}) * Math.PI / 180, p3 = [], c3 = 0, h3 = e3.positionedLines; c3 < h3.length; c3 += 1)
              for (var f3 = h3[c3], y3 = 0, d3 = f3.positionedGlyphs; y3 < d3.length; y3 += 1) {
                var m3 = d3[y3];
                if (m3.rect) {
                  var v3 = m3.rect || {}, g3 = 4, x4 = true, b3 = 1, w2 = 0, _2 = (a3 || u3) && m3.vertical, A3 = m3.metrics.advance * m3.scale / 2;
                  if (u3 && e3.verticalizable && (w2 = f3.lineOffset / 2 - (m3.imageName ? -(24 - m3.metrics.width * m3.scale) / 2 : 24 * (m3.scale - 1))), m3.imageName) {
                    var S2 = s3[m3.imageName];
                    x4 = S2.sdf, g3 = 1 / (b3 = S2.pixelRatio);
                  }
                  var k2 = a3 ? [m3.x + A3, m3.y] : [0, 0], I2 = a3 ? [0, 0] : [m3.x + A3 + r3[0], m3.y + r3[1] - w2], z2 = [0, 0];
                  _2 && (z2 = I2, I2 = [0, 0]);
                  var C3 = (m3.metrics.left - g3) * m3.scale - A3 + I2[0], E3 = (-m3.metrics.top - g3) * m3.scale + I2[1], P2 = C3 + v3.w * m3.scale / b3, M2 = E3 + v3.h * m3.scale / b3, B3 = new i2(C3, E3), T3 = new i2(P2, E3), V2 = new i2(C3, M2), F2 = new i2(P2, M2);
                  if (_2) {
                    var D3 = new i2(-A3, A3 - -17), L3 = -Math.PI / 2, O2 = 12 - A3, R2 = new i2(22 - O2, -(m3.imageName ? O2 : 0)), U2 = new (Function.prototype.bind.apply(i2, [null].concat(z2)))();
                    B3._rotateAround(L3, D3)._add(R2)._add(U2), T3._rotateAround(L3, D3)._add(R2)._add(U2), V2._rotateAround(L3, D3)._add(R2)._add(U2), F2._rotateAround(L3, D3)._add(R2)._add(U2);
                  }
                  if (l3) {
                    var j2 = Math.sin(l3), q2 = Math.cos(l3), N2 = [q2, -j2, j2, q2];
                    B3._matMult(N2), T3._matMult(N2), V2._matMult(N2), F2._matMult(N2);
                  }
                  var K3 = new i2(0, 0), G2 = new i2(0, 0);
                  p3.push({ tl: B3, tr: T3, bl: V2, br: F2, tex: v3, writingMode: e3.writingMode, glyphOffset: k2, sectionIndex: m3.sectionIndex, isSDF: x4, pixelOffsetTL: K3, pixelOffsetBR: G2, minFontScaleX: 0, minFontScaleY: 0 });
                }
              }
            return p3;
          }(0, r2, u2, a2, o2, s2, n2, t4.allowVerticalPlacement), v2 = t4.textSizeData, g2 = null;
          "source" === v2.kind ? (g2 = [128 * a2.layout.get("text-size").evaluate(s2, {})])[0] > 32640 && A2(t4.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".') : "composite" === v2.kind && ((g2 = [128 * y2.compositeTextSizes[0].evaluate(s2, {}, d2), 128 * y2.compositeTextSizes[1].evaluate(s2, {}, d2)])[0] > 32640 || g2[1] > 32640) && A2(t4.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".'), t4.addSymbols(t4.text, m2, g2, u2, o2, s2, p2, e2, l2.lineStartIndex, l2.lineLength, f2, d2);
          for (var x3 = 0, b2 = c2; x3 < b2.length; x3 += 1)
            h2[b2[x3]] = t4.text.placedSymbolArray.length - 1;
          return 4 * m2.length;
        }
        function ul(t4) {
          for (var e2 in t4)
            return t4[e2];
          return null;
        }
        function ll(t4, e2, r2, n2) {
          var i3 = t4.compareText;
          if (e2 in i3) {
            for (var a2 = i3[e2], o2 = a2.length - 1; o2 >= 0; o2--)
              if (n2.dist(a2[o2]) < r2)
                return true;
          } else
            i3[e2] = [];
          return i3[e2].push(n2), false;
        }
        var pl = bs.VectorTileFeature.types, cl = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function hl(t4, e2, r2, n2, i3, a2, o2, s2, u2, l2, p2, c2, h2) {
          var f2 = s2 ? Math.min(32640, Math.round(s2[0])) : 0, y2 = s2 ? Math.min(32640, Math.round(s2[1])) : 0;
          t4.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i3), a2, o2, (f2 << 1) + (u2 ? 1 : 0), y2, 16 * l2, 16 * p2, 256 * c2, 256 * h2);
        }
        function fl2(t4, e2, r2) {
          t4.emplaceBack(e2.x, e2.y, r2), t4.emplaceBack(e2.x, e2.y, r2), t4.emplaceBack(e2.x, e2.y, r2), t4.emplaceBack(e2.x, e2.y, r2);
        }
        function yl(t4) {
          for (var e2 = 0, r2 = t4.sections; e2 < r2.length; e2 += 1)
            if ($n(r2[e2].text))
              return true;
          return false;
        }
        var dl = function(t4) {
          this.layoutVertexArray = new Vi(), this.indexArray = new ji(), this.programConfigurations = t4, this.segments = new sa(), this.dynamicLayoutVertexArray = new Fi(), this.opacityVertexArray = new Di(), this.placedSymbolArray = new Qi();
        };
        dl.prototype.isEmpty = function() {
          return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
        }, dl.prototype.upload = function(t4, e2, r2, n2) {
          this.isEmpty() || (r2 && (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, js.members), this.indexBuffer = t4.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t4.createVertexBuffer(this.dynamicLayoutVertexArray, qs.members, true), this.opacityVertexBuffer = t4.createVertexBuffer(this.opacityVertexArray, cl, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t4));
        }, dl.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }, On("SymbolBuffers", dl);
        var ml = function(t4, e2, r2) {
          this.layoutVertexArray = new t4(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new sa(), this.collisionVertexArray = new Ui();
        };
        ml.prototype.upload = function(t4) {
          this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t4.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t4.createVertexBuffer(this.collisionVertexArray, Ns.members, true);
        }, ml.prototype.destroy = function() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }, On("CollisionBuffers", ml);
        var vl = function(t4) {
          this.collisionBoxArray = t4.collisionBoxArray, this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map(function(t5) {
            return t5.id;
          }), this.index = t4.index, this.pixelRatio = t4.pixelRatio, this.sourceLayerIndex = t4.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = oo([]), this.placementViewportMatrix = oo([]);
          var e2 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = Du(this.zoom, e2["text-size"]), this.iconSizeData = Du(this.zoom, e2["icon-size"]);
          var r2 = this.layers[0].layout, n2 = r2.get("symbol-sort-key"), i3 = r2.get("symbol-z-order");
          this.canOverlap = r2.get("text-allow-overlap") || r2.get("icon-allow-overlap") || r2.get("text-ignore-placement") || r2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i3 && void 0 !== n2.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i3 || "auto" === i3 && !this.sortFeaturesByKey) && this.canOverlap, "point" === r2.get("symbol-placement") && (this.writingModes = r2.get("text-writing-mode").map(function(t5) {
            return wu[t5];
          })), this.stateDependentLayerIds = this.layers.filter(function(t5) {
            return t5.isStateDependent();
          }).map(function(t5) {
            return t5.id;
          }), this.sourceID = t4.sourceID;
        };
        vl.prototype.createArrays = function() {
          this.text = new dl(new Va(this.layers, this.zoom, function(t4) {
            return /^text/.test(t4);
          })), this.icon = new dl(new Va(this.layers, this.zoom, function(t4) {
            return /^icon/.test(t4);
          })), this.glyphOffsetArray = new ra(), this.lineVertexArray = new na(), this.symbolInstances = new ea();
        }, vl.prototype.calculateGlyphDependencies = function(t4, e2, r2, n2, i3) {
          for (var a2 = 0; a2 < t4.length; a2++)
            if (e2[t4.charCodeAt(a2)] = true, (r2 || n2) && i3) {
              var o2 = Xs[t4.charAt(a2)];
              o2 && (e2[o2.charCodeAt(0)] = true);
            }
        }, vl.prototype.populate = function(t4, e2, r2) {
          var n2 = this.layers[0], i3 = n2.layout, a2 = i3.get("text-font"), o2 = i3.get("text-field"), s2 = i3.get("icon-image"), u2 = ("constant" !== o2.value.kind || o2.value.value instanceof ne && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && ("constant" !== a2.value.kind || a2.value.value.length > 0), l2 = "constant" !== s2.value.kind || !!s2.value.value || Object.keys(s2.parameters).length > 0, p2 = i3.get("symbol-sort-key");
          if (this.features = [], u2 || l2) {
            for (var c2 = e2.iconDependencies, h2 = e2.glyphDependencies, f2 = e2.availableImages, y2 = new si(this.zoom), d2 = 0, m2 = t4; d2 < m2.length; d2 += 1) {
              var v2 = m2[d2], g2 = v2.feature, x3 = v2.id, b2 = v2.index, w2 = v2.sourceLayerIndex, _2 = n2._featureFilter.needGeometry, A3 = Ua(g2, _2);
              if (n2._featureFilter.filter(y2, A3, r2)) {
                _2 || (A3.geometry = Ra(g2));
                var S2 = void 0;
                if (u2) {
                  var k2 = n2.getValueAndResolveTokens("text-field", A3, r2, f2), I2 = ne.factory(k2);
                  yl(I2) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === ii() || this.hasRTLText && oi.isParsed()) && (S2 = Zs(I2, n2, A3));
                }
                var z2 = void 0;
                if (l2) {
                  var C3 = n2.getValueAndResolveTokens("icon-image", A3, r2, f2);
                  z2 = C3 instanceof ie ? C3 : ie.fromString(C3);
                }
                if (S2 || z2) {
                  var E3 = this.sortFeaturesByKey ? p2.evaluate(A3, {}, r2) : void 0;
                  if (this.features.push({ id: x3, text: S2, icon: z2, index: b2, sourceLayerIndex: w2, geometry: A3.geometry, properties: g2.properties, type: pl[g2.type], sortKey: E3 }), z2 && (c2[z2.name] = true), S2) {
                    var P2 = a2.evaluate(A3, {}, r2).join(","), M2 = "map" === i3.get("text-rotation-alignment") && "point" !== i3.get("symbol-placement");
                    this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(wu.vertical) >= 0;
                    for (var B3 = 0, T3 = S2.sections; B3 < T3.length; B3 += 1) {
                      var V2 = T3[B3];
                      if (V2.image)
                        c2[V2.image.name] = true;
                      else {
                        var F2 = Zn2(S2.toString()), D3 = V2.fontStack || P2, L3 = h2[D3] = h2[D3] || {};
                        this.calculateGlyphDependencies(V2.text, L3, M2, this.allowVerticalPlacement, F2);
                      }
                    }
                  }
                }
              }
            }
            "line" === i3.get("symbol-placement") && (this.features = function(t5) {
              var e3 = {}, r3 = {}, n3 = [], i4 = 0;
              function a3(e4) {
                n3.push(t5[e4]), i4++;
              }
              function o3(t6, e4, i5) {
                var a4 = r3[t6];
                return delete r3[t6], r3[e4] = a4, n3[a4].geometry[0].pop(), n3[a4].geometry[0] = n3[a4].geometry[0].concat(i5[0]), a4;
              }
              function s3(t6, r4, i5) {
                var a4 = e3[r4];
                return delete e3[r4], e3[t6] = a4, n3[a4].geometry[0].shift(), n3[a4].geometry[0] = i5[0].concat(n3[a4].geometry[0]), a4;
              }
              function u3(t6, e4, r4) {
                var n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                return t6 + ":" + n4.x + ":" + n4.y;
              }
              for (var l3 = 0; l3 < t5.length; l3++) {
                var p3 = t5[l3], c3 = p3.geometry, h3 = p3.text ? p3.text.toString() : null;
                if (h3) {
                  var f3 = u3(h3, c3), y3 = u3(h3, c3, true);
                  if (f3 in r3 && y3 in e3 && r3[f3] !== e3[y3]) {
                    var d3 = s3(f3, y3, c3), m3 = o3(f3, y3, n3[d3].geometry);
                    delete e3[f3], delete r3[y3], r3[u3(h3, n3[m3].geometry, true)] = m3, n3[d3].geometry = null;
                  } else
                    f3 in r3 ? o3(f3, y3, c3) : y3 in e3 ? s3(f3, y3, c3) : (a3(l3), e3[f3] = i4 - 1, r3[y3] = i4 - 1);
                } else
                  a3(l3);
              }
              return n3.filter(function(t6) {
                return t6.geometry;
              });
            }(this.features)), this.sortFeaturesByKey && this.features.sort(function(t5, e3) {
              return t5.sortKey - e3.sortKey;
            });
          }
        }, vl.prototype.update = function(t4, e2, r2) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t4, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t4, e2, this.layers, r2));
        }, vl.prototype.isEmpty = function() {
          return 0 === this.symbolInstances.length && !this.hasRTLText;
        }, vl.prototype.uploadPending = function() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }, vl.prototype.upload = function(t4) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t4), this.iconCollisionBox.upload(t4)), this.text.upload(t4, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t4, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
        }, vl.prototype.destroyDebugData = function() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }, vl.prototype.destroy = function() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }, vl.prototype.addToLineVertexArray = function(t4, e2) {
          var r2 = this.lineVertexArray.length;
          if (void 0 !== t4.segment) {
            for (var n2 = t4.dist(e2[t4.segment + 1]), i3 = t4.dist(e2[t4.segment]), a2 = {}, o2 = t4.segment + 1; o2 < e2.length; o2++)
              a2[o2] = { x: e2[o2].x, y: e2[o2].y, tileUnitDistanceFromAnchor: n2 }, o2 < e2.length - 1 && (n2 += e2[o2 + 1].dist(e2[o2]));
            for (var s2 = t4.segment || 0; s2 >= 0; s2--)
              a2[s2] = { x: e2[s2].x, y: e2[s2].y, tileUnitDistanceFromAnchor: i3 }, s2 > 0 && (i3 += e2[s2 - 1].dist(e2[s2]));
            for (var u2 = 0; u2 < e2.length; u2++) {
              var l2 = a2[u2];
              this.lineVertexArray.emplaceBack(l2.x, l2.y, l2.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
        }, vl.prototype.addSymbols = function(t4, e2, r2, n2, i3, a2, o2, s2, u2, l2, p2, c2) {
          for (var h2 = t4.indexArray, f2 = t4.layoutVertexArray, y2 = t4.segments.prepareSegment(4 * e2.length, f2, h2, this.canOverlap ? a2.sortKey : void 0), d2 = this.glyphOffsetArray.length, m2 = y2.vertexLength, v2 = this.allowVerticalPlacement && o2 === wu.vertical ? Math.PI / 2 : 0, g2 = a2.text && a2.text.sections, x3 = 0; x3 < e2.length; x3++) {
            var b2 = e2[x3], w2 = b2.tl, _2 = b2.tr, A3 = b2.bl, S2 = b2.br, k2 = b2.tex, I2 = b2.pixelOffsetTL, z2 = b2.pixelOffsetBR, C3 = b2.minFontScaleX, E3 = b2.minFontScaleY, P2 = b2.glyphOffset, M2 = b2.isSDF, B3 = b2.sectionIndex, T3 = y2.vertexLength, V2 = P2[1];
            hl(f2, s2.x, s2.y, w2.x, V2 + w2.y, k2.x, k2.y, r2, M2, I2.x, I2.y, C3, E3), hl(f2, s2.x, s2.y, _2.x, V2 + _2.y, k2.x + k2.w, k2.y, r2, M2, z2.x, I2.y, C3, E3), hl(f2, s2.x, s2.y, A3.x, V2 + A3.y, k2.x, k2.y + k2.h, r2, M2, I2.x, z2.y, C3, E3), hl(f2, s2.x, s2.y, S2.x, V2 + S2.y, k2.x + k2.w, k2.y + k2.h, r2, M2, z2.x, z2.y, C3, E3), fl2(t4.dynamicLayoutVertexArray, s2, v2), h2.emplaceBack(T3, T3 + 1, T3 + 2), h2.emplaceBack(T3 + 1, T3 + 2, T3 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P2[0]), x3 !== e2.length - 1 && B3 === e2[x3 + 1].sectionIndex || t4.programConfigurations.populatePaintArrays(f2.length, a2, a2.index, {}, c2, g2 && g2[B3]);
          }
          t4.placedSymbolArray.emplaceBack(s2.x, s2.y, d2, this.glyphOffsetArray.length - d2, m2, u2, l2, s2.segment, r2 ? r2[0] : 0, r2 ? r2[1] : 0, n2[0], n2[1], o2, 0, false, 0, p2);
        }, vl.prototype._addCollisionDebugVertex = function(t4, e2, r2, n2, i3, a2) {
          return e2.emplaceBack(0, 0), t4.emplaceBack(r2.x, r2.y, n2, i3, Math.round(a2.x), Math.round(a2.y));
        }, vl.prototype.addCollisionDebugVertices = function(t4, e2, r2, n2, a2, o2, s2) {
          var u2 = a2.segments.prepareSegment(4, a2.layoutVertexArray, a2.indexArray), l2 = u2.vertexLength, p2 = a2.layoutVertexArray, c2 = a2.collisionVertexArray, h2 = s2.anchorX, f2 = s2.anchorY;
          this._addCollisionDebugVertex(p2, c2, o2, h2, f2, new i2(t4, e2)), this._addCollisionDebugVertex(p2, c2, o2, h2, f2, new i2(r2, e2)), this._addCollisionDebugVertex(p2, c2, o2, h2, f2, new i2(r2, n2)), this._addCollisionDebugVertex(p2, c2, o2, h2, f2, new i2(t4, n2)), u2.vertexLength += 4;
          var y2 = a2.indexArray;
          y2.emplaceBack(l2, l2 + 1), y2.emplaceBack(l2 + 1, l2 + 2), y2.emplaceBack(l2 + 2, l2 + 3), y2.emplaceBack(l2 + 3, l2), u2.primitiveLength += 4;
        }, vl.prototype.addDebugCollisionBoxes = function(t4, e2, r2, n2) {
          for (var i3 = t4; i3 < e2; i3++) {
            var a2 = this.collisionBoxArray.get(i3);
            this.addCollisionDebugVertices(a2.x1, a2.y1, a2.x2, a2.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, a2.anchorPoint, r2);
          }
        }, vl.prototype.generateCollisionDebugBuffers = function() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ml(Oi, Ks.members, Xi), this.iconCollisionBox = new ml(Oi, Ks.members, Xi);
          for (var t4 = 0; t4 < this.symbolInstances.length; t4++) {
            var e2 = this.symbolInstances.get(t4);
            this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
          }
        }, vl.prototype._deserializeCollisionBoxesForSymbol = function(t4, e2, r2, n2, i3, a2, o2, s2, u2) {
          for (var l2 = {}, p2 = e2; p2 < r2; p2++) {
            var c2 = t4.get(p2);
            l2.textBox = { x1: c2.x1, y1: c2.y1, x2: c2.x2, y2: c2.y2, anchorPointX: c2.anchorPointX, anchorPointY: c2.anchorPointY }, l2.textFeatureIndex = c2.featureIndex;
            break;
          }
          for (var h2 = n2; h2 < i3; h2++) {
            var f2 = t4.get(h2);
            l2.verticalTextBox = { x1: f2.x1, y1: f2.y1, x2: f2.x2, y2: f2.y2, anchorPointX: f2.anchorPointX, anchorPointY: f2.anchorPointY }, l2.verticalTextFeatureIndex = f2.featureIndex;
            break;
          }
          for (var y2 = a2; y2 < o2; y2++) {
            var d2 = t4.get(y2);
            l2.iconBox = { x1: d2.x1, y1: d2.y1, x2: d2.x2, y2: d2.y2, anchorPointX: d2.anchorPointX, anchorPointY: d2.anchorPointY }, l2.iconFeatureIndex = d2.featureIndex;
            break;
          }
          for (var m2 = s2; m2 < u2; m2++) {
            var v2 = t4.get(m2);
            l2.verticalIconBox = { x1: v2.x1, y1: v2.y1, x2: v2.x2, y2: v2.y2, anchorPointX: v2.anchorPointX, anchorPointY: v2.anchorPointY }, l2.verticalIconFeatureIndex = v2.featureIndex;
            break;
          }
          return l2;
        }, vl.prototype.deserializeCollisionBoxes = function(t4) {
          this.collisionArrays = [];
          for (var e2 = 0; e2 < this.symbolInstances.length; e2++) {
            var r2 = this.symbolInstances.get(e2);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t4, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
          }
        }, vl.prototype.hasTextData = function() {
          return this.text.segments.get().length > 0;
        }, vl.prototype.hasIconData = function() {
          return this.icon.segments.get().length > 0;
        }, vl.prototype.hasDebugData = function() {
          return this.textCollisionBox && this.iconCollisionBox;
        }, vl.prototype.hasTextCollisionBoxData = function() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }, vl.prototype.hasIconCollisionBoxData = function() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }, vl.prototype.addIndicesForPlacedSymbol = function(t4, e2) {
          for (var r2 = t4.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs, i3 = r2.vertexStartIndex; i3 < n2; i3 += 4)
            t4.indexArray.emplaceBack(i3, i3 + 1, i3 + 2), t4.indexArray.emplaceBack(i3 + 1, i3 + 2, i3 + 3);
        }, vl.prototype.getSortedSymbolIndexes = function(t4) {
          if (this.sortedAngle === t4 && void 0 !== this.symbolInstanceIndexes)
            return this.symbolInstanceIndexes;
          for (var e2 = Math.sin(t4), r2 = Math.cos(t4), n2 = [], i3 = [], a2 = [], o2 = 0; o2 < this.symbolInstances.length; ++o2) {
            a2.push(o2);
            var s2 = this.symbolInstances.get(o2);
            n2.push(0 | Math.round(e2 * s2.anchorX + r2 * s2.anchorY)), i3.push(s2.featureIndex);
          }
          return a2.sort(function(t5, e3) {
            return n2[t5] - n2[e3] || i3[e3] - i3[t5];
          }), a2;
        }, vl.prototype.addToSortKeyRanges = function(t4, e2) {
          var r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t4 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t4, symbolInstanceEnd: t4 + 1 });
        }, vl.prototype.sortFeatures = function(t4) {
          var e2 = this;
          if (this.sortFeaturesByY && this.sortedAngle !== t4 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t4), this.sortedAngle = t4, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (var r2 = 0, n2 = this.symbolInstanceIndexes; r2 < n2.length; r2 += 1) {
              var i3 = this.symbolInstances.get(n2[r2]);
              this.featureSortOrder.push(i3.featureIndex), [i3.rightJustifiedTextSymbolIndex, i3.centerJustifiedTextSymbolIndex, i3.leftJustifiedTextSymbolIndex].forEach(function(t5, r3, n3) {
                t5 >= 0 && n3.indexOf(t5) === r3 && e2.addIndicesForPlacedSymbol(e2.text, t5);
              }), i3.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, i3.verticalPlacedTextSymbolIndex), i3.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i3.placedIconSymbolIndex), i3.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i3.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }, On("SymbolBucket", vl, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), vl.MAX_GLYPHS = 65535, vl.addDynamicAttributes = fl2;
        var gl2 = new wi({ "symbol-placement": new mi(Et.layout_symbol["symbol-placement"]), "symbol-spacing": new mi(Et.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new mi(Et.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new vi(Et.layout_symbol["symbol-sort-key"]), "symbol-z-order": new mi(Et.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new mi(Et.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new mi(Et.layout_symbol["icon-ignore-placement"]), "icon-optional": new mi(Et.layout_symbol["icon-optional"]), "icon-rotation-alignment": new mi(Et.layout_symbol["icon-rotation-alignment"]), "icon-size": new vi(Et.layout_symbol["icon-size"]), "icon-text-fit": new mi(Et.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new mi(Et.layout_symbol["icon-text-fit-padding"]), "icon-image": new vi(Et.layout_symbol["icon-image"]), "icon-rotate": new vi(Et.layout_symbol["icon-rotate"]), "icon-padding": new mi(Et.layout_symbol["icon-padding"]), "icon-keep-upright": new mi(Et.layout_symbol["icon-keep-upright"]), "icon-offset": new vi(Et.layout_symbol["icon-offset"]), "icon-anchor": new vi(Et.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new mi(Et.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new mi(Et.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new mi(Et.layout_symbol["text-rotation-alignment"]), "text-field": new vi(Et.layout_symbol["text-field"]), "text-font": new vi(Et.layout_symbol["text-font"]), "text-size": new vi(Et.layout_symbol["text-size"]), "text-max-width": new vi(Et.layout_symbol["text-max-width"]), "text-line-height": new mi(Et.layout_symbol["text-line-height"]), "text-letter-spacing": new vi(Et.layout_symbol["text-letter-spacing"]), "text-justify": new vi(Et.layout_symbol["text-justify"]), "text-radial-offset": new vi(Et.layout_symbol["text-radial-offset"]), "text-variable-anchor": new mi(Et.layout_symbol["text-variable-anchor"]), "text-anchor": new vi(Et.layout_symbol["text-anchor"]), "text-max-angle": new mi(Et.layout_symbol["text-max-angle"]), "text-writing-mode": new mi(Et.layout_symbol["text-writing-mode"]), "text-rotate": new vi(Et.layout_symbol["text-rotate"]), "text-padding": new mi(Et.layout_symbol["text-padding"]), "text-keep-upright": new mi(Et.layout_symbol["text-keep-upright"]), "text-transform": new vi(Et.layout_symbol["text-transform"]), "text-offset": new vi(Et.layout_symbol["text-offset"]), "text-allow-overlap": new mi(Et.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new mi(Et.layout_symbol["text-ignore-placement"]), "text-optional": new mi(Et.layout_symbol["text-optional"]) }), xl = { paint: new wi({ "icon-opacity": new vi(Et.paint_symbol["icon-opacity"]), "icon-color": new vi(Et.paint_symbol["icon-color"]), "icon-halo-color": new vi(Et.paint_symbol["icon-halo-color"]), "icon-halo-width": new vi(Et.paint_symbol["icon-halo-width"]), "icon-halo-blur": new vi(Et.paint_symbol["icon-halo-blur"]), "icon-translate": new mi(Et.paint_symbol["icon-translate"]), "icon-translate-anchor": new mi(Et.paint_symbol["icon-translate-anchor"]), "text-opacity": new vi(Et.paint_symbol["text-opacity"]), "text-color": new vi(Et.paint_symbol["text-color"], { runtimeType: jt, getOverride: function(t4) {
          return t4.textColor;
        }, hasOverride: function(t4) {
          return !!t4.textColor;
        } }), "text-halo-color": new vi(Et.paint_symbol["text-halo-color"]), "text-halo-width": new vi(Et.paint_symbol["text-halo-width"]), "text-halo-blur": new vi(Et.paint_symbol["text-halo-blur"]), "text-translate": new mi(Et.paint_symbol["text-translate"]), "text-translate-anchor": new mi(Et.paint_symbol["text-translate-anchor"]) }), layout: gl2 }, bl = function(t4) {
          this.type = t4.property.overrides ? t4.property.overrides.runtimeType : Lt, this.defaultValue = t4;
        };
        bl.prototype.evaluate = function(t4) {
          if (t4.formattedSection) {
            var e2 = this.defaultValue.property.overrides;
            if (e2 && e2.hasOverride(t4.formattedSection))
              return e2.getOverride(t4.formattedSection);
          }
          return t4.feature && t4.featureState ? this.defaultValue.evaluate(t4.feature, t4.featureState) : this.defaultValue.property.specification.default;
        }, bl.prototype.eachChild = function(t4) {
          this.defaultValue.isConstant() || t4(this.defaultValue.value._styleExpression.expression);
        }, bl.prototype.outputDefined = function() {
          return false;
        }, bl.prototype.serialize = function() {
          return null;
        }, On("FormatSectionOverride", bl, { omit: ["defaultValue"] });
        var wl = function(t4) {
          function e2(e3) {
            t4.call(this, e3, xl);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.recalculate = function(e3, r2) {
            if (t4.prototype.recalculate.call(this, e3, r2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
              var n2 = this.layout.get("text-writing-mode");
              if (n2) {
                for (var i3 = [], a2 = 0, o2 = n2; a2 < o2.length; a2 += 1) {
                  var s2 = o2[a2];
                  i3.indexOf(s2) < 0 && i3.push(s2);
                }
                this.layout._values["text-writing-mode"] = i3;
              } else
                this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }, e2.prototype.getValueAndResolveTokens = function(t5, e3, r2, n2) {
            var i3 = this.layout.get(t5).evaluate(e3, {}, r2, n2), a2 = this._unevaluatedLayout._values[t5];
            return a2.isDataDriven() || Gr(a2.value) || !i3 ? i3 : function(t6, e4) {
              return e4.replace(/{([^{}]+)}/g, function(e5, r3) {
                return r3 in t6 ? String(t6[r3]) : "";
              });
            }(e3.properties, i3);
          }, e2.prototype.createBucket = function(t5) {
            return new vl(t5);
          }, e2.prototype.queryRadius = function() {
            return 0;
          }, e2.prototype.queryIntersectsFeature = function() {
            return false;
          }, e2.prototype._setPaintOverrides = function() {
            for (var t5 = 0, r2 = xl.paint.overridableProperties; t5 < r2.length; t5 += 1) {
              var n2 = r2[t5];
              if (e2.hasPaintOverride(this.layout, n2)) {
                var i3, a2 = this.paint.get(n2), o2 = new bl(a2), s2 = new Kr(o2, a2.property.specification);
                i3 = "constant" === a2.value.kind || "source" === a2.value.kind ? new Xr("source", s2) : new Jr("composite", s2, a2.value.zoomStops, a2.value._interpolationType), this.paint._values[n2] = new yi(a2.property, i3, a2.parameters);
              }
            }
          }, e2.prototype._handleOverridablePaintPropertyUpdate = function(t5, r2, n2) {
            return !(!this.layout || r2.isDataDriven() || n2.isDataDriven()) && e2.hasPaintOverride(this.layout, t5);
          }, e2.hasPaintOverride = function(t5, e3) {
            var r2 = t5.get("text-field"), n2 = xl.paint.properties[e3], i3 = false, a2 = function(t6) {
              for (var e4 = 0, r3 = t6; e4 < r3.length; e4 += 1)
                if (n2.overrides && n2.overrides.hasOverride(r3[e4]))
                  return void (i3 = true);
            };
            if ("constant" === r2.value.kind && r2.value.value instanceof ne)
              a2(r2.value.value.sections);
            else if ("source" === r2.value.kind) {
              var o2 = function(t6) {
                i3 || (t6 instanceof le && se(t6.value) === Gt ? a2(t6.value.sections) : t6 instanceof fe ? a2(t6.sections) : t6.eachChild(o2));
              }, s2 = r2.value;
              s2._styleExpression && o2(s2._styleExpression.expression);
            }
            return i3;
          }, e2;
        }(_i), _l = { paint: new wi({ "background-color": new mi(Et.paint_background["background-color"]), "background-pattern": new xi(Et.paint_background["background-pattern"]), "background-opacity": new mi(Et.paint_background["background-opacity"]) }) }, Al = function(t4) {
          function e2(e3) {
            t4.call(this, e3, _l);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2;
        }(_i), Sl = { paint: new wi({ "raster-opacity": new mi(Et.paint_raster["raster-opacity"]), "raster-hue-rotate": new mi(Et.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new mi(Et.paint_raster["raster-brightness-min"]), "raster-brightness-max": new mi(Et.paint_raster["raster-brightness-max"]), "raster-saturation": new mi(Et.paint_raster["raster-saturation"]), "raster-contrast": new mi(Et.paint_raster["raster-contrast"]), "raster-resampling": new mi(Et.paint_raster["raster-resampling"]), "raster-fade-duration": new mi(Et.paint_raster["raster-fade-duration"]) }) }, kl = function(t4) {
          function e2(e3) {
            t4.call(this, e3, Sl);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2;
        }(_i), Il = function(t4) {
          function e2(e3) {
            t4.call(this, e3, {}), this.implementation = e3;
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.is3D = function() {
            return "3d" === this.implementation.renderingMode;
          }, e2.prototype.hasOffscreenPass = function() {
            return void 0 !== this.implementation.prerender;
          }, e2.prototype.recalculate = function() {
          }, e2.prototype.updateTransitions = function() {
          }, e2.prototype.hasTransition = function() {
          }, e2.prototype.serialize = function() {
          }, e2.prototype.onAdd = function(t5) {
            this.implementation.onAdd && this.implementation.onAdd(t5, t5.painter.context.gl);
          }, e2.prototype.onRemove = function(t5) {
            this.implementation.onRemove && this.implementation.onRemove(t5, t5.painter.context.gl);
          }, e2;
        }(_i), zl = { circle: co, heatmap: _o, hillshade: So, fill: ps, "fill-extrusion": zs, line: Rs, symbol: wl, background: Al, raster: kl }, Cl = o.HTMLImageElement, El = o.HTMLCanvasElement, Pl = o.HTMLVideoElement, Ml = o.ImageData, Bl = o.ImageBitmap, Tl = function(t4, e2, r2, n2) {
          this.context = t4, this.format = r2, this.texture = t4.gl.createTexture(), this.update(e2, n2);
        };
        Tl.prototype.update = function(t4, e2, r2) {
          var n2 = t4.width, i3 = t4.height, a2 = !(this.size && this.size[0] === n2 && this.size[1] === i3 || r2), o2 = this.context, s2 = o2.gl;
          if (this.useMipmap = Boolean(e2 && e2.useMipmap), s2.bindTexture(s2.TEXTURE_2D, this.texture), o2.pixelStoreUnpackFlipY.set(false), o2.pixelStoreUnpack.set(1), o2.pixelStoreUnpackPremultiplyAlpha.set(this.format === s2.RGBA && (!e2 || false !== e2.premultiply)), a2)
            this.size = [n2, i3], t4 instanceof Cl || t4 instanceof El || t4 instanceof Pl || t4 instanceof Ml || Bl && t4 instanceof Bl ? s2.texImage2D(s2.TEXTURE_2D, 0, this.format, this.format, s2.UNSIGNED_BYTE, t4) : s2.texImage2D(s2.TEXTURE_2D, 0, this.format, n2, i3, 0, this.format, s2.UNSIGNED_BYTE, t4.data);
          else {
            var u2 = r2 || { x: 0, y: 0 }, l2 = u2.x, p2 = u2.y;
            t4 instanceof Cl || t4 instanceof El || t4 instanceof Pl || t4 instanceof Ml || Bl && t4 instanceof Bl ? s2.texSubImage2D(s2.TEXTURE_2D, 0, l2, p2, s2.RGBA, s2.UNSIGNED_BYTE, t4) : s2.texSubImage2D(s2.TEXTURE_2D, 0, l2, p2, n2, i3, s2.RGBA, s2.UNSIGNED_BYTE, t4.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && s2.generateMipmap(s2.TEXTURE_2D);
        }, Tl.prototype.bind = function(t4, e2, r2) {
          var n2 = this.context.gl;
          n2.bindTexture(n2.TEXTURE_2D, this.texture), r2 !== n2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r2 = n2.LINEAR), t4 !== this.filter && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MAG_FILTER, t4), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, r2 || t4), this.filter = t4), e2 !== this.wrap && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, e2), this.wrap = e2);
        }, Tl.prototype.isSizePowerOfTwo = function() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }, Tl.prototype.destroy = function() {
          this.context.gl.deleteTexture(this.texture), this.texture = null;
        };
        var Vl = function(t4) {
          var e2 = this;
          this._callback = t4, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = function() {
            e2._triggered = false, e2._callback();
          });
        };
        Vl.prototype.trigger = function() {
          var t4 = this;
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(function() {
            t4._triggered = false, t4._callback();
          }, 0));
        }, Vl.prototype.remove = function() {
          delete this._channel, this._callback = function() {
          };
        };
        var Fl = function(t4, e2, r2) {
          this.target = t4, this.parent = e2, this.mapId = r2, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, v(["receive", "process"], this), this.invoker = new Vl(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = I() ? t4 : o;
        };
        function Dl(t4, e2, r2) {
          var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
          return [t4 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
        }
        Fl.prototype.send = function(t4, e2, r2, n2, i3) {
          var a2 = this;
          void 0 === i3 && (i3 = false);
          var o2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          r2 && (this.callbacks[o2] = r2);
          var s2 = E2(this.globalScope) ? void 0 : [];
          return this.target.postMessage({ id: o2, type: t4, hasCallback: !!r2, targetMapId: n2, mustQueue: i3, sourceMapId: this.mapId, data: qn(e2, s2) }, s2), { cancel: function() {
            r2 && delete a2.callbacks[o2], a2.target.postMessage({ id: o2, type: "<cancel>", targetMapId: n2, sourceMapId: a2.mapId });
          } };
        }, Fl.prototype.receive = function(t4) {
          var e2 = t4.data, r2 = e2.id;
          if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId))
            if ("<cancel>" === e2.type) {
              delete this.tasks[r2];
              var n2 = this.cancelCallbacks[r2];
              delete this.cancelCallbacks[r2], n2 && n2();
            } else
              I() || e2.mustQueue ? (this.tasks[r2] = e2, this.taskQueue.push(r2), this.invoker.trigger()) : this.processTask(r2, e2);
        }, Fl.prototype.process = function() {
          if (this.taskQueue.length) {
            var t4 = this.taskQueue.shift(), e2 = this.tasks[t4];
            delete this.tasks[t4], this.taskQueue.length && this.invoker.trigger(), e2 && this.processTask(t4, e2);
          }
        }, Fl.prototype.processTask = function(t4, e2) {
          var r2 = this;
          if ("<response>" === e2.type) {
            var n2 = this.callbacks[t4];
            delete this.callbacks[t4], n2 && (e2.error ? n2(Nn(e2.error)) : n2(null, Nn(e2.data)));
          } else {
            var i3 = false, a2 = E2(this.globalScope) ? void 0 : [], o2 = e2.hasCallback ? function(e3, n3) {
              i3 = true, delete r2.cancelCallbacks[t4], r2.target.postMessage({ id: t4, type: "<response>", sourceMapId: r2.mapId, error: e3 ? qn(e3) : null, data: qn(n3, a2) }, a2);
            } : function(t5) {
              i3 = true;
            }, s2 = null, u2 = Nn(e2.data);
            if (this.parent[e2.type])
              s2 = this.parent[e2.type](e2.sourceMapId, u2, o2);
            else if (this.parent.getWorkerSource) {
              var l2 = e2.type.split(".");
              s2 = this.parent.getWorkerSource(e2.sourceMapId, l2[0], u2.source)[l2[1]](u2, o2);
            } else
              o2(new Error("Could not find function " + e2.type));
            !i3 && s2 && s2.cancel && (this.cancelCallbacks[t4] = s2.cancel);
          }
        }, Fl.prototype.remove = function() {
          this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
        };
        var Ll = function(t4, e2) {
          t4 && (e2 ? this.setSouthWest(t4).setNorthEast(e2) : 4 === t4.length ? this.setSouthWest([t4[0], t4[1]]).setNorthEast([t4[2], t4[3]]) : this.setSouthWest(t4[0]).setNorthEast(t4[1]));
        };
        Ll.prototype.setNorthEast = function(t4) {
          return this._ne = t4 instanceof Ol ? new Ol(t4.lng, t4.lat) : Ol.convert(t4), this;
        }, Ll.prototype.setSouthWest = function(t4) {
          return this._sw = t4 instanceof Ol ? new Ol(t4.lng, t4.lat) : Ol.convert(t4), this;
        }, Ll.prototype.extend = function(t4) {
          var e2, r2, n2 = this._sw, i3 = this._ne;
          if (t4 instanceof Ol)
            e2 = t4, r2 = t4;
          else {
            if (!(t4 instanceof Ll))
              return Array.isArray(t4) ? 4 === t4.length || t4.every(Array.isArray) ? this.extend(Ll.convert(t4)) : this.extend(Ol.convert(t4)) : this;
            if (r2 = t4._ne, !(e2 = t4._sw) || !r2)
              return this;
          }
          return n2 || i3 ? (n2.lng = Math.min(e2.lng, n2.lng), n2.lat = Math.min(e2.lat, n2.lat), i3.lng = Math.max(r2.lng, i3.lng), i3.lat = Math.max(r2.lat, i3.lat)) : (this._sw = new Ol(e2.lng, e2.lat), this._ne = new Ol(r2.lng, r2.lat)), this;
        }, Ll.prototype.getCenter = function() {
          return new Ol((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }, Ll.prototype.getSouthWest = function() {
          return this._sw;
        }, Ll.prototype.getNorthEast = function() {
          return this._ne;
        }, Ll.prototype.getNorthWest = function() {
          return new Ol(this.getWest(), this.getNorth());
        }, Ll.prototype.getSouthEast = function() {
          return new Ol(this.getEast(), this.getSouth());
        }, Ll.prototype.getWest = function() {
          return this._sw.lng;
        }, Ll.prototype.getSouth = function() {
          return this._sw.lat;
        }, Ll.prototype.getEast = function() {
          return this._ne.lng;
        }, Ll.prototype.getNorth = function() {
          return this._ne.lat;
        }, Ll.prototype.toArray = function() {
          return [this._sw.toArray(), this._ne.toArray()];
        }, Ll.prototype.toString = function() {
          return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")";
        }, Ll.prototype.isEmpty = function() {
          return !(this._sw && this._ne);
        }, Ll.prototype.contains = function(t4) {
          var e2 = Ol.convert(t4), r2 = e2.lng, n2 = e2.lat, i3 = this._sw.lng <= r2 && r2 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (i3 = this._sw.lng >= r2 && r2 >= this._ne.lng), this._sw.lat <= n2 && n2 <= this._ne.lat && i3;
        }, Ll.convert = function(t4) {
          return !t4 || t4 instanceof Ll ? t4 : new Ll(t4);
        };
        var Ol = function(t4, e2) {
          if (isNaN(t4) || isNaN(e2))
            throw new Error("Invalid LngLat object: (" + t4 + ", " + e2 + ")");
          if (this.lng = +t4, this.lat = +e2, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        };
        Ol.prototype.wrap = function() {
          return new Ol(c(this.lng, -180, 180), this.lat);
        }, Ol.prototype.toArray = function() {
          return [this.lng, this.lat];
        }, Ol.prototype.toString = function() {
          return "LngLat(" + this.lng + ", " + this.lat + ")";
        }, Ol.prototype.distanceTo = function(t4) {
          var e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t4.lat * e2, i3 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t4.lng - this.lng) * e2);
          return 63710088e-1 * Math.acos(Math.min(i3, 1));
        }, Ol.prototype.toBounds = function(t4) {
          void 0 === t4 && (t4 = 0);
          var e2 = 360 * t4 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
          return new Ll(new Ol(this.lng - r2, this.lat - e2), new Ol(this.lng + r2, this.lat + e2));
        }, Ol.convert = function(t4) {
          if (t4 instanceof Ol)
            return t4;
          if (Array.isArray(t4) && (2 === t4.length || 3 === t4.length))
            return new Ol(Number(t4[0]), Number(t4[1]));
          if (!Array.isArray(t4) && "object" == typeof t4 && null !== t4)
            return new Ol(Number("lng" in t4 ? t4.lng : t4.lon), Number(t4.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        };
        var Rl = 2 * Math.PI * 63710088e-1;
        function Ul(t4) {
          return Rl * Math.cos(t4 * Math.PI / 180);
        }
        function jl(t4) {
          return (180 + t4) / 360;
        }
        function ql(t4) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t4 * Math.PI / 360))) / 360;
        }
        function Nl(t4, e2) {
          return t4 / Ul(e2);
        }
        function Kl(t4) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t4) * Math.PI / 180)) - 90;
        }
        var Gl = function(t4, e2, r2) {
          void 0 === r2 && (r2 = 0), this.x = +t4, this.y = +e2, this.z = +r2;
        };
        Gl.fromLngLat = function(t4, e2) {
          void 0 === e2 && (e2 = 0);
          var r2 = Ol.convert(t4);
          return new Gl(jl(r2.lng), ql(r2.lat), Nl(e2, r2.lat));
        }, Gl.prototype.toLngLat = function() {
          return new Ol(360 * this.x - 180, Kl(this.y));
        }, Gl.prototype.toAltitude = function() {
          return this.z * Ul(Kl(this.y));
        }, Gl.prototype.meterInMercatorCoordinateUnits = function() {
          return 1 / Rl * (t4 = Kl(this.y), 1 / Math.cos(t4 * Math.PI / 180));
          var t4;
        };
        var Zl = function(t4, e2, r2) {
          this.z = t4, this.x = e2, this.y = r2, this.key = Hl(0, t4, t4, e2, r2);
        };
        Zl.prototype.equals = function(t4) {
          return this.z === t4.z && this.x === t4.x && this.y === t4.y;
        }, Zl.prototype.url = function(t4, e2) {
          var r2, n2, i3, a2, o2, s2 = (n2 = this.y, i3 = this.z, a2 = Dl(256 * (r2 = this.x), 256 * (n2 = Math.pow(2, i3) - n2 - 1), i3), o2 = Dl(256 * (r2 + 1), 256 * (n2 + 1), i3), a2[0] + "," + a2[1] + "," + o2[0] + "," + o2[1]), u2 = function(t5, e3, r3) {
            for (var n3, i4 = "", a3 = t5; a3 > 0; a3--)
              i4 += (e3 & (n3 = 1 << a3 - 1) ? 1 : 0) + (r3 & n3 ? 2 : 0);
            return i4;
          }(this.z, this.x, this.y);
          return t4[(this.x + this.y) % t4.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === e2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", u2).replace("{bbox-epsg-3857}", s2);
        }, Zl.prototype.getTilePoint = function(t4) {
          var e2 = Math.pow(2, this.z);
          return new i2(8192 * (t4.x * e2 - this.x), 8192 * (t4.y * e2 - this.y));
        }, Zl.prototype.toString = function() {
          return this.z + "/" + this.x + "/" + this.y;
        };
        var Xl = function(t4, e2) {
          this.wrap = t4, this.canonical = e2, this.key = Hl(t4, e2.z, e2.z, e2.x, e2.y);
        }, Jl = function(t4, e2, r2, n2, i3) {
          this.overscaledZ = t4, this.wrap = e2, this.canonical = new Zl(r2, +n2, +i3), this.key = Hl(e2, t4, r2, n2, i3);
        };
        function Hl(t4, e2, r2, n2, i3) {
          (t4 *= 2) < 0 && (t4 = -1 * t4 - 1);
          var a2 = 1 << r2;
          return (a2 * a2 * t4 + a2 * i3 + n2).toString(36) + r2.toString(36) + e2.toString(36);
        }
        Jl.prototype.equals = function(t4) {
          return this.overscaledZ === t4.overscaledZ && this.wrap === t4.wrap && this.canonical.equals(t4.canonical);
        }, Jl.prototype.scaledTo = function(t4) {
          var e2 = this.canonical.z - t4;
          return t4 > this.canonical.z ? new Jl(t4, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Jl(t4, this.wrap, t4, this.canonical.x >> e2, this.canonical.y >> e2);
        }, Jl.prototype.calculateScaledKey = function(t4, e2) {
          var r2 = this.canonical.z - t4;
          return t4 > this.canonical.z ? Hl(this.wrap * +e2, t4, this.canonical.z, this.canonical.x, this.canonical.y) : Hl(this.wrap * +e2, t4, t4, this.canonical.x >> r2, this.canonical.y >> r2);
        }, Jl.prototype.isChildOf = function(t4) {
          if (t4.wrap !== this.wrap)
            return false;
          var e2 = this.canonical.z - t4.canonical.z;
          return 0 === t4.overscaledZ || t4.overscaledZ < this.overscaledZ && t4.canonical.x === this.canonical.x >> e2 && t4.canonical.y === this.canonical.y >> e2;
        }, Jl.prototype.children = function(t4) {
          if (this.overscaledZ >= t4)
            return [new Jl(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          var e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
          return [new Jl(e2, this.wrap, e2, r2, n2), new Jl(e2, this.wrap, e2, r2 + 1, n2), new Jl(e2, this.wrap, e2, r2, n2 + 1), new Jl(e2, this.wrap, e2, r2 + 1, n2 + 1)];
        }, Jl.prototype.isLessThan = function(t4) {
          return this.wrap < t4.wrap || !(this.wrap > t4.wrap) && (this.overscaledZ < t4.overscaledZ || !(this.overscaledZ > t4.overscaledZ) && (this.canonical.x < t4.canonical.x || !(this.canonical.x > t4.canonical.x) && this.canonical.y < t4.canonical.y));
        }, Jl.prototype.wrapped = function() {
          return new Jl(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }, Jl.prototype.unwrapTo = function(t4) {
          return new Jl(this.overscaledZ, t4, this.canonical.z, this.canonical.x, this.canonical.y);
        }, Jl.prototype.overscaleFactor = function() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }, Jl.prototype.toUnwrapped = function() {
          return new Xl(this.wrap, this.canonical);
        }, Jl.prototype.toString = function() {
          return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y;
        }, Jl.prototype.getTilePoint = function(t4) {
          return this.canonical.getTilePoint(new Gl(t4.x - this.wrap, t4.y));
        }, On("CanonicalTileID", Zl), On("OverscaledTileID", Jl, { omit: ["posMatrix"] });
        var Yl = function(t4, e2, r2) {
          if (this.uid = t4, e2.height !== e2.width)
            throw new RangeError("DEM tiles must be square");
          if (r2 && "mapbox" !== r2 && "terrarium" !== r2)
            return A2('"' + r2 + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');
          this.stride = e2.height;
          var n2 = this.dim = e2.height - 2;
          this.data = new Uint32Array(e2.data.buffer), this.encoding = r2 || "mapbox";
          for (var i3 = 0; i3 < n2; i3++)
            this.data[this._idx(-1, i3)] = this.data[this._idx(0, i3)], this.data[this._idx(n2, i3)] = this.data[this._idx(n2 - 1, i3)], this.data[this._idx(i3, -1)] = this.data[this._idx(i3, 0)], this.data[this._idx(i3, n2)] = this.data[this._idx(i3, n2 - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n2, -1)] = this.data[this._idx(n2 - 1, 0)], this.data[this._idx(-1, n2)] = this.data[this._idx(0, n2 - 1)], this.data[this._idx(n2, n2)] = this.data[this._idx(n2 - 1, n2 - 1)];
        };
        Yl.prototype.get = function(t4, e2) {
          var r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t4, e2);
          return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r2[n2], r2[n2 + 1], r2[n2 + 2]);
        }, Yl.prototype.getUnpackVector = function() {
          return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
        }, Yl.prototype._idx = function(t4, e2) {
          if (t4 < -1 || t4 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (e2 + 1) * this.stride + (t4 + 1);
        }, Yl.prototype._unpackMapbox = function(t4, e2, r2) {
          return (256 * t4 * 256 + 256 * e2 + r2) / 10 - 1e4;
        }, Yl.prototype._unpackTerrarium = function(t4, e2, r2) {
          return 256 * t4 + e2 + r2 / 256 - 32768;
        }, Yl.prototype.getPixels = function() {
          return new xo({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }, Yl.prototype.backfillBorder = function(t4, e2, r2) {
          if (this.dim !== t4.dim)
            throw new Error("dem dimension mismatch");
          var n2 = e2 * this.dim, i3 = e2 * this.dim + this.dim, a2 = r2 * this.dim, o2 = r2 * this.dim + this.dim;
          switch (e2) {
            case -1:
              n2 = i3 - 1;
              break;
            case 1:
              i3 = n2 + 1;
          }
          switch (r2) {
            case -1:
              a2 = o2 - 1;
              break;
            case 1:
              o2 = a2 + 1;
          }
          for (var s2 = -e2 * this.dim, u2 = -r2 * this.dim, l2 = a2; l2 < o2; l2++)
            for (var p2 = n2; p2 < i3; p2++)
              this.data[this._idx(p2, l2)] = t4.data[this._idx(p2 + s2, l2 + u2)];
        }, On("DEMData", Yl);
        var $l = function(t4) {
          this._stringToNumber = {}, this._numberToString = [];
          for (var e2 = 0; e2 < t4.length; e2++) {
            var r2 = t4[e2];
            this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
          }
        };
        $l.prototype.encode = function(t4) {
          return this._stringToNumber[t4];
        }, $l.prototype.decode = function(t4) {
          return this._numberToString[t4];
        };
        var Wl = function(t4, e2, r2, n2, i3) {
          this.type = "Feature", this._vectorTileFeature = t4, t4._z = e2, t4._x = r2, t4._y = n2, this.properties = t4.properties, this.id = i3;
        }, Ql = { geometry: { configurable: true } };
        Ql.geometry.get = function() {
          return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }, Ql.geometry.set = function(t4) {
          this._geometry = t4;
        }, Wl.prototype.toJSON = function() {
          var t4 = { geometry: this.geometry };
          for (var e2 in this)
            "_geometry" !== e2 && "_vectorTileFeature" !== e2 && (t4[e2] = this[e2]);
          return t4;
        }, Object.defineProperties(Wl.prototype, Ql);
        var tp = function() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        };
        tp.prototype.updateState = function(t4, e2, r2) {
          var n2 = String(e2);
          if (this.stateChanges[t4] = this.stateChanges[t4] || {}, this.stateChanges[t4][n2] = this.stateChanges[t4][n2] || {}, h(this.stateChanges[t4][n2], r2), null === this.deletedStates[t4])
            for (var i3 in this.deletedStates[t4] = {}, this.state[t4])
              i3 !== n2 && (this.deletedStates[t4][i3] = null);
          else if (this.deletedStates[t4] && null === this.deletedStates[t4][n2])
            for (var a2 in this.deletedStates[t4][n2] = {}, this.state[t4][n2])
              r2[a2] || (this.deletedStates[t4][n2][a2] = null);
          else
            for (var o2 in r2)
              this.deletedStates[t4] && this.deletedStates[t4][n2] && null === this.deletedStates[t4][n2][o2] && delete this.deletedStates[t4][n2][o2];
        }, tp.prototype.removeFeatureState = function(t4, e2, r2) {
          if (null !== this.deletedStates[t4]) {
            var n2 = String(e2);
            if (this.deletedStates[t4] = this.deletedStates[t4] || {}, r2 && void 0 !== e2)
              null !== this.deletedStates[t4][n2] && (this.deletedStates[t4][n2] = this.deletedStates[t4][n2] || {}, this.deletedStates[t4][n2][r2] = null);
            else if (void 0 !== e2)
              if (this.stateChanges[t4] && this.stateChanges[t4][n2])
                for (r2 in this.deletedStates[t4][n2] = {}, this.stateChanges[t4][n2])
                  this.deletedStates[t4][n2][r2] = null;
              else
                this.deletedStates[t4][n2] = null;
            else
              this.deletedStates[t4] = null;
          }
        }, tp.prototype.getState = function(t4, e2) {
          var r2 = String(e2), n2 = h({}, (this.state[t4] || {})[r2], (this.stateChanges[t4] || {})[r2]);
          if (null === this.deletedStates[t4])
            return {};
          if (this.deletedStates[t4]) {
            var i3 = this.deletedStates[t4][e2];
            if (null === i3)
              return {};
            for (var a2 in i3)
              delete n2[a2];
          }
          return n2;
        }, tp.prototype.initializeTileState = function(t4, e2) {
          t4.setFeatureState(this.state, e2);
        }, tp.prototype.coalesceChanges = function(t4, e2) {
          var r2 = {};
          for (var n2 in this.stateChanges) {
            this.state[n2] = this.state[n2] || {};
            var i3 = {};
            for (var a2 in this.stateChanges[n2])
              this.state[n2][a2] || (this.state[n2][a2] = {}), h(this.state[n2][a2], this.stateChanges[n2][a2]), i3[a2] = this.state[n2][a2];
            r2[n2] = i3;
          }
          for (var o2 in this.deletedStates) {
            this.state[o2] = this.state[o2] || {};
            var s2 = {};
            if (null === this.deletedStates[o2])
              for (var u2 in this.state[o2])
                s2[u2] = {}, this.state[o2][u2] = {};
            else
              for (var l2 in this.deletedStates[o2]) {
                if (null === this.deletedStates[o2][l2])
                  this.state[o2][l2] = {};
                else
                  for (var p2 = 0, c2 = Object.keys(this.deletedStates[o2][l2]); p2 < c2.length; p2 += 1)
                    delete this.state[o2][l2][c2[p2]];
                s2[l2] = this.state[o2][l2];
              }
            r2[o2] = r2[o2] || {}, h(r2[o2], s2);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r2).length)
            for (var f2 in t4)
              t4[f2].setFeatureState(r2, e2);
        };
        var ep = function(t4, e2) {
          this.tileID = t4, this.x = t4.canonical.x, this.y = t4.canonical.y, this.z = t4.canonical.z, this.grid = new Tn(8192, 16, 0), this.grid3D = new Tn(8192, 16, 0), this.featureIndexArray = new aa(), this.promoteId = e2;
        };
        function rp(t4, e2, r2, n2, i3) {
          return x2(t4, function(t5, a2) {
            var o2 = e2 instanceof di ? e2.get(a2) : null;
            return o2 && o2.evaluate ? o2.evaluate(r2, n2, i3) : o2;
          });
        }
        function np(t4) {
          for (var e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i3 = -1 / 0, a2 = 0, o2 = t4; a2 < o2.length; a2 += 1) {
            var s2 = o2[a2];
            e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i3 = Math.max(i3, s2.y);
          }
          return { minX: e2, minY: r2, maxX: n2, maxY: i3 };
        }
        function ip(t4, e2) {
          return e2 - t4;
        }
        ep.prototype.insert = function(t4, e2, r2, n2, i3, a2) {
          var o2 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r2, n2, i3);
          for (var s2 = a2 ? this.grid3D : this.grid, u2 = 0; u2 < e2.length; u2++) {
            for (var l2 = e2[u2], p2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], c2 = 0; c2 < l2.length; c2++) {
              var h2 = l2[c2];
              p2[0] = Math.min(p2[0], h2.x), p2[1] = Math.min(p2[1], h2.y), p2[2] = Math.max(p2[2], h2.x), p2[3] = Math.max(p2[3], h2.y);
            }
            p2[0] < 8192 && p2[1] < 8192 && p2[2] >= 0 && p2[3] >= 0 && s2.insert(o2, p2[0], p2[1], p2[2], p2[3]);
          }
        }, ep.prototype.loadVTLayers = function() {
          return this.vtLayers || (this.vtLayers = new bs.VectorTile(new Ys(this.rawTileData)).layers, this.sourceLayerCoder = new $l(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }, ep.prototype.query = function(t4, e2, r2, n2) {
          var a2 = this;
          this.loadVTLayers();
          for (var o2 = t4.params || {}, s2 = 8192 / t4.tileSize / t4.scale, u2 = on(o2.filter), l2 = t4.queryGeometry, p2 = t4.queryPadding * s2, c2 = np(l2), h2 = this.grid.query(c2.minX - p2, c2.minY - p2, c2.maxX + p2, c2.maxY + p2), f2 = np(t4.cameraQueryGeometry), y2 = this.grid3D.query(f2.minX - p2, f2.minY - p2, f2.maxX + p2, f2.maxY + p2, function(e3, r3, n3, a3) {
            return function(t5, e4, r4, n4, a4) {
              for (var o3 = 0, s3 = t5; o3 < s3.length; o3 += 1) {
                var u3 = s3[o3];
                if (e4 <= u3.x && r4 <= u3.y && n4 >= u3.x && a4 >= u3.y)
                  return true;
              }
              var l3 = [new i2(e4, r4), new i2(e4, a4), new i2(n4, a4), new i2(n4, r4)];
              if (t5.length > 2) {
                for (var p3 = 0, c3 = l3; p3 < c3.length; p3 += 1)
                  if (Wa(t5, c3[p3]))
                    return true;
              }
              for (var h3 = 0; h3 < t5.length - 1; h3++)
                if (Qa(t5[h3], t5[h3 + 1], l3))
                  return true;
              return false;
            }(t4.cameraQueryGeometry, e3 - p2, r3 - p2, n3 + p2, a3 + p2);
          }), d2 = 0, m2 = y2; d2 < m2.length; d2 += 1)
            h2.push(m2[d2]);
          h2.sort(ip);
          for (var v2, g2 = {}, x3 = function(i3) {
            var p3 = h2[i3];
            if (p3 !== v2) {
              v2 = p3;
              var c3 = a2.featureIndexArray.get(p3), f3 = null;
              a2.loadMatchingFeature(g2, c3.bucketIndex, c3.sourceLayerIndex, c3.featureIndex, u2, o2.layers, o2.availableImages, e2, r2, n2, function(e3, r3, n3) {
                return f3 || (f3 = Ra(e3)), r3.queryIntersectsFeature(l2, e3, n3, f3, a2.z, t4.transform, s2, t4.pixelPosMatrix);
              });
            }
          }, b2 = 0; b2 < h2.length; b2++)
            x3(b2);
          return g2;
        }, ep.prototype.loadMatchingFeature = function(t4, e2, r2, n2, i3, a2, o2, s2, u2, l2, p2) {
          var c2 = this.bucketLayerIDs[e2];
          if (!a2 || function(t5, e3) {
            for (var r3 = 0; r3 < t5.length; r3++)
              if (e3.indexOf(t5[r3]) >= 0)
                return true;
            return false;
          }(a2, c2)) {
            var f2 = this.sourceLayerCoder.decode(r2), y2 = this.vtLayers[f2].feature(n2);
            if (i3.needGeometry) {
              var d2 = Ua(y2, true);
              if (!i3.filter(new si(this.tileID.overscaledZ), d2, this.tileID.canonical))
                return;
            } else if (!i3.filter(new si(this.tileID.overscaledZ), y2))
              return;
            for (var m2 = this.getId(y2, f2), v2 = 0; v2 < c2.length; v2++) {
              var g2 = c2[v2];
              if (!(a2 && a2.indexOf(g2) < 0)) {
                var x3 = s2[g2];
                if (x3) {
                  var b2 = {};
                  void 0 !== m2 && l2 && (b2 = l2.getState(x3.sourceLayer || "_geojsonTileLayer", m2));
                  var w2 = h({}, u2[g2]);
                  w2.paint = rp(w2.paint, x3.paint, y2, b2, o2), w2.layout = rp(w2.layout, x3.layout, y2, b2, o2);
                  var _2 = !p2 || p2(y2, x3, b2);
                  if (_2) {
                    var A3 = new Wl(y2, this.z, this.x, this.y, m2);
                    A3.layer = w2;
                    var S2 = t4[g2];
                    void 0 === S2 && (S2 = t4[g2] = []), S2.push({ featureIndex: n2, feature: A3, intersectionZ: _2 });
                  }
                }
              }
            }
          }
        }, ep.prototype.lookupSymbolFeatures = function(t4, e2, r2, n2, i3, a2, o2, s2) {
          var u2 = {};
          this.loadVTLayers();
          for (var l2 = on(i3), p2 = 0, c2 = t4; p2 < c2.length; p2 += 1)
            this.loadMatchingFeature(u2, r2, n2, c2[p2], l2, a2, o2, s2, e2);
          return u2;
        }, ep.prototype.hasLayer = function(t4) {
          for (var e2 = 0, r2 = this.bucketLayerIDs; e2 < r2.length; e2 += 1)
            for (var n2 = 0, i3 = r2[e2]; n2 < i3.length; n2 += 1)
              if (t4 === i3[n2])
                return true;
          return false;
        }, ep.prototype.getId = function(t4, e2) {
          var r2 = t4.id;
          return this.promoteId && "boolean" == typeof (r2 = t4.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2]]) && (r2 = Number(r2)), r2;
        }, On("FeatureIndex", ep, { omit: ["rawTileData", "sourceLayerCoder"] });
        var ap = function(t4, e2) {
          this.tileID = t4, this.uid = y(), this.uses = 0, this.tileSize = e2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";
        };
        ap.prototype.registerFadeDuration = function(t4) {
          var e2 = t4 + this.timeAdded;
          e2 < O.now() || this.fadeEndTime && e2 < this.fadeEndTime || (this.fadeEndTime = e2);
        }, ap.prototype.wasRequested = function() {
          return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
        }, ap.prototype.loadVectorData = function(t4, e2, r2) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t4) {
            for (var n2 in t4.featureIndex && (this.latestFeatureIndex = t4.featureIndex, t4.rawTileData ? (this.latestRawTileData = t4.rawTileData, this.latestFeatureIndex.rawTileData = t4.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t4.collisionBoxArray, this.buckets = function(t5, e3) {
              var r3 = {};
              if (!e3)
                return r3;
              for (var n3 = function() {
                var t6 = a3[i4], n4 = t6.layerIds.map(function(t7) {
                  return e3.getLayer(t7);
                }).filter(Boolean);
                if (0 !== n4.length) {
                  t6.layers = n4, t6.stateDependentLayerIds && (t6.stateDependentLayers = t6.stateDependentLayerIds.map(function(t7) {
                    return n4.filter(function(e4) {
                      return e4.id === t7;
                    })[0];
                  }));
                  for (var o3 = 0, s3 = n4; o3 < s3.length; o3 += 1)
                    r3[s3[o3].id] = t6;
                }
              }, i4 = 0, a3 = t5; i4 < a3.length; i4 += 1)
                n3();
              return r3;
            }(t4.buckets, e2.style), this.hasSymbolBuckets = false, this.buckets) {
              var i3 = this.buckets[n2];
              if (i3 instanceof vl) {
                if (this.hasSymbolBuckets = true, !r2)
                  break;
                i3.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets)
              for (var a2 in this.buckets) {
                var o2 = this.buckets[a2];
                if (o2 instanceof vl && o2.hasRTLText) {
                  this.hasRTLText = true, oi.isLoading() || oi.isLoaded() || "deferred" !== ii() || ai();
                  break;
                }
              }
            for (var s2 in this.queryPadding = 0, this.buckets) {
              var u2 = this.buckets[s2];
              this.queryPadding = Math.max(this.queryPadding, e2.style.getLayer(s2).queryRadius(u2));
            }
            t4.imageAtlas && (this.imageAtlas = t4.imageAtlas), t4.glyphAtlasImage && (this.glyphAtlasImage = t4.glyphAtlasImage);
          } else
            this.collisionBoxArray = new $i();
        }, ap.prototype.unloadVectorData = function() {
          for (var t4 in this.buckets)
            this.buckets[t4].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }, ap.prototype.getBucket = function(t4) {
          return this.buckets[t4.id];
        }, ap.prototype.upload = function(t4) {
          for (var e2 in this.buckets) {
            var r2 = this.buckets[e2];
            r2.uploadPending() && r2.upload(t4);
          }
          var n2 = t4.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Tl(t4, this.imageAtlas.image, n2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new Tl(t4, this.glyphAtlasImage, n2.ALPHA), this.glyphAtlasImage = null);
        }, ap.prototype.prepare = function(t4) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(t4, this.imageAtlasTexture);
        }, ap.prototype.queryRenderedFeatures = function(t4, e2, r2, n2, i3, a2, o2, s2, u2, l2) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: n2, cameraQueryGeometry: i3, scale: a2, tileSize: this.tileSize, pixelPosMatrix: l2, transform: s2, params: o2, queryPadding: this.queryPadding * u2 }, t4, e2, r2) : {};
        }, ap.prototype.querySourceFeatures = function(t4, e2) {
          var r2 = this.latestFeatureIndex;
          if (r2 && r2.rawTileData) {
            var n2 = r2.loadVTLayers(), i3 = e2 ? e2.sourceLayer : "", a2 = n2._geojsonTileLayer || n2[i3];
            if (a2)
              for (var o2 = on(e2 && e2.filter), s2 = this.tileID.canonical, u2 = s2.z, l2 = s2.x, p2 = s2.y, c2 = { z: u2, x: l2, y: p2 }, h2 = 0; h2 < a2.length; h2++) {
                var f2 = a2.feature(h2);
                if (o2.needGeometry) {
                  var y2 = Ua(f2, true);
                  if (!o2.filter(new si(this.tileID.overscaledZ), y2, this.tileID.canonical))
                    continue;
                } else if (!o2.filter(new si(this.tileID.overscaledZ), f2))
                  continue;
                var d2 = r2.getId(f2, i3), m2 = new Wl(f2, u2, l2, p2, d2);
                m2.tile = c2, t4.push(m2);
              }
          }
        }, ap.prototype.hasData = function() {
          return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
        }, ap.prototype.patternsLoaded = function() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }, ap.prototype.setExpiryData = function(t4) {
          var e2 = this.expirationTime;
          if (t4.cacheControl) {
            var r2 = z(t4.cacheControl);
            r2["max-age"] && (this.expirationTime = Date.now() + 1e3 * r2["max-age"]);
          } else
            t4.expires && (this.expirationTime = new Date(t4.expires).getTime());
          if (this.expirationTime) {
            var n2 = Date.now(), i3 = false;
            if (this.expirationTime > n2)
              i3 = false;
            else if (e2)
              if (this.expirationTime < e2)
                i3 = true;
              else {
                var a2 = this.expirationTime - e2;
                a2 ? this.expirationTime = n2 + Math.max(a2, 3e4) : i3 = true;
              }
            else
              i3 = true;
            i3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }, ap.prototype.getExpiryTimeout = function() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }, ap.prototype.setFeatureState = function(t4, e2) {
          if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(t4).length) {
            var r2 = this.latestFeatureIndex.loadVTLayers();
            for (var n2 in this.buckets)
              if (e2.style.hasLayer(n2)) {
                var i3 = this.buckets[n2], a2 = i3.layers[0].sourceLayer || "_geojsonTileLayer", o2 = r2[a2], s2 = t4[a2];
                if (o2 && s2 && 0 !== Object.keys(s2).length) {
                  i3.update(s2, o2, this.imageAtlas && this.imageAtlas.patternPositions || {});
                  var u2 = e2 && e2.style && e2.style.getLayer(n2);
                  u2 && (this.queryPadding = Math.max(this.queryPadding, u2.queryRadius(i3)));
                }
              }
          }
        }, ap.prototype.holdingForFade = function() {
          return void 0 !== this.symbolFadeHoldUntil;
        }, ap.prototype.symbolFadeFinished = function() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < O.now();
        }, ap.prototype.clearFadeHold = function() {
          this.symbolFadeHoldUntil = void 0;
        }, ap.prototype.setHoldDuration = function(t4) {
          this.symbolFadeHoldUntil = O.now() + t4;
        }, ap.prototype.setDependencies = function(t4, e2) {
          for (var r2 = {}, n2 = 0, i3 = e2; n2 < i3.length; n2 += 1)
            r2[i3[n2]] = true;
          this.dependencies[t4] = r2;
        }, ap.prototype.hasDependency = function(t4, e2) {
          for (var r2 = 0, n2 = t4; r2 < n2.length; r2 += 1) {
            var i3 = this.dependencies[n2[r2]];
            if (i3) {
              for (var a2 = 0, o2 = e2; a2 < o2.length; a2 += 1)
                if (i3[o2[a2]])
                  return true;
            }
          }
          return false;
        };
        var op = o.performance, sp = function(t4) {
          this._marks = { start: [t4.url, "start"].join("#"), end: [t4.url, "end"].join("#"), measure: t4.url.toString() }, op.mark(this._marks.start);
        };
        sp.prototype.finish = function() {
          op.mark(this._marks.end);
          var t4 = op.getEntriesByName(this._marks.measure);
          return 0 === t4.length && (op.measure(this._marks.measure, this._marks.start, this._marks.end), t4 = op.getEntriesByName(this._marks.measure), op.clearMarks(this._marks.start), op.clearMarks(this._marks.end), op.clearMeasures(this._marks.measure)), t4;
        }, t.Actor = Fl, t.AlphaImage = go, t.CanonicalTileID = Zl, t.CollisionBoxArray = $i, t.Color = te, t.DEMData = Yl, t.DataConstantProperty = mi, t.DictionaryCoder = $l, t.EXTENT = 8192, t.ErrorEvent = zt, t.EvaluationParameters = si, t.Event = It, t.Evented = Ct, t.FeatureIndex = ep, t.FillBucket = ss, t.FillExtrusionBucket = Ss, t.ImageAtlas = bu, t.ImagePosition = gu, t.LineBucket = Fs, t.LngLat = Ol, t.LngLatBounds = Ll, t.MercatorCoordinate = Gl, t.ONE_EM = 24, t.OverscaledTileID = Jl, t.Point = i2, t.Point$1 = i2, t.Properties = wi, t.Protobuf = Ys, t.RGBAImage = xo, t.RequestManager = G, t.RequestPerformance = sp, t.ResourceType = yt, t.SegmentVector = sa, t.SourceFeatureState = tp, t.StructArrayLayout1ui2 = Ji, t.StructArrayLayout2f1f2i16 = Ri, t.StructArrayLayout2i4 = Ci, t.StructArrayLayout3ui6 = ji, t.StructArrayLayout4i8 = Ei, t.SymbolBucket = vl, t.Texture = Tl, t.Tile = ap, t.Transitionable = pi, t.Uniform1f = ba, t.Uniform1i = xa, t.Uniform2f = wa, t.Uniform3f = _a2, t.Uniform4f = Aa, t.UniformColor = Sa, t.UniformMatrix4f = Ia, t.UnwrappedTileID = Xl, t.ValidationError = Pt, t.WritingMode = wu, t.ZoomHistory = Kn, t.add = function(t4, e2, r2) {
          return t4[0] = e2[0] + r2[0], t4[1] = e2[1] + r2[1], t4[2] = e2[2] + r2[2], t4;
        }, t.addDynamicAttributes = fl2, t.asyncAll = function(t4, e2, r2) {
          if (!t4.length)
            return r2(null, []);
          var n2 = t4.length, i3 = new Array(t4.length), a2 = null;
          t4.forEach(function(t5, o2) {
            e2(t5, function(t6, e3) {
              t6 && (a2 = t6), i3[o2] = e3, 0 == --n2 && r2(a2, i3);
            });
          });
        }, t.bezier = u, t.bindAll = v, t.browser = O, t.cacheEntryPossiblyAdded = function(t4) {
          ++ht > ut && (t4.getActor().send("enforceCacheSizeLimit", st), ht = 0);
        }, t.clamp = p, t.clearTileCache = function(t4) {
          var e2 = o.caches.delete("mapbox-tiles");
          t4 && e2.catch(t4).then(function() {
            return t4();
          });
        }, t.clipLine = Zu, t.clone = function(t4) {
          var e2 = new ao(16);
          return e2[0] = t4[0], e2[1] = t4[1], e2[2] = t4[2], e2[3] = t4[3], e2[4] = t4[4], e2[5] = t4[5], e2[6] = t4[6], e2[7] = t4[7], e2[8] = t4[8], e2[9] = t4[9], e2[10] = t4[10], e2[11] = t4[11], e2[12] = t4[12], e2[13] = t4[13], e2[14] = t4[14], e2[15] = t4[15], e2;
        }, t.clone$1 = w, t.clone$2 = function(t4) {
          var e2 = new ao(3);
          return e2[0] = t4[0], e2[1] = t4[1], e2[2] = t4[2], e2;
        }, t.collisionCircleLayout = Gs, t.config = R, t.create = function() {
          var t4 = new ao(16);
          return ao != Float32Array && (t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0), t4[0] = 1, t4[5] = 1, t4[10] = 1, t4[15] = 1, t4;
        }, t.create$1 = function() {
          var t4 = new ao(9);
          return ao != Float32Array && (t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[5] = 0, t4[6] = 0, t4[7] = 0), t4[0] = 1, t4[4] = 1, t4[8] = 1, t4;
        }, t.create$2 = function() {
          var t4 = new ao(4);
          return ao != Float32Array && (t4[1] = 0, t4[2] = 0), t4[0] = 1, t4[3] = 1, t4;
        }, t.createCommonjsModule = e, t.createExpression = Zr, t.createLayout = Ii, t.createStyleLayer = function(t4) {
          return "custom" === t4.type ? new Il(t4) : new zl[t4.type](t4);
        }, t.cross = function(t4, e2, r2) {
          var n2 = e2[0], i3 = e2[1], a2 = e2[2], o2 = r2[0], s2 = r2[1], u2 = r2[2];
          return t4[0] = i3 * u2 - a2 * s2, t4[1] = a2 * o2 - n2 * u2, t4[2] = n2 * s2 - i3 * o2, t4;
        }, t.deepEqual = function t4(e2, r2) {
          if (Array.isArray(e2)) {
            if (!Array.isArray(r2) || e2.length !== r2.length)
              return false;
            for (var n2 = 0; n2 < e2.length; n2++)
              if (!t4(e2[n2], r2[n2]))
                return false;
            return true;
          }
          if ("object" == typeof e2 && null !== e2 && null !== r2) {
            if ("object" != typeof r2)
              return false;
            if (Object.keys(e2).length !== Object.keys(r2).length)
              return false;
            for (var i3 in e2)
              if (!t4(e2[i3], r2[i3]))
                return false;
            return true;
          }
          return e2 === r2;
        }, t.dot = function(t4, e2) {
          return t4[0] * e2[0] + t4[1] * e2[1] + t4[2] * e2[2];
        }, t.dot$1 = function(t4, e2) {
          return t4[0] * e2[0] + t4[1] * e2[1] + t4[2] * e2[2] + t4[3] * e2[3];
        }, t.ease = l, t.emitValidationErrors = Bn, t.endsWith = g, t.enforceCacheSizeLimit = function(t4) {
          lt(), tt && tt.then(function(e2) {
            e2.keys().then(function(r2) {
              for (var n2 = 0; n2 < r2.length - t4; n2++)
                e2.delete(r2[n2]);
            });
          });
        }, t.evaluateSizeForFeature = Lu, t.evaluateSizeForZoom = Ou, t.evaluateVariableOffset = al, t.evented = ni, t.extend = h, t.featureFilter = on, t.filterObject = b, t.fromRotation = function(t4, e2) {
          var r2 = Math.sin(e2), n2 = Math.cos(e2);
          return t4[0] = n2, t4[1] = r2, t4[2] = 0, t4[3] = -r2, t4[4] = n2, t4[5] = 0, t4[6] = 0, t4[7] = 0, t4[8] = 1, t4;
        }, t.getAnchorAlignment = Bu, t.getAnchorJustification = ol, t.getArrayBuffer = bt, t.getImage = At, t.getJSON = function(t4, e2) {
          return xt(h(t4, { type: "json" }), e2);
        }, t.getRTLTextPluginStatus = ii, t.getReferrer = mt, t.getVideo = function(t4, e2) {
          var r2, n2, i3 = o.document.createElement("video");
          i3.muted = true, i3.onloadstart = function() {
            e2(null, i3);
          };
          for (var a2 = 0; a2 < t4.length; a2++) {
            var s2 = o.document.createElement("source");
            r2 = t4[a2], n2 = void 0, (n2 = o.document.createElement("a")).href = r2, (n2.protocol !== o.document.location.protocol || n2.host !== o.document.location.host) && (i3.crossOrigin = "Anonymous"), s2.src = t4[a2], i3.appendChild(s2);
          }
          return { cancel: function() {
          } };
        }, t.identity = oo, t.invert = function(t4, e2) {
          var r2 = e2[0], n2 = e2[1], i3 = e2[2], a2 = e2[3], o2 = e2[4], s2 = e2[5], u2 = e2[6], l2 = e2[7], p2 = e2[8], c2 = e2[9], h2 = e2[10], f2 = e2[11], y2 = e2[12], d2 = e2[13], m2 = e2[14], v2 = e2[15], g2 = r2 * s2 - n2 * o2, x3 = r2 * u2 - i3 * o2, b2 = r2 * l2 - a2 * o2, w2 = n2 * u2 - i3 * s2, _2 = n2 * l2 - a2 * s2, A3 = i3 * l2 - a2 * u2, S2 = p2 * d2 - c2 * y2, k2 = p2 * m2 - h2 * y2, I2 = p2 * v2 - f2 * y2, z2 = c2 * m2 - h2 * d2, C3 = c2 * v2 - f2 * d2, E3 = h2 * v2 - f2 * m2, P2 = g2 * E3 - x3 * C3 + b2 * z2 + w2 * I2 - _2 * k2 + A3 * S2;
          return P2 ? (t4[0] = (s2 * E3 - u2 * C3 + l2 * z2) * (P2 = 1 / P2), t4[1] = (i3 * C3 - n2 * E3 - a2 * z2) * P2, t4[2] = (d2 * A3 - m2 * _2 + v2 * w2) * P2, t4[3] = (h2 * _2 - c2 * A3 - f2 * w2) * P2, t4[4] = (u2 * I2 - o2 * E3 - l2 * k2) * P2, t4[5] = (r2 * E3 - i3 * I2 + a2 * k2) * P2, t4[6] = (m2 * b2 - y2 * A3 - v2 * x3) * P2, t4[7] = (p2 * A3 - h2 * b2 + f2 * x3) * P2, t4[8] = (o2 * C3 - s2 * I2 + l2 * S2) * P2, t4[9] = (n2 * I2 - r2 * C3 - a2 * S2) * P2, t4[10] = (y2 * _2 - d2 * b2 + v2 * g2) * P2, t4[11] = (c2 * b2 - p2 * _2 - f2 * g2) * P2, t4[12] = (s2 * k2 - o2 * z2 - u2 * S2) * P2, t4[13] = (r2 * z2 - n2 * k2 + i3 * S2) * P2, t4[14] = (d2 * x3 - y2 * w2 - m2 * g2) * P2, t4[15] = (p2 * w2 - c2 * x3 + h2 * g2) * P2, t4) : null;
        }, t.isChar = Gn, t.isMapboxURL = Z, t.keysDifference = function(t4, e2) {
          var r2 = [];
          for (var n2 in t4)
            n2 in e2 || r2.push(n2);
          return r2;
        }, t.makeRequest = xt, t.mapObject = x2, t.mercatorXfromLng = jl, t.mercatorYfromLat = ql, t.mercatorZfromAltitude = Nl, t.mul = lo, t.multiply = so, t.mvt = bs, t.nextPowerOfTwo = function(t4) {
          return t4 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t4) / Math.LN2));
        }, t.normalize = function(t4, e2) {
          var r2 = e2[0], n2 = e2[1], i3 = e2[2], a2 = r2 * r2 + n2 * n2 + i3 * i3;
          return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t4[0] = e2[0] * a2, t4[1] = e2[1] * a2, t4[2] = e2[2] * a2, t4;
        }, t.number = Ke, t.offscreenCanvasSupported = ft, t.ortho = function(t4, e2, r2, n2, i3, a2, o2) {
          var s2 = 1 / (e2 - r2), u2 = 1 / (n2 - i3), l2 = 1 / (a2 - o2);
          return t4[0] = -2 * s2, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = -2 * u2, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = 2 * l2, t4[11] = 0, t4[12] = (e2 + r2) * s2, t4[13] = (i3 + n2) * u2, t4[14] = (o2 + a2) * l2, t4[15] = 1, t4;
        }, t.parseGlyphPBF = function(t4) {
          return new Ys(t4).readFields(yu, []);
        }, t.pbf = Ys, t.performSymbolLayout = function(t4, e2, r2, n2, i3, a2, o2) {
          t4.createArrays(), t4.tilePixelRatio = 8192 / (512 * t4.overscaling), t4.compareText = {}, t4.iconsNeedLinear = false;
          var s2 = t4.layers[0].layout, u2 = t4.layers[0]._unevaluatedLayout._values, l2 = {};
          if ("composite" === t4.textSizeData.kind) {
            var p2 = t4.textSizeData, c2 = p2.maxZoom;
            l2.compositeTextSizes = [u2["text-size"].possiblyEvaluate(new si(p2.minZoom), o2), u2["text-size"].possiblyEvaluate(new si(c2), o2)];
          }
          if ("composite" === t4.iconSizeData.kind) {
            var h2 = t4.iconSizeData, f2 = h2.maxZoom;
            l2.compositeIconSizes = [u2["icon-size"].possiblyEvaluate(new si(h2.minZoom), o2), u2["icon-size"].possiblyEvaluate(new si(f2), o2)];
          }
          l2.layoutTextSize = u2["text-size"].possiblyEvaluate(new si(t4.zoom + 1), o2), l2.layoutIconSize = u2["icon-size"].possiblyEvaluate(new si(t4.zoom + 1), o2), l2.textMaxSize = u2["text-size"].possiblyEvaluate(new si(18));
          for (var y2 = 24 * s2.get("text-line-height"), d2 = "map" === s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement"), m2 = s2.get("text-keep-upright"), v2 = s2.get("text-size"), g2 = function() {
            var a3 = b2[x3], u3 = s2.get("text-font").evaluate(a3, {}, o2).join(","), p3 = v2.evaluate(a3, {}, o2), c3 = l2.layoutTextSize.evaluate(a3, {}, o2), h3 = l2.layoutIconSize.evaluate(a3, {}, o2), f3 = { horizontal: {}, vertical: void 0 }, g3 = a3.text, w2 = [0, 0];
            if (g3) {
              var _2 = g3.toString(), S2 = 24 * s2.get("text-letter-spacing").evaluate(a3, {}, o2), k2 = function(t5) {
                for (var e3 = 0, r3 = t5; e3 < r3.length; e3 += 1)
                  if (n3 = r3[e3].charCodeAt(0), Gn.Arabic(n3) || Gn["Arabic Supplement"](n3) || Gn["Arabic Extended-A"](n3) || Gn["Arabic Presentation Forms-A"](n3) || Gn["Arabic Presentation Forms-B"](n3))
                    return false;
                var n3;
                return true;
              }(_2) ? S2 : 0, I2 = s2.get("text-anchor").evaluate(a3, {}, o2), z2 = s2.get("text-variable-anchor");
              if (!z2) {
                var C3 = s2.get("text-radial-offset").evaluate(a3, {}, o2);
                w2 = C3 ? al(I2, [24 * C3, il]) : s2.get("text-offset").evaluate(a3, {}, o2).map(function(t5) {
                  return 24 * t5;
                });
              }
              var E3 = d2 ? "center" : s2.get("text-justify").evaluate(a3, {}, o2), P2 = s2.get("symbol-placement"), M2 = "point" === P2 ? 24 * s2.get("text-max-width").evaluate(a3, {}, o2) : 0, B3 = function() {
                t4.allowVerticalPlacement && Zn2(_2) && (f3.vertical = Su(g3, e2, r2, i3, u3, M2, y2, I2, "left", k2, w2, wu.vertical, true, P2, c3, p3));
              };
              if (!d2 && z2) {
                for (var T3 = "auto" === E3 ? z2.map(function(t5) {
                  return ol(t5);
                }) : [E3], V2 = false, F2 = 0; F2 < T3.length; F2++) {
                  var D3 = T3[F2];
                  if (!f3.horizontal[D3])
                    if (V2)
                      f3.horizontal[D3] = f3.horizontal[0];
                    else {
                      var L3 = Su(g3, e2, r2, i3, u3, M2, y2, "center", D3, k2, w2, wu.horizontal, false, P2, c3, p3);
                      L3 && (f3.horizontal[D3] = L3, V2 = 1 === L3.positionedLines.length);
                    }
                }
                B3();
              } else {
                "auto" === E3 && (E3 = ol(I2));
                var O2 = Su(g3, e2, r2, i3, u3, M2, y2, I2, E3, k2, w2, wu.horizontal, false, P2, c3, p3);
                O2 && (f3.horizontal[E3] = O2), B3(), Zn2(_2) && d2 && m2 && (f3.vertical = Su(g3, e2, r2, i3, u3, M2, y2, I2, E3, k2, w2, wu.vertical, false, P2, c3, p3));
              }
            }
            var R2 = void 0, U2 = false;
            if (a3.icon && a3.icon.name) {
              var j2 = n2[a3.icon.name];
              j2 && (R2 = function(t5, e3, r3) {
                var n3 = Bu(r3), i4 = e3[0] - t5.displaySize[0] * n3.horizontalAlign, a4 = e3[1] - t5.displaySize[1] * n3.verticalAlign;
                return { image: t5, top: a4, bottom: a4 + t5.displaySize[1], left: i4, right: i4 + t5.displaySize[0] };
              }(i3[a3.icon.name], s2.get("icon-offset").evaluate(a3, {}, o2), s2.get("icon-anchor").evaluate(a3, {}, o2)), U2 = j2.sdf, void 0 === t4.sdfIcons ? t4.sdfIcons = j2.sdf : t4.sdfIcons !== j2.sdf && A2("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (j2.pixelRatio !== t4.pixelRatio || 0 !== s2.get("icon-rotate").constantOr(1)) && (t4.iconsNeedLinear = true));
            }
            var q2 = ul(f3.horizontal) || f3.vertical;
            t4.iconsInText = !!q2 && q2.iconsInText, (q2 || R2) && function(t5, e3, r3, n3, i4, a4, o3, s3, u4, l3, p4) {
              var c4 = a4.textMaxSize.evaluate(e3, {});
              void 0 === c4 && (c4 = o3);
              var h4, f4 = t5.layers[0].layout, y3 = f4.get("icon-offset").evaluate(e3, {}, p4), d3 = ul(r3.horizontal), m3 = o3 / 24, v3 = t5.tilePixelRatio * m3, g4 = t5.tilePixelRatio * c4 / 24, x4 = t5.tilePixelRatio * s3, b3 = t5.tilePixelRatio * f4.get("symbol-spacing"), w3 = f4.get("text-padding") * t5.tilePixelRatio, _3 = f4.get("icon-padding") * t5.tilePixelRatio, S3 = f4.get("text-max-angle") / 180 * Math.PI, k3 = "map" === f4.get("text-rotation-alignment") && "point" !== f4.get("symbol-placement"), I3 = "map" === f4.get("icon-rotation-alignment") && "point" !== f4.get("symbol-placement"), z3 = f4.get("symbol-placement"), C4 = b3 / 2, E4 = f4.get("icon-text-fit");
              n3 && "none" !== E4 && (t5.allowVerticalPlacement && r3.vertical && (h4 = Vu(n3, r3.vertical, E4, f4.get("icon-text-fit-padding"), y3, m3)), d3 && (n3 = Vu(n3, d3, E4, f4.get("icon-text-fit-padding"), y3, m3)));
              var P3 = function(s4, c5) {
                c5.x < 0 || c5.x >= 8192 || c5.y < 0 || c5.y >= 8192 || function(t6, e4, r4, n4, i5, a5, o4, s5, u5, l4, p5, c6, h5, f5, y4, d4, m4, v4, g5, x5, b4, w4, _4, S4, k4) {
                  var I4, z4, C5, E5, P4, M4 = t6.addToLineVertexArray(e4, r4), B5 = 0, T5 = 0, V4 = 0, F4 = 0, D5 = -1, L5 = -1, O4 = {}, R4 = ha(""), U4 = 0, j4 = 0;
                  if (void 0 === s5._unevaluatedLayout.getValue("text-radial-offset") ? (U4 = (I4 = s5.layout.get("text-offset").evaluate(b4, {}, S4).map(function(t7) {
                    return 24 * t7;
                  }))[0], j4 = I4[1]) : (U4 = 24 * s5.layout.get("text-radial-offset").evaluate(b4, {}, S4), j4 = il), t6.allowVerticalPlacement && n4.vertical) {
                    var q4 = s5.layout.get("text-rotate").evaluate(b4, {}, S4) + 90;
                    E5 = new Wu(u5, e4, l4, p5, c6, n4.vertical, h5, f5, y4, q4), o4 && (P4 = new Wu(u5, e4, l4, p5, c6, o4, m4, v4, y4, q4));
                  }
                  if (i5) {
                    var N3 = s5.layout.get("icon-rotate").evaluate(b4, {}), K4 = "none" !== s5.layout.get("icon-text-fit"), G3 = Xu(i5, N3, _4, K4), Z3 = o4 ? Xu(o4, N3, _4, K4) : void 0;
                    C5 = new Wu(u5, e4, l4, p5, c6, i5, m4, v4, false, N3), B5 = 4 * G3.length;
                    var X3 = t6.iconSizeData, J3 = null;
                    "source" === X3.kind ? (J3 = [128 * s5.layout.get("icon-size").evaluate(b4, {})])[0] > 32640 && A2(t6.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".') : "composite" === X3.kind && ((J3 = [128 * w4.compositeIconSizes[0].evaluate(b4, {}, S4), 128 * w4.compositeIconSizes[1].evaluate(b4, {}, S4)])[0] > 32640 || J3[1] > 32640) && A2(t6.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".'), t6.addSymbols(t6.icon, G3, J3, x5, g5, b4, false, e4, M4.lineStartIndex, M4.lineLength, -1, S4), D5 = t6.icon.placedSymbolArray.length - 1, Z3 && (T5 = 4 * Z3.length, t6.addSymbols(t6.icon, Z3, J3, x5, g5, b4, wu.vertical, e4, M4.lineStartIndex, M4.lineLength, -1, S4), L5 = t6.icon.placedSymbolArray.length - 1);
                  }
                  for (var H3 in n4.horizontal) {
                    var Y3 = n4.horizontal[H3];
                    if (!z4) {
                      R4 = ha(Y3.text);
                      var $3 = s5.layout.get("text-rotate").evaluate(b4, {}, S4);
                      z4 = new Wu(u5, e4, l4, p5, c6, Y3, h5, f5, y4, $3);
                    }
                    var W3 = 1 === Y3.positionedLines.length;
                    if (V4 += sl(t6, e4, Y3, a5, s5, y4, b4, d4, M4, n4.vertical ? wu.horizontal : wu.horizontalOnly, W3 ? Object.keys(n4.horizontal) : [H3], O4, D5, w4, S4), W3)
                      break;
                  }
                  n4.vertical && (F4 += sl(t6, e4, n4.vertical, a5, s5, y4, b4, d4, M4, wu.vertical, ["vertical"], O4, L5, w4, S4));
                  var Q2 = z4 ? z4.boxStartIndex : t6.collisionBoxArray.length, tt2 = z4 ? z4.boxEndIndex : t6.collisionBoxArray.length, et3 = E5 ? E5.boxStartIndex : t6.collisionBoxArray.length, rt2 = E5 ? E5.boxEndIndex : t6.collisionBoxArray.length, nt2 = C5 ? C5.boxStartIndex : t6.collisionBoxArray.length, it2 = C5 ? C5.boxEndIndex : t6.collisionBoxArray.length, at2 = P4 ? P4.boxStartIndex : t6.collisionBoxArray.length, ot2 = P4 ? P4.boxEndIndex : t6.collisionBoxArray.length, st2 = -1, ut2 = function(t7, e5) {
                    return t7 && t7.circleDiameter ? Math.max(t7.circleDiameter, e5) : e5;
                  };
                  st2 = ut2(z4, st2), st2 = ut2(E5, st2), st2 = ut2(C5, st2);
                  var lt2 = (st2 = ut2(P4, st2)) > -1 ? 1 : 0;
                  lt2 && (st2 *= k4 / 24), t6.glyphOffsetArray.length >= vl.MAX_GLYPHS && A2("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b4.sortKey && t6.addToSortKeyRanges(t6.symbolInstances.length, b4.sortKey), t6.symbolInstances.emplaceBack(e4.x, e4.y, O4.right >= 0 ? O4.right : -1, O4.center >= 0 ? O4.center : -1, O4.left >= 0 ? O4.left : -1, O4.vertical || -1, D5, L5, R4, Q2, tt2, et3, rt2, nt2, it2, at2, ot2, l4, V4, F4, B5, T5, lt2, 0, h5, U4, j4, st2);
                }(t5, c5, s4, r3, n3, i4, h4, t5.layers[0], t5.collisionBoxArray, e3.index, e3.sourceLayerIndex, t5.index, v3, w3, k3, u4, x4, _3, I3, y3, e3, a4, l3, p4, o3);
              };
              if ("line" === z3)
                for (var M3 = 0, B4 = Zu(e3.geometry, 0, 0, 8192, 8192); M3 < B4.length; M3 += 1)
                  for (var T4 = B4[M3], V3 = 0, F3 = Gu(T4, b3, S3, r3.vertical || d3, n3, 24, g4, t5.overscaling, 8192); V3 < F3.length; V3 += 1) {
                    var D4 = F3[V3];
                    d3 && ll(t5, d3.text, C4, D4) || P3(T4, D4);
                  }
              else if ("line-center" === z3)
                for (var L4 = 0, O3 = e3.geometry; L4 < O3.length; L4 += 1) {
                  var R3 = O3[L4];
                  if (R3.length > 1) {
                    var U3 = Ku(R3, S3, r3.vertical || d3, n3, 24, g4);
                    U3 && P3(R3, U3);
                  }
                }
              else if ("Polygon" === e3.type)
                for (var j3 = 0, q3 = ns(e3.geometry, 0); j3 < q3.length; j3 += 1) {
                  var N2 = q3[j3], K3 = el(N2, 16);
                  P3(N2[0], new Fu(K3.x, K3.y, 0));
                }
              else if ("LineString" === e3.type)
                for (var G2 = 0, Z2 = e3.geometry; G2 < Z2.length; G2 += 1) {
                  var X2 = Z2[G2];
                  P3(X2, new Fu(X2[0].x, X2[0].y, 0));
                }
              else if ("Point" === e3.type)
                for (var J2 = 0, H2 = e3.geometry; J2 < H2.length; J2 += 1)
                  for (var Y2 = 0, $2 = H2[J2]; Y2 < $2.length; Y2 += 1) {
                    var W2 = $2[Y2];
                    P3([W2], new Fu(W2.x, W2.y, 0));
                  }
            }(t4, a3, f3, R2, n2, l2, c3, h3, w2, U2, o2);
          }, x3 = 0, b2 = t4.features; x3 < b2.length; x3 += 1)
            g2();
          a2 && t4.generateCollisionDebugBuffers();
        }, t.perspective = function(t4, e2, r2, n2, i3) {
          var a2, o2 = 1 / Math.tan(e2 / 2);
          return t4[0] = o2 / r2, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = o2, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[11] = -1, t4[12] = 0, t4[13] = 0, t4[15] = 0, null != i3 && i3 !== 1 / 0 ? (t4[10] = (i3 + n2) * (a2 = 1 / (n2 - i3)), t4[14] = 2 * i3 * n2 * a2) : (t4[10] = -1, t4[14] = -2 * n2), t4;
        }, t.pick = function(t4, e2) {
          for (var r2 = {}, n2 = 0; n2 < e2.length; n2++) {
            var i3 = e2[n2];
            i3 in t4 && (r2[i3] = t4[i3]);
          }
          return r2;
        }, t.plugin = oi, t.polygonIntersectsPolygon = Na, t.postMapLoadEvent = ot, t.postTurnstileEvent = it, t.potpack = vu, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = On, t.registerForPluginStateChange = function(t4) {
          return t4({ pluginStatus: Qn, pluginURL: ti }), ni.on("pluginStateChange", t4), t4;
        }, t.renderColorRamp = wo, t.rotate = function(t4, e2, r2) {
          var n2 = e2[0], i3 = e2[1], a2 = e2[2], o2 = e2[3], s2 = Math.sin(r2), u2 = Math.cos(r2);
          return t4[0] = n2 * u2 + a2 * s2, t4[1] = i3 * u2 + o2 * s2, t4[2] = n2 * -s2 + a2 * u2, t4[3] = i3 * -s2 + o2 * u2, t4;
        }, t.rotateX = function(t4, e2, r2) {
          var n2 = Math.sin(r2), i3 = Math.cos(r2), a2 = e2[4], o2 = e2[5], s2 = e2[6], u2 = e2[7], l2 = e2[8], p2 = e2[9], c2 = e2[10], h2 = e2[11];
          return e2 !== t4 && (t4[0] = e2[0], t4[1] = e2[1], t4[2] = e2[2], t4[3] = e2[3], t4[12] = e2[12], t4[13] = e2[13], t4[14] = e2[14], t4[15] = e2[15]), t4[4] = a2 * i3 + l2 * n2, t4[5] = o2 * i3 + p2 * n2, t4[6] = s2 * i3 + c2 * n2, t4[7] = u2 * i3 + h2 * n2, t4[8] = l2 * i3 - a2 * n2, t4[9] = p2 * i3 - o2 * n2, t4[10] = c2 * i3 - s2 * n2, t4[11] = h2 * i3 - u2 * n2, t4;
        }, t.rotateZ = function(t4, e2, r2) {
          var n2 = Math.sin(r2), i3 = Math.cos(r2), a2 = e2[0], o2 = e2[1], s2 = e2[2], u2 = e2[3], l2 = e2[4], p2 = e2[5], c2 = e2[6], h2 = e2[7];
          return e2 !== t4 && (t4[8] = e2[8], t4[9] = e2[9], t4[10] = e2[10], t4[11] = e2[11], t4[12] = e2[12], t4[13] = e2[13], t4[14] = e2[14], t4[15] = e2[15]), t4[0] = a2 * i3 + l2 * n2, t4[1] = o2 * i3 + p2 * n2, t4[2] = s2 * i3 + c2 * n2, t4[3] = u2 * i3 + h2 * n2, t4[4] = l2 * i3 - a2 * n2, t4[5] = p2 * i3 - o2 * n2, t4[6] = c2 * i3 - s2 * n2, t4[7] = h2 * i3 - u2 * n2, t4;
        }, t.scale = function(t4, e2, r2) {
          var n2 = r2[0], i3 = r2[1], a2 = r2[2];
          return t4[0] = e2[0] * n2, t4[1] = e2[1] * n2, t4[2] = e2[2] * n2, t4[3] = e2[3] * n2, t4[4] = e2[4] * i3, t4[5] = e2[5] * i3, t4[6] = e2[6] * i3, t4[7] = e2[7] * i3, t4[8] = e2[8] * a2, t4[9] = e2[9] * a2, t4[10] = e2[10] * a2, t4[11] = e2[11] * a2, t4[12] = e2[12], t4[13] = e2[13], t4[14] = e2[14], t4[15] = e2[15], t4;
        }, t.scale$1 = function(t4, e2, r2) {
          return t4[0] = e2[0] * r2, t4[1] = e2[1] * r2, t4[2] = e2[2] * r2, t4[3] = e2[3] * r2, t4;
        }, t.scale$2 = function(t4, e2, r2) {
          return t4[0] = e2[0] * r2, t4[1] = e2[1] * r2, t4[2] = e2[2] * r2, t4;
        }, t.setCacheLimits = function(t4, e2) {
          st = t4, ut = e2;
        }, t.setRTLTextPlugin = function(t4, e2, r2) {
          if (void 0 === r2 && (r2 = false), "deferred" === Qn || "loading" === Qn || "loaded" === Qn)
            throw new Error("setRTLTextPlugin cannot be called multiple times.");
          ti = O.resolveURL(t4), Qn = "deferred", Wn = e2, ri(), r2 || ai();
        }, t.sphericalToCartesian = function(t4) {
          var e2 = t4[0], r2 = t4[1], n2 = t4[2];
          return r2 += 90, r2 *= Math.PI / 180, n2 *= Math.PI / 180, { x: e2 * Math.cos(r2) * Math.sin(n2), y: e2 * Math.sin(r2) * Math.sin(n2), z: e2 * Math.cos(n2) };
        }, t.sqrLen = function(t4) {
          var e2 = t4[0], r2 = t4[1];
          return e2 * e2 + r2 * r2;
        }, t.styleSpec = Et, t.sub = function(t4, e2, r2) {
          return t4[0] = e2[0] - r2[0], t4[1] = e2[1] - r2[1], t4[2] = e2[2] - r2[2], t4;
        }, t.symbolSize = Ru, t.transformMat3 = function(t4, e2, r2) {
          var n2 = e2[0], i3 = e2[1], a2 = e2[2];
          return t4[0] = n2 * r2[0] + i3 * r2[3] + a2 * r2[6], t4[1] = n2 * r2[1] + i3 * r2[4] + a2 * r2[7], t4[2] = n2 * r2[2] + i3 * r2[5] + a2 * r2[8], t4;
        }, t.transformMat4 = po, t.translate = function(t4, e2, r2) {
          var n2, i3, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2 = r2[0], m2 = r2[1], v2 = r2[2];
          return e2 === t4 ? (t4[12] = e2[0] * d2 + e2[4] * m2 + e2[8] * v2 + e2[12], t4[13] = e2[1] * d2 + e2[5] * m2 + e2[9] * v2 + e2[13], t4[14] = e2[2] * d2 + e2[6] * m2 + e2[10] * v2 + e2[14], t4[15] = e2[3] * d2 + e2[7] * m2 + e2[11] * v2 + e2[15]) : (i3 = e2[1], a2 = e2[2], o2 = e2[3], s2 = e2[4], u2 = e2[5], l2 = e2[6], p2 = e2[7], c2 = e2[8], h2 = e2[9], f2 = e2[10], y2 = e2[11], t4[0] = n2 = e2[0], t4[1] = i3, t4[2] = a2, t4[3] = o2, t4[4] = s2, t4[5] = u2, t4[6] = l2, t4[7] = p2, t4[8] = c2, t4[9] = h2, t4[10] = f2, t4[11] = y2, t4[12] = n2 * d2 + s2 * m2 + c2 * v2 + e2[12], t4[13] = i3 * d2 + u2 * m2 + h2 * v2 + e2[13], t4[14] = a2 * d2 + l2 * m2 + f2 * v2 + e2[14], t4[15] = o2 * d2 + p2 * m2 + y2 * v2 + e2[15]), t4;
        }, t.triggerPluginCompletionEvent = ei, t.uniqueId = y, t.validateCustomStyleLayer = function(t4) {
          var e2 = [], r2 = t4.id;
          return void 0 === r2 && e2.push({ message: "layers." + r2 + ': missing required property "id"' }), void 0 === t4.render && e2.push({ message: "layers." + r2 + ': missing required method "render"' }), t4.renderingMode && "2d" !== t4.renderingMode && "3d" !== t4.renderingMode && e2.push({ message: "layers." + r2 + ': property "renderingMode" must be either "2d" or "3d"' }), e2;
        }, t.validateLight = En, t.validateStyle = Cn, t.values = function(t4) {
          var e2 = [];
          for (var r2 in t4)
            e2.push(t4[r2]);
          return e2;
        }, t.vectorTile = bs, t.version = "1.13.3", t.warnOnce = A2, t.webpSupported = U, t.window = o, t.wrap = c;
      });
      define2(["./shared"], function(e) {
        "use strict";
        function t(e2) {
          var r2 = typeof e2;
          if ("number" === r2 || "boolean" === r2 || "string" === r2 || null == e2)
            return JSON.stringify(e2);
          if (Array.isArray(e2)) {
            for (var i3 = "[", o2 = 0, n2 = e2; o2 < n2.length; o2 += 1)
              i3 += t(n2[o2]) + ",";
            return i3 + "]";
          }
          for (var a2 = Object.keys(e2).sort(), s2 = "{", l2 = 0; l2 < a2.length; l2++)
            s2 += JSON.stringify(a2[l2]) + ":" + t(e2[a2[l2]]) + ",";
          return s2 + "}";
        }
        function r(r2) {
          for (var i3 = "", o2 = 0, n2 = e.refProperties; o2 < n2.length; o2 += 1)
            i3 += "/" + t(r2[n2[o2]]);
          return i3;
        }
        var i2 = function(e2) {
          this.keyCache = {}, e2 && this.replace(e2);
        };
        i2.prototype.replace = function(e2) {
          this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
        }, i2.prototype.update = function(t4, i3) {
          for (var o2 = this, n2 = 0, a2 = t4; n2 < a2.length; n2 += 1) {
            var s2 = a2[n2];
            this._layerConfigs[s2.id] = s2;
            var l2 = this._layers[s2.id] = e.createStyleLayer(s2);
            l2._featureFilter = e.featureFilter(l2.filter), this.keyCache[s2.id] && delete this.keyCache[s2.id];
          }
          for (var u2 = 0, h2 = i3; u2 < h2.length; u2 += 1) {
            var c2 = h2[u2];
            delete this.keyCache[c2], delete this._layerConfigs[c2], delete this._layers[c2];
          }
          this.familiesBySource = {};
          for (var p2 = 0, f2 = function(e2, t5) {
            for (var i4 = {}, o3 = 0; o3 < e2.length; o3++) {
              var n3 = t5 && t5[e2[o3].id] || r(e2[o3]);
              t5 && (t5[e2[o3].id] = n3);
              var a3 = i4[n3];
              a3 || (a3 = i4[n3] = []), a3.push(e2[o3]);
            }
            var s3 = [];
            for (var l3 in i4)
              s3.push(i4[l3]);
            return s3;
          }(e.values(this._layerConfigs), this.keyCache); p2 < f2.length; p2 += 1) {
            var d2 = f2[p2].map(function(e2) {
              return o2._layers[e2.id];
            }), g2 = d2[0];
            if ("none" !== g2.visibility) {
              var v2 = g2.source || "", m2 = this.familiesBySource[v2];
              m2 || (m2 = this.familiesBySource[v2] = {});
              var y2 = g2.sourceLayer || "_geojsonTileLayer", x3 = m2[y2];
              x3 || (x3 = m2[y2] = []), x3.push(d2);
            }
          }
        };
        var o = function(t4) {
          var r2 = {}, i3 = [];
          for (var o2 in t4) {
            var n2 = t4[o2], a2 = r2[o2] = {};
            for (var s2 in n2) {
              var l2 = n2[+s2];
              if (l2 && 0 !== l2.bitmap.width && 0 !== l2.bitmap.height) {
                var u2 = { x: 0, y: 0, w: l2.bitmap.width + 2, h: l2.bitmap.height + 2 };
                i3.push(u2), a2[s2] = { rect: u2, metrics: l2.metrics };
              }
            }
          }
          var h2 = e.potpack(i3), c2 = new e.AlphaImage({ width: h2.w || 1, height: h2.h || 1 });
          for (var p2 in t4) {
            var f2 = t4[p2];
            for (var d2 in f2) {
              var g2 = f2[+d2];
              if (g2 && 0 !== g2.bitmap.width && 0 !== g2.bitmap.height) {
                var v2 = r2[p2][d2].rect;
                e.AlphaImage.copy(g2.bitmap, c2, { x: 0, y: 0 }, { x: v2.x + 1, y: v2.y + 1 }, g2.bitmap);
              }
            }
          }
          this.image = c2, this.positions = r2;
        };
        e.register("GlyphAtlas", o);
        var n = function(t4) {
          this.tileID = new e.OverscaledTileID(t4.tileID.overscaledZ, t4.tileID.wrap, t4.tileID.canonical.z, t4.tileID.canonical.x, t4.tileID.canonical.y), this.uid = t4.uid, this.zoom = t4.zoom, this.pixelRatio = t4.pixelRatio, this.tileSize = t4.tileSize, this.source = t4.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t4.showCollisionBoxes, this.collectResourceTiming = !!t4.collectResourceTiming, this.returnDependencies = !!t4.returnDependencies, this.promoteId = t4.promoteId;
        };
        function a(t4, r2, i3) {
          for (var o2 = new e.EvaluationParameters(r2), n2 = 0, a2 = t4; n2 < a2.length; n2 += 1)
            a2[n2].recalculate(o2, i3);
        }
        function s(t4, r2) {
          var i3 = e.getArrayBuffer(t4.request, function(t5, i4, o2, n2) {
            t5 ? r2(t5) : i4 && r2(null, { vectorTile: new e.vectorTile.VectorTile(new e.pbf(i4)), rawData: i4, cacheControl: o2, expires: n2 });
          });
          return function() {
            i3.cancel(), r2();
          };
        }
        n.prototype.parse = function(t4, r2, i3, n2, s2) {
          var l2 = this;
          this.status = "parsing", this.data = t4, this.collisionBoxArray = new e.CollisionBoxArray();
          var u2 = new e.DictionaryCoder(Object.keys(t4.layers).sort()), h2 = new e.FeatureIndex(this.tileID, this.promoteId);
          h2.bucketLayerIDs = [];
          var c2, p2, f2, d2, g2 = {}, v2 = { featureIndex: h2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: i3 }, m2 = r2.familiesBySource[this.source];
          for (var y2 in m2) {
            var x3 = t4.layers[y2];
            if (x3) {
              1 === x3.version && e.warnOnce('Vector tile source "' + this.source + '" layer "' + y2 + '" does not use vector tile spec v2 and therefore may have some rendering errors.');
              for (var w2 = u2.encode(y2), S2 = [], I2 = 0; I2 < x3.length; I2++) {
                var M2 = x3.feature(I2), b2 = h2.getId(M2, y2);
                S2.push({ feature: M2, id: b2, index: I2, sourceLayerIndex: w2 });
              }
              for (var _2 = 0, k2 = m2[y2]; _2 < k2.length; _2 += 1) {
                var P2 = k2[_2], T3 = P2[0];
                T3.minzoom && this.zoom < Math.floor(T3.minzoom) || T3.maxzoom && this.zoom >= T3.maxzoom || "none" !== T3.visibility && (a(P2, this.zoom, i3), (g2[T3.id] = T3.createBucket({ index: h2.bucketLayerIDs.length, layers: P2, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: w2, sourceID: this.source })).populate(S2, v2, this.tileID.canonical), h2.bucketLayerIDs.push(P2.map(function(e2) {
                  return e2.id;
                })));
              }
            }
          }
          var C3 = e.mapObject(v2.glyphDependencies, function(e2) {
            return Object.keys(e2).map(Number);
          });
          Object.keys(C3).length ? n2.send("getGlyphs", { uid: this.uid, stacks: C3 }, function(e2, t5) {
            c2 || (c2 = e2, p2 = t5, z2.call(l2));
          }) : p2 = {};
          var D3 = Object.keys(v2.iconDependencies);
          D3.length ? n2.send("getImages", { icons: D3, source: this.source, tileID: this.tileID, type: "icons" }, function(e2, t5) {
            c2 || (c2 = e2, f2 = t5, z2.call(l2));
          }) : f2 = {};
          var L3 = Object.keys(v2.patternDependencies);
          function z2() {
            if (c2)
              return s2(c2);
            if (p2 && f2 && d2) {
              var t5 = new o(p2), r3 = new e.ImageAtlas(f2, d2);
              for (var n3 in g2) {
                var l3 = g2[n3];
                l3 instanceof e.SymbolBucket ? (a(l3.layers, this.zoom, i3), e.performSymbolLayout(l3, p2, t5.positions, f2, r3.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : l3.hasPattern && (l3 instanceof e.LineBucket || l3 instanceof e.FillBucket || l3 instanceof e.FillExtrusionBucket) && (a(l3.layers, this.zoom, i3), l3.addFeatures(v2, this.tileID.canonical, r3.patternPositions));
              }
              this.status = "done", s2(null, { buckets: e.values(g2).filter(function(e2) {
                return !e2.isEmpty();
              }), featureIndex: h2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t5.image, imageAtlas: r3, glyphMap: this.returnDependencies ? p2 : null, iconMap: this.returnDependencies ? f2 : null, glyphPositions: this.returnDependencies ? t5.positions : null });
            }
          }
          L3.length ? n2.send("getImages", { icons: L3, source: this.source, tileID: this.tileID, type: "patterns" }, function(e2, t5) {
            c2 || (c2 = e2, d2 = t5, z2.call(l2));
          }) : d2 = {}, z2.call(this);
        };
        var l = function(e2, t4, r2, i3) {
          this.actor = e2, this.layerIndex = t4, this.availableImages = r2, this.loadVectorData = i3 || s, this.loading = {}, this.loaded = {};
        };
        l.prototype.loadTile = function(t4, r2) {
          var i3 = this, o2 = t4.uid;
          this.loading || (this.loading = {});
          var a2 = !!(t4 && t4.request && t4.request.collectResourceTiming) && new e.RequestPerformance(t4.request), s2 = this.loading[o2] = new n(t4);
          s2.abort = this.loadVectorData(t4, function(t5, n2) {
            if (delete i3.loading[o2], t5 || !n2)
              return s2.status = "done", i3.loaded[o2] = s2, r2(t5);
            var l2 = n2.rawData, u2 = {};
            n2.expires && (u2.expires = n2.expires), n2.cacheControl && (u2.cacheControl = n2.cacheControl);
            var h2 = {};
            if (a2) {
              var c2 = a2.finish();
              c2 && (h2.resourceTiming = JSON.parse(JSON.stringify(c2)));
            }
            s2.vectorTile = n2.vectorTile, s2.parse(n2.vectorTile, i3.layerIndex, i3.availableImages, i3.actor, function(t6, i4) {
              if (t6 || !i4)
                return r2(t6);
              r2(null, e.extend({ rawTileData: l2.slice(0) }, i4, u2, h2));
            }), i3.loaded = i3.loaded || {}, i3.loaded[o2] = s2;
          });
        }, l.prototype.reloadTile = function(e2, t4) {
          var r2 = this, i3 = this.loaded, o2 = e2.uid, n2 = this;
          if (i3 && i3[o2]) {
            var a2 = i3[o2];
            a2.showCollisionBoxes = e2.showCollisionBoxes;
            var s2 = function(e3, i4) {
              var o3 = a2.reloadCallback;
              o3 && (delete a2.reloadCallback, a2.parse(a2.vectorTile, n2.layerIndex, r2.availableImages, n2.actor, o3)), t4(e3, i4);
            };
            "parsing" === a2.status ? a2.reloadCallback = s2 : "done" === a2.status && (a2.vectorTile ? a2.parse(a2.vectorTile, this.layerIndex, this.availableImages, this.actor, s2) : s2());
          }
        }, l.prototype.abortTile = function(e2, t4) {
          var r2 = this.loading, i3 = e2.uid;
          r2 && r2[i3] && r2[i3].abort && (r2[i3].abort(), delete r2[i3]), t4();
        }, l.prototype.removeTile = function(e2, t4) {
          var r2 = this.loaded, i3 = e2.uid;
          r2 && r2[i3] && delete r2[i3], t4();
        };
        var u = e.window.ImageBitmap, h = function() {
          this.loaded = {};
        };
        function c(e2, t4) {
          if (0 !== e2.length) {
            p(e2[0], t4);
            for (var r2 = 1; r2 < e2.length; r2++)
              p(e2[r2], !t4);
          }
        }
        function p(e2, t4) {
          for (var r2 = 0, i3 = 0, o2 = 0, n2 = e2.length, a2 = n2 - 1; o2 < n2; a2 = o2++) {
            var s2 = (e2[o2][0] - e2[a2][0]) * (e2[a2][1] + e2[o2][1]), l2 = r2 + s2;
            i3 += Math.abs(r2) >= Math.abs(s2) ? r2 - l2 + s2 : s2 - l2 + r2, r2 = l2;
          }
          r2 + i3 >= 0 != !!t4 && e2.reverse();
        }
        h.prototype.loadTile = function(t4, r2) {
          var i3 = t4.uid, o2 = t4.encoding, n2 = t4.rawImageData, a2 = u && n2 instanceof u ? this.getImageData(n2) : n2, s2 = new e.DEMData(i3, a2, o2);
          this.loaded = this.loaded || {}, this.loaded[i3] = s2, r2(null, s2);
        }, h.prototype.getImageData = function(t4) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t4.width, t4.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t4.width, this.offscreenCanvas.height = t4.height, this.offscreenCanvasContext.drawImage(t4, 0, 0, t4.width, t4.height);
          var r2 = this.offscreenCanvasContext.getImageData(-1, -1, t4.width + 2, t4.height + 2);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({ width: r2.width, height: r2.height }, r2.data);
        }, h.prototype.removeTile = function(e2) {
          var t4 = this.loaded, r2 = e2.uid;
          t4 && t4[r2] && delete t4[r2];
        };
        var f = e.vectorTile.VectorTileFeature.prototype.toGeoJSON, d = function(t4) {
          this._feature = t4, this.extent = e.EXTENT, this.type = t4.type, this.properties = t4.tags, "id" in t4 && !isNaN(t4.id) && (this.id = parseInt(t4.id, 10));
        };
        d.prototype.loadGeometry = function() {
          if (1 === this._feature.type) {
            for (var t4 = [], r2 = 0, i3 = this._feature.geometry; r2 < i3.length; r2 += 1) {
              var o2 = i3[r2];
              t4.push([new e.Point$1(o2[0], o2[1])]);
            }
            return t4;
          }
          for (var n2 = [], a2 = 0, s2 = this._feature.geometry; a2 < s2.length; a2 += 1) {
            for (var l2 = [], u2 = 0, h2 = s2[a2]; u2 < h2.length; u2 += 1) {
              var c2 = h2[u2];
              l2.push(new e.Point$1(c2[0], c2[1]));
            }
            n2.push(l2);
          }
          return n2;
        }, d.prototype.toGeoJSON = function(e2, t4, r2) {
          return f.call(this, e2, t4, r2);
        };
        var g = function(t4) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t4.length, this._features = t4;
        };
        g.prototype.feature = function(e2) {
          return new d(this._features[e2]);
        };
        var v = e.vectorTile.VectorTileFeature, m = y;
        function y(e2, t4) {
          this.options = t4 || {}, this.features = e2, this.length = e2.length;
        }
        function x2(e2, t4) {
          this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t4 || 4096;
        }
        y.prototype.feature = function(e2) {
          return new x2(this.features[e2], this.options.extent);
        }, x2.prototype.loadGeometry = function() {
          var t4 = this.rawGeometry;
          this.geometry = [];
          for (var r2 = 0; r2 < t4.length; r2++) {
            for (var i3 = t4[r2], o2 = [], n2 = 0; n2 < i3.length; n2++)
              o2.push(new e.Point$1(i3[n2][0], i3[n2][1]));
            this.geometry.push(o2);
          }
          return this.geometry;
        }, x2.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e2 = this.geometry, t4 = 1 / 0, r2 = -1 / 0, i3 = 1 / 0, o2 = -1 / 0, n2 = 0; n2 < e2.length; n2++)
            for (var a2 = e2[n2], s2 = 0; s2 < a2.length; s2++) {
              var l2 = a2[s2];
              t4 = Math.min(t4, l2.x), r2 = Math.max(r2, l2.x), i3 = Math.min(i3, l2.y), o2 = Math.max(o2, l2.y);
            }
          return [t4, i3, r2, o2];
        }, x2.prototype.toGeoJSON = v.prototype.toGeoJSON;
        var w = I, S = m;
        function I(t4) {
          var r2 = new e.pbf();
          return function(e2, t5) {
            for (var r3 in e2.layers)
              t5.writeMessage(3, M, e2.layers[r3]);
          }(t4, r2), r2.finish();
        }
        function M(e2, t4) {
          var r2;
          t4.writeVarintField(15, e2.version || 1), t4.writeStringField(1, e2.name || ""), t4.writeVarintField(5, e2.extent || 4096);
          var i3 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (r2 = 0; r2 < e2.length; r2++)
            i3.feature = e2.feature(r2), t4.writeMessage(2, b, i3);
          var o2 = i3.keys;
          for (r2 = 0; r2 < o2.length; r2++)
            t4.writeStringField(3, o2[r2]);
          var n2 = i3.values;
          for (r2 = 0; r2 < n2.length; r2++)
            t4.writeMessage(4, C2, n2[r2]);
        }
        function b(e2, t4) {
          var r2 = e2.feature;
          void 0 !== r2.id && t4.writeVarintField(1, r2.id), t4.writeMessage(2, _, e2), t4.writeVarintField(3, r2.type), t4.writeMessage(4, T2, r2);
        }
        function _(e2, t4) {
          var r2 = e2.feature, i3 = e2.keys, o2 = e2.values, n2 = e2.keycache, a2 = e2.valuecache;
          for (var s2 in r2.properties) {
            var l2 = n2[s2];
            void 0 === l2 && (i3.push(s2), n2[s2] = l2 = i3.length - 1), t4.writeVarint(l2);
            var u2 = r2.properties[s2], h2 = typeof u2;
            "string" !== h2 && "boolean" !== h2 && "number" !== h2 && (u2 = JSON.stringify(u2));
            var c2 = h2 + ":" + u2, p2 = a2[c2];
            void 0 === p2 && (o2.push(u2), a2[c2] = p2 = o2.length - 1), t4.writeVarint(p2);
          }
        }
        function k(e2, t4) {
          return (t4 << 3) + (7 & e2);
        }
        function P(e2) {
          return e2 << 1 ^ e2 >> 31;
        }
        function T2(e2, t4) {
          for (var r2 = e2.loadGeometry(), i3 = e2.type, o2 = 0, n2 = 0, a2 = r2.length, s2 = 0; s2 < a2; s2++) {
            var l2 = r2[s2], u2 = 1;
            1 === i3 && (u2 = l2.length), t4.writeVarint(k(1, u2));
            for (var h2 = 3 === i3 ? l2.length - 1 : l2.length, c2 = 0; c2 < h2; c2++) {
              1 === c2 && 1 !== i3 && t4.writeVarint(k(2, h2 - 1));
              var p2 = l2[c2].x - o2, f2 = l2[c2].y - n2;
              t4.writeVarint(P(p2)), t4.writeVarint(P(f2)), o2 += p2, n2 += f2;
            }
            3 === i3 && t4.writeVarint(k(7, 1));
          }
        }
        function C2(e2, t4) {
          var r2 = typeof e2;
          "string" === r2 ? t4.writeStringField(1, e2) : "boolean" === r2 ? t4.writeBooleanField(7, e2) : "number" === r2 && (e2 % 1 != 0 ? t4.writeDoubleField(3, e2) : e2 < 0 ? t4.writeSVarintField(6, e2) : t4.writeVarintField(5, e2));
        }
        function D2(e2, t4, r2, i3) {
          L2(e2, r2, i3), L2(t4, 2 * r2, 2 * i3), L2(t4, 2 * r2 + 1, 2 * i3 + 1);
        }
        function L2(e2, t4, r2) {
          var i3 = e2[t4];
          e2[t4] = e2[r2], e2[r2] = i3;
        }
        function z(e2, t4, r2, i3) {
          var o2 = e2 - r2, n2 = t4 - i3;
          return o2 * o2 + n2 * n2;
        }
        w.fromVectorTileJs = I, w.fromGeojsonVt = function(e2, t4) {
          t4 = t4 || {};
          var r2 = {};
          for (var i3 in e2)
            r2[i3] = new m(e2[i3].features, t4), r2[i3].name = i3, r2[i3].version = t4.version, r2[i3].extent = t4.extent;
          return I({ layers: r2 });
        }, w.GeoJSONWrapper = S;
        var O = function(e2) {
          return e2[0];
        }, E2 = function(e2) {
          return e2[1];
        }, F = function(e2, t4, r2, i3, o2) {
          void 0 === t4 && (t4 = O), void 0 === r2 && (r2 = E2), void 0 === i3 && (i3 = 64), void 0 === o2 && (o2 = Float64Array), this.nodeSize = i3, this.points = e2;
          for (var n2 = e2.length < 65536 ? Uint16Array : Uint32Array, a2 = this.ids = new n2(e2.length), s2 = this.coords = new o2(2 * e2.length), l2 = 0; l2 < e2.length; l2++)
            a2[l2] = l2, s2[2 * l2] = t4(e2[l2]), s2[2 * l2 + 1] = r2(e2[l2]);
          !function e3(t5, r3, i4, o3, n3, a3) {
            if (!(n3 - o3 <= i4)) {
              var s3 = o3 + n3 >> 1;
              !function e4(t6, r4, i5, o4, n4, a4) {
                for (; n4 > o4; ) {
                  if (n4 - o4 > 600) {
                    var s4 = n4 - o4 + 1, l3 = i5 - o4 + 1, u2 = Math.log(s4), h2 = 0.5 * Math.exp(2 * u2 / 3), c2 = 0.5 * Math.sqrt(u2 * h2 * (s4 - h2) / s4) * (l3 - s4 / 2 < 0 ? -1 : 1);
                    e4(t6, r4, i5, Math.max(o4, Math.floor(i5 - l3 * h2 / s4 + c2)), Math.min(n4, Math.floor(i5 + (s4 - l3) * h2 / s4 + c2)), a4);
                  }
                  var p2 = r4[2 * i5 + a4], f2 = o4, d2 = n4;
                  for (D2(t6, r4, o4, i5), r4[2 * n4 + a4] > p2 && D2(t6, r4, o4, n4); f2 < d2; ) {
                    for (D2(t6, r4, f2, d2), f2++, d2--; r4[2 * f2 + a4] < p2; )
                      f2++;
                    for (; r4[2 * d2 + a4] > p2; )
                      d2--;
                  }
                  r4[2 * o4 + a4] === p2 ? D2(t6, r4, o4, d2) : D2(t6, r4, ++d2, n4), d2 <= i5 && (o4 = d2 + 1), i5 <= d2 && (n4 = d2 - 1);
                }
              }(t5, r3, s3, o3, n3, a3 % 2), e3(t5, r3, i4, o3, s3 - 1, a3 + 1), e3(t5, r3, i4, s3 + 1, n3, a3 + 1);
            }
          }(a2, s2, i3, 0, a2.length - 1, 0);
        };
        F.prototype.range = function(e2, t4, r2, i3) {
          return function(e3, t5, r3, i4, o2, n2, a2) {
            for (var s2, l2, u2 = [0, e3.length - 1, 0], h2 = []; u2.length; ) {
              var c2 = u2.pop(), p2 = u2.pop(), f2 = u2.pop();
              if (p2 - f2 <= a2)
                for (var d2 = f2; d2 <= p2; d2++)
                  l2 = t5[2 * d2 + 1], (s2 = t5[2 * d2]) >= r3 && s2 <= o2 && l2 >= i4 && l2 <= n2 && h2.push(e3[d2]);
              else {
                var g2 = Math.floor((f2 + p2) / 2);
                l2 = t5[2 * g2 + 1], (s2 = t5[2 * g2]) >= r3 && s2 <= o2 && l2 >= i4 && l2 <= n2 && h2.push(e3[g2]);
                var v2 = (c2 + 1) % 2;
                (0 === c2 ? r3 <= s2 : i4 <= l2) && (u2.push(f2), u2.push(g2 - 1), u2.push(v2)), (0 === c2 ? o2 >= s2 : n2 >= l2) && (u2.push(g2 + 1), u2.push(p2), u2.push(v2));
              }
            }
            return h2;
          }(this.ids, this.coords, e2, t4, r2, i3, this.nodeSize);
        }, F.prototype.within = function(e2, t4, r2) {
          return function(e3, t5, r3, i3, o2, n2) {
            for (var a2 = [0, e3.length - 1, 0], s2 = [], l2 = o2 * o2; a2.length; ) {
              var u2 = a2.pop(), h2 = a2.pop(), c2 = a2.pop();
              if (h2 - c2 <= n2)
                for (var p2 = c2; p2 <= h2; p2++)
                  z(t5[2 * p2], t5[2 * p2 + 1], r3, i3) <= l2 && s2.push(e3[p2]);
              else {
                var f2 = Math.floor((c2 + h2) / 2), d2 = t5[2 * f2], g2 = t5[2 * f2 + 1];
                z(d2, g2, r3, i3) <= l2 && s2.push(e3[f2]);
                var v2 = (u2 + 1) % 2;
                (0 === u2 ? r3 - o2 <= d2 : i3 - o2 <= g2) && (a2.push(c2), a2.push(f2 - 1), a2.push(v2)), (0 === u2 ? r3 + o2 >= d2 : i3 + o2 >= g2) && (a2.push(f2 + 1), a2.push(h2), a2.push(v2));
              }
            }
            return s2;
          }(this.ids, this.coords, e2, t4, r2, this.nodeSize);
        };
        var N = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: function(e2) {
          return e2;
        } }, J = function(e2) {
          this.options = V(Object.create(N), e2), this.trees = new Array(this.options.maxZoom + 1);
        };
        function Z(e2, t4, r2, i3, o2) {
          return { x: e2, y: t4, zoom: 1 / 0, id: r2, parentId: -1, numPoints: i3, properties: o2 };
        }
        function A2(e2, t4) {
          var r2 = e2.geometry.coordinates, i3 = r2[1];
          return { x: Y(r2[0]), y: j(i3), zoom: 1 / 0, index: t4, parentId: -1 };
        }
        function B2(e2) {
          return { type: "Feature", id: e2.id, properties: G(e2), geometry: { type: "Point", coordinates: [(i3 = e2.x, 360 * (i3 - 0.5)), (t4 = e2.y, r2 = (180 - 360 * t4) * Math.PI / 180, 360 * Math.atan(Math.exp(r2)) / Math.PI - 90)] } };
          var t4, r2, i3;
        }
        function G(e2) {
          var t4 = e2.numPoints, r2 = t4 >= 1e4 ? Math.round(t4 / 1e3) + "k" : t4 >= 1e3 ? Math.round(t4 / 100) / 10 + "k" : t4;
          return V(V({}, e2.properties), { cluster: true, cluster_id: e2.id, point_count: t4, point_count_abbreviated: r2 });
        }
        function Y(e2) {
          return e2 / 360 + 0.5;
        }
        function j(e2) {
          var t4 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t4) / (1 - t4)) / Math.PI;
          return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
        }
        function V(e2, t4) {
          for (var r2 in t4)
            e2[r2] = t4[r2];
          return e2;
        }
        function X(e2) {
          return e2.x;
        }
        function W(e2) {
          return e2.y;
        }
        function R(e2, t4, r2, i3, o2, n2) {
          var a2 = o2 - r2, s2 = n2 - i3;
          if (0 !== a2 || 0 !== s2) {
            var l2 = ((e2 - r2) * a2 + (t4 - i3) * s2) / (a2 * a2 + s2 * s2);
            l2 > 1 ? (r2 = o2, i3 = n2) : l2 > 0 && (r2 += a2 * l2, i3 += s2 * l2);
          }
          return (a2 = e2 - r2) * a2 + (s2 = t4 - i3) * s2;
        }
        function q(e2, t4, r2, i3) {
          var o2 = { id: void 0 === e2 ? null : e2, type: t4, geometry: r2, tags: i3, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e3) {
            var t5 = e3.geometry, r3 = e3.type;
            if ("Point" === r3 || "MultiPoint" === r3 || "LineString" === r3)
              U(e3, t5);
            else if ("Polygon" === r3 || "MultiLineString" === r3)
              for (var i4 = 0; i4 < t5.length; i4++)
                U(e3, t5[i4]);
            else if ("MultiPolygon" === r3)
              for (i4 = 0; i4 < t5.length; i4++)
                for (var o3 = 0; o3 < t5[i4].length; o3++)
                  U(e3, t5[i4][o3]);
          }(o2), o2;
        }
        function U(e2, t4) {
          for (var r2 = 0; r2 < t4.length; r2 += 3)
            e2.minX = Math.min(e2.minX, t4[r2]), e2.minY = Math.min(e2.minY, t4[r2 + 1]), e2.maxX = Math.max(e2.maxX, t4[r2]), e2.maxY = Math.max(e2.maxY, t4[r2 + 1]);
        }
        function $(e2, t4, r2, i3) {
          if (t4.geometry) {
            var o2 = t4.geometry.coordinates, n2 = t4.geometry.type, a2 = Math.pow(r2.tolerance / ((1 << r2.maxZoom) * r2.extent), 2), s2 = [], l2 = t4.id;
            if (r2.promoteId ? l2 = t4.properties[r2.promoteId] : r2.generateId && (l2 = i3 || 0), "Point" === n2)
              H(o2, s2);
            else if ("MultiPoint" === n2)
              for (var u2 = 0; u2 < o2.length; u2++)
                H(o2[u2], s2);
            else if ("LineString" === n2)
              K2(o2, s2, a2, false);
            else if ("MultiLineString" === n2) {
              if (r2.lineMetrics) {
                for (u2 = 0; u2 < o2.length; u2++)
                  K2(o2[u2], s2 = [], a2, false), e2.push(q(l2, "LineString", s2, t4.properties));
                return;
              }
              Q(o2, s2, a2, false);
            } else if ("Polygon" === n2)
              Q(o2, s2, a2, true);
            else {
              if ("MultiPolygon" !== n2) {
                if ("GeometryCollection" === n2) {
                  for (u2 = 0; u2 < t4.geometry.geometries.length; u2++)
                    $(e2, { id: l2, geometry: t4.geometry.geometries[u2], properties: t4.properties }, r2, i3);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (u2 = 0; u2 < o2.length; u2++) {
                var h2 = [];
                Q(o2[u2], h2, a2, true), s2.push(h2);
              }
            }
            e2.push(q(l2, n2, s2, t4.properties));
          }
        }
        function H(e2, t4) {
          t4.push(ee(e2[0])), t4.push(te(e2[1])), t4.push(0);
        }
        function K2(e2, t4, r2, i3) {
          for (var o2, n2, a2 = 0, s2 = 0; s2 < e2.length; s2++) {
            var l2 = ee(e2[s2][0]), u2 = te(e2[s2][1]);
            t4.push(l2), t4.push(u2), t4.push(0), s2 > 0 && (a2 += i3 ? (o2 * u2 - l2 * n2) / 2 : Math.sqrt(Math.pow(l2 - o2, 2) + Math.pow(u2 - n2, 2))), o2 = l2, n2 = u2;
          }
          var h2 = t4.length - 3;
          t4[2] = 1, function e3(t5, r3, i4, o3) {
            for (var n3, a3 = o3, s3 = i4 - r3 >> 1, l3 = i4 - r3, u3 = t5[r3], h3 = t5[r3 + 1], c2 = t5[i4], p2 = t5[i4 + 1], f2 = r3 + 3; f2 < i4; f2 += 3) {
              var d2 = R(t5[f2], t5[f2 + 1], u3, h3, c2, p2);
              if (d2 > a3)
                n3 = f2, a3 = d2;
              else if (d2 === a3) {
                var g2 = Math.abs(f2 - s3);
                g2 < l3 && (n3 = f2, l3 = g2);
              }
            }
            a3 > o3 && (n3 - r3 > 3 && e3(t5, r3, n3, o3), t5[n3 + 2] = a3, i4 - n3 > 3 && e3(t5, n3, i4, o3));
          }(t4, 0, h2, r2), t4[h2 + 2] = 1, t4.size = Math.abs(a2), t4.start = 0, t4.end = t4.size;
        }
        function Q(e2, t4, r2, i3) {
          for (var o2 = 0; o2 < e2.length; o2++) {
            var n2 = [];
            K2(e2[o2], n2, r2, i3), t4.push(n2);
          }
        }
        function ee(e2) {
          return e2 / 360 + 0.5;
        }
        function te(e2) {
          var t4 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t4) / (1 - t4)) / Math.PI;
          return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
        }
        function re(e2, t4, r2, i3, o2, n2, a2, s2) {
          if (i3 /= t4, n2 >= (r2 /= t4) && a2 < i3)
            return e2;
          if (a2 < r2 || n2 >= i3)
            return null;
          for (var l2 = [], u2 = 0; u2 < e2.length; u2++) {
            var h2 = e2[u2], c2 = h2.geometry, p2 = h2.type, f2 = 0 === o2 ? h2.minX : h2.minY, d2 = 0 === o2 ? h2.maxX : h2.maxY;
            if (f2 >= r2 && d2 < i3)
              l2.push(h2);
            else if (!(d2 < r2 || f2 >= i3)) {
              var g2 = [];
              if ("Point" === p2 || "MultiPoint" === p2)
                ie(c2, g2, r2, i3, o2);
              else if ("LineString" === p2)
                oe(c2, g2, r2, i3, o2, false, s2.lineMetrics);
              else if ("MultiLineString" === p2)
                ae(c2, g2, r2, i3, o2, false);
              else if ("Polygon" === p2)
                ae(c2, g2, r2, i3, o2, true);
              else if ("MultiPolygon" === p2)
                for (var v2 = 0; v2 < c2.length; v2++) {
                  var m2 = [];
                  ae(c2[v2], m2, r2, i3, o2, true), m2.length && g2.push(m2);
                }
              if (g2.length) {
                if (s2.lineMetrics && "LineString" === p2) {
                  for (v2 = 0; v2 < g2.length; v2++)
                    l2.push(q(h2.id, p2, g2[v2], h2.tags));
                  continue;
                }
                "LineString" !== p2 && "MultiLineString" !== p2 || (1 === g2.length ? (p2 = "LineString", g2 = g2[0]) : p2 = "MultiLineString"), "Point" !== p2 && "MultiPoint" !== p2 || (p2 = 3 === g2.length ? "Point" : "MultiPoint"), l2.push(q(h2.id, p2, g2, h2.tags));
              }
            }
          }
          return l2.length ? l2 : null;
        }
        function ie(e2, t4, r2, i3, o2) {
          for (var n2 = 0; n2 < e2.length; n2 += 3) {
            var a2 = e2[n2 + o2];
            a2 >= r2 && a2 <= i3 && (t4.push(e2[n2]), t4.push(e2[n2 + 1]), t4.push(e2[n2 + 2]));
          }
        }
        function oe(e2, t4, r2, i3, o2, n2, a2) {
          for (var s2, l2, u2 = ne(e2), h2 = 0 === o2 ? le : ue, c2 = e2.start, p2 = 0; p2 < e2.length - 3; p2 += 3) {
            var f2 = e2[p2], d2 = e2[p2 + 1], g2 = e2[p2 + 2], v2 = e2[p2 + 3], m2 = e2[p2 + 4], y2 = 0 === o2 ? f2 : d2, x3 = 0 === o2 ? v2 : m2, w2 = false;
            a2 && (s2 = Math.sqrt(Math.pow(f2 - v2, 2) + Math.pow(d2 - m2, 2))), y2 < r2 ? x3 > r2 && (l2 = h2(u2, f2, d2, v2, m2, r2), a2 && (u2.start = c2 + s2 * l2)) : y2 > i3 ? x3 < i3 && (l2 = h2(u2, f2, d2, v2, m2, i3), a2 && (u2.start = c2 + s2 * l2)) : se(u2, f2, d2, g2), x3 < r2 && y2 >= r2 && (l2 = h2(u2, f2, d2, v2, m2, r2), w2 = true), x3 > i3 && y2 <= i3 && (l2 = h2(u2, f2, d2, v2, m2, i3), w2 = true), !n2 && w2 && (a2 && (u2.end = c2 + s2 * l2), t4.push(u2), u2 = ne(e2)), a2 && (c2 += s2);
          }
          var S2 = e2.length - 3;
          f2 = e2[S2], d2 = e2[S2 + 1], g2 = e2[S2 + 2], (y2 = 0 === o2 ? f2 : d2) >= r2 && y2 <= i3 && se(u2, f2, d2, g2), S2 = u2.length - 3, n2 && S2 >= 3 && (u2[S2] !== u2[0] || u2[S2 + 1] !== u2[1]) && se(u2, u2[0], u2[1], u2[2]), u2.length && t4.push(u2);
        }
        function ne(e2) {
          var t4 = [];
          return t4.size = e2.size, t4.start = e2.start, t4.end = e2.end, t4;
        }
        function ae(e2, t4, r2, i3, o2, n2) {
          for (var a2 = 0; a2 < e2.length; a2++)
            oe(e2[a2], t4, r2, i3, o2, n2, false);
        }
        function se(e2, t4, r2, i3) {
          e2.push(t4), e2.push(r2), e2.push(i3);
        }
        function le(e2, t4, r2, i3, o2, n2) {
          var a2 = (n2 - t4) / (i3 - t4);
          return e2.push(n2), e2.push(r2 + (o2 - r2) * a2), e2.push(1), a2;
        }
        function ue(e2, t4, r2, i3, o2, n2) {
          var a2 = (n2 - r2) / (o2 - r2);
          return e2.push(t4 + (i3 - t4) * a2), e2.push(n2), e2.push(1), a2;
        }
        function he(e2, t4) {
          for (var r2 = [], i3 = 0; i3 < e2.length; i3++) {
            var o2, n2 = e2[i3], a2 = n2.type;
            if ("Point" === a2 || "MultiPoint" === a2 || "LineString" === a2)
              o2 = ce(n2.geometry, t4);
            else if ("MultiLineString" === a2 || "Polygon" === a2) {
              o2 = [];
              for (var s2 = 0; s2 < n2.geometry.length; s2++)
                o2.push(ce(n2.geometry[s2], t4));
            } else if ("MultiPolygon" === a2)
              for (o2 = [], s2 = 0; s2 < n2.geometry.length; s2++) {
                for (var l2 = [], u2 = 0; u2 < n2.geometry[s2].length; u2++)
                  l2.push(ce(n2.geometry[s2][u2], t4));
                o2.push(l2);
              }
            r2.push(q(n2.id, a2, o2, n2.tags));
          }
          return r2;
        }
        function ce(e2, t4) {
          var r2 = [];
          r2.size = e2.size, void 0 !== e2.start && (r2.start = e2.start, r2.end = e2.end);
          for (var i3 = 0; i3 < e2.length; i3 += 3)
            r2.push(e2[i3] + t4, e2[i3 + 1], e2[i3 + 2]);
          return r2;
        }
        function pe(e2, t4) {
          if (e2.transformed)
            return e2;
          var r2, i3, o2, n2 = 1 << e2.z, a2 = e2.x, s2 = e2.y;
          for (r2 = 0; r2 < e2.features.length; r2++) {
            var l2 = e2.features[r2], u2 = l2.geometry, h2 = l2.type;
            if (l2.geometry = [], 1 === h2)
              for (i3 = 0; i3 < u2.length; i3 += 2)
                l2.geometry.push(fe(u2[i3], u2[i3 + 1], t4, n2, a2, s2));
            else
              for (i3 = 0; i3 < u2.length; i3++) {
                var c2 = [];
                for (o2 = 0; o2 < u2[i3].length; o2 += 2)
                  c2.push(fe(u2[i3][o2], u2[i3][o2 + 1], t4, n2, a2, s2));
                l2.geometry.push(c2);
              }
          }
          return e2.transformed = true, e2;
        }
        function fe(e2, t4, r2, i3, o2, n2) {
          return [Math.round(r2 * (e2 * i3 - o2)), Math.round(r2 * (t4 * i3 - n2))];
        }
        function de(e2, t4, r2, i3, o2) {
          for (var n2 = t4 === o2.maxZoom ? 0 : o2.tolerance / ((1 << t4) * o2.extent), a2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r2, y: i3, z: t4, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, s2 = 0; s2 < e2.length; s2++) {
            a2.numFeatures++, ge(a2, e2[s2], n2, o2);
            var l2 = e2[s2].minX, u2 = e2[s2].minY, h2 = e2[s2].maxX, c2 = e2[s2].maxY;
            l2 < a2.minX && (a2.minX = l2), u2 < a2.minY && (a2.minY = u2), h2 > a2.maxX && (a2.maxX = h2), c2 > a2.maxY && (a2.maxY = c2);
          }
          return a2;
        }
        function ge(e2, t4, r2, i3) {
          var o2 = t4.geometry, n2 = t4.type, a2 = [];
          if ("Point" === n2 || "MultiPoint" === n2)
            for (var s2 = 0; s2 < o2.length; s2 += 3)
              a2.push(o2[s2]), a2.push(o2[s2 + 1]), e2.numPoints++, e2.numSimplified++;
          else if ("LineString" === n2)
            ve(a2, o2, e2, r2, false, false);
          else if ("MultiLineString" === n2 || "Polygon" === n2)
            for (s2 = 0; s2 < o2.length; s2++)
              ve(a2, o2[s2], e2, r2, "Polygon" === n2, 0 === s2);
          else if ("MultiPolygon" === n2)
            for (var l2 = 0; l2 < o2.length; l2++) {
              var u2 = o2[l2];
              for (s2 = 0; s2 < u2.length; s2++)
                ve(a2, u2[s2], e2, r2, true, 0 === s2);
            }
          if (a2.length) {
            var h2 = t4.tags || null;
            if ("LineString" === n2 && i3.lineMetrics) {
              for (var c2 in h2 = {}, t4.tags)
                h2[c2] = t4.tags[c2];
              h2.mapbox_clip_start = o2.start / o2.size, h2.mapbox_clip_end = o2.end / o2.size;
            }
            var p2 = { geometry: a2, type: "Polygon" === n2 || "MultiPolygon" === n2 ? 3 : "LineString" === n2 || "MultiLineString" === n2 ? 2 : 1, tags: h2 };
            null !== t4.id && (p2.id = t4.id), e2.features.push(p2);
          }
        }
        function ve(e2, t4, r2, i3, o2, n2) {
          var a2 = i3 * i3;
          if (i3 > 0 && t4.size < (o2 ? a2 : i3))
            r2.numPoints += t4.length / 3;
          else {
            for (var s2 = [], l2 = 0; l2 < t4.length; l2 += 3)
              (0 === i3 || t4[l2 + 2] > a2) && (r2.numSimplified++, s2.push(t4[l2]), s2.push(t4[l2 + 1])), r2.numPoints++;
            o2 && function(e3, t5) {
              for (var r3 = 0, i4 = 0, o3 = e3.length, n3 = o3 - 2; i4 < o3; n3 = i4, i4 += 2)
                r3 += (e3[i4] - e3[n3]) * (e3[i4 + 1] + e3[n3 + 1]);
              if (r3 > 0 === t5)
                for (i4 = 0, o3 = e3.length; i4 < o3 / 2; i4 += 2) {
                  var a3 = e3[i4], s3 = e3[i4 + 1];
                  e3[i4] = e3[o3 - 2 - i4], e3[i4 + 1] = e3[o3 - 1 - i4], e3[o3 - 2 - i4] = a3, e3[o3 - 1 - i4] = s3;
                }
            }(s2, n2), e2.push(s2);
          }
        }
        function me(e2, t4) {
          var r2 = (t4 = this.options = function(e3, t5) {
            for (var r3 in t5)
              e3[r3] = t5[r3];
            return e3;
          }(Object.create(this.options), t4)).debug;
          if (r2 && console.time("preprocess data"), t4.maxZoom < 0 || t4.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t4.promoteId && t4.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          var i3 = function(e3, t5) {
            var r3 = [];
            if ("FeatureCollection" === e3.type)
              for (var i4 = 0; i4 < e3.features.length; i4++)
                $(r3, e3.features[i4], t5, i4);
            else
              $(r3, "Feature" === e3.type ? e3 : { geometry: e3 }, t5);
            return r3;
          }(e2, t4);
          this.tiles = {}, this.tileCoords = [], r2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t4.indexMaxZoom, t4.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (i3 = function(e3, t5) {
            var r3 = t5.buffer / t5.extent, i4 = e3, o2 = re(e3, 1, -1 - r3, r3, 0, -1, 2, t5), n2 = re(e3, 1, 1 - r3, 2 + r3, 0, -1, 2, t5);
            return (o2 || n2) && (i4 = re(e3, 1, -r3, 1 + r3, 0, -1, 2, t5) || [], o2 && (i4 = he(o2, 1).concat(i4)), n2 && (i4 = i4.concat(he(n2, -1)))), i4;
          }(i3, t4)).length && this.splitTile(i3, 0, 0, 0), r2 && (i3.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function ye(e2, t4, r2) {
          return 32 * ((1 << e2) * r2 + t4) + e2;
        }
        function xe(e2, t4) {
          var r2 = e2.tileID.canonical;
          if (!this._geoJSONIndex)
            return t4(null, null);
          var i3 = this._geoJSONIndex.getTile(r2.z, r2.x, r2.y);
          if (!i3)
            return t4(null, null);
          var o2 = new g(i3.features), n2 = w(o2);
          0 === n2.byteOffset && n2.byteLength === n2.buffer.byteLength || (n2 = new Uint8Array(n2)), t4(null, { vectorTile: o2, rawData: n2.buffer });
        }
        J.prototype.load = function(e2) {
          var t4 = this.options, r2 = t4.log, i3 = t4.minZoom, o2 = t4.maxZoom, n2 = t4.nodeSize;
          r2 && console.time("total time");
          var a2 = "prepare " + e2.length + " points";
          r2 && console.time(a2), this.points = e2;
          for (var s2 = [], l2 = 0; l2 < e2.length; l2++)
            e2[l2].geometry && s2.push(A2(e2[l2], l2));
          this.trees[o2 + 1] = new F(s2, X, W, n2, Float32Array), r2 && console.timeEnd(a2);
          for (var u2 = o2; u2 >= i3; u2--) {
            var h2 = +Date.now();
            s2 = this._cluster(s2, u2), this.trees[u2] = new F(s2, X, W, n2, Float32Array), r2 && console.log("z%d: %d clusters in %dms", u2, s2.length, +Date.now() - h2);
          }
          return r2 && console.timeEnd("total time"), this;
        }, J.prototype.getClusters = function(e2, t4) {
          var r2 = ((e2[0] + 180) % 360 + 360) % 360 - 180, i3 = Math.max(-90, Math.min(90, e2[1])), o2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180, n2 = Math.max(-90, Math.min(90, e2[3]));
          if (e2[2] - e2[0] >= 360)
            r2 = -180, o2 = 180;
          else if (r2 > o2) {
            var a2 = this.getClusters([r2, i3, 180, n2], t4), s2 = this.getClusters([-180, i3, o2, n2], t4);
            return a2.concat(s2);
          }
          for (var l2 = this.trees[this._limitZoom(t4)], u2 = [], h2 = 0, c2 = l2.range(Y(r2), j(n2), Y(o2), j(i3)); h2 < c2.length; h2 += 1) {
            var p2 = l2.points[c2[h2]];
            u2.push(p2.numPoints ? B2(p2) : this.points[p2.index]);
          }
          return u2;
        }, J.prototype.getChildren = function(e2) {
          var t4 = this._getOriginId(e2), r2 = this._getOriginZoom(e2), i3 = "No cluster with the specified id.", o2 = this.trees[r2];
          if (!o2)
            throw new Error(i3);
          var n2 = o2.points[t4];
          if (!n2)
            throw new Error(i3);
          for (var a2 = this.options.radius / (this.options.extent * Math.pow(2, r2 - 1)), s2 = [], l2 = 0, u2 = o2.within(n2.x, n2.y, a2); l2 < u2.length; l2 += 1) {
            var h2 = o2.points[u2[l2]];
            h2.parentId === e2 && s2.push(h2.numPoints ? B2(h2) : this.points[h2.index]);
          }
          if (0 === s2.length)
            throw new Error(i3);
          return s2;
        }, J.prototype.getLeaves = function(e2, t4, r2) {
          var i3 = [];
          return this._appendLeaves(i3, e2, t4 = t4 || 10, r2 = r2 || 0, 0), i3;
        }, J.prototype.getTile = function(e2, t4, r2) {
          var i3 = this.trees[this._limitZoom(e2)], o2 = Math.pow(2, e2), n2 = this.options, a2 = n2.radius / n2.extent, s2 = (r2 - a2) / o2, l2 = (r2 + 1 + a2) / o2, u2 = { features: [] };
          return this._addTileFeatures(i3.range((t4 - a2) / o2, s2, (t4 + 1 + a2) / o2, l2), i3.points, t4, r2, o2, u2), 0 === t4 && this._addTileFeatures(i3.range(1 - a2 / o2, s2, 1, l2), i3.points, o2, r2, o2, u2), t4 === o2 - 1 && this._addTileFeatures(i3.range(0, s2, a2 / o2, l2), i3.points, -1, r2, o2, u2), u2.features.length ? u2 : null;
        }, J.prototype.getClusterExpansionZoom = function(e2) {
          for (var t4 = this._getOriginZoom(e2) - 1; t4 <= this.options.maxZoom; ) {
            var r2 = this.getChildren(e2);
            if (t4++, 1 !== r2.length)
              break;
            e2 = r2[0].properties.cluster_id;
          }
          return t4;
        }, J.prototype._appendLeaves = function(e2, t4, r2, i3, o2) {
          for (var n2 = 0, a2 = this.getChildren(t4); n2 < a2.length; n2 += 1) {
            var s2 = a2[n2], l2 = s2.properties;
            if (l2 && l2.cluster ? o2 + l2.point_count <= i3 ? o2 += l2.point_count : o2 = this._appendLeaves(e2, l2.cluster_id, r2, i3, o2) : o2 < i3 ? o2++ : e2.push(s2), e2.length === r2)
              break;
          }
          return o2;
        }, J.prototype._addTileFeatures = function(e2, t4, r2, i3, o2, n2) {
          for (var a2 = 0, s2 = e2; a2 < s2.length; a2 += 1) {
            var l2 = t4[s2[a2]], u2 = l2.numPoints, h2 = { type: 1, geometry: [[Math.round(this.options.extent * (l2.x * o2 - r2)), Math.round(this.options.extent * (l2.y * o2 - i3))]], tags: u2 ? G(l2) : this.points[l2.index].properties }, c2 = void 0;
            u2 ? c2 = l2.id : this.options.generateId ? c2 = l2.index : this.points[l2.index].id && (c2 = this.points[l2.index].id), void 0 !== c2 && (h2.id = c2), n2.features.push(h2);
          }
        }, J.prototype._limitZoom = function(e2) {
          return Math.max(this.options.minZoom, Math.min(+e2, this.options.maxZoom + 1));
        }, J.prototype._cluster = function(e2, t4) {
          for (var r2 = [], i3 = this.options, o2 = i3.reduce, n2 = i3.minPoints, a2 = i3.radius / (i3.extent * Math.pow(2, t4)), s2 = 0; s2 < e2.length; s2++) {
            var l2 = e2[s2];
            if (!(l2.zoom <= t4)) {
              l2.zoom = t4;
              for (var u2 = this.trees[t4 + 1], h2 = u2.within(l2.x, l2.y, a2), c2 = l2.numPoints || 1, p2 = c2, f2 = 0, d2 = h2; f2 < d2.length; f2 += 1) {
                var g2 = u2.points[d2[f2]];
                g2.zoom > t4 && (p2 += g2.numPoints || 1);
              }
              if (p2 >= n2) {
                for (var v2 = l2.x * c2, m2 = l2.y * c2, y2 = o2 && c2 > 1 ? this._map(l2, true) : null, x3 = (s2 << 5) + (t4 + 1) + this.points.length, w2 = 0, S2 = h2; w2 < S2.length; w2 += 1) {
                  var I2 = u2.points[S2[w2]];
                  if (!(I2.zoom <= t4)) {
                    I2.zoom = t4;
                    var M2 = I2.numPoints || 1;
                    v2 += I2.x * M2, m2 += I2.y * M2, I2.parentId = x3, o2 && (y2 || (y2 = this._map(l2, true)), o2(y2, this._map(I2)));
                  }
                }
                l2.parentId = x3, r2.push(Z(v2 / p2, m2 / p2, x3, p2, y2));
              } else if (r2.push(l2), p2 > 1)
                for (var b2 = 0, _2 = h2; b2 < _2.length; b2 += 1) {
                  var k2 = u2.points[_2[b2]];
                  k2.zoom <= t4 || (k2.zoom = t4, r2.push(k2));
                }
            }
          }
          return r2;
        }, J.prototype._getOriginId = function(e2) {
          return e2 - this.points.length >> 5;
        }, J.prototype._getOriginZoom = function(e2) {
          return (e2 - this.points.length) % 32;
        }, J.prototype._map = function(e2, t4) {
          if (e2.numPoints)
            return t4 ? V({}, e2.properties) : e2.properties;
          var r2 = this.points[e2.index].properties, i3 = this.options.map(r2);
          return t4 && i3 === r2 ? V({}, i3) : i3;
        }, me.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, me.prototype.splitTile = function(e2, t4, r2, i3, o2, n2, a2) {
          for (var s2 = [e2, t4, r2, i3], l2 = this.options, u2 = l2.debug; s2.length; ) {
            i3 = s2.pop(), r2 = s2.pop(), t4 = s2.pop(), e2 = s2.pop();
            var h2 = 1 << t4, c2 = ye(t4, r2, i3), p2 = this.tiles[c2];
            if (!p2 && (u2 > 1 && console.time("creation"), p2 = this.tiles[c2] = de(e2, t4, r2, i3, l2), this.tileCoords.push({ z: t4, x: r2, y: i3 }), u2)) {
              u2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t4, r2, i3, p2.numFeatures, p2.numPoints, p2.numSimplified), console.timeEnd("creation"));
              var f2 = "z" + t4;
              this.stats[f2] = (this.stats[f2] || 0) + 1, this.total++;
            }
            if (p2.source = e2, o2) {
              if (t4 === l2.maxZoom || t4 === o2)
                continue;
              var d2 = 1 << o2 - t4;
              if (r2 !== Math.floor(n2 / d2) || i3 !== Math.floor(a2 / d2))
                continue;
            } else if (t4 === l2.indexMaxZoom || p2.numPoints <= l2.indexMaxPoints)
              continue;
            if (p2.source = null, 0 !== e2.length) {
              u2 > 1 && console.time("clipping");
              var g2, v2, m2, y2, x3, w2, S2 = 0.5 * l2.buffer / l2.extent, I2 = 0.5 - S2, M2 = 0.5 + S2, b2 = 1 + S2;
              g2 = v2 = m2 = y2 = null, x3 = re(e2, h2, r2 - S2, r2 + M2, 0, p2.minX, p2.maxX, l2), w2 = re(e2, h2, r2 + I2, r2 + b2, 0, p2.minX, p2.maxX, l2), e2 = null, x3 && (g2 = re(x3, h2, i3 - S2, i3 + M2, 1, p2.minY, p2.maxY, l2), v2 = re(x3, h2, i3 + I2, i3 + b2, 1, p2.minY, p2.maxY, l2), x3 = null), w2 && (m2 = re(w2, h2, i3 - S2, i3 + M2, 1, p2.minY, p2.maxY, l2), y2 = re(w2, h2, i3 + I2, i3 + b2, 1, p2.minY, p2.maxY, l2), w2 = null), u2 > 1 && console.timeEnd("clipping"), s2.push(g2 || [], t4 + 1, 2 * r2, 2 * i3), s2.push(v2 || [], t4 + 1, 2 * r2, 2 * i3 + 1), s2.push(m2 || [], t4 + 1, 2 * r2 + 1, 2 * i3), s2.push(y2 || [], t4 + 1, 2 * r2 + 1, 2 * i3 + 1);
            }
          }
        }, me.prototype.getTile = function(e2, t4, r2) {
          var i3 = this.options, o2 = i3.extent, n2 = i3.debug;
          if (e2 < 0 || e2 > 24)
            return null;
          var a2 = 1 << e2, s2 = ye(e2, t4 = (t4 % a2 + a2) % a2, r2);
          if (this.tiles[s2])
            return pe(this.tiles[s2], o2);
          n2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t4, r2);
          for (var l2, u2 = e2, h2 = t4, c2 = r2; !l2 && u2 > 0; )
            u2--, h2 = Math.floor(h2 / 2), c2 = Math.floor(c2 / 2), l2 = this.tiles[ye(u2, h2, c2)];
          return l2 && l2.source ? (n2 > 1 && console.log("found parent tile z%d-%d-%d", u2, h2, c2), n2 > 1 && console.time("drilling down"), this.splitTile(l2.source, u2, h2, c2, e2, t4, r2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[s2] ? pe(this.tiles[s2], o2) : null) : null;
        };
        var we = function(t4) {
          function r2(e2, r3, i3, o2) {
            t4.call(this, e2, r3, i3, xe), o2 && (this.loadGeoJSON = o2);
          }
          return t4 && (r2.__proto__ = t4), (r2.prototype = Object.create(t4 && t4.prototype)).constructor = r2, r2.prototype.loadData = function(e2, t5) {
            this._pendingCallback && this._pendingCallback(null, { abandoned: true }), this._pendingCallback = t5, this._pendingLoadDataParams = e2, this._state && "Idle" !== this._state ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());
          }, r2.prototype._loadData = function() {
            var t5 = this;
            if (this._pendingCallback && this._pendingLoadDataParams) {
              var r3 = this._pendingCallback, i3 = this._pendingLoadDataParams;
              delete this._pendingCallback, delete this._pendingLoadDataParams;
              var o2 = !!(i3 && i3.request && i3.request.collectResourceTiming) && new e.RequestPerformance(i3.request);
              this.loadGeoJSON(i3, function(n2, a2) {
                if (n2 || !a2)
                  return r3(n2);
                if ("object" != typeof a2)
                  return r3(new Error("Input data given to '" + i3.source + "' is not a valid GeoJSON object."));
                !function e2(t6, r4) {
                  var i4, o3 = t6 && t6.type;
                  if ("FeatureCollection" === o3)
                    for (i4 = 0; i4 < t6.features.length; i4++)
                      e2(t6.features[i4], r4);
                  else if ("GeometryCollection" === o3)
                    for (i4 = 0; i4 < t6.geometries.length; i4++)
                      e2(t6.geometries[i4], r4);
                  else if ("Feature" === o3)
                    e2(t6.geometry, r4);
                  else if ("Polygon" === o3)
                    c(t6.coordinates, r4);
                  else if ("MultiPolygon" === o3)
                    for (i4 = 0; i4 < t6.coordinates.length; i4++)
                      c(t6.coordinates[i4], r4);
                  return t6;
                }(a2, true);
                try {
                  if (i3.filter) {
                    var s2 = e.createExpression(i3.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                    if ("error" === s2.result)
                      throw new Error(s2.value.map(function(e2) {
                        return e2.key + ": " + e2.message;
                      }).join(", "));
                    var l2 = a2.features.filter(function(e2) {
                      return s2.value.evaluate({ zoom: 0 }, e2);
                    });
                    a2 = { type: "FeatureCollection", features: l2 };
                  }
                  t5._geoJSONIndex = i3.cluster ? new J(function(t6) {
                    var r4 = t6.superclusterOptions, i4 = t6.clusterProperties;
                    if (!i4 || !r4)
                      return r4;
                    for (var o3 = {}, n3 = {}, a3 = { accumulated: null, zoom: 0 }, s3 = { properties: null }, l3 = Object.keys(i4), u3 = 0, h3 = l3; u3 < h3.length; u3 += 1) {
                      var c2 = h3[u3], p2 = i4[c2], f2 = p2[0], d2 = e.createExpression(p2[1]), g2 = e.createExpression("string" == typeof f2 ? [f2, ["accumulated"], ["get", c2]] : f2);
                      o3[c2] = d2.value, n3[c2] = g2.value;
                    }
                    return r4.map = function(e2) {
                      s3.properties = e2;
                      for (var t7 = {}, r5 = 0, i5 = l3; r5 < i5.length; r5 += 1) {
                        var n4 = i5[r5];
                        t7[n4] = o3[n4].evaluate(a3, s3);
                      }
                      return t7;
                    }, r4.reduce = function(e2, t7) {
                      s3.properties = t7;
                      for (var r5 = 0, i5 = l3; r5 < i5.length; r5 += 1) {
                        var o4 = i5[r5];
                        a3.accumulated = e2[o4], e2[o4] = n3[o4].evaluate(a3, s3);
                      }
                    }, r4;
                  }(i3)).load(a2.features) : function(e2, t6) {
                    return new me(e2, t6);
                  }(a2, i3.geojsonVtOptions);
                } catch (n3) {
                  return r3(n3);
                }
                t5.loaded = {};
                var u2 = {};
                if (o2) {
                  var h2 = o2.finish();
                  h2 && (u2.resourceTiming = {}, u2.resourceTiming[i3.source] = JSON.parse(JSON.stringify(h2)));
                }
                r3(null, u2);
              });
            }
          }, r2.prototype.coalesce = function() {
            "Coalescing" === this._state ? this._state = "Idle" : "NeedsLoadData" === this._state && (this._state = "Coalescing", this._loadData());
          }, r2.prototype.reloadTile = function(e2, r3) {
            var i3 = this.loaded;
            return i3 && i3[e2.uid] ? t4.prototype.reloadTile.call(this, e2, r3) : this.loadTile(e2, r3);
          }, r2.prototype.loadGeoJSON = function(t5, r3) {
            if (t5.request)
              e.getJSON(t5.request, r3);
            else {
              if ("string" != typeof t5.data)
                return r3(new Error("Input data given to '" + t5.source + "' is not a valid GeoJSON object."));
              try {
                return r3(null, JSON.parse(t5.data));
              } catch (e2) {
                return r3(new Error("Input data given to '" + t5.source + "' is not a valid GeoJSON object."));
              }
            }
          }, r2.prototype.removeSource = function(e2, t5) {
            this._pendingCallback && this._pendingCallback(null, { abandoned: true }), t5();
          }, r2.prototype.getClusterExpansionZoom = function(e2, t5) {
            try {
              t5(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
            } catch (e3) {
              t5(e3);
            }
          }, r2.prototype.getClusterChildren = function(e2, t5) {
            try {
              t5(null, this._geoJSONIndex.getChildren(e2.clusterId));
            } catch (e3) {
              t5(e3);
            }
          }, r2.prototype.getClusterLeaves = function(e2, t5) {
            try {
              t5(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
            } catch (e3) {
              t5(e3);
            }
          }, r2;
        }(l), Se = function(t4) {
          var r2 = this;
          this.self = t4, this.actor = new e.Actor(t4, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: l, geojson: we }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function(e2, t5) {
            if (r2.workerSourceTypes[e2])
              throw new Error('Worker source with name "' + e2 + '" already registered.');
            r2.workerSourceTypes[e2] = t5;
          }, this.self.registerRTLTextPlugin = function(t5) {
            if (e.plugin.isParsed())
              throw new Error("RTL text plugin already registered.");
            e.plugin.applyArabicShaping = t5.applyArabicShaping, e.plugin.processBidirectionalText = t5.processBidirectionalText, e.plugin.processStyledBidirectionalText = t5.processStyledBidirectionalText;
          };
        };
        return Se.prototype.setReferrer = function(e2, t4) {
          this.referrer = t4;
        }, Se.prototype.setImages = function(e2, t4, r2) {
          for (var i3 in this.availableImages[e2] = t4, this.workerSources[e2]) {
            var o2 = this.workerSources[e2][i3];
            for (var n2 in o2)
              o2[n2].availableImages = t4;
          }
          r2();
        }, Se.prototype.setLayers = function(e2, t4, r2) {
          this.getLayerIndex(e2).replace(t4), r2();
        }, Se.prototype.updateLayers = function(e2, t4, r2) {
          this.getLayerIndex(e2).update(t4.layers, t4.removedIds), r2();
        }, Se.prototype.loadTile = function(e2, t4, r2) {
          this.getWorkerSource(e2, t4.type, t4.source).loadTile(t4, r2);
        }, Se.prototype.loadDEMTile = function(e2, t4, r2) {
          this.getDEMWorkerSource(e2, t4.source).loadTile(t4, r2);
        }, Se.prototype.reloadTile = function(e2, t4, r2) {
          this.getWorkerSource(e2, t4.type, t4.source).reloadTile(t4, r2);
        }, Se.prototype.abortTile = function(e2, t4, r2) {
          this.getWorkerSource(e2, t4.type, t4.source).abortTile(t4, r2);
        }, Se.prototype.removeTile = function(e2, t4, r2) {
          this.getWorkerSource(e2, t4.type, t4.source).removeTile(t4, r2);
        }, Se.prototype.removeDEMTile = function(e2, t4) {
          this.getDEMWorkerSource(e2, t4.source).removeTile(t4);
        }, Se.prototype.removeSource = function(e2, t4, r2) {
          if (this.workerSources[e2] && this.workerSources[e2][t4.type] && this.workerSources[e2][t4.type][t4.source]) {
            var i3 = this.workerSources[e2][t4.type][t4.source];
            delete this.workerSources[e2][t4.type][t4.source], void 0 !== i3.removeSource ? i3.removeSource(t4, r2) : r2();
          }
        }, Se.prototype.loadWorkerSource = function(e2, t4, r2) {
          try {
            this.self.importScripts(t4.url), r2();
          } catch (e3) {
            r2(e3.toString());
          }
        }, Se.prototype.syncRTLPluginState = function(t4, r2, i3) {
          try {
            e.plugin.setState(r2);
            var o2 = e.plugin.getPluginURL();
            if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != o2) {
              this.self.importScripts(o2);
              var n2 = e.plugin.isParsed();
              i3(n2 ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + o2), n2);
            }
          } catch (e2) {
            i3(e2.toString());
          }
        }, Se.prototype.getAvailableImages = function(e2) {
          var t4 = this.availableImages[e2];
          return t4 || (t4 = []), t4;
        }, Se.prototype.getLayerIndex = function(e2) {
          var t4 = this.layerIndexes[e2];
          return t4 || (t4 = this.layerIndexes[e2] = new i2()), t4;
        }, Se.prototype.getWorkerSource = function(e2, t4, r2) {
          var i3 = this;
          return this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t4] || (this.workerSources[e2][t4] = {}), this.workerSources[e2][t4][r2] || (this.workerSources[e2][t4][r2] = new this.workerSourceTypes[t4]({ send: function(t5, r3, o2) {
            i3.actor.send(t5, r3, o2, e2);
          } }, this.getLayerIndex(e2), this.getAvailableImages(e2))), this.workerSources[e2][t4][r2];
        }, Se.prototype.getDEMWorkerSource = function(e2, t4) {
          return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t4] || (this.demWorkerSources[e2][t4] = new h()), this.demWorkerSources[e2][t4];
        }, Se.prototype.enforceCacheSizeLimit = function(t4, r2) {
          e.enforceCacheSizeLimit(r2);
        }, "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Se(self)), Se;
      });
      define2(["./shared"], function(t) {
        "use strict";
        var e = t.createCommonjsModule(function(t4) {
          function e2(t5) {
            return !i3(t5);
          }
          function i3(t5) {
            return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window))
                return false;
              var t6, e3, i5 = new Blob([""], { type: "text/javascript" }), o3 = URL.createObjectURL(i5);
              try {
                e3 = new Worker(o3), t6 = true;
              } catch (e4) {
                t6 = false;
              }
              return e3 && e3.terminate(), URL.revokeObjectURL(o3), t6;
            }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
              var t6 = document.createElement("canvas");
              t6.width = t6.height = 1;
              var e3 = t6.getContext("2d");
              if (!e3)
                return false;
              var i5 = e3.getImageData(0, 0, 1, 1);
              return i5 && i5.width === t6.width;
            }() ? (void 0 === o2[i4 = t5 && t5.failIfMajorPerformanceCaveat] && (o2[i4] = function(t6) {
              var i5 = function(t7) {
                var i6 = document.createElement("canvas"), o4 = Object.create(e2.webGLContextAttributes);
                return o4.failIfMajorPerformanceCaveat = t7, i6.probablySupportsContext ? i6.probablySupportsContext("webgl", o4) || i6.probablySupportsContext("experimental-webgl", o4) : i6.supportsContext ? i6.supportsContext("webgl", o4) || i6.supportsContext("experimental-webgl", o4) : i6.getContext("webgl", o4) || i6.getContext("experimental-webgl", o4);
              }(t6);
              if (!i5)
                return false;
              var o3 = i5.createShader(i5.VERTEX_SHADER);
              return !(!o3 || i5.isContextLost()) && (i5.shaderSource(o3, "void main() {}"), i5.compileShader(o3), true === i5.getShaderParameter(o3, i5.COMPILE_STATUS));
            }(i4)), o2[i4] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
            var i4;
          }
          t4.exports ? t4.exports = e2 : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = e2, window.mapboxgl.notSupportedReason = i3);
          var o2 = {};
          e2.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
        }), i2 = { create: function(e2, i3, o2) {
          var r2 = t.window.document.createElement(e2);
          return void 0 !== i3 && (r2.className = i3), o2 && o2.appendChild(r2), r2;
        }, createNS: function(e2, i3) {
          return t.window.document.createElementNS(e2, i3);
        } }, o = t.window.document && t.window.document.documentElement.style;
        function r(t4) {
          if (!o)
            return t4[0];
          for (var e2 = 0; e2 < t4.length; e2++)
            if (t4[e2] in o)
              return t4[e2];
          return t4[0];
        }
        var a, n = r(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]);
        i2.disableDrag = function() {
          o && n && (a = o[n], o[n] = "none");
        }, i2.enableDrag = function() {
          o && n && (o[n] = a);
        };
        var s = r(["transform", "WebkitTransform"]);
        i2.setTransform = function(t4, e2) {
          t4.style[s] = e2;
        };
        var l = false;
        try {
          var c = Object.defineProperty({}, "passive", { get: function() {
            l = true;
          } });
          t.window.addEventListener("test", c, c), t.window.removeEventListener("test", c, c);
        } catch (t4) {
          l = false;
        }
        i2.addEventListener = function(t4, e2, i3, o2) {
          void 0 === o2 && (o2 = {}), t4.addEventListener(e2, i3, "passive" in o2 && l ? o2 : o2.capture);
        }, i2.removeEventListener = function(t4, e2, i3, o2) {
          void 0 === o2 && (o2 = {}), t4.removeEventListener(e2, i3, "passive" in o2 && l ? o2 : o2.capture);
        };
        var u = function(e2) {
          e2.preventDefault(), e2.stopPropagation(), t.window.removeEventListener("click", u, true);
        };
        function h(t4) {
          var e2 = t4.userImage;
          return !!(e2 && e2.render && e2.render()) && (t4.data.replace(new Uint8Array(e2.data.buffer)), true);
        }
        i2.suppressClick = function() {
          t.window.addEventListener("click", u, true), t.window.setTimeout(function() {
            t.window.removeEventListener("click", u, true);
          }, 0);
        }, i2.mousePos = function(e2, i3) {
          var o2 = e2.getBoundingClientRect();
          return new t.Point(i3.clientX - o2.left - e2.clientLeft, i3.clientY - o2.top - e2.clientTop);
        }, i2.touchPos = function(e2, i3) {
          for (var o2 = e2.getBoundingClientRect(), r2 = [], a2 = 0; a2 < i3.length; a2++)
            r2.push(new t.Point(i3[a2].clientX - o2.left - e2.clientLeft, i3[a2].clientY - o2.top - e2.clientTop));
          return r2;
        }, i2.mouseButton = function(e2) {
          return void 0 !== t.window.InstallTrigger && 2 === e2.button && e2.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e2.button;
        }, i2.remove = function(t4) {
          t4.parentNode && t4.parentNode.removeChild(t4);
        };
        var p = function(e2) {
          function i3() {
            e2.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.isLoaded = function() {
            return this.loaded;
          }, i3.prototype.setLoaded = function(t4) {
            if (this.loaded !== t4 && (this.loaded = t4, t4)) {
              for (var e3 = 0, i4 = this.requestors; e3 < i4.length; e3 += 1) {
                var o2 = i4[e3];
                this._notify(o2.ids, o2.callback);
              }
              this.requestors = [];
            }
          }, i3.prototype.getImage = function(t4) {
            return this.images[t4];
          }, i3.prototype.addImage = function(t4, e3) {
            this._validate(t4, e3) && (this.images[t4] = e3);
          }, i3.prototype._validate = function(e3, i4) {
            var o2 = true;
            return this._validateStretch(i4.stretchX, i4.data && i4.data.width) || (this.fire(new t.ErrorEvent(new Error('Image "' + e3 + '" has invalid "stretchX" value'))), o2 = false), this._validateStretch(i4.stretchY, i4.data && i4.data.height) || (this.fire(new t.ErrorEvent(new Error('Image "' + e3 + '" has invalid "stretchY" value'))), o2 = false), this._validateContent(i4.content, i4) || (this.fire(new t.ErrorEvent(new Error('Image "' + e3 + '" has invalid "content" value'))), o2 = false), o2;
          }, i3.prototype._validateStretch = function(t4, e3) {
            if (!t4)
              return true;
            for (var i4 = 0, o2 = 0, r2 = t4; o2 < r2.length; o2 += 1) {
              var a2 = r2[o2];
              if (a2[0] < i4 || a2[1] < a2[0] || e3 < a2[1])
                return false;
              i4 = a2[1];
            }
            return true;
          }, i3.prototype._validateContent = function(t4, e3) {
            return !(t4 && (4 !== t4.length || t4[0] < 0 || e3.data.width < t4[0] || t4[1] < 0 || e3.data.height < t4[1] || t4[2] < 0 || e3.data.width < t4[2] || t4[3] < 0 || e3.data.height < t4[3] || t4[2] < t4[0] || t4[3] < t4[1]));
          }, i3.prototype.updateImage = function(t4, e3) {
            e3.version = this.images[t4].version + 1, this.images[t4] = e3, this.updatedImages[t4] = true;
          }, i3.prototype.removeImage = function(t4) {
            var e3 = this.images[t4];
            delete this.images[t4], delete this.patterns[t4], e3.userImage && e3.userImage.onRemove && e3.userImage.onRemove();
          }, i3.prototype.listImages = function() {
            return Object.keys(this.images);
          }, i3.prototype.getImages = function(t4, e3) {
            var i4 = true;
            if (!this.isLoaded())
              for (var o2 = 0, r2 = t4; o2 < r2.length; o2 += 1)
                this.images[r2[o2]] || (i4 = false);
            this.isLoaded() || i4 ? this._notify(t4, e3) : this.requestors.push({ ids: t4, callback: e3 });
          }, i3.prototype._notify = function(e3, i4) {
            for (var o2 = {}, r2 = 0, a2 = e3; r2 < a2.length; r2 += 1) {
              var n2 = a2[r2];
              this.images[n2] || this.fire(new t.Event("styleimagemissing", { id: n2 }));
              var s2 = this.images[n2];
              s2 ? o2[n2] = { data: s2.data.clone(), pixelRatio: s2.pixelRatio, sdf: s2.sdf, version: s2.version, stretchX: s2.stretchX, stretchY: s2.stretchY, content: s2.content, hasRenderCallback: Boolean(s2.userImage && s2.userImage.render) } : t.warnOnce('Image "' + n2 + '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');
            }
            i4(null, o2);
          }, i3.prototype.getPixelSize = function() {
            var t4 = this.atlasImage;
            return { width: t4.width, height: t4.height };
          }, i3.prototype.getPattern = function(e3) {
            var i4 = this.patterns[e3], o2 = this.getImage(e3);
            if (!o2)
              return null;
            if (i4 && i4.position.version === o2.version)
              return i4.position;
            if (i4)
              i4.position.version = o2.version;
            else {
              var r2 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, a2 = new t.ImagePosition(r2, o2);
              this.patterns[e3] = { bin: r2, position: a2 };
            }
            return this._updatePatternAtlas(), this.patterns[e3].position;
          }, i3.prototype.bind = function(e3) {
            var i4 = e3.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new t.Texture(e3, this.atlasImage, i4.RGBA), this.atlasTexture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE);
          }, i3.prototype._updatePatternAtlas = function() {
            var e3 = [];
            for (var i4 in this.patterns)
              e3.push(this.patterns[i4].bin);
            var o2 = t.potpack(e3), r2 = o2.w, a2 = o2.h, n2 = this.atlasImage;
            for (var s2 in n2.resize({ width: r2 || 1, height: a2 || 1 }), this.patterns) {
              var l2 = this.patterns[s2].bin, c2 = l2.x + 1, u2 = l2.y + 1, h2 = this.images[s2].data, p2 = h2.width, d2 = h2.height;
              t.RGBAImage.copy(h2, n2, { x: 0, y: 0 }, { x: c2, y: u2 }, { width: p2, height: d2 }), t.RGBAImage.copy(h2, n2, { x: 0, y: d2 - 1 }, { x: c2, y: u2 - 1 }, { width: p2, height: 1 }), t.RGBAImage.copy(h2, n2, { x: 0, y: 0 }, { x: c2, y: u2 + d2 }, { width: p2, height: 1 }), t.RGBAImage.copy(h2, n2, { x: p2 - 1, y: 0 }, { x: c2 - 1, y: u2 }, { width: 1, height: d2 }), t.RGBAImage.copy(h2, n2, { x: 0, y: 0 }, { x: c2 + p2, y: u2 }, { width: 1, height: d2 });
            }
            this.dirty = true;
          }, i3.prototype.beginFrame = function() {
            this.callbackDispatchedThisFrame = {};
          }, i3.prototype.dispatchRenderCallbacks = function(t4) {
            for (var e3 = 0, i4 = t4; e3 < i4.length; e3 += 1) {
              var o2 = i4[e3];
              if (!this.callbackDispatchedThisFrame[o2]) {
                this.callbackDispatchedThisFrame[o2] = true;
                var r2 = this.images[o2];
                h(r2) && this.updateImage(o2, r2);
              }
            }
          }, i3;
        }(t.Evented), d = m, _ = m, f = 1e20;
        function m(t4, e2, i3, o2, r2, a2) {
          this.fontSize = t4 || 24, this.buffer = void 0 === e2 ? 3 : e2, this.cutoff = o2 || 0.25, this.fontFamily = r2 || "sans-serif", this.fontWeight = a2 || "normal", this.radius = i3 || 8;
          var n2 = this.size = this.fontSize + 2 * this.buffer;
          this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = n2, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.d = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Int16Array(n2), this.middle = Math.round(n2 / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
        }
        function g(t4, e2, i3, o2, r2, a2, n2) {
          for (var s2 = 0; s2 < e2; s2++) {
            for (var l2 = 0; l2 < i3; l2++)
              o2[l2] = t4[l2 * e2 + s2];
            for (v(o2, r2, a2, n2, i3), l2 = 0; l2 < i3; l2++)
              t4[l2 * e2 + s2] = r2[l2];
          }
          for (l2 = 0; l2 < i3; l2++) {
            for (s2 = 0; s2 < e2; s2++)
              o2[s2] = t4[l2 * e2 + s2];
            for (v(o2, r2, a2, n2, e2), s2 = 0; s2 < e2; s2++)
              t4[l2 * e2 + s2] = Math.sqrt(r2[s2]);
          }
        }
        function v(t4, e2, i3, o2, r2) {
          i3[0] = 0, o2[0] = -f, o2[1] = +f;
          for (var a2 = 1, n2 = 0; a2 < r2; a2++) {
            for (var s2 = (t4[a2] + a2 * a2 - (t4[i3[n2]] + i3[n2] * i3[n2])) / (2 * a2 - 2 * i3[n2]); s2 <= o2[n2]; )
              n2--, s2 = (t4[a2] + a2 * a2 - (t4[i3[n2]] + i3[n2] * i3[n2])) / (2 * a2 - 2 * i3[n2]);
            i3[++n2] = a2, o2[n2] = s2, o2[n2 + 1] = +f;
          }
          for (a2 = 0, n2 = 0; a2 < r2; a2++) {
            for (; o2[n2 + 1] < a2; )
              n2++;
            e2[a2] = (a2 - i3[n2]) * (a2 - i3[n2]) + t4[i3[n2]];
          }
        }
        m.prototype.draw = function(t4) {
          this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(t4, this.buffer, this.middle);
          for (var e2 = this.ctx.getImageData(0, 0, this.size, this.size), i3 = new Uint8ClampedArray(this.size * this.size), o2 = 0; o2 < this.size * this.size; o2++) {
            var r2 = e2.data[4 * o2 + 3] / 255;
            this.gridOuter[o2] = 1 === r2 ? 0 : 0 === r2 ? f : Math.pow(Math.max(0, 0.5 - r2), 2), this.gridInner[o2] = 1 === r2 ? f : 0 === r2 ? 0 : Math.pow(Math.max(0, r2 - 0.5), 2);
          }
          for (g(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), g(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), o2 = 0; o2 < this.size * this.size; o2++)
            i3[o2] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[o2] - this.gridInner[o2]) / this.radius + this.cutoff))));
          return i3;
        }, d.default = _;
        var y = function(t4, e2) {
          this.requestManager = t4, this.localIdeographFontFamily = e2, this.entries = {};
        };
        y.prototype.setURL = function(t4) {
          this.url = t4;
        }, y.prototype.getGlyphs = function(e2, i3) {
          var o2 = this, r2 = [];
          for (var a2 in e2)
            for (var n2 = 0, s2 = e2[a2]; n2 < s2.length; n2 += 1)
              r2.push({ stack: a2, id: s2[n2] });
          t.asyncAll(r2, function(t4, e3) {
            var i4 = t4.stack, r3 = t4.id, a3 = o2.entries[i4];
            a3 || (a3 = o2.entries[i4] = { glyphs: {}, requests: {}, ranges: {} });
            var n3 = a3.glyphs[r3];
            if (void 0 === n3) {
              if (n3 = o2._tinySDF(a3, i4, r3))
                return a3.glyphs[r3] = n3, void e3(null, { stack: i4, id: r3, glyph: n3 });
              var s3 = Math.floor(r3 / 256);
              if (256 * s3 > 65535)
                e3(new Error("glyphs > 65535 not supported"));
              else if (a3.ranges[s3])
                e3(null, { stack: i4, id: r3, glyph: n3 });
              else {
                var l2 = a3.requests[s3];
                l2 || (l2 = a3.requests[s3] = [], y.loadGlyphRange(i4, s3, o2.url, o2.requestManager, function(t5, e4) {
                  if (e4) {
                    for (var i5 in e4)
                      o2._doesCharSupportLocalGlyph(+i5) || (a3.glyphs[+i5] = e4[+i5]);
                    a3.ranges[s3] = true;
                  }
                  for (var r4 = 0, n4 = l2; r4 < n4.length; r4 += 1)
                    (0, n4[r4])(t5, e4);
                  delete a3.requests[s3];
                })), l2.push(function(t5, o3) {
                  t5 ? e3(t5) : o3 && e3(null, { stack: i4, id: r3, glyph: o3[r3] || null });
                });
              }
            } else
              e3(null, { stack: i4, id: r3, glyph: n3 });
          }, function(t4, e3) {
            if (t4)
              i3(t4);
            else if (e3) {
              for (var o3 = {}, r3 = 0, a3 = e3; r3 < a3.length; r3 += 1) {
                var n3 = a3[r3], s3 = n3.stack, l2 = n3.id, c2 = n3.glyph;
                (o3[s3] || (o3[s3] = {}))[l2] = c2 && { id: c2.id, bitmap: c2.bitmap.clone(), metrics: c2.metrics };
              }
              i3(null, o3);
            }
          });
        }, y.prototype._doesCharSupportLocalGlyph = function(e2) {
          return !!this.localIdeographFontFamily && (t.isChar["CJK Unified Ideographs"](e2) || t.isChar["Hangul Syllables"](e2) || t.isChar.Hiragana(e2) || t.isChar.Katakana(e2));
        }, y.prototype._tinySDF = function(e2, i3, o2) {
          var r2 = this.localIdeographFontFamily;
          if (r2 && this._doesCharSupportLocalGlyph(o2)) {
            var a2 = e2.tinySDF;
            if (!a2) {
              var n2 = "400";
              /bold/i.test(i3) ? n2 = "900" : /medium/i.test(i3) ? n2 = "500" : /light/i.test(i3) && (n2 = "200"), a2 = e2.tinySDF = new y.TinySDF(24, 3, 8, 0.25, r2, n2);
            }
            return { id: o2, bitmap: new t.AlphaImage({ width: 30, height: 30 }, a2.draw(String.fromCharCode(o2))), metrics: { width: 24, height: 24, left: 0, top: -8, advance: 24 } };
          }
        }, y.loadGlyphRange = function(e2, i3, o2, r2, a2) {
          var n2 = 256 * i3, s2 = n2 + 255, l2 = r2.transformRequest(r2.normalizeGlyphsURL(o2).replace("{fontstack}", e2).replace("{range}", n2 + "-" + s2), t.ResourceType.Glyphs);
          t.getArrayBuffer(l2, function(e3, i4) {
            if (e3)
              a2(e3);
            else if (i4) {
              for (var o3 = {}, r3 = 0, n3 = t.parseGlyphPBF(i4); r3 < n3.length; r3 += 1) {
                var s3 = n3[r3];
                o3[s3.id] = s3;
              }
              a2(null, o3);
            }
          });
        }, y.TinySDF = d;
        var x2 = function() {
          this.specification = t.styleSpec.light.position;
        };
        x2.prototype.possiblyEvaluate = function(e2, i3) {
          return t.sphericalToCartesian(e2.expression.evaluate(i3));
        }, x2.prototype.interpolate = function(e2, i3, o2) {
          return { x: t.number(e2.x, i3.x, o2), y: t.number(e2.y, i3.y, o2), z: t.number(e2.z, i3.z, o2) };
        };
        var b = new t.Properties({ anchor: new t.DataConstantProperty(t.styleSpec.light.anchor), position: new x2(), color: new t.DataConstantProperty(t.styleSpec.light.color), intensity: new t.DataConstantProperty(t.styleSpec.light.intensity) }), w = function(e2) {
          function i3(i4) {
            e2.call(this), this._transitionable = new t.Transitionable(b), this.setLight(i4), this._transitioning = this._transitionable.untransitioned();
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.getLight = function() {
            return this._transitionable.serialize();
          }, i3.prototype.setLight = function(e3, i4) {
            if (void 0 === i4 && (i4 = {}), !this._validate(t.validateLight, e3, i4))
              for (var o2 in e3) {
                var r2 = e3[o2];
                t.endsWith(o2, "-transition") ? this._transitionable.setTransition(o2.slice(0, -"-transition".length), r2) : this._transitionable.setValue(o2, r2);
              }
          }, i3.prototype.updateTransitions = function(t4) {
            this._transitioning = this._transitionable.transitioned(t4, this._transitioning);
          }, i3.prototype.hasTransition = function() {
            return this._transitioning.hasTransition();
          }, i3.prototype.recalculate = function(t4) {
            this.properties = this._transitioning.possiblyEvaluate(t4);
          }, i3.prototype._validate = function(e3, i4, o2) {
            return (!o2 || false !== o2.validate) && t.emitValidationErrors(this, e3.call(t.validateStyle, t.extend({ value: i4, style: { glyphs: true, sprite: true }, styleSpec: t.styleSpec })));
          }, i3;
        }(t.Evented), T2 = function(t4, e2) {
          this.width = t4, this.height = e2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        };
        T2.prototype.getDash = function(t4, e2) {
          var i3 = t4.join(",") + String(e2);
          return this.dashEntry[i3] || (this.dashEntry[i3] = this.addDash(t4, e2)), this.dashEntry[i3];
        }, T2.prototype.getDashRanges = function(t4, e2, i3) {
          var o2 = [], r2 = t4.length % 2 == 1 ? -t4[t4.length - 1] * i3 : 0, a2 = t4[0] * i3, n2 = true;
          o2.push({ left: r2, right: a2, isDash: n2, zeroLength: 0 === t4[0] });
          for (var s2 = t4[0], l2 = 1; l2 < t4.length; l2++) {
            var c2 = t4[l2];
            o2.push({ left: r2 = s2 * i3, right: a2 = (s2 += c2) * i3, isDash: n2 = !n2, zeroLength: 0 === c2 });
          }
          return o2;
        }, T2.prototype.addRoundDash = function(t4, e2, i3) {
          for (var o2 = e2 / 2, r2 = -i3; r2 <= i3; r2++)
            for (var a2 = this.width * (this.nextRow + i3 + r2), n2 = 0, s2 = t4[n2], l2 = 0; l2 < this.width; l2++) {
              l2 / s2.right > 1 && (s2 = t4[++n2]);
              var c2 = Math.abs(l2 - s2.left), u2 = Math.abs(l2 - s2.right), h2 = Math.min(c2, u2), p2 = void 0, d2 = r2 / i3 * (o2 + 1);
              if (s2.isDash) {
                var _2 = o2 - Math.abs(d2);
                p2 = Math.sqrt(h2 * h2 + _2 * _2);
              } else
                p2 = o2 - Math.sqrt(h2 * h2 + d2 * d2);
              this.data[a2 + l2] = Math.max(0, Math.min(255, p2 + 128));
            }
        }, T2.prototype.addRegularDash = function(t4) {
          for (var e2 = t4.length - 1; e2 >= 0; --e2) {
            var i3 = t4[e2], o2 = t4[e2 + 1];
            i3.zeroLength ? t4.splice(e2, 1) : o2 && o2.isDash === i3.isDash && (o2.left = i3.left, t4.splice(e2, 1));
          }
          var r2 = t4[0], a2 = t4[t4.length - 1];
          r2.isDash === a2.isDash && (r2.left = a2.left - this.width, a2.right = r2.right + this.width);
          for (var n2 = this.width * this.nextRow, s2 = 0, l2 = t4[s2], c2 = 0; c2 < this.width; c2++) {
            c2 / l2.right > 1 && (l2 = t4[++s2]);
            var u2 = Math.abs(c2 - l2.left), h2 = Math.abs(c2 - l2.right), p2 = Math.min(u2, h2);
            this.data[n2 + c2] = Math.max(0, Math.min(255, (l2.isDash ? p2 : -p2) + 128));
          }
        }, T2.prototype.addDash = function(e2, i3) {
          var o2 = i3 ? 7 : 0, r2 = 2 * o2 + 1;
          if (this.nextRow + r2 > this.height)
            return t.warnOnce("LineAtlas out of space"), null;
          for (var a2 = 0, n2 = 0; n2 < e2.length; n2++)
            a2 += e2[n2];
          if (0 !== a2) {
            var s2 = this.width / a2, l2 = this.getDashRanges(e2, this.width, s2);
            i3 ? this.addRoundDash(l2, s2, o2) : this.addRegularDash(l2);
          }
          var c2 = { y: (this.nextRow + o2 + 0.5) / this.height, height: 2 * o2 / this.height, width: a2 };
          return this.nextRow += r2, this.dirty = true, c2;
        }, T2.prototype.bind = function(t4) {
          var e2 = t4.gl;
          this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.ALPHA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.ALPHA, this.width, this.height, 0, e2.ALPHA, e2.UNSIGNED_BYTE, this.data));
        };
        var E2 = function e2(i3, o2) {
          this.workerPool = i3, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();
          for (var r2 = this.workerPool.acquire(this.id), a2 = 0; a2 < r2.length; a2++) {
            var n2 = new e2.Actor(r2[a2], o2, this.id);
            n2.name = "Worker " + a2, this.actors.push(n2);
          }
        };
        function I(e2, i3, o2) {
          var r2 = function(r3, a2) {
            if (r3)
              return o2(r3);
            if (a2) {
              var n2 = t.pick(t.extend(a2, e2), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
              a2.vector_layers && (n2.vectorLayers = a2.vector_layers, n2.vectorLayerIds = n2.vectorLayers.map(function(t4) {
                return t4.id;
              })), n2.tiles = i3.canonicalizeTileset(n2, e2.url), o2(null, n2);
            }
          };
          return e2.url ? t.getJSON(i3.transformRequest(i3.normalizeSourceURL(e2.url), t.ResourceType.Source), r2) : t.browser.frame(function() {
            return r2(null, e2);
          });
        }
        E2.prototype.broadcast = function(e2, i3, o2) {
          t.asyncAll(this.actors, function(t4, o3) {
            t4.send(e2, i3, o3);
          }, o2 = o2 || function() {
          });
        }, E2.prototype.getActor = function() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }, E2.prototype.remove = function() {
          this.actors.forEach(function(t4) {
            t4.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }, E2.Actor = t.Actor;
        var P = function(e2, i3, o2) {
          this.bounds = t.LngLatBounds.convert(this.validateBounds(e2)), this.minzoom = i3 || 0, this.maxzoom = o2 || 24;
        };
        P.prototype.validateBounds = function(t4) {
          return Array.isArray(t4) && 4 === t4.length ? [Math.max(-180, t4[0]), Math.max(-90, t4[1]), Math.min(180, t4[2]), Math.min(90, t4[3])] : [-180, -90, 180, 90];
        }, P.prototype.contains = function(e2) {
          var i3 = Math.pow(2, e2.z), o2 = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i3), r2 = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i3), a2 = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i3), n2 = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i3);
          return e2.x >= o2 && e2.x < a2 && e2.y >= r2 && e2.y < n2;
        };
        var S = function(e2) {
          function i3(i4, o2, r2, a2) {
            if (e2.call(this), this.id = i4, this.dispatcher = r2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.extend(this, t.pick(o2, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({ type: "vector" }, o2), this._collectResourceTiming = o2.collectResourceTiming, 512 !== this.tileSize)
              throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(a2);
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.load = function() {
            var e3 = this;
            this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = I(this._options, this.map._requestManager, function(i4, o2) {
              e3._tileJSONRequest = null, e3._loaded = true, i4 ? e3.fire(new t.ErrorEvent(i4)) : o2 && (t.extend(e3, o2), o2.bounds && (e3.tileBounds = new P(o2.bounds, e3.minzoom, e3.maxzoom)), t.postTurnstileEvent(o2.tiles, e3.map._requestManager._customAccessToken), t.postMapLoadEvent(o2.tiles, e3.map._getMapId(), e3.map._requestManager._skuToken, e3.map._requestManager._customAccessToken), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
            });
          }, i3.prototype.loaded = function() {
            return this._loaded;
          }, i3.prototype.hasTile = function(t4) {
            return !this.tileBounds || this.tileBounds.contains(t4.canonical);
          }, i3.prototype.onAdd = function(t4) {
            this.map = t4, this.load();
          }, i3.prototype.setSourceProperty = function(t4) {
            this._tileJSONRequest && this._tileJSONRequest.cancel(), t4(), this.map.style.sourceCaches[this.id].clearTiles(), this.load();
          }, i3.prototype.setTiles = function(t4) {
            var e3 = this;
            return this.setSourceProperty(function() {
              e3._options.tiles = t4;
            }), this;
          }, i3.prototype.setUrl = function(t4) {
            var e3 = this;
            return this.setSourceProperty(function() {
              e3.url = t4, e3._options.url = t4;
            }), this;
          }, i3.prototype.onRemove = function() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }, i3.prototype.serialize = function() {
            return t.extend({}, this._options);
          }, i3.prototype.loadTile = function(e3, i4) {
            var o2 = this.map._requestManager.normalizeTileURL(e3.tileID.canonical.url(this.tiles, this.scheme)), r2 = { request: this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), uid: e3.uid, tileID: e3.tileID, zoom: e3.tileID.overscaledZ, tileSize: this.tileSize * e3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: t.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            function a2(o3, r3) {
              return delete e3.request, e3.aborted ? i4(null) : o3 && 404 !== o3.status ? i4(o3) : (r3 && r3.resourceTiming && (e3.resourceTiming = r3.resourceTiming), this.map._refreshExpiredTiles && r3 && e3.setExpiryData(r3), e3.loadVectorData(r3, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i4(null), void (e3.reloadCallback && (this.loadTile(e3, e3.reloadCallback), e3.reloadCallback = null)));
            }
            r2.request.collectResourceTiming = this._collectResourceTiming, e3.actor && "expired" !== e3.state ? "loading" === e3.state ? e3.reloadCallback = i4 : e3.request = e3.actor.send("reloadTile", r2, a2.bind(this)) : (e3.actor = this.dispatcher.getActor(), e3.request = e3.actor.send("loadTile", r2, a2.bind(this)));
          }, i3.prototype.abortTile = function(t4) {
            t4.request && (t4.request.cancel(), delete t4.request), t4.actor && t4.actor.send("abortTile", { uid: t4.uid, type: this.type, source: this.id }, void 0);
          }, i3.prototype.unloadTile = function(t4) {
            t4.unloadVectorData(), t4.actor && t4.actor.send("removeTile", { uid: t4.uid, type: this.type, source: this.id }, void 0);
          }, i3.prototype.hasTransition = function() {
            return false;
          }, i3;
        }(t.Evented), C2 = function(e2) {
          function i3(i4, o2, r2, a2) {
            e2.call(this), this.id = i4, this.dispatcher = r2, this.setEventedParent(a2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.extend({ type: "raster" }, o2), t.extend(this, t.pick(o2, ["url", "scheme", "tileSize"]));
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.load = function() {
            var e3 = this;
            this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = I(this._options, this.map._requestManager, function(i4, o2) {
              e3._tileJSONRequest = null, e3._loaded = true, i4 ? e3.fire(new t.ErrorEvent(i4)) : o2 && (t.extend(e3, o2), o2.bounds && (e3.tileBounds = new P(o2.bounds, e3.minzoom, e3.maxzoom)), t.postTurnstileEvent(o2.tiles), t.postMapLoadEvent(o2.tiles, e3.map._getMapId(), e3.map._requestManager._skuToken), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
            });
          }, i3.prototype.loaded = function() {
            return this._loaded;
          }, i3.prototype.onAdd = function(t4) {
            this.map = t4, this.load();
          }, i3.prototype.onRemove = function() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }, i3.prototype.serialize = function() {
            return t.extend({}, this._options);
          }, i3.prototype.hasTile = function(t4) {
            return !this.tileBounds || this.tileBounds.contains(t4.canonical);
          }, i3.prototype.loadTile = function(e3, i4) {
            var o2 = this, r2 = this.map._requestManager.normalizeTileURL(e3.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
            e3.request = t.getImage(this.map._requestManager.transformRequest(r2, t.ResourceType.Tile), function(r3, a2) {
              if (delete e3.request, e3.aborted)
                e3.state = "unloaded", i4(null);
              else if (r3)
                e3.state = "errored", i4(r3);
              else if (a2) {
                o2.map._refreshExpiredTiles && e3.setExpiryData(a2), delete a2.cacheControl, delete a2.expires;
                var n2 = o2.map.painter.context, s2 = n2.gl;
                e3.texture = o2.map.painter.getTileTexture(a2.width), e3.texture ? e3.texture.update(a2, { useMipmap: true }) : (e3.texture = new t.Texture(n2, a2, s2.RGBA, { useMipmap: true }), e3.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), n2.extTextureFilterAnisotropic && s2.texParameterf(s2.TEXTURE_2D, n2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, n2.extTextureFilterAnisotropicMax)), e3.state = "loaded", t.cacheEntryPossiblyAdded(o2.dispatcher), i4(null);
              }
            });
          }, i3.prototype.abortTile = function(t4, e3) {
            t4.request && (t4.request.cancel(), delete t4.request), e3();
          }, i3.prototype.unloadTile = function(t4, e3) {
            t4.texture && this.map.painter.saveTileTexture(t4.texture), e3();
          }, i3.prototype.hasTransition = function() {
            return false;
          }, i3;
        }(t.Evented), z = function(e2) {
          function i3(i4, o2, r2, a2) {
            e2.call(this, i4, o2, r2, a2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({ type: "raster-dem" }, o2), this.encoding = o2.encoding || "mapbox";
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.serialize = function() {
            return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
          }, i3.prototype.loadTile = function(e3, i4) {
            var o2 = this.map._requestManager.normalizeTileURL(e3.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
            function r2(t4, o3) {
              t4 && (e3.state = "errored", i4(t4)), o3 && (e3.dem = o3, e3.needsHillshadePrepare = true, e3.state = "loaded", i4(null));
            }
            e3.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), (function(o3, a2) {
              if (delete e3.request, e3.aborted)
                e3.state = "unloaded", i4(null);
              else if (o3)
                e3.state = "errored", i4(o3);
              else if (a2) {
                this.map._refreshExpiredTiles && e3.setExpiryData(a2), delete a2.cacheControl, delete a2.expires;
                var n2 = t.window.ImageBitmap && a2 instanceof t.window.ImageBitmap && t.offscreenCanvasSupported() ? a2 : t.browser.getImageData(a2, 1), s2 = { uid: e3.uid, coord: e3.tileID, source: this.id, rawImageData: n2, encoding: this.encoding };
                e3.actor && "expired" !== e3.state || (e3.actor = this.dispatcher.getActor(), e3.actor.send("loadDEMTile", s2, r2.bind(this)));
              }
            }).bind(this)), e3.neighboringTiles = this._getNeighboringTiles(e3.tileID);
          }, i3.prototype._getNeighboringTiles = function(e3) {
            var i4 = e3.canonical, o2 = Math.pow(2, i4.z), r2 = (i4.x - 1 + o2) % o2, a2 = 0 === i4.x ? e3.wrap - 1 : e3.wrap, n2 = (i4.x + 1 + o2) % o2, s2 = i4.x + 1 === o2 ? e3.wrap + 1 : e3.wrap, l2 = {};
            return l2[new t.OverscaledTileID(e3.overscaledZ, a2, i4.z, r2, i4.y).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, s2, i4.z, n2, i4.y).key] = { backfilled: false }, i4.y > 0 && (l2[new t.OverscaledTileID(e3.overscaledZ, a2, i4.z, r2, i4.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, e3.wrap, i4.z, i4.x, i4.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, s2, i4.z, n2, i4.y - 1).key] = { backfilled: false }), i4.y + 1 < o2 && (l2[new t.OverscaledTileID(e3.overscaledZ, a2, i4.z, r2, i4.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, e3.wrap, i4.z, i4.x, i4.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, s2, i4.z, n2, i4.y + 1).key] = { backfilled: false }), l2;
          }, i3.prototype.unloadTile = function(t4) {
            t4.demTexture && this.map.painter.saveTileTexture(t4.demTexture), t4.fbo && (t4.fbo.destroy(), delete t4.fbo), t4.dem && delete t4.dem, delete t4.neighboringTiles, t4.state = "unloaded", t4.actor && t4.actor.send("removeDEMTile", { uid: t4.uid, source: this.id });
          }, i3;
        }(C2), D2 = function(e2) {
          function i3(i4, o2, r2, a2) {
            e2.call(this), this.id = i4, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._loaded = false, this.actor = r2.getActor(), this.setEventedParent(a2), this._data = o2.data, this._options = t.extend({}, o2), this._collectResourceTiming = o2.collectResourceTiming, this._resourceTiming = [], void 0 !== o2.maxzoom && (this.maxzoom = o2.maxzoom), o2.type && (this.type = o2.type), o2.attribution && (this.attribution = o2.attribution), this.promoteId = o2.promoteId;
            var n2 = t.EXTENT / this.tileSize;
            this.workerOptions = t.extend({ source: this.id, cluster: o2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== o2.buffer ? o2.buffer : 128) * n2, tolerance: (void 0 !== o2.tolerance ? o2.tolerance : 0.375) * n2, extent: t.EXTENT, maxZoom: this.maxzoom, lineMetrics: o2.lineMetrics || false, generateId: o2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== o2.clusterMaxZoom ? Math.min(o2.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, minPoints: Math.max(2, o2.clusterMinPoints || 2), extent: t.EXTENT, radius: (o2.clusterRadius || 50) * n2, log: false, generateId: o2.generateId || false }, clusterProperties: o2.clusterProperties, filter: o2.filter }, o2.workerOptions);
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.load = function() {
            var e3 = this;
            this.fire(new t.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(i4) {
              if (i4)
                e3.fire(new t.ErrorEvent(i4));
              else {
                var o2 = { dataType: "source", sourceDataType: "metadata" };
                e3._collectResourceTiming && e3._resourceTiming && e3._resourceTiming.length > 0 && (o2.resourceTiming = e3._resourceTiming, e3._resourceTiming = []), e3.fire(new t.Event("data", o2));
              }
            });
          }, i3.prototype.onAdd = function(t4) {
            this.map = t4, this.load();
          }, i3.prototype.setData = function(e3) {
            var i4 = this;
            return this._data = e3, this.fire(new t.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(e4) {
              if (e4)
                i4.fire(new t.ErrorEvent(e4));
              else {
                var o2 = { dataType: "source", sourceDataType: "content" };
                i4._collectResourceTiming && i4._resourceTiming && i4._resourceTiming.length > 0 && (o2.resourceTiming = i4._resourceTiming, i4._resourceTiming = []), i4.fire(new t.Event("data", o2));
              }
            }), this;
          }, i3.prototype.getClusterExpansionZoom = function(t4, e3) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t4, source: this.id }, e3), this;
          }, i3.prototype.getClusterChildren = function(t4, e3) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: t4, source: this.id }, e3), this;
          }, i3.prototype.getClusterLeaves = function(t4, e3, i4, o2) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t4, limit: e3, offset: i4 }, o2), this;
          }, i3.prototype._updateWorkerData = function(e3) {
            var i4 = this;
            this._loaded = false;
            var o2 = t.extend({}, this.workerOptions), r2 = this._data;
            "string" == typeof r2 ? (o2.request = this.map._requestManager.transformRequest(t.browser.resolveURL(r2), t.ResourceType.Source), o2.request.collectResourceTiming = this._collectResourceTiming) : o2.data = JSON.stringify(r2), this.actor.send(this.type + ".loadData", o2, function(t4, r3) {
              i4._removed || r3 && r3.abandoned || (i4._loaded = true, r3 && r3.resourceTiming && r3.resourceTiming[i4.id] && (i4._resourceTiming = r3.resourceTiming[i4.id].slice(0)), i4.actor.send(i4.type + ".coalesce", { source: o2.source }, null), e3(t4));
            });
          }, i3.prototype.loaded = function() {
            return this._loaded;
          }, i3.prototype.loadTile = function(e3, i4) {
            var o2 = this, r2 = e3.actor ? "reloadTile" : "loadTile";
            e3.actor = this.actor, e3.request = this.actor.send(r2, { type: this.type, uid: e3.uid, tileID: e3.tileID, zoom: e3.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: t.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, function(t4, a2) {
              return delete e3.request, e3.unloadVectorData(), e3.aborted ? i4(null) : t4 ? i4(t4) : (e3.loadVectorData(a2, o2.map.painter, "reloadTile" === r2), i4(null));
            });
          }, i3.prototype.abortTile = function(t4) {
            t4.request && (t4.request.cancel(), delete t4.request), t4.aborted = true;
          }, i3.prototype.unloadTile = function(t4) {
            t4.unloadVectorData(), this.actor.send("removeTile", { uid: t4.uid, type: this.type, source: this.id });
          }, i3.prototype.onRemove = function() {
            this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
          }, i3.prototype.serialize = function() {
            return t.extend({}, this._options, { type: this.type, data: this._data });
          }, i3.prototype.hasTransition = function() {
            return false;
          }, i3;
        }(t.Evented), A2 = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]), M = function(e2) {
          function i3(t4, i4, o2, r2) {
            e2.call(this), this.id = t4, this.dispatcher = o2, this.coordinates = i4.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(r2), this.options = i4;
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.load = function(e3, i4) {
            var o2 = this;
            this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), function(r2, a2) {
              o2._loaded = true, r2 ? o2.fire(new t.ErrorEvent(r2)) : a2 && (o2.image = a2, e3 && (o2.coordinates = e3), i4 && i4(), o2._finishLoading());
            });
          }, i3.prototype.loaded = function() {
            return this._loaded;
          }, i3.prototype.updateImage = function(t4) {
            var e3 = this;
            return this.image && t4.url ? (this.options.url = t4.url, this.load(t4.coordinates, function() {
              e3.texture = null;
            }), this) : this;
          }, i3.prototype._finishLoading = function() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })));
          }, i3.prototype.onAdd = function(t4) {
            this.map = t4, this.load();
          }, i3.prototype.setCoordinates = function(e3) {
            var i4 = this;
            this.coordinates = e3;
            var o2 = e3.map(t.MercatorCoordinate.fromLngLat);
            this.tileID = function(e4) {
              for (var i5 = 1 / 0, o3 = 1 / 0, r3 = -1 / 0, a2 = -1 / 0, n2 = 0, s2 = e4; n2 < s2.length; n2 += 1) {
                var l2 = s2[n2];
                i5 = Math.min(i5, l2.x), o3 = Math.min(o3, l2.y), r3 = Math.max(r3, l2.x), a2 = Math.max(a2, l2.y);
              }
              var c2 = Math.max(r3 - i5, a2 - o3), u2 = Math.max(0, Math.floor(-Math.log(c2) / Math.LN2)), h2 = Math.pow(2, u2);
              return new t.CanonicalTileID(u2, Math.floor((i5 + r3) / 2 * h2), Math.floor((o3 + a2) / 2 * h2));
            }(o2), this.minzoom = this.maxzoom = this.tileID.z;
            var r2 = o2.map(function(t4) {
              return i4.tileID.getTilePoint(t4)._round();
            });
            return this._boundsArray = new t.StructArrayLayout4i8(), this._boundsArray.emplaceBack(r2[0].x, r2[0].y, 0, 0), this._boundsArray.emplaceBack(r2[1].x, r2[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(r2[3].x, r2[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(r2[2].x, r2[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })), this;
          }, i3.prototype.prepare = function() {
            if (0 !== Object.keys(this.tiles).length && this.image) {
              var e3 = this.map.painter.context, i4 = e3.gl;
              for (var o2 in this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, A2.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new t.Texture(e3, this.image, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE)), this.tiles) {
                var r2 = this.tiles[o2];
                "loaded" !== r2.state && (r2.state = "loaded", r2.texture = this.texture);
              }
            }
          }, i3.prototype.loadTile = function(t4, e3) {
            this.tileID && this.tileID.equals(t4.tileID.canonical) ? (this.tiles[String(t4.tileID.wrap)] = t4, t4.buckets = {}, e3(null)) : (t4.state = "errored", e3(null));
          }, i3.prototype.serialize = function() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }, i3.prototype.hasTransition = function() {
            return false;
          }, i3;
        }(t.Evented), L2 = function(e2) {
          function i3(t4, i4, o2, r2) {
            e2.call(this, t4, i4, o2, r2), this.roundZoom = true, this.type = "video", this.options = i4;
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.load = function() {
            var e3 = this;
            this._loaded = false;
            var i4 = this.options;
            this.urls = [];
            for (var o2 = 0, r2 = i4.urls; o2 < r2.length; o2 += 1)
              this.urls.push(this.map._requestManager.transformRequest(r2[o2], t.ResourceType.Source).url);
            t.getVideo(this.urls, function(i5, o3) {
              e3._loaded = true, i5 ? e3.fire(new t.ErrorEvent(i5)) : o3 && (e3.video = o3, e3.video.loop = true, e3.video.setAttribute("playsinline", ""), e3.video.addEventListener("playing", function() {
                e3.map.triggerRepaint();
              }), e3.map && e3.video.play(), e3._finishLoading());
            });
          }, i3.prototype.pause = function() {
            this.video && this.video.pause();
          }, i3.prototype.play = function() {
            this.video && this.video.play();
          }, i3.prototype.seek = function(e3) {
            if (this.video) {
              var i4 = this.video.seekable;
              e3 < i4.start(0) || e3 > i4.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + i4.start(0) + " and " + i4.end(0) + "-second mark."))) : this.video.currentTime = e3;
            }
          }, i3.prototype.getVideo = function() {
            return this.video;
          }, i3.prototype.onAdd = function(t4) {
            this.map || (this.map = t4, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }, i3.prototype.prepare = function() {
            if (!(0 === Object.keys(this.tiles).length || this.video.readyState < 2)) {
              var e3 = this.map.painter.context, i4 = e3.gl;
              for (var o2 in this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, A2.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE), i4.texSubImage2D(i4.TEXTURE_2D, 0, 0, 0, i4.RGBA, i4.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e3, this.video, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE)), this.tiles) {
                var r2 = this.tiles[o2];
                "loaded" !== r2.state && (r2.state = "loaded", r2.texture = this.texture);
              }
            }
          }, i3.prototype.serialize = function() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }, i3.prototype.hasTransition = function() {
            return this.video && !this.video.paused;
          }, i3;
        }(M), R = function(e2) {
          function i3(i4, o2, r2, a2) {
            e2.call(this, i4, o2, r2, a2), o2.coordinates ? Array.isArray(o2.coordinates) && 4 === o2.coordinates.length && !o2.coordinates.some(function(t4) {
              return !Array.isArray(t4) || 2 !== t4.length || t4.some(function(t5) {
                return "number" != typeof t5;
              });
            }) || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i4, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i4, null, 'missing required property "coordinates"'))), o2.animate && "boolean" != typeof o2.animate && this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i4, null, 'optional "animate" property must be a boolean value'))), o2.canvas ? "string" == typeof o2.canvas || o2.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i4, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i4, null, 'missing required property "canvas"'))), this.options = o2, this.animate = void 0 === o2.animate || o2.animate;
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.load = function() {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          }, i3.prototype.getCanvas = function() {
            return this.canvas;
          }, i3.prototype.onAdd = function(t4) {
            this.map = t4, this.load(), this.canvas && this.animate && this.play();
          }, i3.prototype.onRemove = function() {
            this.pause();
          }, i3.prototype.prepare = function() {
            var e3 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e3 = true), !this._hasInvalidDimensions() && 0 !== Object.keys(this.tiles).length) {
              var i4 = this.map.painter.context, o2 = i4.gl;
              for (var r2 in this.boundsBuffer || (this.boundsBuffer = i4.createVertexBuffer(this._boundsArray, A2.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new t.Texture(i4, this.canvas, o2.RGBA, { premultiply: true }), this.tiles) {
                var a2 = this.tiles[r2];
                "loaded" !== a2.state && (a2.state = "loaded", a2.texture = this.texture);
              }
            }
          }, i3.prototype.serialize = function() {
            return { type: "canvas", coordinates: this.coordinates };
          }, i3.prototype.hasTransition = function() {
            return this._playing;
          }, i3.prototype._hasInvalidDimensions = function() {
            for (var t4 = 0, e3 = [this.canvas.width, this.canvas.height]; t4 < e3.length; t4 += 1) {
              var i4 = e3[t4];
              if (isNaN(i4) || i4 <= 0)
                return true;
            }
            return false;
          }, i3;
        }(M), k = { vector: S, raster: C2, "raster-dem": z, geojson: D2, video: L2, image: M, canvas: R };
        function B2(e2, i3) {
          var o2 = t.identity([]);
          return t.translate(o2, o2, [1, 1, 0]), t.scale(o2, o2, [0.5 * e2.width, 0.5 * e2.height, 1]), t.multiply(o2, o2, e2.calculatePosMatrix(i3.toUnwrapped()));
        }
        function O(t4, e2, i3, o2, r2, a2) {
          var n2 = function(t5, e3, i4) {
            if (t5)
              for (var o3 = 0, r3 = t5; o3 < r3.length; o3 += 1) {
                var a3 = e3[r3[o3]];
                if (a3 && a3.source === i4 && "fill-extrusion" === a3.type)
                  return true;
              }
            else
              for (var n3 in e3) {
                var s3 = e3[n3];
                if (s3.source === i4 && "fill-extrusion" === s3.type)
                  return true;
              }
            return false;
          }(r2 && r2.layers, e2, t4.id), s2 = a2.maxPitchScaleFactor(), l2 = t4.tilesIn(o2, s2, n2);
          l2.sort(F);
          for (var c2 = [], u2 = 0, h2 = l2; u2 < h2.length; u2 += 1) {
            var p2 = h2[u2];
            c2.push({ wrappedTileID: p2.tileID.wrapped().key, queryResults: p2.tile.queryRenderedFeatures(e2, i3, t4._state, p2.queryGeometry, p2.cameraQueryGeometry, p2.scale, r2, a2, s2, B2(t4.transform, p2.tileID)) });
          }
          var d2 = function(t5) {
            for (var e3 = {}, i4 = {}, o3 = 0, r3 = t5; o3 < r3.length; o3 += 1) {
              var a3 = r3[o3], n3 = a3.queryResults, s3 = a3.wrappedTileID, l3 = i4[s3] = i4[s3] || {};
              for (var c3 in n3)
                for (var u3 = n3[c3], h3 = l3[c3] = l3[c3] || {}, p3 = e3[c3] = e3[c3] || [], d3 = 0, _3 = u3; d3 < _3.length; d3 += 1) {
                  var f2 = _3[d3];
                  h3[f2.featureIndex] || (h3[f2.featureIndex] = true, p3.push(f2));
                }
            }
            return e3;
          }(c2);
          for (var _2 in d2)
            d2[_2].forEach(function(e3) {
              var i4 = e3.feature, o3 = t4.getFeatureState(i4.layer["source-layer"], i4.id);
              i4.source = i4.layer.source, i4.layer["source-layer"] && (i4.sourceLayer = i4.layer["source-layer"]), i4.state = o3;
            });
          return d2;
        }
        function F(t4, e2) {
          var i3 = t4.tileID, o2 = e2.tileID;
          return i3.overscaledZ - o2.overscaledZ || i3.canonical.y - o2.canonical.y || i3.wrap - o2.wrap || i3.canonical.x - o2.canonical.x;
        }
        var U = function(t4, e2) {
          this.max = t4, this.onRemove = e2, this.reset();
        };
        U.prototype.reset = function() {
          for (var t4 in this.data)
            for (var e2 = 0, i3 = this.data[t4]; e2 < i3.length; e2 += 1) {
              var o2 = i3[e2];
              o2.timeout && clearTimeout(o2.timeout), this.onRemove(o2.value);
            }
          return this.data = {}, this.order = [], this;
        }, U.prototype.add = function(t4, e2, i3) {
          var o2 = this, r2 = t4.wrapped().key;
          void 0 === this.data[r2] && (this.data[r2] = []);
          var a2 = { value: e2, timeout: void 0 };
          if (void 0 !== i3 && (a2.timeout = setTimeout(function() {
            o2.remove(t4, a2);
          }, i3)), this.data[r2].push(a2), this.order.push(r2), this.order.length > this.max) {
            var n2 = this._getAndRemoveByKey(this.order[0]);
            n2 && this.onRemove(n2);
          }
          return this;
        }, U.prototype.has = function(t4) {
          return t4.wrapped().key in this.data;
        }, U.prototype.getAndRemove = function(t4) {
          return this.has(t4) ? this._getAndRemoveByKey(t4.wrapped().key) : null;
        }, U.prototype._getAndRemoveByKey = function(t4) {
          var e2 = this.data[t4].shift();
          return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t4].length && delete this.data[t4], this.order.splice(this.order.indexOf(t4), 1), e2.value;
        }, U.prototype.getByKey = function(t4) {
          var e2 = this.data[t4];
          return e2 ? e2[0].value : null;
        }, U.prototype.get = function(t4) {
          return this.has(t4) ? this.data[t4.wrapped().key][0].value : null;
        }, U.prototype.remove = function(t4, e2) {
          if (!this.has(t4))
            return this;
          var i3 = t4.wrapped().key, o2 = void 0 === e2 ? 0 : this.data[i3].indexOf(e2), r2 = this.data[i3][o2];
          return this.data[i3].splice(o2, 1), r2.timeout && clearTimeout(r2.timeout), 0 === this.data[i3].length && delete this.data[i3], this.onRemove(r2.value), this.order.splice(this.order.indexOf(i3), 1), this;
        }, U.prototype.setMaxSize = function(t4) {
          for (this.max = t4; this.order.length > this.max; ) {
            var e2 = this._getAndRemoveByKey(this.order[0]);
            e2 && this.onRemove(e2);
          }
          return this;
        }, U.prototype.filter = function(t4) {
          var e2 = [];
          for (var i3 in this.data)
            for (var o2 = 0, r2 = this.data[i3]; o2 < r2.length; o2 += 1) {
              var a2 = r2[o2];
              t4(a2.value) || e2.push(a2);
            }
          for (var n2 = 0, s2 = e2; n2 < s2.length; n2 += 1) {
            var l2 = s2[n2];
            this.remove(l2.value.tileID, l2);
          }
        };
        var N = function(t4, e2, i3) {
          this.context = t4;
          var o2 = t4.gl;
          this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i3), this.context.unbindVAO(), t4.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
        };
        N.prototype.bind = function() {
          this.context.bindElementBuffer.set(this.buffer);
        }, N.prototype.updateData = function(t4) {
          var e2 = this.context.gl;
          this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t4.arrayBuffer);
        }, N.prototype.destroy = function() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        };
        var Z = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }, q = function(t4, e2, i3, o2) {
          this.length = e2.length, this.attributes = i3, this.itemSize = e2.bytesPerElement, this.dynamicDraw = o2, this.context = t4;
          var r2 = t4.gl;
          this.buffer = r2.createBuffer(), t4.bindVertexBuffer.set(this.buffer), r2.bufferData(r2.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
        };
        q.prototype.bind = function() {
          this.context.bindVertexBuffer.set(this.buffer);
        }, q.prototype.updateData = function(t4) {
          var e2 = this.context.gl;
          this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t4.arrayBuffer);
        }, q.prototype.enableAttributes = function(t4, e2) {
          for (var i3 = 0; i3 < this.attributes.length; i3++) {
            var o2 = e2.attributes[this.attributes[i3].name];
            void 0 !== o2 && t4.enableVertexAttribArray(o2);
          }
        }, q.prototype.setVertexAttribPointers = function(t4, e2, i3) {
          for (var o2 = 0; o2 < this.attributes.length; o2++) {
            var r2 = this.attributes[o2], a2 = e2.attributes[r2.name];
            void 0 !== a2 && t4.vertexAttribPointer(a2, r2.components, t4[Z[r2.type]], false, this.itemSize, r2.offset + this.itemSize * (i3 || 0));
          }
        }, q.prototype.destroy = function() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        };
        var j = function(t4) {
          this.gl = t4.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        };
        j.prototype.get = function() {
          return this.current;
        }, j.prototype.set = function(t4) {
        }, j.prototype.getDefault = function() {
          return this.default;
        }, j.prototype.setDefault = function() {
          this.set(this.default);
        };
        var V = function(e2) {
          function i3() {
            e2.apply(this, arguments);
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.getDefault = function() {
            return t.Color.transparent;
          }, i3.prototype.set = function(t4) {
            var e3 = this.current;
            (t4.r !== e3.r || t4.g !== e3.g || t4.b !== e3.b || t4.a !== e3.a || this.dirty) && (this.gl.clearColor(t4.r, t4.g, t4.b, t4.a), this.current = t4, this.dirty = false);
          }, i3;
        }(j), G = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return 1;
          }, e2.prototype.set = function(t5) {
            (t5 !== this.current || this.dirty) && (this.gl.clearDepth(t5), this.current = t5, this.dirty = false);
          }, e2;
        }(j), W = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return 0;
          }, e2.prototype.set = function(t5) {
            (t5 !== this.current || this.dirty) && (this.gl.clearStencil(t5), this.current = t5, this.dirty = false);
          }, e2;
        }(j), X = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return [true, true, true, true];
          }, e2.prototype.set = function(t5) {
            var e3 = this.current;
            (t5[0] !== e3[0] || t5[1] !== e3[1] || t5[2] !== e3[2] || t5[3] !== e3[3] || this.dirty) && (this.gl.colorMask(t5[0], t5[1], t5[2], t5[3]), this.current = t5, this.dirty = false);
          }, e2;
        }(j), H = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return true;
          }, e2.prototype.set = function(t5) {
            (t5 !== this.current || this.dirty) && (this.gl.depthMask(t5), this.current = t5, this.dirty = false);
          }, e2;
        }(j), K2 = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return 255;
          }, e2.prototype.set = function(t5) {
            (t5 !== this.current || this.dirty) && (this.gl.stencilMask(t5), this.current = t5, this.dirty = false);
          }, e2;
        }(j), Y = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }, e2.prototype.set = function(t5) {
            var e3 = this.current;
            (t5.func !== e3.func || t5.ref !== e3.ref || t5.mask !== e3.mask || this.dirty) && (this.gl.stencilFunc(t5.func, t5.ref, t5.mask), this.current = t5, this.dirty = false);
          }, e2;
        }(j), J = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            var t5 = this.gl;
            return [t5.KEEP, t5.KEEP, t5.KEEP];
          }, e2.prototype.set = function(t5) {
            var e3 = this.current;
            (t5[0] !== e3[0] || t5[1] !== e3[1] || t5[2] !== e3[2] || this.dirty) && (this.gl.stencilOp(t5[0], t5[1], t5[2]), this.current = t5, this.dirty = false);
          }, e2;
        }(j), Q = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return false;
          }, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              var e3 = this.gl;
              t5 ? e3.enable(e3.STENCIL_TEST) : e3.disable(e3.STENCIL_TEST), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(j), $ = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return [0, 1];
          }, e2.prototype.set = function(t5) {
            var e3 = this.current;
            (t5[0] !== e3[0] || t5[1] !== e3[1] || this.dirty) && (this.gl.depthRange(t5[0], t5[1]), this.current = t5, this.dirty = false);
          }, e2;
        }(j), tt = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return false;
          }, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              var e3 = this.gl;
              t5 ? e3.enable(e3.DEPTH_TEST) : e3.disable(e3.DEPTH_TEST), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(j), et2 = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return this.gl.LESS;
          }, e2.prototype.set = function(t5) {
            (t5 !== this.current || this.dirty) && (this.gl.depthFunc(t5), this.current = t5, this.dirty = false);
          }, e2;
        }(j), it = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return false;
          }, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              var e3 = this.gl;
              t5 ? e3.enable(e3.BLEND) : e3.disable(e3.BLEND), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(j), ot = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            var t5 = this.gl;
            return [t5.ONE, t5.ZERO];
          }, e2.prototype.set = function(t5) {
            var e3 = this.current;
            (t5[0] !== e3[0] || t5[1] !== e3[1] || this.dirty) && (this.gl.blendFunc(t5[0], t5[1]), this.current = t5, this.dirty = false);
          }, e2;
        }(j), rt = function(e2) {
          function i3() {
            e2.apply(this, arguments);
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.getDefault = function() {
            return t.Color.transparent;
          }, i3.prototype.set = function(t4) {
            var e3 = this.current;
            (t4.r !== e3.r || t4.g !== e3.g || t4.b !== e3.b || t4.a !== e3.a || this.dirty) && (this.gl.blendColor(t4.r, t4.g, t4.b, t4.a), this.current = t4, this.dirty = false);
          }, i3;
        }(j), at = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return this.gl.FUNC_ADD;
          }, e2.prototype.set = function(t5) {
            (t5 !== this.current || this.dirty) && (this.gl.blendEquation(t5), this.current = t5, this.dirty = false);
          }, e2;
        }(j), nt = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return false;
          }, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              var e3 = this.gl;
              t5 ? e3.enable(e3.CULL_FACE) : e3.disable(e3.CULL_FACE), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(j), st = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return this.gl.BACK;
          }, e2.prototype.set = function(t5) {
            (t5 !== this.current || this.dirty) && (this.gl.cullFace(t5), this.current = t5, this.dirty = false);
          }, e2;
        }(j), lt = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return this.gl.CCW;
          }, e2.prototype.set = function(t5) {
            (t5 !== this.current || this.dirty) && (this.gl.frontFace(t5), this.current = t5, this.dirty = false);
          }, e2;
        }(j), ct = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t5) {
            (t5 !== this.current || this.dirty) && (this.gl.useProgram(t5), this.current = t5, this.dirty = false);
          }, e2;
        }(j), ut = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return this.gl.TEXTURE0;
          }, e2.prototype.set = function(t5) {
            (t5 !== this.current || this.dirty) && (this.gl.activeTexture(t5), this.current = t5, this.dirty = false);
          }, e2;
        }(j), ht = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            var t5 = this.gl;
            return [0, 0, t5.drawingBufferWidth, t5.drawingBufferHeight];
          }, e2.prototype.set = function(t5) {
            var e3 = this.current;
            (t5[0] !== e3[0] || t5[1] !== e3[1] || t5[2] !== e3[2] || t5[3] !== e3[3] || this.dirty) && (this.gl.viewport(t5[0], t5[1], t5[2], t5[3]), this.current = t5, this.dirty = false);
          }, e2;
        }(j), pt = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.bindFramebuffer(e3.FRAMEBUFFER, t5), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(j), dt = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.bindRenderbuffer(e3.RENDERBUFFER, t5), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(j), _t = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.bindTexture(e3.TEXTURE_2D, t5), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(j), ft = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.bindBuffer(e3.ARRAY_BUFFER, t5), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(j), mt = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t5) {
            var e3 = this.gl;
            e3.bindBuffer(e3.ELEMENT_ARRAY_BUFFER, t5), this.current = t5, this.dirty = false;
          }, e2;
        }(j), gt = function(t4) {
          function e2(e3) {
            t4.call(this, e3), this.vao = e3.extVertexArrayObject;
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2.prototype.set = function(t5) {
            this.vao && (t5 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t5), this.current = t5, this.dirty = false);
          }, e2;
        }(j), vt = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return 4;
          }, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.pixelStorei(e3.UNPACK_ALIGNMENT, t5), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(j), yt = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return false;
          }, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.pixelStorei(e3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t5), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(j), xt = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return false;
          }, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              var e3 = this.gl;
              e3.pixelStorei(e3.UNPACK_FLIP_Y_WEBGL, t5), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(j), bt = function(t4) {
          function e2(e3, i3) {
            t4.call(this, e3), this.context = e3, this.parent = i3;
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.getDefault = function() {
            return null;
          }, e2;
        }(j), wt = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.setDirty = function() {
            this.dirty = true;
          }, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              this.context.bindFramebuffer.set(this.parent);
              var e3 = this.gl;
              e3.framebufferTexture2D(e3.FRAMEBUFFER, e3.COLOR_ATTACHMENT0, e3.TEXTURE_2D, t5, 0), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(bt), Tt = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.set = function(t5) {
            if (t5 !== this.current || this.dirty) {
              this.context.bindFramebuffer.set(this.parent);
              var e3 = this.gl;
              e3.framebufferRenderbuffer(e3.FRAMEBUFFER, e3.DEPTH_ATTACHMENT, e3.RENDERBUFFER, t5), this.current = t5, this.dirty = false;
            }
          }, e2;
        }(bt), Et = function(t4, e2, i3, o2) {
          this.context = t4, this.width = e2, this.height = i3;
          var r2 = this.framebuffer = t4.gl.createFramebuffer();
          this.colorAttachment = new wt(t4, r2), o2 && (this.depthAttachment = new Tt(t4, r2));
        };
        Et.prototype.destroy = function() {
          var t4 = this.context.gl, e2 = this.colorAttachment.get();
          if (e2 && t4.deleteTexture(e2), this.depthAttachment) {
            var i3 = this.depthAttachment.get();
            i3 && t4.deleteRenderbuffer(i3);
          }
          t4.deleteFramebuffer(this.framebuffer);
        };
        var It = function(t4, e2, i3) {
          this.func = t4, this.mask = e2, this.range = i3;
        };
        It.ReadOnly = false, It.ReadWrite = true, It.disabled = new It(519, It.ReadOnly, [0, 1]);
        var Pt = function(t4, e2, i3, o2, r2, a2) {
          this.test = t4, this.ref = e2, this.mask = i3, this.fail = o2, this.depthFail = r2, this.pass = a2;
        };
        Pt.disabled = new Pt({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
        var St = function(t4, e2, i3) {
          this.blendFunction = t4, this.blendColor = e2, this.mask = i3;
        };
        St.disabled = new St(St.Replace = [1, 0], t.Color.transparent, [false, false, false, false]), St.unblended = new St(St.Replace, t.Color.transparent, [true, true, true, true]), St.alphaBlended = new St([1, 771], t.Color.transparent, [true, true, true, true]);
        var Ct = function(t4, e2, i3) {
          this.enable = t4, this.mode = e2, this.frontFace = i3;
        };
        Ct.disabled = new Ct(false, 1029, 2305), Ct.backCCW = new Ct(true, 1029, 2305);
        var zt = function(t4) {
          this.gl = t4, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new V(this), this.clearDepth = new G(this), this.clearStencil = new W(this), this.colorMask = new X(this), this.depthMask = new H(this), this.stencilMask = new K2(this), this.stencilFunc = new Y(this), this.stencilOp = new J(this), this.stencilTest = new Q(this), this.depthRange = new $(this), this.depthTest = new tt(this), this.depthFunc = new et2(this), this.blend = new it(this), this.blendFunc = new ot(this), this.blendColor = new rt(this), this.blendEquation = new at(this), this.cullFace = new nt(this), this.cullFaceSide = new st(this), this.frontFace = new lt(this), this.program = new ct(this), this.activeTexture = new ut(this), this.viewport = new ht(this), this.bindFramebuffer = new pt(this), this.bindRenderbuffer = new dt(this), this.bindTexture = new _t(this), this.bindVertexBuffer = new ft(this), this.bindElementBuffer = new mt(this), this.bindVertexArrayOES = this.extVertexArrayObject && new gt(this), this.pixelStoreUnpack = new vt(this), this.pixelStoreUnpackPremultiplyAlpha = new yt(this), this.pixelStoreUnpackFlipY = new xt(this), this.extTextureFilterAnisotropic = t4.getExtension("EXT_texture_filter_anisotropic") || t4.getExtension("MOZ_EXT_texture_filter_anisotropic") || t4.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t4.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t4.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t4.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t4.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t4.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t4.getParameter(t4.MAX_TEXTURE_SIZE);
        };
        zt.prototype.setDefault = function() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }, zt.prototype.setDirty = function() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }, zt.prototype.createIndexBuffer = function(t4, e2) {
          return new N(this, t4, e2);
        }, zt.prototype.createVertexBuffer = function(t4, e2, i3) {
          return new q(this, t4, e2, i3);
        }, zt.prototype.createRenderbuffer = function(t4, e2, i3) {
          var o2 = this.gl, r2 = o2.createRenderbuffer();
          return this.bindRenderbuffer.set(r2), o2.renderbufferStorage(o2.RENDERBUFFER, t4, e2, i3), this.bindRenderbuffer.set(null), r2;
        }, zt.prototype.createFramebuffer = function(t4, e2, i3) {
          return new Et(this, t4, e2, i3);
        }, zt.prototype.clear = function(t4) {
          var e2 = t4.color, i3 = t4.depth, o2 = this.gl, r2 = 0;
          e2 && (r2 |= o2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), void 0 !== i3 && (r2 |= o2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i3), this.depthMask.set(true)), o2.clear(r2);
        }, zt.prototype.setCullFace = function(t4) {
          false === t4.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t4.mode), this.frontFace.set(t4.frontFace));
        }, zt.prototype.setDepthMode = function(t4) {
          t4.func !== this.gl.ALWAYS || t4.mask ? (this.depthTest.set(true), this.depthFunc.set(t4.func), this.depthMask.set(t4.mask), this.depthRange.set(t4.range)) : this.depthTest.set(false);
        }, zt.prototype.setStencilMode = function(t4) {
          t4.test.func !== this.gl.ALWAYS || t4.mask ? (this.stencilTest.set(true), this.stencilMask.set(t4.mask), this.stencilOp.set([t4.fail, t4.depthFail, t4.pass]), this.stencilFunc.set({ func: t4.test.func, ref: t4.ref, mask: t4.test.mask })) : this.stencilTest.set(false);
        }, zt.prototype.setColorMode = function(e2) {
          t.deepEqual(e2.blendFunction, St.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
        }, zt.prototype.unbindVAO = function() {
          this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
        };
        var Dt = function(e2) {
          function i3(i4, o2, r2) {
            var a2 = this;
            e2.call(this), this.id = i4, this.dispatcher = r2, this.on("data", function(t4) {
              "source" === t4.dataType && "metadata" === t4.sourceDataType && (a2._sourceLoaded = true), a2._sourceLoaded && !a2._paused && "source" === t4.dataType && "content" === t4.sourceDataType && (a2.reload(), a2.transform && a2.update(a2.transform));
            }), this.on("error", function() {
              a2._sourceErrored = true;
            }), this._source = function(e3, i5, o3, r3) {
              var a3 = new k[i5.type](e3, i5, o3, r3);
              if (a3.id !== e3)
                throw new Error("Expected Source id to be " + e3 + " instead of " + a3.id);
              return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], a3), a3;
            }(i4, o2, r2, this), this._tiles = {}, this._cache = new U(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new t.SourceFeatureState();
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.onAdd = function(t4) {
            this.map = t4, this._maxTileCacheSize = t4 ? t4._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t4);
          }, i3.prototype.onRemove = function(t4) {
            this._source && this._source.onRemove && this._source.onRemove(t4);
          }, i3.prototype.loaded = function() {
            if (this._sourceErrored)
              return true;
            if (!this._sourceLoaded)
              return false;
            if (!this._source.loaded())
              return false;
            for (var t4 in this._tiles) {
              var e3 = this._tiles[t4];
              if ("loaded" !== e3.state && "errored" !== e3.state)
                return false;
            }
            return true;
          }, i3.prototype.getSource = function() {
            return this._source;
          }, i3.prototype.pause = function() {
            this._paused = true;
          }, i3.prototype.resume = function() {
            if (this._paused) {
              var t4 = this._shouldReloadOnResume;
              this._paused = false, this._shouldReloadOnResume = false, t4 && this.reload(), this.transform && this.update(this.transform);
            }
          }, i3.prototype._loadTile = function(t4, e3) {
            return this._source.loadTile(t4, e3);
          }, i3.prototype._unloadTile = function(t4) {
            if (this._source.unloadTile)
              return this._source.unloadTile(t4, function() {
              });
          }, i3.prototype._abortTile = function(t4) {
            if (this._source.abortTile)
              return this._source.abortTile(t4, function() {
              });
          }, i3.prototype.serialize = function() {
            return this._source.serialize();
          }, i3.prototype.prepare = function(t4) {
            for (var e3 in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {
              var i4 = this._tiles[e3];
              i4.upload(t4), i4.prepare(this.map.style.imageManager);
            }
          }, i3.prototype.getIds = function() {
            return t.values(this._tiles).map(function(t4) {
              return t4.tileID;
            }).sort(At).map(function(t4) {
              return t4.key;
            });
          }, i3.prototype.getRenderableIds = function(e3) {
            var i4 = this, o2 = [];
            for (var r2 in this._tiles)
              this._isIdRenderable(r2, e3) && o2.push(this._tiles[r2]);
            return e3 ? o2.sort(function(e4, o3) {
              var r3 = e4.tileID, a2 = o3.tileID, n2 = new t.Point(r3.canonical.x, r3.canonical.y)._rotate(i4.transform.angle), s2 = new t.Point(a2.canonical.x, a2.canonical.y)._rotate(i4.transform.angle);
              return r3.overscaledZ - a2.overscaledZ || s2.y - n2.y || s2.x - n2.x;
            }).map(function(t4) {
              return t4.tileID.key;
            }) : o2.map(function(t4) {
              return t4.tileID;
            }).sort(At).map(function(t4) {
              return t4.key;
            });
          }, i3.prototype.hasRenderableParent = function(t4) {
            var e3 = this.findLoadedParent(t4, 0);
            return !!e3 && this._isIdRenderable(e3.tileID.key);
          }, i3.prototype._isIdRenderable = function(t4, e3) {
            return this._tiles[t4] && this._tiles[t4].hasData() && !this._coveredTiles[t4] && (e3 || !this._tiles[t4].holdingForFade());
          }, i3.prototype.reload = function() {
            if (this._paused)
              this._shouldReloadOnResume = true;
            else
              for (var t4 in this._cache.reset(), this._tiles)
                "errored" !== this._tiles[t4].state && this._reloadTile(t4, "reloading");
          }, i3.prototype._reloadTile = function(t4, e3) {
            var i4 = this._tiles[t4];
            i4 && ("loading" !== i4.state && (i4.state = e3), this._loadTile(i4, this._tileLoaded.bind(this, i4, t4, e3)));
          }, i3.prototype._tileLoaded = function(e3, i4, o2, r2) {
            if (r2)
              return e3.state = "errored", void (404 !== r2.status ? this._source.fire(new t.ErrorEvent(r2, { tile: e3 })) : this.update(this.transform));
            e3.timeAdded = t.browser.now(), "expired" === o2 && (e3.refreshedUponExpiration = true), this._setTileReloadTimer(i4, e3), "raster-dem" === this.getSource().type && e3.dem && this._backfillDEM(e3), this._state.initializeTileState(e3, this.map ? this.map.painter : null), this._source.fire(new t.Event("data", { dataType: "source", tile: e3, coord: e3.tileID }));
          }, i3.prototype._backfillDEM = function(t4) {
            for (var e3 = this.getRenderableIds(), i4 = 0; i4 < e3.length; i4++) {
              var o2 = e3[i4];
              if (t4.neighboringTiles && t4.neighboringTiles[o2]) {
                var r2 = this.getTileByID(o2);
                a2(t4, r2), a2(r2, t4);
              }
            }
            function a2(t5, e4) {
              t5.needsHillshadePrepare = true;
              var i5 = e4.tileID.canonical.x - t5.tileID.canonical.x, o3 = e4.tileID.canonical.y - t5.tileID.canonical.y, r3 = Math.pow(2, t5.tileID.canonical.z), a3 = e4.tileID.key;
              0 === i5 && 0 === o3 || Math.abs(o3) > 1 || (Math.abs(i5) > 1 && (1 === Math.abs(i5 + r3) ? i5 += r3 : 1 === Math.abs(i5 - r3) && (i5 -= r3)), e4.dem && t5.dem && (t5.dem.backfillBorder(e4.dem, i5, o3), t5.neighboringTiles && t5.neighboringTiles[a3] && (t5.neighboringTiles[a3].backfilled = true)));
            }
          }, i3.prototype.getTile = function(t4) {
            return this.getTileByID(t4.key);
          }, i3.prototype.getTileByID = function(t4) {
            return this._tiles[t4];
          }, i3.prototype._retainLoadedChildren = function(t4, e3, i4, o2) {
            for (var r2 in this._tiles) {
              var a2 = this._tiles[r2];
              if (!(o2[r2] || !a2.hasData() || a2.tileID.overscaledZ <= e3 || a2.tileID.overscaledZ > i4)) {
                for (var n2 = a2.tileID; a2 && a2.tileID.overscaledZ > e3 + 1; ) {
                  var s2 = a2.tileID.scaledTo(a2.tileID.overscaledZ - 1);
                  (a2 = this._tiles[s2.key]) && a2.hasData() && (n2 = s2);
                }
                for (var l2 = n2; l2.overscaledZ > e3; )
                  if (t4[(l2 = l2.scaledTo(l2.overscaledZ - 1)).key]) {
                    o2[n2.key] = n2;
                    break;
                  }
              }
            }
          }, i3.prototype.findLoadedParent = function(t4, e3) {
            if (t4.key in this._loadedParentTiles) {
              var i4 = this._loadedParentTiles[t4.key];
              return i4 && i4.tileID.overscaledZ >= e3 ? i4 : null;
            }
            for (var o2 = t4.overscaledZ - 1; o2 >= e3; o2--) {
              var r2 = t4.scaledTo(o2), a2 = this._getLoadedTile(r2);
              if (a2)
                return a2;
            }
          }, i3.prototype._getLoadedTile = function(t4) {
            var e3 = this._tiles[t4.key];
            return e3 && e3.hasData() ? e3 : this._cache.getByKey(t4.wrapped().key);
          }, i3.prototype.updateCacheSize = function(t4) {
            var e3 = Math.ceil(t4.width / this._source.tileSize) + 1, i4 = Math.ceil(t4.height / this._source.tileSize) + 1, o2 = Math.floor(e3 * i4 * 5), r2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o2) : o2;
            this._cache.setMaxSize(r2);
          }, i3.prototype.handleWrapJump = function(t4) {
            var e3 = Math.round((t4 - (void 0 === this._prevLng ? t4 : this._prevLng)) / 360);
            if (this._prevLng = t4, e3) {
              var i4 = {};
              for (var o2 in this._tiles) {
                var r2 = this._tiles[o2];
                r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + e3), i4[r2.tileID.key] = r2;
              }
              for (var a2 in this._tiles = i4, this._timers)
                clearTimeout(this._timers[a2]), delete this._timers[a2];
              for (var n2 in this._tiles)
                this._setTileReloadTimer(n2, this._tiles[n2]);
            }
          }, i3.prototype.update = function(e3) {
            var o2 = this;
            if (this.transform = e3, this._sourceLoaded && !this._paused) {
              var r2;
              this.updateCacheSize(e3), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? r2 = e3.getVisibleUnwrappedCoordinates(this._source.tileID).map(function(e4) {
                return new t.OverscaledTileID(e4.canonical.z, e4.wrap, e4.canonical.z, e4.canonical.x, e4.canonical.y);
              }) : (r2 = e3.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (r2 = r2.filter(function(t4) {
                return o2._source.hasTile(t4);
              }))) : r2 = [];
              var a2 = e3.coveringZoomLevel(this._source), n2 = Math.max(a2 - i3.maxOverzooming, this._source.minzoom), s2 = Math.max(a2 + i3.maxUnderzooming, this._source.minzoom), l2 = this._updateRetainedTiles(r2, a2);
              if (Mt(this._source.type)) {
                for (var c2 = {}, u2 = {}, h2 = 0, p2 = Object.keys(l2); h2 < p2.length; h2 += 1) {
                  var d2 = p2[h2], _2 = l2[d2], f2 = this._tiles[d2];
                  if (f2 && !(f2.fadeEndTime && f2.fadeEndTime <= t.browser.now())) {
                    var m2 = this.findLoadedParent(_2, n2);
                    m2 && (this._addTile(m2.tileID), c2[m2.tileID.key] = m2.tileID), u2[d2] = _2;
                  }
                }
                for (var g2 in this._retainLoadedChildren(u2, a2, s2, l2), c2)
                  l2[g2] || (this._coveredTiles[g2] = true, l2[g2] = c2[g2]);
              }
              for (var v2 in l2)
                this._tiles[v2].clearFadeHold();
              for (var y2 = 0, x3 = t.keysDifference(this._tiles, l2); y2 < x3.length; y2 += 1) {
                var b2 = x3[y2], w2 = this._tiles[b2];
                w2.hasSymbolBuckets && !w2.holdingForFade() ? w2.setHoldDuration(this.map._fadeDuration) : w2.hasSymbolBuckets && !w2.symbolFadeFinished() || this._removeTile(b2);
              }
              this._updateLoadedParentTileCache();
            }
          }, i3.prototype.releaseSymbolFadeTiles = function() {
            for (var t4 in this._tiles)
              this._tiles[t4].holdingForFade() && this._removeTile(t4);
          }, i3.prototype._updateRetainedTiles = function(t4, e3) {
            for (var o2 = {}, r2 = {}, a2 = Math.max(e3 - i3.maxOverzooming, this._source.minzoom), n2 = Math.max(e3 + i3.maxUnderzooming, this._source.minzoom), s2 = {}, l2 = 0, c2 = t4; l2 < c2.length; l2 += 1) {
              var u2 = c2[l2], h2 = this._addTile(u2);
              o2[u2.key] = u2, h2.hasData() || e3 < this._source.maxzoom && (s2[u2.key] = u2);
            }
            this._retainLoadedChildren(s2, e3, n2, o2);
            for (var p2 = 0, d2 = t4; p2 < d2.length; p2 += 1) {
              var _2 = d2[p2], f2 = this._tiles[_2.key];
              if (!f2.hasData()) {
                if (e3 + 1 > this._source.maxzoom) {
                  var m2 = _2.children(this._source.maxzoom)[0], g2 = this.getTile(m2);
                  if (g2 && g2.hasData()) {
                    o2[m2.key] = m2;
                    continue;
                  }
                } else {
                  var v2 = _2.children(this._source.maxzoom);
                  if (o2[v2[0].key] && o2[v2[1].key] && o2[v2[2].key] && o2[v2[3].key])
                    continue;
                }
                for (var y2 = f2.wasRequested(), x3 = _2.overscaledZ - 1; x3 >= a2; --x3) {
                  var b2 = _2.scaledTo(x3);
                  if (r2[b2.key])
                    break;
                  if (r2[b2.key] = true, !(f2 = this.getTile(b2)) && y2 && (f2 = this._addTile(b2)), f2 && (o2[b2.key] = b2, y2 = f2.wasRequested(), f2.hasData()))
                    break;
                }
              }
            }
            return o2;
          }, i3.prototype._updateLoadedParentTileCache = function() {
            for (var t4 in this._loadedParentTiles = {}, this._tiles) {
              for (var e3 = [], i4 = void 0, o2 = this._tiles[t4].tileID; o2.overscaledZ > 0; ) {
                if (o2.key in this._loadedParentTiles) {
                  i4 = this._loadedParentTiles[o2.key];
                  break;
                }
                e3.push(o2.key);
                var r2 = o2.scaledTo(o2.overscaledZ - 1);
                if (i4 = this._getLoadedTile(r2))
                  break;
                o2 = r2;
              }
              for (var a2 = 0, n2 = e3; a2 < n2.length; a2 += 1)
                this._loadedParentTiles[n2[a2]] = i4;
            }
          }, i3.prototype._addTile = function(e3) {
            var i4 = this._tiles[e3.key];
            if (i4)
              return i4;
            (i4 = this._cache.getAndRemove(e3)) && (this._setTileReloadTimer(e3.key, i4), i4.tileID = e3, this._state.initializeTileState(i4, this.map ? this.map.painter : null), this._cacheTimers[e3.key] && (clearTimeout(this._cacheTimers[e3.key]), delete this._cacheTimers[e3.key], this._setTileReloadTimer(e3.key, i4)));
            var o2 = Boolean(i4);
            return o2 || (i4 = new t.Tile(e3, this._source.tileSize * e3.overscaleFactor()), this._loadTile(i4, this._tileLoaded.bind(this, i4, e3.key, i4.state))), i4 ? (i4.uses++, this._tiles[e3.key] = i4, o2 || this._source.fire(new t.Event("dataloading", { tile: i4, coord: i4.tileID, dataType: "source" })), i4) : null;
          }, i3.prototype._setTileReloadTimer = function(t4, e3) {
            var i4 = this;
            t4 in this._timers && (clearTimeout(this._timers[t4]), delete this._timers[t4]);
            var o2 = e3.getExpiryTimeout();
            o2 && (this._timers[t4] = setTimeout(function() {
              i4._reloadTile(t4, "expired"), delete i4._timers[t4];
            }, o2));
          }, i3.prototype._removeTile = function(t4) {
            var e3 = this._tiles[t4];
            e3 && (e3.uses--, delete this._tiles[t4], this._timers[t4] && (clearTimeout(this._timers[t4]), delete this._timers[t4]), e3.uses > 0 || (e3.hasData() && "reloading" !== e3.state ? this._cache.add(e3.tileID, e3, e3.getExpiryTimeout()) : (e3.aborted = true, this._abortTile(e3), this._unloadTile(e3))));
          }, i3.prototype.clearTiles = function() {
            for (var t4 in this._shouldReloadOnResume = false, this._paused = false, this._tiles)
              this._removeTile(t4);
            this._cache.reset();
          }, i3.prototype.tilesIn = function(e3, i4, o2) {
            var r2 = this, a2 = [], n2 = this.transform;
            if (!n2)
              return a2;
            for (var s2 = o2 ? n2.getCameraQueryGeometry(e3) : e3, l2 = e3.map(function(t4) {
              return n2.pointCoordinate(t4);
            }), c2 = s2.map(function(t4) {
              return n2.pointCoordinate(t4);
            }), u2 = this.getIds(), h2 = 1 / 0, p2 = 1 / 0, d2 = -1 / 0, _2 = -1 / 0, f2 = 0, m2 = c2; f2 < m2.length; f2 += 1) {
              var g2 = m2[f2];
              h2 = Math.min(h2, g2.x), p2 = Math.min(p2, g2.y), d2 = Math.max(d2, g2.x), _2 = Math.max(_2, g2.y);
            }
            for (var v2 = function(e4) {
              var o3 = r2._tiles[u2[e4]];
              if (!o3.holdingForFade()) {
                var s3 = o3.tileID, f3 = Math.pow(2, n2.zoom - o3.tileID.overscaledZ), m3 = i4 * o3.queryPadding * t.EXTENT / o3.tileSize / f3, g3 = [s3.getTilePoint(new t.MercatorCoordinate(h2, p2)), s3.getTilePoint(new t.MercatorCoordinate(d2, _2))];
                if (g3[0].x - m3 < t.EXTENT && g3[0].y - m3 < t.EXTENT && g3[1].x + m3 >= 0 && g3[1].y + m3 >= 0) {
                  var v3 = l2.map(function(t4) {
                    return s3.getTilePoint(t4);
                  }), y3 = c2.map(function(t4) {
                    return s3.getTilePoint(t4);
                  });
                  a2.push({ tile: o3, tileID: s3, queryGeometry: v3, cameraQueryGeometry: y3, scale: f3 });
                }
              }
            }, y2 = 0; y2 < u2.length; y2++)
              v2(y2);
            return a2;
          }, i3.prototype.getVisibleCoordinates = function(t4) {
            for (var e3 = this, i4 = this.getRenderableIds(t4).map(function(t5) {
              return e3._tiles[t5].tileID;
            }), o2 = 0, r2 = i4; o2 < r2.length; o2 += 1) {
              var a2 = r2[o2];
              a2.posMatrix = this.transform.calculatePosMatrix(a2.toUnwrapped());
            }
            return i4;
          }, i3.prototype.hasTransition = function() {
            if (this._source.hasTransition())
              return true;
            if (Mt(this._source.type))
              for (var e3 in this._tiles) {
                var i4 = this._tiles[e3];
                if (void 0 !== i4.fadeEndTime && i4.fadeEndTime >= t.browser.now())
                  return true;
              }
            return false;
          }, i3.prototype.setFeatureState = function(t4, e3, i4) {
            this._state.updateState(t4 = t4 || "_geojsonTileLayer", e3, i4);
          }, i3.prototype.removeFeatureState = function(t4, e3, i4) {
            this._state.removeFeatureState(t4 = t4 || "_geojsonTileLayer", e3, i4);
          }, i3.prototype.getFeatureState = function(t4, e3) {
            return this._state.getState(t4 = t4 || "_geojsonTileLayer", e3);
          }, i3.prototype.setDependencies = function(t4, e3, i4) {
            var o2 = this._tiles[t4];
            o2 && o2.setDependencies(e3, i4);
          }, i3.prototype.reloadTilesForDependencies = function(t4, e3) {
            for (var i4 in this._tiles)
              this._tiles[i4].hasDependency(t4, e3) && this._reloadTile(i4, "reloading");
            this._cache.filter(function(i5) {
              return !i5.hasDependency(t4, e3);
            });
          }, i3;
        }(t.Evented);
        function At(t4, e2) {
          var i3 = Math.abs(2 * t4.wrap) - +(t4.wrap < 0), o2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
          return t4.overscaledZ - e2.overscaledZ || o2 - i3 || e2.canonical.y - t4.canonical.y || e2.canonical.x - t4.canonical.x;
        }
        function Mt(t4) {
          return "raster" === t4 || "image" === t4 || "video" === t4;
        }
        function Lt() {
          return new t.window.Worker(Kr.workerUrl);
        }
        Dt.maxOverzooming = 10, Dt.maxUnderzooming = 3;
        var Rt = "mapboxgl_preloaded_worker_pool", kt = function() {
          this.active = {};
        };
        kt.prototype.acquire = function(t4) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < kt.workerCount; )
              this.workers.push(new Lt());
          return this.active[t4] = true, this.workers.slice();
        }, kt.prototype.release = function(t4) {
          delete this.active[t4], 0 === this.numActive() && (this.workers.forEach(function(t5) {
            t5.terminate();
          }), this.workers = null);
        }, kt.prototype.isPreloaded = function() {
          return !!this.active[Rt];
        }, kt.prototype.numActive = function() {
          return Object.keys(this.active).length;
        };
        var Bt, Ot = Math.floor(t.browser.hardwareConcurrency / 2);
        function Ft() {
          return Bt || (Bt = new kt()), Bt;
        }
        function Ut(e2, i3) {
          var o2 = {};
          for (var r2 in e2)
            "ref" !== r2 && (o2[r2] = e2[r2]);
          return t.refProperties.forEach(function(t4) {
            t4 in i3 && (o2[t4] = i3[t4]);
          }), o2;
        }
        function Nt(t4) {
          t4 = t4.slice();
          for (var e2 = /* @__PURE__ */ Object.create(null), i3 = 0; i3 < t4.length; i3++)
            e2[t4[i3].id] = t4[i3];
          for (var o2 = 0; o2 < t4.length; o2++)
            "ref" in t4[o2] && (t4[o2] = Ut(t4[o2], e2[t4[o2].ref]));
          return t4;
        }
        kt.workerCount = Math.max(Math.min(Ot, 6), 1);
        var Zt = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
        function qt(t4, e2, i3) {
          i3.push({ command: Zt.addSource, args: [t4, e2[t4]] });
        }
        function jt(t4, e2, i3) {
          e2.push({ command: Zt.removeSource, args: [t4] }), i3[t4] = true;
        }
        function Vt(t4, e2, i3, o2) {
          jt(t4, i3, o2), qt(t4, e2, i3);
        }
        function Gt(e2, i3, o2) {
          var r2;
          for (r2 in e2[o2])
            if (e2[o2].hasOwnProperty(r2) && "data" !== r2 && !t.deepEqual(e2[o2][r2], i3[o2][r2]))
              return false;
          for (r2 in i3[o2])
            if (i3[o2].hasOwnProperty(r2) && "data" !== r2 && !t.deepEqual(e2[o2][r2], i3[o2][r2]))
              return false;
          return true;
        }
        function Wt(e2, i3, o2, r2, a2, n2) {
          var s2;
          for (s2 in i3 = i3 || {}, e2 = e2 || {})
            e2.hasOwnProperty(s2) && (t.deepEqual(e2[s2], i3[s2]) || o2.push({ command: n2, args: [r2, s2, i3[s2], a2] }));
          for (s2 in i3)
            i3.hasOwnProperty(s2) && !e2.hasOwnProperty(s2) && (t.deepEqual(e2[s2], i3[s2]) || o2.push({ command: n2, args: [r2, s2, i3[s2], a2] }));
        }
        function Xt(t4) {
          return t4.id;
        }
        function Ht(t4, e2) {
          return t4[e2.id] = e2, t4;
        }
        var Kt = function(t4, e2) {
          this.reset(t4, e2);
        };
        Kt.prototype.reset = function(t4, e2) {
          this.points = t4 || [], this._distances = [0];
          for (var i3 = 1; i3 < this.points.length; i3++)
            this._distances[i3] = this._distances[i3 - 1] + this.points[i3].dist(this.points[i3 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }, Kt.prototype.lerp = function(e2) {
          if (1 === this.points.length)
            return this.points[0];
          e2 = t.clamp(e2, 0, 1);
          for (var i3 = 1, o2 = this._distances[i3], r2 = e2 * this.paddedLength + this.padding; o2 < r2 && i3 < this._distances.length; )
            o2 = this._distances[++i3];
          var a2 = i3 - 1, n2 = this._distances[a2], s2 = o2 - n2, l2 = s2 > 0 ? (r2 - n2) / s2 : 0;
          return this.points[a2].mult(1 - l2).add(this.points[i3].mult(l2));
        };
        var Yt = function(t4, e2, i3) {
          var o2 = this.boxCells = [], r2 = this.circleCells = [];
          this.xCellCount = Math.ceil(t4 / i3), this.yCellCount = Math.ceil(e2 / i3);
          for (var a2 = 0; a2 < this.xCellCount * this.yCellCount; a2++)
            o2.push([]), r2.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t4, this.height = e2, this.xScale = this.xCellCount / t4, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
        };
        function Jt(e2, i3, o2, r2, a2) {
          var n2 = t.create();
          return i3 ? (t.scale(n2, n2, [1 / a2, 1 / a2, 1]), o2 || t.rotateZ(n2, n2, r2.angle)) : t.multiply(n2, r2.labelPlaneMatrix, e2), n2;
        }
        function Qt(e2, i3, o2, r2, a2) {
          if (i3) {
            var n2 = t.clone(e2);
            return t.scale(n2, n2, [a2, a2, 1]), o2 || t.rotateZ(n2, n2, -r2.angle), n2;
          }
          return r2.glCoordMatrix;
        }
        function $t(e2, i3) {
          var o2 = [e2.x, e2.y, 0, 1];
          ue(o2, o2, i3);
          var r2 = o2[3];
          return { point: new t.Point(o2[0] / r2, o2[1] / r2), signedDistanceFromCamera: r2 };
        }
        function te(t4, e2) {
          return 0.5 + t4 / e2 * 0.5;
        }
        function ee(t4, e2) {
          var i3 = t4[0] / t4[3], o2 = t4[1] / t4[3];
          return i3 >= -e2[0] && i3 <= e2[0] && o2 >= -e2[1] && o2 <= e2[1];
        }
        function ie(e2, i3, o2, r2, a2, n2, s2, l2) {
          var c2 = r2 ? e2.textSizeData : e2.iconSizeData, u2 = t.evaluateSizeForZoom(c2, o2.transform.zoom), h2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], p2 = r2 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
          p2.clear();
          for (var d2 = e2.lineVertexArray, _2 = r2 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, f2 = o2.transform.width / o2.transform.height, m2 = false, g2 = 0; g2 < _2.length; g2++) {
            var v2 = _2.get(g2);
            if (v2.hidden || v2.writingMode === t.WritingMode.vertical && !m2)
              ce(v2.numGlyphs, p2);
            else {
              m2 = false;
              var y2 = [v2.anchorX, v2.anchorY, 0, 1];
              if (t.transformMat4(y2, y2, i3), ee(y2, h2)) {
                var x3 = te(o2.transform.cameraToCenterDistance, y2[3]), b2 = t.evaluateSizeForFeature(c2, u2, v2), w2 = s2 ? b2 / x3 : b2 * x3, T3 = new t.Point(v2.anchorX, v2.anchorY), E3 = $t(T3, a2).point, I2 = {}, P2 = ae(v2, w2, false, l2, i3, a2, n2, e2.glyphOffsetArray, d2, p2, E3, T3, I2, f2);
                m2 = P2.useVertical, (P2.notEnoughRoom || m2 || P2.needsFlipping && ae(v2, w2, true, l2, i3, a2, n2, e2.glyphOffsetArray, d2, p2, E3, T3, I2, f2).notEnoughRoom) && ce(v2.numGlyphs, p2);
              } else
                ce(v2.numGlyphs, p2);
            }
          }
          r2 ? e2.text.dynamicLayoutVertexBuffer.updateData(p2) : e2.icon.dynamicLayoutVertexBuffer.updateData(p2);
        }
        function oe(t4, e2, i3, o2, r2, a2, n2, s2, l2, c2, u2) {
          var h2 = s2.glyphStartIndex + s2.numGlyphs, p2 = s2.lineStartIndex, d2 = s2.lineStartIndex + s2.lineLength, _2 = e2.getoffsetX(s2.glyphStartIndex), f2 = e2.getoffsetX(h2 - 1), m2 = se(t4 * _2, i3, o2, r2, a2, n2, s2.segment, p2, d2, l2, c2, u2);
          if (!m2)
            return null;
          var g2 = se(t4 * f2, i3, o2, r2, a2, n2, s2.segment, p2, d2, l2, c2, u2);
          return g2 ? { first: m2, last: g2 } : null;
        }
        function re(e2, i3, o2, r2) {
          return e2 === t.WritingMode.horizontal && Math.abs(o2.y - i3.y) > Math.abs(o2.x - i3.x) * r2 ? { useVertical: true } : (e2 === t.WritingMode.vertical ? i3.y < o2.y : i3.x > o2.x) ? { needsFlipping: true } : null;
        }
        function ae(e2, i3, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2, _2) {
          var f2, m2 = i3 / 24, g2 = e2.lineOffsetX * m2, v2 = e2.lineOffsetY * m2;
          if (e2.numGlyphs > 1) {
            var y2 = e2.glyphStartIndex + e2.numGlyphs, x3 = e2.lineStartIndex, b2 = e2.lineStartIndex + e2.lineLength, w2 = oe(m2, l2, g2, v2, o2, h2, p2, e2, c2, n2, d2);
            if (!w2)
              return { notEnoughRoom: true };
            var T3 = $t(w2.first.point, s2).point, E3 = $t(w2.last.point, s2).point;
            if (r2 && !o2) {
              var I2 = re(e2.writingMode, T3, E3, _2);
              if (I2)
                return I2;
            }
            f2 = [w2.first];
            for (var P2 = e2.glyphStartIndex + 1; P2 < y2 - 1; P2++)
              f2.push(se(m2 * l2.getoffsetX(P2), g2, v2, o2, h2, p2, e2.segment, x3, b2, c2, n2, d2));
            f2.push(w2.last);
          } else {
            if (r2 && !o2) {
              var S2 = $t(p2, a2).point, C3 = e2.lineStartIndex + e2.segment + 1, z2 = new t.Point(c2.getx(C3), c2.gety(C3)), D3 = $t(z2, a2), A3 = D3.signedDistanceFromCamera > 0 ? D3.point : ne(p2, z2, S2, 1, a2), M2 = re(e2.writingMode, S2, A3, _2);
              if (M2)
                return M2;
            }
            var L3 = se(m2 * l2.getoffsetX(e2.glyphStartIndex), g2, v2, o2, h2, p2, e2.segment, e2.lineStartIndex, e2.lineStartIndex + e2.lineLength, c2, n2, d2);
            if (!L3)
              return { notEnoughRoom: true };
            f2 = [L3];
          }
          for (var R2 = 0, k2 = f2; R2 < k2.length; R2 += 1) {
            var B3 = k2[R2];
            t.addDynamicAttributes(u2, B3.point, B3.angle);
          }
          return {};
        }
        function ne(t4, e2, i3, o2, r2) {
          var a2 = $t(t4.add(t4.sub(e2)._unit()), r2).point, n2 = i3.sub(a2);
          return i3.add(n2._mult(o2 / n2.mag()));
        }
        function se(e2, i3, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2) {
          var d2 = r2 ? e2 - i3 : e2 + i3, _2 = d2 > 0 ? 1 : -1, f2 = 0;
          r2 && (_2 *= -1, f2 = Math.PI), _2 < 0 && (f2 += Math.PI);
          for (var m2 = _2 > 0 ? l2 + s2 : l2 + s2 + 1, g2 = a2, v2 = a2, y2 = 0, x3 = 0, b2 = Math.abs(d2), w2 = []; y2 + x3 <= b2; ) {
            if ((m2 += _2) < l2 || m2 >= c2)
              return null;
            if (v2 = g2, w2.push(g2), void 0 === (g2 = p2[m2])) {
              var T3 = new t.Point(u2.getx(m2), u2.gety(m2)), E3 = $t(T3, h2);
              if (E3.signedDistanceFromCamera > 0)
                g2 = p2[m2] = E3.point;
              else {
                var I2 = m2 - _2;
                g2 = ne(0 === y2 ? n2 : new t.Point(u2.getx(I2), u2.gety(I2)), T3, v2, b2 - y2 + 1, h2);
              }
            }
            y2 += x3, x3 = v2.dist(g2);
          }
          var P2 = (b2 - y2) / x3, S2 = g2.sub(v2), C3 = S2.mult(P2)._add(v2);
          C3._add(S2._unit()._perp()._mult(o2 * _2));
          var z2 = f2 + Math.atan2(g2.y - v2.y, g2.x - v2.x);
          return w2.push(C3), { point: C3, angle: z2, path: w2 };
        }
        Yt.prototype.keysLength = function() {
          return this.boxKeys.length + this.circleKeys.length;
        }, Yt.prototype.insert = function(t4, e2, i3, o2, r2) {
          this._forEachCell(e2, i3, o2, r2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t4), this.bboxes.push(e2), this.bboxes.push(i3), this.bboxes.push(o2), this.bboxes.push(r2);
        }, Yt.prototype.insertCircle = function(t4, e2, i3, o2) {
          this._forEachCell(e2 - o2, i3 - o2, e2 + o2, i3 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t4), this.circles.push(e2), this.circles.push(i3), this.circles.push(o2);
        }, Yt.prototype._insertBoxCell = function(t4, e2, i3, o2, r2, a2) {
          this.boxCells[r2].push(a2);
        }, Yt.prototype._insertCircleCell = function(t4, e2, i3, o2, r2, a2) {
          this.circleCells[r2].push(a2);
        }, Yt.prototype._query = function(t4, e2, i3, o2, r2, a2) {
          if (i3 < 0 || t4 > this.width || o2 < 0 || e2 > this.height)
            return !r2 && [];
          var n2 = [];
          if (t4 <= 0 && e2 <= 0 && this.width <= i3 && this.height <= o2) {
            if (r2)
              return true;
            for (var s2 = 0; s2 < this.boxKeys.length; s2++)
              n2.push({ key: this.boxKeys[s2], x1: this.bboxes[4 * s2], y1: this.bboxes[4 * s2 + 1], x2: this.bboxes[4 * s2 + 2], y2: this.bboxes[4 * s2 + 3] });
            for (var l2 = 0; l2 < this.circleKeys.length; l2++) {
              var c2 = this.circles[3 * l2], u2 = this.circles[3 * l2 + 1], h2 = this.circles[3 * l2 + 2];
              n2.push({ key: this.circleKeys[l2], x1: c2 - h2, y1: u2 - h2, x2: c2 + h2, y2: u2 + h2 });
            }
            return a2 ? n2.filter(a2) : n2;
          }
          return this._forEachCell(t4, e2, i3, o2, this._queryCell, n2, { hitTest: r2, seenUids: { box: {}, circle: {} } }, a2), r2 ? n2.length > 0 : n2;
        }, Yt.prototype._queryCircle = function(t4, e2, i3, o2, r2) {
          var a2 = t4 - i3, n2 = t4 + i3, s2 = e2 - i3, l2 = e2 + i3;
          if (n2 < 0 || a2 > this.width || l2 < 0 || s2 > this.height)
            return !o2 && [];
          var c2 = [];
          return this._forEachCell(a2, s2, n2, l2, this._queryCellCircle, c2, { hitTest: o2, circle: { x: t4, y: e2, radius: i3 }, seenUids: { box: {}, circle: {} } }, r2), o2 ? c2.length > 0 : c2;
        }, Yt.prototype.query = function(t4, e2, i3, o2, r2) {
          return this._query(t4, e2, i3, o2, false, r2);
        }, Yt.prototype.hitTest = function(t4, e2, i3, o2, r2) {
          return this._query(t4, e2, i3, o2, true, r2);
        }, Yt.prototype.hitTestCircle = function(t4, e2, i3, o2) {
          return this._queryCircle(t4, e2, i3, true, o2);
        }, Yt.prototype._queryCell = function(t4, e2, i3, o2, r2, a2, n2, s2) {
          var l2 = n2.seenUids, c2 = this.boxCells[r2];
          if (null !== c2)
            for (var u2 = this.bboxes, h2 = 0, p2 = c2; h2 < p2.length; h2 += 1) {
              var d2 = p2[h2];
              if (!l2.box[d2]) {
                l2.box[d2] = true;
                var _2 = 4 * d2;
                if (t4 <= u2[_2 + 2] && e2 <= u2[_2 + 3] && i3 >= u2[_2 + 0] && o2 >= u2[_2 + 1] && (!s2 || s2(this.boxKeys[d2]))) {
                  if (n2.hitTest)
                    return a2.push(true), true;
                  a2.push({ key: this.boxKeys[d2], x1: u2[_2], y1: u2[_2 + 1], x2: u2[_2 + 2], y2: u2[_2 + 3] });
                }
              }
            }
          var f2 = this.circleCells[r2];
          if (null !== f2)
            for (var m2 = this.circles, g2 = 0, v2 = f2; g2 < v2.length; g2 += 1) {
              var y2 = v2[g2];
              if (!l2.circle[y2]) {
                l2.circle[y2] = true;
                var x3 = 3 * y2;
                if (this._circleAndRectCollide(m2[x3], m2[x3 + 1], m2[x3 + 2], t4, e2, i3, o2) && (!s2 || s2(this.circleKeys[y2]))) {
                  if (n2.hitTest)
                    return a2.push(true), true;
                  var b2 = m2[x3], w2 = m2[x3 + 1], T3 = m2[x3 + 2];
                  a2.push({ key: this.circleKeys[y2], x1: b2 - T3, y1: w2 - T3, x2: b2 + T3, y2: w2 + T3 });
                }
              }
            }
        }, Yt.prototype._queryCellCircle = function(t4, e2, i3, o2, r2, a2, n2, s2) {
          var l2 = n2.circle, c2 = n2.seenUids, u2 = this.boxCells[r2];
          if (null !== u2)
            for (var h2 = this.bboxes, p2 = 0, d2 = u2; p2 < d2.length; p2 += 1) {
              var _2 = d2[p2];
              if (!c2.box[_2]) {
                c2.box[_2] = true;
                var f2 = 4 * _2;
                if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, h2[f2 + 0], h2[f2 + 1], h2[f2 + 2], h2[f2 + 3]) && (!s2 || s2(this.boxKeys[_2])))
                  return a2.push(true), true;
              }
            }
          var m2 = this.circleCells[r2];
          if (null !== m2)
            for (var g2 = this.circles, v2 = 0, y2 = m2; v2 < y2.length; v2 += 1) {
              var x3 = y2[v2];
              if (!c2.circle[x3]) {
                c2.circle[x3] = true;
                var b2 = 3 * x3;
                if (this._circlesCollide(g2[b2], g2[b2 + 1], g2[b2 + 2], l2.x, l2.y, l2.radius) && (!s2 || s2(this.circleKeys[x3])))
                  return a2.push(true), true;
              }
            }
        }, Yt.prototype._forEachCell = function(t4, e2, i3, o2, r2, a2, n2, s2) {
          for (var l2 = this._convertToXCellCoord(t4), c2 = this._convertToYCellCoord(e2), u2 = this._convertToXCellCoord(i3), h2 = this._convertToYCellCoord(o2), p2 = l2; p2 <= u2; p2++)
            for (var d2 = c2; d2 <= h2; d2++)
              if (r2.call(this, t4, e2, i3, o2, this.xCellCount * d2 + p2, a2, n2, s2))
                return;
        }, Yt.prototype._convertToXCellCoord = function(t4) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t4 * this.xScale)));
        }, Yt.prototype._convertToYCellCoord = function(t4) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t4 * this.yScale)));
        }, Yt.prototype._circlesCollide = function(t4, e2, i3, o2, r2, a2) {
          var n2 = o2 - t4, s2 = r2 - e2, l2 = i3 + a2;
          return l2 * l2 > n2 * n2 + s2 * s2;
        }, Yt.prototype._circleAndRectCollide = function(t4, e2, i3, o2, r2, a2, n2) {
          var s2 = (a2 - o2) / 2, l2 = Math.abs(t4 - (o2 + s2));
          if (l2 > s2 + i3)
            return false;
          var c2 = (n2 - r2) / 2, u2 = Math.abs(e2 - (r2 + c2));
          if (u2 > c2 + i3)
            return false;
          if (l2 <= s2 || u2 <= c2)
            return true;
          var h2 = l2 - s2, p2 = u2 - c2;
          return h2 * h2 + p2 * p2 <= i3 * i3;
        };
        var le = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function ce(t4, e2) {
          for (var i3 = 0; i3 < t4; i3++) {
            var o2 = e2.length;
            e2.resize(o2 + 4), e2.float32.set(le, 3 * o2);
          }
        }
        function ue(t4, e2, i3) {
          var o2 = e2[0], r2 = e2[1];
          return t4[0] = i3[0] * o2 + i3[4] * r2 + i3[12], t4[1] = i3[1] * o2 + i3[5] * r2 + i3[13], t4[3] = i3[3] * o2 + i3[7] * r2 + i3[15], t4;
        }
        var he = function(t4, e2, i3) {
          void 0 === e2 && (e2 = new Yt(t4.width + 200, t4.height + 200, 25)), void 0 === i3 && (i3 = new Yt(t4.width + 200, t4.height + 200, 25)), this.transform = t4, this.grid = e2, this.ignoredGrid = i3, this.pitchfactor = Math.cos(t4._pitch) * t4.cameraToCenterDistance, this.screenRightBoundary = t4.width + 100, this.screenBottomBoundary = t4.height + 100, this.gridRightBoundary = t4.width + 200, this.gridBottomBoundary = t4.height + 200;
        };
        function pe(e2, i3, o2) {
          return i3 * (t.EXTENT / (e2.tileSize * Math.pow(2, o2 - e2.tileID.overscaledZ)));
        }
        he.prototype.placeCollisionBox = function(t4, e2, i3, o2, r2) {
          var a2 = this.projectAndGetPerspectiveRatio(o2, t4.anchorPointX, t4.anchorPointY), n2 = i3 * a2.perspectiveRatio, s2 = t4.x1 * n2 + a2.point.x, l2 = t4.y1 * n2 + a2.point.y, c2 = t4.x2 * n2 + a2.point.x, u2 = t4.y2 * n2 + a2.point.y;
          return !this.isInsideGrid(s2, l2, c2, u2) || !e2 && this.grid.hitTest(s2, l2, c2, u2, r2) ? { box: [], offscreen: false } : { box: [s2, l2, c2, u2], offscreen: this.isOffscreen(s2, l2, c2, u2) };
        }, he.prototype.placeCollisionCircles = function(e2, i3, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2) {
          var _2 = [], f2 = new t.Point(i3.anchorX, i3.anchorY), m2 = $t(f2, n2), g2 = te(this.transform.cameraToCenterDistance, m2.signedDistanceFromCamera), v2 = (u2 ? a2 / g2 : a2 * g2) / t.ONE_EM, y2 = $t(f2, s2).point, x3 = oe(v2, r2, i3.lineOffsetX * v2, i3.lineOffsetY * v2, false, y2, f2, i3, o2, s2, {}), b2 = false, w2 = false, T3 = true;
          if (x3) {
            for (var E3 = 0.5 * p2 * g2 + d2, I2 = new t.Point(-100, -100), P2 = new t.Point(this.screenRightBoundary, this.screenBottomBoundary), S2 = new Kt(), C3 = x3.first, z2 = x3.last, D3 = [], A3 = C3.path.length - 1; A3 >= 1; A3--)
              D3.push(C3.path[A3]);
            for (var M2 = 1; M2 < z2.path.length; M2++)
              D3.push(z2.path[M2]);
            var L3 = 2.5 * E3;
            if (l2) {
              var R2 = D3.map(function(t4) {
                return $t(t4, l2);
              });
              D3 = R2.some(function(t4) {
                return t4.signedDistanceFromCamera <= 0;
              }) ? [] : R2.map(function(t4) {
                return t4.point;
              });
            }
            var k2 = [];
            if (D3.length > 0) {
              for (var B3 = D3[0].clone(), O2 = D3[0].clone(), F2 = 1; F2 < D3.length; F2++)
                B3.x = Math.min(B3.x, D3[F2].x), B3.y = Math.min(B3.y, D3[F2].y), O2.x = Math.max(O2.x, D3[F2].x), O2.y = Math.max(O2.y, D3[F2].y);
              k2 = B3.x >= I2.x && O2.x <= P2.x && B3.y >= I2.y && O2.y <= P2.y ? [D3] : O2.x < I2.x || B3.x > P2.x || O2.y < I2.y || B3.y > P2.y ? [] : t.clipLine([D3], I2.x, I2.y, P2.x, P2.y);
            }
            for (var U2 = 0, N2 = k2; U2 < N2.length; U2 += 1) {
              var Z2;
              S2.reset(N2[U2], 0.25 * E3), Z2 = S2.length <= 0.5 * E3 ? 1 : Math.ceil(S2.paddedLength / L3) + 1;
              for (var q2 = 0; q2 < Z2; q2++) {
                var j2 = q2 / Math.max(Z2 - 1, 1), V2 = S2.lerp(j2), G2 = V2.x + 100, W2 = V2.y + 100;
                _2.push(G2, W2, E3, 0);
                var X2 = G2 - E3, H2 = W2 - E3, K3 = G2 + E3, Y2 = W2 + E3;
                if (T3 = T3 && this.isOffscreen(X2, H2, K3, Y2), w2 = w2 || this.isInsideGrid(X2, H2, K3, Y2), !e2 && this.grid.hitTestCircle(G2, W2, E3, h2) && (b2 = true, !c2))
                  return { circles: [], offscreen: false, collisionDetected: b2 };
              }
            }
          }
          return { circles: !c2 && b2 || !w2 ? [] : _2, offscreen: T3, collisionDetected: b2 };
        }, he.prototype.queryRenderedSymbols = function(e2) {
          if (0 === e2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
            return {};
          for (var i3 = [], o2 = 1 / 0, r2 = 1 / 0, a2 = -1 / 0, n2 = -1 / 0, s2 = 0, l2 = e2; s2 < l2.length; s2 += 1) {
            var c2 = l2[s2], u2 = new t.Point(c2.x + 100, c2.y + 100);
            o2 = Math.min(o2, u2.x), r2 = Math.min(r2, u2.y), a2 = Math.max(a2, u2.x), n2 = Math.max(n2, u2.y), i3.push(u2);
          }
          for (var h2 = {}, p2 = {}, d2 = 0, _2 = this.grid.query(o2, r2, a2, n2).concat(this.ignoredGrid.query(o2, r2, a2, n2)); d2 < _2.length; d2 += 1) {
            var f2 = _2[d2], m2 = f2.key;
            if (void 0 === h2[m2.bucketInstanceId] && (h2[m2.bucketInstanceId] = {}), !h2[m2.bucketInstanceId][m2.featureIndex]) {
              var g2 = [new t.Point(f2.x1, f2.y1), new t.Point(f2.x2, f2.y1), new t.Point(f2.x2, f2.y2), new t.Point(f2.x1, f2.y2)];
              t.polygonIntersectsPolygon(i3, g2) && (h2[m2.bucketInstanceId][m2.featureIndex] = true, void 0 === p2[m2.bucketInstanceId] && (p2[m2.bucketInstanceId] = []), p2[m2.bucketInstanceId].push(m2.featureIndex));
            }
          }
          return p2;
        }, he.prototype.insertCollisionBox = function(t4, e2, i3, o2, r2) {
          (e2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i3, featureIndex: o2, collisionGroupID: r2 }, t4[0], t4[1], t4[2], t4[3]);
        }, he.prototype.insertCollisionCircles = function(t4, e2, i3, o2, r2) {
          for (var a2 = e2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: i3, featureIndex: o2, collisionGroupID: r2 }, s2 = 0; s2 < t4.length; s2 += 4)
            a2.insertCircle(n2, t4[s2], t4[s2 + 1], t4[s2 + 2]);
        }, he.prototype.projectAndGetPerspectiveRatio = function(e2, i3, o2) {
          var r2 = [i3, o2, 0, 1];
          return ue(r2, r2, e2), { point: new t.Point((r2[0] / r2[3] + 1) / 2 * this.transform.width + 100, (-r2[1] / r2[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / r2[3] * 0.5 };
        }, he.prototype.isOffscreen = function(t4, e2, i3, o2) {
          return i3 < 100 || t4 >= this.screenRightBoundary || o2 < 100 || e2 > this.screenBottomBoundary;
        }, he.prototype.isInsideGrid = function(t4, e2, i3, o2) {
          return i3 >= 0 && t4 < this.gridRightBoundary && o2 >= 0 && e2 < this.gridBottomBoundary;
        }, he.prototype.getViewportMatrix = function() {
          var e2 = t.identity([]);
          return t.translate(e2, e2, [-100, -100, 0]), e2;
        };
        var de = function(t4, e2, i3, o2) {
          this.opacity = t4 ? Math.max(0, Math.min(1, t4.opacity + (t4.placed ? e2 : -e2))) : o2 && i3 ? 1 : 0, this.placed = i3;
        };
        de.prototype.isHidden = function() {
          return 0 === this.opacity && !this.placed;
        };
        var _e = function(t4, e2, i3, o2, r2) {
          this.text = new de(t4 ? t4.text : null, e2, i3, r2), this.icon = new de(t4 ? t4.icon : null, e2, o2, r2);
        };
        _e.prototype.isHidden = function() {
          return this.text.isHidden() && this.icon.isHidden();
        };
        var fe = function(t4, e2, i3) {
          this.text = t4, this.icon = e2, this.skipFade = i3;
        }, me = function() {
          this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [];
        }, ge = function(t4, e2, i3, o2, r2) {
          this.bucketInstanceId = t4, this.featureIndex = e2, this.sourceLayerIndex = i3, this.bucketIndex = o2, this.tileID = r2;
        }, ve = function(t4) {
          this.crossSourceCollisions = t4, this.maxGroupID = 0, this.collisionGroups = {};
        };
        function ye(e2, i3, o2, r2, a2) {
          var n2 = t.getAnchorAlignment(e2), s2 = -(n2.horizontalAlign - 0.5) * i3, l2 = -(n2.verticalAlign - 0.5) * o2, c2 = t.evaluateVariableOffset(e2, r2);
          return new t.Point(s2 + c2[0] * a2, l2 + c2[1] * a2);
        }
        function xe(e2, i3, o2, r2, a2, n2) {
          var s2 = e2.x1, l2 = e2.x2, c2 = e2.y1, u2 = e2.y2, h2 = e2.anchorPointX, p2 = e2.anchorPointY, d2 = new t.Point(i3, o2);
          return r2 && d2._rotate(a2 ? n2 : -n2), { x1: s2 + d2.x, y1: c2 + d2.y, x2: l2 + d2.x, y2: u2 + d2.y, anchorPointX: h2, anchorPointY: p2 };
        }
        ve.prototype.get = function(t4) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[t4]) {
            var e2 = ++this.maxGroupID;
            this.collisionGroups[t4] = { ID: e2, predicate: function(t5) {
              return t5.collisionGroupID === e2;
            } };
          }
          return this.collisionGroups[t4];
        };
        var be = function(t4, e2, i3, o2) {
          this.transform = t4.clone(), this.collisionIndex = new he(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = e2, this.retainedQueryData = {}, this.collisionGroups = new ve(i3), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
        };
        function we(t4, e2, i3, o2, r2) {
          t4.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, o2 || 0, r2 || 0), t4.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, o2 || 0, r2 || 0), t4.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, o2 || 0, r2 || 0), t4.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, o2 || 0, r2 || 0);
        }
        be.prototype.getBucketParts = function(e2, i3, o2, r2) {
          var a2 = o2.getBucket(i3), n2 = o2.latestFeatureIndex;
          if (a2 && n2 && i3.id === a2.layerIds[0]) {
            var s2 = o2.collisionBoxArray, l2 = a2.layers[0].layout, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), u2 = o2.tileSize / t.EXTENT, h2 = this.transform.calculatePosMatrix(o2.tileID.toUnwrapped()), p2 = "map" === l2.get("text-pitch-alignment"), d2 = "map" === l2.get("text-rotation-alignment"), _2 = pe(o2, 1, this.transform.zoom), f2 = Jt(h2, p2, d2, this.transform, _2), m2 = null;
            if (p2) {
              var g2 = Qt(h2, p2, d2, this.transform, _2);
              m2 = t.multiply([], this.transform.labelPlaneMatrix, g2);
            }
            this.retainedQueryData[a2.bucketInstanceId] = new ge(a2.bucketInstanceId, n2, a2.sourceLayerIndex, a2.index, o2.tileID);
            var v2 = { bucket: a2, layout: l2, posMatrix: h2, textLabelPlaneMatrix: f2, labelToScreenMatrix: m2, scale: c2, textPixelRatio: u2, holdingForFade: o2.holdingForFade(), collisionBoxArray: s2, partiallyEvaluatedTextSize: t.evaluateSizeForZoom(a2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(a2.sourceID) };
            if (r2)
              for (var y2 = 0, x3 = a2.sortKeyRanges; y2 < x3.length; y2 += 1) {
                var b2 = x3[y2];
                e2.push({ sortKey: b2.sortKey, symbolInstanceStart: b2.symbolInstanceStart, symbolInstanceEnd: b2.symbolInstanceEnd, parameters: v2 });
              }
            else
              e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: a2.symbolInstances.length, parameters: v2 });
          }
        }, be.prototype.attemptAnchorPlacement = function(t4, e2, i3, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2, _2) {
          var f2, m2 = [h2.textOffset0, h2.textOffset1], g2 = ye(t4, i3, o2, m2, r2), v2 = this.collisionIndex.placeCollisionBox(xe(e2, g2.x, g2.y, a2, n2, this.transform.angle), u2, s2, l2, c2.predicate);
          if (!_2 || 0 !== this.collisionIndex.placeCollisionBox(xe(_2, g2.x, g2.y, a2, n2, this.transform.angle), u2, s2, l2, c2.predicate).box.length)
            return v2.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[h2.crossTileID] && this.prevPlacement.placements[h2.crossTileID] && this.prevPlacement.placements[h2.crossTileID].text && (f2 = this.prevPlacement.variableOffsets[h2.crossTileID].anchor), this.variableOffsets[h2.crossTileID] = { textOffset: m2, width: i3, height: o2, anchor: t4, textBoxScale: r2, prevAnchor: f2 }, this.markUsedJustification(p2, t4, h2, d2), p2.allowVerticalPlacement && (this.markUsedOrientation(p2, d2, h2), this.placedOrientations[h2.crossTileID] = d2), { shift: g2, placedGlyphBoxes: v2 }) : void 0;
        }, be.prototype.placeLayerBucketPart = function(e2, i3, o2) {
          var r2 = this, a2 = e2.parameters, n2 = a2.bucket, s2 = a2.layout, l2 = a2.posMatrix, c2 = a2.textLabelPlaneMatrix, u2 = a2.labelToScreenMatrix, h2 = a2.textPixelRatio, p2 = a2.holdingForFade, d2 = a2.collisionBoxArray, _2 = a2.partiallyEvaluatedTextSize, f2 = a2.collisionGroup, m2 = s2.get("text-optional"), g2 = s2.get("icon-optional"), v2 = s2.get("text-allow-overlap"), y2 = s2.get("icon-allow-overlap"), x3 = "map" === s2.get("text-rotation-alignment"), b2 = "map" === s2.get("text-pitch-alignment"), w2 = "none" !== s2.get("icon-text-fit"), T3 = "viewport-y" === s2.get("symbol-z-order"), E3 = v2 && (y2 || !n2.hasIconData() || g2), I2 = y2 && (v2 || !n2.hasTextData() || m2);
          !n2.collisionArrays && d2 && n2.deserializeCollisionBoxes(d2);
          var P2 = function(e3, a3) {
            if (!i3[e3.crossTileID])
              if (p2)
                r2.placements[e3.crossTileID] = new fe(false, false, false);
              else {
                var d3, T4 = false, P3 = false, S3 = true, C4 = null, z3 = { box: null, offscreen: null }, D4 = { box: null, offscreen: null }, A4 = null, M2 = null, L3 = 0, R2 = 0, k2 = 0;
                a3.textFeatureIndex ? L3 = a3.textFeatureIndex : e3.useRuntimeCollisionCircles && (L3 = e3.featureIndex), a3.verticalTextFeatureIndex && (R2 = a3.verticalTextFeatureIndex);
                var B3 = a3.textBox;
                if (B3) {
                  var O2 = function(i4) {
                    var o3 = t.WritingMode.horizontal;
                    if (n2.allowVerticalPlacement && !i4 && r2.prevPlacement) {
                      var a4 = r2.prevPlacement.placedOrientations[e3.crossTileID];
                      a4 && (r2.placedOrientations[e3.crossTileID] = a4, r2.markUsedOrientation(n2, o3 = a4, e3));
                    }
                    return o3;
                  }, F2 = function(i4, o3) {
                    if (n2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && a3.verticalTextBox)
                      for (var r3 = 0, s3 = n2.writingModes; r3 < s3.length && (s3[r3] === t.WritingMode.vertical ? (z3 = o3(), D4 = z3) : z3 = i4(), !(z3 && z3.box && z3.box.length)); r3 += 1)
                        ;
                    else
                      z3 = i4();
                  };
                  if (s2.get("text-variable-anchor")) {
                    var U2 = s2.get("text-variable-anchor");
                    if (r2.prevPlacement && r2.prevPlacement.variableOffsets[e3.crossTileID]) {
                      var N2 = r2.prevPlacement.variableOffsets[e3.crossTileID];
                      U2.indexOf(N2.anchor) > 0 && (U2 = U2.filter(function(t4) {
                        return t4 !== N2.anchor;
                      })).unshift(N2.anchor);
                    }
                    var Z2 = function(t4, i4, o3) {
                      for (var a4 = t4.x2 - t4.x1, s3 = t4.y2 - t4.y1, c3 = e3.textBoxScale, u3 = w2 && !y2 ? i4 : null, p3 = { box: [], offscreen: false }, d4 = v2 ? 2 * U2.length : U2.length, _3 = 0; _3 < d4; ++_3) {
                        var m3 = r2.attemptAnchorPlacement(U2[_3 % U2.length], t4, a4, s3, c3, x3, b2, h2, l2, f2, _3 >= U2.length, e3, n2, o3, u3);
                        if (m3 && (p3 = m3.placedGlyphBoxes) && p3.box && p3.box.length) {
                          T4 = true, C4 = m3.shift;
                          break;
                        }
                      }
                      return p3;
                    };
                    F2(function() {
                      return Z2(B3, a3.iconBox, t.WritingMode.horizontal);
                    }, function() {
                      var i4 = a3.verticalTextBox;
                      return n2.allowVerticalPlacement && !(z3 && z3.box && z3.box.length) && e3.numVerticalGlyphVertices > 0 && i4 ? Z2(i4, a3.verticalIconBox, t.WritingMode.vertical) : { box: null, offscreen: null };
                    }), z3 && (T4 = z3.box, S3 = z3.offscreen);
                    var q2 = O2(z3 && z3.box);
                    if (!T4 && r2.prevPlacement) {
                      var j2 = r2.prevPlacement.variableOffsets[e3.crossTileID];
                      j2 && (r2.variableOffsets[e3.crossTileID] = j2, r2.markUsedJustification(n2, j2.anchor, e3, q2));
                    }
                  } else {
                    var V2 = function(t4, i4) {
                      var o3 = r2.collisionIndex.placeCollisionBox(t4, v2, h2, l2, f2.predicate);
                      return o3 && o3.box && o3.box.length && (r2.markUsedOrientation(n2, i4, e3), r2.placedOrientations[e3.crossTileID] = i4), o3;
                    };
                    F2(function() {
                      return V2(B3, t.WritingMode.horizontal);
                    }, function() {
                      var i4 = a3.verticalTextBox;
                      return n2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i4 ? V2(i4, t.WritingMode.vertical) : { box: null, offscreen: null };
                    }), O2(z3 && z3.box && z3.box.length);
                  }
                }
                if (T4 = (d3 = z3) && d3.box && d3.box.length > 0, S3 = d3 && d3.offscreen, e3.useRuntimeCollisionCircles) {
                  var G2 = n2.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex), W2 = t.evaluateSizeForFeature(n2.textSizeData, _2, G2), X2 = s2.get("text-padding");
                  A4 = r2.collisionIndex.placeCollisionCircles(v2, G2, n2.lineVertexArray, n2.glyphOffsetArray, W2, l2, c2, u2, o2, b2, f2.predicate, e3.collisionCircleDiameter, X2), T4 = v2 || A4.circles.length > 0 && !A4.collisionDetected, S3 = S3 && A4.offscreen;
                }
                if (a3.iconFeatureIndex && (k2 = a3.iconFeatureIndex), a3.iconBox) {
                  var H2 = function(t4) {
                    var e4 = w2 && C4 ? xe(t4, C4.x, C4.y, x3, b2, r2.transform.angle) : t4;
                    return r2.collisionIndex.placeCollisionBox(e4, y2, h2, l2, f2.predicate);
                  };
                  P3 = D4 && D4.box && D4.box.length && a3.verticalIconBox ? (M2 = H2(a3.verticalIconBox)).box.length > 0 : (M2 = H2(a3.iconBox)).box.length > 0, S3 = S3 && M2.offscreen;
                }
                var K3 = m2 || 0 === e3.numHorizontalGlyphVertices && 0 === e3.numVerticalGlyphVertices, Y2 = g2 || 0 === e3.numIconVertices;
                if (K3 || Y2 ? Y2 ? K3 || (P3 = P3 && T4) : T4 = P3 && T4 : P3 = T4 = P3 && T4, T4 && d3 && d3.box && r2.collisionIndex.insertCollisionBox(d3.box, s2.get("text-ignore-placement"), n2.bucketInstanceId, D4 && D4.box && R2 ? R2 : L3, f2.ID), P3 && M2 && r2.collisionIndex.insertCollisionBox(M2.box, s2.get("icon-ignore-placement"), n2.bucketInstanceId, k2, f2.ID), A4 && (T4 && r2.collisionIndex.insertCollisionCircles(A4.circles, s2.get("text-ignore-placement"), n2.bucketInstanceId, L3, f2.ID), o2)) {
                  var J2 = n2.bucketInstanceId, Q2 = r2.collisionCircleArrays[J2];
                  void 0 === Q2 && (Q2 = r2.collisionCircleArrays[J2] = new me());
                  for (var $2 = 0; $2 < A4.circles.length; $2 += 4)
                    Q2.circles.push(A4.circles[$2 + 0]), Q2.circles.push(A4.circles[$2 + 1]), Q2.circles.push(A4.circles[$2 + 2]), Q2.circles.push(A4.collisionDetected ? 1 : 0);
                }
                r2.placements[e3.crossTileID] = new fe(T4 || E3, P3 || I2, S3 || n2.justReloaded), i3[e3.crossTileID] = true;
              }
          };
          if (T3)
            for (var S2 = n2.getSortedSymbolIndexes(this.transform.angle), C3 = S2.length - 1; C3 >= 0; --C3) {
              var z2 = S2[C3];
              P2(n2.symbolInstances.get(z2), n2.collisionArrays[z2]);
            }
          else
            for (var D3 = e2.symbolInstanceStart; D3 < e2.symbolInstanceEnd; D3++)
              P2(n2.symbolInstances.get(D3), n2.collisionArrays[D3]);
          if (o2 && n2.bucketInstanceId in this.collisionCircleArrays) {
            var A3 = this.collisionCircleArrays[n2.bucketInstanceId];
            t.invert(A3.invProjMatrix, l2), A3.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          n2.justReloaded = false;
        }, be.prototype.markUsedJustification = function(e2, i3, o2, r2) {
          var a2;
          a2 = r2 === t.WritingMode.vertical ? o2.verticalPlacedTextSymbolIndex : { left: o2.leftJustifiedTextSymbolIndex, center: o2.centerJustifiedTextSymbolIndex, right: o2.rightJustifiedTextSymbolIndex }[t.getAnchorJustification(i3)];
          for (var n2 = 0, s2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex, o2.verticalPlacedTextSymbolIndex]; n2 < s2.length; n2 += 1) {
            var l2 = s2[n2];
            l2 >= 0 && (e2.text.placedSymbolArray.get(l2).crossTileID = a2 >= 0 && l2 !== a2 ? 0 : o2.crossTileID);
          }
        }, be.prototype.markUsedOrientation = function(e2, i3, o2) {
          for (var r2 = i3 === t.WritingMode.horizontal || i3 === t.WritingMode.horizontalOnly ? i3 : 0, a2 = i3 === t.WritingMode.vertical ? i3 : 0, n2 = 0, s2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex]; n2 < s2.length; n2 += 1)
            e2.text.placedSymbolArray.get(s2[n2]).placedOrientation = r2;
          o2.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(o2.verticalPlacedTextSymbolIndex).placedOrientation = a2);
        }, be.prototype.commit = function(t4) {
          this.commitTime = t4, this.zoomAtLastRecencyCheck = this.transform.zoom;
          var e2 = this.prevPlacement, i3 = false;
          this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
          var o2 = e2 ? e2.symbolFadeChange(t4) : 1, r2 = e2 ? e2.opacities : {}, a2 = e2 ? e2.variableOffsets : {}, n2 = e2 ? e2.placedOrientations : {};
          for (var s2 in this.placements) {
            var l2 = this.placements[s2], c2 = r2[s2];
            c2 ? (this.opacities[s2] = new _e(c2, o2, l2.text, l2.icon), i3 = i3 || l2.text !== c2.text.placed || l2.icon !== c2.icon.placed) : (this.opacities[s2] = new _e(null, o2, l2.text, l2.icon, l2.skipFade), i3 = i3 || l2.text || l2.icon);
          }
          for (var u2 in r2) {
            var h2 = r2[u2];
            if (!this.opacities[u2]) {
              var p2 = new _e(h2, o2, false, false);
              p2.isHidden() || (this.opacities[u2] = p2, i3 = i3 || h2.text.placed || h2.icon.placed);
            }
          }
          for (var d2 in a2)
            this.variableOffsets[d2] || !this.opacities[d2] || this.opacities[d2].isHidden() || (this.variableOffsets[d2] = a2[d2]);
          for (var _2 in n2)
            this.placedOrientations[_2] || !this.opacities[_2] || this.opacities[_2].isHidden() || (this.placedOrientations[_2] = n2[_2]);
          i3 ? this.lastPlacementChangeTime = t4 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t4);
        }, be.prototype.updateLayerOpacities = function(t4, e2) {
          for (var i3 = {}, o2 = 0, r2 = e2; o2 < r2.length; o2 += 1) {
            var a2 = r2[o2], n2 = a2.getBucket(t4);
            n2 && a2.latestFeatureIndex && t4.id === n2.layerIds[0] && this.updateBucketOpacities(n2, i3, a2.collisionBoxArray);
          }
        }, be.prototype.updateBucketOpacities = function(e2, i3, o2) {
          var r2 = this;
          e2.hasTextData() && e2.text.opacityVertexArray.clear(), e2.hasIconData() && e2.icon.opacityVertexArray.clear(), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
          var a2 = e2.layers[0].layout, n2 = new _e(null, 0, false, false, true), s2 = a2.get("text-allow-overlap"), l2 = a2.get("icon-allow-overlap"), c2 = a2.get("text-variable-anchor"), u2 = "map" === a2.get("text-rotation-alignment"), h2 = "map" === a2.get("text-pitch-alignment"), p2 = "none" !== a2.get("icon-text-fit"), d2 = new _e(null, 0, s2 && (l2 || !e2.hasIconData() || a2.get("icon-optional")), l2 && (s2 || !e2.hasTextData() || a2.get("text-optional")), true);
          !e2.collisionArrays && o2 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(o2);
          for (var _2 = function(t4, e3, i4) {
            for (var o3 = 0; o3 < e3 / 4; o3++)
              t4.opacityVertexArray.emplaceBack(i4);
          }, f2 = function(o3) {
            var a3 = e2.symbolInstances.get(o3), s3 = a3.numHorizontalGlyphVertices, l3 = a3.numVerticalGlyphVertices, f3 = a3.crossTileID, m3 = r2.opacities[f3];
            i3[f3] ? m3 = n2 : m3 || (r2.opacities[f3] = m3 = d2), i3[f3] = true;
            var g3 = a3.numIconVertices > 0, v2 = r2.placedOrientations[a3.crossTileID], y2 = v2 === t.WritingMode.vertical, x3 = v2 === t.WritingMode.horizontal || v2 === t.WritingMode.horizontalOnly;
            if (s3 > 0 || l3 > 0) {
              var b2 = De(m3.text);
              _2(e2.text, s3, y2 ? Ae : b2), _2(e2.text, l3, x3 ? Ae : b2);
              var w2 = m3.text.isHidden();
              [a3.rightJustifiedTextSymbolIndex, a3.centerJustifiedTextSymbolIndex, a3.leftJustifiedTextSymbolIndex].forEach(function(t4) {
                t4 >= 0 && (e2.text.placedSymbolArray.get(t4).hidden = w2 || y2 ? 1 : 0);
              }), a3.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(a3.verticalPlacedTextSymbolIndex).hidden = w2 || x3 ? 1 : 0);
              var T3 = r2.variableOffsets[a3.crossTileID];
              T3 && r2.markUsedJustification(e2, T3.anchor, a3, v2);
              var E3 = r2.placedOrientations[a3.crossTileID];
              E3 && (r2.markUsedJustification(e2, "left", a3, E3), r2.markUsedOrientation(e2, E3, a3));
            }
            if (g3) {
              var I2 = De(m3.icon), P2 = !(p2 && a3.verticalPlacedIconSymbolIndex && y2);
              a3.placedIconSymbolIndex >= 0 && (_2(e2.icon, a3.numIconVertices, P2 ? I2 : Ae), e2.icon.placedSymbolArray.get(a3.placedIconSymbolIndex).hidden = m3.icon.isHidden()), a3.verticalPlacedIconSymbolIndex >= 0 && (_2(e2.icon, a3.numVerticalIconVertices, P2 ? Ae : I2), e2.icon.placedSymbolArray.get(a3.verticalPlacedIconSymbolIndex).hidden = m3.icon.isHidden());
            }
            if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
              var S2 = e2.collisionArrays[o3];
              if (S2) {
                var C3 = new t.Point(0, 0);
                if (S2.textBox || S2.verticalTextBox) {
                  var z2 = true;
                  if (c2) {
                    var D3 = r2.variableOffsets[f3];
                    D3 ? (C3 = ye(D3.anchor, D3.width, D3.height, D3.textOffset, D3.textBoxScale), u2 && C3._rotate(h2 ? r2.transform.angle : -r2.transform.angle)) : z2 = false;
                  }
                  S2.textBox && we(e2.textCollisionBox.collisionVertexArray, m3.text.placed, !z2 || y2, C3.x, C3.y), S2.verticalTextBox && we(e2.textCollisionBox.collisionVertexArray, m3.text.placed, !z2 || x3, C3.x, C3.y);
                }
                var A3 = Boolean(!x3 && S2.verticalIconBox);
                S2.iconBox && we(e2.iconCollisionBox.collisionVertexArray, m3.icon.placed, A3, p2 ? C3.x : 0, p2 ? C3.y : 0), S2.verticalIconBox && we(e2.iconCollisionBox.collisionVertexArray, m3.icon.placed, !A3, p2 ? C3.x : 0, p2 ? C3.y : 0);
              }
            }
          }, m2 = 0; m2 < e2.symbolInstances.length; m2++)
            f2(m2);
          if (e2.sortFeatures(this.transform.angle), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.bucketInstanceId in this.collisionCircleArrays) {
            var g2 = this.collisionCircleArrays[e2.bucketInstanceId];
            e2.placementInvProjMatrix = g2.invProjMatrix, e2.placementViewportMatrix = g2.viewportMatrix, e2.collisionCircleArray = g2.circles, delete this.collisionCircleArrays[e2.bucketInstanceId];
          }
        }, be.prototype.symbolFadeChange = function(t4) {
          return 0 === this.fadeDuration ? 1 : (t4 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }, be.prototype.zoomAdjustment = function(t4) {
          return Math.max(0, (this.transform.zoom - t4) / 1.5);
        }, be.prototype.hasTransitions = function(t4) {
          return this.stale || t4 - this.lastPlacementChangeTime < this.fadeDuration;
        }, be.prototype.stillRecent = function(t4, e2) {
          var i3 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
          return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i3 > t4;
        }, be.prototype.setStale = function() {
          this.stale = true;
        };
        var Te = Math.pow(2, 25), Ee = Math.pow(2, 24), Ie = Math.pow(2, 17), Pe = Math.pow(2, 16), Se = Math.pow(2, 9), Ce = Math.pow(2, 8), ze = Math.pow(2, 1);
        function De(t4) {
          if (0 === t4.opacity && !t4.placed)
            return 0;
          if (1 === t4.opacity && t4.placed)
            return 4294967295;
          var e2 = t4.placed ? 1 : 0, i3 = Math.floor(127 * t4.opacity);
          return i3 * Te + e2 * Ee + i3 * Ie + e2 * Pe + i3 * Se + e2 * Ce + i3 * ze + e2;
        }
        var Ae = 0, Me = function(t4) {
          this._sortAcrossTiles = "viewport-y" !== t4.layout.get("symbol-z-order") && void 0 !== t4.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        };
        Me.prototype.continuePlacement = function(t4, e2, i3, o2, r2) {
          for (var a2 = this._bucketParts; this._currentTileIndex < t4.length; )
            if (e2.getBucketParts(a2, o2, t4[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r2())
              return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a2.sort(function(t5, e3) {
            return t5.sortKey - e3.sortKey;
          })); this._currentPartIndex < a2.length; )
            if (e2.placeLayerBucketPart(a2[this._currentPartIndex], this._seenCrossTileIDs, i3), this._currentPartIndex++, r2())
              return true;
          return false;
        };
        var Le = function(t4, e2, i3, o2, r2, a2, n2) {
          this.placement = new be(t4, r2, a2, n2), this._currentPlacementIndex = e2.length - 1, this._forceFullPlacement = i3, this._showCollisionBoxes = o2, this._done = false;
        };
        Le.prototype.isDone = function() {
          return this._done;
        }, Le.prototype.continuePlacement = function(e2, i3, o2) {
          for (var r2 = this, a2 = t.browser.now(), n2 = function() {
            var e3 = t.browser.now() - a2;
            return !r2._forceFullPlacement && e3 > 2;
          }; this._currentPlacementIndex >= 0; ) {
            var s2 = i3[e2[this._currentPlacementIndex]], l2 = this.placement.collisionIndex.transform.zoom;
            if ("symbol" === s2.type && (!s2.minzoom || s2.minzoom <= l2) && (!s2.maxzoom || s2.maxzoom > l2)) {
              if (this._inProgressLayer || (this._inProgressLayer = new Me(s2)), this._inProgressLayer.continuePlacement(o2[s2.source], this.placement, this._showCollisionBoxes, s2, n2))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }, Le.prototype.commit = function(t4) {
          return this.placement.commit(t4), this.placement;
        };
        var Re = 512 / t.EXTENT / 2, ke = function(t4, e2, i3) {
          this.tileID = t4, this.indexedSymbolInstances = {}, this.bucketInstanceId = i3;
          for (var o2 = 0; o2 < e2.length; o2++) {
            var r2 = e2.get(o2), a2 = r2.key;
            this.indexedSymbolInstances[a2] || (this.indexedSymbolInstances[a2] = []), this.indexedSymbolInstances[a2].push({ crossTileID: r2.crossTileID, coord: this.getScaledCoordinates(r2, t4) });
          }
        };
        ke.prototype.getScaledCoordinates = function(e2, i3) {
          var o2 = Re / Math.pow(2, i3.canonical.z - this.tileID.canonical.z);
          return { x: Math.floor((i3.canonical.x * t.EXTENT + e2.anchorX) * o2), y: Math.floor((i3.canonical.y * t.EXTENT + e2.anchorY) * o2) };
        }, ke.prototype.findMatches = function(t4, e2, i3) {
          for (var o2 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z), r2 = 0; r2 < t4.length; r2++) {
            var a2 = t4.get(r2);
            if (!a2.crossTileID) {
              var n2 = this.indexedSymbolInstances[a2.key];
              if (n2)
                for (var s2 = this.getScaledCoordinates(a2, e2), l2 = 0, c2 = n2; l2 < c2.length; l2 += 1) {
                  var u2 = c2[l2];
                  if (Math.abs(u2.coord.x - s2.x) <= o2 && Math.abs(u2.coord.y - s2.y) <= o2 && !i3[u2.crossTileID]) {
                    i3[u2.crossTileID] = true, a2.crossTileID = u2.crossTileID;
                    break;
                  }
                }
            }
          }
        };
        var Be = function() {
          this.maxCrossTileID = 0;
        };
        Be.prototype.generate = function() {
          return ++this.maxCrossTileID;
        };
        var Oe = function() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        };
        Oe.prototype.handleWrapJump = function(t4) {
          var e2 = Math.round((t4 - this.lng) / 360);
          if (0 !== e2)
            for (var i3 in this.indexes) {
              var o2 = this.indexes[i3], r2 = {};
              for (var a2 in o2) {
                var n2 = o2[a2];
                n2.tileID = n2.tileID.unwrapTo(n2.tileID.wrap + e2), r2[n2.tileID.key] = n2;
              }
              this.indexes[i3] = r2;
            }
          this.lng = t4;
        }, Oe.prototype.addBucket = function(t4, e2, i3) {
          if (this.indexes[t4.overscaledZ] && this.indexes[t4.overscaledZ][t4.key]) {
            if (this.indexes[t4.overscaledZ][t4.key].bucketInstanceId === e2.bucketInstanceId)
              return false;
            this.removeBucketCrossTileIDs(t4.overscaledZ, this.indexes[t4.overscaledZ][t4.key]);
          }
          for (var o2 = 0; o2 < e2.symbolInstances.length; o2++)
            e2.symbolInstances.get(o2).crossTileID = 0;
          this.usedCrossTileIDs[t4.overscaledZ] || (this.usedCrossTileIDs[t4.overscaledZ] = {});
          var r2 = this.usedCrossTileIDs[t4.overscaledZ];
          for (var a2 in this.indexes) {
            var n2 = this.indexes[a2];
            if (Number(a2) > t4.overscaledZ)
              for (var s2 in n2) {
                var l2 = n2[s2];
                l2.tileID.isChildOf(t4) && l2.findMatches(e2.symbolInstances, t4, r2);
              }
            else {
              var c2 = n2[t4.scaledTo(Number(a2)).key];
              c2 && c2.findMatches(e2.symbolInstances, t4, r2);
            }
          }
          for (var u2 = 0; u2 < e2.symbolInstances.length; u2++) {
            var h2 = e2.symbolInstances.get(u2);
            h2.crossTileID || (h2.crossTileID = i3.generate(), r2[h2.crossTileID] = true);
          }
          return void 0 === this.indexes[t4.overscaledZ] && (this.indexes[t4.overscaledZ] = {}), this.indexes[t4.overscaledZ][t4.key] = new ke(t4, e2.symbolInstances, e2.bucketInstanceId), true;
        }, Oe.prototype.removeBucketCrossTileIDs = function(t4, e2) {
          for (var i3 in e2.indexedSymbolInstances)
            for (var o2 = 0, r2 = e2.indexedSymbolInstances[i3]; o2 < r2.length; o2 += 1)
              delete this.usedCrossTileIDs[t4][r2[o2].crossTileID];
        }, Oe.prototype.removeStaleBuckets = function(t4) {
          var e2 = false;
          for (var i3 in this.indexes) {
            var o2 = this.indexes[i3];
            for (var r2 in o2)
              t4[o2[r2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i3, o2[r2]), delete o2[r2], e2 = true);
          }
          return e2;
        };
        var Fe = function() {
          this.layerIndexes = {}, this.crossTileIDs = new Be(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        };
        Fe.prototype.addLayer = function(t4, e2, i3) {
          var o2 = this.layerIndexes[t4.id];
          void 0 === o2 && (o2 = this.layerIndexes[t4.id] = new Oe());
          var r2 = false, a2 = {};
          o2.handleWrapJump(i3);
          for (var n2 = 0, s2 = e2; n2 < s2.length; n2 += 1) {
            var l2 = s2[n2], c2 = l2.getBucket(t4);
            c2 && t4.id === c2.layerIds[0] && (c2.bucketInstanceId || (c2.bucketInstanceId = ++this.maxBucketInstanceId), o2.addBucket(l2.tileID, c2, this.crossTileIDs) && (r2 = true), a2[c2.bucketInstanceId] = true);
          }
          return o2.removeStaleBuckets(a2) && (r2 = true), r2;
        }, Fe.prototype.pruneUnusedLayers = function(t4) {
          var e2 = {};
          for (var i3 in t4.forEach(function(t5) {
            e2[t5] = true;
          }), this.layerIndexes)
            e2[i3] || delete this.layerIndexes[i3];
        };
        var Ue = function(e2, i3) {
          return t.emitValidationErrors(e2, i3 && i3.filter(function(t4) {
            return "source.canvas" !== t4.identifier;
          }));
        }, Ne = t.pick(Zt, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), Ze = t.pick(Zt, ["setCenter", "setZoom", "setBearing", "setPitch"]), qe = function() {
          var e2 = {}, i3 = t.styleSpec.$version;
          for (var o2 in t.styleSpec.$root) {
            var r2, a2 = t.styleSpec.$root[o2];
            if (a2.required)
              null != (r2 = "version" === o2 ? i3 : "array" === a2.type ? [] : {}) && (e2[o2] = r2);
          }
          return e2;
        }(), je = function(e2) {
          function i3(o2, r2) {
            var a2 = this;
            void 0 === r2 && (r2 = {}), e2.call(this), this.map = o2, this.dispatcher = new E2(Ft(), this), this.imageManager = new p(), this.imageManager.setEventedParent(this), this.glyphManager = new y(o2._requestManager, r2.localIdeographFontFamily), this.lineAtlas = new T2(256, 512), this.crossTileSymbolIndex = new Fe(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer());
            var n2 = this;
            this._rtlTextPluginCallback = i3.registerForPluginStateChange(function(e3) {
              n2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e3.pluginStatus, pluginURL: e3.pluginURL }, function(e4, i4) {
                if (t.triggerPluginCompletionEvent(e4), i4 && i4.every(function(t4) {
                  return t4;
                }))
                  for (var o3 in n2.sourceCaches)
                    n2.sourceCaches[o3].reload();
              });
            }), this.on("data", function(t4) {
              if ("source" === t4.dataType && "metadata" === t4.sourceDataType) {
                var e3 = a2.sourceCaches[t4.sourceId];
                if (e3) {
                  var i4 = e3.getSource();
                  if (i4 && i4.vectorLayerIds)
                    for (var o3 in a2._layers) {
                      var r3 = a2._layers[o3];
                      r3.source === i4.id && a2._validateLayer(r3);
                    }
                }
              }
            });
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.loadURL = function(e3, i4) {
            var o2 = this;
            void 0 === i4 && (i4 = {}), this.fire(new t.Event("dataloading", { dataType: "style" }));
            var r2 = "boolean" == typeof i4.validate ? i4.validate : !t.isMapboxURL(e3);
            e3 = this.map._requestManager.normalizeStyleURL(e3, i4.accessToken);
            var a2 = this.map._requestManager.transformRequest(e3, t.ResourceType.Style);
            this._request = t.getJSON(a2, function(e4, i5) {
              o2._request = null, e4 ? o2.fire(new t.ErrorEvent(e4)) : i5 && o2._load(i5, r2);
            });
          }, i3.prototype.loadJSON = function(e3, i4) {
            var o2 = this;
            void 0 === i4 && (i4 = {}), this.fire(new t.Event("dataloading", { dataType: "style" })), this._request = t.browser.frame(function() {
              o2._request = null, o2._load(e3, false !== i4.validate);
            });
          }, i3.prototype.loadEmpty = function() {
            this.fire(new t.Event("dataloading", { dataType: "style" })), this._load(qe, false);
          }, i3.prototype._load = function(e3, i4) {
            if (!i4 || !Ue(this, t.validateStyle(e3))) {
              for (var o2 in this._loaded = true, this.stylesheet = e3, e3.sources)
                this.addSource(o2, e3.sources[o2], { validate: false });
              e3.sprite ? this._loadSprite(e3.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(e3.glyphs);
              var r2 = Nt(this.stylesheet.layers);
              this._order = r2.map(function(t4) {
                return t4.id;
              }), this._layers = {}, this._serializedLayers = {};
              for (var a2 = 0, n2 = r2; a2 < n2.length; a2 += 1) {
                var s2 = n2[a2];
                (s2 = t.createStyleLayer(s2)).setEventedParent(this, { layer: { id: s2.id } }), this._layers[s2.id] = s2, this._serializedLayers[s2.id] = s2.serialize();
              }
              this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.fire(new t.Event("data", { dataType: "style" })), this.fire(new t.Event("style.load"));
            }
          }, i3.prototype._loadSprite = function(e3) {
            var i4 = this;
            this._spriteRequest = function(e4, i5, o2) {
              var r2, a2, n2, s2 = t.browser.devicePixelRatio > 1 ? "@2x" : "", l2 = t.getJSON(i5.transformRequest(i5.normalizeSpriteURL(e4, s2, ".json"), t.ResourceType.SpriteJSON), function(t4, e5) {
                l2 = null, n2 || (n2 = t4, r2 = e5, u2());
              }), c2 = t.getImage(i5.transformRequest(i5.normalizeSpriteURL(e4, s2, ".png"), t.ResourceType.SpriteImage), function(t4, e5) {
                c2 = null, n2 || (n2 = t4, a2 = e5, u2());
              });
              function u2() {
                if (n2)
                  o2(n2);
                else if (r2 && a2) {
                  var e5 = t.browser.getImageData(a2), i6 = {};
                  for (var s3 in r2) {
                    var l3 = r2[s3], c3 = l3.width, u3 = l3.height, h2 = l3.x, p2 = l3.y, d2 = l3.sdf, _2 = l3.pixelRatio, f2 = l3.stretchX, m2 = l3.stretchY, g2 = l3.content, v2 = new t.RGBAImage({ width: c3, height: u3 });
                    t.RGBAImage.copy(e5, v2, { x: h2, y: p2 }, { x: 0, y: 0 }, { width: c3, height: u3 }), i6[s3] = { data: v2, pixelRatio: _2, sdf: d2, stretchX: f2, stretchY: m2, content: g2 };
                  }
                  o2(null, i6);
                }
              }
              return { cancel: function() {
                l2 && (l2.cancel(), l2 = null), c2 && (c2.cancel(), c2 = null);
              } };
            }(e3, this.map._requestManager, function(e4, o2) {
              if (i4._spriteRequest = null, e4)
                i4.fire(new t.ErrorEvent(e4));
              else if (o2)
                for (var r2 in o2)
                  i4.imageManager.addImage(r2, o2[r2]);
              i4.imageManager.setLoaded(true), i4._availableImages = i4.imageManager.listImages(), i4.dispatcher.broadcast("setImages", i4._availableImages), i4.fire(new t.Event("data", { dataType: "style" }));
            });
          }, i3.prototype._validateLayer = function(e3) {
            var i4 = this.sourceCaches[e3.source];
            if (i4) {
              var o2 = e3.sourceLayer;
              if (o2) {
                var r2 = i4.getSource();
                ("geojson" === r2.type || r2.vectorLayerIds && -1 === r2.vectorLayerIds.indexOf(o2)) && this.fire(new t.ErrorEvent(new Error('Source layer "' + o2 + '" does not exist on source "' + r2.id + '" as specified by style layer "' + e3.id + '"')));
              }
            }
          }, i3.prototype.loaded = function() {
            if (!this._loaded)
              return false;
            if (Object.keys(this._updatedSources).length)
              return false;
            for (var t4 in this.sourceCaches)
              if (!this.sourceCaches[t4].loaded())
                return false;
            return !!this.imageManager.isLoaded();
          }, i3.prototype._serializeLayers = function(t4) {
            for (var e3 = [], i4 = 0, o2 = t4; i4 < o2.length; i4 += 1) {
              var r2 = this._layers[o2[i4]];
              "custom" !== r2.type && e3.push(r2.serialize());
            }
            return e3;
          }, i3.prototype.hasTransitions = function() {
            if (this.light && this.light.hasTransition())
              return true;
            for (var t4 in this.sourceCaches)
              if (this.sourceCaches[t4].hasTransition())
                return true;
            for (var e3 in this._layers)
              if (this._layers[e3].hasTransition())
                return true;
            return false;
          }, i3.prototype._checkLoaded = function() {
            if (!this._loaded)
              throw new Error("Style is not done loading");
          }, i3.prototype.update = function(e3) {
            if (this._loaded) {
              var i4 = this._changed;
              if (this._changed) {
                var o2 = Object.keys(this._updatedLayers), r2 = Object.keys(this._removedLayers);
                for (var a2 in (o2.length || r2.length) && this._updateWorkerLayers(o2, r2), this._updatedSources) {
                  var n2 = this._updatedSources[a2];
                  "reload" === n2 ? this._reloadSource(a2) : "clear" === n2 && this._clearSource(a2);
                }
                for (var s2 in this._updateTilesForChangedImages(), this._updatedPaintProps)
                  this._layers[s2].updateTransitions(e3);
                this.light.updateTransitions(e3), this._resetUpdates();
              }
              var l2 = {};
              for (var c2 in this.sourceCaches) {
                var u2 = this.sourceCaches[c2];
                l2[c2] = u2.used, u2.used = false;
              }
              for (var h2 = 0, p2 = this._order; h2 < p2.length; h2 += 1) {
                var d2 = this._layers[p2[h2]];
                d2.recalculate(e3, this._availableImages), !d2.isHidden(e3.zoom) && d2.source && (this.sourceCaches[d2.source].used = true);
              }
              for (var _2 in l2) {
                var f2 = this.sourceCaches[_2];
                l2[_2] !== f2.used && f2.fire(new t.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: _2 }));
              }
              this.light.recalculate(e3), this.z = e3.zoom, i4 && this.fire(new t.Event("data", { dataType: "style" }));
            }
          }, i3.prototype._updateTilesForChangedImages = function() {
            var t4 = Object.keys(this._changedImages);
            if (t4.length) {
              for (var e3 in this.sourceCaches)
                this.sourceCaches[e3].reloadTilesForDependencies(["icons", "patterns"], t4);
              this._changedImages = {};
            }
          }, i3.prototype._updateWorkerLayers = function(t4, e3) {
            this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(t4), removedIds: e3 });
          }, i3.prototype._resetUpdates = function() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
          }, i3.prototype.setState = function(e3) {
            var i4 = this;
            if (this._checkLoaded(), Ue(this, t.validateStyle(e3)))
              return false;
            (e3 = t.clone$1(e3)).layers = Nt(e3.layers);
            var o2 = function(e4, i5) {
              if (!e4)
                return [{ command: Zt.setStyle, args: [i5] }];
              var o3 = [];
              try {
                if (!t.deepEqual(e4.version, i5.version))
                  return [{ command: Zt.setStyle, args: [i5] }];
                t.deepEqual(e4.center, i5.center) || o3.push({ command: Zt.setCenter, args: [i5.center] }), t.deepEqual(e4.zoom, i5.zoom) || o3.push({ command: Zt.setZoom, args: [i5.zoom] }), t.deepEqual(e4.bearing, i5.bearing) || o3.push({ command: Zt.setBearing, args: [i5.bearing] }), t.deepEqual(e4.pitch, i5.pitch) || o3.push({ command: Zt.setPitch, args: [i5.pitch] }), t.deepEqual(e4.sprite, i5.sprite) || o3.push({ command: Zt.setSprite, args: [i5.sprite] }), t.deepEqual(e4.glyphs, i5.glyphs) || o3.push({ command: Zt.setGlyphs, args: [i5.glyphs] }), t.deepEqual(e4.transition, i5.transition) || o3.push({ command: Zt.setTransition, args: [i5.transition] }), t.deepEqual(e4.light, i5.light) || o3.push({ command: Zt.setLight, args: [i5.light] });
                var r3 = {}, a2 = [];
                !function(e5, i6, o4, r4) {
                  var a3;
                  for (a3 in i6 = i6 || {}, e5 = e5 || {})
                    e5.hasOwnProperty(a3) && (i6.hasOwnProperty(a3) || jt(a3, o4, r4));
                  for (a3 in i6)
                    i6.hasOwnProperty(a3) && (e5.hasOwnProperty(a3) ? t.deepEqual(e5[a3], i6[a3]) || ("geojson" === e5[a3].type && "geojson" === i6[a3].type && Gt(e5, i6, a3) ? o4.push({ command: Zt.setGeoJSONSourceData, args: [a3, i6[a3].data] }) : Vt(a3, i6, o4, r4)) : qt(a3, i6, o4));
                }(e4.sources, i5.sources, a2, r3);
                var n2 = [];
                e4.layers && e4.layers.forEach(function(t4) {
                  r3[t4.source] ? o3.push({ command: Zt.removeLayer, args: [t4.id] }) : n2.push(t4);
                }), o3 = o3.concat(a2), function(e5, i6, o4) {
                  i6 = i6 || [];
                  var r4, a3, n3, s2, l2, c2, u2, h2 = (e5 = e5 || []).map(Xt), p2 = i6.map(Xt), d2 = e5.reduce(Ht, {}), _2 = i6.reduce(Ht, {}), f2 = h2.slice(), m2 = /* @__PURE__ */ Object.create(null);
                  for (r4 = 0, a3 = 0; r4 < h2.length; r4++)
                    _2.hasOwnProperty(n3 = h2[r4]) ? a3++ : (o4.push({ command: Zt.removeLayer, args: [n3] }), f2.splice(f2.indexOf(n3, a3), 1));
                  for (r4 = 0, a3 = 0; r4 < p2.length; r4++)
                    f2[f2.length - 1 - r4] !== (n3 = p2[p2.length - 1 - r4]) && (d2.hasOwnProperty(n3) ? (o4.push({ command: Zt.removeLayer, args: [n3] }), f2.splice(f2.lastIndexOf(n3, f2.length - a3), 1)) : a3++, o4.push({ command: Zt.addLayer, args: [_2[n3], c2 = f2[f2.length - r4]] }), f2.splice(f2.length - r4, 0, n3), m2[n3] = true);
                  for (r4 = 0; r4 < p2.length; r4++)
                    if (s2 = d2[n3 = p2[r4]], l2 = _2[n3], !m2[n3] && !t.deepEqual(s2, l2))
                      if (t.deepEqual(s2.source, l2.source) && t.deepEqual(s2["source-layer"], l2["source-layer"]) && t.deepEqual(s2.type, l2.type)) {
                        for (u2 in Wt(s2.layout, l2.layout, o4, n3, null, Zt.setLayoutProperty), Wt(s2.paint, l2.paint, o4, n3, null, Zt.setPaintProperty), t.deepEqual(s2.filter, l2.filter) || o4.push({ command: Zt.setFilter, args: [n3, l2.filter] }), t.deepEqual(s2.minzoom, l2.minzoom) && t.deepEqual(s2.maxzoom, l2.maxzoom) || o4.push({ command: Zt.setLayerZoomRange, args: [n3, l2.minzoom, l2.maxzoom] }), s2)
                          s2.hasOwnProperty(u2) && "layout" !== u2 && "paint" !== u2 && "filter" !== u2 && "metadata" !== u2 && "minzoom" !== u2 && "maxzoom" !== u2 && (0 === u2.indexOf("paint.") ? Wt(s2[u2], l2[u2], o4, n3, u2.slice(6), Zt.setPaintProperty) : t.deepEqual(s2[u2], l2[u2]) || o4.push({ command: Zt.setLayerProperty, args: [n3, u2, l2[u2]] }));
                        for (u2 in l2)
                          l2.hasOwnProperty(u2) && !s2.hasOwnProperty(u2) && "layout" !== u2 && "paint" !== u2 && "filter" !== u2 && "metadata" !== u2 && "minzoom" !== u2 && "maxzoom" !== u2 && (0 === u2.indexOf("paint.") ? Wt(s2[u2], l2[u2], o4, n3, u2.slice(6), Zt.setPaintProperty) : t.deepEqual(s2[u2], l2[u2]) || o4.push({ command: Zt.setLayerProperty, args: [n3, u2, l2[u2]] }));
                      } else
                        o4.push({ command: Zt.removeLayer, args: [n3] }), c2 = f2[f2.lastIndexOf(n3) + 1], o4.push({ command: Zt.addLayer, args: [l2, c2] });
                }(n2, i5.layers, o3);
              } catch (t4) {
                console.warn("Unable to compute style diff:", t4), o3 = [{ command: Zt.setStyle, args: [i5] }];
              }
              return o3;
            }(this.serialize(), e3).filter(function(t4) {
              return !(t4.command in Ze);
            });
            if (0 === o2.length)
              return false;
            var r2 = o2.filter(function(t4) {
              return !(t4.command in Ne);
            });
            if (r2.length > 0)
              throw new Error("Unimplemented: " + r2.map(function(t4) {
                return t4.command;
              }).join(", ") + ".");
            return o2.forEach(function(t4) {
              "setTransition" !== t4.command && i4[t4.command].apply(i4, t4.args);
            }), this.stylesheet = e3, true;
          }, i3.prototype.addImage = function(e3, i4) {
            if (this.getImage(e3))
              return this.fire(new t.ErrorEvent(new Error("An image with this name already exists.")));
            this.imageManager.addImage(e3, i4), this._afterImageUpdated(e3);
          }, i3.prototype.updateImage = function(t4, e3) {
            this.imageManager.updateImage(t4, e3);
          }, i3.prototype.getImage = function(t4) {
            return this.imageManager.getImage(t4);
          }, i3.prototype.removeImage = function(e3) {
            if (!this.getImage(e3))
              return this.fire(new t.ErrorEvent(new Error("No image with this name exists.")));
            this.imageManager.removeImage(e3), this._afterImageUpdated(e3);
          }, i3.prototype._afterImageUpdated = function(e3) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e3] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" }));
          }, i3.prototype.listImages = function() {
            return this._checkLoaded(), this.imageManager.listImages();
          }, i3.prototype.addSource = function(e3, i4, o2) {
            var r2 = this;
            if (void 0 === o2 && (o2 = {}), this._checkLoaded(), void 0 !== this.sourceCaches[e3])
              throw new Error("There is already a source with this ID");
            if (!i4.type)
              throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(i4).join(", ") + ".");
            if (!(["vector", "raster", "geojson", "video", "image"].indexOf(i4.type) >= 0 && this._validate(t.validateStyle.source, "sources." + e3, i4, null, o2))) {
              this.map && this.map._collectResourceTiming && (i4.collectResourceTiming = true);
              var a2 = this.sourceCaches[e3] = new Dt(e3, i4, this.dispatcher);
              a2.style = this, a2.setEventedParent(this, function() {
                return { isSourceLoaded: r2.loaded(), source: a2.serialize(), sourceId: e3 };
              }), a2.onAdd(this.map), this._changed = true;
            }
          }, i3.prototype.removeSource = function(e3) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[e3])
              throw new Error("There is no source with this ID");
            for (var i4 in this._layers)
              if (this._layers[i4].source === e3)
                return this.fire(new t.ErrorEvent(new Error('Source "' + e3 + '" cannot be removed while layer "' + i4 + '" is using it.')));
            var o2 = this.sourceCaches[e3];
            delete this.sourceCaches[e3], delete this._updatedSources[e3], o2.fire(new t.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e3 })), o2.setEventedParent(null), o2.clearTiles(), o2.onRemove && o2.onRemove(this.map), this._changed = true;
          }, i3.prototype.setGeoJSONSourceData = function(t4, e3) {
            this._checkLoaded(), this.sourceCaches[t4].getSource().setData(e3), this._changed = true;
          }, i3.prototype.getSource = function(t4) {
            return this.sourceCaches[t4] && this.sourceCaches[t4].getSource();
          }, i3.prototype.addLayer = function(e3, i4, o2) {
            void 0 === o2 && (o2 = {}), this._checkLoaded();
            var r2 = e3.id;
            if (this.getLayer(r2))
              this.fire(new t.ErrorEvent(new Error('Layer with id "' + r2 + '" already exists on this map')));
            else {
              var a2;
              if ("custom" === e3.type) {
                if (Ue(this, t.validateCustomStyleLayer(e3)))
                  return;
                a2 = t.createStyleLayer(e3);
              } else {
                if ("object" == typeof e3.source && (this.addSource(r2, e3.source), e3 = t.clone$1(e3), e3 = t.extend(e3, { source: r2 })), this._validate(t.validateStyle.layer, "layers." + r2, e3, { arrayIndex: -1 }, o2))
                  return;
                a2 = t.createStyleLayer(e3), this._validateLayer(a2), a2.setEventedParent(this, { layer: { id: r2 } }), this._serializedLayers[a2.id] = a2.serialize();
              }
              var n2 = i4 ? this._order.indexOf(i4) : this._order.length;
              if (i4 && -1 === n2)
                this.fire(new t.ErrorEvent(new Error('Layer with id "' + i4 + '" does not exist on this map.')));
              else {
                if (this._order.splice(n2, 0, r2), this._layerOrderChanged = true, this._layers[r2] = a2, this._removedLayers[r2] && a2.source && "custom" !== a2.type) {
                  var s2 = this._removedLayers[r2];
                  delete this._removedLayers[r2], s2.type !== a2.type ? this._updatedSources[a2.source] = "clear" : (this._updatedSources[a2.source] = "reload", this.sourceCaches[a2.source].pause());
                }
                this._updateLayer(a2), a2.onAdd && a2.onAdd(this.map);
              }
            }
          }, i3.prototype.moveLayer = function(e3, i4) {
            if (this._checkLoaded(), this._changed = true, this._layers[e3]) {
              if (e3 !== i4) {
                var o2 = this._order.indexOf(e3);
                this._order.splice(o2, 1);
                var r2 = i4 ? this._order.indexOf(i4) : this._order.length;
                i4 && -1 === r2 ? this.fire(new t.ErrorEvent(new Error('Layer with id "' + i4 + '" does not exist on this map.'))) : (this._order.splice(r2, 0, e3), this._layerOrderChanged = true);
              }
            } else
              this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be moved.")));
          }, i3.prototype.removeLayer = function(e3) {
            this._checkLoaded();
            var i4 = this._layers[e3];
            if (i4) {
              i4.setEventedParent(null);
              var o2 = this._order.indexOf(e3);
              this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e3] = i4, delete this._layers[e3], delete this._serializedLayers[e3], delete this._updatedLayers[e3], delete this._updatedPaintProps[e3], i4.onRemove && i4.onRemove(this.map);
            } else
              this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be removed.")));
          }, i3.prototype.getLayer = function(t4) {
            return this._layers[t4];
          }, i3.prototype.hasLayer = function(t4) {
            return t4 in this._layers;
          }, i3.prototype.setLayerZoomRange = function(e3, i4, o2) {
            this._checkLoaded();
            var r2 = this.getLayer(e3);
            r2 ? r2.minzoom === i4 && r2.maxzoom === o2 || (null != i4 && (r2.minzoom = i4), null != o2 && (r2.maxzoom = o2), this._updateLayer(r2)) : this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot have zoom extent.")));
          }, i3.prototype.setFilter = function(e3, i4, o2) {
            void 0 === o2 && (o2 = {}), this._checkLoaded();
            var r2 = this.getLayer(e3);
            if (r2) {
              if (!t.deepEqual(r2.filter, i4))
                return null == i4 ? (r2.filter = void 0, void this._updateLayer(r2)) : void (this._validate(t.validateStyle.filter, "layers." + r2.id + ".filter", i4, null, o2) || (r2.filter = t.clone$1(i4), this._updateLayer(r2)));
            } else
              this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be filtered.")));
          }, i3.prototype.getFilter = function(e3) {
            return t.clone$1(this.getLayer(e3).filter);
          }, i3.prototype.setLayoutProperty = function(e3, i4, o2, r2) {
            void 0 === r2 && (r2 = {}), this._checkLoaded();
            var a2 = this.getLayer(e3);
            a2 ? t.deepEqual(a2.getLayoutProperty(i4), o2) || (a2.setLayoutProperty(i4, o2, r2), this._updateLayer(a2)) : this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be styled.")));
          }, i3.prototype.getLayoutProperty = function(e3, i4) {
            var o2 = this.getLayer(e3);
            if (o2)
              return o2.getLayoutProperty(i4);
            this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style.")));
          }, i3.prototype.setPaintProperty = function(e3, i4, o2, r2) {
            void 0 === r2 && (r2 = {}), this._checkLoaded();
            var a2 = this.getLayer(e3);
            a2 ? t.deepEqual(a2.getPaintProperty(i4), o2) || (a2.setPaintProperty(i4, o2, r2) && this._updateLayer(a2), this._changed = true, this._updatedPaintProps[e3] = true) : this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be styled.")));
          }, i3.prototype.getPaintProperty = function(t4, e3) {
            return this.getLayer(t4).getPaintProperty(e3);
          }, i3.prototype.setFeatureState = function(e3, i4) {
            this._checkLoaded();
            var o2 = e3.source, r2 = e3.sourceLayer, a2 = this.sourceCaches[o2];
            if (void 0 !== a2) {
              var n2 = a2.getSource().type;
              "geojson" === n2 && r2 ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== n2 || r2 ? (void 0 === e3.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), a2.setFeatureState(r2, e3.id, i4)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else
              this.fire(new t.ErrorEvent(new Error("The source '" + o2 + "' does not exist in the map's style.")));
          }, i3.prototype.removeFeatureState = function(e3, i4) {
            this._checkLoaded();
            var o2 = e3.source, r2 = this.sourceCaches[o2];
            if (void 0 !== r2) {
              var a2 = r2.getSource().type, n2 = "vector" === a2 ? e3.sourceLayer : void 0;
              "vector" !== a2 || n2 ? i4 && "string" != typeof e3.id && "number" != typeof e3.id ? this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : r2.removeFeatureState(n2, e3.id, i4) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else
              this.fire(new t.ErrorEvent(new Error("The source '" + o2 + "' does not exist in the map's style.")));
          }, i3.prototype.getFeatureState = function(e3) {
            this._checkLoaded();
            var i4 = e3.source, o2 = e3.sourceLayer, r2 = this.sourceCaches[i4];
            if (void 0 !== r2) {
              if ("vector" !== r2.getSource().type || o2)
                return void 0 === e3.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), r2.getFeatureState(o2, e3.id);
              this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else
              this.fire(new t.ErrorEvent(new Error("The source '" + i4 + "' does not exist in the map's style.")));
          }, i3.prototype.getTransition = function() {
            return t.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }, i3.prototype.serialize = function() {
            return t.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: t.mapObject(this.sourceCaches, function(t4) {
              return t4.serialize();
            }), layers: this._serializeLayers(this._order) }, function(t4) {
              return void 0 !== t4;
            });
          }, i3.prototype._updateLayer = function(t4) {
            this._updatedLayers[t4.id] = true, t4.source && !this._updatedSources[t4.source] && "raster" !== this.sourceCaches[t4.source].getSource().type && (this._updatedSources[t4.source] = "reload", this.sourceCaches[t4.source].pause()), this._changed = true;
          }, i3.prototype._flattenAndSortRenderedFeatures = function(t4) {
            for (var e3 = this, i4 = function(t5) {
              return "fill-extrusion" === e3._layers[t5].type;
            }, o2 = {}, r2 = [], a2 = this._order.length - 1; a2 >= 0; a2--) {
              var n2 = this._order[a2];
              if (i4(n2)) {
                o2[n2] = a2;
                for (var s2 = 0, l2 = t4; s2 < l2.length; s2 += 1) {
                  var c2 = l2[s2][n2];
                  if (c2)
                    for (var u2 = 0, h2 = c2; u2 < h2.length; u2 += 1)
                      r2.push(h2[u2]);
                }
              }
            }
            r2.sort(function(t5, e4) {
              return e4.intersectionZ - t5.intersectionZ;
            });
            for (var p2 = [], d2 = this._order.length - 1; d2 >= 0; d2--) {
              var _2 = this._order[d2];
              if (i4(_2))
                for (var f2 = r2.length - 1; f2 >= 0; f2--) {
                  var m2 = r2[f2].feature;
                  if (o2[m2.layer.id] < d2)
                    break;
                  p2.push(m2), r2.pop();
                }
              else
                for (var g2 = 0, v2 = t4; g2 < v2.length; g2 += 1) {
                  var y2 = v2[g2][_2];
                  if (y2)
                    for (var x3 = 0, b2 = y2; x3 < b2.length; x3 += 1)
                      p2.push(b2[x3].feature);
                }
            }
            return p2;
          }, i3.prototype.queryRenderedFeatures = function(e3, i4, o2) {
            i4 && i4.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i4.filter, null, i4);
            var r2 = {};
            if (i4 && i4.layers) {
              if (!Array.isArray(i4.layers))
                return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
              for (var a2 = 0, n2 = i4.layers; a2 < n2.length; a2 += 1) {
                var s2 = n2[a2], l2 = this._layers[s2];
                if (!l2)
                  return this.fire(new t.ErrorEvent(new Error("The layer '" + s2 + "' does not exist in the map's style and cannot be queried for features."))), [];
                r2[l2.source] = true;
              }
            }
            var c2 = [];
            for (var u2 in i4.availableImages = this._availableImages, this.sourceCaches)
              i4.layers && !r2[u2] || c2.push(O(this.sourceCaches[u2], this._layers, this._serializedLayers, e3, i4, o2));
            return this.placement && c2.push(function(t4, e4, i5, o3, r3, a3, n3) {
              for (var s3 = {}, l3 = a3.queryRenderedSymbols(o3), c3 = [], u3 = 0, h2 = Object.keys(l3).map(Number); u3 < h2.length; u3 += 1)
                c3.push(n3[h2[u3]]);
              c3.sort(F);
              for (var p2 = function() {
                var i6 = _2[d2], o4 = i6.featureIndex.lookupSymbolFeatures(l3[i6.bucketInstanceId], e4, i6.bucketIndex, i6.sourceLayerIndex, r3.filter, r3.layers, r3.availableImages, t4);
                for (var a4 in o4) {
                  var n4 = s3[a4] = s3[a4] || [], c4 = o4[a4];
                  c4.sort(function(t5, e5) {
                    var o5 = i6.featureSortOrder;
                    if (o5) {
                      var r4 = o5.indexOf(t5.featureIndex);
                      return o5.indexOf(e5.featureIndex) - r4;
                    }
                    return e5.featureIndex - t5.featureIndex;
                  });
                  for (var u4 = 0, h3 = c4; u4 < h3.length; u4 += 1)
                    n4.push(h3[u4]);
                }
              }, d2 = 0, _2 = c3; d2 < _2.length; d2 += 1)
                p2();
              var f2 = function(e5) {
                s3[e5].forEach(function(o4) {
                  var r4 = o4.feature, a4 = i5[t4[e5].source].getFeatureState(r4.layer["source-layer"], r4.id);
                  r4.source = r4.layer.source, r4.layer["source-layer"] && (r4.sourceLayer = r4.layer["source-layer"]), r4.state = a4;
                });
              };
              for (var m2 in s3)
                f2(m2);
              return s3;
            }(this._layers, this._serializedLayers, this.sourceCaches, e3, i4, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(c2);
          }, i3.prototype.querySourceFeatures = function(e3, i4) {
            i4 && i4.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i4.filter, null, i4);
            var o2 = this.sourceCaches[e3];
            return o2 ? function(t4, e4) {
              for (var i5 = t4.getRenderableIds().map(function(e5) {
                return t4.getTileByID(e5);
              }), o3 = [], r2 = {}, a2 = 0; a2 < i5.length; a2++) {
                var n2 = i5[a2], s2 = n2.tileID.canonical.key;
                r2[s2] || (r2[s2] = true, n2.querySourceFeatures(o3, e4));
              }
              return o3;
            }(o2, i4) : [];
          }, i3.prototype.addSourceType = function(t4, e3, o2) {
            return i3.getSourceType(t4) ? o2(new Error('A source type called "' + t4 + '" already exists.')) : (i3.setSourceType(t4, e3), e3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t4, url: e3.workerSourceURL }, o2) : o2(null, null));
          }, i3.prototype.getLight = function() {
            return this.light.getLight();
          }, i3.prototype.setLight = function(e3, i4) {
            void 0 === i4 && (i4 = {}), this._checkLoaded();
            var o2 = this.light.getLight(), r2 = false;
            for (var a2 in e3)
              if (!t.deepEqual(e3[a2], o2[a2])) {
                r2 = true;
                break;
              }
            if (r2) {
              var n2 = { now: t.browser.now(), transition: t.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
              this.light.setLight(e3, i4), this.light.updateTransitions(n2);
            }
          }, i3.prototype._validate = function(e3, i4, o2, r2, a2) {
            return void 0 === a2 && (a2 = {}), (!a2 || false !== a2.validate) && Ue(this, e3.call(t.validateStyle, t.extend({ key: i4, style: this.serialize(), value: o2, styleSpec: t.styleSpec }, r2)));
          }, i3.prototype._remove = function() {
            for (var e3 in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers)
              this._layers[e3].setEventedParent(null);
            for (var i4 in this.sourceCaches)
              this.sourceCaches[i4].clearTiles(), this.sourceCaches[i4].setEventedParent(null);
            this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
          }, i3.prototype._clearSource = function(t4) {
            this.sourceCaches[t4].clearTiles();
          }, i3.prototype._reloadSource = function(t4) {
            this.sourceCaches[t4].resume(), this.sourceCaches[t4].reload();
          }, i3.prototype._updateSources = function(t4) {
            for (var e3 in this.sourceCaches)
              this.sourceCaches[e3].update(t4);
          }, i3.prototype._generateCollisionBoxes = function() {
            for (var t4 in this.sourceCaches)
              this._reloadSource(t4);
          }, i3.prototype._updatePlacement = function(e3, i4, o2, r2, a2) {
            void 0 === a2 && (a2 = false);
            for (var n2 = false, s2 = false, l2 = {}, c2 = 0, u2 = this._order; c2 < u2.length; c2 += 1) {
              var h2 = this._layers[u2[c2]];
              if ("symbol" === h2.type) {
                if (!l2[h2.source]) {
                  var p2 = this.sourceCaches[h2.source];
                  l2[h2.source] = p2.getRenderableIds(true).map(function(t4) {
                    return p2.getTileByID(t4);
                  }).sort(function(t4, e4) {
                    return e4.tileID.overscaledZ - t4.tileID.overscaledZ || (t4.tileID.isLessThan(e4.tileID) ? -1 : 1);
                  });
                }
                var d2 = this.crossTileSymbolIndex.addLayer(h2, l2[h2.source], e3.center.lng);
                n2 = n2 || d2;
              }
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a2 = a2 || this._layerOrderChanged || 0 === o2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.browser.now(), e3.zoom)) && (this.pauseablePlacement = new Le(e3, this._order, a2, i4, o2, r2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.browser.now()), s2 = true), n2 && this.pauseablePlacement.placement.setStale()), s2 || n2)
              for (var _2 = 0, f2 = this._order; _2 < f2.length; _2 += 1) {
                var m2 = this._layers[f2[_2]];
                "symbol" === m2.type && this.placement.updateLayerOpacities(m2, l2[m2.source]);
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.browser.now());
          }, i3.prototype._releaseSymbolFadeTiles = function() {
            for (var t4 in this.sourceCaches)
              this.sourceCaches[t4].releaseSymbolFadeTiles();
          }, i3.prototype.getImages = function(t4, e3, i4) {
            this.imageManager.getImages(e3.icons, i4), this._updateTilesForChangedImages();
            var o2 = this.sourceCaches[e3.source];
            o2 && o2.setDependencies(e3.tileID.key, e3.type, e3.icons);
          }, i3.prototype.getGlyphs = function(t4, e3, i4) {
            this.glyphManager.getGlyphs(e3.stacks, i4);
          }, i3.prototype.getResource = function(e3, i4, o2) {
            return t.makeRequest(i4, o2);
          }, i3;
        }(t.Evented);
        je.getSourceType = function(t4) {
          return k[t4];
        }, je.setSourceType = function(t4, e2) {
          k[t4] = e2;
        }, je.registerForPluginStateChange = t.registerForPluginStateChange;
        var Ve = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), Ge = gi("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"), We = gi("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Xe = gi("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), He = gi("varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), Ke = gi("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Ye = gi("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), Je = gi("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), Qe = gi("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), $e = gi("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), ti = gi("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"), ei = gi("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), ii = gi("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), oi = gi("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), ri = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), ai = gi("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), ni = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), si = gi("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), li = gi("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), ci = gi("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), ui = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), hi = gi("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), pi = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), di = gi("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), _i = gi("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"), fi = gi("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), mi = gi("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}");
        function gi(t4, e2) {
          var i3 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = e2.match(/attribute ([\w]+) ([\w]+)/g), r2 = t4.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), n2 = a2 ? a2.concat(r2) : r2, s2 = {};
          return { fragmentSource: t4 = t4.replace(i3, function(t5, e3, i4, o3, r3) {
            return s2[r3] = true, "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\nvarying " + i4 + " " + o3 + " " + r3 + ";\n#else\nuniform " + i4 + " " + o3 + " u_" + r3 + ";\n#endif\n" : "\n#ifdef HAS_UNIFORM_u_" + r3 + "\n    " + i4 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n";
          }), vertexSource: e2 = e2.replace(i3, function(t5, e3, i4, o3, r3) {
            var a3 = "float" === o3 ? "vec2" : "vec4", n3 = r3.match(/color/) ? "color" : a3;
            return s2[r3] ? "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\nuniform lowp float u_" + r3 + "_t;\nattribute " + i4 + " " + a3 + " a_" + r3 + ";\nvarying " + i4 + " " + o3 + " " + r3 + ";\n#else\nuniform " + i4 + " " + o3 + " u_" + r3 + ";\n#endif\n" : "vec4" === n3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\n    " + r3 + " = a_" + r3 + ";\n#else\n    " + i4 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + r3 + "\n    " + r3 + " = unpack_mix_" + n3 + "(a_" + r3 + ", u_" + r3 + "_t);\n#else\n    " + i4 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n" : "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\nuniform lowp float u_" + r3 + "_t;\nattribute " + i4 + " " + a3 + " a_" + r3 + ";\n#else\nuniform " + i4 + " " + o3 + " u_" + r3 + ";\n#endif\n" : "vec4" === n3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\n    " + i4 + " " + o3 + " " + r3 + " = a_" + r3 + ";\n#else\n    " + i4 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + r3 + "\n    " + i4 + " " + o3 + " " + r3 + " = unpack_mix_" + n3 + "(a_" + r3 + ", u_" + r3 + "_t);\n#else\n    " + i4 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n";
          }), staticAttributes: o2, staticUniforms: n2 };
        }
        var vi = Object.freeze({ __proto__: null, prelude: Ge, background: We, backgroundPattern: Xe, circle: He, clippingMask: Ke, heatmap: Ye, heatmapTexture: Je, collisionBox: Qe, collisionCircle: $e, debug: ti, fill: ei, fillOutline: ii, fillOutlinePattern: oi, fillPattern: ri, fillExtrusion: ai, fillExtrusionPattern: ni, hillshadePrepare: si, hillshade: li, line: ci, lineGradient: ui, linePattern: hi, lineSDF: pi, raster: di, symbolIcon: _i, symbolSDF: fi, symbolTextAndIcon: mi }), yi = function() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        };
        function xi(t4) {
          for (var e2 = [], i3 = 0; i3 < t4.length; i3++)
            if (null !== t4[i3]) {
              var o2 = t4[i3].split(" ");
              e2.push(o2.pop());
            }
          return e2;
        }
        yi.prototype.bind = function(t4, e2, i3, o2, r2, a2, n2, s2) {
          this.context = t4;
          for (var l2 = this.boundPaintVertexBuffers.length !== o2.length, c2 = 0; !l2 && c2 < o2.length; c2++)
            this.boundPaintVertexBuffers[c2] !== o2[c2] && (l2 = true);
          t4.extVertexArrayObject && this.vao && this.boundProgram === e2 && this.boundLayoutVertexBuffer === i3 && !l2 && this.boundIndexBuffer === r2 && this.boundVertexOffset === a2 && this.boundDynamicVertexBuffer === n2 && this.boundDynamicVertexBuffer2 === s2 ? (t4.bindVertexArrayOES.set(this.vao), n2 && n2.bind(), r2 && r2.dynamicDraw && r2.bind(), s2 && s2.bind()) : this.freshBind(e2, i3, o2, r2, a2, n2, s2);
        }, yi.prototype.freshBind = function(t4, e2, i3, o2, r2, a2, n2) {
          var s2, l2 = t4.numAttributes, c2 = this.context, u2 = c2.gl;
          if (c2.extVertexArrayObject)
            this.vao && this.destroy(), this.vao = c2.extVertexArrayObject.createVertexArrayOES(), c2.bindVertexArrayOES.set(this.vao), s2 = 0, this.boundProgram = t4, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i3, this.boundIndexBuffer = o2, this.boundVertexOffset = r2, this.boundDynamicVertexBuffer = a2, this.boundDynamicVertexBuffer2 = n2;
          else {
            s2 = c2.currentNumAttributes || 0;
            for (var h2 = l2; h2 < s2; h2++)
              u2.disableVertexAttribArray(h2);
          }
          e2.enableAttributes(u2, t4);
          for (var p2 = 0, d2 = i3; p2 < d2.length; p2 += 1)
            d2[p2].enableAttributes(u2, t4);
          a2 && a2.enableAttributes(u2, t4), n2 && n2.enableAttributes(u2, t4), e2.bind(), e2.setVertexAttribPointers(u2, t4, r2);
          for (var _2 = 0, f2 = i3; _2 < f2.length; _2 += 1) {
            var m2 = f2[_2];
            m2.bind(), m2.setVertexAttribPointers(u2, t4, r2);
          }
          a2 && (a2.bind(), a2.setVertexAttribPointers(u2, t4, r2)), o2 && o2.bind(), n2 && (n2.bind(), n2.setVertexAttribPointers(u2, t4, r2)), c2.currentNumAttributes = l2;
        }, yi.prototype.destroy = function() {
          this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
        };
        var bi = function(t4, e2, i3, o2, r2, a2) {
          var n2 = t4.gl;
          this.program = n2.createProgram();
          for (var s2 = xi(i3.staticAttributes), l2 = o2 ? o2.getBinderAttributes() : [], c2 = s2.concat(l2), u2 = i3.staticUniforms ? xi(i3.staticUniforms) : [], h2 = o2 ? o2.getBinderUniforms() : [], p2 = [], d2 = 0, _2 = u2.concat(h2); d2 < _2.length; d2 += 1) {
            var f2 = _2[d2];
            p2.indexOf(f2) < 0 && p2.push(f2);
          }
          var m2 = o2 ? o2.defines() : [];
          a2 && m2.push("#define OVERDRAW_INSPECTOR;");
          var g2 = m2.concat(Ge.fragmentSource, i3.fragmentSource).join("\n"), v2 = m2.concat(Ge.vertexSource, i3.vertexSource).join("\n"), y2 = n2.createShader(n2.FRAGMENT_SHADER);
          if (n2.isContextLost())
            this.failedToCreate = true;
          else {
            n2.shaderSource(y2, g2), n2.compileShader(y2), n2.attachShader(this.program, y2);
            var x3 = n2.createShader(n2.VERTEX_SHADER);
            if (n2.isContextLost())
              this.failedToCreate = true;
            else {
              n2.shaderSource(x3, v2), n2.compileShader(x3), n2.attachShader(this.program, x3), this.attributes = {};
              var b2 = {};
              this.numAttributes = c2.length;
              for (var w2 = 0; w2 < this.numAttributes; w2++)
                c2[w2] && (n2.bindAttribLocation(this.program, w2, c2[w2]), this.attributes[c2[w2]] = w2);
              n2.linkProgram(this.program), n2.deleteShader(x3), n2.deleteShader(y2);
              for (var T3 = 0; T3 < p2.length; T3++) {
                var E3 = p2[T3];
                if (E3 && !b2[E3]) {
                  var I2 = n2.getUniformLocation(this.program, E3);
                  I2 && (b2[E3] = I2);
                }
              }
              this.fixedUniforms = r2(t4, b2), this.binderUniforms = o2 ? o2.getUniforms(t4, b2) : [];
            }
          }
        };
        function wi(t4, e2, i3) {
          var o2 = 1 / pe(i3, 1, e2.transform.tileZoom), r2 = Math.pow(2, i3.tileID.overscaledZ), a2 = i3.tileSize * Math.pow(2, e2.transform.tileZoom) / r2, n2 = a2 * (i3.tileID.canonical.x + i3.tileID.wrap * r2), s2 = a2 * i3.tileID.canonical.y;
          return { u_image: 0, u_texsize: i3.imageAtlasTexture.size, u_scale: [o2, t4.fromScale, t4.toScale], u_fade: t4.t, u_pixel_coord_upper: [n2 >> 16, s2 >> 16], u_pixel_coord_lower: [65535 & n2, 65535 & s2] };
        }
        bi.prototype.draw = function(t4, e2, i3, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2, _2, f2) {
          var m2, g2 = t4.gl;
          if (!this.failedToCreate) {
            for (var v2 in t4.program.set(this.program), t4.setDepthMode(i3), t4.setStencilMode(o2), t4.setColorMode(r2), t4.setCullFace(a2), this.fixedUniforms)
              this.fixedUniforms[v2].set(n2[v2]);
            d2 && d2.setUniforms(t4, this.binderUniforms, h2, { zoom: p2 });
            for (var y2 = (m2 = {}, m2[g2.LINES] = 2, m2[g2.TRIANGLES] = 3, m2[g2.LINE_STRIP] = 1, m2)[e2], x3 = 0, b2 = u2.get(); x3 < b2.length; x3 += 1) {
              var w2 = b2[x3], T3 = w2.vaos || (w2.vaos = {});
              (T3[s2] || (T3[s2] = new yi())).bind(t4, this, l2, d2 ? d2.getPaintVertexBuffers() : [], c2, w2.vertexOffset, _2, f2), g2.drawElements(e2, w2.primitiveLength * y2, g2.UNSIGNED_SHORT, w2.primitiveOffset * y2 * 2);
            }
          }
        };
        var Ti = function(e2, i3, o2, r2) {
          var a2 = i3.style.light, n2 = a2.properties.get("position"), s2 = [n2.x, n2.y, n2.z], l2 = t.create$1();
          "viewport" === a2.properties.get("anchor") && t.fromRotation(l2, -i3.transform.angle), t.transformMat3(s2, s2, l2);
          var c2 = a2.properties.get("color");
          return { u_matrix: e2, u_lightpos: s2, u_lightintensity: a2.properties.get("intensity"), u_lightcolor: [c2.r, c2.g, c2.b], u_vertical_gradient: +o2, u_opacity: r2 };
        }, Ei = function(e2, i3, o2, r2, a2, n2, s2) {
          return t.extend(Ti(e2, i3, o2, r2), wi(n2, i3, s2), { u_height_factor: -Math.pow(2, a2.overscaledZ) / s2.tileSize / 8 });
        }, Ii = function(t4) {
          return { u_matrix: t4 };
        }, Pi = function(e2, i3, o2, r2) {
          return t.extend(Ii(e2), wi(o2, i3, r2));
        }, Si = function(t4, e2) {
          return { u_matrix: t4, u_world: e2 };
        }, Ci = function(e2, i3, o2, r2, a2) {
          return t.extend(Pi(e2, i3, o2, r2), { u_world: a2 });
        }, zi = function(e2, i3, o2, r2) {
          var a2, n2, s2 = e2.transform;
          if ("map" === r2.paint.get("circle-pitch-alignment")) {
            var l2 = pe(o2, 1, s2.zoom);
            a2 = true, n2 = [l2, l2];
          } else
            a2 = false, n2 = s2.pixelsToGLUnits;
          return { u_camera_to_center_distance: s2.cameraToCenterDistance, u_scale_with_map: +("map" === r2.paint.get("circle-pitch-scale")), u_matrix: e2.translatePosMatrix(i3.posMatrix, o2, r2.paint.get("circle-translate"), r2.paint.get("circle-translate-anchor")), u_pitch_with_map: +a2, u_device_pixel_ratio: t.browser.devicePixelRatio, u_extrude_scale: n2 };
        }, Di = function(t4, e2, i3) {
          var o2 = pe(i3, 1, e2.zoom), r2 = Math.pow(2, e2.zoom - i3.tileID.overscaledZ), a2 = i3.tileID.overscaleFactor();
          return { u_matrix: t4, u_camera_to_center_distance: e2.cameraToCenterDistance, u_pixels_to_tile_units: o2, u_extrude_scale: [e2.pixelsToGLUnits[0] / (o2 * r2), e2.pixelsToGLUnits[1] / (o2 * r2)], u_overscale_factor: a2 };
        }, Ai = function(t4, e2, i3) {
          return { u_matrix: t4, u_inv_matrix: e2, u_camera_to_center_distance: i3.cameraToCenterDistance, u_viewport_size: [i3.width, i3.height] };
        }, Mi = function(t4, e2, i3) {
          return void 0 === i3 && (i3 = 1), { u_matrix: t4, u_color: e2, u_overlay: 0, u_overlay_scale: i3 };
        }, Li = function(t4) {
          return { u_matrix: t4 };
        }, Ri = function(t4, e2, i3, o2) {
          return { u_matrix: t4, u_extrude_scale: pe(e2, 1, i3), u_intensity: o2 };
        }, ki = function(e2, i3, o2) {
          var r2 = e2.transform;
          return { u_matrix: Ni(e2, i3, o2), u_ratio: 1 / pe(i3, 1, r2.zoom), u_device_pixel_ratio: t.browser.devicePixelRatio, u_units_to_pixels: [1 / r2.pixelsToGLUnits[0], 1 / r2.pixelsToGLUnits[1]] };
        }, Bi = function(e2, i3, o2, r2) {
          return t.extend(ki(e2, i3, o2), { u_image: 0, u_image_height: r2 });
        }, Oi = function(e2, i3, o2, r2) {
          var a2 = e2.transform, n2 = Ui(i3, a2);
          return { u_matrix: Ni(e2, i3, o2), u_texsize: i3.imageAtlasTexture.size, u_ratio: 1 / pe(i3, 1, a2.zoom), u_device_pixel_ratio: t.browser.devicePixelRatio, u_image: 0, u_scale: [n2, r2.fromScale, r2.toScale], u_fade: r2.t, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
        }, Fi = function(e2, i3, o2, r2, a2) {
          var n2 = e2.lineAtlas, s2 = Ui(i3, e2.transform), l2 = "round" === o2.layout.get("line-cap"), c2 = n2.getDash(r2.from, l2), u2 = n2.getDash(r2.to, l2), h2 = c2.width * a2.fromScale, p2 = u2.width * a2.toScale;
          return t.extend(ki(e2, i3, o2), { u_patternscale_a: [s2 / h2, -c2.height / 2], u_patternscale_b: [s2 / p2, -u2.height / 2], u_sdfgamma: n2.width / (256 * Math.min(h2, p2) * t.browser.devicePixelRatio) / 2, u_image: 0, u_tex_y_a: c2.y, u_tex_y_b: u2.y, u_mix: a2.t });
        };
        function Ui(t4, e2) {
          return 1 / pe(t4, 1, e2.tileZoom);
        }
        function Ni(t4, e2, i3) {
          return t4.translatePosMatrix(e2.tileID.posMatrix, e2, i3.paint.get("line-translate"), i3.paint.get("line-translate-anchor"));
        }
        var Zi = function(t4, e2, i3, o2, r2) {
          return { u_matrix: t4, u_tl_parent: e2, u_scale_parent: i3, u_buffer_scale: 1, u_fade_t: o2.mix, u_opacity: o2.opacity * r2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r2.paint.get("raster-brightness-min"), u_brightness_high: r2.paint.get("raster-brightness-max"), u_saturation_factor: (n2 = r2.paint.get("raster-saturation"), n2 > 0 ? 1 - 1 / (1.001 - n2) : -n2), u_contrast_factor: (a2 = r2.paint.get("raster-contrast"), a2 > 0 ? 1 / (1 - a2) : 1 + a2), u_spin_weights: qi(r2.paint.get("raster-hue-rotate")) };
          var a2, n2;
        };
        function qi(t4) {
          t4 *= Math.PI / 180;
          var e2 = Math.sin(t4), i3 = Math.cos(t4);
          return [(2 * i3 + 1) / 3, (-Math.sqrt(3) * e2 - i3 + 1) / 3, (Math.sqrt(3) * e2 - i3 + 1) / 3];
        }
        var ji, Vi = function(t4, e2, i3, o2, r2, a2, n2, s2, l2, c2) {
          var u2 = r2.transform;
          return { u_is_size_zoom_constant: +("constant" === t4 || "source" === t4), u_is_size_feature_constant: +("constant" === t4 || "camera" === t4), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: u2.cameraToCenterDistance, u_pitch: u2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i3, u_aspect_ratio: u2.width / u2.height, u_fade_change: r2.options.fadeDuration ? r2.symbolFadeChange : 1, u_matrix: a2, u_label_plane_matrix: n2, u_coord_matrix: s2, u_is_text: +l2, u_pitch_with_map: +o2, u_texsize: c2, u_texture: 0 };
        }, Gi = function(e2, i3, o2, r2, a2, n2, s2, l2, c2, u2, h2) {
          var p2 = a2.transform;
          return t.extend(Vi(e2, i3, o2, r2, a2, n2, s2, l2, c2, u2), { u_gamma_scale: r2 ? Math.cos(p2._pitch) * p2.cameraToCenterDistance : 1, u_device_pixel_ratio: t.browser.devicePixelRatio, u_is_halo: +h2 });
        }, Wi = function(e2, i3, o2, r2, a2, n2, s2, l2, c2, u2) {
          return t.extend(Gi(e2, i3, o2, r2, a2, n2, s2, l2, true, c2, true), { u_texsize_icon: u2, u_texture_icon: 1 });
        }, Xi = function(t4, e2, i3) {
          return { u_matrix: t4, u_opacity: e2, u_color: i3 };
        }, Hi = function(e2, i3, o2, r2, a2, n2) {
          return t.extend(function(t4, e3, i4, o3) {
            var r3 = i4.imageManager.getPattern(t4.from.toString()), a3 = i4.imageManager.getPattern(t4.to.toString()), n3 = i4.imageManager.getPixelSize(), s2 = n3.width, l2 = n3.height, c2 = Math.pow(2, o3.tileID.overscaledZ), u2 = o3.tileSize * Math.pow(2, i4.transform.tileZoom) / c2, h2 = u2 * (o3.tileID.canonical.x + o3.tileID.wrap * c2), p2 = u2 * o3.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl_a: r3.tl, u_pattern_br_a: r3.br, u_pattern_tl_b: a3.tl, u_pattern_br_b: a3.br, u_texsize: [s2, l2], u_mix: e3.t, u_pattern_size_a: r3.displaySize, u_pattern_size_b: a3.displaySize, u_scale_a: e3.fromScale, u_scale_b: e3.toScale, u_tile_units_to_pixels: 1 / pe(o3, 1, i4.transform.tileZoom), u_pixel_coord_upper: [h2 >> 16, p2 >> 16], u_pixel_coord_lower: [65535 & h2, 65535 & p2] };
          }(r2, n2, o2, a2), { u_matrix: e2, u_opacity: i3 });
        }, Ki = { fillExtrusion: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_lightpos: new t.Uniform3f(e2, i3.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i3.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i3.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i3.u_vertical_gradient), u_opacity: new t.Uniform1f(e2, i3.u_opacity) };
        }, fillExtrusionPattern: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_lightpos: new t.Uniform3f(e2, i3.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i3.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i3.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i3.u_vertical_gradient), u_height_factor: new t.Uniform1f(e2, i3.u_height_factor), u_image: new t.Uniform1i(e2, i3.u_image), u_texsize: new t.Uniform2f(e2, i3.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i3.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i3.u_scale), u_fade: new t.Uniform1f(e2, i3.u_fade), u_opacity: new t.Uniform1f(e2, i3.u_opacity) };
        }, fill: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix) };
        }, fillPattern: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_image: new t.Uniform1i(e2, i3.u_image), u_texsize: new t.Uniform2f(e2, i3.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i3.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i3.u_scale), u_fade: new t.Uniform1f(e2, i3.u_fade) };
        }, fillOutline: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_world: new t.Uniform2f(e2, i3.u_world) };
        }, fillOutlinePattern: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_world: new t.Uniform2f(e2, i3.u_world), u_image: new t.Uniform1i(e2, i3.u_image), u_texsize: new t.Uniform2f(e2, i3.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i3.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i3.u_scale), u_fade: new t.Uniform1f(e2, i3.u_fade) };
        }, circle: function(e2, i3) {
          return { u_camera_to_center_distance: new t.Uniform1f(e2, i3.u_camera_to_center_distance), u_scale_with_map: new t.Uniform1i(e2, i3.u_scale_with_map), u_pitch_with_map: new t.Uniform1i(e2, i3.u_pitch_with_map), u_extrude_scale: new t.Uniform2f(e2, i3.u_extrude_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i3.u_device_pixel_ratio), u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix) };
        }, collisionBox: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i3.u_camera_to_center_distance), u_pixels_to_tile_units: new t.Uniform1f(e2, i3.u_pixels_to_tile_units), u_extrude_scale: new t.Uniform2f(e2, i3.u_extrude_scale), u_overscale_factor: new t.Uniform1f(e2, i3.u_overscale_factor) };
        }, collisionCircle: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_inv_matrix: new t.UniformMatrix4f(e2, i3.u_inv_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i3.u_camera_to_center_distance), u_viewport_size: new t.Uniform2f(e2, i3.u_viewport_size) };
        }, debug: function(e2, i3) {
          return { u_color: new t.UniformColor(e2, i3.u_color), u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_overlay: new t.Uniform1i(e2, i3.u_overlay), u_overlay_scale: new t.Uniform1f(e2, i3.u_overlay_scale) };
        }, clippingMask: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix) };
        }, heatmap: function(e2, i3) {
          return { u_extrude_scale: new t.Uniform1f(e2, i3.u_extrude_scale), u_intensity: new t.Uniform1f(e2, i3.u_intensity), u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix) };
        }, heatmapTexture: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_world: new t.Uniform2f(e2, i3.u_world), u_image: new t.Uniform1i(e2, i3.u_image), u_color_ramp: new t.Uniform1i(e2, i3.u_color_ramp), u_opacity: new t.Uniform1f(e2, i3.u_opacity) };
        }, hillshade: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_image: new t.Uniform1i(e2, i3.u_image), u_latrange: new t.Uniform2f(e2, i3.u_latrange), u_light: new t.Uniform2f(e2, i3.u_light), u_shadow: new t.UniformColor(e2, i3.u_shadow), u_highlight: new t.UniformColor(e2, i3.u_highlight), u_accent: new t.UniformColor(e2, i3.u_accent) };
        }, hillshadePrepare: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_image: new t.Uniform1i(e2, i3.u_image), u_dimension: new t.Uniform2f(e2, i3.u_dimension), u_zoom: new t.Uniform1f(e2, i3.u_zoom), u_unpack: new t.Uniform4f(e2, i3.u_unpack) };
        }, line: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_ratio: new t.Uniform1f(e2, i3.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i3.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i3.u_units_to_pixels) };
        }, lineGradient: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_ratio: new t.Uniform1f(e2, i3.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i3.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i3.u_units_to_pixels), u_image: new t.Uniform1i(e2, i3.u_image), u_image_height: new t.Uniform1f(e2, i3.u_image_height) };
        }, linePattern: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_texsize: new t.Uniform2f(e2, i3.u_texsize), u_ratio: new t.Uniform1f(e2, i3.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i3.u_device_pixel_ratio), u_image: new t.Uniform1i(e2, i3.u_image), u_units_to_pixels: new t.Uniform2f(e2, i3.u_units_to_pixels), u_scale: new t.Uniform3f(e2, i3.u_scale), u_fade: new t.Uniform1f(e2, i3.u_fade) };
        }, lineSDF: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_ratio: new t.Uniform1f(e2, i3.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i3.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i3.u_units_to_pixels), u_patternscale_a: new t.Uniform2f(e2, i3.u_patternscale_a), u_patternscale_b: new t.Uniform2f(e2, i3.u_patternscale_b), u_sdfgamma: new t.Uniform1f(e2, i3.u_sdfgamma), u_image: new t.Uniform1i(e2, i3.u_image), u_tex_y_a: new t.Uniform1f(e2, i3.u_tex_y_a), u_tex_y_b: new t.Uniform1f(e2, i3.u_tex_y_b), u_mix: new t.Uniform1f(e2, i3.u_mix) };
        }, raster: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_tl_parent: new t.Uniform2f(e2, i3.u_tl_parent), u_scale_parent: new t.Uniform1f(e2, i3.u_scale_parent), u_buffer_scale: new t.Uniform1f(e2, i3.u_buffer_scale), u_fade_t: new t.Uniform1f(e2, i3.u_fade_t), u_opacity: new t.Uniform1f(e2, i3.u_opacity), u_image0: new t.Uniform1i(e2, i3.u_image0), u_image1: new t.Uniform1i(e2, i3.u_image1), u_brightness_low: new t.Uniform1f(e2, i3.u_brightness_low), u_brightness_high: new t.Uniform1f(e2, i3.u_brightness_high), u_saturation_factor: new t.Uniform1f(e2, i3.u_saturation_factor), u_contrast_factor: new t.Uniform1f(e2, i3.u_contrast_factor), u_spin_weights: new t.Uniform3f(e2, i3.u_spin_weights) };
        }, symbolIcon: function(e2, i3) {
          return { u_is_size_zoom_constant: new t.Uniform1i(e2, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i3.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i3.u_size_t), u_size: new t.Uniform1f(e2, i3.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i3.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i3.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i3.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i3.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i3.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i3.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i3.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i3.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i3.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i3.u_texsize), u_texture: new t.Uniform1i(e2, i3.u_texture) };
        }, symbolSDF: function(e2, i3) {
          return { u_is_size_zoom_constant: new t.Uniform1i(e2, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i3.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i3.u_size_t), u_size: new t.Uniform1f(e2, i3.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i3.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i3.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i3.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i3.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i3.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i3.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i3.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i3.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i3.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i3.u_texsize), u_texture: new t.Uniform1i(e2, i3.u_texture), u_gamma_scale: new t.Uniform1f(e2, i3.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i3.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e2, i3.u_is_halo) };
        }, symbolTextAndIcon: function(e2, i3) {
          return { u_is_size_zoom_constant: new t.Uniform1i(e2, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i3.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i3.u_size_t), u_size: new t.Uniform1f(e2, i3.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i3.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i3.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i3.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i3.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i3.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i3.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i3.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i3.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i3.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i3.u_texsize), u_texsize_icon: new t.Uniform2f(e2, i3.u_texsize_icon), u_texture: new t.Uniform1i(e2, i3.u_texture), u_texture_icon: new t.Uniform1i(e2, i3.u_texture_icon), u_gamma_scale: new t.Uniform1f(e2, i3.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i3.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e2, i3.u_is_halo) };
        }, background: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_opacity: new t.Uniform1f(e2, i3.u_opacity), u_color: new t.UniformColor(e2, i3.u_color) };
        }, backgroundPattern: function(e2, i3) {
          return { u_matrix: new t.UniformMatrix4f(e2, i3.u_matrix), u_opacity: new t.Uniform1f(e2, i3.u_opacity), u_image: new t.Uniform1i(e2, i3.u_image), u_pattern_tl_a: new t.Uniform2f(e2, i3.u_pattern_tl_a), u_pattern_br_a: new t.Uniform2f(e2, i3.u_pattern_br_a), u_pattern_tl_b: new t.Uniform2f(e2, i3.u_pattern_tl_b), u_pattern_br_b: new t.Uniform2f(e2, i3.u_pattern_br_b), u_texsize: new t.Uniform2f(e2, i3.u_texsize), u_mix: new t.Uniform1f(e2, i3.u_mix), u_pattern_size_a: new t.Uniform2f(e2, i3.u_pattern_size_a), u_pattern_size_b: new t.Uniform2f(e2, i3.u_pattern_size_b), u_scale_a: new t.Uniform1f(e2, i3.u_scale_a), u_scale_b: new t.Uniform1f(e2, i3.u_scale_b), u_pixel_coord_upper: new t.Uniform2f(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i3.u_pixel_coord_lower), u_tile_units_to_pixels: new t.Uniform1f(e2, i3.u_tile_units_to_pixels) };
        } };
        function Yi(e2, i3, o2, r2, a2, n2, s2) {
          for (var l2 = e2.context, c2 = l2.gl, u2 = e2.useProgram("collisionBox"), h2 = [], p2 = 0, d2 = 0, _2 = 0; _2 < r2.length; _2++) {
            var f2 = r2[_2], m2 = i3.getTile(f2), g2 = m2.getBucket(o2);
            if (g2) {
              var v2 = f2.posMatrix;
              0 === a2[0] && 0 === a2[1] || (v2 = e2.translatePosMatrix(f2.posMatrix, m2, a2, n2));
              var y2 = s2 ? g2.textCollisionBox : g2.iconCollisionBox, x3 = g2.collisionCircleArray;
              if (x3.length > 0) {
                var b2 = t.create(), w2 = v2;
                t.mul(b2, g2.placementInvProjMatrix, e2.transform.glCoordMatrix), t.mul(b2, b2, g2.placementViewportMatrix), h2.push({ circleArray: x3, circleOffset: d2, transform: w2, invTransform: b2 }), d2 = p2 += x3.length / 4;
              }
              y2 && u2.draw(l2, c2.LINES, It.disabled, Pt.disabled, e2.colorModeForRenderPass(), Ct.disabled, Di(v2, e2.transform, m2), o2.id, y2.layoutVertexBuffer, y2.indexBuffer, y2.segments, null, e2.transform.zoom, null, null, y2.collisionVertexBuffer);
            }
          }
          if (s2 && h2.length) {
            var T3 = e2.useProgram("collisionCircle"), E3 = new t.StructArrayLayout2f1f2i16();
            E3.resize(4 * p2), E3._trim();
            for (var I2 = 0, P2 = 0, S2 = h2; P2 < S2.length; P2 += 1)
              for (var C3 = S2[P2], z2 = 0; z2 < C3.circleArray.length / 4; z2++) {
                var D3 = 4 * z2, A3 = C3.circleArray[D3 + 0], M2 = C3.circleArray[D3 + 1], L3 = C3.circleArray[D3 + 2], R2 = C3.circleArray[D3 + 3];
                E3.emplace(I2++, A3, M2, L3, R2, 0), E3.emplace(I2++, A3, M2, L3, R2, 1), E3.emplace(I2++, A3, M2, L3, R2, 2), E3.emplace(I2++, A3, M2, L3, R2, 3);
              }
            (!ji || ji.length < 2 * p2) && (ji = function(e3) {
              var i4 = 2 * e3, o3 = new t.StructArrayLayout3ui6();
              o3.resize(i4), o3._trim();
              for (var r3 = 0; r3 < i4; r3++) {
                var a3 = 6 * r3;
                o3.uint16[a3 + 0] = 4 * r3 + 0, o3.uint16[a3 + 1] = 4 * r3 + 1, o3.uint16[a3 + 2] = 4 * r3 + 2, o3.uint16[a3 + 3] = 4 * r3 + 2, o3.uint16[a3 + 4] = 4 * r3 + 3, o3.uint16[a3 + 5] = 4 * r3 + 0;
              }
              return o3;
            }(p2));
            for (var k2 = l2.createIndexBuffer(ji, true), B3 = l2.createVertexBuffer(E3, t.collisionCircleLayout.members, true), O2 = 0, F2 = h2; O2 < F2.length; O2 += 1) {
              var U2 = F2[O2], N2 = Ai(U2.transform, U2.invTransform, e2.transform);
              T3.draw(l2, c2.TRIANGLES, It.disabled, Pt.disabled, e2.colorModeForRenderPass(), Ct.disabled, N2, o2.id, B3, k2, t.SegmentVector.simpleSegment(0, 2 * U2.circleOffset, U2.circleArray.length, U2.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
            }
            B3.destroy(), k2.destroy();
          }
        }
        var Ji = t.identity(new Float32Array(16));
        function Qi(e2, i3, o2, r2, a2, n2) {
          var s2 = t.getAnchorAlignment(e2), l2 = -(s2.horizontalAlign - 0.5) * i3, c2 = -(s2.verticalAlign - 0.5) * o2, u2 = t.evaluateVariableOffset(e2, r2);
          return new t.Point((l2 / a2 + u2[0]) * n2, (c2 / a2 + u2[1]) * n2);
        }
        function $i(e2, i3, o2, r2, a2, n2, s2, l2, c2, u2, h2) {
          var p2 = e2.text.placedSymbolArray, d2 = e2.text.dynamicLayoutVertexArray, _2 = e2.icon.dynamicLayoutVertexArray, f2 = {};
          d2.clear();
          for (var m2 = 0; m2 < p2.length; m2++) {
            var g2 = p2.get(m2), v2 = g2.hidden || !g2.crossTileID || e2.allowVerticalPlacement && !g2.placedOrientation ? null : r2[g2.crossTileID];
            if (v2) {
              var y2 = new t.Point(g2.anchorX, g2.anchorY), x3 = $t(y2, o2 ? l2 : s2), b2 = te(n2.cameraToCenterDistance, x3.signedDistanceFromCamera), w2 = a2.evaluateSizeForFeature(e2.textSizeData, u2, g2) * b2 / t.ONE_EM;
              o2 && (w2 *= e2.tilePixelRatio / c2);
              for (var T3 = Qi(v2.anchor, v2.width, v2.height, v2.textOffset, v2.textBoxScale, w2), E3 = o2 ? $t(y2.add(T3), s2).point : x3.point.add(i3 ? T3.rotate(-n2.angle) : T3), I2 = e2.allowVerticalPlacement && g2.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0, P2 = 0; P2 < g2.numGlyphs; P2++)
                t.addDynamicAttributes(d2, E3, I2);
              h2 && g2.associatedIconIndex >= 0 && (f2[g2.associatedIconIndex] = { shiftedAnchor: E3, angle: I2 });
            } else
              ce(g2.numGlyphs, d2);
          }
          if (h2) {
            _2.clear();
            for (var S2 = e2.icon.placedSymbolArray, C3 = 0; C3 < S2.length; C3++) {
              var z2 = S2.get(C3);
              if (z2.hidden)
                ce(z2.numGlyphs, _2);
              else {
                var D3 = f2[C3];
                if (D3)
                  for (var A3 = 0; A3 < z2.numGlyphs; A3++)
                    t.addDynamicAttributes(_2, D3.shiftedAnchor, D3.angle);
                else
                  ce(z2.numGlyphs, _2);
              }
            }
            e2.icon.dynamicLayoutVertexBuffer.updateData(_2);
          }
          e2.text.dynamicLayoutVertexBuffer.updateData(d2);
        }
        function to(t4, e2, i3) {
          return i3.iconsInText && e2 ? "symbolTextAndIcon" : t4 ? "symbolSDF" : "symbolIcon";
        }
        function eo(e2, i3, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2) {
          for (var d2 = e2.context, _2 = d2.gl, f2 = e2.transform, m2 = "map" === l2, g2 = "map" === c2, v2 = m2 && "point" !== o2.layout.get("symbol-placement"), y2 = m2 && !g2 && !v2, x3 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1), b2 = false, w2 = e2.depthModeForSublayer(0, It.ReadOnly), T3 = o2.layout.get("text-variable-anchor"), E3 = [], I2 = 0, P2 = r2; I2 < P2.length; I2 += 1) {
            var S2 = P2[I2], C3 = i3.getTile(S2), z2 = C3.getBucket(o2);
            if (z2) {
              var D3 = a2 ? z2.text : z2.icon;
              if (D3 && D3.segments.get().length) {
                var A3 = D3.programConfigurations.get(o2.id), M2 = a2 || z2.sdfIcons, L3 = a2 ? z2.textSizeData : z2.iconSizeData, R2 = g2 || 0 !== f2.pitch, k2 = e2.useProgram(to(M2, a2, z2), A3), B3 = t.evaluateSizeForZoom(L3, f2.zoom), O2 = void 0, F2 = [0, 0], U2 = void 0, N2 = void 0, Z2 = null, q2 = void 0;
                if (a2)
                  U2 = C3.glyphAtlasTexture, N2 = _2.LINEAR, O2 = C3.glyphAtlasTexture.size, z2.iconsInText && (F2 = C3.imageAtlasTexture.size, Z2 = C3.imageAtlasTexture, q2 = R2 || e2.options.rotating || e2.options.zooming || "composite" === L3.kind || "camera" === L3.kind ? _2.LINEAR : _2.NEAREST);
                else {
                  var j2 = 1 !== o2.layout.get("icon-size").constantOr(0) || z2.iconsNeedLinear;
                  U2 = C3.imageAtlasTexture, N2 = M2 || e2.options.rotating || e2.options.zooming || j2 || R2 ? _2.LINEAR : _2.NEAREST, O2 = C3.imageAtlasTexture.size;
                }
                var V2 = pe(C3, 1, e2.transform.zoom), G2 = Jt(S2.posMatrix, g2, m2, e2.transform, V2), W2 = Qt(S2.posMatrix, g2, m2, e2.transform, V2), X2 = T3 && z2.hasTextData(), H2 = "none" !== o2.layout.get("icon-text-fit") && X2 && z2.hasIconData();
                v2 && ie(z2, S2.posMatrix, e2, a2, G2, W2, g2, u2);
                var K3 = e2.translatePosMatrix(S2.posMatrix, C3, n2, s2), Y2 = v2 || a2 && T3 || H2 ? Ji : G2, J2 = e2.translatePosMatrix(W2, C3, n2, s2, true), Q2 = M2 && 0 !== o2.paint.get(a2 ? "text-halo-width" : "icon-halo-width").constantOr(1), $2 = { program: k2, buffers: D3, uniformValues: M2 ? z2.iconsInText ? Wi(L3.kind, B3, y2, g2, e2, K3, Y2, J2, O2, F2) : Gi(L3.kind, B3, y2, g2, e2, K3, Y2, J2, a2, O2, true) : Vi(L3.kind, B3, y2, g2, e2, K3, Y2, J2, a2, O2), atlasTexture: U2, atlasTextureIcon: Z2, atlasInterpolation: N2, atlasInterpolationIcon: q2, isSDF: M2, hasHalo: Q2 };
                if (x3 && z2.canOverlap) {
                  b2 = true;
                  for (var tt2 = 0, et3 = D3.segments.get(); tt2 < et3.length; tt2 += 1) {
                    var it2 = et3[tt2];
                    E3.push({ segments: new t.SegmentVector([it2]), sortKey: it2.sortKey, state: $2 });
                  }
                } else
                  E3.push({ segments: D3.segments, sortKey: 0, state: $2 });
              }
            }
          }
          b2 && E3.sort(function(t4, e3) {
            return t4.sortKey - e3.sortKey;
          });
          for (var ot2 = 0, rt2 = E3; ot2 < rt2.length; ot2 += 1) {
            var at2 = rt2[ot2], nt2 = at2.state;
            if (d2.activeTexture.set(_2.TEXTURE0), nt2.atlasTexture.bind(nt2.atlasInterpolation, _2.CLAMP_TO_EDGE), nt2.atlasTextureIcon && (d2.activeTexture.set(_2.TEXTURE1), nt2.atlasTextureIcon && nt2.atlasTextureIcon.bind(nt2.atlasInterpolationIcon, _2.CLAMP_TO_EDGE)), nt2.isSDF) {
              var st2 = nt2.uniformValues;
              nt2.hasHalo && (st2.u_is_halo = 1, io(nt2.buffers, at2.segments, o2, e2, nt2.program, w2, h2, p2, st2)), st2.u_is_halo = 0;
            }
            io(nt2.buffers, at2.segments, o2, e2, nt2.program, w2, h2, p2, nt2.uniformValues);
          }
        }
        function io(t4, e2, i3, o2, r2, a2, n2, s2, l2) {
          var c2 = o2.context;
          r2.draw(c2, c2.gl.TRIANGLES, a2, n2, s2, Ct.disabled, l2, i3.id, t4.layoutVertexBuffer, t4.indexBuffer, e2, i3.paint, o2.transform.zoom, t4.programConfigurations.get(i3.id), t4.dynamicLayoutVertexBuffer, t4.opacityVertexBuffer);
        }
        function oo(t4, e2, i3, o2, r2, a2, n2) {
          var s2, l2, c2, u2, h2, p2 = t4.context.gl, d2 = i3.paint.get("fill-pattern"), _2 = d2 && d2.constantOr(1), f2 = i3.getCrossfadeParameters();
          n2 ? (l2 = _2 && !i3.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", s2 = p2.LINES) : (l2 = _2 ? "fillPattern" : "fill", s2 = p2.TRIANGLES);
          for (var m2 = 0, g2 = o2; m2 < g2.length; m2 += 1) {
            var v2 = g2[m2], y2 = e2.getTile(v2);
            if (!_2 || y2.patternsLoaded()) {
              var x3 = y2.getBucket(i3);
              if (x3) {
                var b2 = x3.programConfigurations.get(i3.id), w2 = t4.useProgram(l2, b2);
                _2 && (t4.context.activeTexture.set(p2.TEXTURE0), y2.imageAtlasTexture.bind(p2.LINEAR, p2.CLAMP_TO_EDGE), b2.updatePaintBuffers(f2));
                var T3 = d2.constantOr(null);
                if (T3 && y2.imageAtlas) {
                  var E3 = y2.imageAtlas, I2 = E3.patternPositions[T3.to.toString()], P2 = E3.patternPositions[T3.from.toString()];
                  I2 && P2 && b2.setConstantPatternPositions(I2, P2);
                }
                var S2 = t4.translatePosMatrix(v2.posMatrix, y2, i3.paint.get("fill-translate"), i3.paint.get("fill-translate-anchor"));
                if (n2) {
                  u2 = x3.indexBuffer2, h2 = x3.segments2;
                  var C3 = [p2.drawingBufferWidth, p2.drawingBufferHeight];
                  c2 = "fillOutlinePattern" === l2 && _2 ? Ci(S2, t4, f2, y2, C3) : Si(S2, C3);
                } else
                  u2 = x3.indexBuffer, h2 = x3.segments, c2 = _2 ? Pi(S2, t4, f2, y2) : Ii(S2);
                w2.draw(t4.context, s2, r2, t4.stencilModeForClipping(v2), a2, Ct.disabled, c2, i3.id, x3.layoutVertexBuffer, u2, h2, i3.paint, t4.transform.zoom, b2);
              }
            }
          }
        }
        function ro(t4, e2, i3, o2, r2, a2, n2) {
          for (var s2 = t4.context, l2 = s2.gl, c2 = i3.paint.get("fill-extrusion-pattern"), u2 = c2.constantOr(1), h2 = i3.getCrossfadeParameters(), p2 = i3.paint.get("fill-extrusion-opacity"), d2 = 0, _2 = o2; d2 < _2.length; d2 += 1) {
            var f2 = _2[d2], m2 = e2.getTile(f2), g2 = m2.getBucket(i3);
            if (g2) {
              var v2 = g2.programConfigurations.get(i3.id), y2 = t4.useProgram(u2 ? "fillExtrusionPattern" : "fillExtrusion", v2);
              u2 && (t4.context.activeTexture.set(l2.TEXTURE0), m2.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), v2.updatePaintBuffers(h2));
              var x3 = c2.constantOr(null);
              if (x3 && m2.imageAtlas) {
                var b2 = m2.imageAtlas, w2 = b2.patternPositions[x3.to.toString()], T3 = b2.patternPositions[x3.from.toString()];
                w2 && T3 && v2.setConstantPatternPositions(w2, T3);
              }
              var E3 = t4.translatePosMatrix(f2.posMatrix, m2, i3.paint.get("fill-extrusion-translate"), i3.paint.get("fill-extrusion-translate-anchor")), I2 = i3.paint.get("fill-extrusion-vertical-gradient"), P2 = u2 ? Ei(E3, t4, I2, p2, f2, h2, m2) : Ti(E3, t4, I2, p2);
              y2.draw(s2, s2.gl.TRIANGLES, r2, a2, n2, Ct.backCCW, P2, i3.id, g2.layoutVertexBuffer, g2.indexBuffer, g2.segments, i3.paint, t4.transform.zoom, v2);
            }
          }
        }
        function ao(e2, i3, o2, r2, a2, n2) {
          var s2 = e2.context, l2 = s2.gl, c2 = i3.fbo;
          if (c2) {
            var u2 = e2.useProgram("hillshade");
            s2.activeTexture.set(l2.TEXTURE0), l2.bindTexture(l2.TEXTURE_2D, c2.colorAttachment.get());
            var h2 = function(e3, i4, o3) {
              var r3 = o3.paint.get("hillshade-shadow-color"), a3 = o3.paint.get("hillshade-highlight-color"), n3 = o3.paint.get("hillshade-accent-color"), s3 = o3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
              "viewport" === o3.paint.get("hillshade-illumination-anchor") && (s3 -= e3.transform.angle);
              var l3, c3, u3, h3 = !e3.options.moving;
              return { u_matrix: e3.transform.calculatePosMatrix(i4.tileID.toUnwrapped(), h3), u_image: 0, u_latrange: (l3 = i4.tileID, c3 = Math.pow(2, l3.canonical.z), u3 = l3.canonical.y, [new t.MercatorCoordinate(0, u3 / c3).toLngLat().lat, new t.MercatorCoordinate(0, (u3 + 1) / c3).toLngLat().lat]), u_light: [o3.paint.get("hillshade-exaggeration"), s3], u_shadow: r3, u_highlight: a3, u_accent: n3 };
            }(e2, i3, o2);
            u2.draw(s2, l2.TRIANGLES, r2, a2, n2, Ct.disabled, h2, o2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments);
          }
        }
        function no(e2, i3, o2, r2, a2, n2) {
          var s2 = e2.context, l2 = s2.gl, c2 = i3.dem;
          if (c2 && c2.data) {
            var u2 = c2.dim, h2 = c2.stride, p2 = c2.getPixels();
            if (s2.activeTexture.set(l2.TEXTURE1), s2.pixelStoreUnpackPremultiplyAlpha.set(false), i3.demTexture = i3.demTexture || e2.getTileTexture(h2), i3.demTexture) {
              var d2 = i3.demTexture;
              d2.update(p2, { premultiply: false }), d2.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
            } else
              i3.demTexture = new t.Texture(s2, p2, l2.RGBA, { premultiply: false }), i3.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
            s2.activeTexture.set(l2.TEXTURE0);
            var _2 = i3.fbo;
            if (!_2) {
              var f2 = new t.Texture(s2, { width: u2, height: u2, data: null }, l2.RGBA);
              f2.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), (_2 = i3.fbo = s2.createFramebuffer(u2, u2, true)).colorAttachment.set(f2.texture);
            }
            s2.bindFramebuffer.set(_2.framebuffer), s2.viewport.set([0, 0, u2, u2]), e2.useProgram("hillshadePrepare").draw(s2, l2.TRIANGLES, r2, a2, n2, Ct.disabled, function(e3, i4) {
              var o3 = i4.stride, r3 = t.create();
              return t.ortho(r3, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(r3, r3, [0, -t.EXTENT, 0]), { u_matrix: r3, u_image: 1, u_dimension: [o3, o3], u_zoom: e3.overscaledZ, u_unpack: i4.getUnpackVector() };
            }(i3.tileID, c2), o2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments), i3.needsHillshadePrepare = false;
          }
        }
        function so(e2, i3, o2, r2, a2) {
          var n2 = r2.paint.get("raster-fade-duration");
          if (n2 > 0) {
            var s2 = t.browser.now(), l2 = (s2 - e2.timeAdded) / n2, c2 = i3 ? (s2 - i3.timeAdded) / n2 : -1, u2 = o2.getSource(), h2 = a2.coveringZoomLevel({ tileSize: u2.tileSize, roundZoom: u2.roundZoom }), p2 = !i3 || Math.abs(i3.tileID.overscaledZ - h2) > Math.abs(e2.tileID.overscaledZ - h2), d2 = p2 && e2.refreshedUponExpiration ? 1 : t.clamp(p2 ? l2 : 1 - c2, 0, 1);
            return e2.refreshedUponExpiration && l2 >= 1 && (e2.refreshedUponExpiration = false), i3 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        var lo = new t.Color(1, 0, 0, 1), co = new t.Color(0, 1, 0, 1), uo = new t.Color(0, 0, 1, 1), ho = new t.Color(1, 0, 1, 1), po = new t.Color(0, 1, 1, 1);
        function _o(t4, e2, i3, o2) {
          mo(t4, 0, e2 + i3 / 2, t4.transform.width, i3, o2);
        }
        function fo(t4, e2, i3, o2) {
          mo(t4, e2 - i3 / 2, 0, i3, t4.transform.height, o2);
        }
        function mo(e2, i3, o2, r2, a2, n2) {
          var s2 = e2.context, l2 = s2.gl;
          l2.enable(l2.SCISSOR_TEST), l2.scissor(i3 * t.browser.devicePixelRatio, o2 * t.browser.devicePixelRatio, r2 * t.browser.devicePixelRatio, a2 * t.browser.devicePixelRatio), s2.clear({ color: n2 }), l2.disable(l2.SCISSOR_TEST);
        }
        function go(e2, i3, o2) {
          var r2 = e2.context, a2 = r2.gl, n2 = o2.posMatrix, s2 = e2.useProgram("debug"), l2 = It.disabled, c2 = Pt.disabled, u2 = e2.colorModeForRenderPass();
          r2.activeTexture.set(a2.TEXTURE0), e2.emptyTexture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE), s2.draw(r2, a2.LINE_STRIP, l2, c2, u2, Ct.disabled, Mi(n2, t.Color.red), "$debug", e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
          var h2 = i3.getTileByID(o2.key).latestRawTileData, p2 = Math.floor((h2 && h2.byteLength || 0) / 1024), d2 = i3.getTile(o2).tileSize, _2 = 512 / Math.min(d2, 512) * (o2.overscaledZ / e2.transform.zoom) * 0.5, f2 = o2.canonical.toString();
          o2.overscaledZ !== o2.canonical.z && (f2 += " => " + o2.overscaledZ), function(t4, e3) {
            t4.initDebugOverlayCanvas();
            var i4 = t4.debugOverlayCanvas, o3 = t4.context.gl, r3 = t4.debugOverlayCanvas.getContext("2d");
            r3.clearRect(0, 0, i4.width, i4.height), r3.shadowColor = "white", r3.shadowBlur = 2, r3.lineWidth = 1.5, r3.strokeStyle = "white", r3.textBaseline = "top", r3.font = "bold 36px Open Sans, sans-serif", r3.fillText(e3, 5, 5), r3.strokeText(e3, 5, 5), t4.debugOverlayTexture.update(i4), t4.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
          }(e2, f2 + " " + p2 + "kb"), s2.draw(r2, a2.TRIANGLES, l2, c2, St.alphaBlended, Ct.disabled, Mi(n2, t.Color.transparent, _2), "$debug", e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments);
        }
        var vo = { symbol: function(e2, i3, o2, r2, a2) {
          if ("translucent" === e2.renderPass) {
            var n2 = Pt.disabled, s2 = e2.colorModeForRenderPass();
            o2.layout.get("text-variable-anchor") && function(e3, i4, o3, r3, a3, n3, s3) {
              for (var l2 = i4.transform, c2 = "map" === a3, u2 = "map" === n3, h2 = 0, p2 = e3; h2 < p2.length; h2 += 1) {
                var d2 = p2[h2], _2 = r3.getTile(d2), f2 = _2.getBucket(o3);
                if (f2 && f2.text && f2.text.segments.get().length) {
                  var m2 = t.evaluateSizeForZoom(f2.textSizeData, l2.zoom), g2 = pe(_2, 1, i4.transform.zoom), v2 = Jt(d2.posMatrix, u2, c2, i4.transform, g2), y2 = "none" !== o3.layout.get("icon-text-fit") && f2.hasIconData();
                  if (m2) {
                    var x3 = Math.pow(2, l2.zoom - _2.tileID.overscaledZ);
                    $i(f2, c2, u2, s3, t.symbolSize, l2, v2, d2.posMatrix, x3, m2, y2);
                  }
                }
              }
            }(r2, e2, o2, i3, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), a2), 0 !== o2.paint.get("icon-opacity").constantOr(1) && eo(e2, i3, o2, r2, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), n2, s2), 0 !== o2.paint.get("text-opacity").constantOr(1) && eo(e2, i3, o2, r2, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), n2, s2), i3.map.showCollisionBoxes && (Yi(e2, i3, o2, r2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), Yi(e2, i3, o2, r2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
          }
        }, circle: function(e2, i3, o2, r2) {
          if ("translucent" === e2.renderPass) {
            var a2 = o2.paint.get("circle-opacity"), n2 = o2.paint.get("circle-stroke-width"), s2 = o2.paint.get("circle-stroke-opacity"), l2 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1);
            if (0 !== a2.constantOr(1) || 0 !== n2.constantOr(1) && 0 !== s2.constantOr(1)) {
              for (var c2 = e2.context, u2 = c2.gl, h2 = e2.depthModeForSublayer(0, It.ReadOnly), p2 = Pt.disabled, d2 = e2.colorModeForRenderPass(), _2 = [], f2 = 0; f2 < r2.length; f2++) {
                var m2 = r2[f2], g2 = i3.getTile(m2), v2 = g2.getBucket(o2);
                if (v2) {
                  var y2 = v2.programConfigurations.get(o2.id), x3 = { programConfiguration: y2, program: e2.useProgram("circle", y2), layoutVertexBuffer: v2.layoutVertexBuffer, indexBuffer: v2.indexBuffer, uniformValues: zi(e2, m2, g2, o2) };
                  if (l2)
                    for (var b2 = 0, w2 = v2.segments.get(); b2 < w2.length; b2 += 1) {
                      var T3 = w2[b2];
                      _2.push({ segments: new t.SegmentVector([T3]), sortKey: T3.sortKey, state: x3 });
                    }
                  else
                    _2.push({ segments: v2.segments, sortKey: 0, state: x3 });
                }
              }
              l2 && _2.sort(function(t4, e3) {
                return t4.sortKey - e3.sortKey;
              });
              for (var E3 = 0, I2 = _2; E3 < I2.length; E3 += 1) {
                var P2 = I2[E3], S2 = P2.state;
                S2.program.draw(c2, u2.TRIANGLES, h2, p2, d2, Ct.disabled, S2.uniformValues, o2.id, S2.layoutVertexBuffer, S2.indexBuffer, P2.segments, o2.paint, e2.transform.zoom, S2.programConfiguration);
              }
            }
          }
        }, heatmap: function(e2, i3, o2, r2) {
          if (0 !== o2.paint.get("heatmap-opacity"))
            if ("offscreen" === e2.renderPass) {
              var a2 = e2.context, n2 = a2.gl, s2 = Pt.disabled, l2 = new St([n2.ONE, n2.ONE], t.Color.transparent, [true, true, true, true]);
              !function(t4, e3, i4) {
                var o3 = t4.gl;
                t4.activeTexture.set(o3.TEXTURE1), t4.viewport.set([0, 0, e3.width / 4, e3.height / 4]);
                var r3 = i4.heatmapFbo;
                if (r3)
                  o3.bindTexture(o3.TEXTURE_2D, r3.colorAttachment.get()), t4.bindFramebuffer.set(r3.framebuffer);
                else {
                  var a3 = o3.createTexture();
                  o3.bindTexture(o3.TEXTURE_2D, a3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, o3.LINEAR), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, o3.LINEAR), r3 = i4.heatmapFbo = t4.createFramebuffer(e3.width / 4, e3.height / 4, false), function(t5, e4, i5, o4) {
                    var r4 = t5.gl;
                    r4.texImage2D(r4.TEXTURE_2D, 0, r4.RGBA, e4.width / 4, e4.height / 4, 0, r4.RGBA, t5.extRenderToTextureHalfFloat ? t5.extTextureHalfFloat.HALF_FLOAT_OES : r4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i5);
                  }(t4, e3, a3, r3);
                }
              }(a2, e2, o2), a2.clear({ color: t.Color.transparent });
              for (var c2 = 0; c2 < r2.length; c2++) {
                var u2 = r2[c2];
                if (!i3.hasRenderableParent(u2)) {
                  var h2 = i3.getTile(u2), p2 = h2.getBucket(o2);
                  if (p2) {
                    var d2 = p2.programConfigurations.get(o2.id);
                    e2.useProgram("heatmap", d2).draw(a2, n2.TRIANGLES, It.disabled, s2, l2, Ct.disabled, Ri(u2.posMatrix, h2, e2.transform.zoom, o2.paint.get("heatmap-intensity")), o2.id, p2.layoutVertexBuffer, p2.indexBuffer, p2.segments, o2.paint, e2.transform.zoom, d2);
                  }
                }
              }
              a2.viewport.set([0, 0, e2.width, e2.height]);
            } else
              "translucent" === e2.renderPass && (e2.context.setColorMode(e2.colorModeForRenderPass()), function(e3, i4) {
                var o3 = e3.context, r3 = o3.gl, a3 = i4.heatmapFbo;
                if (a3) {
                  o3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, a3.colorAttachment.get()), o3.activeTexture.set(r3.TEXTURE1);
                  var n3 = i4.colorRampTexture;
                  n3 || (n3 = i4.colorRampTexture = new t.Texture(o3, i4.colorRamp, r3.RGBA)), n3.bind(r3.LINEAR, r3.CLAMP_TO_EDGE), e3.useProgram("heatmapTexture").draw(o3, r3.TRIANGLES, It.disabled, Pt.disabled, e3.colorModeForRenderPass(), Ct.disabled, function(e4, i5, o4, r4) {
                    var a4 = t.create();
                    t.ortho(a4, 0, e4.width, e4.height, 0, 0, 1);
                    var n4 = e4.context.gl;
                    return { u_matrix: a4, u_world: [n4.drawingBufferWidth, n4.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i5.paint.get("heatmap-opacity") };
                  }(e3, i4), i4.id, e3.viewportBuffer, e3.quadTriangleIndexBuffer, e3.viewportSegments, i4.paint, e3.transform.zoom);
                }
              }(e2, o2));
        }, line: function(e2, i3, o2, r2) {
          if ("translucent" === e2.renderPass) {
            var a2 = o2.paint.get("line-opacity"), n2 = o2.paint.get("line-width");
            if (0 !== a2.constantOr(1) && 0 !== n2.constantOr(1))
              for (var s2 = e2.depthModeForSublayer(0, It.ReadOnly), l2 = e2.colorModeForRenderPass(), c2 = o2.paint.get("line-dasharray"), u2 = o2.paint.get("line-pattern"), h2 = u2.constantOr(1), p2 = o2.paint.get("line-gradient"), d2 = o2.getCrossfadeParameters(), _2 = h2 ? "linePattern" : c2 ? "lineSDF" : p2 ? "lineGradient" : "line", f2 = e2.context, m2 = f2.gl, g2 = true, v2 = 0, y2 = r2; v2 < y2.length; v2 += 1) {
                var x3 = y2[v2], b2 = i3.getTile(x3);
                if (!h2 || b2.patternsLoaded()) {
                  var w2 = b2.getBucket(o2);
                  if (w2) {
                    var T3 = w2.programConfigurations.get(o2.id), E3 = e2.context.program.get(), I2 = e2.useProgram(_2, T3), P2 = g2 || I2.program !== E3, S2 = u2.constantOr(null);
                    if (S2 && b2.imageAtlas) {
                      var C3 = b2.imageAtlas, z2 = C3.patternPositions[S2.to.toString()], D3 = C3.patternPositions[S2.from.toString()];
                      z2 && D3 && T3.setConstantPatternPositions(z2, D3);
                    }
                    var A3 = h2 ? Oi(e2, b2, o2, d2) : c2 ? Fi(e2, b2, o2, c2, d2) : p2 ? Bi(e2, b2, o2, w2.lineClipsArray.length) : ki(e2, b2, o2);
                    if (h2)
                      f2.activeTexture.set(m2.TEXTURE0), b2.imageAtlasTexture.bind(m2.LINEAR, m2.CLAMP_TO_EDGE), T3.updatePaintBuffers(d2);
                    else if (c2 && (P2 || e2.lineAtlas.dirty))
                      f2.activeTexture.set(m2.TEXTURE0), e2.lineAtlas.bind(f2);
                    else if (p2) {
                      var M2 = w2.gradients[o2.id], L3 = M2.texture;
                      if (o2.gradientVersion !== M2.version) {
                        var R2 = 256;
                        if (o2.stepInterpolant) {
                          var k2 = i3.getSource().maxzoom, B3 = x3.canonical.z === k2 ? Math.ceil(1 << e2.transform.maxZoom - x3.canonical.z) : 1;
                          R2 = t.clamp(t.nextPowerOfTwo(w2.maxLineLength / t.EXTENT * 1024 * B3), 256, f2.maxTextureSize);
                        }
                        M2.gradient = t.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: R2, image: M2.gradient || void 0, clips: w2.lineClipsArray }), M2.texture ? M2.texture.update(M2.gradient) : M2.texture = new t.Texture(f2, M2.gradient, m2.RGBA), M2.version = o2.gradientVersion, L3 = M2.texture;
                      }
                      f2.activeTexture.set(m2.TEXTURE0), L3.bind(o2.stepInterpolant ? m2.NEAREST : m2.LINEAR, m2.CLAMP_TO_EDGE);
                    }
                    I2.draw(f2, m2.TRIANGLES, s2, e2.stencilModeForClipping(x3), l2, Ct.disabled, A3, o2.id, w2.layoutVertexBuffer, w2.indexBuffer, w2.segments, o2.paint, e2.transform.zoom, T3, w2.layoutVertexBuffer2), g2 = false;
                  }
                }
              }
          }
        }, fill: function(e2, i3, o2, r2) {
          var a2 = o2.paint.get("fill-color"), n2 = o2.paint.get("fill-opacity");
          if (0 !== n2.constantOr(1)) {
            var s2 = e2.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = e2.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === a2.constantOr(t.Color.transparent).a && 1 === n2.constantOr(0) ? "opaque" : "translucent";
            if (e2.renderPass === c2) {
              var u2 = e2.depthModeForSublayer(1, "opaque" === e2.renderPass ? It.ReadWrite : It.ReadOnly);
              oo(e2, i3, o2, r2, u2, s2, false);
            }
            if ("translucent" === e2.renderPass && o2.paint.get("fill-antialias")) {
              var h2 = e2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, It.ReadOnly);
              oo(e2, i3, o2, r2, h2, s2, true);
            }
          }
        }, "fill-extrusion": function(t4, e2, i3, o2) {
          var r2 = i3.paint.get("fill-extrusion-opacity");
          if (0 !== r2 && "translucent" === t4.renderPass) {
            var a2 = new It(t4.context.gl.LEQUAL, It.ReadWrite, t4.depthRangeFor3D);
            if (1 !== r2 || i3.paint.get("fill-extrusion-pattern").constantOr(1))
              ro(t4, e2, i3, o2, a2, Pt.disabled, St.disabled), ro(t4, e2, i3, o2, a2, t4.stencilModeFor3D(), t4.colorModeForRenderPass());
            else {
              var n2 = t4.colorModeForRenderPass();
              ro(t4, e2, i3, o2, a2, Pt.disabled, n2);
            }
          }
        }, hillshade: function(t4, e2, i3, o2) {
          if ("offscreen" === t4.renderPass || "translucent" === t4.renderPass) {
            for (var r2 = t4.context, a2 = t4.depthModeForSublayer(0, It.ReadOnly), n2 = t4.colorModeForRenderPass(), s2 = "translucent" === t4.renderPass ? t4.stencilConfigForOverlap(o2) : [{}, o2], l2 = s2[0], c2 = 0, u2 = s2[1]; c2 < u2.length; c2 += 1) {
              var h2 = u2[c2], p2 = e2.getTile(h2);
              p2.needsHillshadePrepare && "offscreen" === t4.renderPass ? no(t4, p2, i3, a2, Pt.disabled, n2) : "translucent" === t4.renderPass && ao(t4, p2, i3, a2, l2[h2.overscaledZ], n2);
            }
            r2.viewport.set([0, 0, t4.width, t4.height]);
          }
        }, raster: function(t4, e2, i3, o2) {
          if ("translucent" === t4.renderPass && 0 !== i3.paint.get("raster-opacity") && o2.length)
            for (var r2 = t4.context, a2 = r2.gl, n2 = e2.getSource(), s2 = t4.useProgram("raster"), l2 = t4.colorModeForRenderPass(), c2 = n2 instanceof M ? [{}, o2] : t4.stencilConfigForOverlap(o2), u2 = c2[0], h2 = c2[1], p2 = h2[h2.length - 1].overscaledZ, d2 = !t4.options.moving, _2 = 0, f2 = h2; _2 < f2.length; _2 += 1) {
              var m2 = f2[_2], g2 = t4.depthModeForSublayer(m2.overscaledZ - p2, 1 === i3.paint.get("raster-opacity") ? It.ReadWrite : It.ReadOnly, a2.LESS), v2 = e2.getTile(m2), y2 = t4.transform.calculatePosMatrix(m2.toUnwrapped(), d2);
              v2.registerFadeDuration(i3.paint.get("raster-fade-duration"));
              var x3 = e2.findLoadedParent(m2, 0), b2 = so(v2, x3, e2, i3, t4.transform), w2 = void 0, T3 = void 0, E3 = "nearest" === i3.paint.get("raster-resampling") ? a2.NEAREST : a2.LINEAR;
              r2.activeTexture.set(a2.TEXTURE0), v2.texture.bind(E3, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST), r2.activeTexture.set(a2.TEXTURE1), x3 ? (x3.texture.bind(E3, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST), w2 = Math.pow(2, x3.tileID.overscaledZ - v2.tileID.overscaledZ), T3 = [v2.tileID.canonical.x * w2 % 1, v2.tileID.canonical.y * w2 % 1]) : v2.texture.bind(E3, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST);
              var I2 = Zi(y2, T3 || [0, 0], w2 || 1, b2, i3);
              n2 instanceof M ? s2.draw(r2, a2.TRIANGLES, g2, Pt.disabled, l2, Ct.disabled, I2, i3.id, n2.boundsBuffer, t4.quadTriangleIndexBuffer, n2.boundsSegments) : s2.draw(r2, a2.TRIANGLES, g2, u2[m2.overscaledZ], l2, Ct.disabled, I2, i3.id, t4.rasterBoundsBuffer, t4.quadTriangleIndexBuffer, t4.rasterBoundsSegments);
            }
        }, background: function(t4, e2, i3) {
          var o2 = i3.paint.get("background-color"), r2 = i3.paint.get("background-opacity");
          if (0 !== r2) {
            var a2 = t4.context, n2 = a2.gl, s2 = t4.transform, l2 = s2.tileSize, c2 = i3.paint.get("background-pattern");
            if (!t4.isPatternMissing(c2)) {
              var u2 = !c2 && 1 === o2.a && 1 === r2 && t4.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (t4.renderPass === u2) {
                var h2 = Pt.disabled, p2 = t4.depthModeForSublayer(0, "opaque" === u2 ? It.ReadWrite : It.ReadOnly), d2 = t4.colorModeForRenderPass(), _2 = t4.useProgram(c2 ? "backgroundPattern" : "background"), f2 = s2.coveringTiles({ tileSize: l2 });
                c2 && (a2.activeTexture.set(n2.TEXTURE0), t4.imageManager.bind(t4.context));
                for (var m2 = i3.getCrossfadeParameters(), g2 = 0, v2 = f2; g2 < v2.length; g2 += 1) {
                  var y2 = v2[g2], x3 = t4.transform.calculatePosMatrix(y2.toUnwrapped()), b2 = c2 ? Hi(x3, r2, t4, c2, { tileID: y2, tileSize: l2 }, m2) : Xi(x3, r2, o2);
                  _2.draw(a2, n2.TRIANGLES, p2, h2, d2, Ct.disabled, b2, i3.id, t4.tileExtentBuffer, t4.quadTriangleIndexBuffer, t4.tileExtentSegments);
                }
              }
            }
          }
        }, debug: function(t4, e2, i3) {
          for (var o2 = 0; o2 < i3.length; o2++)
            go(t4, e2, i3[o2]);
        }, custom: function(t4, e2, i3) {
          var o2 = t4.context, r2 = i3.implementation;
          if ("offscreen" === t4.renderPass) {
            var a2 = r2.prerender;
            a2 && (t4.setCustomLayerDefaults(), o2.setColorMode(t4.colorModeForRenderPass()), a2.call(r2, o2.gl, t4.transform.customLayerMatrix()), o2.setDirty(), t4.setBaseState());
          } else if ("translucent" === t4.renderPass) {
            t4.setCustomLayerDefaults(), o2.setColorMode(t4.colorModeForRenderPass()), o2.setStencilMode(Pt.disabled);
            var n2 = "3d" === r2.renderingMode ? new It(t4.context.gl.LEQUAL, It.ReadWrite, t4.depthRangeFor3D) : t4.depthModeForSublayer(0, It.ReadOnly);
            o2.setDepthMode(n2), r2.render(o2.gl, t4.transform.customLayerMatrix()), o2.setDirty(), t4.setBaseState(), o2.bindFramebuffer.set(null);
          }
        } }, yo = function(t4, e2) {
          this.context = new zt(t4), this.transform = e2, this._tileTextures = {}, this.setup(), this.numSublayers = Dt.maxUnderzooming + Dt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Fe(), this.gpuTimers = {};
        };
        yo.prototype.resize = function(e2, i3) {
          if (this.width = e2 * t.browser.devicePixelRatio, this.height = i3 * t.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (var o2 = 0, r2 = this.style._order; o2 < r2.length; o2 += 1)
              this.style._layers[r2[o2]].resize();
        }, yo.prototype.setup = function() {
          var e2 = this.context, i3 = new t.StructArrayLayout2i4();
          i3.emplaceBack(0, 0), i3.emplaceBack(t.EXTENT, 0), i3.emplaceBack(0, t.EXTENT), i3.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e2.createVertexBuffer(i3, Ve.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
          var o2 = new t.StructArrayLayout2i4();
          o2.emplaceBack(0, 0), o2.emplaceBack(t.EXTENT, 0), o2.emplaceBack(0, t.EXTENT), o2.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e2.createVertexBuffer(o2, Ve.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);
          var r2 = new t.StructArrayLayout4i8();
          r2.emplaceBack(0, 0, 0, 0), r2.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), r2.emplaceBack(0, t.EXTENT, 0, t.EXTENT), r2.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e2.createVertexBuffer(r2, A2.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
          var a2 = new t.StructArrayLayout2i4();
          a2.emplaceBack(0, 0), a2.emplaceBack(1, 0), a2.emplaceBack(0, 1), a2.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(a2, Ve.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
          var n2 = new t.StructArrayLayout1ui2();
          n2.emplaceBack(0), n2.emplaceBack(1), n2.emplaceBack(3), n2.emplaceBack(2), n2.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(n2);
          var s2 = new t.StructArrayLayout3ui6();
          s2.emplaceBack(0, 1, 2), s2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(s2), this.emptyTexture = new t.Texture(e2, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, e2.gl.RGBA);
          var l2 = this.context.gl;
          this.stencilClearMode = new Pt({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO);
        }, yo.prototype.clearStencil = function() {
          var e2 = this.context, i3 = e2.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          var o2 = t.create();
          t.ortho(o2, 0, this.width, this.height, 0, 0, 1), t.scale(o2, o2, [i3.drawingBufferWidth, i3.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e2, i3.TRIANGLES, It.disabled, this.stencilClearMode, St.disabled, Ct.disabled, Li(o2), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }, yo.prototype._renderTileClippingMasks = function(t4, e2) {
          if (this.currentStencilSource !== t4.source && t4.isTileClipped() && e2 && e2.length) {
            this.currentStencilSource = t4.source;
            var i3 = this.context, o2 = i3.gl;
            this.nextStencilID + e2.length > 256 && this.clearStencil(), i3.setColorMode(St.disabled), i3.setDepthMode(It.disabled);
            var r2 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (var a2 = 0, n2 = e2; a2 < n2.length; a2 += 1) {
              var s2 = n2[a2], l2 = this._tileClippingMaskIDs[s2.key] = this.nextStencilID++;
              r2.draw(i3, o2.TRIANGLES, It.disabled, new Pt({ func: o2.ALWAYS, mask: 0 }, l2, 255, o2.KEEP, o2.KEEP, o2.REPLACE), St.disabled, Ct.disabled, Li(s2.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
            }
          }
        }, yo.prototype.stencilModeFor3D = function() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          var t4 = this.nextStencilID++, e2 = this.context.gl;
          return new Pt({ func: e2.NOTEQUAL, mask: 255 }, t4, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
        }, yo.prototype.stencilModeForClipping = function(t4) {
          var e2 = this.context.gl;
          return new Pt({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t4.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
        }, yo.prototype.stencilConfigForOverlap = function(t4) {
          var e2, i3 = this.context.gl, o2 = t4.sort(function(t5, e3) {
            return e3.overscaledZ - t5.overscaledZ;
          }), r2 = o2[o2.length - 1].overscaledZ, a2 = o2[0].overscaledZ - r2 + 1;
          if (a2 > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + a2 > 256 && this.clearStencil();
            for (var n2 = {}, s2 = 0; s2 < a2; s2++)
              n2[s2 + r2] = new Pt({ func: i3.GEQUAL, mask: 255 }, s2 + this.nextStencilID, 255, i3.KEEP, i3.KEEP, i3.REPLACE);
            return this.nextStencilID += a2, [n2, o2];
          }
          return [(e2 = {}, e2[r2] = Pt.disabled, e2), o2];
        }, yo.prototype.colorModeForRenderPass = function() {
          var e2 = this.context.gl;
          return this._showOverdrawInspector ? new St([e2.CONSTANT_COLOR, e2.ONE], new t.Color(1 / 8, 1 / 8, 1 / 8, 0), [true, true, true, true]) : "opaque" === this.renderPass ? St.unblended : St.alphaBlended;
        }, yo.prototype.depthModeForSublayer = function(t4, e2, i3) {
          if (!this.opaquePassEnabledForLayer())
            return It.disabled;
          var o2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t4) * this.depthEpsilon;
          return new It(i3 || this.context.gl.LEQUAL, e2, [o2, o2]);
        }, yo.prototype.opaquePassEnabledForLayer = function() {
          return this.currentLayer < this.opaquePassCutoff;
        }, yo.prototype.render = function(e2, i3) {
          var o2 = this;
          this.style = e2, this.options = i3, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(t.browser.now()), this.imageManager.beginFrame();
          var r2 = this.style._order, a2 = this.style.sourceCaches;
          for (var n2 in a2) {
            var s2 = a2[n2];
            s2.used && s2.prepare(this.context);
          }
          var l2, c2, u2 = {}, h2 = {}, p2 = {};
          for (var d2 in a2) {
            var _2 = a2[d2];
            u2[d2] = _2.getVisibleCoordinates(), h2[d2] = u2[d2].slice().reverse(), p2[d2] = _2.getVisibleCoordinates(true).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (var f2 = 0; f2 < r2.length; f2++)
            if (this.style._layers[r2[f2]].is3D()) {
              this.opaquePassCutoff = f2;
              break;
            }
          this.renderPass = "offscreen";
          for (var m2 = 0, g2 = r2; m2 < g2.length; m2 += 1) {
            var v2 = this.style._layers[g2[m2]];
            if (v2.hasOffscreenPass() && !v2.isHidden(this.transform.zoom)) {
              var y2 = h2[v2.source];
              ("custom" === v2.type || y2.length) && this.renderLayer(this, a2[v2.source], v2, y2);
            }
          }
          for (this.context.bindFramebuffer.set(null), this.context.clear({ color: i3.showOverdrawInspector ? t.Color.black : t.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i3.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = r2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            var x3 = this.style._layers[r2[this.currentLayer]], b2 = a2[x3.source], w2 = u2[x3.source];
            this._renderTileClippingMasks(x3, w2), this.renderLayer(this, b2, x3, w2);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < r2.length; this.currentLayer++) {
            var T3 = this.style._layers[r2[this.currentLayer]], E3 = a2[T3.source], I2 = ("symbol" === T3.type ? p2 : h2)[T3.source];
            this._renderTileClippingMasks(T3, u2[T3.source]), this.renderLayer(this, E3, T3, I2);
          }
          this.options.showTileBoundaries && (t.values(this.style._layers).forEach(function(t4) {
            t4.source && !t4.isHidden(o2.transform.zoom) && (t4.source !== (c2 && c2.id) && (c2 = o2.style.sourceCaches[t4.source]), (!l2 || l2.getSource().maxzoom < c2.getSource().maxzoom) && (l2 = c2));
          }), l2 && vo.debug(this, l2, l2.getVisibleCoordinates())), this.options.showPadding && function(t4) {
            var e3 = t4.transform.padding;
            _o(t4, t4.transform.height - (e3.top || 0), 3, lo), _o(t4, e3.bottom || 0, 3, co), fo(t4, e3.left || 0, 3, uo), fo(t4, t4.transform.width - (e3.right || 0), 3, ho);
            var i4 = t4.transform.centerPoint;
            !function(t5, e4, i5, o3) {
              mo(t5, e4 - 1, i5 - 10, 2, 20, o3), mo(t5, e4 - 10, i5 - 1, 20, 2, o3);
            }(t4, i4.x, t4.transform.height - i4.y, po);
          }(this), this.context.setDefault();
        }, yo.prototype.renderLayer = function(t4, e2, i3, o2) {
          i3.isHidden(this.transform.zoom) || ("background" === i3.type || "custom" === i3.type || o2.length) && (this.id = i3.id, this.gpuTimingStart(i3), vo[i3.type](t4, e2, i3, o2, this.style.placement.variableOffsets), this.gpuTimingEnd());
        }, yo.prototype.gpuTimingStart = function(t4) {
          if (this.options.gpuTiming) {
            var e2 = this.context.extTimerQuery, i3 = this.gpuTimers[t4.id];
            i3 || (i3 = this.gpuTimers[t4.id] = { calls: 0, cpuTime: 0, query: e2.createQueryEXT() }), i3.calls++, e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, i3.query);
          }
        }, yo.prototype.gpuTimingEnd = function() {
          if (this.options.gpuTiming) {
            var t4 = this.context.extTimerQuery;
            t4.endQueryEXT(t4.TIME_ELAPSED_EXT);
          }
        }, yo.prototype.collectGpuTimers = function() {
          var t4 = this.gpuTimers;
          return this.gpuTimers = {}, t4;
        }, yo.prototype.queryGpuTimers = function(t4) {
          var e2 = {};
          for (var i3 in t4) {
            var o2 = t4[i3], r2 = this.context.extTimerQuery, a2 = r2.getQueryObjectEXT(o2.query, r2.QUERY_RESULT_EXT) / 1e6;
            r2.deleteQueryEXT(o2.query), e2[i3] = a2;
          }
          return e2;
        }, yo.prototype.translatePosMatrix = function(e2, i3, o2, r2, a2) {
          if (!o2[0] && !o2[1])
            return e2;
          var n2 = a2 ? "map" === r2 ? this.transform.angle : 0 : "viewport" === r2 ? -this.transform.angle : 0;
          if (n2) {
            var s2 = Math.sin(n2), l2 = Math.cos(n2);
            o2 = [o2[0] * l2 - o2[1] * s2, o2[0] * s2 + o2[1] * l2];
          }
          var c2 = [a2 ? o2[0] : pe(i3, o2[0], this.transform.zoom), a2 ? o2[1] : pe(i3, o2[1], this.transform.zoom), 0], u2 = new Float32Array(16);
          return t.translate(u2, e2, c2), u2;
        }, yo.prototype.saveTileTexture = function(t4) {
          var e2 = this._tileTextures[t4.size[0]];
          e2 ? e2.push(t4) : this._tileTextures[t4.size[0]] = [t4];
        }, yo.prototype.getTileTexture = function(t4) {
          var e2 = this._tileTextures[t4];
          return e2 && e2.length > 0 ? e2.pop() : null;
        }, yo.prototype.isPatternMissing = function(t4) {
          if (!t4)
            return false;
          if (!t4.from || !t4.to)
            return true;
          var e2 = this.imageManager.getPattern(t4.from.toString()), i3 = this.imageManager.getPattern(t4.to.toString());
          return !e2 || !i3;
        }, yo.prototype.useProgram = function(t4, e2) {
          this.cache = this.cache || {};
          var i3 = "" + t4 + (e2 ? e2.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "");
          return this.cache[i3] || (this.cache[i3] = new bi(this.context, t4, vi[t4], e2, Ki[t4], this._showOverdrawInspector)), this.cache[i3];
        }, yo.prototype.setCustomLayerDefaults = function() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }, yo.prototype.setBaseState = function() {
          var t4 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t4.FUNC_ADD);
        }, yo.prototype.initDebugOverlayCanvas = function() {
          null == this.debugOverlayCanvas && (this.debugOverlayCanvas = t.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }, yo.prototype.destroy = function() {
          this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        };
        var xo = function(t4, e2) {
          this.points = t4, this.planes = e2;
        };
        xo.fromInvProjectionMatrix = function(e2, i3, o2) {
          var r2 = Math.pow(2, o2), a2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(function(i4) {
            return t.transformMat4([], i4, e2);
          }).map(function(e3) {
            return t.scale$1([], e3, 1 / e3[3] / i3 * r2);
          }), n2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(function(e3) {
            var i4 = t.sub([], a2[e3[0]], a2[e3[1]]), o3 = t.sub([], a2[e3[2]], a2[e3[1]]), r3 = t.normalize([], t.cross([], i4, o3)), n3 = -t.dot(r3, a2[e3[1]]);
            return r3.concat(n3);
          });
          return new xo(a2, n2);
        };
        var bo = function(e2, i3) {
          this.min = e2, this.max = i3, this.center = t.scale$2([], t.add([], this.min, this.max), 0.5);
        };
        bo.prototype.quadrant = function(e2) {
          for (var i3 = [e2 % 2 == 0, e2 < 2], o2 = t.clone$2(this.min), r2 = t.clone$2(this.max), a2 = 0; a2 < i3.length; a2++)
            o2[a2] = i3[a2] ? this.min[a2] : this.center[a2], r2[a2] = i3[a2] ? this.center[a2] : this.max[a2];
          return r2[2] = this.max[2], new bo(o2, r2);
        }, bo.prototype.distanceX = function(t4) {
          return Math.max(Math.min(this.max[0], t4[0]), this.min[0]) - t4[0];
        }, bo.prototype.distanceY = function(t4) {
          return Math.max(Math.min(this.max[1], t4[1]), this.min[1]) - t4[1];
        }, bo.prototype.intersects = function(e2) {
          for (var i3 = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], o2 = true, r2 = 0; r2 < e2.planes.length; r2++) {
            for (var a2 = e2.planes[r2], n2 = 0, s2 = 0; s2 < i3.length; s2++)
              n2 += t.dot$1(a2, i3[s2]) >= 0;
            if (0 === n2)
              return 0;
            n2 !== i3.length && (o2 = false);
          }
          if (o2)
            return 2;
          for (var l2 = 0; l2 < 3; l2++) {
            for (var c2 = Number.MAX_VALUE, u2 = -Number.MAX_VALUE, h2 = 0; h2 < e2.points.length; h2++) {
              var p2 = e2.points[h2][l2] - this.min[l2];
              c2 = Math.min(c2, p2), u2 = Math.max(u2, p2);
            }
            if (u2 < 0 || c2 > this.max[l2] - this.min[l2])
              return 0;
          }
          return 1;
        };
        var wo = function(t4, e2, i3, o2) {
          if (void 0 === t4 && (t4 = 0), void 0 === e2 && (e2 = 0), void 0 === i3 && (i3 = 0), void 0 === o2 && (o2 = 0), isNaN(t4) || t4 < 0 || isNaN(e2) || e2 < 0 || isNaN(i3) || i3 < 0 || isNaN(o2) || o2 < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = t4, this.bottom = e2, this.left = i3, this.right = o2;
        };
        wo.prototype.interpolate = function(e2, i3, o2) {
          return null != i3.top && null != e2.top && (this.top = t.number(e2.top, i3.top, o2)), null != i3.bottom && null != e2.bottom && (this.bottom = t.number(e2.bottom, i3.bottom, o2)), null != i3.left && null != e2.left && (this.left = t.number(e2.left, i3.left, o2)), null != i3.right && null != e2.right && (this.right = t.number(e2.right, i3.right, o2)), this;
        }, wo.prototype.getCenter = function(e2, i3) {
          var o2 = t.clamp((this.left + e2 - this.right) / 2, 0, e2), r2 = t.clamp((this.top + i3 - this.bottom) / 2, 0, i3);
          return new t.Point(o2, r2);
        }, wo.prototype.equals = function(t4) {
          return this.top === t4.top && this.bottom === t4.bottom && this.left === t4.left && this.right === t4.right;
        }, wo.prototype.clone = function() {
          return new wo(this.top, this.bottom, this.left, this.right);
        }, wo.prototype.toJSON = function() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        };
        var To = function(e2, i3, o2, r2, a2) {
          this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === a2 || a2, this._minZoom = e2 || 0, this._maxZoom = i3 || 22, this._minPitch = null == o2 ? 0 : o2, this._maxPitch = null == r2 ? 60 : r2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new wo(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
        }, Eo = { minZoom: { configurable: true }, maxZoom: { configurable: true }, minPitch: { configurable: true }, maxPitch: { configurable: true }, renderWorldCopies: { configurable: true }, worldSize: { configurable: true }, centerOffset: { configurable: true }, size: { configurable: true }, bearing: { configurable: true }, pitch: { configurable: true }, fov: { configurable: true }, zoom: { configurable: true }, center: { configurable: true }, padding: { configurable: true }, centerPoint: { configurable: true }, unmodified: { configurable: true }, point: { configurable: true } };
        To.prototype.clone = function() {
          var t4 = new To(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return t4.tileSize = this.tileSize, t4.latRange = this.latRange, t4.width = this.width, t4.height = this.height, t4._center = this._center, t4.zoom = this.zoom, t4.angle = this.angle, t4._fov = this._fov, t4._pitch = this._pitch, t4._unmodified = this._unmodified, t4._edgeInsets = this._edgeInsets.clone(), t4._calcMatrices(), t4;
        }, Eo.minZoom.get = function() {
          return this._minZoom;
        }, Eo.minZoom.set = function(t4) {
          this._minZoom !== t4 && (this._minZoom = t4, this.zoom = Math.max(this.zoom, t4));
        }, Eo.maxZoom.get = function() {
          return this._maxZoom;
        }, Eo.maxZoom.set = function(t4) {
          this._maxZoom !== t4 && (this._maxZoom = t4, this.zoom = Math.min(this.zoom, t4));
        }, Eo.minPitch.get = function() {
          return this._minPitch;
        }, Eo.minPitch.set = function(t4) {
          this._minPitch !== t4 && (this._minPitch = t4, this.pitch = Math.max(this.pitch, t4));
        }, Eo.maxPitch.get = function() {
          return this._maxPitch;
        }, Eo.maxPitch.set = function(t4) {
          this._maxPitch !== t4 && (this._maxPitch = t4, this.pitch = Math.min(this.pitch, t4));
        }, Eo.renderWorldCopies.get = function() {
          return this._renderWorldCopies;
        }, Eo.renderWorldCopies.set = function(t4) {
          void 0 === t4 ? t4 = true : null === t4 && (t4 = false), this._renderWorldCopies = t4;
        }, Eo.worldSize.get = function() {
          return this.tileSize * this.scale;
        }, Eo.centerOffset.get = function() {
          return this.centerPoint._sub(this.size._div(2));
        }, Eo.size.get = function() {
          return new t.Point(this.width, this.height);
        }, Eo.bearing.get = function() {
          return -this.angle / Math.PI * 180;
        }, Eo.bearing.set = function(e2) {
          var i3 = -t.wrap(e2, -180, 180) * Math.PI / 180;
          this.angle !== i3 && (this._unmodified = false, this.angle = i3, this._calcMatrices(), this.rotationMatrix = t.create$2(), t.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
        }, Eo.pitch.get = function() {
          return this._pitch / Math.PI * 180;
        }, Eo.pitch.set = function(e2) {
          var i3 = t.clamp(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== i3 && (this._unmodified = false, this._pitch = i3, this._calcMatrices());
        }, Eo.fov.get = function() {
          return this._fov / Math.PI * 180;
        }, Eo.fov.set = function(t4) {
          t4 = Math.max(0.01, Math.min(60, t4)), this._fov !== t4 && (this._unmodified = false, this._fov = t4 / 180 * Math.PI, this._calcMatrices());
        }, Eo.zoom.get = function() {
          return this._zoom;
        }, Eo.zoom.set = function(t4) {
          var e2 = Math.min(Math.max(t4, this.minZoom), this.maxZoom);
          this._zoom !== e2 && (this._unmodified = false, this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom, this._constrain(), this._calcMatrices());
        }, Eo.center.get = function() {
          return this._center;
        }, Eo.center.set = function(t4) {
          t4.lat === this._center.lat && t4.lng === this._center.lng || (this._unmodified = false, this._center = t4, this._constrain(), this._calcMatrices());
        }, Eo.padding.get = function() {
          return this._edgeInsets.toJSON();
        }, Eo.padding.set = function(t4) {
          this._edgeInsets.equals(t4) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t4, 1), this._calcMatrices());
        }, Eo.centerPoint.get = function() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }, To.prototype.isPaddingEqual = function(t4) {
          return this._edgeInsets.equals(t4);
        }, To.prototype.interpolatePadding = function(t4, e2, i3) {
          this._unmodified = false, this._edgeInsets.interpolate(t4, e2, i3), this._constrain(), this._calcMatrices();
        }, To.prototype.coveringZoomLevel = function(t4) {
          var e2 = (t4.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t4.tileSize));
          return Math.max(0, e2);
        }, To.prototype.getVisibleUnwrappedCoordinates = function(e2) {
          var i3 = [new t.UnwrappedTileID(0, e2)];
          if (this._renderWorldCopies)
            for (var o2 = this.pointCoordinate(new t.Point(0, 0)), r2 = this.pointCoordinate(new t.Point(this.width, 0)), a2 = this.pointCoordinate(new t.Point(this.width, this.height)), n2 = this.pointCoordinate(new t.Point(0, this.height)), s2 = Math.floor(Math.min(o2.x, r2.x, a2.x, n2.x)), l2 = Math.floor(Math.max(o2.x, r2.x, a2.x, n2.x)), c2 = s2 - 1; c2 <= l2 + 1; c2++)
              0 !== c2 && i3.push(new t.UnwrappedTileID(c2, e2));
          return i3;
        }, To.prototype.coveringTiles = function(e2) {
          var i3 = this.coveringZoomLevel(e2), o2 = i3;
          if (void 0 !== e2.minzoom && i3 < e2.minzoom)
            return [];
          void 0 !== e2.maxzoom && i3 > e2.maxzoom && (i3 = e2.maxzoom);
          var r2 = t.MercatorCoordinate.fromLngLat(this.center), a2 = Math.pow(2, i3), n2 = [a2 * r2.x, a2 * r2.y, 0], s2 = xo.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i3), l2 = e2.minzoom || 0;
          this.pitch <= 60 && this._edgeInsets.top < 0.1 && (l2 = i3);
          var c2 = function(t4) {
            return { aabb: new bo([t4 * a2, 0, 0], [(t4 + 1) * a2, a2, 0]), zoom: 0, x: 0, y: 0, wrap: t4, fullyVisible: false };
          }, u2 = [], h2 = [], p2 = i3, d2 = e2.reparseOverscaled ? o2 : i3;
          if (this._renderWorldCopies)
            for (var _2 = 1; _2 <= 3; _2++)
              u2.push(c2(-_2)), u2.push(c2(_2));
          for (u2.push(c2(0)); u2.length > 0; ) {
            var f2 = u2.pop(), m2 = f2.x, g2 = f2.y, v2 = f2.fullyVisible;
            if (!v2) {
              var y2 = f2.aabb.intersects(s2);
              if (0 === y2)
                continue;
              v2 = 2 === y2;
            }
            var x3 = f2.aabb.distanceX(n2), b2 = f2.aabb.distanceY(n2), w2 = Math.max(Math.abs(x3), Math.abs(b2));
            if (f2.zoom === p2 || w2 > 3 + (1 << p2 - f2.zoom) - 2 && f2.zoom >= l2)
              h2.push({ tileID: new t.OverscaledTileID(f2.zoom === p2 ? d2 : f2.zoom, f2.wrap, f2.zoom, m2, g2), distanceSq: t.sqrLen([n2[0] - 0.5 - m2, n2[1] - 0.5 - g2]) });
            else
              for (var T3 = 0; T3 < 4; T3++) {
                var E3 = (m2 << 1) + T3 % 2, I2 = (g2 << 1) + (T3 >> 1);
                u2.push({ aabb: f2.aabb.quadrant(T3), zoom: f2.zoom + 1, x: E3, y: I2, wrap: f2.wrap, fullyVisible: v2 });
              }
          }
          return h2.sort(function(t4, e3) {
            return t4.distanceSq - e3.distanceSq;
          }).map(function(t4) {
            return t4.tileID;
          });
        }, To.prototype.resize = function(t4, e2) {
          this.width = t4, this.height = e2, this.pixelsToGLUnits = [2 / t4, -2 / e2], this._constrain(), this._calcMatrices();
        }, Eo.unmodified.get = function() {
          return this._unmodified;
        }, To.prototype.zoomScale = function(t4) {
          return Math.pow(2, t4);
        }, To.prototype.scaleZoom = function(t4) {
          return Math.log(t4) / Math.LN2;
        }, To.prototype.project = function(e2) {
          var i3 = t.clamp(e2.lat, -this.maxValidLatitude, this.maxValidLatitude);
          return new t.Point(t.mercatorXfromLng(e2.lng) * this.worldSize, t.mercatorYfromLat(i3) * this.worldSize);
        }, To.prototype.unproject = function(e2) {
          return new t.MercatorCoordinate(e2.x / this.worldSize, e2.y / this.worldSize).toLngLat();
        }, Eo.point.get = function() {
          return this.project(this.center);
        }, To.prototype.setLocationAtPoint = function(e2, i3) {
          var o2 = this.pointCoordinate(i3), r2 = this.pointCoordinate(this.centerPoint), a2 = this.locationCoordinate(e2), n2 = new t.MercatorCoordinate(a2.x - (o2.x - r2.x), a2.y - (o2.y - r2.y));
          this.center = this.coordinateLocation(n2), this._renderWorldCopies && (this.center = this.center.wrap());
        }, To.prototype.locationPoint = function(t4) {
          return this.coordinatePoint(this.locationCoordinate(t4));
        }, To.prototype.pointLocation = function(t4) {
          return this.coordinateLocation(this.pointCoordinate(t4));
        }, To.prototype.locationCoordinate = function(e2) {
          return t.MercatorCoordinate.fromLngLat(e2);
        }, To.prototype.coordinateLocation = function(t4) {
          return t4.toLngLat();
        }, To.prototype.pointCoordinate = function(e2) {
          var i3 = [e2.x, e2.y, 0, 1], o2 = [e2.x, e2.y, 1, 1];
          t.transformMat4(i3, i3, this.pixelMatrixInverse), t.transformMat4(o2, o2, this.pixelMatrixInverse);
          var r2 = i3[3], a2 = o2[3], n2 = i3[1] / r2, s2 = o2[1] / a2, l2 = i3[2] / r2, c2 = o2[2] / a2, u2 = l2 === c2 ? 0 : (0 - l2) / (c2 - l2);
          return new t.MercatorCoordinate(t.number(i3[0] / r2, o2[0] / a2, u2) / this.worldSize, t.number(n2, s2, u2) / this.worldSize);
        }, To.prototype.coordinatePoint = function(e2) {
          var i3 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
          return t.transformMat4(i3, i3, this.pixelMatrix), new t.Point(i3[0] / i3[3], i3[1] / i3[3]);
        }, To.prototype.getBounds = function() {
          return new t.LngLatBounds().extend(this.pointLocation(new t.Point(0, 0))).extend(this.pointLocation(new t.Point(this.width, 0))).extend(this.pointLocation(new t.Point(this.width, this.height))).extend(this.pointLocation(new t.Point(0, this.height)));
        }, To.prototype.getMaxBounds = function() {
          return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }, To.prototype.setMaxBounds = function(t4) {
          t4 ? (this.lngRange = [t4.getWest(), t4.getEast()], this.latRange = [t4.getSouth(), t4.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
        }, To.prototype.calculatePosMatrix = function(e2, i3) {
          void 0 === i3 && (i3 = false);
          var o2 = e2.key, r2 = i3 ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (r2[o2])
            return r2[o2];
          var a2 = e2.canonical, n2 = this.worldSize / this.zoomScale(a2.z), s2 = a2.x + Math.pow(2, a2.z) * e2.wrap, l2 = t.identity(new Float64Array(16));
          return t.translate(l2, l2, [s2 * n2, a2.y * n2, 0]), t.scale(l2, l2, [n2 / t.EXTENT, n2 / t.EXTENT, 1]), t.multiply(l2, i3 ? this.alignedProjMatrix : this.projMatrix, l2), r2[o2] = new Float32Array(l2), r2[o2];
        }, To.prototype.customLayerMatrix = function() {
          return this.mercatorMatrix.slice();
        }, To.prototype._constrain = function() {
          if (this.center && this.width && this.height && !this._constraining) {
            this._constraining = true;
            var e2, i3, o2, r2, a2 = -90, n2 = 90, s2 = -180, l2 = 180, c2 = this.size, u2 = this._unmodified;
            if (this.latRange) {
              var h2 = this.latRange;
              a2 = t.mercatorYfromLat(h2[1]) * this.worldSize, e2 = (n2 = t.mercatorYfromLat(h2[0]) * this.worldSize) - a2 < c2.y ? c2.y / (n2 - a2) : 0;
            }
            if (this.lngRange) {
              var p2 = this.lngRange;
              s2 = t.mercatorXfromLng(p2[0]) * this.worldSize, i3 = (l2 = t.mercatorXfromLng(p2[1]) * this.worldSize) - s2 < c2.x ? c2.x / (l2 - s2) : 0;
            }
            var d2 = this.point, _2 = Math.max(i3 || 0, e2 || 0);
            if (_2)
              return this.center = this.unproject(new t.Point(i3 ? (l2 + s2) / 2 : d2.x, e2 ? (n2 + a2) / 2 : d2.y)), this.zoom += this.scaleZoom(_2), this._unmodified = u2, void (this._constraining = false);
            if (this.latRange) {
              var f2 = d2.y, m2 = c2.y / 2;
              f2 - m2 < a2 && (r2 = a2 + m2), f2 + m2 > n2 && (r2 = n2 - m2);
            }
            if (this.lngRange) {
              var g2 = d2.x, v2 = c2.x / 2;
              g2 - v2 < s2 && (o2 = s2 + v2), g2 + v2 > l2 && (o2 = l2 - v2);
            }
            void 0 === o2 && void 0 === r2 || (this.center = this.unproject(new t.Point(void 0 !== o2 ? o2 : d2.x, void 0 !== r2 ? r2 : d2.y))), this._unmodified = u2, this._constraining = false;
          }
        }, To.prototype._calcMatrices = function() {
          if (this.height) {
            var e2 = this.centerOffset;
            this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
            var i3 = Math.PI / 2 + this._pitch, o2 = this._fov * (0.5 + e2.y / this.height), r2 = Math.sin(o2) * this.cameraToCenterDistance / Math.sin(t.clamp(Math.PI - i3 - o2, 0.01, Math.PI - 0.01)), a2 = this.point, n2 = a2.x, s2 = a2.y, l2 = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * r2 + this.cameraToCenterDistance), c2 = this.height / 50, u2 = new Float64Array(16);
            t.perspective(u2, this._fov, this.width / this.height, c2, l2), u2[8] = 2 * -e2.x / this.width, u2[9] = 2 * e2.y / this.height, t.scale(u2, u2, [1, -1, 1]), t.translate(u2, u2, [0, 0, -this.cameraToCenterDistance]), t.rotateX(u2, u2, this._pitch), t.rotateZ(u2, u2, this.angle), t.translate(u2, u2, [-n2, -s2, 0]), this.mercatorMatrix = t.scale([], u2, [this.worldSize, this.worldSize, this.worldSize]), t.scale(u2, u2, [1, 1, t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = u2, this.invProjMatrix = t.invert([], this.projMatrix);
            var h2 = this.width % 2 / 2, p2 = this.height % 2 / 2, d2 = Math.cos(this.angle), _2 = Math.sin(this.angle), f2 = n2 - Math.round(n2) + d2 * h2 + _2 * p2, m2 = s2 - Math.round(s2) + d2 * p2 + _2 * h2, g2 = new Float64Array(u2);
            if (t.translate(g2, g2, [f2 > 0.5 ? f2 - 1 : f2, m2 > 0.5 ? m2 - 1 : m2, 0]), this.alignedProjMatrix = g2, u2 = t.create(), t.scale(u2, u2, [this.width / 2, -this.height / 2, 1]), t.translate(u2, u2, [1, -1, 0]), this.labelPlaneMatrix = u2, u2 = t.create(), t.scale(u2, u2, [1, -1, 1]), t.translate(u2, u2, [-1, -1, 0]), t.scale(u2, u2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = u2, this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(u2 = t.invert(new Float64Array(16), this.pixelMatrix)))
              throw new Error("failed to invert matrix");
            this.pixelMatrixInverse = u2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
          }
        }, To.prototype.maxPitchScaleFactor = function() {
          if (!this.pixelMatrixInverse)
            return 1;
          var e2 = this.pointCoordinate(new t.Point(0, 0)), i3 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
          return t.transformMat4(i3, i3, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }, To.prototype.getCameraPoint = function() {
          var e2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new t.Point(0, e2));
        }, To.prototype.getCameraQueryGeometry = function(e2) {
          var i3 = this.getCameraPoint();
          if (1 === e2.length)
            return [e2[0], i3];
          for (var o2 = i3.x, r2 = i3.y, a2 = i3.x, n2 = i3.y, s2 = 0, l2 = e2; s2 < l2.length; s2 += 1) {
            var c2 = l2[s2];
            o2 = Math.min(o2, c2.x), r2 = Math.min(r2, c2.y), a2 = Math.max(a2, c2.x), n2 = Math.max(n2, c2.y);
          }
          return [new t.Point(o2, r2), new t.Point(a2, r2), new t.Point(a2, n2), new t.Point(o2, n2), new t.Point(o2, r2)];
        }, Object.defineProperties(To.prototype, Eo);
        var Io = function(e2) {
          var i3, o2, r2, a2;
          this._hashName = e2 && encodeURIComponent(e2), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (i3 = this._updateHashUnthrottled.bind(this), o2 = false, r2 = null, a2 = function() {
            r2 = null, o2 && (i3(), r2 = setTimeout(a2, 300), o2 = false);
          }, function() {
            return o2 = true, r2 || a2(), r2;
          });
        };
        Io.prototype.addTo = function(e2) {
          return this._map = e2, t.window.addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
        }, Io.prototype.remove = function() {
          return t.window.removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
        }, Io.prototype.getHashString = function(e2) {
          var i3 = this._map.getCenter(), o2 = Math.round(100 * this._map.getZoom()) / 100, r2 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a2 = Math.pow(10, r2), n2 = Math.round(i3.lng * a2) / a2, s2 = Math.round(i3.lat * a2) / a2, l2 = this._map.getBearing(), c2 = this._map.getPitch(), u2 = "";
          if (u2 += e2 ? "/" + n2 + "/" + s2 + "/" + o2 : o2 + "/" + s2 + "/" + n2, (l2 || c2) && (u2 += "/" + Math.round(10 * l2) / 10), c2 && (u2 += "/" + Math.round(c2)), this._hashName) {
            var h2 = this._hashName, p2 = false, d2 = t.window.location.hash.slice(1).split("&").map(function(t4) {
              var e3 = t4.split("=")[0];
              return e3 === h2 ? (p2 = true, e3 + "=" + u2) : t4;
            }).filter(function(t4) {
              return t4;
            });
            return p2 || d2.push(h2 + "=" + u2), "#" + d2.join("&");
          }
          return "#" + u2;
        }, Io.prototype._getCurrentHash = function() {
          var e2, i3 = this, o2 = t.window.location.hash.replace("#", "");
          return this._hashName ? (o2.split("&").map(function(t4) {
            return t4.split("=");
          }).forEach(function(t4) {
            t4[0] === i3._hashName && (e2 = t4);
          }), (e2 && e2[1] || "").split("/")) : o2.split("/");
        }, Io.prototype._onHashChange = function() {
          var t4 = this._getCurrentHash();
          if (t4.length >= 3 && !t4.some(function(t5) {
            return isNaN(t5);
          })) {
            var e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t4[3] || 0) : this._map.getBearing();
            return this._map.jumpTo({ center: [+t4[2], +t4[1]], zoom: +t4[0], bearing: e2, pitch: +(t4[4] || 0) }), true;
          }
          return false;
        }, Io.prototype._updateHashUnthrottled = function() {
          var e2 = t.window.location.href.replace(/(#.+)?$/, this.getHashString());
          try {
            t.window.history.replaceState(t.window.history.state, null, e2);
          } catch (t4) {
          }
        };
        var Po = { linearity: 0.3, easing: t.bezier(0, 0, 0.3, 1) }, So = t.extend({ deceleration: 2500, maxSpeed: 1400 }, Po), Co = t.extend({ deceleration: 20, maxSpeed: 1400 }, Po), zo = t.extend({ deceleration: 1e3, maxSpeed: 360 }, Po), Do = t.extend({ deceleration: 1e3, maxSpeed: 90 }, Po), Ao = function(t4) {
          this._map = t4, this.clear();
        };
        function Mo(t4, e2) {
          (!t4.duration || t4.duration < e2.duration) && (t4.duration = e2.duration, t4.easing = e2.easing);
        }
        function Lo(e2, i3, o2) {
          var r2 = o2.maxSpeed, a2 = o2.linearity, n2 = o2.deceleration, s2 = t.clamp(e2 * a2 / (i3 / 1e3), -r2, r2), l2 = Math.abs(s2) / (n2 * a2);
          return { easing: o2.easing, duration: 1e3 * l2, amount: s2 * (l2 / 2) };
        }
        Ao.prototype.clear = function() {
          this._inertiaBuffer = [];
        }, Ao.prototype.record = function(e2) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t.browser.now(), settings: e2 });
        }, Ao.prototype._drainInertiaBuffer = function() {
          for (var e2 = this._inertiaBuffer, i3 = t.browser.now(); e2.length > 0 && i3 - e2[0].time > 160; )
            e2.shift();
        }, Ao.prototype._onMoveEnd = function(e2) {
          if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) {
            for (var i3 = { zoom: 0, bearing: 0, pitch: 0, pan: new t.Point(0, 0), pinchAround: void 0, around: void 0 }, o2 = 0, r2 = this._inertiaBuffer; o2 < r2.length; o2 += 1) {
              var a2 = r2[o2].settings;
              i3.zoom += a2.zoomDelta || 0, i3.bearing += a2.bearingDelta || 0, i3.pitch += a2.pitchDelta || 0, a2.panDelta && i3.pan._add(a2.panDelta), a2.around && (i3.around = a2.around), a2.pinchAround && (i3.pinchAround = a2.pinchAround);
            }
            var n2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s2 = {};
            if (i3.pan.mag()) {
              var l2 = Lo(i3.pan.mag(), n2, t.extend({}, So, e2 || {}));
              s2.offset = i3.pan.mult(l2.amount / i3.pan.mag()), s2.center = this._map.transform.center, Mo(s2, l2);
            }
            if (i3.zoom) {
              var c2 = Lo(i3.zoom, n2, Co);
              s2.zoom = this._map.transform.zoom + c2.amount, Mo(s2, c2);
            }
            if (i3.bearing) {
              var u2 = Lo(i3.bearing, n2, zo);
              s2.bearing = this._map.transform.bearing + t.clamp(u2.amount, -179, 179), Mo(s2, u2);
            }
            if (i3.pitch) {
              var h2 = Lo(i3.pitch, n2, Do);
              s2.pitch = this._map.transform.pitch + h2.amount, Mo(s2, h2);
            }
            if (s2.zoom || s2.bearing) {
              var p2 = void 0 === i3.pinchAround ? i3.around : i3.pinchAround;
              s2.around = p2 ? this._map.unproject(p2) : this._map.getCenter();
            }
            return this.clear(), t.extend(s2, { noMoveStart: true });
          }
        };
        var Ro = function(e2) {
          function o2(o3, r3, a2, n2) {
            void 0 === n2 && (n2 = {});
            var s2 = i2.mousePos(r3.getCanvasContainer(), a2), l2 = r3.unproject(s2);
            e2.call(this, o3, t.extend({ point: s2, lngLat: l2, originalEvent: a2 }, n2)), this._defaultPrevented = false, this.target = r3;
          }
          e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2;
          var r2 = { defaultPrevented: { configurable: true } };
          return o2.prototype.preventDefault = function() {
            this._defaultPrevented = true;
          }, r2.defaultPrevented.get = function() {
            return this._defaultPrevented;
          }, Object.defineProperties(o2.prototype, r2), o2;
        }(t.Event), ko = function(e2) {
          function o2(o3, r3, a2) {
            var n2 = "touchend" === o3 ? a2.changedTouches : a2.touches, s2 = i2.touchPos(r3.getCanvasContainer(), n2), l2 = s2.map(function(t4) {
              return r3.unproject(t4);
            }), c2 = s2.reduce(function(t4, e3, i3, o4) {
              return t4.add(e3.div(o4.length));
            }, new t.Point(0, 0)), u2 = r3.unproject(c2);
            e2.call(this, o3, { points: s2, point: c2, lngLats: l2, lngLat: u2, originalEvent: a2 }), this._defaultPrevented = false;
          }
          e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2;
          var r2 = { defaultPrevented: { configurable: true } };
          return o2.prototype.preventDefault = function() {
            this._defaultPrevented = true;
          }, r2.defaultPrevented.get = function() {
            return this._defaultPrevented;
          }, Object.defineProperties(o2.prototype, r2), o2;
        }(t.Event), Bo = function(t4) {
          function e2(e3, i4, o2) {
            t4.call(this, e3, { originalEvent: o2 }), this._defaultPrevented = false;
          }
          t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2;
          var i3 = { defaultPrevented: { configurable: true } };
          return e2.prototype.preventDefault = function() {
            this._defaultPrevented = true;
          }, i3.defaultPrevented.get = function() {
            return this._defaultPrevented;
          }, Object.defineProperties(e2.prototype, i3), e2;
        }(t.Event), Oo = function(t4, e2) {
          this._map = t4, this._clickTolerance = e2.clickTolerance;
        };
        Oo.prototype.reset = function() {
          delete this._mousedownPos;
        }, Oo.prototype.wheel = function(t4) {
          return this._firePreventable(new Bo(t4.type, this._map, t4));
        }, Oo.prototype.mousedown = function(t4, e2) {
          return this._mousedownPos = e2, this._firePreventable(new Ro(t4.type, this._map, t4));
        }, Oo.prototype.mouseup = function(t4) {
          this._map.fire(new Ro(t4.type, this._map, t4));
        }, Oo.prototype.click = function(t4, e2) {
          this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new Ro(t4.type, this._map, t4));
        }, Oo.prototype.dblclick = function(t4) {
          return this._firePreventable(new Ro(t4.type, this._map, t4));
        }, Oo.prototype.mouseover = function(t4) {
          this._map.fire(new Ro(t4.type, this._map, t4));
        }, Oo.prototype.mouseout = function(t4) {
          this._map.fire(new Ro(t4.type, this._map, t4));
        }, Oo.prototype.touchstart = function(t4) {
          return this._firePreventable(new ko(t4.type, this._map, t4));
        }, Oo.prototype.touchmove = function(t4) {
          this._map.fire(new ko(t4.type, this._map, t4));
        }, Oo.prototype.touchend = function(t4) {
          this._map.fire(new ko(t4.type, this._map, t4));
        }, Oo.prototype.touchcancel = function(t4) {
          this._map.fire(new ko(t4.type, this._map, t4));
        }, Oo.prototype._firePreventable = function(t4) {
          if (this._map.fire(t4), t4.defaultPrevented)
            return {};
        }, Oo.prototype.isEnabled = function() {
          return true;
        }, Oo.prototype.isActive = function() {
          return false;
        }, Oo.prototype.enable = function() {
        }, Oo.prototype.disable = function() {
        };
        var Fo = function(t4) {
          this._map = t4;
        };
        Fo.prototype.reset = function() {
          this._delayContextMenu = false, delete this._contextMenuEvent;
        }, Fo.prototype.mousemove = function(t4) {
          this._map.fire(new Ro(t4.type, this._map, t4));
        }, Fo.prototype.mousedown = function() {
          this._delayContextMenu = true;
        }, Fo.prototype.mouseup = function() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Ro("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }, Fo.prototype.contextmenu = function(t4) {
          this._delayContextMenu ? this._contextMenuEvent = t4 : this._map.fire(new Ro(t4.type, this._map, t4)), this._map.listens("contextmenu") && t4.preventDefault();
        }, Fo.prototype.isEnabled = function() {
          return true;
        }, Fo.prototype.isActive = function() {
          return false;
        }, Fo.prototype.enable = function() {
        }, Fo.prototype.disable = function() {
        };
        var Uo = function(t4, e2) {
          this._map = t4, this._el = t4.getCanvasContainer(), this._container = t4.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
        };
        function No(t4, e2) {
          for (var i3 = {}, o2 = 0; o2 < t4.length; o2++)
            i3[t4[o2].identifier] = e2[o2];
          return i3;
        }
        Uo.prototype.isEnabled = function() {
          return !!this._enabled;
        }, Uo.prototype.isActive = function() {
          return !!this._active;
        }, Uo.prototype.enable = function() {
          this.isEnabled() || (this._enabled = true);
        }, Uo.prototype.disable = function() {
          this.isEnabled() && (this._enabled = false);
        }, Uo.prototype.mousedown = function(t4, e2) {
          this.isEnabled() && t4.shiftKey && 0 === t4.button && (i2.disableDrag(), this._startPos = this._lastPos = e2, this._active = true);
        }, Uo.prototype.mousemoveWindow = function(t4, e2) {
          if (this._active) {
            var o2 = e2;
            if (!(this._lastPos.equals(o2) || !this._box && o2.dist(this._startPos) < this._clickTolerance)) {
              var r2 = this._startPos;
              this._lastPos = o2, this._box || (this._box = i2.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t4));
              var a2 = Math.min(r2.x, o2.x), n2 = Math.max(r2.x, o2.x), s2 = Math.min(r2.y, o2.y), l2 = Math.max(r2.y, o2.y);
              i2.setTransform(this._box, "translate(" + a2 + "px," + s2 + "px)"), this._box.style.width = n2 - a2 + "px", this._box.style.height = l2 - s2 + "px";
            }
          }
        }, Uo.prototype.mouseupWindow = function(e2, o2) {
          var r2 = this;
          if (this._active && 0 === e2.button) {
            var a2 = this._startPos, n2 = o2;
            if (this.reset(), i2.suppressClick(), a2.x !== n2.x || a2.y !== n2.y)
              return this._map.fire(new t.Event("boxzoomend", { originalEvent: e2 })), { cameraAnimation: function(t4) {
                return t4.fitScreenCoordinates(a2, n2, r2._map.getBearing(), { linear: true });
              } };
            this._fireEvent("boxzoomcancel", e2);
          }
        }, Uo.prototype.keydown = function(t4) {
          this._active && 27 === t4.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t4));
        }, Uo.prototype.blur = function() {
          this.reset();
        }, Uo.prototype.reset = function() {
          this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (i2.remove(this._box), this._box = null), i2.enableDrag(), delete this._startPos, delete this._lastPos;
        }, Uo.prototype._fireEvent = function(e2, i3) {
          return this._map.fire(new t.Event(e2, { originalEvent: i3 }));
        };
        var Zo = function(t4) {
          this.reset(), this.numTouches = t4.numTouches;
        };
        Zo.prototype.reset = function() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
        }, Zo.prototype.touchstart = function(e2, i3, o2) {
          (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e2.timeStamp), o2.length === this.numTouches && (this.centroid = function(e3) {
            for (var i4 = new t.Point(0, 0), o3 = 0, r2 = e3; o3 < r2.length; o3 += 1)
              i4._add(r2[o3]);
            return i4.div(e3.length);
          }(i3), this.touches = No(o2, i3)));
        }, Zo.prototype.touchmove = function(t4, e2, i3) {
          if (!this.aborted && this.centroid) {
            var o2 = No(i3, e2);
            for (var r2 in this.touches) {
              var a2 = o2[r2];
              (!a2 || a2.dist(this.touches[r2]) > 30) && (this.aborted = true);
            }
          }
        }, Zo.prototype.touchend = function(t4, e2, i3) {
          if ((!this.centroid || t4.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i3.length) {
            var o2 = !this.aborted && this.centroid;
            if (this.reset(), o2)
              return o2;
          }
        };
        var qo = function(t4) {
          this.singleTap = new Zo(t4), this.numTaps = t4.numTaps, this.reset();
        };
        qo.prototype.reset = function() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }, qo.prototype.touchstart = function(t4, e2, i3) {
          this.singleTap.touchstart(t4, e2, i3);
        }, qo.prototype.touchmove = function(t4, e2, i3) {
          this.singleTap.touchmove(t4, e2, i3);
        }, qo.prototype.touchend = function(t4, e2, i3) {
          var o2 = this.singleTap.touchend(t4, e2, i3);
          if (o2) {
            var r2 = t4.timeStamp - this.lastTime < 500, a2 = !this.lastTap || this.lastTap.dist(o2) < 30;
            if (r2 && a2 || this.reset(), this.count++, this.lastTime = t4.timeStamp, this.lastTap = o2, this.count === this.numTaps)
              return this.reset(), o2;
          }
        };
        var jo = function() {
          this._zoomIn = new qo({ numTouches: 1, numTaps: 2 }), this._zoomOut = new qo({ numTouches: 2, numTaps: 1 }), this.reset();
        };
        jo.prototype.reset = function() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }, jo.prototype.touchstart = function(t4, e2, i3) {
          this._zoomIn.touchstart(t4, e2, i3), this._zoomOut.touchstart(t4, e2, i3);
        }, jo.prototype.touchmove = function(t4, e2, i3) {
          this._zoomIn.touchmove(t4, e2, i3), this._zoomOut.touchmove(t4, e2, i3);
        }, jo.prototype.touchend = function(t4, e2, i3) {
          var o2 = this, r2 = this._zoomIn.touchend(t4, e2, i3), a2 = this._zoomOut.touchend(t4, e2, i3);
          return r2 ? (this._active = true, t4.preventDefault(), setTimeout(function() {
            return o2.reset();
          }, 0), { cameraAnimation: function(e3) {
            return e3.easeTo({ duration: 300, zoom: e3.getZoom() + 1, around: e3.unproject(r2) }, { originalEvent: t4 });
          } }) : a2 ? (this._active = true, t4.preventDefault(), setTimeout(function() {
            return o2.reset();
          }, 0), { cameraAnimation: function(e3) {
            return e3.easeTo({ duration: 300, zoom: e3.getZoom() - 1, around: e3.unproject(a2) }, { originalEvent: t4 });
          } }) : void 0;
        }, jo.prototype.touchcancel = function() {
          this.reset();
        }, jo.prototype.enable = function() {
          this._enabled = true;
        }, jo.prototype.disable = function() {
          this._enabled = false, this.reset();
        }, jo.prototype.isEnabled = function() {
          return this._enabled;
        }, jo.prototype.isActive = function() {
          return this._active;
        };
        var Vo = { 0: 1, 2: 2 }, Go = function(t4) {
          this.reset(), this._clickTolerance = t4.clickTolerance || 1;
        };
        Go.prototype.blur = function() {
          this.reset();
        }, Go.prototype.reset = function() {
          this._active = false, this._moved = false, delete this._lastPoint, delete this._eventButton;
        }, Go.prototype._correctButton = function(t4, e2) {
          return false;
        }, Go.prototype._move = function(t4, e2) {
          return {};
        }, Go.prototype.mousedown = function(t4, e2) {
          if (!this._lastPoint) {
            var o2 = i2.mouseButton(t4);
            this._correctButton(t4, o2) && (this._lastPoint = e2, this._eventButton = o2);
          }
        }, Go.prototype.mousemoveWindow = function(t4, e2) {
          var i3 = this._lastPoint;
          if (i3) {
            if (t4.preventDefault(), function(t5, e3) {
              var i4 = Vo[e3];
              return void 0 === t5.buttons || (t5.buttons & i4) !== i4;
            }(t4, this._eventButton))
              this.reset();
            else if (this._moved || !(e2.dist(i3) < this._clickTolerance))
              return this._moved = true, this._lastPoint = e2, this._move(i3, e2);
          }
        }, Go.prototype.mouseupWindow = function(t4) {
          this._lastPoint && i2.mouseButton(t4) === this._eventButton && (this._moved && i2.suppressClick(), this.reset());
        }, Go.prototype.enable = function() {
          this._enabled = true;
        }, Go.prototype.disable = function() {
          this._enabled = false, this.reset();
        }, Go.prototype.isEnabled = function() {
          return this._enabled;
        }, Go.prototype.isActive = function() {
          return this._active;
        };
        var Wo = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.mousedown = function(e3, i3) {
            t4.prototype.mousedown.call(this, e3, i3), this._lastPoint && (this._active = true);
          }, e2.prototype._correctButton = function(t5, e3) {
            return 0 === e3 && !t5.ctrlKey;
          }, e2.prototype._move = function(t5, e3) {
            return { around: e3, panDelta: e3.sub(t5) };
          }, e2;
        }(Go), Xo = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._correctButton = function(t5, e3) {
            return 0 === e3 && t5.ctrlKey || 2 === e3;
          }, e2.prototype._move = function(t5, e3) {
            var i3 = 0.8 * (e3.x - t5.x);
            if (i3)
              return this._active = true, { bearingDelta: i3 };
          }, e2.prototype.contextmenu = function(t5) {
            t5.preventDefault();
          }, e2;
        }(Go), Ho = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype._correctButton = function(t5, e3) {
            return 0 === e3 && t5.ctrlKey || 2 === e3;
          }, e2.prototype._move = function(t5, e3) {
            var i3 = -0.5 * (e3.y - t5.y);
            if (i3)
              return this._active = true, { pitchDelta: i3 };
          }, e2.prototype.contextmenu = function(t5) {
            t5.preventDefault();
          }, e2;
        }(Go), Ko = function(t4) {
          this._minTouches = 1, this._clickTolerance = t4.clickTolerance || 1, this.reset();
        };
        Ko.prototype.reset = function() {
          this._active = false, this._touches = {}, this._sum = new t.Point(0, 0);
        }, Ko.prototype.touchstart = function(t4, e2, i3) {
          return this._calculateTransform(t4, e2, i3);
        }, Ko.prototype.touchmove = function(t4, e2, i3) {
          if (this._active && !(i3.length < this._minTouches))
            return t4.preventDefault(), this._calculateTransform(t4, e2, i3);
        }, Ko.prototype.touchend = function(t4, e2, i3) {
          this._calculateTransform(t4, e2, i3), this._active && i3.length < this._minTouches && this.reset();
        }, Ko.prototype.touchcancel = function() {
          this.reset();
        }, Ko.prototype._calculateTransform = function(e2, i3, o2) {
          o2.length > 0 && (this._active = true);
          var r2 = No(o2, i3), a2 = new t.Point(0, 0), n2 = new t.Point(0, 0), s2 = 0;
          for (var l2 in r2) {
            var c2 = r2[l2], u2 = this._touches[l2];
            u2 && (a2._add(c2), n2._add(c2.sub(u2)), s2++, r2[l2] = c2);
          }
          if (this._touches = r2, !(s2 < this._minTouches) && n2.mag()) {
            var h2 = n2.div(s2);
            if (this._sum._add(h2), !(this._sum.mag() < this._clickTolerance))
              return { around: a2.div(s2), panDelta: h2 };
          }
        }, Ko.prototype.enable = function() {
          this._enabled = true;
        }, Ko.prototype.disable = function() {
          this._enabled = false, this.reset();
        }, Ko.prototype.isEnabled = function() {
          return this._enabled;
        }, Ko.prototype.isActive = function() {
          return this._active;
        };
        var Yo = function() {
          this.reset();
        };
        function Jo(t4, e2, i3) {
          for (var o2 = 0; o2 < t4.length; o2++)
            if (t4[o2].identifier === i3)
              return e2[o2];
        }
        function Qo(t4, e2) {
          return Math.log(t4 / e2) / Math.LN2;
        }
        Yo.prototype.reset = function() {
          this._active = false, delete this._firstTwoTouches;
        }, Yo.prototype._start = function(t4) {
        }, Yo.prototype._move = function(t4, e2, i3) {
          return {};
        }, Yo.prototype.touchstart = function(t4, e2, i3) {
          this._firstTwoTouches || i3.length < 2 || (this._firstTwoTouches = [i3[0].identifier, i3[1].identifier], this._start([e2[0], e2[1]]));
        }, Yo.prototype.touchmove = function(t4, e2, i3) {
          if (this._firstTwoTouches) {
            t4.preventDefault();
            var o2 = this._firstTwoTouches, r2 = o2[1], a2 = Jo(i3, e2, o2[0]), n2 = Jo(i3, e2, r2);
            if (a2 && n2) {
              var s2 = this._aroundCenter ? null : a2.add(n2).div(2);
              return this._move([a2, n2], s2, t4);
            }
          }
        }, Yo.prototype.touchend = function(t4, e2, o2) {
          if (this._firstTwoTouches) {
            var r2 = this._firstTwoTouches, a2 = r2[1], n2 = Jo(o2, e2, r2[0]), s2 = Jo(o2, e2, a2);
            n2 && s2 || (this._active && i2.suppressClick(), this.reset());
          }
        }, Yo.prototype.touchcancel = function() {
          this.reset();
        }, Yo.prototype.enable = function(t4) {
          this._enabled = true, this._aroundCenter = !!t4 && "center" === t4.around;
        }, Yo.prototype.disable = function() {
          this._enabled = false, this.reset();
        }, Yo.prototype.isEnabled = function() {
          return this._enabled;
        }, Yo.prototype.isActive = function() {
          return this._active;
        };
        var $o = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.reset = function() {
            t4.prototype.reset.call(this), delete this._distance, delete this._startDistance;
          }, e2.prototype._start = function(t5) {
            this._startDistance = this._distance = t5[0].dist(t5[1]);
          }, e2.prototype._move = function(t5, e3) {
            var i3 = this._distance;
            if (this._distance = t5[0].dist(t5[1]), this._active || !(Math.abs(Qo(this._distance, this._startDistance)) < 0.1))
              return this._active = true, { zoomDelta: Qo(this._distance, i3), pinchAround: e3 };
          }, e2;
        }(Yo);
        function tr(t4, e2) {
          return 180 * t4.angleWith(e2) / Math.PI;
        }
        var er = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.reset = function() {
            t4.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector;
          }, e2.prototype._start = function(t5) {
            this._startVector = this._vector = t5[0].sub(t5[1]), this._minDiameter = t5[0].dist(t5[1]);
          }, e2.prototype._move = function(t5, e3) {
            var i3 = this._vector;
            if (this._vector = t5[0].sub(t5[1]), this._active || !this._isBelowThreshold(this._vector))
              return this._active = true, { bearingDelta: tr(this._vector, i3), pinchAround: e3 };
          }, e2.prototype._isBelowThreshold = function(t5) {
            this._minDiameter = Math.min(this._minDiameter, t5.mag());
            var e3 = 25 / (Math.PI * this._minDiameter) * 360, i3 = tr(t5, this._startVector);
            return Math.abs(i3) < e3;
          }, e2;
        }(Yo);
        function ir(t4) {
          return Math.abs(t4.y) > Math.abs(t4.x);
        }
        var or = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2.prototype.reset = function() {
            t4.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }, e2.prototype._start = function(t5) {
            this._lastPoints = t5, ir(t5[0].sub(t5[1])) && (this._valid = false);
          }, e2.prototype._move = function(t5, e3, i3) {
            var o2 = t5[0].sub(this._lastPoints[0]), r2 = t5[1].sub(this._lastPoints[1]);
            if (this._valid = this.gestureBeginsVertically(o2, r2, i3.timeStamp), this._valid)
              return this._lastPoints = t5, this._active = true, { pitchDelta: (o2.y + r2.y) / 2 * -0.5 };
          }, e2.prototype.gestureBeginsVertically = function(t5, e3, i3) {
            if (void 0 !== this._valid)
              return this._valid;
            var o2 = t5.mag() >= 2, r2 = e3.mag() >= 2;
            if (o2 || r2) {
              if (!o2 || !r2)
                return void 0 === this._firstMove && (this._firstMove = i3), i3 - this._firstMove < 100 && void 0;
              var a2 = t5.y > 0 == e3.y > 0;
              return ir(t5) && ir(e3) && a2;
            }
          }, e2;
        }(Yo), rr = { panStep: 100, bearingStep: 15, pitchStep: 10 }, ar = function() {
          var t4 = rr;
          this._panStep = t4.panStep, this._bearingStep = t4.bearingStep, this._pitchStep = t4.pitchStep, this._rotationDisabled = false;
        };
        function nr(t4) {
          return t4 * (2 - t4);
        }
        ar.prototype.blur = function() {
          this.reset();
        }, ar.prototype.reset = function() {
          this._active = false;
        }, ar.prototype.keydown = function(t4) {
          var e2 = this;
          if (!(t4.altKey || t4.ctrlKey || t4.metaKey)) {
            var i3 = 0, o2 = 0, r2 = 0, a2 = 0, n2 = 0;
            switch (t4.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                i3 = 1;
                break;
              case 189:
              case 109:
              case 173:
                i3 = -1;
                break;
              case 37:
                t4.shiftKey ? o2 = -1 : (t4.preventDefault(), a2 = -1);
                break;
              case 39:
                t4.shiftKey ? o2 = 1 : (t4.preventDefault(), a2 = 1);
                break;
              case 38:
                t4.shiftKey ? r2 = 1 : (t4.preventDefault(), n2 = -1);
                break;
              case 40:
                t4.shiftKey ? r2 = -1 : (t4.preventDefault(), n2 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (o2 = 0, r2 = 0), { cameraAnimation: function(s2) {
              var l2 = s2.getZoom();
              s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: nr, zoom: i3 ? Math.round(l2) + i3 * (t4.shiftKey ? 2 : 1) : l2, bearing: s2.getBearing() + o2 * e2._bearingStep, pitch: s2.getPitch() + r2 * e2._pitchStep, offset: [-a2 * e2._panStep, -n2 * e2._panStep], center: s2.getCenter() }, { originalEvent: t4 });
            } };
          }
        }, ar.prototype.enable = function() {
          this._enabled = true;
        }, ar.prototype.disable = function() {
          this._enabled = false, this.reset();
        }, ar.prototype.isEnabled = function() {
          return this._enabled;
        }, ar.prototype.isActive = function() {
          return this._active;
        }, ar.prototype.disableRotation = function() {
          this._rotationDisabled = true;
        }, ar.prototype.enableRotation = function() {
          this._rotationDisabled = false;
        };
        var sr = function(e2, i3) {
          this._map = e2, this._el = e2.getCanvasContainer(), this._handler = i3, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 1 / 450, t.bindAll(["_onTimeout"], this);
        };
        sr.prototype.setZoomRate = function(t4) {
          this._defaultZoomRate = t4;
        }, sr.prototype.setWheelZoomRate = function(t4) {
          this._wheelZoomRate = t4;
        }, sr.prototype.isEnabled = function() {
          return !!this._enabled;
        }, sr.prototype.isActive = function() {
          return !!this._active || void 0 !== this._finishTimeout;
        }, sr.prototype.isZooming = function() {
          return !!this._zooming;
        }, sr.prototype.enable = function(t4) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = t4 && "center" === t4.around);
        }, sr.prototype.disable = function() {
          this.isEnabled() && (this._enabled = false);
        }, sr.prototype.wheel = function(e2) {
          if (this.isEnabled()) {
            var i3 = e2.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY, o2 = t.browser.now(), r2 = o2 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o2, 0 !== i3 && i3 % 4.000244140625 == 0 ? this._type = "wheel" : 0 !== i3 && Math.abs(i3) < 4 ? this._type = "trackpad" : r2 > 400 ? (this._type = null, this._lastValue = i3, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(r2 * i3) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i3 += this._lastValue)), e2.shiftKey && i3 && (i3 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= i3, this._active || this._start(e2)), e2.preventDefault();
          }
        }, sr.prototype._onTimeout = function(t4) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t4);
        }, sr.prototype._start = function(e2) {
          if (this._delta) {
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            var o2 = i2.mousePos(this._el, e2);
            this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(o2)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
          }
        }, sr.prototype.renderFrame = function() {
          var e2 = this;
          if (this._frameId && (this._frameId = null, this.isActive())) {
            var i3 = this._map.transform;
            if (0 !== this._delta) {
              var o2 = "wheel" === this._type && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate, r2 = 2 / (1 + Math.exp(-Math.abs(this._delta * o2)));
              this._delta < 0 && 0 !== r2 && (r2 = 1 / r2);
              var a2 = "number" == typeof this._targetZoom ? i3.zoomScale(this._targetZoom) : i3.scale;
              this._targetZoom = Math.min(i3.maxZoom, Math.max(i3.minZoom, i3.scaleZoom(a2 * r2))), "wheel" === this._type && (this._startZoom = i3.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            var n2, s2 = "number" == typeof this._targetZoom ? this._targetZoom : i3.zoom, l2 = this._startZoom, c2 = this._easing, u2 = false;
            if ("wheel" === this._type && l2 && c2) {
              var h2 = Math.min((t.browser.now() - this._lastWheelEventTime) / 200, 1), p2 = c2(h2);
              n2 = t.number(l2, s2, p2), h2 < 1 ? this._frameId || (this._frameId = true) : u2 = true;
            } else
              n2 = s2, u2 = true;
            return this._active = true, u2 && (this._active = false, this._finishTimeout = setTimeout(function() {
              e2._zooming = false, e2._handler._triggerRenderFrame(), delete e2._targetZoom, delete e2._finishTimeout;
            }, 200)), { noInertia: true, needsRenderFrame: !u2, zoomDelta: n2 - i3.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
        }, sr.prototype._smoothOutEasing = function(e2) {
          var i3 = t.ease;
          if (this._prevEase) {
            var o2 = this._prevEase, r2 = (t.browser.now() - o2.start) / o2.duration, a2 = o2.easing(r2 + 0.01) - o2.easing(r2), n2 = 0.27 / Math.sqrt(a2 * a2 + 1e-4) * 0.01, s2 = Math.sqrt(0.0729 - n2 * n2);
            i3 = t.bezier(n2, s2, 0.25, 1);
          }
          return this._prevEase = { start: t.browser.now(), duration: e2, easing: i3 }, i3;
        }, sr.prototype.blur = function() {
          this.reset();
        }, sr.prototype.reset = function() {
          this._active = false;
        };
        var lr = function(t4, e2) {
          this._clickZoom = t4, this._tapZoom = e2;
        };
        lr.prototype.enable = function() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }, lr.prototype.disable = function() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }, lr.prototype.isEnabled = function() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }, lr.prototype.isActive = function() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        };
        var cr = function() {
          this.reset();
        };
        cr.prototype.reset = function() {
          this._active = false;
        }, cr.prototype.blur = function() {
          this.reset();
        }, cr.prototype.dblclick = function(t4, e2) {
          return t4.preventDefault(), { cameraAnimation: function(i3) {
            i3.easeTo({ duration: 300, zoom: i3.getZoom() + (t4.shiftKey ? -1 : 1), around: i3.unproject(e2) }, { originalEvent: t4 });
          } };
        }, cr.prototype.enable = function() {
          this._enabled = true;
        }, cr.prototype.disable = function() {
          this._enabled = false, this.reset();
        }, cr.prototype.isEnabled = function() {
          return this._enabled;
        }, cr.prototype.isActive = function() {
          return this._active;
        };
        var ur = function() {
          this._tap = new qo({ numTouches: 1, numTaps: 1 }), this.reset();
        };
        ur.prototype.reset = function() {
          this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
        }, ur.prototype.touchstart = function(t4, e2, i3) {
          this._swipePoint || (this._tapTime && t4.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i3.length > 0 && (this._swipePoint = e2[0], this._swipeTouch = i3[0].identifier) : this._tap.touchstart(t4, e2, i3));
        }, ur.prototype.touchmove = function(t4, e2, i3) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i3[0].identifier !== this._swipeTouch)
                return;
              var o2 = e2[0], r2 = o2.y - this._swipePoint.y;
              return this._swipePoint = o2, t4.preventDefault(), this._active = true, { zoomDelta: r2 / 128 };
            }
          } else
            this._tap.touchmove(t4, e2, i3);
        }, ur.prototype.touchend = function(t4, e2, i3) {
          this._tapTime ? this._swipePoint && 0 === i3.length && this.reset() : this._tap.touchend(t4, e2, i3) && (this._tapTime = t4.timeStamp);
        }, ur.prototype.touchcancel = function() {
          this.reset();
        }, ur.prototype.enable = function() {
          this._enabled = true;
        }, ur.prototype.disable = function() {
          this._enabled = false, this.reset();
        }, ur.prototype.isEnabled = function() {
          return this._enabled;
        }, ur.prototype.isActive = function() {
          return this._active;
        };
        var hr = function(t4, e2, i3) {
          this._el = t4, this._mousePan = e2, this._touchPan = i3;
        };
        hr.prototype.enable = function(t4) {
          this._inertiaOptions = t4 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }, hr.prototype.disable = function() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }, hr.prototype.isEnabled = function() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }, hr.prototype.isActive = function() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        };
        var pr = function(t4, e2, i3) {
          this._pitchWithRotate = t4.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i3;
        };
        pr.prototype.enable = function() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }, pr.prototype.disable = function() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }, pr.prototype.isEnabled = function() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }, pr.prototype.isActive = function() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        };
        var dr = function(t4, e2, i3, o2) {
          this._el = t4, this._touchZoom = e2, this._touchRotate = i3, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
        };
        dr.prototype.enable = function(t4) {
          this._touchZoom.enable(t4), this._rotationDisabled || this._touchRotate.enable(t4), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }, dr.prototype.disable = function() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }, dr.prototype.isEnabled = function() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }, dr.prototype.isActive = function() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }, dr.prototype.disableRotation = function() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }, dr.prototype.enableRotation = function() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        };
        var _r = function(t4) {
          return t4.zoom || t4.drag || t4.pitch || t4.rotate;
        }, fr = function(t4) {
          function e2() {
            t4.apply(this, arguments);
          }
          return t4 && (e2.__proto__ = t4), (e2.prototype = Object.create(t4 && t4.prototype)).constructor = e2, e2;
        }(t.Event);
        function mr(t4) {
          return t4.panDelta && t4.panDelta.mag() || t4.zoomDelta || t4.bearingDelta || t4.pitchDelta;
        }
        var gr = function(e2, o2) {
          this._map = e2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ao(e2), this._bearingSnap = o2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(o2), t.bindAll(["handleEvent", "handleWindowEvent"], this);
          var r2 = this._el;
          this._listeners = [[r2, "touchstart", { passive: true }], [r2, "touchmove", { passive: false }], [r2, "touchend", void 0], [r2, "touchcancel", void 0], [r2, "mousedown", void 0], [r2, "mousemove", void 0], [r2, "mouseup", void 0], [t.window.document, "mousemove", { capture: true }], [t.window.document, "mouseup", void 0], [r2, "mouseover", void 0], [r2, "mouseout", void 0], [r2, "dblclick", void 0], [r2, "click", void 0], [r2, "keydown", { capture: false }], [r2, "keyup", void 0], [r2, "wheel", { passive: false }], [r2, "contextmenu", void 0], [t.window, "blur", void 0]];
          for (var a2 = 0, n2 = this._listeners; a2 < n2.length; a2 += 1) {
            var s2 = n2[a2], l2 = s2[0];
            i2.addEventListener(l2, s2[1], l2 === t.window.document ? this.handleWindowEvent : this.handleEvent, s2[2]);
          }
        };
        gr.prototype.destroy = function() {
          for (var e2 = 0, o2 = this._listeners; e2 < o2.length; e2 += 1) {
            var r2 = o2[e2], a2 = r2[0];
            i2.removeEventListener(a2, r2[1], a2 === t.window.document ? this.handleWindowEvent : this.handleEvent, r2[2]);
          }
        }, gr.prototype._addDefaultHandlers = function(t4) {
          var e2 = this._map, i3 = e2.getCanvasContainer();
          this._add("mapEvent", new Oo(e2, t4));
          var o2 = e2.boxZoom = new Uo(e2, t4);
          this._add("boxZoom", o2);
          var r2 = new jo(), a2 = new cr();
          e2.doubleClickZoom = new lr(a2, r2), this._add("tapZoom", r2), this._add("clickZoom", a2);
          var n2 = new ur();
          this._add("tapDragZoom", n2);
          var s2 = e2.touchPitch = new or();
          this._add("touchPitch", s2);
          var l2 = new Xo(t4), c2 = new Ho(t4);
          e2.dragRotate = new pr(t4, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
          var u2 = new Wo(t4), h2 = new Ko(t4);
          e2.dragPan = new hr(i3, u2, h2), this._add("mousePan", u2), this._add("touchPan", h2, ["touchZoom", "touchRotate"]);
          var p2 = new er(), d2 = new $o();
          e2.touchZoomRotate = new dr(i3, d2, p2, n2), this._add("touchRotate", p2, ["touchPan", "touchZoom"]), this._add("touchZoom", d2, ["touchPan", "touchRotate"]);
          var _2 = e2.scrollZoom = new sr(e2, this);
          this._add("scrollZoom", _2, ["mousePan"]);
          var f2 = e2.keyboard = new ar();
          this._add("keyboard", f2), this._add("blockableMapEvent", new Fo(e2));
          for (var m2 = 0, g2 = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; m2 < g2.length; m2 += 1) {
            var v2 = g2[m2];
            t4.interactive && t4[v2] && e2[v2].enable(t4[v2]);
          }
        }, gr.prototype._add = function(t4, e2, i3) {
          this._handlers.push({ handlerName: t4, handler: e2, allowed: i3 }), this._handlersById[t4] = e2;
        }, gr.prototype.stop = function(t4) {
          if (!this._updatingCamera) {
            for (var e2 = 0, i3 = this._handlers; e2 < i3.length; e2 += 1)
              i3[e2].handler.reset();
            this._inertia.clear(), this._fireEvents({}, {}, t4), this._changes = [];
          }
        }, gr.prototype.isActive = function() {
          for (var t4 = 0, e2 = this._handlers; t4 < e2.length; t4 += 1)
            if (e2[t4].handler.isActive())
              return true;
          return false;
        }, gr.prototype.isZooming = function() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }, gr.prototype.isRotating = function() {
          return !!this._eventsInProgress.rotate;
        }, gr.prototype.isMoving = function() {
          return Boolean(_r(this._eventsInProgress)) || this.isZooming();
        }, gr.prototype._blockedByActive = function(t4, e2, i3) {
          for (var o2 in t4)
            if (o2 !== i3 && (!e2 || e2.indexOf(o2) < 0))
              return true;
          return false;
        }, gr.prototype.handleWindowEvent = function(t4) {
          this.handleEvent(t4, t4.type + "Window");
        }, gr.prototype._getMapTouches = function(t4) {
          for (var e2 = [], i3 = 0, o2 = t4; i3 < o2.length; i3 += 1) {
            var r2 = o2[i3];
            this._el.contains(r2.target) && e2.push(r2);
          }
          return e2;
        }, gr.prototype.handleEvent = function(t4, e2) {
          this._updatingCamera = true;
          for (var o2 = "renderFrame" === t4.type ? void 0 : t4, r2 = { needsRenderFrame: false }, a2 = {}, n2 = {}, s2 = t4.touches ? this._getMapTouches(t4.touches) : void 0, l2 = s2 ? i2.touchPos(this._el, s2) : i2.mousePos(this._el, t4), c2 = 0, u2 = this._handlers; c2 < u2.length; c2 += 1) {
            var h2 = u2[c2], p2 = h2.handlerName, d2 = h2.handler, _2 = h2.allowed;
            if (d2.isEnabled()) {
              var f2 = void 0;
              this._blockedByActive(n2, _2, p2) ? d2.reset() : d2[e2 || t4.type] && (f2 = d2[e2 || t4.type](t4, l2, s2), this.mergeHandlerResult(r2, a2, f2, p2, o2), f2 && f2.needsRenderFrame && this._triggerRenderFrame()), (f2 || d2.isActive()) && (n2[p2] = d2);
            }
          }
          var m2 = {};
          for (var g2 in this._previousActiveHandlers)
            n2[g2] || (m2[g2] = o2);
          this._previousActiveHandlers = n2, (Object.keys(m2).length || mr(r2)) && (this._changes.push([r2, a2, m2]), this._triggerRenderFrame()), (Object.keys(n2).length || mr(r2)) && this._map._stop(true), this._updatingCamera = false;
          var v2 = r2.cameraAnimation;
          v2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], v2(this._map));
        }, gr.prototype.mergeHandlerResult = function(e2, i3, o2, r2, a2) {
          if (o2) {
            t.extend(e2, o2);
            var n2 = { handlerName: r2, originalEvent: o2.originalEvent || a2 };
            void 0 !== o2.zoomDelta && (i3.zoom = n2), void 0 !== o2.panDelta && (i3.drag = n2), void 0 !== o2.pitchDelta && (i3.pitch = n2), void 0 !== o2.bearingDelta && (i3.rotate = n2);
          }
        }, gr.prototype._applyChanges = function() {
          for (var e2 = {}, i3 = {}, o2 = {}, r2 = 0, a2 = this._changes; r2 < a2.length; r2 += 1) {
            var n2 = a2[r2], s2 = n2[0], l2 = n2[1], c2 = n2[2];
            s2.panDelta && (e2.panDelta = (e2.panDelta || new t.Point(0, 0))._add(s2.panDelta)), s2.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + s2.zoomDelta), s2.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + s2.bearingDelta), s2.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + s2.pitchDelta), void 0 !== s2.around && (e2.around = s2.around), void 0 !== s2.pinchAround && (e2.pinchAround = s2.pinchAround), s2.noInertia && (e2.noInertia = s2.noInertia), t.extend(i3, l2), t.extend(o2, c2);
          }
          this._updateMapTransform(e2, i3, o2), this._changes = [];
        }, gr.prototype._updateMapTransform = function(t4, e2, i3) {
          var o2 = this._map, r2 = o2.transform;
          if (!mr(t4))
            return this._fireEvents(e2, i3, true);
          var a2 = t4.panDelta, n2 = t4.zoomDelta, s2 = t4.bearingDelta, l2 = t4.pitchDelta, c2 = t4.around, u2 = t4.pinchAround;
          void 0 !== u2 && (c2 = u2), o2._stop(true), c2 = c2 || o2.transform.centerPoint;
          var h2 = r2.pointLocation(a2 ? c2.sub(a2) : c2);
          s2 && (r2.bearing += s2), l2 && (r2.pitch += l2), n2 && (r2.zoom += n2), r2.setLocationAtPoint(h2, c2), this._map._update(), t4.noInertia || this._inertia.record(t4), this._fireEvents(e2, i3, true);
        }, gr.prototype._fireEvents = function(e2, i3, o2) {
          var r2 = this, a2 = _r(this._eventsInProgress), n2 = _r(e2), s2 = {};
          for (var l2 in e2)
            this._eventsInProgress[l2] || (s2[l2 + "start"] = e2[l2].originalEvent), this._eventsInProgress[l2] = e2[l2];
          for (var c2 in !a2 && n2 && this._fireEvent("movestart", n2.originalEvent), s2)
            this._fireEvent(c2, s2[c2]);
          for (var u2 in n2 && this._fireEvent("move", n2.originalEvent), e2)
            this._fireEvent(u2, e2[u2].originalEvent);
          var h2, p2 = {};
          for (var d2 in this._eventsInProgress) {
            var _2 = this._eventsInProgress[d2], f2 = _2.handlerName, m2 = _2.originalEvent;
            this._handlersById[f2].isActive() || (delete this._eventsInProgress[d2], p2[d2 + "end"] = h2 = i3[f2] || m2);
          }
          for (var g2 in p2)
            this._fireEvent(g2, p2[g2]);
          var v2 = _r(this._eventsInProgress);
          if (o2 && (a2 || n2) && !v2) {
            this._updatingCamera = true;
            var y2 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), x3 = function(t4) {
              return 0 !== t4 && -r2._bearingSnap < t4 && t4 < r2._bearingSnap;
            };
            y2 ? (x3(y2.bearing || this._map.getBearing()) && (y2.bearing = 0), this._map.easeTo(y2, { originalEvent: h2 })) : (this._map.fire(new t.Event("moveend", { originalEvent: h2 })), x3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
          }
        }, gr.prototype._fireEvent = function(e2, i3) {
          this._map.fire(new t.Event(e2, i3 ? { originalEvent: i3 } : {}));
        }, gr.prototype._requestFrame = function() {
          var t4 = this;
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add(function(e2) {
            delete t4._frameId, t4.handleEvent(new fr("renderFrame", { timeStamp: e2 })), t4._applyChanges();
          });
        }, gr.prototype._triggerRenderFrame = function() {
          void 0 === this._frameId && (this._frameId = this._requestFrame());
        };
        var vr = function(e2) {
          function i3(i4, o2) {
            e2.call(this), this._moving = false, this._zooming = false, this.transform = i4, this._bearingSnap = o2.bearingSnap, t.bindAll(["_renderFrameCallback"], this);
          }
          return e2 && (i3.__proto__ = e2), (i3.prototype = Object.create(e2 && e2.prototype)).constructor = i3, i3.prototype.getCenter = function() {
            return new t.LngLat(this.transform.center.lng, this.transform.center.lat);
          }, i3.prototype.setCenter = function(t4, e3) {
            return this.jumpTo({ center: t4 }, e3);
          }, i3.prototype.panBy = function(e3, i4, o2) {
            return e3 = t.Point.convert(e3).mult(-1), this.panTo(this.transform.center, t.extend({ offset: e3 }, i4), o2);
          }, i3.prototype.panTo = function(e3, i4, o2) {
            return this.easeTo(t.extend({ center: e3 }, i4), o2);
          }, i3.prototype.getZoom = function() {
            return this.transform.zoom;
          }, i3.prototype.setZoom = function(t4, e3) {
            return this.jumpTo({ zoom: t4 }, e3), this;
          }, i3.prototype.zoomTo = function(e3, i4, o2) {
            return this.easeTo(t.extend({ zoom: e3 }, i4), o2);
          }, i3.prototype.zoomIn = function(t4, e3) {
            return this.zoomTo(this.getZoom() + 1, t4, e3), this;
          }, i3.prototype.zoomOut = function(t4, e3) {
            return this.zoomTo(this.getZoom() - 1, t4, e3), this;
          }, i3.prototype.getBearing = function() {
            return this.transform.bearing;
          }, i3.prototype.setBearing = function(t4, e3) {
            return this.jumpTo({ bearing: t4 }, e3), this;
          }, i3.prototype.getPadding = function() {
            return this.transform.padding;
          }, i3.prototype.setPadding = function(t4, e3) {
            return this.jumpTo({ padding: t4 }, e3), this;
          }, i3.prototype.rotateTo = function(e3, i4, o2) {
            return this.easeTo(t.extend({ bearing: e3 }, i4), o2);
          }, i3.prototype.resetNorth = function(e3, i4) {
            return this.rotateTo(0, t.extend({ duration: 1e3 }, e3), i4), this;
          }, i3.prototype.resetNorthPitch = function(e3, i4) {
            return this.easeTo(t.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e3), i4), this;
          }, i3.prototype.snapToNorth = function(t4, e3) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t4, e3) : this;
          }, i3.prototype.getPitch = function() {
            return this.transform.pitch;
          }, i3.prototype.setPitch = function(t4, e3) {
            return this.jumpTo({ pitch: t4 }, e3), this;
          }, i3.prototype.cameraForBounds = function(e3, i4) {
            e3 = t.LngLatBounds.convert(e3);
            var o2 = i4 && i4.bearing || 0;
            return this._cameraForBoxAndBearing(e3.getNorthWest(), e3.getSouthEast(), o2, i4);
          }, i3.prototype._cameraForBoxAndBearing = function(e3, i4, o2, r2) {
            var a2 = { top: 0, bottom: 0, right: 0, left: 0 };
            if ("number" == typeof (r2 = t.extend({ padding: a2, offset: [0, 0], maxZoom: this.transform.maxZoom }, r2)).padding) {
              var n2 = r2.padding;
              r2.padding = { top: n2, bottom: n2, right: n2, left: n2 };
            }
            r2.padding = t.extend(a2, r2.padding);
            var s2 = this.transform, l2 = s2.padding, c2 = s2.project(t.LngLat.convert(e3)), u2 = s2.project(t.LngLat.convert(i4)), h2 = c2.rotate(-o2 * Math.PI / 180), p2 = u2.rotate(-o2 * Math.PI / 180), d2 = new t.Point(Math.max(h2.x, p2.x), Math.max(h2.y, p2.y)), _2 = new t.Point(Math.min(h2.x, p2.x), Math.min(h2.y, p2.y)), f2 = d2.sub(_2), m2 = (s2.width - (l2.left + l2.right + r2.padding.left + r2.padding.right)) / f2.x, g2 = (s2.height - (l2.top + l2.bottom + r2.padding.top + r2.padding.bottom)) / f2.y;
            if (!(g2 < 0 || m2 < 0)) {
              var v2 = Math.min(s2.scaleZoom(s2.scale * Math.min(m2, g2)), r2.maxZoom), y2 = "number" == typeof r2.offset.x ? new t.Point(r2.offset.x, r2.offset.y) : t.Point.convert(r2.offset), x3 = new t.Point((r2.padding.left - r2.padding.right) / 2, (r2.padding.top - r2.padding.bottom) / 2).rotate(o2 * Math.PI / 180), b2 = y2.add(x3).mult(s2.scale / s2.zoomScale(v2));
              return { center: s2.unproject(c2.add(u2).div(2).sub(b2)), zoom: v2, bearing: o2 };
            }
            t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          }, i3.prototype.fitBounds = function(t4, e3, i4) {
            return this._fitInternal(this.cameraForBounds(t4, e3), e3, i4);
          }, i3.prototype.fitScreenCoordinates = function(e3, i4, o2, r2, a2) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.Point.convert(e3)), this.transform.pointLocation(t.Point.convert(i4)), o2, r2), r2, a2);
          }, i3.prototype._fitInternal = function(e3, i4, o2) {
            return e3 ? (delete (i4 = t.extend(e3, i4)).padding, i4.linear ? this.easeTo(i4, o2) : this.flyTo(i4, o2)) : this;
          }, i3.prototype.jumpTo = function(e3, i4) {
            this.stop();
            var o2 = this.transform, r2 = false, a2 = false, n2 = false;
            return "zoom" in e3 && o2.zoom !== +e3.zoom && (r2 = true, o2.zoom = +e3.zoom), void 0 !== e3.center && (o2.center = t.LngLat.convert(e3.center)), "bearing" in e3 && o2.bearing !== +e3.bearing && (a2 = true, o2.bearing = +e3.bearing), "pitch" in e3 && o2.pitch !== +e3.pitch && (n2 = true, o2.pitch = +e3.pitch), null == e3.padding || o2.isPaddingEqual(e3.padding) || (o2.padding = e3.padding), this.fire(new t.Event("movestart", i4)).fire(new t.Event("move", i4)), r2 && this.fire(new t.Event("zoomstart", i4)).fire(new t.Event("zoom", i4)).fire(new t.Event("zoomend", i4)), a2 && this.fire(new t.Event("rotatestart", i4)).fire(new t.Event("rotate", i4)).fire(new t.Event("rotateend", i4)), n2 && this.fire(new t.Event("pitchstart", i4)).fire(new t.Event("pitch", i4)).fire(new t.Event("pitchend", i4)), this.fire(new t.Event("moveend", i4));
          }, i3.prototype.easeTo = function(e3, i4) {
            var o2 = this;
            this._stop(false, e3.easeId), (false === (e3 = t.extend({ offset: [0, 0], duration: 500, easing: t.ease }, e3)).animate || !e3.essential && t.browser.prefersReducedMotion) && (e3.duration = 0);
            var r2 = this.transform, a2 = this.getZoom(), n2 = this.getBearing(), s2 = this.getPitch(), l2 = this.getPadding(), c2 = "zoom" in e3 ? +e3.zoom : a2, u2 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, n2) : n2, h2 = "pitch" in e3 ? +e3.pitch : s2, p2 = "padding" in e3 ? e3.padding : r2.padding, d2 = t.Point.convert(e3.offset), _2 = r2.centerPoint.add(d2), f2 = r2.pointLocation(_2), m2 = t.LngLat.convert(e3.center || f2);
            this._normalizeCenter(m2);
            var g2, v2, y2 = r2.project(f2), x3 = r2.project(m2).sub(y2), b2 = r2.zoomScale(c2 - a2);
            e3.around && (g2 = t.LngLat.convert(e3.around), v2 = r2.locationPoint(g2));
            var w2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = this._zooming || c2 !== a2, this._rotating = this._rotating || n2 !== u2, this._pitching = this._pitching || h2 !== s2, this._padding = !r2.isPaddingEqual(p2), this._easeId = e3.easeId, this._prepareEase(i4, e3.noMoveStart, w2), this._ease(function(e4) {
              if (o2._zooming && (r2.zoom = t.number(a2, c2, e4)), o2._rotating && (r2.bearing = t.number(n2, u2, e4)), o2._pitching && (r2.pitch = t.number(s2, h2, e4)), o2._padding && (r2.interpolatePadding(l2, p2, e4), _2 = r2.centerPoint.add(d2)), g2)
                r2.setLocationAtPoint(g2, v2);
              else {
                var f3 = r2.zoomScale(r2.zoom - a2), m3 = c2 > a2 ? Math.min(2, b2) : Math.max(0.5, b2), w3 = Math.pow(m3, 1 - e4), T3 = r2.unproject(y2.add(x3.mult(e4 * w3)).mult(f3));
                r2.setLocationAtPoint(r2.renderWorldCopies ? T3.wrap() : T3, _2);
              }
              o2._fireMoveEvents(i4);
            }, function(t4) {
              o2._afterEase(i4, t4);
            }, e3), this;
          }, i3.prototype._prepareEase = function(e3, i4, o2) {
            void 0 === o2 && (o2 = {}), this._moving = true, i4 || o2.moving || this.fire(new t.Event("movestart", e3)), this._zooming && !o2.zooming && this.fire(new t.Event("zoomstart", e3)), this._rotating && !o2.rotating && this.fire(new t.Event("rotatestart", e3)), this._pitching && !o2.pitching && this.fire(new t.Event("pitchstart", e3));
          }, i3.prototype._fireMoveEvents = function(e3) {
            this.fire(new t.Event("move", e3)), this._zooming && this.fire(new t.Event("zoom", e3)), this._rotating && this.fire(new t.Event("rotate", e3)), this._pitching && this.fire(new t.Event("pitch", e3));
          }, i3.prototype._afterEase = function(e3, i4) {
            if (!this._easeId || !i4 || this._easeId !== i4) {
              delete this._easeId;
              var o2 = this._zooming, r2 = this._rotating, a2 = this._pitching;
              this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new t.Event("zoomend", e3)), r2 && this.fire(new t.Event("rotateend", e3)), a2 && this.fire(new t.Event("pitchend", e3)), this.fire(new t.Event("moveend", e3));
            }
          }, i3.prototype.flyTo = function(e3, i4) {
            var o2 = this;
            if (!e3.essential && t.browser.prefersReducedMotion) {
              var r2 = t.pick(e3, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(r2, i4);
            }
            this.stop(), e3 = t.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.ease }, e3);
            var a2 = this.transform, n2 = this.getZoom(), s2 = this.getBearing(), l2 = this.getPitch(), c2 = this.getPadding(), u2 = "zoom" in e3 ? t.clamp(+e3.zoom, a2.minZoom, a2.maxZoom) : n2, h2 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, s2) : s2, p2 = "pitch" in e3 ? +e3.pitch : l2, d2 = "padding" in e3 ? e3.padding : a2.padding, _2 = a2.zoomScale(u2 - n2), f2 = t.Point.convert(e3.offset), m2 = a2.centerPoint.add(f2), g2 = a2.pointLocation(m2), v2 = t.LngLat.convert(e3.center || g2);
            this._normalizeCenter(v2);
            var y2 = a2.project(g2), x3 = a2.project(v2).sub(y2), b2 = e3.curve, w2 = Math.max(a2.width, a2.height), T3 = w2 / _2, E3 = x3.mag();
            if ("minZoom" in e3) {
              var I2 = t.clamp(Math.min(e3.minZoom, n2, u2), a2.minZoom, a2.maxZoom), P2 = w2 / a2.zoomScale(I2 - n2);
              b2 = Math.sqrt(P2 / E3 * 2);
            }
            var S2 = b2 * b2;
            function C3(t4) {
              var e4 = (T3 * T3 - w2 * w2 + (t4 ? -1 : 1) * S2 * S2 * E3 * E3) / (2 * (t4 ? T3 : w2) * S2 * E3);
              return Math.log(Math.sqrt(e4 * e4 + 1) - e4);
            }
            function z2(t4) {
              return (Math.exp(t4) - Math.exp(-t4)) / 2;
            }
            function D3(t4) {
              return (Math.exp(t4) + Math.exp(-t4)) / 2;
            }
            var A3 = C3(0), M2 = function(t4) {
              return D3(A3) / D3(A3 + b2 * t4);
            }, L3 = function(t4) {
              return w2 * ((D3(A3) * (z2(e4 = A3 + b2 * t4) / D3(e4)) - z2(A3)) / S2) / E3;
              var e4;
            }, R2 = (C3(1) - A3) / b2;
            if (Math.abs(E3) < 1e-6 || !isFinite(R2)) {
              if (Math.abs(w2 - T3) < 1e-6)
                return this.easeTo(e3, i4);
              var k2 = T3 < w2 ? -1 : 1;
              R2 = Math.abs(Math.log(T3 / w2)) / b2, L3 = function() {
                return 0;
              }, M2 = function(t4) {
                return Math.exp(k2 * b2 * t4);
              };
            }
            return e3.duration = "duration" in e3 ? +e3.duration : 1e3 * R2 / ("screenSpeed" in e3 ? +e3.screenSpeed / b2 : +e3.speed), e3.maxDuration && e3.duration > e3.maxDuration && (e3.duration = 0), this._zooming = true, this._rotating = s2 !== h2, this._pitching = p2 !== l2, this._padding = !a2.isPaddingEqual(d2), this._prepareEase(i4, false), this._ease(function(e4) {
              var r3 = e4 * R2, _3 = 1 / M2(r3);
              a2.zoom = 1 === e4 ? u2 : n2 + a2.scaleZoom(_3), o2._rotating && (a2.bearing = t.number(s2, h2, e4)), o2._pitching && (a2.pitch = t.number(l2, p2, e4)), o2._padding && (a2.interpolatePadding(c2, d2, e4), m2 = a2.centerPoint.add(f2));
              var g3 = 1 === e4 ? v2 : a2.unproject(y2.add(x3.mult(L3(r3))).mult(_3));
              a2.setLocationAtPoint(a2.renderWorldCopies ? g3.wrap() : g3, m2), o2._fireMoveEvents(i4);
            }, function() {
              return o2._afterEase(i4);
            }, e3), this;
          }, i3.prototype.isEasing = function() {
            return !!this._easeFrameId;
          }, i3.prototype.stop = function() {
            return this._stop();
          }, i3.prototype._stop = function(t4, e3) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              var i4 = this._onEaseEnd;
              delete this._onEaseEnd, i4.call(this, e3);
            }
            if (!t4) {
              var o2 = this.handlers;
              o2 && o2.stop(false);
            }
            return this;
          }, i3.prototype._ease = function(e3, i4, o2) {
            false === o2.animate || 0 === o2.duration ? (e3(1), i4()) : (this._easeStart = t.browser.now(), this._easeOptions = o2, this._onEaseFrame = e3, this._onEaseEnd = i4, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }, i3.prototype._renderFrameCallback = function() {
            var e3 = Math.min((t.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, i3.prototype._normalizeBearing = function(e3, i4) {
            e3 = t.wrap(e3, -180, 180);
            var o2 = Math.abs(e3 - i4);
            return Math.abs(e3 - 360 - i4) < o2 && (e3 -= 360), Math.abs(e3 + 360 - i4) < o2 && (e3 += 360), e3;
          }, i3.prototype._normalizeCenter = function(t4) {
            var e3 = this.transform;
            if (e3.renderWorldCopies && !e3.lngRange) {
              var i4 = t4.lng - e3.center.lng;
              t4.lng += i4 > 180 ? -360 : i4 < -180 ? 360 : 0;
            }
          }, i3;
        }(t.Evented), yr = function(e2) {
          void 0 === e2 && (e2 = {}), this.options = e2, t.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        };
        yr.prototype.getDefaultPosition = function() {
          return "bottom-right";
        }, yr.prototype.onAdd = function(t4) {
          var e2 = this.options && this.options.compact;
          return this._map = t4, this._container = i2.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = i2.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = i2.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), e2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === e2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }, yr.prototype.onRemove = function() {
          i2.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }, yr.prototype._setElementTitle = function(t4, e2) {
          var i3 = this._map._getUIString("AttributionControl." + e2);
          t4.title = i3, t4.setAttribute("aria-label", i3);
        }, yr.prototype._toggleAttribution = function() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));
        }, yr.prototype._updateEditLink = function() {
          var e2 = this._editLink;
          e2 || (e2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          var i3 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN }];
          if (e2) {
            var o2 = i3.reduce(function(t4, e3, o3) {
              return e3.value && (t4 += e3.key + "=" + e3.value + (o3 < i3.length - 1 ? "&" : "")), t4;
            }, "?");
            e2.href = t.config.FEEDBACK_URL + "/" + o2 + (this._map._hash ? this._map._hash.getHashString(true) : ""), e2.rel = "noopener nofollow", this._setElementTitle(e2, "MapFeedback");
          }
        }, yr.prototype._updateData = function(t4) {
          !t4 || "metadata" !== t4.sourceDataType && "visibility" !== t4.sourceDataType && "style" !== t4.dataType || (this._updateAttributions(), this._updateEditLink());
        }, yr.prototype._updateAttributions = function() {
          if (this._map.style) {
            var t4 = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t4 = t4.concat(this.options.customAttribution.map(function(t5) {
              return "string" != typeof t5 ? "" : t5;
            })) : "string" == typeof this.options.customAttribution && t4.push(this.options.customAttribution)), this._map.style.stylesheet) {
              var e2 = this._map.style.stylesheet;
              this.styleOwner = e2.owner, this.styleId = e2.id;
            }
            var i3 = this._map.style.sourceCaches;
            for (var o2 in i3) {
              var r2 = i3[o2];
              if (r2.used) {
                var a2 = r2.getSource();
                a2.attribution && t4.indexOf(a2.attribution) < 0 && t4.push(a2.attribution);
              }
            }
            t4.sort(function(t5, e3) {
              return t5.length - e3.length;
            });
            var n2 = (t4 = t4.filter(function(e3, i4) {
              for (var o3 = i4 + 1; o3 < t4.length; o3++)
                if (t4[o3].indexOf(e3) >= 0)
                  return false;
              return true;
            })).join(" | ");
            n2 !== this._attribHTML && (this._attribHTML = n2, t4.length ? (this._innerContainer.innerHTML = n2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
          }
        }, yr.prototype._updateCompact = function() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        };
        var xr = function() {
          t.bindAll(["_updateLogo"], this), t.bindAll(["_updateCompact"], this);
        };
        xr.prototype.onAdd = function(t4) {
          this._map = t4, this._container = i2.create("div", "mapboxgl-ctrl");
          var e2 = i2.create("a", "mapboxgl-ctrl-logo");
          return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://www.mapbox.com/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }, xr.prototype.onRemove = function() {
          i2.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }, xr.prototype.getDefaultPosition = function() {
          return "bottom-left";
        }, xr.prototype._updateLogo = function(t4) {
          t4 && "metadata" !== t4.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }, xr.prototype._logoRequired = function() {
          if (this._map.style) {
            var t4 = this._map.style.sourceCaches;
            for (var e2 in t4)
              if (t4[e2].getSource().mapbox_logo)
                return true;
            return false;
          }
        }, xr.prototype._updateCompact = function() {
          var t4 = this._container.children;
          if (t4.length) {
            var e2 = t4[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? e2.classList.add("mapboxgl-compact") : e2.classList.remove("mapboxgl-compact");
          }
        };
        var br = function() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        };
        br.prototype.add = function(t4) {
          var e2 = ++this._id;
          return this._queue.push({ callback: t4, id: e2, cancelled: false }), e2;
        }, br.prototype.remove = function(t4) {
          for (var e2 = this._currentlyRunning, i3 = 0, o2 = e2 ? this._queue.concat(e2) : this._queue; i3 < o2.length; i3 += 1) {
            var r2 = o2[i3];
            if (r2.id === t4)
              return void (r2.cancelled = true);
          }
        }, br.prototype.run = function(t4) {
          void 0 === t4 && (t4 = 0);
          var e2 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (var i3 = 0, o2 = e2; i3 < o2.length; i3 += 1) {
            var r2 = o2[i3];
            if (!r2.cancelled && (r2.callback(t4), this._cleared))
              break;
          }
          this._cleared = false, this._currentlyRunning = false;
        }, br.prototype.clear = function() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        };
        var wr = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, Tr = t.window.HTMLImageElement, Er = t.window.HTMLElement, Ir = t.window.ImageBitmap, Pr = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: true }, Sr = function(o2) {
          function r2(e2) {
            var i3 = this;
            if (null != (e2 = t.extend({}, Pr, e2)).minZoom && null != e2.maxZoom && e2.minZoom > e2.maxZoom)
              throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != e2.minPitch && null != e2.maxPitch && e2.minPitch > e2.maxPitch)
              throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != e2.minPitch && e2.minPitch < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (null != e2.maxPitch && e2.maxPitch > 60)
              throw new Error("maxPitch must be less than or equal to 60");
            var r3 = new To(e2.minZoom, e2.maxZoom, e2.minPitch, e2.maxPitch, e2.renderWorldCopies);
            if (o2.call(this, r3, e2), this._interactive = e2.interactive, this._maxTileCacheSize = e2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e2.preserveDrawingBuffer, this._antialias = e2.antialias, this._trackResize = e2.trackResize, this._bearingSnap = e2.bearingSnap, this._refreshExpiredTiles = e2.refreshExpiredTiles, this._fadeDuration = e2.fadeDuration, this._crossSourceCollisions = e2.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e2.collectResourceTiming, this._renderTaskQueue = new br(), this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, wr, e2.locale), this._clickTolerance = e2.clickTolerance, this._requestManager = new t.RequestManager(e2.transformRequest, e2.accessToken), "string" == typeof e2.container) {
              if (this._container = t.window.document.getElementById(e2.container), !this._container)
                throw new Error("Container '" + e2.container + "' not found.");
            } else {
              if (!(e2.container instanceof Er))
                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = e2.container;
            }
            if (e2.maxBounds && this.setMaxBounds(e2.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter)
              throw new Error("Failed to initialize WebGL.");
            this.on("move", function() {
              return i3._update(false);
            }), this.on("moveend", function() {
              return i3._update(false);
            }), this.on("zoom", function() {
              return i3._update(true);
            }), void 0 !== t.window && (t.window.addEventListener("online", this._onWindowOnline, false), t.window.addEventListener("resize", this._onWindowResize, false), t.window.addEventListener("orientationchange", this._onWindowResize, false)), this.handlers = new gr(this, e2), this._hash = e2.hash && new Io("string" == typeof e2.hash && e2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e2.center, zoom: e2.zoom, bearing: e2.bearing, pitch: e2.pitch }), e2.bounds && (this.resize(), this.fitBounds(e2.bounds, t.extend({}, e2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e2.localIdeographFontFamily, e2.style && this.setStyle(e2.style, { localIdeographFontFamily: e2.localIdeographFontFamily }), e2.attributionControl && this.addControl(new yr({ customAttribution: e2.customAttribution })), this.addControl(new xr(), e2.logoPosition), this.on("style.load", function() {
              i3.transform.unmodified && i3.jumpTo(i3.style.stylesheet);
            }), this.on("data", function(e3) {
              i3._update("style" === e3.dataType), i3.fire(new t.Event(e3.dataType + "data", e3));
            }), this.on("dataloading", function(e3) {
              i3.fire(new t.Event(e3.dataType + "dataloading", e3));
            });
          }
          o2 && (r2.__proto__ = o2), (r2.prototype = Object.create(o2 && o2.prototype)).constructor = r2;
          var a2 = { showTileBoundaries: { configurable: true }, showPadding: { configurable: true }, showCollisionBoxes: { configurable: true }, showOverdrawInspector: { configurable: true }, repaint: { configurable: true }, vertices: { configurable: true }, version: { configurable: true } };
          return r2.prototype._getMapId = function() {
            return this._mapId;
          }, r2.prototype.addControl = function(e2, i3) {
            if (void 0 === i3 && (i3 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd)
              return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            var o3 = e2.onAdd(this);
            this._controls.push(e2);
            var r3 = this._controlPositions[i3];
            return -1 !== i3.indexOf("bottom") ? r3.insertBefore(o3, r3.firstChild) : r3.appendChild(o3), this;
          }, r2.prototype.removeControl = function(e2) {
            if (!e2 || !e2.onRemove)
              return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            var i3 = this._controls.indexOf(e2);
            return i3 > -1 && this._controls.splice(i3, 1), e2.onRemove(this), this;
          }, r2.prototype.hasControl = function(t4) {
            return this._controls.indexOf(t4) > -1;
          }, r2.prototype.resize = function(e2) {
            var i3 = this._containerDimensions(), o3 = i3[0], r3 = i3[1];
            if (o3 === this.transform.width && r3 === this.transform.height)
              return this;
            this._resizeCanvas(o3, r3), this.transform.resize(o3, r3), this.painter.resize(o3, r3);
            var a3 = !this._moving;
            return a3 && this.fire(new t.Event("movestart", e2)).fire(new t.Event("move", e2)), this.fire(new t.Event("resize", e2)), a3 && this.fire(new t.Event("moveend", e2)), this;
          }, r2.prototype.getBounds = function() {
            return this.transform.getBounds();
          }, r2.prototype.getMaxBounds = function() {
            return this.transform.getMaxBounds();
          }, r2.prototype.setMaxBounds = function(e2) {
            return this.transform.setMaxBounds(t.LngLatBounds.convert(e2)), this._update();
          }, r2.prototype.setMinZoom = function(t4) {
            if ((t4 = null == t4 ? -2 : t4) >= -2 && t4 <= this.transform.maxZoom)
              return this.transform.minZoom = t4, this._update(), this.getZoom() < t4 && this.setZoom(t4), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }, r2.prototype.getMinZoom = function() {
            return this.transform.minZoom;
          }, r2.prototype.setMaxZoom = function(t4) {
            if ((t4 = null == t4 ? 22 : t4) >= this.transform.minZoom)
              return this.transform.maxZoom = t4, this._update(), this.getZoom() > t4 && this.setZoom(t4), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }, r2.prototype.getMaxZoom = function() {
            return this.transform.maxZoom;
          }, r2.prototype.setMinPitch = function(t4) {
            if ((t4 = null == t4 ? 0 : t4) < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (t4 >= 0 && t4 <= this.transform.maxPitch)
              return this.transform.minPitch = t4, this._update(), this.getPitch() < t4 && this.setPitch(t4), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }, r2.prototype.getMinPitch = function() {
            return this.transform.minPitch;
          }, r2.prototype.setMaxPitch = function(t4) {
            if ((t4 = null == t4 ? 60 : t4) > 60)
              throw new Error("maxPitch must be less than or equal to 60");
            if (t4 >= this.transform.minPitch)
              return this.transform.maxPitch = t4, this._update(), this.getPitch() > t4 && this.setPitch(t4), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }, r2.prototype.getMaxPitch = function() {
            return this.transform.maxPitch;
          }, r2.prototype.getRenderWorldCopies = function() {
            return this.transform.renderWorldCopies;
          }, r2.prototype.setRenderWorldCopies = function(t4) {
            return this.transform.renderWorldCopies = t4, this._update();
          }, r2.prototype.project = function(e2) {
            return this.transform.locationPoint(t.LngLat.convert(e2));
          }, r2.prototype.unproject = function(e2) {
            return this.transform.pointLocation(t.Point.convert(e2));
          }, r2.prototype.isMoving = function() {
            return this._moving || this.handlers.isMoving();
          }, r2.prototype.isZooming = function() {
            return this._zooming || this.handlers.isZooming();
          }, r2.prototype.isRotating = function() {
            return this._rotating || this.handlers.isRotating();
          }, r2.prototype._createDelegatedListener = function(t4, e2, i3) {
            var o3, r3 = this;
            if ("mouseenter" === t4 || "mouseover" === t4) {
              var a3 = false;
              return { layer: e2, listener: i3, delegates: { mousemove: function(o4) {
                var n3 = r3.getLayer(e2) ? r3.queryRenderedFeatures(o4.point, { layers: [e2] }) : [];
                n3.length ? a3 || (a3 = true, i3.call(r3, new Ro(t4, r3, o4.originalEvent, { features: n3 }))) : a3 = false;
              }, mouseout: function() {
                a3 = false;
              } } };
            }
            if ("mouseleave" === t4 || "mouseout" === t4) {
              var n2 = false;
              return { layer: e2, listener: i3, delegates: { mousemove: function(o4) {
                (r3.getLayer(e2) ? r3.queryRenderedFeatures(o4.point, { layers: [e2] }) : []).length ? n2 = true : n2 && (n2 = false, i3.call(r3, new Ro(t4, r3, o4.originalEvent)));
              }, mouseout: function(e3) {
                n2 && (n2 = false, i3.call(r3, new Ro(t4, r3, e3.originalEvent)));
              } } };
            }
            return { layer: e2, listener: i3, delegates: (o3 = {}, o3[t4] = function(t5) {
              var o4 = r3.getLayer(e2) ? r3.queryRenderedFeatures(t5.point, { layers: [e2] }) : [];
              o4.length && (t5.features = o4, i3.call(r3, t5), delete t5.features);
            }, o3) };
          }, r2.prototype.on = function(t4, e2, i3) {
            if (void 0 === i3)
              return o2.prototype.on.call(this, t4, e2);
            var r3 = this._createDelegatedListener(t4, e2, i3);
            for (var a3 in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t4] = this._delegatedListeners[t4] || [], this._delegatedListeners[t4].push(r3), r3.delegates)
              this.on(a3, r3.delegates[a3]);
            return this;
          }, r2.prototype.once = function(t4, e2, i3) {
            if (void 0 === i3)
              return o2.prototype.once.call(this, t4, e2);
            var r3 = this._createDelegatedListener(t4, e2, i3);
            for (var a3 in r3.delegates)
              this.once(a3, r3.delegates[a3]);
            return this;
          }, r2.prototype.off = function(t4, e2, i3) {
            var r3 = this;
            return void 0 === i3 ? o2.prototype.off.call(this, t4, e2) : (this._delegatedListeners && this._delegatedListeners[t4] && function(o3) {
              for (var a3 = o3[t4], n2 = 0; n2 < a3.length; n2++) {
                var s2 = a3[n2];
                if (s2.layer === e2 && s2.listener === i3) {
                  for (var l2 in s2.delegates)
                    r3.off(l2, s2.delegates[l2]);
                  return a3.splice(n2, 1), r3;
                }
              }
            }(this._delegatedListeners), this);
          }, r2.prototype.queryRenderedFeatures = function(e2, i3) {
            if (!this.style)
              return [];
            var o3;
            if (void 0 !== i3 || void 0 === e2 || e2 instanceof t.Point || Array.isArray(e2) || (i3 = e2, e2 = void 0), i3 = i3 || {}, (e2 = e2 || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.Point || "number" == typeof e2[0])
              o3 = [t.Point.convert(e2)];
            else {
              var r3 = t.Point.convert(e2[0]), a3 = t.Point.convert(e2[1]);
              o3 = [r3, new t.Point(a3.x, r3.y), a3, new t.Point(r3.x, a3.y), r3];
            }
            return this.style.queryRenderedFeatures(o3, i3, this.transform);
          }, r2.prototype.querySourceFeatures = function(t4, e2) {
            return this.style.querySourceFeatures(t4, e2);
          }, r2.prototype.setStyle = function(e2, i3) {
            return false !== (i3 = t.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, i3)).diff && i3.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i3), this) : (this._localIdeographFontFamily = i3.localIdeographFontFamily, this._updateStyle(e2, i3));
          }, r2.prototype._getUIString = function(t4) {
            var e2 = this._locale[t4];
            if (null == e2)
              throw new Error("Missing UI string '" + t4 + "'");
            return e2;
          }, r2.prototype._updateStyle = function(t4, e2) {
            return this.style && (this.style.setEventedParent(null), this.style._remove()), t4 ? (this.style = new je(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t4 ? this.style.loadURL(t4) : this.style.loadJSON(t4), this) : (delete this.style, this);
          }, r2.prototype._lazyInitEmptyStyle = function() {
            this.style || (this.style = new je(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }, r2.prototype._diffStyle = function(e2, i3) {
            var o3 = this;
            if ("string" == typeof e2) {
              var r3 = this._requestManager.normalizeStyleURL(e2), a3 = this._requestManager.transformRequest(r3, t.ResourceType.Style);
              t.getJSON(a3, function(e3, r4) {
                e3 ? o3.fire(new t.ErrorEvent(e3)) : r4 && o3._updateDiff(r4, i3);
              });
            } else
              "object" == typeof e2 && this._updateDiff(e2, i3);
          }, r2.prototype._updateDiff = function(e2, i3) {
            try {
              this.style.setState(e2) && this._update(true);
            } catch (o3) {
              t.warnOnce("Unable to perform style diff: " + (o3.message || o3.error || o3) + ".  Rebuilding the style from scratch."), this._updateStyle(e2, i3);
            }
          }, r2.prototype.getStyle = function() {
            if (this.style)
              return this.style.serialize();
          }, r2.prototype.isStyleLoaded = function() {
            return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.");
          }, r2.prototype.addSource = function(t4, e2) {
            return this._lazyInitEmptyStyle(), this.style.addSource(t4, e2), this._update(true);
          }, r2.prototype.isSourceLoaded = function(e2) {
            var i3 = this.style && this.style.sourceCaches[e2];
            if (void 0 !== i3)
              return i3.loaded();
            this.fire(new t.ErrorEvent(new Error("There is no source with ID '" + e2 + "'")));
          }, r2.prototype.areTilesLoaded = function() {
            var t4 = this.style && this.style.sourceCaches;
            for (var e2 in t4) {
              var i3 = t4[e2]._tiles;
              for (var o3 in i3) {
                var r3 = i3[o3];
                if ("loaded" !== r3.state && "errored" !== r3.state)
                  return false;
              }
            }
            return true;
          }, r2.prototype.addSourceType = function(t4, e2, i3) {
            return this._lazyInitEmptyStyle(), this.style.addSourceType(t4, e2, i3);
          }, r2.prototype.removeSource = function(t4) {
            return this.style.removeSource(t4), this._update(true);
          }, r2.prototype.getSource = function(t4) {
            return this.style.getSource(t4);
          }, r2.prototype.addImage = function(e2, i3, o3) {
            void 0 === o3 && (o3 = {});
            var r3 = o3.pixelRatio;
            void 0 === r3 && (r3 = 1);
            var a3 = o3.sdf;
            void 0 === a3 && (a3 = false);
            var n2 = o3.stretchX, s2 = o3.stretchY, l2 = o3.content;
            if (this._lazyInitEmptyStyle(), i3 instanceof Tr || Ir && i3 instanceof Ir) {
              var c2 = t.browser.getImageData(i3);
              this.style.addImage(e2, { data: new t.RGBAImage({ width: c2.width, height: c2.height }, c2.data), pixelRatio: r3, stretchX: n2, stretchY: s2, content: l2, sdf: a3, version: 0 });
            } else {
              if (void 0 === i3.width || void 0 === i3.height)
                return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              var u2 = i3;
              this.style.addImage(e2, { data: new t.RGBAImage({ width: i3.width, height: i3.height }, new Uint8Array(i3.data)), pixelRatio: r3, stretchX: n2, stretchY: s2, content: l2, sdf: a3, version: 0, userImage: u2 }), u2.onAdd && u2.onAdd(this, e2);
            }
          }, r2.prototype.updateImage = function(e2, i3) {
            var o3 = this.style.getImage(e2);
            if (!o3)
              return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            var r3 = i3 instanceof Tr || Ir && i3 instanceof Ir ? t.browser.getImageData(i3) : i3, a3 = r3.width, n2 = r3.height, s2 = r3.data;
            return void 0 === a3 || void 0 === n2 ? this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : a3 !== o3.data.width || n2 !== o3.data.height ? this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (o3.data.replace(s2, !(i3 instanceof Tr || Ir && i3 instanceof Ir)), void this.style.updateImage(e2, o3));
          }, r2.prototype.hasImage = function(e2) {
            return e2 ? !!this.style.getImage(e2) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), false);
          }, r2.prototype.removeImage = function(t4) {
            this.style.removeImage(t4);
          }, r2.prototype.loadImage = function(e2, i3) {
            t.getImage(this._requestManager.transformRequest(e2, t.ResourceType.Image), i3);
          }, r2.prototype.listImages = function() {
            return this.style.listImages();
          }, r2.prototype.addLayer = function(t4, e2) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(t4, e2), this._update(true);
          }, r2.prototype.moveLayer = function(t4, e2) {
            return this.style.moveLayer(t4, e2), this._update(true);
          }, r2.prototype.removeLayer = function(t4) {
            return this.style.removeLayer(t4), this._update(true);
          }, r2.prototype.getLayer = function(t4) {
            return this.style.getLayer(t4);
          }, r2.prototype.setLayerZoomRange = function(t4, e2, i3) {
            return this.style.setLayerZoomRange(t4, e2, i3), this._update(true);
          }, r2.prototype.setFilter = function(t4, e2, i3) {
            return void 0 === i3 && (i3 = {}), this.style.setFilter(t4, e2, i3), this._update(true);
          }, r2.prototype.getFilter = function(t4) {
            return this.style.getFilter(t4);
          }, r2.prototype.setPaintProperty = function(t4, e2, i3, o3) {
            return void 0 === o3 && (o3 = {}), this.style.setPaintProperty(t4, e2, i3, o3), this._update(true);
          }, r2.prototype.getPaintProperty = function(t4, e2) {
            return this.style.getPaintProperty(t4, e2);
          }, r2.prototype.setLayoutProperty = function(t4, e2, i3, o3) {
            return void 0 === o3 && (o3 = {}), this.style.setLayoutProperty(t4, e2, i3, o3), this._update(true);
          }, r2.prototype.getLayoutProperty = function(t4, e2) {
            return this.style.getLayoutProperty(t4, e2);
          }, r2.prototype.setLight = function(t4, e2) {
            return void 0 === e2 && (e2 = {}), this._lazyInitEmptyStyle(), this.style.setLight(t4, e2), this._update(true);
          }, r2.prototype.getLight = function() {
            return this.style.getLight();
          }, r2.prototype.setFeatureState = function(t4, e2) {
            return this.style.setFeatureState(t4, e2), this._update();
          }, r2.prototype.removeFeatureState = function(t4, e2) {
            return this.style.removeFeatureState(t4, e2), this._update();
          }, r2.prototype.getFeatureState = function(t4) {
            return this.style.getFeatureState(t4);
          }, r2.prototype.getContainer = function() {
            return this._container;
          }, r2.prototype.getCanvasContainer = function() {
            return this._canvasContainer;
          }, r2.prototype.getCanvas = function() {
            return this._canvas;
          }, r2.prototype._containerDimensions = function() {
            var t4 = 0, e2 = 0;
            return this._container && (t4 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t4, e2];
          }, r2.prototype._detectMissingCSS = function() {
            "rgb(250, 128, 114)" !== t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && t.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
          }, r2.prototype._setupContainer = function() {
            var t4 = this._container;
            t4.classList.add("mapboxgl-map"), (this._missingCSSCanary = i2.create("div", "mapboxgl-canary", t4)).style.visibility = "hidden", this._detectMissingCSS();
            var e2 = this._canvasContainer = i2.create("div", "mapboxgl-canvas-container", t4);
            this._interactive && e2.classList.add("mapboxgl-interactive"), this._canvas = i2.create("canvas", "mapboxgl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
            var o3 = this._containerDimensions();
            this._resizeCanvas(o3[0], o3[1]);
            var r3 = this._controlContainer = i2.create("div", "mapboxgl-control-container", t4), a3 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(function(t5) {
              a3[t5] = i2.create("div", "mapboxgl-ctrl-" + t5, r3);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }, r2.prototype._resizeCanvas = function(e2, i3) {
            var o3 = t.browser.devicePixelRatio || 1;
            this._canvas.width = o3 * e2, this._canvas.height = o3 * i3, this._canvas.style.width = e2 + "px", this._canvas.style.height = i3 + "px";
          }, r2.prototype._setupPainter = function() {
            var i3 = t.extend({}, e.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o3 = this._canvas.getContext("webgl", i3) || this._canvas.getContext("experimental-webgl", i3);
            o3 ? (this.painter = new yo(o3, this.transform), t.webpSupported.testSupport(o3)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));
          }, r2.prototype._contextLost = function(e2) {
            e2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", { originalEvent: e2 }));
          }, r2.prototype._contextRestored = function(e2) {
            this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", { originalEvent: e2 }));
          }, r2.prototype._onMapScroll = function(t4) {
            if (t4.target === this._container)
              return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }, r2.prototype.loaded = function() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }, r2.prototype._update = function(t4) {
            return this.style ? (this._styleDirty = this._styleDirty || t4, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }, r2.prototype._requestRenderFrame = function(t4) {
            return this._update(), this._renderTaskQueue.add(t4);
          }, r2.prototype._cancelRenderFrame = function(t4) {
            this._renderTaskQueue.remove(t4);
          }, r2.prototype._render = function(e2) {
            var i3, o3 = this, r3 = 0, a3 = this.painter.context.extTimerQuery;
            if (this.listens("gpu-timing-frame") && (i3 = a3.createQueryEXT(), a3.beginQueryEXT(a3.TIME_ELAPSED_EXT, i3), r3 = t.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), !this._removed) {
              var n2 = false;
              if (this.style && this._styleDirty) {
                this._styleDirty = false;
                var s2 = this.transform.zoom, l2 = t.browser.now();
                this.style.zoomHistory.update(s2, l2);
                var c2 = new t.EvaluationParameters(s2, { now: l2, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), u2 = c2.crossFadingFactor();
                1 === u2 && u2 === this._crossFadingFactor || (n2 = true, this._crossFadingFactor = u2), this.style.update(c2);
              }
              if (this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || n2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
                var h2 = t.browser.now() - r3;
                a3.endQueryEXT(a3.TIME_ELAPSED_EXT, i3), setTimeout(function() {
                  var e3 = a3.getQueryObjectEXT(i3, a3.QUERY_RESULT_EXT) / 1e6;
                  a3.deleteQueryEXT(i3), o3.fire(new t.Event("gpu-timing-frame", { cpuTime: h2, gpuTime: e3 }));
                }, 50);
              }
              if (this.listens("gpu-timing-layer")) {
                var p2 = this.painter.collectGpuTimers();
                setTimeout(function() {
                  var e3 = o3.painter.queryGpuTimers(p2);
                  o3.fire(new t.Event("gpu-timing-layer", { layerTimes: e3 }));
                }, 50);
              }
              var d2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
              return d2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event("idle")), !this._loaded || this._fullyLoaded || d2 || (this._fullyLoaded = true), this;
            }
          }, r2.prototype.remove = function() {
            this._hash && this._hash.remove();
            for (var e2 = 0, i3 = this._controls; e2 < i3.length; e2 += 1)
              i3[e2].onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), void 0 !== t.window && (t.window.removeEventListener("resize", this._onWindowResize, false), t.window.removeEventListener("orientationchange", this._onWindowResize, false), t.window.removeEventListener("online", this._onWindowOnline, false));
            var o3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            o3 && o3.loseContext(), Cr(this._canvasContainer), Cr(this._controlContainer), Cr(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this._removed = true, this.fire(new t.Event("remove"));
          }, r2.prototype.triggerRepaint = function() {
            var e2 = this;
            this.style && !this._frame && (this._frame = t.browser.frame(function(t4) {
              e2._frame = null, e2._render(t4);
            }));
          }, r2.prototype._onWindowOnline = function() {
            this._update();
          }, r2.prototype._onWindowResize = function(t4) {
            this._trackResize && this.resize({ originalEvent: t4 })._update();
          }, a2.showTileBoundaries.get = function() {
            return !!this._showTileBoundaries;
          }, a2.showTileBoundaries.set = function(t4) {
            this._showTileBoundaries !== t4 && (this._showTileBoundaries = t4, this._update());
          }, a2.showPadding.get = function() {
            return !!this._showPadding;
          }, a2.showPadding.set = function(t4) {
            this._showPadding !== t4 && (this._showPadding = t4, this._update());
          }, a2.showCollisionBoxes.get = function() {
            return !!this._showCollisionBoxes;
          }, a2.showCollisionBoxes.set = function(t4) {
            this._showCollisionBoxes !== t4 && (this._showCollisionBoxes = t4, t4 ? this.style._generateCollisionBoxes() : this._update());
          }, a2.showOverdrawInspector.get = function() {
            return !!this._showOverdrawInspector;
          }, a2.showOverdrawInspector.set = function(t4) {
            this._showOverdrawInspector !== t4 && (this._showOverdrawInspector = t4, this._update());
          }, a2.repaint.get = function() {
            return !!this._repaint;
          }, a2.repaint.set = function(t4) {
            this._repaint !== t4 && (this._repaint = t4, this.triggerRepaint());
          }, a2.vertices.get = function() {
            return !!this._vertices;
          }, a2.vertices.set = function(t4) {
            this._vertices = t4, this._update();
          }, r2.prototype._setCacheLimits = function(e2, i3) {
            t.setCacheLimits(e2, i3);
          }, a2.version.get = function() {
            return t.version;
          }, Object.defineProperties(r2.prototype, a2), r2;
        }(vr);
        function Cr(t4) {
          t4.parentNode && t4.parentNode.removeChild(t4);
        }
        var zr = { showCompass: true, showZoom: true, visualizePitch: false }, Dr = function(e2) {
          var o2 = this;
          this.options = t.extend({}, zr, e2), this._container = i2.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", function(t4) {
            return t4.preventDefault();
          }), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", function(t4) {
            return o2._map.zoomIn({}, { originalEvent: t4 });
          }), i2.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", true), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", function(t4) {
            return o2._map.zoomOut({}, { originalEvent: t4 });
          }), i2.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", true)), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", function(t4) {
            o2.options.visualizePitch ? o2._map.resetNorthPitch({}, { originalEvent: t4 }) : o2._map.resetNorth({}, { originalEvent: t4 });
          }), this._compassIcon = i2.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", true));
        };
        Dr.prototype._updateZoomButtons = function() {
          var t4 = this._map.getZoom(), e2 = t4 === this._map.getMaxZoom(), i3 = t4 === this._map.getMinZoom();
          this._zoomInButton.disabled = e2, this._zoomOutButton.disabled = i3, this._zoomInButton.setAttribute("aria-disabled", e2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i3.toString());
        }, Dr.prototype._rotateCompassArrow = function() {
          var t4 = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)";
          this._compassIcon.style.transform = t4;
        }, Dr.prototype.onAdd = function(t4) {
          return this._map = t4, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ar(this._map, this._compass, this.options.visualizePitch)), this._container;
        }, Dr.prototype.onRemove = function() {
          i2.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }, Dr.prototype._createButton = function(t4, e2) {
          var o2 = i2.create("button", t4, this._container);
          return o2.type = "button", o2.addEventListener("click", e2), o2;
        }, Dr.prototype._setButtonTitle = function(t4, e2) {
          var i3 = this._map._getUIString("NavigationControl." + e2);
          t4.title = i3, t4.setAttribute("aria-label", i3);
        };
        var Ar = function(e2, o2, r2) {
          void 0 === r2 && (r2 = false), this._clickTolerance = 10, this.element = o2, this.mouseRotate = new Xo({ clickTolerance: e2.dragRotate._mouseRotate._clickTolerance }), this.map = e2, r2 && (this.mousePitch = new Ho({ clickTolerance: e2.dragRotate._mousePitch._clickTolerance })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i2.addEventListener(o2, "mousedown", this.mousedown), i2.addEventListener(o2, "touchstart", this.touchstart, { passive: false }), i2.addEventListener(o2, "touchmove", this.touchmove), i2.addEventListener(o2, "touchend", this.touchend), i2.addEventListener(o2, "touchcancel", this.reset);
        };
        function Mr(e2, i3, o2) {
          if (e2 = new t.LngLat(e2.lng, e2.lat), i3) {
            var r2 = new t.LngLat(e2.lng - 360, e2.lat), a2 = new t.LngLat(e2.lng + 360, e2.lat), n2 = o2.locationPoint(e2).distSqr(i3);
            o2.locationPoint(r2).distSqr(i3) < n2 ? e2 = r2 : o2.locationPoint(a2).distSqr(i3) < n2 && (e2 = a2);
          }
          for (; Math.abs(e2.lng - o2.center.lng) > 180; ) {
            var s2 = o2.locationPoint(e2);
            if (s2.x >= 0 && s2.y >= 0 && s2.x <= o2.width && s2.y <= o2.height)
              break;
            e2.lng > o2.center.lng ? e2.lng -= 360 : e2.lng += 360;
          }
          return e2;
        }
        Ar.prototype.down = function(t4, e2) {
          this.mouseRotate.mousedown(t4, e2), this.mousePitch && this.mousePitch.mousedown(t4, e2), i2.disableDrag();
        }, Ar.prototype.move = function(t4, e2) {
          var i3 = this.map, o2 = this.mouseRotate.mousemoveWindow(t4, e2);
          if (o2 && o2.bearingDelta && i3.setBearing(i3.getBearing() + o2.bearingDelta), this.mousePitch) {
            var r2 = this.mousePitch.mousemoveWindow(t4, e2);
            r2 && r2.pitchDelta && i3.setPitch(i3.getPitch() + r2.pitchDelta);
          }
        }, Ar.prototype.off = function() {
          var t4 = this.element;
          i2.removeEventListener(t4, "mousedown", this.mousedown), i2.removeEventListener(t4, "touchstart", this.touchstart, { passive: false }), i2.removeEventListener(t4, "touchmove", this.touchmove), i2.removeEventListener(t4, "touchend", this.touchend), i2.removeEventListener(t4, "touchcancel", this.reset), this.offTemp();
        }, Ar.prototype.offTemp = function() {
          i2.enableDrag(), i2.removeEventListener(t.window, "mousemove", this.mousemove), i2.removeEventListener(t.window, "mouseup", this.mouseup);
        }, Ar.prototype.mousedown = function(e2) {
          this.down(t.extend({}, e2, { ctrlKey: true, preventDefault: function() {
            return e2.preventDefault();
          } }), i2.mousePos(this.element, e2)), i2.addEventListener(t.window, "mousemove", this.mousemove), i2.addEventListener(t.window, "mouseup", this.mouseup);
        }, Ar.prototype.mousemove = function(t4) {
          this.move(t4, i2.mousePos(this.element, t4));
        }, Ar.prototype.mouseup = function(t4) {
          this.mouseRotate.mouseupWindow(t4), this.mousePitch && this.mousePitch.mouseupWindow(t4), this.offTemp();
        }, Ar.prototype.touchstart = function(t4) {
          1 !== t4.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = i2.touchPos(this.element, t4.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: function() {
            return t4.preventDefault();
          } }, this._startPos));
        }, Ar.prototype.touchmove = function(t4) {
          1 !== t4.targetTouches.length ? this.reset() : (this._lastPos = i2.touchPos(this.element, t4.targetTouches)[0], this.move({ preventDefault: function() {
            return t4.preventDefault();
          } }, this._lastPos));
        }, Ar.prototype.touchend = function(t4) {
          0 === t4.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }, Ar.prototype.reset = function() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        };
        var Lr = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function Rr(t4, e2, i3) {
          var o2 = t4.classList;
          for (var r2 in Lr)
            o2.remove("mapboxgl-" + i3 + "-anchor-" + r2);
          o2.add("mapboxgl-" + i3 + "-anchor-" + e2);
        }
        var kr, Br = function(e2) {
          function o2(o3, r2) {
            if (e2.call(this), (o3 instanceof t.window.HTMLElement || r2) && (o3 = t.extend({ element: o3 }, r2)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = o3 && o3.anchor || "center", this._color = o3 && o3.color || "#3FB1CE", this._scale = o3 && o3.scale || 1, this._draggable = o3 && o3.draggable || false, this._clickTolerance = o3 && o3.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = o3 && o3.rotation || 0, this._rotationAlignment = o3 && o3.rotationAlignment || "auto", this._pitchAlignment = o3 && o3.pitchAlignment && "auto" !== o3.pitchAlignment ? o3.pitchAlignment : this._rotationAlignment, o3 && o3.element)
              this._element = o3.element, this._offset = t.Point.convert(o3 && o3.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = i2.create("div"), this._element.setAttribute("aria-label", "Map marker");
              var a2 = i2.createNS("http://www.w3.org/2000/svg", "svg");
              a2.setAttributeNS(null, "display", "block"), a2.setAttributeNS(null, "height", "41px"), a2.setAttributeNS(null, "width", "27px"), a2.setAttributeNS(null, "viewBox", "0 0 27 41");
              var n2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              n2.setAttributeNS(null, "stroke", "none"), n2.setAttributeNS(null, "stroke-width", "1"), n2.setAttributeNS(null, "fill", "none"), n2.setAttributeNS(null, "fill-rule", "evenodd");
              var s2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              s2.setAttributeNS(null, "fill-rule", "nonzero");
              var l2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
              for (var c2 = 0, u2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; c2 < u2.length; c2 += 1) {
                var h2 = u2[c2], p2 = i2.createNS("http://www.w3.org/2000/svg", "ellipse");
                p2.setAttributeNS(null, "opacity", "0.04"), p2.setAttributeNS(null, "cx", "10.5"), p2.setAttributeNS(null, "cy", "5.80029008"), p2.setAttributeNS(null, "rx", h2.rx), p2.setAttributeNS(null, "ry", h2.ry), l2.appendChild(p2);
              }
              var d2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              d2.setAttributeNS(null, "fill", this._color);
              var _2 = i2.createNS("http://www.w3.org/2000/svg", "path");
              _2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), d2.appendChild(_2);
              var f2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "fill", "#000000");
              var m2 = i2.createNS("http://www.w3.org/2000/svg", "path");
              m2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), f2.appendChild(m2);
              var g2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              g2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), g2.setAttributeNS(null, "fill", "#FFFFFF");
              var v2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              v2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              var y2 = i2.createNS("http://www.w3.org/2000/svg", "circle");
              y2.setAttributeNS(null, "fill", "#000000"), y2.setAttributeNS(null, "opacity", "0.25"), y2.setAttributeNS(null, "cx", "5.5"), y2.setAttributeNS(null, "cy", "5.5"), y2.setAttributeNS(null, "r", "5.4999962");
              var x3 = i2.createNS("http://www.w3.org/2000/svg", "circle");
              x3.setAttributeNS(null, "fill", "#FFFFFF"), x3.setAttributeNS(null, "cx", "5.5"), x3.setAttributeNS(null, "cy", "5.5"), x3.setAttributeNS(null, "r", "5.4999962"), v2.appendChild(y2), v2.appendChild(x3), s2.appendChild(l2), s2.appendChild(d2), s2.appendChild(f2), s2.appendChild(g2), s2.appendChild(v2), a2.appendChild(s2), a2.setAttributeNS(null, "height", 41 * this._scale + "px"), a2.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(a2), this._offset = t.Point.convert(o3 && o3.offset || [0, -14]);
            }
            this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", function(t4) {
              t4.preventDefault();
            }), this._element.addEventListener("mousedown", function(t4) {
              t4.preventDefault();
            }), Rr(this._element, this._anchor, "marker"), this._popup = null;
          }
          return e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2, o2.prototype.addTo = function(t4) {
            return this.remove(), this._map = t4, t4.getCanvasContainer().appendChild(this._element), t4.on("move", this._update), t4.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }, o2.prototype.remove = function() {
            return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i2.remove(this._element), this._popup && this._popup.remove(), this;
          }, o2.prototype.getLngLat = function() {
            return this._lngLat;
          }, o2.prototype.setLngLat = function(e3) {
            return this._lngLat = t.LngLat.convert(e3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }, o2.prototype.getElement = function() {
            return this._element;
          }, o2.prototype.setPopup = function(t4) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t4) {
              if (!("offset" in t4.options)) {
                var e3 = Math.sqrt(Math.pow(13.5, 2) / 2);
                t4.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [e3, -1 * (24.6 + e3)], "bottom-right": [-e3, -1 * (24.6 + e3)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset;
              }
              this._popup = t4, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }, o2.prototype._onKeyPress = function(t4) {
            var e3 = t4.code, i3 = t4.charCode || t4.keyCode;
            "Space" !== e3 && "Enter" !== e3 && 32 !== i3 && 13 !== i3 || this.togglePopup();
          }, o2.prototype._onMapClick = function(t4) {
            var e3 = t4.originalEvent.target, i3 = this._element;
            this._popup && (e3 === i3 || i3.contains(e3)) && this.togglePopup();
          }, o2.prototype.getPopup = function() {
            return this._popup;
          }, o2.prototype.togglePopup = function() {
            var t4 = this._popup;
            return t4 ? (t4.isOpen() ? t4.remove() : t4.addTo(this._map), this) : this;
          }, o2.prototype._update = function(t4) {
            if (this._map) {
              this._map.transform.renderWorldCopies && (this._lngLat = Mr(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
              var e3 = "";
              "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e3 = "rotateZ(" + this._rotation + "deg)" : "map" === this._rotationAlignment && (e3 = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)");
              var o3 = "";
              "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? o3 = "rotateX(0deg)" : "map" === this._pitchAlignment && (o3 = "rotateX(" + this._map.getPitch() + "deg)"), t4 && "moveend" !== t4.type || (this._pos = this._pos.round()), i2.setTransform(this._element, Lr[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + o3 + " " + e3);
            }
          }, o2.prototype.getOffset = function() {
            return this._offset;
          }, o2.prototype.setOffset = function(e3) {
            return this._offset = t.Point.convert(e3), this._update(), this;
          }, o2.prototype._onMove = function(e3) {
            if (!this._isDragging) {
              var i3 = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = e3.point.dist(this._pointerdownPos) >= i3;
            }
            this._isDragging && (this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag")));
          }, o2.prototype._onUp = function() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.Event("dragend")), this._state = "inactive";
          }, o2.prototype._addDragHandler = function(t4) {
            this._element.contains(t4.originalEvent.target) && (t4.preventDefault(), this._positionDelta = t4.point.sub(this._pos).add(this._offset), this._pointerdownPos = t4.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, o2.prototype.setDraggable = function(t4) {
            return this._draggable = !!t4, this._map && (t4 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }, o2.prototype.isDraggable = function() {
            return this._draggable;
          }, o2.prototype.setRotation = function(t4) {
            return this._rotation = t4 || 0, this._update(), this;
          }, o2.prototype.getRotation = function() {
            return this._rotation;
          }, o2.prototype.setRotationAlignment = function(t4) {
            return this._rotationAlignment = t4 || "auto", this._update(), this;
          }, o2.prototype.getRotationAlignment = function() {
            return this._rotationAlignment;
          }, o2.prototype.setPitchAlignment = function(t4) {
            return this._pitchAlignment = t4 && "auto" !== t4 ? t4 : this._rotationAlignment, this._update(), this;
          }, o2.prototype.getPitchAlignment = function() {
            return this._pitchAlignment;
          }, o2;
        }(t.Evented), Or = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true }, Fr = 0, Ur = false, Nr = function(e2) {
          function o2(i3) {
            e2.call(this), this.options = t.extend({}, Or, i3), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
          }
          return e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2, o2.prototype.onAdd = function(e3) {
            var o3;
            return this._map = e3, this._container = i2.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), o3 = this._setupUI, void 0 !== kr ? o3(kr) : void 0 !== t.window.navigator.permissions ? t.window.navigator.permissions.query({ name: "geolocation" }).then(function(t4) {
              o3(kr = "denied" !== t4.state);
            }) : o3(kr = !!t.window.navigator.geolocation), this._container;
          }, o2.prototype.onRemove = function() {
            void 0 !== this._geolocationWatchID && (t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), i2.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Fr = 0, Ur = false;
          }, o2.prototype._isOutOfMapMaxBounds = function(t4) {
            var e3 = this._map.getMaxBounds(), i3 = t4.coords;
            return e3 && (i3.longitude < e3.getWest() || i3.longitude > e3.getEast() || i3.latitude < e3.getSouth() || i3.latitude > e3.getNorth());
          }, o2.prototype._setErrorState = function() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
            }
          }, o2.prototype._onSuccess = function(e3) {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(e3))
                return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation)
                switch (this._lastKnownPosition = e3, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                }
              this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e3)), this._finish();
            }
          }, o2.prototype._updateCamera = function(e3) {
            var i3 = new t.LngLat(e3.coords.longitude, e3.coords.latitude), o3 = e3.coords.accuracy, r2 = this._map.getBearing(), a2 = t.extend({ bearing: r2 }, this.options.fitBoundsOptions);
            this._map.fitBounds(i3.toBounds(o3), a2, { geolocateSource: true });
          }, o2.prototype._updateMarker = function(e3) {
            if (e3) {
              var i3 = new t.LngLat(e3.coords.longitude, e3.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i3).addTo(this._map), this._userLocationDotMarker.setLngLat(i3).addTo(this._map), this._accuracy = e3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else
              this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, o2.prototype._updateCircleRadius = function() {
            var t4 = this._map._container.clientHeight / 2, e3 = this._map.unproject([0, t4]), i3 = this._map.unproject([1, t4]), o3 = e3.distanceTo(i3), r2 = Math.ceil(2 * this._accuracy / o3);
            this._circleElement.style.width = r2 + "px", this._circleElement.style.height = r2 + "px";
          }, o2.prototype._onZoom = function() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, o2.prototype._onError = function(e3) {
            if (this._map) {
              if (this.options.trackUserLocation)
                if (1 === e3.code) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  var i3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = i3, this._geolocateButton.setAttribute("aria-label", i3), void 0 !== this._geolocationWatchID && this._clearWatch();
                } else {
                  if (3 === e3.code && Ur)
                    return;
                  this._setErrorState();
                }
              "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e3)), this._finish();
            }
          }, o2.prototype._finish = function() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, o2.prototype._setupUI = function(e3) {
            var o3 = this;
            if (this._container.addEventListener("contextmenu", function(t4) {
              return t4.preventDefault();
            }), this._geolocateButton = i2.create("button", "mapboxgl-ctrl-geolocate", this._container), i2.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", true), this._geolocateButton.type = "button", false === e3) {
              t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
              var r2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = true, this._geolocateButton.title = r2, this._geolocateButton.setAttribute("aria-label", r2);
            } else {
              var a2 = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.title = a2, this._geolocateButton.setAttribute("aria-label", a2);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i2.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new Br(this._dotElement), this._circleElement = i2.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Br({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", function(e4) {
              e4.geolocateSource || "ACTIVE_LOCK" !== o3._watchState || e4.originalEvent && "resize" === e4.originalEvent.type || (o3._watchState = "BACKGROUND", o3._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), o3._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), o3.fire(new t.Event("trackuserlocationend")));
            });
          }, o2.prototype.trigger = function() {
            if (!this._setup)
              return t.warnOnce("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Fr--, Ur = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "BACKGROUND":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  break;
                case "BACKGROUND_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                var e3;
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++Fr > 1 ? (e3 = { maximumAge: 6e5, timeout: 0 }, Ur = true) : (e3 = this.options.positionOptions, Ur = false), this._geolocationWatchID = t.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e3);
              }
            } else
              t.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }, o2.prototype._clearWatch = function() {
            t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }, o2;
        }(t.Evented), Zr = { maxWidth: 100, unit: "metric" }, qr = function(e2) {
          this.options = t.extend({}, Zr, e2), t.bindAll(["_onMove", "setUnit"], this);
        };
        function jr(t4, e2, i3) {
          var o2 = i3 && i3.maxWidth || 100, r2 = t4._container.clientHeight / 2, a2 = t4.unproject([0, r2]), n2 = t4.unproject([o2, r2]), s2 = a2.distanceTo(n2);
          if (i3 && "imperial" === i3.unit) {
            var l2 = 3.2808 * s2;
            l2 > 5280 ? Vr(e2, o2, l2 / 5280, t4._getUIString("ScaleControl.Miles")) : Vr(e2, o2, l2, t4._getUIString("ScaleControl.Feet"));
          } else
            i3 && "nautical" === i3.unit ? Vr(e2, o2, s2 / 1852, t4._getUIString("ScaleControl.NauticalMiles")) : s2 >= 1e3 ? Vr(e2, o2, s2 / 1e3, t4._getUIString("ScaleControl.Kilometers")) : Vr(e2, o2, s2, t4._getUIString("ScaleControl.Meters"));
        }
        function Vr(t4, e2, i3, o2) {
          var r2, a2, n2, s2 = (r2 = i3, (a2 = Math.pow(10, ("" + Math.floor(r2)).length - 1)) * (n2 = (n2 = r2 / a2) >= 10 ? 10 : n2 >= 5 ? 5 : n2 >= 3 ? 3 : n2 >= 2 ? 2 : n2 >= 1 ? 1 : function(t5) {
            var e3 = Math.pow(10, Math.ceil(-Math.log(t5) / Math.LN10));
            return Math.round(t5 * e3) / e3;
          }(n2)));
          t4.style.width = e2 * (s2 / i3) + "px", t4.innerHTML = s2 + "&nbsp;" + o2;
        }
        qr.prototype.getDefaultPosition = function() {
          return "bottom-left";
        }, qr.prototype._onMove = function() {
          jr(this._map, this._container, this.options);
        }, qr.prototype.onAdd = function(t4) {
          return this._map = t4, this._container = i2.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", t4.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }, qr.prototype.onRemove = function() {
          i2.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }, qr.prototype.setUnit = function(t4) {
          this.options.unit = t4, jr(this._map, this._container, this.options);
        };
        var Gr = function(e2) {
          this._fullscreen = false, e2 && e2.container && (e2.container instanceof t.window.HTMLElement ? this._container = e2.container : t.warnOnce("Full screen control 'container' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in t.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in t.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in t.window.document && (this._fullscreenchange = "MSFullscreenChange");
        };
        Gr.prototype.onAdd = function(e2) {
          return this._map = e2, this._container || (this._container = this._map.getContainer()), this._controlContainer = i2.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
        }, Gr.prototype.onRemove = function() {
          i2.remove(this._controlContainer), this._map = null, t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }, Gr.prototype._checkFullscreenSupport = function() {
          return !!(t.window.document.fullscreenEnabled || t.window.document.mozFullScreenEnabled || t.window.document.msFullscreenEnabled || t.window.document.webkitFullscreenEnabled);
        }, Gr.prototype._setupUI = function() {
          var e2 = this._fullscreenButton = i2.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          i2.create("span", "mapboxgl-ctrl-icon", e2).setAttribute("aria-hidden", true), e2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), t.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
        }, Gr.prototype._updateTitle = function() {
          var t4 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", t4), this._fullscreenButton.title = t4;
        }, Gr.prototype._getTitle = function() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }, Gr.prototype._isFullscreen = function() {
          return this._fullscreen;
        }, Gr.prototype._changeIcon = function() {
          (t.window.document.fullscreenElement || t.window.document.mozFullScreenElement || t.window.document.webkitFullscreenElement || t.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }, Gr.prototype._onClickFullscreen = function() {
          this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.mozCancelFullScreen ? t.window.document.mozCancelFullScreen() : t.window.document.msExitFullscreen ? t.window.document.msExitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        };
        var Wr = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, Xr = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), Hr = function(e2) {
          function o2(i3) {
            e2.call(this), this.options = t.extend(Object.create(Wr), i3), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
          }
          return e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2, o2.prototype.addTo = function(e3) {
            return this._map && this.remove(), this._map = e3, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this;
          }, o2.prototype.isOpen = function() {
            return !!this._map;
          }, o2.prototype.remove = function() {
            return this._content && i2.remove(this._content), this._container && (i2.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this;
          }, o2.prototype.getLngLat = function() {
            return this._lngLat;
          }, o2.prototype.setLngLat = function(e3) {
            return this._lngLat = t.LngLat.convert(e3), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
          }, o2.prototype.trackPointer = function() {
            return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
          }, o2.prototype.getElement = function() {
            return this._container;
          }, o2.prototype.setText = function(e3) {
            return this.setDOMContent(t.window.document.createTextNode(e3));
          }, o2.prototype.setHTML = function(e3) {
            var i3, o3 = t.window.document.createDocumentFragment(), r2 = t.window.document.createElement("body");
            for (r2.innerHTML = e3; i3 = r2.firstChild; )
              o3.appendChild(i3);
            return this.setDOMContent(o3);
          }, o2.prototype.getMaxWidth = function() {
            return this._container && this._container.style.maxWidth;
          }, o2.prototype.setMaxWidth = function(t4) {
            return this.options.maxWidth = t4, this._update(), this;
          }, o2.prototype.setDOMContent = function(t4) {
            if (this._content)
              for (; this._content.hasChildNodes(); )
                this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else
              this._content = i2.create("div", "mapboxgl-popup-content", this._container);
            return this._content.appendChild(t4), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }, o2.prototype.addClassName = function(t4) {
            this._container && this._container.classList.add(t4);
          }, o2.prototype.removeClassName = function(t4) {
            this._container && this._container.classList.remove(t4);
          }, o2.prototype.setOffset = function(t4) {
            return this.options.offset = t4, this._update(), this;
          }, o2.prototype.toggleClassName = function(t4) {
            if (this._container)
              return this._container.classList.toggle(t4);
          }, o2.prototype._createCloseButton = function() {
            this.options.closeButton && (this._closeButton = i2.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }, o2.prototype._onMouseUp = function(t4) {
            this._update(t4.point);
          }, o2.prototype._onMouseMove = function(t4) {
            this._update(t4.point);
          }, o2.prototype._onDrag = function(t4) {
            this._update(t4.point);
          }, o2.prototype._update = function(e3) {
            var o3 = this;
            if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = i2.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = i2.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach(function(t4) {
              return o3._container.classList.add(t4);
            }), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Mr(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || e3)) {
              var r2 = this._pos = this._trackPointer && e3 ? e3 : this._map.project(this._lngLat), a2 = this.options.anchor, n2 = function e4(i3) {
                if (i3) {
                  if ("number" == typeof i3) {
                    var o4 = Math.round(Math.sqrt(0.5 * Math.pow(i3, 2)));
                    return { center: new t.Point(0, 0), top: new t.Point(0, i3), "top-left": new t.Point(o4, o4), "top-right": new t.Point(-o4, o4), bottom: new t.Point(0, -i3), "bottom-left": new t.Point(o4, -o4), "bottom-right": new t.Point(-o4, -o4), left: new t.Point(i3, 0), right: new t.Point(-i3, 0) };
                  }
                  if (i3 instanceof t.Point || Array.isArray(i3)) {
                    var r3 = t.Point.convert(i3);
                    return { center: r3, top: r3, "top-left": r3, "top-right": r3, bottom: r3, "bottom-left": r3, "bottom-right": r3, left: r3, right: r3 };
                  }
                  return { center: t.Point.convert(i3.center || [0, 0]), top: t.Point.convert(i3.top || [0, 0]), "top-left": t.Point.convert(i3["top-left"] || [0, 0]), "top-right": t.Point.convert(i3["top-right"] || [0, 0]), bottom: t.Point.convert(i3.bottom || [0, 0]), "bottom-left": t.Point.convert(i3["bottom-left"] || [0, 0]), "bottom-right": t.Point.convert(i3["bottom-right"] || [0, 0]), left: t.Point.convert(i3.left || [0, 0]), right: t.Point.convert(i3.right || [0, 0]) };
                }
                return e4(new t.Point(0, 0));
              }(this.options.offset);
              if (!a2) {
                var s2, l2 = this._container.offsetWidth, c2 = this._container.offsetHeight;
                s2 = r2.y + n2.bottom.y < c2 ? ["top"] : r2.y > this._map.transform.height - c2 ? ["bottom"] : [], r2.x < l2 / 2 ? s2.push("left") : r2.x > this._map.transform.width - l2 / 2 && s2.push("right"), a2 = 0 === s2.length ? "bottom" : s2.join("-");
              }
              var u2 = r2.add(n2[a2]).round();
              i2.setTransform(this._container, Lr[a2] + " translate(" + u2.x + "px," + u2.y + "px)"), Rr(this._container, a2, "popup");
            }
          }, o2.prototype._focusFirstElement = function() {
            if (this.options.focusAfterOpen && this._container) {
              var t4 = this._container.querySelector(Xr);
              t4 && t4.focus();
            }
          }, o2.prototype._onClose = function() {
            this.remove();
          }, o2;
        }(t.Evented), Kr = { version: t.version, supported: e, setRTLTextPlugin: t.setRTLTextPlugin, getRTLTextPluginStatus: t.getRTLTextPluginStatus, Map: Sr, NavigationControl: Dr, GeolocateControl: Nr, AttributionControl: yr, ScaleControl: qr, FullscreenControl: Gr, Popup: Hr, Marker: Br, Style: je, LngLat: t.LngLat, LngLatBounds: t.LngLatBounds, Point: t.Point, MercatorCoordinate: t.MercatorCoordinate, Evented: t.Evented, config: t.config, prewarm: function() {
          Ft().acquire(Rt);
        }, clearPrewarmedResources: function() {
          var t4 = Bt;
          t4 && (t4.isPreloaded() && 1 === t4.numActive() ? (t4.release(Rt), Bt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, get accessToken() {
          return t.config.ACCESS_TOKEN;
        }, set accessToken(e2) {
          t.config.ACCESS_TOKEN = e2;
        }, get baseApiUrl() {
          return t.config.API_URL;
        }, set baseApiUrl(e2) {
          t.config.API_URL = e2;
        }, get workerCount() {
          return kt.workerCount;
        }, set workerCount(t4) {
          kt.workerCount = t4;
        }, get maxParallelImageRequests() {
          return t.config.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(e2) {
          t.config.MAX_PARALLEL_IMAGE_REQUESTS = e2;
        }, clearStorage: function(e2) {
          t.clearTileCache(e2);
        }, workerUrl: "" };
        return Kr;
      });
      return mapboxgl2;
    });
  }
});

// node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = __commonJS({
  "node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.maplibregl = factory());
    })(exports, function() {
      "use strict";
      var shared, worker, maplibregl2;
      function define2(_, chunk) {
        if (!shared) {
          shared = chunk;
        } else if (!worker) {
          worker = chunk;
        } else {
          var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
          var sharedChunk = {};
          shared(sharedChunk);
          maplibregl2 = chunk(sharedChunk);
          if (typeof window !== "undefined") {
            maplibregl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
          }
        }
      }
      define2(["exports"], function(t) {
        "use strict";
        function e(t4, e2, r2, n2) {
          return new (r2 || (r2 = Promise))(function(i3, a2) {
            function s2(t5) {
              try {
                l2(n2.next(t5));
              } catch (t6) {
                a2(t6);
              }
            }
            function o2(t5) {
              try {
                l2(n2.throw(t5));
              } catch (t6) {
                a2(t6);
              }
            }
            function l2(t5) {
              var e3;
              t5.done ? i3(t5.value) : (e3 = t5.value, e3 instanceof r2 ? e3 : new r2(function(t6) {
                t6(e3);
              })).then(s2, o2);
            }
            l2((n2 = n2.apply(t4, e2 || [])).next());
          });
        }
        function r(t4) {
          return t4 && t4.__esModule && Object.prototype.hasOwnProperty.call(t4, "default") ? t4.default : t4;
        }
        "function" == typeof SuppressedError && SuppressedError;
        var n = i2;
        function i2(t4, e2) {
          this.x = t4, this.y = e2;
        }
        i2.prototype = { clone: function() {
          return new i2(this.x, this.y);
        }, add: function(t4) {
          return this.clone()._add(t4);
        }, sub: function(t4) {
          return this.clone()._sub(t4);
        }, multByPoint: function(t4) {
          return this.clone()._multByPoint(t4);
        }, divByPoint: function(t4) {
          return this.clone()._divByPoint(t4);
        }, mult: function(t4) {
          return this.clone()._mult(t4);
        }, div: function(t4) {
          return this.clone()._div(t4);
        }, rotate: function(t4) {
          return this.clone()._rotate(t4);
        }, rotateAround: function(t4, e2) {
          return this.clone()._rotateAround(t4, e2);
        }, matMult: function(t4) {
          return this.clone()._matMult(t4);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t4) {
          return this.x === t4.x && this.y === t4.y;
        }, dist: function(t4) {
          return Math.sqrt(this.distSqr(t4));
        }, distSqr: function(t4) {
          var e2 = t4.x - this.x, r2 = t4.y - this.y;
          return e2 * e2 + r2 * r2;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t4) {
          return Math.atan2(this.y - t4.y, this.x - t4.x);
        }, angleWith: function(t4) {
          return this.angleWithSep(t4.x, t4.y);
        }, angleWithSep: function(t4, e2) {
          return Math.atan2(this.x * e2 - this.y * t4, this.x * t4 + this.y * e2);
        }, _matMult: function(t4) {
          var e2 = t4[2] * this.x + t4[3] * this.y;
          return this.x = t4[0] * this.x + t4[1] * this.y, this.y = e2, this;
        }, _add: function(t4) {
          return this.x += t4.x, this.y += t4.y, this;
        }, _sub: function(t4) {
          return this.x -= t4.x, this.y -= t4.y, this;
        }, _mult: function(t4) {
          return this.x *= t4, this.y *= t4, this;
        }, _div: function(t4) {
          return this.x /= t4, this.y /= t4, this;
        }, _multByPoint: function(t4) {
          return this.x *= t4.x, this.y *= t4.y, this;
        }, _divByPoint: function(t4) {
          return this.x /= t4.x, this.y /= t4.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t4 = this.y;
          return this.y = this.x, this.x = -t4, this;
        }, _rotate: function(t4) {
          var e2 = Math.cos(t4), r2 = Math.sin(t4), n2 = r2 * this.x + e2 * this.y;
          return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
        }, _rotateAround: function(t4, e2) {
          var r2 = Math.cos(t4), n2 = Math.sin(t4), i3 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
          return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i3, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, i2.convert = function(t4) {
          return t4 instanceof i2 ? t4 : Array.isArray(t4) ? new i2(t4[0], t4[1]) : t4;
        };
        var a = r(n), s = o;
        function o(t4, e2, r2, n2) {
          this.cx = 3 * t4, this.bx = 3 * (r2 - t4) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t4, this.p1y = e2, this.p2x = r2, this.p2y = n2;
        }
        o.prototype = { sampleCurveX: function(t4) {
          return ((this.ax * t4 + this.bx) * t4 + this.cx) * t4;
        }, sampleCurveY: function(t4) {
          return ((this.ay * t4 + this.by) * t4 + this.cy) * t4;
        }, sampleCurveDerivativeX: function(t4) {
          return (3 * this.ax * t4 + 2 * this.bx) * t4 + this.cx;
        }, solveCurveX: function(t4, e2) {
          if (void 0 === e2 && (e2 = 1e-6), t4 < 0)
            return 0;
          if (t4 > 1)
            return 1;
          for (var r2 = t4, n2 = 0; n2 < 8; n2++) {
            var i3 = this.sampleCurveX(r2) - t4;
            if (Math.abs(i3) < e2)
              return r2;
            var a2 = this.sampleCurveDerivativeX(r2);
            if (Math.abs(a2) < 1e-6)
              break;
            r2 -= i3 / a2;
          }
          var s2 = 0, o2 = 1;
          for (r2 = t4, n2 = 0; n2 < 20 && (i3 = this.sampleCurveX(r2), !(Math.abs(i3 - t4) < e2)); n2++)
            t4 > i3 ? s2 = r2 : o2 = r2, r2 = 0.5 * (o2 - s2) + s2;
          return r2;
        }, solve: function(t4, e2) {
          return this.sampleCurveY(this.solveCurveX(t4, e2));
        } };
        var l = r(s);
        let u, c;
        function h() {
          return null == u && (u = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), u;
        }
        function p() {
          if (null == c && (c = false, h())) {
            const t4 = 5, e2 = new OffscreenCanvas(t4, t4).getContext("2d", { willReadFrequently: true });
            if (e2) {
              for (let r3 = 0; r3 < t4 * t4; r3++) {
                const n2 = 4 * r3;
                e2.fillStyle = `rgb(${n2},${n2 + 1},${n2 + 2})`, e2.fillRect(r3 % t4, Math.floor(r3 / t4), 1, 1);
              }
              const r2 = e2.getImageData(0, 0, t4, t4).data;
              for (let e3 = 0; e3 < t4 * t4 * 4; e3++)
                if (e3 % 4 != 3 && r2[e3] !== e3) {
                  c = true;
                  break;
                }
            }
          }
          return c || false;
        }
        function f(t4, e2, r2, n2) {
          const i3 = new l(t4, e2, r2, n2);
          return function(t5) {
            return i3.solve(t5);
          };
        }
        const d = f(0.25, 0.1, 0.25, 1);
        function y(t4, e2, r2) {
          return Math.min(r2, Math.max(e2, t4));
        }
        function m(t4, e2, r2) {
          const n2 = r2 - e2, i3 = ((t4 - e2) % n2 + n2) % n2 + e2;
          return i3 === e2 ? r2 : i3;
        }
        function g(t4, ...e2) {
          for (const r2 of e2)
            for (const e3 in r2)
              t4[e3] = r2[e3];
          return t4;
        }
        let x2 = 1;
        function v(t4, e2, r2) {
          const n2 = {};
          for (const i3 in t4)
            n2[i3] = e2.call(r2 || this, t4[i3], i3, t4);
          return n2;
        }
        function b(t4, e2, r2) {
          const n2 = {};
          for (const i3 in t4)
            e2.call(r2 || this, t4[i3], i3, t4) && (n2[i3] = t4[i3]);
          return n2;
        }
        function w(t4) {
          return Array.isArray(t4) ? t4.map(w) : "object" == typeof t4 && t4 ? v(t4, w) : t4;
        }
        const _ = {};
        function A2(t4) {
          _[t4] || ("undefined" != typeof console && console.warn(t4), _[t4] = true);
        }
        function S(t4, e2, r2) {
          return (r2.y - t4.y) * (e2.x - t4.x) > (e2.y - t4.y) * (r2.x - t4.x);
        }
        function k(t4) {
          let e2 = 0;
          for (let r2, n2, i3 = 0, a2 = t4.length, s2 = a2 - 1; i3 < a2; s2 = i3++)
            r2 = t4[i3], n2 = t4[s2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
          return e2;
        }
        function I() {
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        let z = null;
        function M(t4) {
          return "undefined" != typeof ImageBitmap && t4 instanceof ImageBitmap;
        }
        const C2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function B2(t4, r2, n2, i3, a2) {
          return e(this, void 0, void 0, function* () {
            if ("undefined" == typeof VideoFrame)
              throw new Error("VideoFrame not supported");
            const e2 = new VideoFrame(t4, { timestamp: 0 });
            try {
              const s2 = null == e2 ? void 0 : e2.format;
              if (!s2 || !s2.startsWith("BGR") && !s2.startsWith("RGB"))
                throw new Error(`Unrecognized format ${s2}`);
              const o2 = s2.startsWith("BGR"), l2 = new Uint8ClampedArray(i3 * a2 * 4);
              if (yield e2.copyTo(l2, function(t5, e3, r3, n3, i4) {
                const a3 = 4 * Math.max(-e3, 0), s3 = (Math.max(0, r3) - r3) * n3 * 4 + a3, o3 = 4 * n3, l3 = Math.max(0, e3), u2 = Math.max(0, r3);
                return { rect: { x: l3, y: u2, width: Math.min(t5.width, e3 + n3) - l3, height: Math.min(t5.height, r3 + i4) - u2 }, layout: [{ offset: s3, stride: o3 }] };
              }(t4, r2, n2, i3, a2)), o2)
                for (let t5 = 0; t5 < l2.length; t5 += 4) {
                  const e3 = l2[t5];
                  l2[t5] = l2[t5 + 2], l2[t5 + 2] = e3;
                }
              return l2;
            } finally {
              e2.close();
            }
          });
        }
        let P, V, E2, F;
        const T2 = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(t4) {
          const e2 = requestAnimationFrame(t4);
          return { cancel: () => cancelAnimationFrame(e2) };
        }, getImageData(t4, e2 = 0) {
          return this.getImageCanvasContext(t4).getImageData(-e2, -e2, t4.width + 2 * e2, t4.height + 2 * e2);
        }, getImageCanvasContext(t4) {
          const e2 = window.document.createElement("canvas"), r2 = e2.getContext("2d", { willReadFrequently: true });
          if (!r2)
            throw new Error("failed to create canvas 2d context");
          return e2.width = t4.width, e2.height = t4.height, r2.drawImage(t4, 0, 0, t4.width, t4.height), r2;
        }, resolveURL: (t4) => (E2 || (E2 = document.createElement("a")), E2.href = t4, E2.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (null == F && (F = matchMedia("(prefers-reduced-motion: reduce)")), F.matches);
        } }, $ = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        class L2 extends Error {
          constructor(t4, e2, r2, n2) {
            super(`AJAXError: ${e2} (${t4}): ${r2}`), this.status = t4, this.statusText = e2, this.url = r2, this.body = n2;
          }
        }
        const D2 = I() ? () => self.worker && self.worker.referrer : () => ("blob:" === window.location.protocol ? window.parent : window).location.href, O = (t4) => $.REGISTERED_PROTOCOLS[t4.substring(0, t4.indexOf("://"))];
        function U(t4, e2) {
          const r2 = new AbortController(), n2 = new Request(t4.url, { method: t4.method || "GET", body: t4.body, credentials: t4.credentials, headers: t4.headers, cache: t4.cache, referrer: D2(), signal: r2.signal });
          let i3 = false, a2 = false;
          "json" === t4.type && n2.headers.set("Accept", "application/json");
          return a2 || fetch(n2).then((r3) => r3.ok ? ((r4) => {
            ("arrayBuffer" === t4.type || "image" === t4.type ? r4.arrayBuffer() : "json" === t4.type ? r4.json() : r4.text()).then((t5) => {
              a2 || (i3 = true, e2(null, t5, r4.headers.get("Cache-Control"), r4.headers.get("Expires")));
            }).catch((t5) => {
              a2 || e2(new Error(t5.message));
            });
          })(r3) : r3.blob().then((n3) => e2(new L2(r3.status, r3.statusText, t4.url, n3)))).catch((t5) => {
            20 !== t5.code && e2(new Error(t5.message));
          }), { cancel: () => {
            a2 = true, i3 || r2.abort();
          } };
        }
        const R = function(t4, e2) {
          if (/:\/\//.test(t4.url) && !/^https?:|^file:/.test(t4.url)) {
            if (I() && self.worker && self.worker.actor)
              return self.worker.actor.send("getResource", t4, e2);
            if (!I())
              return (O(t4.url) || U)(t4, e2);
          }
          if (!(/^file:/.test(r2 = t4.url) || /^file:/.test(D2()) && !/^\w+:/.test(r2))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
              return U(t4, e2);
            if (I() && self.worker && self.worker.actor)
              return self.worker.actor.send("getResource", t4, e2, void 0, true);
          }
          var r2;
          return function(t5, e3) {
            const r3 = new XMLHttpRequest();
            r3.open(t5.method || "GET", t5.url, true), "arrayBuffer" !== t5.type && "image" !== t5.type || (r3.responseType = "arraybuffer");
            for (const e4 in t5.headers)
              r3.setRequestHeader(e4, t5.headers[e4]);
            return "json" === t5.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t5.credentials, r3.onerror = () => {
              e3(new Error(r3.statusText));
            }, r3.onload = () => {
              if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
                let n2 = r3.response;
                if ("json" === t5.type)
                  try {
                    n2 = JSON.parse(r3.response);
                  } catch (t6) {
                    return e3(t6);
                  }
                e3(null, n2, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
              } else {
                const n2 = new Blob([r3.response], { type: r3.getResponseHeader("Content-Type") });
                e3(new L2(r3.status, r3.statusText, t5.url, n2));
              }
            }, r3.send(t5.body), { cancel: () => r3.abort() };
          }(t4, e2);
        }, q = function(t4, e2) {
          return R(g(t4, { type: "arrayBuffer" }), e2);
        };
        function j(t4) {
          if (!t4 || t4.indexOf("://") <= 0 || 0 === t4.indexOf("data:image/") || 0 === t4.indexOf("blob:"))
            return true;
          const e2 = new URL(t4), r2 = window.location;
          return e2.protocol === r2.protocol && e2.host === r2.host;
        }
        function N(t4, e2, r2) {
          r2[t4] && -1 !== r2[t4].indexOf(e2) || (r2[t4] = r2[t4] || [], r2[t4].push(e2));
        }
        function Z(t4, e2, r2) {
          if (r2 && r2[t4]) {
            const n2 = r2[t4].indexOf(e2);
            -1 !== n2 && r2[t4].splice(n2, 1);
          }
        }
        class K2 {
          constructor(t4, e2 = {}) {
            g(this, e2), this.type = t4;
          }
        }
        class G extends K2 {
          constructor(t4, e2 = {}) {
            super("error", g({ error: t4 }, e2));
          }
        }
        class J {
          on(t4, e2) {
            return this._listeners = this._listeners || {}, N(t4, e2, this._listeners), this;
          }
          off(t4, e2) {
            return Z(t4, e2, this._listeners), Z(t4, e2, this._oneTimeListeners), this;
          }
          once(t4, e2) {
            return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, N(t4, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t4, e3));
          }
          fire(t4, e2) {
            "string" == typeof t4 && (t4 = new K2(t4, e2 || {}));
            const r2 = t4.type;
            if (this.listens(r2)) {
              t4.target = this;
              const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
              for (const r3 of e3)
                r3.call(this, t4);
              const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
              for (const e4 of n2)
                Z(r2, e4, this._oneTimeListeners), e4.call(this, t4);
              const i3 = this._eventedParent;
              i3 && (g(t4, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i3.fire(t4));
            } else
              t4 instanceof G && console.error(t4.error);
            return this;
          }
          listens(t4) {
            return this._listeners && this._listeners[t4] && this._listeners[t4].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t4] && this._oneTimeListeners[t4].length > 0 || this._eventedParent && this._eventedParent.listens(t4);
          }
          setEventedParent(t4, e2) {
            return this._eventedParent = t4, this._eventedParentData = e2, this;
          }
        }
        var X = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const Y = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function H(t4, e2) {
          const r2 = {};
          for (const e3 in t4)
            "ref" !== e3 && (r2[e3] = t4[e3]);
          return Y.forEach((t5) => {
            t5 in e2 && (r2[t5] = e2[t5]);
          }), r2;
        }
        function W(t4, e2) {
          if (Array.isArray(t4)) {
            if (!Array.isArray(e2) || t4.length !== e2.length)
              return false;
            for (let r2 = 0; r2 < t4.length; r2++)
              if (!W(t4[r2], e2[r2]))
                return false;
            return true;
          }
          if ("object" == typeof t4 && null !== t4 && null !== e2) {
            if ("object" != typeof e2)
              return false;
            if (Object.keys(t4).length !== Object.keys(e2).length)
              return false;
            for (const r2 in t4)
              if (!W(t4[r2], e2[r2]))
                return false;
            return true;
          }
          return t4 === e2;
        }
        const Q = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
        function tt(t4, e2, r2) {
          r2.push({ command: Q.addSource, args: [t4, e2[t4]] });
        }
        function et2(t4, e2, r2) {
          e2.push({ command: Q.removeSource, args: [t4] }), r2[t4] = true;
        }
        function rt(t4, e2, r2, n2) {
          et2(t4, r2, n2), tt(t4, e2, r2);
        }
        function nt(t4, e2, r2) {
          let n2;
          for (n2 in t4[r2])
            if (Object.prototype.hasOwnProperty.call(t4[r2], n2) && "data" !== n2 && !W(t4[r2][n2], e2[r2][n2]))
              return false;
          for (n2 in e2[r2])
            if (Object.prototype.hasOwnProperty.call(e2[r2], n2) && "data" !== n2 && !W(t4[r2][n2], e2[r2][n2]))
              return false;
          return true;
        }
        function it(t4, e2, r2, n2, i3, a2) {
          let s2;
          for (s2 in e2 = e2 || {}, t4 = t4 || {})
            Object.prototype.hasOwnProperty.call(t4, s2) && (W(t4[s2], e2[s2]) || r2.push({ command: a2, args: [n2, s2, e2[s2], i3] }));
          for (s2 in e2)
            Object.prototype.hasOwnProperty.call(e2, s2) && !Object.prototype.hasOwnProperty.call(t4, s2) && (W(t4[s2], e2[s2]) || r2.push({ command: a2, args: [n2, s2, e2[s2], i3] }));
        }
        function at(t4) {
          return t4.id;
        }
        function st(t4, e2) {
          return t4[e2.id] = e2, t4;
        }
        class ot {
          constructor(t4, e2, r2, n2) {
            this.message = (t4 ? `${t4}: ` : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
          }
        }
        function lt(t4, ...e2) {
          for (const r2 of e2)
            for (const e3 in r2)
              t4[e3] = r2[e3];
          return t4;
        }
        class ut extends Error {
          constructor(t4, e2) {
            super(e2), this.message = e2, this.key = t4;
          }
        }
        class ct {
          constructor(t4, e2 = []) {
            this.parent = t4, this.bindings = {};
            for (const [t5, r2] of e2)
              this.bindings[t5] = r2;
          }
          concat(t4) {
            return new ct(this, t4);
          }
          get(t4) {
            if (this.bindings[t4])
              return this.bindings[t4];
            if (this.parent)
              return this.parent.get(t4);
            throw new Error(`${t4} not found in scope.`);
          }
          has(t4) {
            return !!this.bindings[t4] || !!this.parent && this.parent.has(t4);
          }
        }
        const ht = { kind: "null" }, pt = { kind: "number" }, ft = { kind: "string" }, dt = { kind: "boolean" }, yt = { kind: "color" }, mt = { kind: "object" }, gt = { kind: "value" }, xt = { kind: "collator" }, vt = { kind: "formatted" }, bt = { kind: "padding" }, wt = { kind: "resolvedImage" }, _t = { kind: "variableAnchorOffsetCollection" };
        function At(t4, e2) {
          return { kind: "array", itemType: t4, N: e2 };
        }
        function St(t4) {
          if ("array" === t4.kind) {
            const e2 = St(t4.itemType);
            return "number" == typeof t4.N ? `array<${e2}, ${t4.N}>` : "value" === t4.itemType.kind ? "array" : `array<${e2}>`;
          }
          return t4.kind;
        }
        const kt = [ht, pt, ft, dt, yt, vt, mt, At(gt), bt, wt, _t];
        function It(t4, e2) {
          if ("error" === e2.kind)
            return null;
          if ("array" === t4.kind) {
            if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !It(t4.itemType, e2.itemType)) && ("number" != typeof t4.N || t4.N === e2.N))
              return null;
          } else {
            if (t4.kind === e2.kind)
              return null;
            if ("value" === t4.kind) {
              for (const t5 of kt)
                if (!It(t5, e2))
                  return null;
            }
          }
          return `Expected ${St(t4)} but found ${St(e2)} instead.`;
        }
        function zt(t4, e2) {
          return e2.some((e3) => e3.kind === t4.kind);
        }
        function Mt(t4, e2) {
          return e2.some((e3) => "null" === e3 ? null === t4 : "array" === e3 ? Array.isArray(t4) : "object" === e3 ? t4 && !Array.isArray(t4) && "object" == typeof t4 : e3 === typeof t4);
        }
        function Ct(t4, e2) {
          return "array" === t4.kind && "array" === e2.kind ? t4.itemType.kind === e2.itemType.kind && "number" == typeof t4.N : t4.kind === e2.kind;
        }
        const Bt = 0.96422, Pt = 0.82521, Vt = 4 / 29, Et = 6 / 29, Ft = 3 * Et * Et, Tt = Et * Et * Et, $t = Math.PI / 180, Lt = 180 / Math.PI;
        function Dt(t4) {
          return (t4 %= 360) < 0 && (t4 += 360), t4;
        }
        function Ot([t4, e2, r2, n2]) {
          let i3, a2;
          const s2 = Rt((0.2225045 * (t4 = Ut(t4)) + 0.7168786 * (e2 = Ut(e2)) + 0.0606169 * (r2 = Ut(r2))) / 1);
          t4 === e2 && e2 === r2 ? i3 = a2 = s2 : (i3 = Rt((0.4360747 * t4 + 0.3850649 * e2 + 0.1430804 * r2) / Bt), a2 = Rt((0.0139322 * t4 + 0.0971045 * e2 + 0.7141733 * r2) / Pt));
          const o2 = 116 * s2 - 16;
          return [o2 < 0 ? 0 : o2, 500 * (i3 - s2), 200 * (s2 - a2), n2];
        }
        function Ut(t4) {
          return t4 <= 0.04045 ? t4 / 12.92 : Math.pow((t4 + 0.055) / 1.055, 2.4);
        }
        function Rt(t4) {
          return t4 > Tt ? Math.pow(t4, 1 / 3) : t4 / Ft + Vt;
        }
        function qt([t4, e2, r2, n2]) {
          let i3 = (t4 + 16) / 116, a2 = isNaN(e2) ? i3 : i3 + e2 / 500, s2 = isNaN(r2) ? i3 : i3 - r2 / 200;
          return i3 = 1 * Nt(i3), a2 = Bt * Nt(a2), s2 = Pt * Nt(s2), [jt(3.1338561 * a2 - 1.6168667 * i3 - 0.4906146 * s2), jt(-0.9787684 * a2 + 1.9161415 * i3 + 0.033454 * s2), jt(0.0719453 * a2 - 0.2289914 * i3 + 1.4052427 * s2), n2];
        }
        function jt(t4) {
          return (t4 = t4 <= 304e-5 ? 12.92 * t4 : 1.055 * Math.pow(t4, 1 / 2.4) - 0.055) < 0 ? 0 : t4 > 1 ? 1 : t4;
        }
        function Nt(t4) {
          return t4 > Et ? t4 * t4 * t4 : Ft * (t4 - Vt);
        }
        function Zt(t4) {
          return parseInt(t4.padEnd(2, t4), 16) / 255;
        }
        function Kt(t4, e2) {
          return Gt(e2 ? t4 / 100 : t4, 0, 1);
        }
        function Gt(t4, e2, r2) {
          return Math.min(Math.max(e2, t4), r2);
        }
        function Jt(t4) {
          return !t4.some(Number.isNaN);
        }
        const Xt = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        class Yt {
          constructor(t4, e2, r2, n2 = 1, i3 = true) {
            this.r = t4, this.g = e2, this.b = r2, this.a = n2, i3 || (this.r *= n2, this.g *= n2, this.b *= n2, n2 || this.overwriteGetter("rgb", [t4, e2, r2, n2]));
          }
          static parse(t4) {
            if (t4 instanceof Yt)
              return t4;
            if ("string" != typeof t4)
              return;
            const e2 = function(t5) {
              if ("transparent" === (t5 = t5.toLowerCase().trim()))
                return [0, 0, 0, 0];
              const e3 = Xt[t5];
              if (e3) {
                const [t6, r3, n2] = e3;
                return [t6 / 255, r3 / 255, n2 / 255, 1];
              }
              if (t5.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t5)) {
                const e4 = t5.length < 6 ? 1 : 2;
                let r3 = 1;
                return [Zt(t5.slice(r3, r3 += e4)), Zt(t5.slice(r3, r3 += e4)), Zt(t5.slice(r3, r3 += e4)), Zt(t5.slice(r3, r3 + e4) || "ff")];
              }
              if (t5.startsWith("rgb")) {
                const e4 = t5.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (e4) {
                  const [t6, r3, n2, i3, a2, s2, o2, l2, u2, c2, h2, p2] = e4, f2 = [i3 || " ", o2 || " ", c2].join("");
                  if ("  " === f2 || "  /" === f2 || ",," === f2 || ",,," === f2) {
                    const t7 = [n2, s2, u2].join(""), e5 = "%%%" === t7 ? 100 : "" === t7 ? 255 : 0;
                    if (e5) {
                      const t8 = [Gt(+r3 / e5, 0, 1), Gt(+a2 / e5, 0, 1), Gt(+l2 / e5, 0, 1), h2 ? Kt(+h2, p2) : 1];
                      if (Jt(t8))
                        return t8;
                    }
                  }
                  return;
                }
              }
              const r2 = t5.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (r2) {
                const [t6, e4, n2, i3, a2, s2, o2, l2, u2] = r2, c2 = [n2 || " ", a2 || " ", o2].join("");
                if ("  " === c2 || "  /" === c2 || ",," === c2 || ",,," === c2) {
                  const t7 = [+e4, Gt(+i3, 0, 100), Gt(+s2, 0, 100), l2 ? Kt(+l2, u2) : 1];
                  if (Jt(t7))
                    return function([t8, e5, r3, n3]) {
                      function i4(n4) {
                        const i5 = (n4 + t8 / 30) % 12, a3 = e5 * Math.min(r3, 1 - r3);
                        return r3 - a3 * Math.max(-1, Math.min(i5 - 3, 9 - i5, 1));
                      }
                      return t8 = Dt(t8), e5 /= 100, r3 /= 100, [i4(0), i4(8), i4(4), n3];
                    }(t7);
                }
              }
            }(t4);
            return e2 ? new Yt(...e2, false) : void 0;
          }
          get rgb() {
            const { r: t4, g: e2, b: r2, a: n2 } = this, i3 = n2 || 1 / 0;
            return this.overwriteGetter("rgb", [t4 / i3, e2 / i3, r2 / i3, n2]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", function(t4) {
              const [e2, r2, n2, i3] = Ot(t4), a2 = Math.sqrt(r2 * r2 + n2 * n2);
              return [Math.round(1e4 * a2) ? Dt(Math.atan2(n2, r2) * Lt) : NaN, a2, e2, i3];
            }(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Ot(this.rgb));
          }
          overwriteGetter(t4, e2) {
            return Object.defineProperty(this, t4, { value: e2 }), e2;
          }
          toString() {
            const [t4, e2, r2, n2] = this.rgb;
            return `rgba(${[t4, e2, r2].map((t5) => Math.round(255 * t5)).join(",")},${n2})`;
          }
        }
        Yt.black = new Yt(0, 0, 0, 1), Yt.white = new Yt(1, 1, 1, 1), Yt.transparent = new Yt(0, 0, 0, 0), Yt.red = new Yt(1, 0, 0, 1);
        class Ht {
          constructor(t4, e2, r2) {
            this.sensitivity = t4 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t4, e2) {
            return this.collator.compare(t4, e2);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Wt {
          constructor(t4, e2, r2, n2, i3) {
            this.text = t4, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i3;
          }
        }
        class Qt {
          constructor(t4) {
            this.sections = t4;
          }
          static fromString(t4) {
            return new Qt([new Wt(t4, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t4) => 0 !== t4.text.length || t4.image && 0 !== t4.image.name.length);
          }
          static factory(t4) {
            return t4 instanceof Qt ? t4 : Qt.fromString(t4);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t4) => t4.text).join("");
          }
        }
        class te {
          constructor(t4) {
            this.values = t4.slice();
          }
          static parse(t4) {
            if (t4 instanceof te)
              return t4;
            if ("number" == typeof t4)
              return new te([t4, t4, t4, t4]);
            if (Array.isArray(t4) && !(t4.length < 1 || t4.length > 4)) {
              for (const e2 of t4)
                if ("number" != typeof e2)
                  return;
              switch (t4.length) {
                case 1:
                  t4 = [t4[0], t4[0], t4[0], t4[0]];
                  break;
                case 2:
                  t4 = [t4[0], t4[1], t4[0], t4[1]];
                  break;
                case 3:
                  t4 = [t4[0], t4[1], t4[2], t4[1]];
              }
              return new te(t4);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        const ee = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class re {
          constructor(t4) {
            this.values = t4.slice();
          }
          static parse(t4) {
            if (t4 instanceof re)
              return t4;
            if (Array.isArray(t4) && !(t4.length < 1) && t4.length % 2 == 0) {
              for (let e2 = 0; e2 < t4.length; e2 += 2) {
                const r2 = t4[e2], n2 = t4[e2 + 1];
                if ("string" != typeof r2 || !ee.has(r2))
                  return;
                if (!Array.isArray(n2) || 2 !== n2.length || "number" != typeof n2[0] || "number" != typeof n2[1])
                  return;
              }
              return new re(t4);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
        }
        class ne {
          constructor(t4) {
            this.name = t4.name, this.available = t4.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t4) {
            return t4 ? new ne({ name: t4, available: false }) : null;
          }
        }
        function ie(t4, e2, r2, n2) {
          return "number" == typeof t4 && t4 >= 0 && t4 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t4, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t4, e2, r2, n2] : [t4, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function ae(t4) {
          if (null === t4 || "string" == typeof t4 || "boolean" == typeof t4 || "number" == typeof t4 || t4 instanceof Yt || t4 instanceof Ht || t4 instanceof Qt || t4 instanceof te || t4 instanceof re || t4 instanceof ne)
            return true;
          if (Array.isArray(t4)) {
            for (const e2 of t4)
              if (!ae(e2))
                return false;
            return true;
          }
          if ("object" == typeof t4) {
            for (const e2 in t4)
              if (!ae(t4[e2]))
                return false;
            return true;
          }
          return false;
        }
        function se(t4) {
          if (null === t4)
            return ht;
          if ("string" == typeof t4)
            return ft;
          if ("boolean" == typeof t4)
            return dt;
          if ("number" == typeof t4)
            return pt;
          if (t4 instanceof Yt)
            return yt;
          if (t4 instanceof Ht)
            return xt;
          if (t4 instanceof Qt)
            return vt;
          if (t4 instanceof te)
            return bt;
          if (t4 instanceof re)
            return _t;
          if (t4 instanceof ne)
            return wt;
          if (Array.isArray(t4)) {
            const e2 = t4.length;
            let r2;
            for (const e3 of t4) {
              const t5 = se(e3);
              if (r2) {
                if (r2 === t5)
                  continue;
                r2 = gt;
                break;
              }
              r2 = t5;
            }
            return At(r2 || gt, e2);
          }
          return mt;
        }
        function oe(t4) {
          const e2 = typeof t4;
          return null === t4 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t4) : t4 instanceof Yt || t4 instanceof Qt || t4 instanceof te || t4 instanceof re || t4 instanceof ne ? t4.toString() : JSON.stringify(t4);
        }
        class le {
          constructor(t4, e2) {
            this.type = t4, this.value = e2;
          }
          static parse(t4, e2) {
            if (2 !== t4.length)
              return e2.error(`'literal' expression requires exactly one argument, but found ${t4.length - 1} instead.`);
            if (!ae(t4[1]))
              return e2.error("invalid value");
            const r2 = t4[1];
            let n2 = se(r2);
            const i3 = e2.expectedType;
            return "array" !== n2.kind || 0 !== n2.N || !i3 || "array" !== i3.kind || "number" == typeof i3.N && 0 !== i3.N || (n2 = i3), new le(n2, r2);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class ue {
          constructor(t4) {
            this.name = "ExpressionEvaluationError", this.message = t4;
          }
          toJSON() {
            return this.message;
          }
        }
        const ce = { string: ft, number: pt, boolean: dt, object: mt };
        class he {
          constructor(t4, e2) {
            this.type = t4, this.args = e2;
          }
          static parse(t4, e2) {
            if (t4.length < 2)
              return e2.error("Expected at least one argument.");
            let r2, n2 = 1;
            const i3 = t4[0];
            if ("array" === i3) {
              let i4, a3;
              if (t4.length > 2) {
                const r3 = t4[1];
                if ("string" != typeof r3 || !(r3 in ce) || "object" === r3)
                  return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i4 = ce[r3], n2++;
              } else
                i4 = gt;
              if (t4.length > 3) {
                if (null !== t4[2] && ("number" != typeof t4[2] || t4[2] < 0 || t4[2] !== Math.floor(t4[2])))
                  return e2.error('The length argument to "array" must be a positive integer literal', 2);
                a3 = t4[2], n2++;
              }
              r2 = At(i4, a3);
            } else {
              if (!ce[i3])
                throw new Error(`Types doesn't contain name = ${i3}`);
              r2 = ce[i3];
            }
            const a2 = [];
            for (; n2 < t4.length; n2++) {
              const r3 = e2.parse(t4[n2], n2, gt);
              if (!r3)
                return null;
              a2.push(r3);
            }
            return new he(r2, a2);
          }
          evaluate(t4) {
            for (let e2 = 0; e2 < this.args.length; e2++) {
              const r2 = this.args[e2].evaluate(t4);
              if (!It(this.type, se(r2)))
                return r2;
              if (e2 === this.args.length - 1)
                throw new ue(`Expected value to be of type ${St(this.type)}, but found ${St(se(r2))} instead.`);
            }
            throw new Error();
          }
          eachChild(t4) {
            this.args.forEach(t4);
          }
          outputDefined() {
            return this.args.every((t4) => t4.outputDefined());
          }
        }
        const pe = { "to-boolean": dt, "to-color": yt, "to-number": pt, "to-string": ft };
        class fe {
          constructor(t4, e2) {
            this.type = t4, this.args = e2;
          }
          static parse(t4, e2) {
            if (t4.length < 2)
              return e2.error("Expected at least one argument.");
            const r2 = t4[0];
            if (!pe[r2])
              throw new Error(`Can't parse ${r2} as it is not part of the known types`);
            if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t4.length)
              return e2.error("Expected one argument.");
            const n2 = pe[r2], i3 = [];
            for (let r3 = 1; r3 < t4.length; r3++) {
              const n3 = e2.parse(t4[r3], r3, gt);
              if (!n3)
                return null;
              i3.push(n3);
            }
            return new fe(n2, i3);
          }
          evaluate(t4) {
            switch (this.type.kind) {
              case "boolean":
                return Boolean(this.args[0].evaluate(t4));
              case "color": {
                let e2, r2;
                for (const n2 of this.args) {
                  if (e2 = n2.evaluate(t4), r2 = null, e2 instanceof Yt)
                    return e2;
                  if ("string" == typeof e2) {
                    const r3 = t4.parseColor(e2);
                    if (r3)
                      return r3;
                  } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : ie(e2[0], e2[1], e2[2], e2[3]), !r2))
                    return new Yt(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
                }
                throw new ue(r2 || `Could not parse color from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "padding": {
                let e2;
                for (const r2 of this.args) {
                  e2 = r2.evaluate(t4);
                  const n2 = te.parse(e2);
                  if (n2)
                    return n2;
                }
                throw new ue(`Could not parse padding from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let e2;
                for (const r2 of this.args) {
                  e2 = r2.evaluate(t4);
                  const n2 = re.parse(e2);
                  if (n2)
                    return n2;
                }
                throw new ue(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
              }
              case "number": {
                let e2 = null;
                for (const r2 of this.args) {
                  if (e2 = r2.evaluate(t4), null === e2)
                    return 0;
                  const n2 = Number(e2);
                  if (!isNaN(n2))
                    return n2;
                }
                throw new ue(`Could not convert ${JSON.stringify(e2)} to number.`);
              }
              case "formatted":
                return Qt.fromString(oe(this.args[0].evaluate(t4)));
              case "resolvedImage":
                return ne.fromString(oe(this.args[0].evaluate(t4)));
              default:
                return oe(this.args[0].evaluate(t4));
            }
          }
          eachChild(t4) {
            this.args.forEach(t4);
          }
          outputDefined() {
            return this.args.every((t4) => t4.outputDefined());
          }
        }
        const de = ["Unknown", "Point", "LineString", "Polygon"];
        class ye {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? de[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t4) {
            let e2 = this._parseColorCache[t4];
            return e2 || (e2 = this._parseColorCache[t4] = Yt.parse(t4)), e2;
          }
        }
        class me {
          constructor(t4, e2, r2 = [], n2, i3 = new ct(), a2 = []) {
            this.registry = t4, this.path = r2, this.key = r2.map((t5) => `[${t5}]`).join(""), this.scope = i3, this.errors = a2, this.expectedType = n2, this._isConstant = e2;
          }
          parse(t4, e2, r2, n2, i3 = {}) {
            return e2 ? this.concat(e2, r2, n2)._parse(t4, i3) : this._parse(t4, i3);
          }
          _parse(t4, e2) {
            function r2(t5, e3, r3) {
              return "assert" === r3 ? new he(e3, [t5]) : "coerce" === r3 ? new fe(e3, [t5]) : t5;
            }
            if (null !== t4 && "string" != typeof t4 && "boolean" != typeof t4 && "number" != typeof t4 || (t4 = ["literal", t4]), Array.isArray(t4)) {
              if (0 === t4.length)
                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n2 = t4[0];
              if ("string" != typeof n2)
                return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const i3 = this.registry[n2];
              if (i3) {
                let n3 = i3.parse(t4, this);
                if (!n3)
                  return null;
                if (this.expectedType) {
                  const t5 = this.expectedType, i4 = n3.type;
                  if ("string" !== t5.kind && "number" !== t5.kind && "boolean" !== t5.kind && "object" !== t5.kind && "array" !== t5.kind || "value" !== i4.kind)
                    if ("color" !== t5.kind && "formatted" !== t5.kind && "resolvedImage" !== t5.kind || "value" !== i4.kind && "string" !== i4.kind)
                      if ("padding" !== t5.kind || "value" !== i4.kind && "number" !== i4.kind && "array" !== i4.kind)
                        if ("variableAnchorOffsetCollection" !== t5.kind || "value" !== i4.kind && "array" !== i4.kind) {
                          if (this.checkSubtype(t5, i4))
                            return null;
                        } else
                          n3 = r2(n3, t5, e2.typeAnnotation || "coerce");
                      else
                        n3 = r2(n3, t5, e2.typeAnnotation || "coerce");
                    else
                      n3 = r2(n3, t5, e2.typeAnnotation || "coerce");
                  else
                    n3 = r2(n3, t5, e2.typeAnnotation || "assert");
                }
                if (!(n3 instanceof le) && "resolvedImage" !== n3.type.kind && this._isConstant(n3)) {
                  const t5 = new ye();
                  try {
                    n3 = new le(n3.type, n3.evaluate(t5));
                  } catch (t6) {
                    return this.error(t6.message), null;
                  }
                }
                return n3;
              }
              return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(void 0 === t4 ? "'undefined' value invalid. Use null instead." : "object" == typeof t4 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t4} instead.`);
          }
          concat(t4, e2, r2) {
            const n2 = "number" == typeof t4 ? this.path.concat(t4) : this.path, i3 = r2 ? this.scope.concat(r2) : this.scope;
            return new me(this.registry, this._isConstant, n2, e2 || null, i3, this.errors);
          }
          error(t4, ...e2) {
            const r2 = `${this.key}${e2.map((t5) => `[${t5}]`).join("")}`;
            this.errors.push(new ut(r2, t4));
          }
          checkSubtype(t4, e2) {
            const r2 = It(t4, e2);
            return r2 && this.error(r2), r2;
          }
        }
        class ge {
          constructor(t4, e2, r2) {
            this.type = xt, this.locale = r2, this.caseSensitive = t4, this.diacriticSensitive = e2;
          }
          static parse(t4, e2) {
            if (2 !== t4.length)
              return e2.error("Expected one argument.");
            const r2 = t4[1];
            if ("object" != typeof r2 || Array.isArray(r2))
              return e2.error("Collator options argument must be an object.");
            const n2 = e2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, dt);
            if (!n2)
              return null;
            const i3 = e2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, dt);
            if (!i3)
              return null;
            let a2 = null;
            return r2.locale && (a2 = e2.parse(r2.locale, 1, ft), !a2) ? null : new ge(n2, i3, a2);
          }
          evaluate(t4) {
            return new Ht(this.caseSensitive.evaluate(t4), this.diacriticSensitive.evaluate(t4), this.locale ? this.locale.evaluate(t4) : null);
          }
          eachChild(t4) {
            t4(this.caseSensitive), t4(this.diacriticSensitive), this.locale && t4(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        const xe = 8192;
        function ve(t4, e2) {
          t4[0] = Math.min(t4[0], e2[0]), t4[1] = Math.min(t4[1], e2[1]), t4[2] = Math.max(t4[2], e2[0]), t4[3] = Math.max(t4[3], e2[1]);
        }
        function be(t4, e2) {
          return !(t4[0] <= e2[0] || t4[2] >= e2[2] || t4[1] <= e2[1] || t4[3] >= e2[3]);
        }
        function we(t4, e2) {
          const r2 = (180 + t4[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t4[1] * Math.PI / 360))) / 360, i3 = Math.pow(2, e2.z);
          return [Math.round(r2 * i3 * xe), Math.round(n2 * i3 * xe)];
        }
        function _e(t4, e2, r2) {
          const n2 = t4[0] - e2[0], i3 = t4[1] - e2[1], a2 = t4[0] - r2[0], s2 = t4[1] - r2[1];
          return n2 * s2 - a2 * i3 == 0 && n2 * a2 <= 0 && i3 * s2 <= 0;
        }
        function Ae(t4, e2) {
          let r2 = false;
          for (let s2 = 0, o2 = e2.length; s2 < o2; s2++) {
            const o3 = e2[s2];
            for (let e3 = 0, s3 = o3.length; e3 < s3 - 1; e3++) {
              if (_e(t4, o3[e3], o3[e3 + 1]))
                return false;
              (i3 = o3[e3])[1] > (n2 = t4)[1] != (a2 = o3[e3 + 1])[1] > n2[1] && n2[0] < (a2[0] - i3[0]) * (n2[1] - i3[1]) / (a2[1] - i3[1]) + i3[0] && (r2 = !r2);
            }
          }
          var n2, i3, a2;
          return r2;
        }
        function Se(t4, e2) {
          for (let r2 = 0; r2 < e2.length; r2++)
            if (Ae(t4, e2[r2]))
              return true;
          return false;
        }
        function ke(t4, e2, r2, n2) {
          const i3 = n2[0] - r2[0], a2 = n2[1] - r2[1], s2 = (t4[0] - r2[0]) * a2 - i3 * (t4[1] - r2[1]), o2 = (e2[0] - r2[0]) * a2 - i3 * (e2[1] - r2[1]);
          return s2 > 0 && o2 < 0 || s2 < 0 && o2 > 0;
        }
        function Ie(t4, e2, r2) {
          for (const u2 of r2)
            for (let r3 = 0; r3 < u2.length - 1; ++r3)
              if (0 != (o2 = [(s2 = u2[r3 + 1])[0] - (a2 = u2[r3])[0], s2[1] - a2[1]])[0] * (l2 = [(i3 = e2)[0] - (n2 = t4)[0], i3[1] - n2[1]])[1] - o2[1] * l2[0] && ke(n2, i3, a2, s2) && ke(a2, s2, n2, i3))
                return true;
          var n2, i3, a2, s2, o2, l2;
          return false;
        }
        function ze(t4, e2) {
          for (let r2 = 0; r2 < t4.length; ++r2)
            if (!Ae(t4[r2], e2))
              return false;
          for (let r2 = 0; r2 < t4.length - 1; ++r2)
            if (Ie(t4[r2], t4[r2 + 1], e2))
              return false;
          return true;
        }
        function Me(t4, e2) {
          for (let r2 = 0; r2 < e2.length; r2++)
            if (ze(t4, e2[r2]))
              return true;
          return false;
        }
        function Ce(t4, e2, r2) {
          const n2 = [];
          for (let i3 = 0; i3 < t4.length; i3++) {
            const a2 = [];
            for (let n3 = 0; n3 < t4[i3].length; n3++) {
              const s2 = we(t4[i3][n3], r2);
              ve(e2, s2), a2.push(s2);
            }
            n2.push(a2);
          }
          return n2;
        }
        function Be(t4, e2, r2) {
          const n2 = [];
          for (let i3 = 0; i3 < t4.length; i3++) {
            const a2 = Ce(t4[i3], e2, r2);
            n2.push(a2);
          }
          return n2;
        }
        function Pe(t4, e2, r2, n2) {
          if (t4[0] < r2[0] || t4[0] > r2[2]) {
            const e3 = 0.5 * n2;
            let i3 = t4[0] - r2[0] > e3 ? -n2 : r2[0] - t4[0] > e3 ? n2 : 0;
            0 === i3 && (i3 = t4[0] - r2[2] > e3 ? -n2 : r2[2] - t4[0] > e3 ? n2 : 0), t4[0] += i3;
          }
          ve(e2, t4);
        }
        function Ve(t4, e2, r2, n2) {
          const i3 = Math.pow(2, n2.z) * xe, a2 = [n2.x * xe, n2.y * xe], s2 = [];
          for (const n3 of t4)
            for (const t5 of n3) {
              const n4 = [t5.x + a2[0], t5.y + a2[1]];
              Pe(n4, e2, r2, i3), s2.push(n4);
            }
          return s2;
        }
        function Ee(t4, e2, r2, n2) {
          const i3 = Math.pow(2, n2.z) * xe, a2 = [n2.x * xe, n2.y * xe], s2 = [];
          for (const r3 of t4) {
            const t5 = [];
            for (const n3 of r3) {
              const r4 = [n3.x + a2[0], n3.y + a2[1]];
              ve(e2, r4), t5.push(r4);
            }
            s2.push(t5);
          }
          if (e2[2] - e2[0] <= i3 / 2) {
            (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
            for (const t5 of s2)
              for (const n3 of t5)
                Pe(n3, e2, r2, i3);
          }
          var o2;
          return s2;
        }
        class Fe {
          constructor(t4, e2) {
            this.type = dt, this.geojson = t4, this.geometries = e2;
          }
          static parse(t4, e2) {
            if (2 !== t4.length)
              return e2.error(`'within' expression requires exactly one argument, but found ${t4.length - 1} instead.`);
            if (ae(t4[1])) {
              const e3 = t4[1];
              if ("FeatureCollection" === e3.type)
                for (let t5 = 0; t5 < e3.features.length; ++t5) {
                  const r2 = e3.features[t5].geometry.type;
                  if ("Polygon" === r2 || "MultiPolygon" === r2)
                    return new Fe(e3, e3.features[t5].geometry);
                }
              else if ("Feature" === e3.type) {
                const t5 = e3.geometry.type;
                if ("Polygon" === t5 || "MultiPolygon" === t5)
                  return new Fe(e3, e3.geometry);
              } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type)
                return new Fe(e3, e3);
            }
            return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t4) {
            if (null != t4.geometry() && null != t4.canonicalID()) {
              if ("Point" === t4.geometryType())
                return function(t5, e2) {
                  const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t5.canonicalID();
                  if ("Polygon" === e2.type) {
                    const a2 = Ce(e2.coordinates, n2, i3), s2 = Ve(t5.geometry(), r2, n2, i3);
                    if (!be(r2, n2))
                      return false;
                    for (const t6 of s2)
                      if (!Ae(t6, a2))
                        return false;
                  }
                  if ("MultiPolygon" === e2.type) {
                    const a2 = Be(e2.coordinates, n2, i3), s2 = Ve(t5.geometry(), r2, n2, i3);
                    if (!be(r2, n2))
                      return false;
                    for (const t6 of s2)
                      if (!Se(t6, a2))
                        return false;
                  }
                  return true;
                }(t4, this.geometries);
              if ("LineString" === t4.geometryType())
                return function(t5, e2) {
                  const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t5.canonicalID();
                  if ("Polygon" === e2.type) {
                    const a2 = Ce(e2.coordinates, n2, i3), s2 = Ee(t5.geometry(), r2, n2, i3);
                    if (!be(r2, n2))
                      return false;
                    for (const t6 of s2)
                      if (!ze(t6, a2))
                        return false;
                  }
                  if ("MultiPolygon" === e2.type) {
                    const a2 = Be(e2.coordinates, n2, i3), s2 = Ee(t5.geometry(), r2, n2, i3);
                    if (!be(r2, n2))
                      return false;
                    for (const t6 of s2)
                      if (!Me(t6, a2))
                        return false;
                  }
                  return true;
                }(t4, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class Te {
          constructor(t4, e2) {
            this.type = e2.type, this.name = t4, this.boundExpression = e2;
          }
          static parse(t4, e2) {
            if (2 !== t4.length || "string" != typeof t4[1])
              return e2.error("'var' expression requires exactly one string literal argument.");
            const r2 = t4[1];
            return e2.scope.has(r2) ? new Te(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t4) {
            return this.boundExpression.evaluate(t4);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class $e {
          constructor(t4, e2, r2, n2) {
            this.name = t4, this.type = e2, this._evaluate = r2, this.args = n2;
          }
          evaluate(t4) {
            return this._evaluate(t4, this.args);
          }
          eachChild(t4) {
            this.args.forEach(t4);
          }
          outputDefined() {
            return false;
          }
          static parse(t4, e2) {
            const r2 = t4[0], n2 = $e.definitions[r2];
            if (!n2)
              return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i3 = Array.isArray(n2) ? n2[0] : n2.type, a2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, s2 = a2.filter(([e3]) => !Array.isArray(e3) || e3.length === t4.length - 1);
            let o2 = null;
            for (const [n3, a3] of s2) {
              o2 = new me(e2.registry, Le, e2.path, null, e2.scope);
              const s3 = [];
              let l2 = false;
              for (let e3 = 1; e3 < t4.length; e3++) {
                const r3 = t4[e3], i4 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, a4 = o2.parse(r3, 1 + s3.length, i4);
                if (!a4) {
                  l2 = true;
                  break;
                }
                s3.push(a4);
              }
              if (!l2)
                if (Array.isArray(n3) && n3.length !== s3.length)
                  o2.error(`Expected ${n3.length} arguments, but found ${s3.length} instead.`);
                else {
                  for (let t5 = 0; t5 < s3.length; t5++) {
                    const e3 = Array.isArray(n3) ? n3[t5] : n3.type, r3 = s3[t5];
                    o2.concat(t5 + 1).checkSubtype(e3, r3.type);
                  }
                  if (0 === o2.errors.length)
                    return new $e(r2, i3, a3, s3);
                }
            }
            if (1 === s2.length)
              e2.errors.push(...o2.errors);
            else {
              const r3 = (s2.length ? s2 : a2).map(([t5]) => {
                return e3 = t5, Array.isArray(e3) ? `(${e3.map(St).join(", ")})` : `(${St(e3.type)}...)`;
                var e3;
              }).join(" | "), n3 = [];
              for (let r4 = 1; r4 < t4.length; r4++) {
                const i4 = e2.parse(t4[r4], 1 + n3.length);
                if (!i4)
                  return null;
                n3.push(St(i4.type));
              }
              e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t4, e2) {
            $e.definitions = e2;
            for (const r2 in e2)
              t4[r2] = $e;
          }
        }
        function Le(t4) {
          if (t4 instanceof Te)
            return Le(t4.boundExpression);
          if (t4 instanceof $e && "error" === t4.name)
            return false;
          if (t4 instanceof ge)
            return false;
          if (t4 instanceof Fe)
            return false;
          const e2 = t4 instanceof fe || t4 instanceof he;
          let r2 = true;
          return t4.eachChild((t5) => {
            r2 = e2 ? r2 && Le(t5) : r2 && t5 instanceof le;
          }), !!r2 && De(t4) && Ue(t4, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
        }
        function De(t4) {
          if (t4 instanceof $e) {
            if ("get" === t4.name && 1 === t4.args.length)
              return false;
            if ("feature-state" === t4.name)
              return false;
            if ("has" === t4.name && 1 === t4.args.length)
              return false;
            if ("properties" === t4.name || "geometry-type" === t4.name || "id" === t4.name)
              return false;
            if (/^filter-/.test(t4.name))
              return false;
          }
          if (t4 instanceof Fe)
            return false;
          let e2 = true;
          return t4.eachChild((t5) => {
            e2 && !De(t5) && (e2 = false);
          }), e2;
        }
        function Oe(t4) {
          if (t4 instanceof $e && "feature-state" === t4.name)
            return false;
          let e2 = true;
          return t4.eachChild((t5) => {
            e2 && !Oe(t5) && (e2 = false);
          }), e2;
        }
        function Ue(t4, e2) {
          if (t4 instanceof $e && e2.indexOf(t4.name) >= 0)
            return false;
          let r2 = true;
          return t4.eachChild((t5) => {
            r2 && !Ue(t5, e2) && (r2 = false);
          }), r2;
        }
        function Re(t4, e2) {
          const r2 = t4.length - 1;
          let n2, i3, a2 = 0, s2 = r2, o2 = 0;
          for (; a2 <= s2; )
            if (o2 = Math.floor((a2 + s2) / 2), n2 = t4[o2], i3 = t4[o2 + 1], n2 <= e2) {
              if (o2 === r2 || e2 < i3)
                return o2;
              a2 = o2 + 1;
            } else {
              if (!(n2 > e2))
                throw new ue("Input is not a number.");
              s2 = o2 - 1;
            }
          return 0;
        }
        class qe {
          constructor(t4, e2, r2) {
            this.type = t4, this.input = e2, this.labels = [], this.outputs = [];
            for (const [t5, e3] of r2)
              this.labels.push(t5), this.outputs.push(e3);
          }
          static parse(t4, e2) {
            if (t4.length - 1 < 4)
              return e2.error(`Expected at least 4 arguments, but found only ${t4.length - 1}.`);
            if ((t4.length - 1) % 2 != 0)
              return e2.error("Expected an even number of arguments.");
            const r2 = e2.parse(t4[1], 1, pt);
            if (!r2)
              return null;
            const n2 = [];
            let i3 = null;
            e2.expectedType && "value" !== e2.expectedType.kind && (i3 = e2.expectedType);
            for (let r3 = 1; r3 < t4.length; r3 += 2) {
              const a2 = 1 === r3 ? -1 / 0 : t4[r3], s2 = t4[r3 + 1], o2 = r3, l2 = r3 + 1;
              if ("number" != typeof a2)
                return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
              if (n2.length && n2[n2.length - 1][0] >= a2)
                return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
              const u2 = e2.parse(s2, l2, i3);
              if (!u2)
                return null;
              i3 = i3 || u2.type, n2.push([a2, u2]);
            }
            return new qe(i3, r2, n2);
          }
          evaluate(t4) {
            const e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length)
              return r2[0].evaluate(t4);
            const n2 = this.input.evaluate(t4);
            if (n2 <= e2[0])
              return r2[0].evaluate(t4);
            const i3 = e2.length;
            return n2 >= e2[i3 - 1] ? r2[i3 - 1].evaluate(t4) : r2[Re(e2, n2)].evaluate(t4);
          }
          eachChild(t4) {
            t4(this.input);
            for (const e2 of this.outputs)
              t4(e2);
          }
          outputDefined() {
            return this.outputs.every((t4) => t4.outputDefined());
          }
        }
        function je(t4, e2, r2) {
          return t4 + r2 * (e2 - t4);
        }
        function Ne(t4, e2, r2) {
          return t4.map((t5, n2) => je(t5, e2[n2], r2));
        }
        const Ze = { number: je, color: function(t4, e2, r2, n2 = "rgb") {
          switch (n2) {
            case "rgb": {
              const [n3, i3, a2, s2] = Ne(t4.rgb, e2.rgb, r2);
              return new Yt(n3, i3, a2, s2, false);
            }
            case "hcl": {
              const [n3, i3, a2, s2] = t4.hcl, [o2, l2, u2, c2] = e2.hcl;
              let h2, p2;
              if (isNaN(n3) || isNaN(o2))
                isNaN(n3) ? isNaN(o2) ? h2 = NaN : (h2 = o2, 1 !== a2 && 0 !== a2 || (p2 = l2)) : (h2 = n3, 1 !== u2 && 0 !== u2 || (p2 = i3));
              else {
                let t5 = o2 - n3;
                o2 > n3 && t5 > 180 ? t5 -= 360 : o2 < n3 && n3 - o2 > 180 && (t5 += 360), h2 = n3 + r2 * t5;
              }
              const [f2, d2, y2, m2] = function([t5, e3, r3, n4]) {
                return t5 = isNaN(t5) ? 0 : t5 * $t, qt([r3, Math.cos(t5) * e3, Math.sin(t5) * e3, n4]);
              }([h2, null != p2 ? p2 : je(i3, l2, r2), je(a2, u2, r2), je(s2, c2, r2)]);
              return new Yt(f2, d2, y2, m2, false);
            }
            case "lab": {
              const [n3, i3, a2, s2] = qt(Ne(t4.lab, e2.lab, r2));
              return new Yt(n3, i3, a2, s2, false);
            }
          }
        }, array: Ne, padding: function(t4, e2, r2) {
          return new te(Ne(t4.values, e2.values, r2));
        }, variableAnchorOffsetCollection: function(t4, e2, r2) {
          const n2 = t4.values, i3 = e2.values;
          if (n2.length !== i3.length)
            throw new ue(`Cannot interpolate values of different length. from: ${t4.toString()}, to: ${e2.toString()}`);
          const a2 = [];
          for (let t5 = 0; t5 < n2.length; t5 += 2) {
            if (n2[t5] !== i3[t5])
              throw new ue(`Cannot interpolate values containing mismatched anchors. from[${t5}]: ${n2[t5]}, to[${t5}]: ${i3[t5]}`);
            a2.push(n2[t5]);
            const [e3, s2] = n2[t5 + 1], [o2, l2] = i3[t5 + 1];
            a2.push([je(e3, o2, r2), je(s2, l2, r2)]);
          }
          return new re(a2);
        } };
        class Ke {
          constructor(t4, e2, r2, n2, i3) {
            this.type = t4, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
            for (const [t5, e3] of i3)
              this.labels.push(t5), this.outputs.push(e3);
          }
          static interpolationFactor(t4, e2, r2, n2) {
            let i3 = 0;
            if ("exponential" === t4.name)
              i3 = Ge(e2, t4.base, r2, n2);
            else if ("linear" === t4.name)
              i3 = Ge(e2, 1, r2, n2);
            else if ("cubic-bezier" === t4.name) {
              const a2 = t4.controlPoints;
              i3 = new l(a2[0], a2[1], a2[2], a2[3]).solve(Ge(e2, 1, r2, n2));
            }
            return i3;
          }
          static parse(t4, e2) {
            let [r2, n2, i3, ...a2] = t4;
            if (!Array.isArray(n2) || 0 === n2.length)
              return e2.error("Expected an interpolation type expression.", 1);
            if ("linear" === n2[0])
              n2 = { name: "linear" };
            else if ("exponential" === n2[0]) {
              const t5 = n2[1];
              if ("number" != typeof t5)
                return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
              n2 = { name: "exponential", base: t5 };
            } else {
              if ("cubic-bezier" !== n2[0])
                return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
              {
                const t5 = n2.slice(1);
                if (4 !== t5.length || t5.some((t6) => "number" != typeof t6 || t6 < 0 || t6 > 1))
                  return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n2 = { name: "cubic-bezier", controlPoints: t5 };
              }
            }
            if (t4.length - 1 < 4)
              return e2.error(`Expected at least 4 arguments, but found only ${t4.length - 1}.`);
            if ((t4.length - 1) % 2 != 0)
              return e2.error("Expected an even number of arguments.");
            if (i3 = e2.parse(i3, 2, pt), !i3)
              return null;
            const s2 = [];
            let o2 = null;
            "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? o2 = yt : e2.expectedType && "value" !== e2.expectedType.kind && (o2 = e2.expectedType);
            for (let t5 = 0; t5 < a2.length; t5 += 2) {
              const r3 = a2[t5], n3 = a2[t5 + 1], i4 = t5 + 3, l2 = t5 + 4;
              if ("number" != typeof r3)
                return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i4);
              if (s2.length && s2[s2.length - 1][0] >= r3)
                return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i4);
              const u2 = e2.parse(n3, l2, o2);
              if (!u2)
                return null;
              o2 = o2 || u2.type, s2.push([r3, u2]);
            }
            return Ct(o2, pt) || Ct(o2, yt) || Ct(o2, bt) || Ct(o2, _t) || Ct(o2, At(pt)) ? new Ke(o2, r2, n2, i3, s2) : e2.error(`Type ${St(o2)} is not interpolatable.`);
          }
          evaluate(t4) {
            const e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length)
              return r2[0].evaluate(t4);
            const n2 = this.input.evaluate(t4);
            if (n2 <= e2[0])
              return r2[0].evaluate(t4);
            const i3 = e2.length;
            if (n2 >= e2[i3 - 1])
              return r2[i3 - 1].evaluate(t4);
            const a2 = Re(e2, n2), s2 = Ke.interpolationFactor(this.interpolation, n2, e2[a2], e2[a2 + 1]), o2 = r2[a2].evaluate(t4), l2 = r2[a2 + 1].evaluate(t4);
            switch (this.operator) {
              case "interpolate":
                return Ze[this.type.kind](o2, l2, s2);
              case "interpolate-hcl":
                return Ze.color(o2, l2, s2, "hcl");
              case "interpolate-lab":
                return Ze.color(o2, l2, s2, "lab");
            }
          }
          eachChild(t4) {
            t4(this.input);
            for (const e2 of this.outputs)
              t4(e2);
          }
          outputDefined() {
            return this.outputs.every((t4) => t4.outputDefined());
          }
        }
        function Ge(t4, e2, r2, n2) {
          const i3 = n2 - r2, a2 = t4 - r2;
          return 0 === i3 ? 0 : 1 === e2 ? a2 / i3 : (Math.pow(e2, a2) - 1) / (Math.pow(e2, i3) - 1);
        }
        class Je {
          constructor(t4, e2) {
            this.type = t4, this.args = e2;
          }
          static parse(t4, e2) {
            if (t4.length < 2)
              return e2.error("Expectected at least one argument.");
            let r2 = null;
            const n2 = e2.expectedType;
            n2 && "value" !== n2.kind && (r2 = n2);
            const i3 = [];
            for (const n3 of t4.slice(1)) {
              const t5 = e2.parse(n3, 1 + i3.length, r2, void 0, { typeAnnotation: "omit" });
              if (!t5)
                return null;
              r2 = r2 || t5.type, i3.push(t5);
            }
            if (!r2)
              throw new Error("No output type");
            const a2 = n2 && i3.some((t5) => It(n2, t5.type));
            return new Je(a2 ? gt : r2, i3);
          }
          evaluate(t4) {
            let e2, r2 = null, n2 = 0;
            for (const i3 of this.args)
              if (n2++, r2 = i3.evaluate(t4), r2 && r2 instanceof ne && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), null !== r2)
                break;
            return r2;
          }
          eachChild(t4) {
            this.args.forEach(t4);
          }
          outputDefined() {
            return this.args.every((t4) => t4.outputDefined());
          }
        }
        class Xe {
          constructor(t4, e2) {
            this.type = e2.type, this.bindings = [].concat(t4), this.result = e2;
          }
          evaluate(t4) {
            return this.result.evaluate(t4);
          }
          eachChild(t4) {
            for (const e2 of this.bindings)
              t4(e2[1]);
            t4(this.result);
          }
          static parse(t4, e2) {
            if (t4.length < 4)
              return e2.error(`Expected at least 3 arguments, but found ${t4.length - 1} instead.`);
            const r2 = [];
            for (let n3 = 1; n3 < t4.length - 1; n3 += 2) {
              const i3 = t4[n3];
              if ("string" != typeof i3)
                return e2.error(`Expected string, but found ${typeof i3} instead.`, n3);
              if (/[^a-zA-Z0-9_]/.test(i3))
                return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
              const a2 = e2.parse(t4[n3 + 1], n3 + 1);
              if (!a2)
                return null;
              r2.push([i3, a2]);
            }
            const n2 = e2.parse(t4[t4.length - 1], t4.length - 1, e2.expectedType, r2);
            return n2 ? new Xe(r2, n2) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Ye {
          constructor(t4, e2, r2) {
            this.type = t4, this.index = e2, this.input = r2;
          }
          static parse(t4, e2) {
            if (3 !== t4.length)
              return e2.error(`Expected 2 arguments, but found ${t4.length - 1} instead.`);
            const r2 = e2.parse(t4[1], 1, pt), n2 = e2.parse(t4[2], 2, At(e2.expectedType || gt));
            return r2 && n2 ? new Ye(n2.type.itemType, r2, n2) : null;
          }
          evaluate(t4) {
            const e2 = this.index.evaluate(t4), r2 = this.input.evaluate(t4);
            if (e2 < 0)
              throw new ue(`Array index out of bounds: ${e2} < 0.`);
            if (e2 >= r2.length)
              throw new ue(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
            if (e2 !== Math.floor(e2))
              throw new ue(`Array index must be an integer, but found ${e2} instead.`);
            return r2[e2];
          }
          eachChild(t4) {
            t4(this.index), t4(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class He {
          constructor(t4, e2) {
            this.type = dt, this.needle = t4, this.haystack = e2;
          }
          static parse(t4, e2) {
            if (3 !== t4.length)
              return e2.error(`Expected 2 arguments, but found ${t4.length - 1} instead.`);
            const r2 = e2.parse(t4[1], 1, gt), n2 = e2.parse(t4[2], 2, gt);
            return r2 && n2 ? zt(r2.type, [dt, ft, pt, ht, gt]) ? new He(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${St(r2.type)} instead`) : null;
          }
          evaluate(t4) {
            const e2 = this.needle.evaluate(t4), r2 = this.haystack.evaluate(t4);
            if (!r2)
              return false;
            if (!Mt(e2, ["boolean", "string", "number", "null"]))
              throw new ue(`Expected first argument to be of type boolean, string, number or null, but found ${St(se(e2))} instead.`);
            if (!Mt(r2, ["string", "array"]))
              throw new ue(`Expected second argument to be of type array or string, but found ${St(se(r2))} instead.`);
            return r2.indexOf(e2) >= 0;
          }
          eachChild(t4) {
            t4(this.needle), t4(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class We {
          constructor(t4, e2, r2) {
            this.type = pt, this.needle = t4, this.haystack = e2, this.fromIndex = r2;
          }
          static parse(t4, e2) {
            if (t4.length <= 2 || t4.length >= 5)
              return e2.error(`Expected 3 or 4 arguments, but found ${t4.length - 1} instead.`);
            const r2 = e2.parse(t4[1], 1, gt), n2 = e2.parse(t4[2], 2, gt);
            if (!r2 || !n2)
              return null;
            if (!zt(r2.type, [dt, ft, pt, ht, gt]))
              return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${St(r2.type)} instead`);
            if (4 === t4.length) {
              const i3 = e2.parse(t4[3], 3, pt);
              return i3 ? new We(r2, n2, i3) : null;
            }
            return new We(r2, n2);
          }
          evaluate(t4) {
            const e2 = this.needle.evaluate(t4), r2 = this.haystack.evaluate(t4);
            if (!Mt(e2, ["boolean", "string", "number", "null"]))
              throw new ue(`Expected first argument to be of type boolean, string, number or null, but found ${St(se(e2))} instead.`);
            if (!Mt(r2, ["string", "array"]))
              throw new ue(`Expected second argument to be of type array or string, but found ${St(se(r2))} instead.`);
            if (this.fromIndex) {
              const n2 = this.fromIndex.evaluate(t4);
              return r2.indexOf(e2, n2);
            }
            return r2.indexOf(e2);
          }
          eachChild(t4) {
            t4(this.needle), t4(this.haystack), this.fromIndex && t4(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class Qe {
          constructor(t4, e2, r2, n2, i3, a2) {
            this.inputType = t4, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i3, this.otherwise = a2;
          }
          static parse(t4, e2) {
            if (t4.length < 5)
              return e2.error(`Expected at least 4 arguments, but found only ${t4.length - 1}.`);
            if (t4.length % 2 != 1)
              return e2.error("Expected an even number of arguments.");
            let r2, n2;
            e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
            const i3 = {}, a2 = [];
            for (let s3 = 2; s3 < t4.length - 1; s3 += 2) {
              let o3 = t4[s3];
              const l2 = t4[s3 + 1];
              Array.isArray(o3) || (o3 = [o3]);
              const u2 = e2.concat(s3);
              if (0 === o3.length)
                return u2.error("Expected at least one branch label.");
              for (const t5 of o3) {
                if ("number" != typeof t5 && "string" != typeof t5)
                  return u2.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t5 && Math.abs(t5) > Number.MAX_SAFE_INTEGER)
                  return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t5 && Math.floor(t5) !== t5)
                  return u2.error("Numeric branch labels must be integer values.");
                if (r2) {
                  if (u2.checkSubtype(r2, se(t5)))
                    return null;
                } else
                  r2 = se(t5);
                if (void 0 !== i3[String(t5)])
                  return u2.error("Branch labels must be unique.");
                i3[String(t5)] = a2.length;
              }
              const c2 = e2.parse(l2, s3, n2);
              if (!c2)
                return null;
              n2 = n2 || c2.type, a2.push(c2);
            }
            const s2 = e2.parse(t4[1], 1, gt);
            if (!s2)
              return null;
            const o2 = e2.parse(t4[t4.length - 1], t4.length - 1, n2);
            return o2 ? "value" !== s2.type.kind && e2.concat(1).checkSubtype(r2, s2.type) ? null : new Qe(r2, n2, s2, i3, a2, o2) : null;
          }
          evaluate(t4) {
            const e2 = this.input.evaluate(t4);
            return (se(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t4);
          }
          eachChild(t4) {
            t4(this.input), this.outputs.forEach(t4), t4(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t4) => t4.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class tr {
          constructor(t4, e2, r2) {
            this.type = t4, this.branches = e2, this.otherwise = r2;
          }
          static parse(t4, e2) {
            if (t4.length < 4)
              return e2.error(`Expected at least 3 arguments, but found only ${t4.length - 1}.`);
            if (t4.length % 2 != 0)
              return e2.error("Expected an odd number of arguments.");
            let r2;
            e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
            const n2 = [];
            for (let i4 = 1; i4 < t4.length - 1; i4 += 2) {
              const a2 = e2.parse(t4[i4], i4, dt);
              if (!a2)
                return null;
              const s2 = e2.parse(t4[i4 + 1], i4 + 1, r2);
              if (!s2)
                return null;
              n2.push([a2, s2]), r2 = r2 || s2.type;
            }
            const i3 = e2.parse(t4[t4.length - 1], t4.length - 1, r2);
            if (!i3)
              return null;
            if (!r2)
              throw new Error("Can't infer output type");
            return new tr(r2, n2, i3);
          }
          evaluate(t4) {
            for (const [e2, r2] of this.branches)
              if (e2.evaluate(t4))
                return r2.evaluate(t4);
            return this.otherwise.evaluate(t4);
          }
          eachChild(t4) {
            for (const [e2, r2] of this.branches)
              t4(e2), t4(r2);
            t4(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t4, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class er {
          constructor(t4, e2, r2, n2) {
            this.type = t4, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
          }
          static parse(t4, e2) {
            if (t4.length <= 2 || t4.length >= 5)
              return e2.error(`Expected 3 or 4 arguments, but found ${t4.length - 1} instead.`);
            const r2 = e2.parse(t4[1], 1, gt), n2 = e2.parse(t4[2], 2, pt);
            if (!r2 || !n2)
              return null;
            if (!zt(r2.type, [At(gt), ft, gt]))
              return e2.error(`Expected first argument to be of type array or string, but found ${St(r2.type)} instead`);
            if (4 === t4.length) {
              const i3 = e2.parse(t4[3], 3, pt);
              return i3 ? new er(r2.type, r2, n2, i3) : null;
            }
            return new er(r2.type, r2, n2);
          }
          evaluate(t4) {
            const e2 = this.input.evaluate(t4), r2 = this.beginIndex.evaluate(t4);
            if (!Mt(e2, ["string", "array"]))
              throw new ue(`Expected first argument to be of type array or string, but found ${St(se(e2))} instead.`);
            if (this.endIndex) {
              const n2 = this.endIndex.evaluate(t4);
              return e2.slice(r2, n2);
            }
            return e2.slice(r2);
          }
          eachChild(t4) {
            t4(this.input), t4(this.beginIndex), this.endIndex && t4(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function rr(t4, e2) {
          return "==" === t4 || "!=" === t4 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
        }
        function nr(t4, e2, r2, n2) {
          return 0 === n2.compare(e2, r2);
        }
        function ir(t4, e2, r2) {
          const n2 = "==" !== t4 && "!=" !== t4;
          return class i3 {
            constructor(t5, e3, r3) {
              this.type = dt, this.lhs = t5, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t5.type.kind || "value" === e3.type.kind;
            }
            static parse(t5, e3) {
              if (3 !== t5.length && 4 !== t5.length)
                return e3.error("Expected two or three arguments.");
              const r3 = t5[0];
              let a2 = e3.parse(t5[1], 1, gt);
              if (!a2)
                return null;
              if (!rr(r3, a2.type))
                return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${St(a2.type)}'.`);
              let s2 = e3.parse(t5[2], 2, gt);
              if (!s2)
                return null;
              if (!rr(r3, s2.type))
                return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${St(s2.type)}'.`);
              if (a2.type.kind !== s2.type.kind && "value" !== a2.type.kind && "value" !== s2.type.kind)
                return e3.error(`Cannot compare types '${St(a2.type)}' and '${St(s2.type)}'.`);
              n2 && ("value" === a2.type.kind && "value" !== s2.type.kind ? a2 = new he(s2.type, [a2]) : "value" !== a2.type.kind && "value" === s2.type.kind && (s2 = new he(a2.type, [s2])));
              let o2 = null;
              if (4 === t5.length) {
                if ("string" !== a2.type.kind && "string" !== s2.type.kind && "value" !== a2.type.kind && "value" !== s2.type.kind)
                  return e3.error("Cannot use collator to compare non-string types.");
                if (o2 = e3.parse(t5[3], 3, xt), !o2)
                  return null;
              }
              return new i3(a2, s2, o2);
            }
            evaluate(i4) {
              const a2 = this.lhs.evaluate(i4), s2 = this.rhs.evaluate(i4);
              if (n2 && this.hasUntypedArgument) {
                const e3 = se(a2), r3 = se(s2);
                if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind)
                  throw new ue(`Expected arguments for "${t4}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
              }
              if (this.collator && !n2 && this.hasUntypedArgument) {
                const t5 = se(a2), r3 = se(s2);
                if ("string" !== t5.kind || "string" !== r3.kind)
                  return e2(i4, a2, s2);
              }
              return this.collator ? r2(i4, a2, s2, this.collator.evaluate(i4)) : e2(i4, a2, s2);
            }
            eachChild(t5) {
              t5(this.lhs), t5(this.rhs), this.collator && t5(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const ar = ir("==", function(t4, e2, r2) {
          return e2 === r2;
        }, nr), sr = ir("!=", function(t4, e2, r2) {
          return e2 !== r2;
        }, function(t4, e2, r2, n2) {
          return !nr(0, e2, r2, n2);
        }), or = ir("<", function(t4, e2, r2) {
          return e2 < r2;
        }, function(t4, e2, r2, n2) {
          return n2.compare(e2, r2) < 0;
        }), lr = ir(">", function(t4, e2, r2) {
          return e2 > r2;
        }, function(t4, e2, r2, n2) {
          return n2.compare(e2, r2) > 0;
        }), ur = ir("<=", function(t4, e2, r2) {
          return e2 <= r2;
        }, function(t4, e2, r2, n2) {
          return n2.compare(e2, r2) <= 0;
        }), cr = ir(">=", function(t4, e2, r2) {
          return e2 >= r2;
        }, function(t4, e2, r2, n2) {
          return n2.compare(e2, r2) >= 0;
        });
        class hr {
          constructor(t4, e2, r2, n2, i3) {
            this.type = ft, this.number = t4, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i3;
          }
          static parse(t4, e2) {
            if (3 !== t4.length)
              return e2.error("Expected two arguments.");
            const r2 = e2.parse(t4[1], 1, pt);
            if (!r2)
              return null;
            const n2 = t4[2];
            if ("object" != typeof n2 || Array.isArray(n2))
              return e2.error("NumberFormat options argument must be an object.");
            let i3 = null;
            if (n2.locale && (i3 = e2.parse(n2.locale, 1, ft), !i3))
              return null;
            let a2 = null;
            if (n2.currency && (a2 = e2.parse(n2.currency, 1, ft), !a2))
              return null;
            let s2 = null;
            if (n2["min-fraction-digits"] && (s2 = e2.parse(n2["min-fraction-digits"], 1, pt), !s2))
              return null;
            let o2 = null;
            return n2["max-fraction-digits"] && (o2 = e2.parse(n2["max-fraction-digits"], 1, pt), !o2) ? null : new hr(r2, i3, a2, s2, o2);
          }
          evaluate(t4) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t4) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t4) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t4) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t4) : void 0 }).format(this.number.evaluate(t4));
          }
          eachChild(t4) {
            t4(this.number), this.locale && t4(this.locale), this.currency && t4(this.currency), this.minFractionDigits && t4(this.minFractionDigits), this.maxFractionDigits && t4(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class pr {
          constructor(t4) {
            this.type = vt, this.sections = t4;
          }
          static parse(t4, e2) {
            if (t4.length < 2)
              return e2.error("Expected at least one argument.");
            const r2 = t4[1];
            if (!Array.isArray(r2) && "object" == typeof r2)
              return e2.error("First argument must be an image or text section.");
            const n2 = [];
            let i3 = false;
            for (let r3 = 1; r3 <= t4.length - 1; ++r3) {
              const a2 = t4[r3];
              if (i3 && "object" == typeof a2 && !Array.isArray(a2)) {
                i3 = false;
                let t5 = null;
                if (a2["font-scale"] && (t5 = e2.parse(a2["font-scale"], 1, pt), !t5))
                  return null;
                let r4 = null;
                if (a2["text-font"] && (r4 = e2.parse(a2["text-font"], 1, At(ft)), !r4))
                  return null;
                let s2 = null;
                if (a2["text-color"] && (s2 = e2.parse(a2["text-color"], 1, yt), !s2))
                  return null;
                const o2 = n2[n2.length - 1];
                o2.scale = t5, o2.font = r4, o2.textColor = s2;
              } else {
                const a3 = e2.parse(t4[r3], 1, gt);
                if (!a3)
                  return null;
                const s2 = a3.type.kind;
                if ("string" !== s2 && "value" !== s2 && "null" !== s2 && "resolvedImage" !== s2)
                  return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i3 = true, n2.push({ content: a3, scale: null, font: null, textColor: null });
              }
            }
            return new pr(n2);
          }
          evaluate(t4) {
            return new Qt(this.sections.map((e2) => {
              const r2 = e2.content.evaluate(t4);
              return se(r2) === wt ? new Wt("", r2, null, null, null) : new Wt(oe(r2), null, e2.scale ? e2.scale.evaluate(t4) : null, e2.font ? e2.font.evaluate(t4).join(",") : null, e2.textColor ? e2.textColor.evaluate(t4) : null);
            }));
          }
          eachChild(t4) {
            for (const e2 of this.sections)
              t4(e2.content), e2.scale && t4(e2.scale), e2.font && t4(e2.font), e2.textColor && t4(e2.textColor);
          }
          outputDefined() {
            return false;
          }
        }
        class fr {
          constructor(t4) {
            this.type = wt, this.input = t4;
          }
          static parse(t4, e2) {
            if (2 !== t4.length)
              return e2.error("Expected two arguments.");
            const r2 = e2.parse(t4[1], 1, ft);
            return r2 ? new fr(r2) : e2.error("No image name provided.");
          }
          evaluate(t4) {
            const e2 = this.input.evaluate(t4), r2 = ne.fromString(e2);
            return r2 && t4.availableImages && (r2.available = t4.availableImages.indexOf(e2) > -1), r2;
          }
          eachChild(t4) {
            t4(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class dr {
          constructor(t4) {
            this.type = pt, this.input = t4;
          }
          static parse(t4, e2) {
            if (2 !== t4.length)
              return e2.error(`Expected 1 argument, but found ${t4.length - 1} instead.`);
            const r2 = e2.parse(t4[1], 1);
            return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error(`Expected argument of type string or array, but found ${St(r2.type)} instead.`) : new dr(r2) : null;
          }
          evaluate(t4) {
            const e2 = this.input.evaluate(t4);
            if ("string" == typeof e2)
              return e2.length;
            if (Array.isArray(e2))
              return e2.length;
            throw new ue(`Expected value to be of type string or array, but found ${St(se(e2))} instead.`);
          }
          eachChild(t4) {
            t4(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const yr = { "==": ar, "!=": sr, ">": lr, "<": or, ">=": cr, "<=": ur, array: he, at: Ye, boolean: he, case: tr, coalesce: Je, collator: ge, format: pr, image: fr, in: He, "index-of": We, interpolate: Ke, "interpolate-hcl": Ke, "interpolate-lab": Ke, length: dr, let: Xe, literal: le, match: Qe, number: he, "number-format": hr, object: he, slice: er, step: qe, string: he, "to-boolean": fe, "to-color": fe, "to-number": fe, "to-string": fe, var: Te, within: Fe };
        function mr(t4, [e2, r2, n2, i3]) {
          e2 = e2.evaluate(t4), r2 = r2.evaluate(t4), n2 = n2.evaluate(t4);
          const a2 = i3 ? i3.evaluate(t4) : 1, s2 = ie(e2, r2, n2, a2);
          if (s2)
            throw new ue(s2);
          return new Yt(e2 / 255, r2 / 255, n2 / 255, a2, false);
        }
        function gr(t4, e2) {
          return t4 in e2;
        }
        function xr(t4, e2) {
          const r2 = e2[t4];
          return void 0 === r2 ? null : r2;
        }
        function vr(t4) {
          return { type: t4 };
        }
        function br(t4) {
          return { result: "success", value: t4 };
        }
        function wr(t4) {
          return { result: "error", value: t4 };
        }
        function _r(t4) {
          return "data-driven" === t4["property-type"] || "cross-faded-data-driven" === t4["property-type"];
        }
        function Ar(t4) {
          return !!t4.expression && t4.expression.parameters.indexOf("zoom") > -1;
        }
        function Sr(t4) {
          return !!t4.expression && t4.expression.interpolated;
        }
        function kr(t4) {
          return t4 instanceof Number ? "number" : t4 instanceof String ? "string" : t4 instanceof Boolean ? "boolean" : Array.isArray(t4) ? "array" : null === t4 ? "null" : typeof t4;
        }
        function Ir(t4) {
          return "object" == typeof t4 && null !== t4 && !Array.isArray(t4);
        }
        function zr(t4) {
          return t4;
        }
        function Mr(t4, e2) {
          const r2 = "color" === e2.type, n2 = t4.stops && "object" == typeof t4.stops[0][0], i3 = n2 || !(n2 || void 0 !== t4.property), a2 = t4.type || (Sr(e2) ? "exponential" : "interval");
          if (r2 || "padding" === e2.type) {
            const n3 = r2 ? Yt.parse : te.parse;
            (t4 = lt({}, t4)).stops && (t4.stops = t4.stops.map((t5) => [t5[0], n3(t5[1])])), t4.default = n3(t4.default ? t4.default : e2.default);
          }
          if (t4.colorSpace && "rgb" !== (s2 = t4.colorSpace) && "hcl" !== s2 && "lab" !== s2)
            throw new Error(`Unknown color space: "${t4.colorSpace}"`);
          var s2;
          let o2, l2, u2;
          if ("exponential" === a2)
            o2 = Vr;
          else if ("interval" === a2)
            o2 = Pr;
          else if ("categorical" === a2) {
            o2 = Br, l2 = /* @__PURE__ */ Object.create(null);
            for (const e3 of t4.stops)
              l2[e3[0]] = e3[1];
            u2 = typeof t4.stops[0][0];
          } else {
            if ("identity" !== a2)
              throw new Error(`Unknown function type "${a2}"`);
            o2 = Er;
          }
          if (n2) {
            const r3 = {}, n3 = [];
            for (let e3 = 0; e3 < t4.stops.length; e3++) {
              const i5 = t4.stops[e3], a4 = i5[0].zoom;
              void 0 === r3[a4] && (r3[a4] = { zoom: a4, type: t4.type, property: t4.property, default: t4.default, stops: [] }, n3.push(a4)), r3[a4].stops.push([i5[0].value, i5[1]]);
            }
            const i4 = [];
            for (const t5 of n3)
              i4.push([r3[t5].zoom, Mr(r3[t5], e2)]);
            const a3 = { name: "linear" };
            return { kind: "composite", interpolationType: a3, interpolationFactor: Ke.interpolationFactor.bind(void 0, a3), zoomStops: i4.map((t5) => t5[0]), evaluate: ({ zoom: r4 }, n4) => Vr({ stops: i4, base: t4.base }, e2, r4).evaluate(r4, n4) };
          }
          if (i3) {
            const r3 = "exponential" === a2 ? { name: "exponential", base: void 0 !== t4.base ? t4.base : 1 } : null;
            return { kind: "camera", interpolationType: r3, interpolationFactor: Ke.interpolationFactor.bind(void 0, r3), zoomStops: t4.stops.map((t5) => t5[0]), evaluate: ({ zoom: r4 }) => o2(t4, e2, r4, l2, u2) };
          }
          return { kind: "source", evaluate(r3, n3) {
            const i4 = n3 && n3.properties ? n3.properties[t4.property] : void 0;
            return void 0 === i4 ? Cr(t4.default, e2.default) : o2(t4, e2, i4, l2, u2);
          } };
        }
        function Cr(t4, e2, r2) {
          return void 0 !== t4 ? t4 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
        }
        function Br(t4, e2, r2, n2, i3) {
          return Cr(typeof r2 === i3 ? n2[r2] : void 0, t4.default, e2.default);
        }
        function Pr(t4, e2, r2) {
          if ("number" !== kr(r2))
            return Cr(t4.default, e2.default);
          const n2 = t4.stops.length;
          if (1 === n2)
            return t4.stops[0][1];
          if (r2 <= t4.stops[0][0])
            return t4.stops[0][1];
          if (r2 >= t4.stops[n2 - 1][0])
            return t4.stops[n2 - 1][1];
          const i3 = Re(t4.stops.map((t5) => t5[0]), r2);
          return t4.stops[i3][1];
        }
        function Vr(t4, e2, r2) {
          const n2 = void 0 !== t4.base ? t4.base : 1;
          if ("number" !== kr(r2))
            return Cr(t4.default, e2.default);
          const i3 = t4.stops.length;
          if (1 === i3)
            return t4.stops[0][1];
          if (r2 <= t4.stops[0][0])
            return t4.stops[0][1];
          if (r2 >= t4.stops[i3 - 1][0])
            return t4.stops[i3 - 1][1];
          const a2 = Re(t4.stops.map((t5) => t5[0]), r2), s2 = function(t5, e3, r3, n3) {
            const i4 = n3 - r3, a3 = t5 - r3;
            return 0 === i4 ? 0 : 1 === e3 ? a3 / i4 : (Math.pow(e3, a3) - 1) / (Math.pow(e3, i4) - 1);
          }(r2, n2, t4.stops[a2][0], t4.stops[a2 + 1][0]), o2 = t4.stops[a2][1], l2 = t4.stops[a2 + 1][1], u2 = Ze[e2.type] || zr;
          return "function" == typeof o2.evaluate ? { evaluate(...e3) {
            const r3 = o2.evaluate.apply(void 0, e3), n3 = l2.evaluate.apply(void 0, e3);
            if (void 0 !== r3 && void 0 !== n3)
              return u2(r3, n3, s2, t4.colorSpace);
          } } : u2(o2, l2, s2, t4.colorSpace);
        }
        function Er(t4, e2, r2) {
          switch (e2.type) {
            case "color":
              r2 = Yt.parse(r2);
              break;
            case "formatted":
              r2 = Qt.fromString(r2.toString());
              break;
            case "resolvedImage":
              r2 = ne.fromString(r2.toString());
              break;
            case "padding":
              r2 = te.parse(r2);
              break;
            default:
              kr(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0);
          }
          return Cr(r2, t4.default, e2.default);
        }
        $e.register(yr, { error: [{ kind: "error" }, [ft], (t4, [e2]) => {
          throw new ue(e2.evaluate(t4));
        }], typeof: [ft, [gt], (t4, [e2]) => St(se(e2.evaluate(t4)))], "to-rgba": [At(pt, 4), [yt], (t4, [e2]) => {
          const [r2, n2, i3, a2] = e2.evaluate(t4).rgb;
          return [255 * r2, 255 * n2, 255 * i3, a2];
        }], rgb: [yt, [pt, pt, pt], mr], rgba: [yt, [pt, pt, pt, pt], mr], has: { type: dt, overloads: [[[ft], (t4, [e2]) => gr(e2.evaluate(t4), t4.properties())], [[ft, mt], (t4, [e2, r2]) => gr(e2.evaluate(t4), r2.evaluate(t4))]] }, get: { type: gt, overloads: [[[ft], (t4, [e2]) => xr(e2.evaluate(t4), t4.properties())], [[ft, mt], (t4, [e2, r2]) => xr(e2.evaluate(t4), r2.evaluate(t4))]] }, "feature-state": [gt, [ft], (t4, [e2]) => xr(e2.evaluate(t4), t4.featureState || {})], properties: [mt, [], (t4) => t4.properties()], "geometry-type": [ft, [], (t4) => t4.geometryType()], id: [gt, [], (t4) => t4.id()], zoom: [pt, [], (t4) => t4.globals.zoom], "heatmap-density": [pt, [], (t4) => t4.globals.heatmapDensity || 0], "line-progress": [pt, [], (t4) => t4.globals.lineProgress || 0], accumulated: [gt, [], (t4) => void 0 === t4.globals.accumulated ? null : t4.globals.accumulated], "+": [pt, vr(pt), (t4, e2) => {
          let r2 = 0;
          for (const n2 of e2)
            r2 += n2.evaluate(t4);
          return r2;
        }], "*": [pt, vr(pt), (t4, e2) => {
          let r2 = 1;
          for (const n2 of e2)
            r2 *= n2.evaluate(t4);
          return r2;
        }], "-": { type: pt, overloads: [[[pt, pt], (t4, [e2, r2]) => e2.evaluate(t4) - r2.evaluate(t4)], [[pt], (t4, [e2]) => -e2.evaluate(t4)]] }, "/": [pt, [pt, pt], (t4, [e2, r2]) => e2.evaluate(t4) / r2.evaluate(t4)], "%": [pt, [pt, pt], (t4, [e2, r2]) => e2.evaluate(t4) % r2.evaluate(t4)], ln2: [pt, [], () => Math.LN2], pi: [pt, [], () => Math.PI], e: [pt, [], () => Math.E], "^": [pt, [pt, pt], (t4, [e2, r2]) => Math.pow(e2.evaluate(t4), r2.evaluate(t4))], sqrt: [pt, [pt], (t4, [e2]) => Math.sqrt(e2.evaluate(t4))], log10: [pt, [pt], (t4, [e2]) => Math.log(e2.evaluate(t4)) / Math.LN10], ln: [pt, [pt], (t4, [e2]) => Math.log(e2.evaluate(t4))], log2: [pt, [pt], (t4, [e2]) => Math.log(e2.evaluate(t4)) / Math.LN2], sin: [pt, [pt], (t4, [e2]) => Math.sin(e2.evaluate(t4))], cos: [pt, [pt], (t4, [e2]) => Math.cos(e2.evaluate(t4))], tan: [pt, [pt], (t4, [e2]) => Math.tan(e2.evaluate(t4))], asin: [pt, [pt], (t4, [e2]) => Math.asin(e2.evaluate(t4))], acos: [pt, [pt], (t4, [e2]) => Math.acos(e2.evaluate(t4))], atan: [pt, [pt], (t4, [e2]) => Math.atan(e2.evaluate(t4))], min: [pt, vr(pt), (t4, e2) => Math.min(...e2.map((e3) => e3.evaluate(t4)))], max: [pt, vr(pt), (t4, e2) => Math.max(...e2.map((e3) => e3.evaluate(t4)))], abs: [pt, [pt], (t4, [e2]) => Math.abs(e2.evaluate(t4))], round: [pt, [pt], (t4, [e2]) => {
          const r2 = e2.evaluate(t4);
          return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
        }], floor: [pt, [pt], (t4, [e2]) => Math.floor(e2.evaluate(t4))], ceil: [pt, [pt], (t4, [e2]) => Math.ceil(e2.evaluate(t4))], "filter-==": [dt, [ft, gt], (t4, [e2, r2]) => t4.properties()[e2.value] === r2.value], "filter-id-==": [dt, [gt], (t4, [e2]) => t4.id() === e2.value], "filter-type-==": [dt, [ft], (t4, [e2]) => t4.geometryType() === e2.value], "filter-<": [dt, [ft, gt], (t4, [e2, r2]) => {
          const n2 = t4.properties()[e2.value], i3 = r2.value;
          return typeof n2 == typeof i3 && n2 < i3;
        }], "filter-id-<": [dt, [gt], (t4, [e2]) => {
          const r2 = t4.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 < n2;
        }], "filter->": [dt, [ft, gt], (t4, [e2, r2]) => {
          const n2 = t4.properties()[e2.value], i3 = r2.value;
          return typeof n2 == typeof i3 && n2 > i3;
        }], "filter-id->": [dt, [gt], (t4, [e2]) => {
          const r2 = t4.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 > n2;
        }], "filter-<=": [dt, [ft, gt], (t4, [e2, r2]) => {
          const n2 = t4.properties()[e2.value], i3 = r2.value;
          return typeof n2 == typeof i3 && n2 <= i3;
        }], "filter-id-<=": [dt, [gt], (t4, [e2]) => {
          const r2 = t4.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 <= n2;
        }], "filter->=": [dt, [ft, gt], (t4, [e2, r2]) => {
          const n2 = t4.properties()[e2.value], i3 = r2.value;
          return typeof n2 == typeof i3 && n2 >= i3;
        }], "filter-id->=": [dt, [gt], (t4, [e2]) => {
          const r2 = t4.id(), n2 = e2.value;
          return typeof r2 == typeof n2 && r2 >= n2;
        }], "filter-has": [dt, [gt], (t4, [e2]) => e2.value in t4.properties()], "filter-has-id": [dt, [], (t4) => null !== t4.id() && void 0 !== t4.id()], "filter-type-in": [dt, [At(ft)], (t4, [e2]) => e2.value.indexOf(t4.geometryType()) >= 0], "filter-id-in": [dt, [At(gt)], (t4, [e2]) => e2.value.indexOf(t4.id()) >= 0], "filter-in-small": [dt, [ft, At(gt)], (t4, [e2, r2]) => r2.value.indexOf(t4.properties()[e2.value]) >= 0], "filter-in-large": [dt, [ft, At(gt)], (t4, [e2, r2]) => function(t5, e3, r3, n2) {
          for (; r3 <= n2; ) {
            const i3 = r3 + n2 >> 1;
            if (e3[i3] === t5)
              return true;
            e3[i3] > t5 ? n2 = i3 - 1 : r3 = i3 + 1;
          }
          return false;
        }(t4.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: dt, overloads: [[[dt, dt], (t4, [e2, r2]) => e2.evaluate(t4) && r2.evaluate(t4)], [vr(dt), (t4, e2) => {
          for (const r2 of e2)
            if (!r2.evaluate(t4))
              return false;
          return true;
        }]] }, any: { type: dt, overloads: [[[dt, dt], (t4, [e2, r2]) => e2.evaluate(t4) || r2.evaluate(t4)], [vr(dt), (t4, e2) => {
          for (const r2 of e2)
            if (r2.evaluate(t4))
              return true;
          return false;
        }]] }, "!": [dt, [dt], (t4, [e2]) => !e2.evaluate(t4)], "is-supported-script": [dt, [ft], (t4, [e2]) => {
          const r2 = t4.globals && t4.globals.isSupportedScript;
          return !r2 || r2(e2.evaluate(t4));
        }], upcase: [ft, [ft], (t4, [e2]) => e2.evaluate(t4).toUpperCase()], downcase: [ft, [ft], (t4, [e2]) => e2.evaluate(t4).toLowerCase()], concat: [ft, vr(gt), (t4, e2) => e2.map((e3) => oe(e3.evaluate(t4))).join("")], "resolved-locale": [ft, [xt], (t4, [e2]) => e2.evaluate(t4).resolvedLocale()] });
        class Fr {
          constructor(t4, e2) {
            var r2;
            this.expression = t4, this._warningHistory = {}, this._evaluator = new ye(), this._defaultValue = e2 ? "color" === (r2 = e2).type && Ir(r2.default) ? new Yt(0, 0, 0, 0) : "color" === r2.type ? Yt.parse(r2.default) || null : "padding" === r2.type ? te.parse(r2.default) || null : "variableAnchorOffsetCollection" === r2.type ? re.parse(r2.default) || null : void 0 === r2.default ? null : r2.default : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
          }
          evaluateWithoutErrorHandling(t4, e2, r2, n2, i3, a2) {
            return this._evaluator.globals = t4, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = a2, this.expression.evaluate(this._evaluator);
          }
          evaluate(t4, e2, r2, n2, i3, a2) {
            this._evaluator.globals = t4, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = a2 || null;
            try {
              const t5 = this.expression.evaluate(this._evaluator);
              if (null == t5 || "number" == typeof t5 && t5 != t5)
                return this._defaultValue;
              if (this._enumValues && !(t5 in this._enumValues))
                throw new ue(`Expected value to be one of ${Object.keys(this._enumValues).map((t6) => JSON.stringify(t6)).join(", ")}, but found ${JSON.stringify(t5)} instead.`);
              return t5;
            } catch (t5) {
              return this._warningHistory[t5.message] || (this._warningHistory[t5.message] = true, "undefined" != typeof console && console.warn(t5.message)), this._defaultValue;
            }
          }
        }
        function Tr(t4) {
          return Array.isArray(t4) && t4.length > 0 && "string" == typeof t4[0] && t4[0] in yr;
        }
        function $r(t4, e2) {
          const r2 = new me(yr, Le, [], e2 ? function(t5) {
            const e3 = { color: yt, string: ft, number: pt, enum: ft, boolean: dt, formatted: vt, padding: bt, resolvedImage: wt, variableAnchorOffsetCollection: _t };
            return "array" === t5.type ? At(e3[t5.value] || gt, t5.length) : e3[t5.type];
          }(e2) : void 0), n2 = r2.parse(t4, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
          return n2 ? br(new Fr(n2, e2)) : wr(r2.errors);
        }
        class Lr {
          constructor(t4, e2) {
            this.kind = t4, this._styleExpression = e2, this.isStateDependent = "constant" !== t4 && !Oe(e2.expression);
          }
          evaluateWithoutErrorHandling(t4, e2, r2, n2, i3, a2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t4, e2, r2, n2, i3, a2);
          }
          evaluate(t4, e2, r2, n2, i3, a2) {
            return this._styleExpression.evaluate(t4, e2, r2, n2, i3, a2);
          }
        }
        class Dr {
          constructor(t4, e2, r2, n2) {
            this.kind = t4, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t4 && !Oe(e2.expression), this.interpolationType = n2;
          }
          evaluateWithoutErrorHandling(t4, e2, r2, n2, i3, a2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t4, e2, r2, n2, i3, a2);
          }
          evaluate(t4, e2, r2, n2, i3, a2) {
            return this._styleExpression.evaluate(t4, e2, r2, n2, i3, a2);
          }
          interpolationFactor(t4, e2, r2) {
            return this.interpolationType ? Ke.interpolationFactor(this.interpolationType, t4, e2, r2) : 0;
          }
        }
        function Or(t4, e2) {
          const r2 = $r(t4, e2);
          if ("error" === r2.result)
            return r2;
          const n2 = r2.value.expression, i3 = De(n2);
          if (!i3 && !_r(e2))
            return wr([new ut("", "data expressions not supported")]);
          const a2 = Ue(n2, ["zoom"]);
          if (!a2 && !Ar(e2))
            return wr([new ut("", "zoom expressions not supported")]);
          const s2 = Rr(n2);
          return s2 || a2 ? s2 instanceof ut ? wr([s2]) : s2 instanceof Ke && !Sr(e2) ? wr([new ut("", '"interpolate" expressions cannot be used with this property')]) : br(s2 ? new Dr(i3 ? "camera" : "composite", r2.value, s2.labels, s2 instanceof Ke ? s2.interpolation : void 0) : new Lr(i3 ? "constant" : "source", r2.value)) : wr([new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Ur {
          constructor(t4, e2) {
            this._parameters = t4, this._specification = e2, lt(this, Mr(this._parameters, this._specification));
          }
          static deserialize(t4) {
            return new Ur(t4._parameters, t4._specification);
          }
          static serialize(t4) {
            return { _parameters: t4._parameters, _specification: t4._specification };
          }
        }
        function Rr(t4) {
          let e2 = null;
          if (t4 instanceof Xe)
            e2 = Rr(t4.result);
          else if (t4 instanceof Je) {
            for (const r2 of t4.args)
              if (e2 = Rr(r2), e2)
                break;
          } else
            (t4 instanceof qe || t4 instanceof Ke) && t4.input instanceof $e && "zoom" === t4.input.name && (e2 = t4);
          return e2 instanceof ut || t4.eachChild((t5) => {
            const r2 = Rr(t5);
            r2 instanceof ut ? e2 = r2 : !e2 && r2 ? e2 = new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new ut("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e2;
        }
        function qr(t4) {
          if (true === t4 || false === t4)
            return true;
          if (!Array.isArray(t4) || 0 === t4.length)
            return false;
          switch (t4[0]) {
            case "has":
              return t4.length >= 2 && "$id" !== t4[1] && "$type" !== t4[1];
            case "in":
              return t4.length >= 3 && ("string" != typeof t4[1] || Array.isArray(t4[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t4.length || Array.isArray(t4[1]) || Array.isArray(t4[2]);
            case "any":
            case "all":
              for (const e2 of t4.slice(1))
                if (!qr(e2) && "boolean" != typeof e2)
                  return false;
              return true;
            default:
              return true;
          }
        }
        const jr = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function Nr(t4) {
          if (null == t4)
            return { filter: () => true, needGeometry: false };
          qr(t4) || (t4 = Gr(t4));
          const e2 = $r(t4, jr);
          if ("error" === e2.result)
            throw new Error(e2.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
          return { filter: (t5, r2, n2) => e2.value.evaluate(t5, r2, {}, n2), needGeometry: Kr(t4) };
        }
        function Zr(t4, e2) {
          return t4 < e2 ? -1 : t4 > e2 ? 1 : 0;
        }
        function Kr(t4) {
          if (!Array.isArray(t4))
            return false;
          if ("within" === t4[0])
            return true;
          for (let e2 = 1; e2 < t4.length; e2++)
            if (Kr(t4[e2]))
              return true;
          return false;
        }
        function Gr(t4) {
          if (!t4)
            return true;
          const e2 = t4[0];
          return t4.length <= 1 ? "any" !== e2 : "==" === e2 ? Jr(t4[1], t4[2], "==") : "!=" === e2 ? Hr(Jr(t4[1], t4[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? Jr(t4[1], t4[2], e2) : "any" === e2 ? (r2 = t4.slice(1), ["any"].concat(r2.map(Gr))) : "all" === e2 ? ["all"].concat(t4.slice(1).map(Gr)) : "none" === e2 ? ["all"].concat(t4.slice(1).map(Gr).map(Hr)) : "in" === e2 ? Xr(t4[1], t4.slice(2)) : "!in" === e2 ? Hr(Xr(t4[1], t4.slice(2))) : "has" === e2 ? Yr(t4[1]) : "!has" === e2 ? Hr(Yr(t4[1])) : "within" !== e2 || t4;
          var r2;
        }
        function Jr(t4, e2, r2) {
          switch (t4) {
            case "$type":
              return [`filter-type-${r2}`, e2];
            case "$id":
              return [`filter-id-${r2}`, e2];
            default:
              return [`filter-${r2}`, t4, e2];
          }
        }
        function Xr(t4, e2) {
          if (0 === e2.length)
            return false;
          switch (t4) {
            case "$type":
              return ["filter-type-in", ["literal", e2]];
            case "$id":
              return ["filter-id-in", ["literal", e2]];
            default:
              return e2.length > 200 && !e2.some((t5) => typeof t5 != typeof e2[0]) ? ["filter-in-large", t4, ["literal", e2.sort(Zr)]] : ["filter-in-small", t4, ["literal", e2]];
          }
        }
        function Yr(t4) {
          switch (t4) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t4];
          }
        }
        function Hr(t4) {
          return ["!", t4];
        }
        function Wr(t4) {
          const e2 = typeof t4;
          if ("number" === e2 || "boolean" === e2 || "string" === e2 || null == t4)
            return JSON.stringify(t4);
          if (Array.isArray(t4)) {
            let e3 = "[";
            for (const r3 of t4)
              e3 += `${Wr(r3)},`;
            return `${e3}]`;
          }
          const r2 = Object.keys(t4).sort();
          let n2 = "{";
          for (let e3 = 0; e3 < r2.length; e3++)
            n2 += `${JSON.stringify(r2[e3])}:${Wr(t4[r2[e3]])},`;
          return `${n2}}`;
        }
        function Qr(t4) {
          let e2 = "";
          for (const r2 of Y)
            e2 += `/${Wr(t4[r2])}`;
          return e2;
        }
        function tn(t4) {
          const e2 = t4.value;
          return e2 ? [new ot(t4.key, e2, "constants have been deprecated as of v8")] : [];
        }
        function en(t4) {
          return t4 instanceof Number || t4 instanceof String || t4 instanceof Boolean ? t4.valueOf() : t4;
        }
        function rn(t4) {
          if (Array.isArray(t4))
            return t4.map(rn);
          if (t4 instanceof Object && !(t4 instanceof Number || t4 instanceof String || t4 instanceof Boolean)) {
            const e2 = {};
            for (const r2 in t4)
              e2[r2] = rn(t4[r2]);
            return e2;
          }
          return en(t4);
        }
        function nn(t4) {
          const e2 = t4.key, r2 = t4.value, n2 = t4.valueSpec || {}, i3 = t4.objectElementValidators || {}, a2 = t4.style, s2 = t4.styleSpec, o2 = t4.validateSpec;
          let l2 = [];
          const u2 = kr(r2);
          if ("object" !== u2)
            return [new ot(e2, r2, `object expected, ${u2} found`)];
          for (const t5 in r2) {
            const u3 = t5.split(".")[0], c2 = n2[u3] || n2["*"];
            let h2;
            if (i3[u3])
              h2 = i3[u3];
            else if (n2[u3])
              h2 = o2;
            else if (i3["*"])
              h2 = i3["*"];
            else {
              if (!n2["*"]) {
                l2.push(new ot(e2, r2[t5], `unknown property "${t5}"`));
                continue;
              }
              h2 = o2;
            }
            l2 = l2.concat(h2({ key: (e2 ? `${e2}.` : e2) + t5, value: r2[t5], valueSpec: c2, style: a2, styleSpec: s2, object: r2, objectKey: t5, validateSpec: o2 }, r2));
          }
          for (const t5 in n2)
            i3[t5] || n2[t5].required && void 0 === n2[t5].default && void 0 === r2[t5] && l2.push(new ot(e2, r2, `missing required property "${t5}"`));
          return l2;
        }
        function an(t4) {
          const e2 = t4.value, r2 = t4.valueSpec, n2 = t4.style, i3 = t4.styleSpec, a2 = t4.key, s2 = t4.arrayElementValidator || t4.validateSpec;
          if ("array" !== kr(e2))
            return [new ot(a2, e2, `array expected, ${kr(e2)} found`)];
          if (r2.length && e2.length !== r2.length)
            return [new ot(a2, e2, `array length ${r2.length} expected, length ${e2.length} found`)];
          if (r2["min-length"] && e2.length < r2["min-length"])
            return [new ot(a2, e2, `array length at least ${r2["min-length"]} expected, length ${e2.length} found`)];
          let o2 = { type: r2.value, values: r2.values };
          i3.$version < 7 && (o2.function = r2.function), "object" === kr(r2.value) && (o2 = r2.value);
          let l2 = [];
          for (let r3 = 0; r3 < e2.length; r3++)
            l2 = l2.concat(s2({ array: e2, arrayIndex: r3, value: e2[r3], valueSpec: o2, validateSpec: t4.validateSpec, style: n2, styleSpec: i3, key: `${a2}[${r3}]` }));
          return l2;
        }
        function sn(t4) {
          const e2 = t4.key, r2 = t4.value, n2 = t4.valueSpec;
          let i3 = kr(r2);
          return "number" === i3 && r2 != r2 && (i3 = "NaN"), "number" !== i3 ? [new ot(e2, r2, `number expected, ${i3} found`)] : "minimum" in n2 && r2 < n2.minimum ? [new ot(e2, r2, `${r2} is less than the minimum value ${n2.minimum}`)] : "maximum" in n2 && r2 > n2.maximum ? [new ot(e2, r2, `${r2} is greater than the maximum value ${n2.maximum}`)] : [];
        }
        function on(t4) {
          const e2 = t4.valueSpec, r2 = en(t4.value.type);
          let n2, i3, a2, s2 = {};
          const o2 = "categorical" !== r2 && void 0 === t4.value.property, l2 = !o2, u2 = "array" === kr(t4.value.stops) && "array" === kr(t4.value.stops[0]) && "object" === kr(t4.value.stops[0][0]), c2 = nn({ key: t4.key, value: t4.value, valueSpec: t4.styleSpec.function, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { stops: function(t5) {
            if ("identity" === r2)
              return [new ot(t5.key, t5.value, 'identity function may not have a "stops" property')];
            let e3 = [];
            const n3 = t5.value;
            return e3 = e3.concat(an({ key: t5.key, value: n3, valueSpec: t5.valueSpec, validateSpec: t5.validateSpec, style: t5.style, styleSpec: t5.styleSpec, arrayElementValidator: h2 })), "array" === kr(n3) && 0 === n3.length && e3.push(new ot(t5.key, n3, "array must have at least one stop")), e3;
          }, default: function(t5) {
            return t5.validateSpec({ key: t5.key, value: t5.value, valueSpec: e2, validateSpec: t5.validateSpec, style: t5.style, styleSpec: t5.styleSpec });
          } } });
          return "identity" === r2 && o2 && c2.push(new ot(t4.key, t4.value, 'missing required property "property"')), "identity" === r2 || t4.value.stops || c2.push(new ot(t4.key, t4.value, 'missing required property "stops"')), "exponential" === r2 && t4.valueSpec.expression && !Sr(t4.valueSpec) && c2.push(new ot(t4.key, t4.value, "exponential functions not supported")), t4.styleSpec.$version >= 8 && (l2 && !_r(t4.valueSpec) ? c2.push(new ot(t4.key, t4.value, "property functions not supported")) : o2 && !Ar(t4.valueSpec) && c2.push(new ot(t4.key, t4.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== t4.value.property || c2.push(new ot(t4.key, t4.value, '"property" property is required')), c2;
          function h2(t5) {
            let r3 = [];
            const n3 = t5.value, o3 = t5.key;
            if ("array" !== kr(n3))
              return [new ot(o3, n3, `array expected, ${kr(n3)} found`)];
            if (2 !== n3.length)
              return [new ot(o3, n3, `array length 2 expected, length ${n3.length} found`)];
            if (u2) {
              if ("object" !== kr(n3[0]))
                return [new ot(o3, n3, `object expected, ${kr(n3[0])} found`)];
              if (void 0 === n3[0].zoom)
                return [new ot(o3, n3, "object stop key must have zoom")];
              if (void 0 === n3[0].value)
                return [new ot(o3, n3, "object stop key must have value")];
              if (a2 && a2 > en(n3[0].zoom))
                return [new ot(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
              en(n3[0].zoom) !== a2 && (a2 = en(n3[0].zoom), i3 = void 0, s2 = {}), r3 = r3.concat(nn({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, validateSpec: t5.validateSpec, style: t5.style, styleSpec: t5.styleSpec, objectElementValidators: { zoom: sn, value: p2 } }));
            } else
              r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, validateSpec: t5.validateSpec, style: t5.style, styleSpec: t5.styleSpec }, n3));
            return Tr(rn(n3[1])) ? r3.concat([new ot(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(t5.validateSpec({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, validateSpec: t5.validateSpec, style: t5.style, styleSpec: t5.styleSpec }));
          }
          function p2(t5, a3) {
            const o3 = kr(t5.value), l3 = en(t5.value), u3 = null !== t5.value ? t5.value : a3;
            if (n2) {
              if (o3 !== n2)
                return [new ot(t5.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
            } else
              n2 = o3;
            if ("number" !== o3 && "string" !== o3 && "boolean" !== o3)
              return [new ot(t5.key, u3, "stop domain value must be a number, string, or boolean")];
            if ("number" !== o3 && "categorical" !== r2) {
              let n3 = `number expected, ${o3} found`;
              return _r(e2) && void 0 === r2 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ot(t5.key, u3, n3)];
            }
            return "categorical" !== r2 || "number" !== o3 || isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r2 && "number" === o3 && void 0 !== i3 && l3 < i3 ? [new ot(t5.key, u3, "stop domain values must appear in ascending order")] : (i3 = l3, "categorical" === r2 && l3 in s2 ? [new ot(t5.key, u3, "stop domain values must be unique")] : (s2[l3] = true, [])) : [new ot(t5.key, u3, `integer expected, found ${l3}`)];
          }
        }
        function ln(t4) {
          const e2 = ("property" === t4.expressionContext ? Or : $r)(rn(t4.value), t4.valueSpec);
          if ("error" === e2.result)
            return e2.value.map((e3) => new ot(`${t4.key}${e3.key}`, t4.value, e3.message));
          const r2 = e2.value.expression || e2.value._styleExpression.expression;
          if ("property" === t4.expressionContext && "text-font" === t4.propertyKey && !r2.outputDefined())
            return [new ot(t4.key, t4.value, `Invalid data expression for "${t4.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t4.expressionContext && "layout" === t4.propertyType && !Oe(r2))
            return [new ot(t4.key, t4.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t4.expressionContext && !Oe(r2))
            return [new ot(t4.key, t4.value, '"feature-state" data expressions are not supported with filters.')];
          if (t4.expressionContext && 0 === t4.expressionContext.indexOf("cluster")) {
            if (!Ue(r2, ["zoom", "feature-state"]))
              return [new ot(t4.key, t4.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t4.expressionContext && !De(r2))
              return [new ot(t4.key, t4.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function un(t4) {
          const e2 = t4.key, r2 = t4.value, n2 = t4.valueSpec, i3 = [];
          return Array.isArray(n2.values) ? -1 === n2.values.indexOf(en(r2)) && i3.push(new ot(e2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : -1 === Object.keys(n2.values).indexOf(en(r2)) && i3.push(new ot(e2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i3;
        }
        function cn(t4) {
          return qr(rn(t4.value)) ? ln(lt({}, t4, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : hn(t4);
        }
        function hn(t4) {
          const e2 = t4.value, r2 = t4.key;
          if ("array" !== kr(e2))
            return [new ot(r2, e2, `array expected, ${kr(e2)} found`)];
          const n2 = t4.styleSpec;
          let i3, a2 = [];
          if (e2.length < 1)
            return [new ot(r2, e2, "filter array must have at least 1 element")];
          switch (a2 = a2.concat(un({ key: `${r2}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t4.style, styleSpec: t4.styleSpec })), en(e2[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e2.length >= 2 && "$type" === en(e2[1]) && a2.push(new ot(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
            case "==":
            case "!=":
              3 !== e2.length && a2.push(new ot(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e2.length >= 2 && (i3 = kr(e2[1]), "string" !== i3 && a2.push(new ot(`${r2}[1]`, e2[1], `string expected, ${i3} found`)));
              for (let s2 = 2; s2 < e2.length; s2++)
                i3 = kr(e2[s2]), "$type" === en(e2[1]) ? a2 = a2.concat(un({ key: `${r2}[${s2}]`, value: e2[s2], valueSpec: n2.geometry_type, style: t4.style, styleSpec: t4.styleSpec })) : "string" !== i3 && "number" !== i3 && "boolean" !== i3 && a2.push(new ot(`${r2}[${s2}]`, e2[s2], `string, number, or boolean expected, ${i3} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let n3 = 1; n3 < e2.length; n3++)
                a2 = a2.concat(hn({ key: `${r2}[${n3}]`, value: e2[n3], style: t4.style, styleSpec: t4.styleSpec }));
              break;
            case "has":
            case "!has":
              i3 = kr(e2[1]), 2 !== e2.length ? a2.push(new ot(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "string" !== i3 && a2.push(new ot(`${r2}[1]`, e2[1], `string expected, ${i3} found`));
              break;
            case "within":
              i3 = kr(e2[1]), 2 !== e2.length ? a2.push(new ot(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "object" !== i3 && a2.push(new ot(`${r2}[1]`, e2[1], `object expected, ${i3} found`));
          }
          return a2;
        }
        function pn(t4, e2) {
          const r2 = t4.key, n2 = t4.validateSpec, i3 = t4.style, a2 = t4.styleSpec, s2 = t4.value, o2 = t4.objectKey, l2 = a2[`${e2}_${t4.layerType}`];
          if (!l2)
            return [];
          const u2 = o2.match(/^(.*)-transition$/);
          if ("paint" === e2 && u2 && l2[u2[1]] && l2[u2[1]].transition)
            return n2({ key: r2, value: s2, valueSpec: a2.transition, style: i3, styleSpec: a2 });
          const c2 = t4.valueSpec || l2[o2];
          if (!c2)
            return [new ot(r2, s2, `unknown property "${o2}"`)];
          let h2;
          if ("string" === kr(s2) && _r(c2) && !c2.tokens && (h2 = /^{([^}]+)}$/.exec(s2)))
            return [new ot(r2, s2, `"${o2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h2[1])} }\`.`)];
          const p2 = [];
          return "symbol" === t4.layerType && ("text-field" === o2 && i3 && !i3.glyphs && p2.push(new ot(r2, s2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o2 && Ir(rn(s2)) && "identity" === en(s2.type) && p2.push(new ot(r2, s2, '"text-font" does not support identity functions'))), p2.concat(n2({ key: t4.key, value: s2, valueSpec: c2, style: i3, styleSpec: a2, expressionContext: "property", propertyType: e2, propertyKey: o2 }));
        }
        function fn(t4) {
          return pn(t4, "paint");
        }
        function dn(t4) {
          return pn(t4, "layout");
        }
        function yn(t4) {
          let e2 = [];
          const r2 = t4.value, n2 = t4.key, i3 = t4.style, a2 = t4.styleSpec;
          r2.type || r2.ref || e2.push(new ot(n2, r2, 'either "type" or "ref" is required'));
          let s2 = en(r2.type);
          const o2 = en(r2.ref);
          if (r2.id) {
            const a3 = en(r2.id);
            for (let s3 = 0; s3 < t4.arrayIndex; s3++) {
              const t5 = i3.layers[s3];
              en(t5.id) === a3 && e2.push(new ot(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t5.id.__line__}`));
            }
          }
          if ("ref" in r2) {
            let t5;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t6) => {
              t6 in r2 && e2.push(new ot(n2, r2[t6], `"${t6}" is prohibited for ref layers`));
            }), i3.layers.forEach((e3) => {
              en(e3.id) === o2 && (t5 = e3);
            }), t5 ? t5.ref ? e2.push(new ot(n2, r2.ref, "ref cannot reference another ref layer")) : s2 = en(t5.type) : e2.push(new ot(n2, r2.ref, `ref layer "${o2}" not found`));
          } else if ("background" !== s2)
            if (r2.source) {
              const t5 = i3.sources && i3.sources[r2.source], a3 = t5 && en(t5.type);
              t5 ? "vector" === a3 && "raster" === s2 ? e2.push(new ot(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : "raster-dem" !== a3 && "hillshade" === s2 ? e2.push(new ot(n2, r2.source, `layer "${r2.id}" requires a raster-dem source`)) : "raster" === a3 && "raster" !== s2 ? e2.push(new ot(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : "vector" !== a3 || r2["source-layer"] ? "raster-dem" === a3 && "hillshade" !== s2 ? e2.push(new ot(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === a3 && t5.lineMetrics || e2.push(new ot(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new ot(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new ot(n2, r2.source, `source "${r2.source}" not found`));
            } else
              e2.push(new ot(n2, r2, 'missing required property "source"'));
          return e2 = e2.concat(nn({ key: n2, value: r2, valueSpec: a2.layer, style: t4.style, styleSpec: t4.styleSpec, validateSpec: t4.validateSpec, objectElementValidators: { "*": () => [], type: () => t4.validateSpec({ key: `${n2}.type`, value: r2.type, valueSpec: a2.layer.type, style: t4.style, styleSpec: t4.styleSpec, validateSpec: t4.validateSpec, object: r2, objectKey: "type" }), filter: cn, layout: (t5) => nn({ layer: r2, key: t5.key, value: t5.value, style: t5.style, styleSpec: t5.styleSpec, validateSpec: t5.validateSpec, objectElementValidators: { "*": (t6) => dn(lt({ layerType: s2 }, t6)) } }), paint: (t5) => nn({ layer: r2, key: t5.key, value: t5.value, style: t5.style, styleSpec: t5.styleSpec, validateSpec: t5.validateSpec, objectElementValidators: { "*": (t6) => fn(lt({ layerType: s2 }, t6)) } }) } })), e2;
        }
        function mn(t4) {
          const e2 = t4.value, r2 = t4.key, n2 = kr(e2);
          return "string" !== n2 ? [new ot(r2, e2, `string expected, ${n2} found`)] : [];
        }
        const gn = { promoteId: function({ key: t4, value: e2 }) {
          if ("string" === kr(e2))
            return mn({ key: t4, value: e2 });
          {
            const r2 = [];
            for (const n2 in e2)
              r2.push(...mn({ key: `${t4}.${n2}`, value: e2[n2] }));
            return r2;
          }
        } };
        function xn(t4) {
          const e2 = t4.value, r2 = t4.key, n2 = t4.styleSpec, i3 = t4.style, a2 = t4.validateSpec;
          if (!e2.type)
            return [new ot(r2, e2, '"type" is required')];
          const s2 = en(e2.type);
          let o2;
          switch (s2) {
            case "vector":
            case "raster":
              return o2 = nn({ key: r2, value: e2, valueSpec: n2[`source_${s2.replace("-", "_")}`], style: t4.style, styleSpec: n2, objectElementValidators: gn, validateSpec: a2 }), o2;
            case "raster-dem":
              return o2 = function(t5) {
                var e3;
                const r3 = null !== (e3 = t5.sourceName) && void 0 !== e3 ? e3 : "", n3 = t5.value, i4 = t5.styleSpec, a3 = i4.source_raster_dem, s3 = t5.style;
                let o3 = [];
                const l2 = kr(n3);
                if (void 0 === n3)
                  return o3;
                if ("object" !== l2)
                  return o3.push(new ot("source_raster_dem", n3, `object expected, ${l2} found`)), o3;
                const u2 = "custom" === en(n3.encoding), c2 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h2 = t5.value.encoding ? `"${t5.value.encoding}"` : "Default";
                for (const e4 in n3)
                  !u2 && c2.includes(e4) ? o3.push(new ot(e4, n3[e4], `In "${r3}": "${e4}" is only valid when "encoding" is set to "custom". ${h2} encoding found`)) : a3[e4] ? o3 = o3.concat(t5.validateSpec({ key: e4, value: n3[e4], valueSpec: a3[e4], validateSpec: t5.validateSpec, style: s3, styleSpec: i4 })) : o3.push(new ot(e4, n3[e4], `unknown property "${e4}"`));
                return o3;
              }({ sourceName: r2, value: e2, style: t4.style, styleSpec: n2, validateSpec: a2 }), o2;
            case "geojson":
              if (o2 = nn({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i3, styleSpec: n2, validateSpec: a2, objectElementValidators: gn }), e2.cluster)
                for (const t5 in e2.clusterProperties) {
                  const [n3, i4] = e2.clusterProperties[t5], s3 = "string" == typeof n3 ? [n3, ["accumulated"], ["get", t5]] : n3;
                  o2.push(...ln({ key: `${r2}.${t5}.map`, value: i4, validateSpec: a2, expressionContext: "cluster-map" })), o2.push(...ln({ key: `${r2}.${t5}.reduce`, value: s3, validateSpec: a2, expressionContext: "cluster-reduce" }));
                }
              return o2;
            case "video":
              return nn({ key: r2, value: e2, valueSpec: n2.source_video, style: i3, validateSpec: a2, styleSpec: n2 });
            case "image":
              return nn({ key: r2, value: e2, valueSpec: n2.source_image, style: i3, validateSpec: a2, styleSpec: n2 });
            case "canvas":
              return [new ot(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return un({ key: `${r2}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i3, validateSpec: a2, styleSpec: n2 });
          }
        }
        function vn(t4) {
          const e2 = t4.value, r2 = t4.styleSpec, n2 = r2.light, i3 = t4.style;
          let a2 = [];
          const s2 = kr(e2);
          if (void 0 === e2)
            return a2;
          if ("object" !== s2)
            return a2 = a2.concat([new ot("light", e2, `object expected, ${s2} found`)]), a2;
          for (const s3 in e2) {
            const o2 = s3.match(/^(.*)-transition$/);
            a2 = a2.concat(o2 && n2[o2[1]] && n2[o2[1]].transition ? t4.validateSpec({ key: s3, value: e2[s3], valueSpec: r2.transition, validateSpec: t4.validateSpec, style: i3, styleSpec: r2 }) : n2[s3] ? t4.validateSpec({ key: s3, value: e2[s3], valueSpec: n2[s3], validateSpec: t4.validateSpec, style: i3, styleSpec: r2 }) : [new ot(s3, e2[s3], `unknown property "${s3}"`)]);
          }
          return a2;
        }
        function bn(t4) {
          const e2 = t4.value, r2 = t4.styleSpec, n2 = r2.terrain, i3 = t4.style;
          let a2 = [];
          const s2 = kr(e2);
          if (void 0 === e2)
            return a2;
          if ("object" !== s2)
            return a2 = a2.concat([new ot("terrain", e2, `object expected, ${s2} found`)]), a2;
          for (const s3 in e2)
            a2 = a2.concat(n2[s3] ? t4.validateSpec({ key: s3, value: e2[s3], valueSpec: n2[s3], validateSpec: t4.validateSpec, style: i3, styleSpec: r2 }) : [new ot(s3, e2[s3], `unknown property "${s3}"`)]);
          return a2;
        }
        function wn(t4) {
          let e2 = [];
          const r2 = t4.value, n2 = t4.key;
          if (Array.isArray(r2)) {
            const i3 = [], a2 = [];
            for (const s2 in r2)
              r2[s2].id && i3.includes(r2[s2].id) && e2.push(new ot(n2, r2, `all the sprites' ids must be unique, but ${r2[s2].id} is duplicated`)), i3.push(r2[s2].id), r2[s2].url && a2.includes(r2[s2].url) && e2.push(new ot(n2, r2, `all the sprites' URLs must be unique, but ${r2[s2].url} is duplicated`)), a2.push(r2[s2].url), e2 = e2.concat(nn({ key: `${n2}[${s2}]`, value: r2[s2], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t4.validateSpec }));
            return e2;
          }
          return mn({ key: n2, value: r2 });
        }
        const _n = { "*": () => [], array: an, boolean: function(t4) {
          const e2 = t4.value, r2 = t4.key, n2 = kr(e2);
          return "boolean" !== n2 ? [new ot(r2, e2, `boolean expected, ${n2} found`)] : [];
        }, number: sn, color: function(t4) {
          const e2 = t4.key, r2 = t4.value, n2 = kr(r2);
          return "string" !== n2 ? [new ot(e2, r2, `color expected, ${n2} found`)] : Yt.parse(String(r2)) ? [] : [new ot(e2, r2, `color expected, "${r2}" found`)];
        }, constants: tn, enum: un, filter: cn, function: on, layer: yn, object: nn, source: xn, light: vn, terrain: bn, string: mn, formatted: function(t4) {
          return 0 === mn(t4).length ? [] : ln(t4);
        }, resolvedImage: function(t4) {
          return 0 === mn(t4).length ? [] : ln(t4);
        }, padding: function(t4) {
          const e2 = t4.key, r2 = t4.value;
          if ("array" === kr(r2)) {
            if (r2.length < 1 || r2.length > 4)
              return [new ot(e2, r2, `padding requires 1 to 4 values; ${r2.length} values found`)];
            const n2 = { type: "number" };
            let i3 = [];
            for (let a2 = 0; a2 < r2.length; a2++)
              i3 = i3.concat(t4.validateSpec({ key: `${e2}[${a2}]`, value: r2[a2], validateSpec: t4.validateSpec, valueSpec: n2 }));
            return i3;
          }
          return sn({ key: e2, value: r2, valueSpec: {} });
        }, variableAnchorOffsetCollection: function(t4) {
          const e2 = t4.key, r2 = t4.value, n2 = kr(r2), i3 = t4.styleSpec;
          if ("array" !== n2 || r2.length < 1 || r2.length % 2 != 0)
            return [new ot(e2, r2, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let a2 = [];
          for (let n3 = 0; n3 < r2.length; n3 += 2)
            a2 = a2.concat(un({ key: `${e2}[${n3}]`, value: r2[n3], valueSpec: i3.layout_symbol["text-anchor"] })), a2 = a2.concat(an({ key: `${e2}[${n3 + 1}]`, value: r2[n3 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t4.validateSpec, style: t4.style, styleSpec: i3 }));
          return a2;
        }, sprite: wn };
        function An(t4) {
          const e2 = t4.value, r2 = t4.valueSpec, n2 = t4.styleSpec;
          return t4.validateSpec = An, r2.expression && Ir(en(e2)) ? on(t4) : r2.expression && Tr(rn(e2)) ? ln(t4) : r2.type && _n[r2.type] ? _n[r2.type](t4) : nn(lt({}, t4, { valueSpec: r2.type ? n2[r2.type] : r2 }));
        }
        function Sn(t4) {
          const e2 = t4.value, r2 = t4.key, n2 = mn(t4);
          return n2.length || (-1 === e2.indexOf("{fontstack}") && n2.push(new ot(r2, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n2.push(new ot(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
        }
        function kn(t4, e2 = X) {
          let r2 = [];
          return r2 = r2.concat(An({ key: "", value: t4, valueSpec: e2.$root, styleSpec: e2, style: t4, validateSpec: An, objectElementValidators: { glyphs: Sn, "*": () => [] } })), t4.constants && (r2 = r2.concat(tn({ key: "constants", value: t4.constants, style: t4, styleSpec: e2, validateSpec: An }))), zn(r2);
        }
        function In(t4) {
          return function(e2) {
            return t4({ ...e2, validateSpec: An });
          };
        }
        function zn(t4) {
          return [].concat(t4).sort((t5, e2) => t5.line - e2.line);
        }
        function Mn(t4) {
          return function(...e2) {
            return zn(t4.apply(this, e2));
          };
        }
        kn.source = Mn(In(xn)), kn.sprite = Mn(In(wn)), kn.glyphs = Mn(In(Sn)), kn.light = Mn(In(vn)), kn.terrain = Mn(In(bn)), kn.layer = Mn(In(yn)), kn.filter = Mn(In(cn)), kn.paintProperty = Mn(In(fn)), kn.layoutProperty = Mn(In(dn));
        const Cn = kn, Bn = Cn.light, Pn = Cn.paintProperty, Vn = Cn.layoutProperty;
        function En(t4, e2) {
          let r2 = false;
          if (e2 && e2.length)
            for (const n2 of e2)
              t4.fire(new G(new Error(n2.message))), r2 = true;
          return r2;
        }
        class Fn {
          constructor(t4, e2, r2) {
            const n2 = this.cells = [];
            if (t4 instanceof ArrayBuffer) {
              this.arrayBuffer = t4;
              const i4 = new Int32Array(this.arrayBuffer);
              t4 = i4[0], this.d = (e2 = i4[1]) + 2 * (r2 = i4[2]);
              for (let t5 = 0; t5 < this.d * this.d; t5++) {
                const e3 = i4[3 + t5], r3 = i4[3 + t5 + 1];
                n2.push(e3 === r3 ? null : i4.subarray(e3, r3));
              }
              const a2 = i4[3 + n2.length + 1];
              this.keys = i4.subarray(i4[3 + n2.length], a2), this.bboxes = i4.subarray(a2), this.insert = this._insertReadonly;
            } else {
              this.d = e2 + 2 * r2;
              for (let t5 = 0; t5 < this.d * this.d; t5++)
                n2.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = e2, this.extent = t4, this.padding = r2, this.scale = e2 / t4, this.uid = 0;
            const i3 = r2 / e2 * t4;
            this.min = -i3, this.max = t4 + i3;
          }
          insert(t4, e2, r2, n2, i3) {
            this._forEachCell(e2, r2, n2, i3, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t4), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i3);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t4, e2, r2, n2, i3, a2) {
            this.cells[i3].push(a2);
          }
          query(t4, e2, r2, n2, i3) {
            const a2 = this.min, s2 = this.max;
            if (t4 <= a2 && e2 <= a2 && s2 <= r2 && s2 <= n2 && !i3)
              return Array.prototype.slice.call(this.keys);
            {
              const a3 = [];
              return this._forEachCell(t4, e2, r2, n2, this._queryCell, a3, {}, i3), a3;
            }
          }
          _queryCell(t4, e2, r2, n2, i3, a2, s2, o2) {
            const l2 = this.cells[i3];
            if (null !== l2) {
              const i4 = this.keys, u2 = this.bboxes;
              for (let c2 = 0; c2 < l2.length; c2++) {
                const h2 = l2[c2];
                if (void 0 === s2[h2]) {
                  const l3 = 4 * h2;
                  (o2 ? o2(u2[l3 + 0], u2[l3 + 1], u2[l3 + 2], u2[l3 + 3]) : t4 <= u2[l3 + 2] && e2 <= u2[l3 + 3] && r2 >= u2[l3 + 0] && n2 >= u2[l3 + 1]) ? (s2[h2] = true, a2.push(i4[h2])) : s2[h2] = false;
                }
              }
            }
          }
          _forEachCell(t4, e2, r2, n2, i3, a2, s2, o2) {
            const l2 = this._convertToCellCoord(t4), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2);
            for (let p2 = l2; p2 <= c2; p2++)
              for (let l3 = u2; l3 <= h2; l3++) {
                const u3 = this.d * l3 + p2;
                if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l3), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l3 + 1))) && i3.call(this, t4, e2, r2, n2, u3, a2, s2, o2))
                  return;
              }
          }
          _convertFromCellCoord(t4) {
            return (t4 - this.padding) / this.scale;
          }
          _convertToCellCoord(t4) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t4 * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer)
              return this.arrayBuffer;
            const t4 = this.cells, e2 = 3 + this.cells.length + 1 + 1;
            let r2 = 0;
            for (let t5 = 0; t5 < this.cells.length; t5++)
              r2 += this.cells[t5].length;
            const n2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
            n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
            let i3 = e2;
            for (let e3 = 0; e3 < t4.length; e3++) {
              const r3 = t4[e3];
              n2[3 + e3] = i3, n2.set(r3, i3), i3 += r3.length;
            }
            return n2[3 + t4.length] = i3, n2.set(this.keys, i3), i3 += this.keys.length, n2[3 + t4.length + 1] = i3, n2.set(this.bboxes, i3), i3 += this.bboxes.length, n2.buffer;
          }
          static serialize(t4, e2) {
            const r2 = t4.toArrayBuffer();
            return e2 && e2.push(r2), { buffer: r2 };
          }
          static deserialize(t4) {
            return new Fn(t4.buffer);
          }
        }
        const Tn = {};
        function $n(t4, e2, r2 = {}) {
          if (Tn[t4])
            throw new Error(`${t4} is already registered.`);
          Object.defineProperty(e2, "_classRegistryKey", { value: t4, writeable: false }), Tn[t4] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
        }
        $n("Object", Object), $n("TransferableGridIndex", Fn), $n("Color", Yt), $n("Error", Error), $n("AJAXError", L2), $n("ResolvedImage", ne), $n("StylePropertyFunction", Ur), $n("StyleExpression", Fr, { omit: ["_evaluator"] }), $n("ZoomDependentExpression", Dr), $n("ZoomConstantExpression", Lr), $n("CompoundExpression", $e, { omit: ["_evaluate"] });
        for (const t4 in yr)
          yr[t4]._classRegistryKey || $n(`Expression_${t4}`, yr[t4]);
        function Ln(t4) {
          return t4 && "undefined" != typeof ArrayBuffer && (t4 instanceof ArrayBuffer || t4.constructor && "ArrayBuffer" === t4.constructor.name);
        }
        function Dn(t4, e2) {
          if (null == t4 || "boolean" == typeof t4 || "number" == typeof t4 || "string" == typeof t4 || t4 instanceof Boolean || t4 instanceof Number || t4 instanceof String || t4 instanceof Date || t4 instanceof RegExp || t4 instanceof Blob)
            return t4;
          if (Ln(t4))
            return e2 && e2.push(t4), t4;
          if (M(t4))
            return e2 && e2.push(t4), t4;
          if (ArrayBuffer.isView(t4)) {
            const r2 = t4;
            return e2 && e2.push(r2.buffer), r2;
          }
          if (t4 instanceof ImageData)
            return e2 && e2.push(t4.data.buffer), t4;
          if (Array.isArray(t4)) {
            const r2 = [];
            for (const n2 of t4)
              r2.push(Dn(n2, e2));
            return r2;
          }
          if ("object" == typeof t4) {
            const r2 = t4.constructor, n2 = r2._classRegistryKey;
            if (!n2)
              throw new Error("can't serialize object of unregistered class");
            if (!Tn[n2])
              throw new Error(`${n2} is not registered.`);
            const i3 = r2.serialize ? r2.serialize(t4, e2) : {};
            if (r2.serialize) {
              if (e2 && i3 === e2[e2.length - 1])
                throw new Error("statically serialized object won't survive transfer of $name property");
            } else {
              for (const r3 in t4) {
                if (!t4.hasOwnProperty(r3))
                  continue;
                if (Tn[n2].omit.indexOf(r3) >= 0)
                  continue;
                const a2 = t4[r3];
                i3[r3] = Tn[n2].shallow.indexOf(r3) >= 0 ? a2 : Dn(a2, e2);
              }
              t4 instanceof Error && (i3.message = t4.message);
            }
            if (i3.$name)
              throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== n2 && (i3.$name = n2), i3;
          }
          throw new Error("can't serialize object of type " + typeof t4);
        }
        function On(t4) {
          if (null == t4 || "boolean" == typeof t4 || "number" == typeof t4 || "string" == typeof t4 || t4 instanceof Boolean || t4 instanceof Number || t4 instanceof String || t4 instanceof Date || t4 instanceof RegExp || t4 instanceof Blob || Ln(t4) || M(t4) || ArrayBuffer.isView(t4) || t4 instanceof ImageData)
            return t4;
          if (Array.isArray(t4))
            return t4.map(On);
          if ("object" == typeof t4) {
            const e2 = t4.$name || "Object";
            if (!Tn[e2])
              throw new Error(`can't deserialize unregistered class ${e2}`);
            const { klass: r2 } = Tn[e2];
            if (!r2)
              throw new Error(`can't deserialize unregistered class ${e2}`);
            if (r2.deserialize)
              return r2.deserialize(t4);
            const n2 = Object.create(r2.prototype);
            for (const r3 of Object.keys(t4)) {
              if ("$name" === r3)
                continue;
              const i3 = t4[r3];
              n2[r3] = Tn[e2].shallow.indexOf(r3) >= 0 ? i3 : On(i3);
            }
            return n2;
          }
          throw new Error("can't deserialize object of type " + typeof t4);
        }
        class Un {
          constructor() {
            this.first = true;
          }
          update(t4, e2) {
            const r2 = Math.floor(t4);
            return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t4, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t4 !== this.lastZoom && (this.lastZoom = t4, this.lastFloorZoom = r2, true));
          }
        }
        const Rn = { "Latin-1 Supplement": (t4) => t4 >= 128 && t4 <= 255, Arabic: (t4) => t4 >= 1536 && t4 <= 1791, "Arabic Supplement": (t4) => t4 >= 1872 && t4 <= 1919, "Arabic Extended-A": (t4) => t4 >= 2208 && t4 <= 2303, "Hangul Jamo": (t4) => t4 >= 4352 && t4 <= 4607, "Unified Canadian Aboriginal Syllabics": (t4) => t4 >= 5120 && t4 <= 5759, Khmer: (t4) => t4 >= 6016 && t4 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t4) => t4 >= 6320 && t4 <= 6399, "General Punctuation": (t4) => t4 >= 8192 && t4 <= 8303, "Letterlike Symbols": (t4) => t4 >= 8448 && t4 <= 8527, "Number Forms": (t4) => t4 >= 8528 && t4 <= 8591, "Miscellaneous Technical": (t4) => t4 >= 8960 && t4 <= 9215, "Control Pictures": (t4) => t4 >= 9216 && t4 <= 9279, "Optical Character Recognition": (t4) => t4 >= 9280 && t4 <= 9311, "Enclosed Alphanumerics": (t4) => t4 >= 9312 && t4 <= 9471, "Geometric Shapes": (t4) => t4 >= 9632 && t4 <= 9727, "Miscellaneous Symbols": (t4) => t4 >= 9728 && t4 <= 9983, "Miscellaneous Symbols and Arrows": (t4) => t4 >= 11008 && t4 <= 11263, "CJK Radicals Supplement": (t4) => t4 >= 11904 && t4 <= 12031, "Kangxi Radicals": (t4) => t4 >= 12032 && t4 <= 12255, "Ideographic Description Characters": (t4) => t4 >= 12272 && t4 <= 12287, "CJK Symbols and Punctuation": (t4) => t4 >= 12288 && t4 <= 12351, Hiragana: (t4) => t4 >= 12352 && t4 <= 12447, Katakana: (t4) => t4 >= 12448 && t4 <= 12543, Bopomofo: (t4) => t4 >= 12544 && t4 <= 12591, "Hangul Compatibility Jamo": (t4) => t4 >= 12592 && t4 <= 12687, Kanbun: (t4) => t4 >= 12688 && t4 <= 12703, "Bopomofo Extended": (t4) => t4 >= 12704 && t4 <= 12735, "CJK Strokes": (t4) => t4 >= 12736 && t4 <= 12783, "Katakana Phonetic Extensions": (t4) => t4 >= 12784 && t4 <= 12799, "Enclosed CJK Letters and Months": (t4) => t4 >= 12800 && t4 <= 13055, "CJK Compatibility": (t4) => t4 >= 13056 && t4 <= 13311, "CJK Unified Ideographs Extension A": (t4) => t4 >= 13312 && t4 <= 19903, "Yijing Hexagram Symbols": (t4) => t4 >= 19904 && t4 <= 19967, "CJK Unified Ideographs": (t4) => t4 >= 19968 && t4 <= 40959, "Yi Syllables": (t4) => t4 >= 40960 && t4 <= 42127, "Yi Radicals": (t4) => t4 >= 42128 && t4 <= 42191, "Hangul Jamo Extended-A": (t4) => t4 >= 43360 && t4 <= 43391, "Hangul Syllables": (t4) => t4 >= 44032 && t4 <= 55215, "Hangul Jamo Extended-B": (t4) => t4 >= 55216 && t4 <= 55295, "Private Use Area": (t4) => t4 >= 57344 && t4 <= 63743, "CJK Compatibility Ideographs": (t4) => t4 >= 63744 && t4 <= 64255, "Arabic Presentation Forms-A": (t4) => t4 >= 64336 && t4 <= 65023, "Vertical Forms": (t4) => t4 >= 65040 && t4 <= 65055, "CJK Compatibility Forms": (t4) => t4 >= 65072 && t4 <= 65103, "Small Form Variants": (t4) => t4 >= 65104 && t4 <= 65135, "Arabic Presentation Forms-B": (t4) => t4 >= 65136 && t4 <= 65279, "Halfwidth and Fullwidth Forms": (t4) => t4 >= 65280 && t4 <= 65519 };
        function qn(t4) {
          for (const e2 of t4)
            if (Zn2(e2.charCodeAt(0)))
              return true;
          return false;
        }
        function jn(t4) {
          for (const e2 of t4)
            if (!Nn(e2.charCodeAt(0)))
              return false;
          return true;
        }
        function Nn(t4) {
          return !(Rn.Arabic(t4) || Rn["Arabic Supplement"](t4) || Rn["Arabic Extended-A"](t4) || Rn["Arabic Presentation Forms-A"](t4) || Rn["Arabic Presentation Forms-B"](t4));
        }
        function Zn2(t4) {
          return !(746 !== t4 && 747 !== t4 && (t4 < 4352 || !(Rn["Bopomofo Extended"](t4) || Rn.Bopomofo(t4) || Rn["CJK Compatibility Forms"](t4) && !(t4 >= 65097 && t4 <= 65103) || Rn["CJK Compatibility Ideographs"](t4) || Rn["CJK Compatibility"](t4) || Rn["CJK Radicals Supplement"](t4) || Rn["CJK Strokes"](t4) || !(!Rn["CJK Symbols and Punctuation"](t4) || t4 >= 12296 && t4 <= 12305 || t4 >= 12308 && t4 <= 12319 || 12336 === t4) || Rn["CJK Unified Ideographs Extension A"](t4) || Rn["CJK Unified Ideographs"](t4) || Rn["Enclosed CJK Letters and Months"](t4) || Rn["Hangul Compatibility Jamo"](t4) || Rn["Hangul Jamo Extended-A"](t4) || Rn["Hangul Jamo Extended-B"](t4) || Rn["Hangul Jamo"](t4) || Rn["Hangul Syllables"](t4) || Rn.Hiragana(t4) || Rn["Ideographic Description Characters"](t4) || Rn.Kanbun(t4) || Rn["Kangxi Radicals"](t4) || Rn["Katakana Phonetic Extensions"](t4) || Rn.Katakana(t4) && 12540 !== t4 || !(!Rn["Halfwidth and Fullwidth Forms"](t4) || 65288 === t4 || 65289 === t4 || 65293 === t4 || t4 >= 65306 && t4 <= 65310 || 65339 === t4 || 65341 === t4 || 65343 === t4 || t4 >= 65371 && t4 <= 65503 || 65507 === t4 || t4 >= 65512 && t4 <= 65519) || !(!Rn["Small Form Variants"](t4) || t4 >= 65112 && t4 <= 65118 || t4 >= 65123 && t4 <= 65126) || Rn["Unified Canadian Aboriginal Syllabics"](t4) || Rn["Unified Canadian Aboriginal Syllabics Extended"](t4) || Rn["Vertical Forms"](t4) || Rn["Yijing Hexagram Symbols"](t4) || Rn["Yi Syllables"](t4) || Rn["Yi Radicals"](t4))));
        }
        function Kn(t4) {
          return !(Zn2(t4) || function(t5) {
            return !!(Rn["Latin-1 Supplement"](t5) && (167 === t5 || 169 === t5 || 174 === t5 || 177 === t5 || 188 === t5 || 189 === t5 || 190 === t5 || 215 === t5 || 247 === t5) || Rn["General Punctuation"](t5) && (8214 === t5 || 8224 === t5 || 8225 === t5 || 8240 === t5 || 8241 === t5 || 8251 === t5 || 8252 === t5 || 8258 === t5 || 8263 === t5 || 8264 === t5 || 8265 === t5 || 8273 === t5) || Rn["Letterlike Symbols"](t5) || Rn["Number Forms"](t5) || Rn["Miscellaneous Technical"](t5) && (t5 >= 8960 && t5 <= 8967 || t5 >= 8972 && t5 <= 8991 || t5 >= 8996 && t5 <= 9e3 || 9003 === t5 || t5 >= 9085 && t5 <= 9114 || t5 >= 9150 && t5 <= 9165 || 9167 === t5 || t5 >= 9169 && t5 <= 9179 || t5 >= 9186 && t5 <= 9215) || Rn["Control Pictures"](t5) && 9251 !== t5 || Rn["Optical Character Recognition"](t5) || Rn["Enclosed Alphanumerics"](t5) || Rn["Geometric Shapes"](t5) || Rn["Miscellaneous Symbols"](t5) && !(t5 >= 9754 && t5 <= 9759) || Rn["Miscellaneous Symbols and Arrows"](t5) && (t5 >= 11026 && t5 <= 11055 || t5 >= 11088 && t5 <= 11097 || t5 >= 11192 && t5 <= 11243) || Rn["CJK Symbols and Punctuation"](t5) || Rn.Katakana(t5) || Rn["Private Use Area"](t5) || Rn["CJK Compatibility Forms"](t5) || Rn["Small Form Variants"](t5) || Rn["Halfwidth and Fullwidth Forms"](t5) || 8734 === t5 || 8756 === t5 || 8757 === t5 || t5 >= 9984 && t5 <= 10087 || t5 >= 10102 && t5 <= 10131 || 65532 === t5 || 65533 === t5);
          }(t4));
        }
        function Gn(t4) {
          return t4 >= 1424 && t4 <= 2303 || Rn["Arabic Presentation Forms-A"](t4) || Rn["Arabic Presentation Forms-B"](t4);
        }
        function Jn(t4, e2) {
          return !(!e2 && Gn(t4) || t4 >= 2304 && t4 <= 3583 || t4 >= 3840 && t4 <= 4255 || Rn.Khmer(t4));
        }
        function Xn2(t4) {
          for (const e2 of t4)
            if (Gn(e2.charCodeAt(0)))
              return true;
          return false;
        }
        const Yn2 = "deferred", Hn = "loading", Wn = "loaded";
        let Qn = null, ti = "unavailable", ei = null;
        const ri = function(t4) {
          t4 && "string" == typeof t4 && t4.indexOf("NetworkError") > -1 && (ti = "error"), Qn && Qn(t4);
        };
        function ni() {
          ii.fire(new K2("pluginStateChange", { pluginStatus: ti, pluginURL: ei }));
        }
        const ii = new J(), ai = function() {
          return ti;
        }, si = function() {
          if (ti !== Yn2 || !ei)
            throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          ti = Hn, ni(), ei && q({ url: ei }, (t4) => {
            t4 ? ri(t4) : (ti = Wn, ni());
          });
        }, oi = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => ti === Wn || null != oi.applyArabicShaping, isLoading: () => ti === Hn, setState(t4) {
          if (!I())
            throw new Error("Cannot set the state of the rtl-text-plugin when not in the web-worker context");
          ti = t4.pluginStatus, ei = t4.pluginURL;
        }, isParsed() {
          if (!I())
            throw new Error("rtl-text-plugin is only parsed on the worker-threads");
          return null != oi.applyArabicShaping && null != oi.processBidirectionalText && null != oi.processStyledBidirectionalText;
        }, getPluginURL() {
          if (!I())
            throw new Error("rtl-text-plugin url can only be queried from the worker threads");
          return ei;
        } };
        class li {
          constructor(t4, e2) {
            this.zoom = t4, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Un(), this.transition = {});
          }
          isSupportedScript(t4) {
            return function(t5, e2) {
              for (const r2 of t5)
                if (!Jn(r2.charCodeAt(0), e2))
                  return false;
              return true;
            }(t4, oi.isLoaded());
          }
          crossFadingFactor() {
            return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t4 = this.zoom, e2 = t4 - Math.floor(t4), r2 = this.crossFadingFactor();
            return t4 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
          }
        }
        class ui {
          constructor(t4, e2) {
            this.property = t4, this.value = e2, this.expression = function(t5, e3) {
              if (Ir(t5))
                return new Ur(t5, e3);
              if (Tr(t5)) {
                const r2 = Or(t5, e3);
                if ("error" === r2.result)
                  throw new Error(r2.value.map((t6) => `${t6.key}: ${t6.message}`).join(", "));
                return r2.value;
              }
              {
                let r2 = t5;
                return "color" === e3.type && "string" == typeof t5 ? r2 = Yt.parse(t5) : "padding" !== e3.type || "number" != typeof t5 && !Array.isArray(t5) ? "variableAnchorOffsetCollection" === e3.type && Array.isArray(t5) && (r2 = re.parse(t5)) : r2 = te.parse(t5), { kind: "constant", evaluate: () => r2 };
              }
            }(void 0 === e2 ? t4.specification.default : e2, t4.specification);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t4, e2, r2) {
            return this.property.possiblyEvaluate(this, t4, e2, r2);
          }
        }
        class ci {
          constructor(t4) {
            this.property = t4, this.value = new ui(t4, void 0);
          }
          transitioned(t4, e2) {
            return new pi(this.property, this.value, e2, g({}, t4.transition, this.transition), t4.now);
          }
          untransitioned() {
            return new pi(this.property, this.value, null, {}, 0);
          }
        }
        class hi {
          constructor(t4) {
            this._properties = t4, this._values = Object.create(t4.defaultTransitionablePropertyValues);
          }
          getValue(t4) {
            return w(this._values[t4].value.value);
          }
          setValue(t4, e2) {
            Object.prototype.hasOwnProperty.call(this._values, t4) || (this._values[t4] = new ci(this._values[t4].property)), this._values[t4].value = new ui(this._values[t4].property, null === e2 ? void 0 : w(e2));
          }
          getTransition(t4) {
            return w(this._values[t4].transition);
          }
          setTransition(t4, e2) {
            Object.prototype.hasOwnProperty.call(this._values, t4) || (this._values[t4] = new ci(this._values[t4].property)), this._values[t4].transition = w(e2) || void 0;
          }
          serialize() {
            const t4 = {};
            for (const e2 of Object.keys(this._values)) {
              const r2 = this.getValue(e2);
              void 0 !== r2 && (t4[e2] = r2);
              const n2 = this.getTransition(e2);
              void 0 !== n2 && (t4[`${e2}-transition`] = n2);
            }
            return t4;
          }
          transitioned(t4, e2) {
            const r2 = new fi(this._properties);
            for (const n2 of Object.keys(this._values))
              r2._values[n2] = this._values[n2].transitioned(t4, e2._values[n2]);
            return r2;
          }
          untransitioned() {
            const t4 = new fi(this._properties);
            for (const e2 of Object.keys(this._values))
              t4._values[e2] = this._values[e2].untransitioned();
            return t4;
          }
        }
        class pi {
          constructor(t4, e2, r2, n2, i3) {
            this.property = t4, this.value = e2, this.begin = i3 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t4.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
          }
          possiblyEvaluate(t4, e2, r2) {
            const n2 = t4.now || 0, i3 = this.value.possiblyEvaluate(t4, e2, r2), a2 = this.prior;
            if (a2) {
              if (n2 > this.end)
                return this.prior = null, i3;
              if (this.value.isDataDriven())
                return this.prior = null, i3;
              if (n2 < this.begin)
                return a2.possiblyEvaluate(t4, e2, r2);
              {
                const s2 = (n2 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(a2.possiblyEvaluate(t4, e2, r2), i3, function(t5) {
                  if (t5 <= 0)
                    return 0;
                  if (t5 >= 1)
                    return 1;
                  const e3 = t5 * t5, r3 = e3 * t5;
                  return 4 * (t5 < 0.5 ? r3 : 3 * (t5 - e3) + r3 - 0.75);
                }(s2));
              }
            }
            return i3;
          }
        }
        class fi {
          constructor(t4) {
            this._properties = t4, this._values = Object.create(t4.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t4, e2, r2) {
            const n2 = new mi(this._properties);
            for (const i3 of Object.keys(this._values))
              n2._values[i3] = this._values[i3].possiblyEvaluate(t4, e2, r2);
            return n2;
          }
          hasTransition() {
            for (const t4 of Object.keys(this._values))
              if (this._values[t4].prior)
                return true;
            return false;
          }
        }
        class di {
          constructor(t4) {
            this._properties = t4, this._values = Object.create(t4.defaultPropertyValues);
          }
          hasValue(t4) {
            return void 0 !== this._values[t4].value;
          }
          getValue(t4) {
            return w(this._values[t4].value);
          }
          setValue(t4, e2) {
            this._values[t4] = new ui(this._values[t4].property, null === e2 ? void 0 : w(e2));
          }
          serialize() {
            const t4 = {};
            for (const e2 of Object.keys(this._values)) {
              const r2 = this.getValue(e2);
              void 0 !== r2 && (t4[e2] = r2);
            }
            return t4;
          }
          possiblyEvaluate(t4, e2, r2) {
            const n2 = new mi(this._properties);
            for (const i3 of Object.keys(this._values))
              n2._values[i3] = this._values[i3].possiblyEvaluate(t4, e2, r2);
            return n2;
          }
        }
        class yi {
          constructor(t4, e2, r2) {
            this.property = t4, this.value = e2, this.parameters = r2;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t4) {
            return "constant" === this.value.kind ? this.value.value : t4;
          }
          evaluate(t4, e2, r2, n2) {
            return this.property.evaluate(this.value, this.parameters, t4, e2, r2, n2);
          }
        }
        class mi {
          constructor(t4) {
            this._properties = t4, this._values = Object.create(t4.defaultPossiblyEvaluatedValues);
          }
          get(t4) {
            return this._values[t4];
          }
        }
        class gi {
          constructor(t4) {
            this.specification = t4;
          }
          possiblyEvaluate(t4, e2) {
            if (t4.isDataDriven())
              throw new Error("Value should not be data driven");
            return t4.expression.evaluate(e2);
          }
          interpolate(t4, e2, r2) {
            const n2 = Ze[this.specification.type];
            return n2 ? n2(t4, e2, r2) : t4;
          }
        }
        class xi {
          constructor(t4, e2) {
            this.specification = t4, this.overrides = e2;
          }
          possiblyEvaluate(t4, e2, r2, n2) {
            return new yi(this, "constant" === t4.expression.kind || "camera" === t4.expression.kind ? { kind: "constant", value: t4.expression.evaluate(e2, null, {}, r2, n2) } : t4.expression, e2);
          }
          interpolate(t4, e2, r2) {
            if ("constant" !== t4.value.kind || "constant" !== e2.value.kind)
              return t4;
            if (void 0 === t4.value.value || void 0 === e2.value.value)
              return new yi(this, { kind: "constant", value: void 0 }, t4.parameters);
            const n2 = Ze[this.specification.type];
            if (n2) {
              const i3 = n2(t4.value.value, e2.value.value, r2);
              return new yi(this, { kind: "constant", value: i3 }, t4.parameters);
            }
            return t4;
          }
          evaluate(t4, e2, r2, n2, i3, a2) {
            return "constant" === t4.kind ? t4.value : t4.evaluate(e2, r2, n2, i3, a2);
          }
        }
        class vi extends xi {
          possiblyEvaluate(t4, e2, r2, n2) {
            if (void 0 === t4.value)
              return new yi(this, { kind: "constant", value: void 0 }, e2);
            if ("constant" === t4.expression.kind) {
              const i3 = t4.expression.evaluate(e2, null, {}, r2, n2), a2 = "resolvedImage" === t4.property.specification.type && "string" != typeof i3 ? i3.name : i3, s2 = this._calculate(a2, a2, a2, e2);
              return new yi(this, { kind: "constant", value: s2 }, e2);
            }
            if ("camera" === t4.expression.kind) {
              const r3 = this._calculate(t4.expression.evaluate({ zoom: e2.zoom - 1 }), t4.expression.evaluate({ zoom: e2.zoom }), t4.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
              return new yi(this, { kind: "constant", value: r3 }, e2);
            }
            return new yi(this, t4.expression, e2);
          }
          evaluate(t4, e2, r2, n2, i3, a2) {
            if ("source" === t4.kind) {
              const s2 = t4.evaluate(e2, r2, n2, i3, a2);
              return this._calculate(s2, s2, s2, e2);
            }
            return "composite" === t4.kind ? this._calculate(t4.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r2, n2), t4.evaluate({ zoom: Math.floor(e2.zoom) }, r2, n2), t4.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r2, n2), e2) : t4.value;
          }
          _calculate(t4, e2, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t4, to: e2 } : { from: r2, to: e2 };
          }
          interpolate(t4) {
            return t4;
          }
        }
        class bi {
          constructor(t4) {
            this.specification = t4;
          }
          possiblyEvaluate(t4, e2, r2, n2) {
            if (void 0 !== t4.value) {
              if ("constant" === t4.expression.kind) {
                const i3 = t4.expression.evaluate(e2, null, {}, r2, n2);
                return this._calculate(i3, i3, i3, e2);
              }
              return this._calculate(t4.expression.evaluate(new li(Math.floor(e2.zoom - 1), e2)), t4.expression.evaluate(new li(Math.floor(e2.zoom), e2)), t4.expression.evaluate(new li(Math.floor(e2.zoom + 1), e2)), e2);
            }
          }
          _calculate(t4, e2, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t4, to: e2 } : { from: r2, to: e2 };
          }
          interpolate(t4) {
            return t4;
          }
        }
        class wi {
          constructor(t4) {
            this.specification = t4;
          }
          possiblyEvaluate(t4, e2, r2, n2) {
            return !!t4.expression.evaluate(e2, null, {}, r2, n2);
          }
          interpolate() {
            return false;
          }
        }
        class _i {
          constructor(t4) {
            this.properties = t4, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const e2 in t4) {
              const r2 = t4[e2];
              r2.specification.overridable && this.overridableProperties.push(e2);
              const n2 = this.defaultPropertyValues[e2] = new ui(r2, void 0), i3 = this.defaultTransitionablePropertyValues[e2] = new ci(r2);
              this.defaultTransitioningPropertyValues[e2] = i3.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
            }
          }
        }
        $n("DataDrivenProperty", xi), $n("DataConstantProperty", gi), $n("CrossFadedDataDrivenProperty", vi), $n("CrossFadedProperty", bi), $n("ColorRampProperty", wi);
        const Ai = "-transition";
        class Si extends J {
          constructor(t4, e2) {
            if (super(), this.id = t4.id, this.type = t4.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t4.type && (this.metadata = t4.metadata, this.minzoom = t4.minzoom, this.maxzoom = t4.maxzoom, "background" !== t4.type && (this.source = t4.source, this.sourceLayer = t4["source-layer"], this.filter = t4.filter), e2.layout && (this._unevaluatedLayout = new di(e2.layout)), e2.paint)) {
              this._transitionablePaint = new hi(e2.paint);
              for (const e3 in t4.paint)
                this.setPaintProperty(e3, t4.paint[e3], { validate: false });
              for (const e3 in t4.layout)
                this.setLayoutProperty(e3, t4.layout[e3], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new mi(e2.paint);
            }
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t4) {
            return "visibility" === t4 ? this.visibility : this._unevaluatedLayout.getValue(t4);
          }
          setLayoutProperty(t4, e2, r2 = {}) {
            null != e2 && this._validate(Vn, `layers.${this.id}.layout.${t4}`, t4, e2, r2) || ("visibility" !== t4 ? this._unevaluatedLayout.setValue(t4, e2) : this.visibility = e2);
          }
          getPaintProperty(t4) {
            return t4.endsWith(Ai) ? this._transitionablePaint.getTransition(t4.slice(0, -11)) : this._transitionablePaint.getValue(t4);
          }
          setPaintProperty(t4, e2, r2 = {}) {
            if (null != e2 && this._validate(Pn, `layers.${this.id}.paint.${t4}`, t4, e2, r2))
              return false;
            if (t4.endsWith(Ai))
              return this._transitionablePaint.setTransition(t4.slice(0, -11), e2 || void 0), false;
            {
              const r3 = this._transitionablePaint._values[t4], n2 = "cross-faded-data-driven" === r3.property.specification["property-type"], i3 = r3.value.isDataDriven(), a2 = r3.value;
              this._transitionablePaint.setValue(t4, e2), this._handleSpecialPaintPropertyUpdate(t4);
              const s2 = this._transitionablePaint._values[t4].value;
              return s2.isDataDriven() || i3 || n2 || this._handleOverridablePaintPropertyUpdate(t4, a2, s2);
            }
          }
          _handleSpecialPaintPropertyUpdate(t4) {
          }
          _handleOverridablePaintPropertyUpdate(t4, e2, r2) {
            return false;
          }
          isHidden(t4) {
            return !!(this.minzoom && t4 < this.minzoom) || !!(this.maxzoom && t4 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t4) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t4, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t4, e2) {
            t4.getCrossfadeParameters && (this._crossfadeParameters = t4.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t4, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t4, void 0, e2);
          }
          serialize() {
            const t4 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t4.layout = t4.layout || {}, t4.layout.visibility = this.visibility), b(t4, (t5, e2) => !(void 0 === t5 || "layout" === e2 && !Object.keys(t5).length || "paint" === e2 && !Object.keys(t5).length));
          }
          _validate(t4, e2, r2, n2, i3 = {}) {
            return (!i3 || false !== i3.validate) && En(this, t4.call(Cn, { key: e2, layerType: this.type, objectKey: r2, value: n2, styleSpec: X, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t4 in this.paint._values) {
              const e2 = this.paint.get(t4);
              if (e2 instanceof yi && _r(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent)
                return true;
            }
            return false;
          }
        }
        const ki = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Ii {
          constructor(t4, e2) {
            this._structArray = t4, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class zi {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t4, e2) {
            return t4._trim(), e2 && (t4.isTransferred = true, e2.push(t4.arrayBuffer)), { length: t4.length, arrayBuffer: t4.arrayBuffer };
          }
          static deserialize(t4) {
            const e2 = Object.create(this.prototype);
            return e2.arrayBuffer = t4.arrayBuffer, e2.length = t4.length, e2.capacity = t4.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t4) {
            this.reserve(t4), this.length = t4;
          }
          reserve(t4) {
            if (t4 > this.capacity) {
              this.capacity = Math.max(t4, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e2 = this.uint8;
              this._refreshViews(), e2 && this.uint8.set(e2);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Mi(t4, e2 = 1) {
          let r2 = 0, n2 = 0;
          return { members: t4.map((t5) => {
            const i3 = ki[t5.type].BYTES_PER_ELEMENT, a2 = r2 = Ci(r2, Math.max(e2, i3)), s2 = t5.components || 1;
            return n2 = Math.max(n2, i3), r2 += i3 * s2, { name: t5.name, type: t5.type, components: s2, offset: a2 };
          }), size: Ci(r2, Math.max(n2, e2)), alignment: e2 };
        }
        function Ci(t4, e2) {
          return Math.ceil(t4 / e2) * e2;
        }
        class Bi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t4, e2);
          }
          emplace(t4, e2, r2) {
            const n2 = 2 * t4;
            return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t4;
          }
        }
        Bi.prototype.bytesPerElement = 4, $n("StructArrayLayout2i4", Bi);
        class Pi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t4, e2, r2);
          }
          emplace(t4, e2, r2, n2) {
            const i3 = 3 * t4;
            return this.int16[i3 + 0] = e2, this.int16[i3 + 1] = r2, this.int16[i3 + 2] = n2, t4;
          }
        }
        Pi.prototype.bytesPerElement = 6, $n("StructArrayLayout3i6", Pi);
        class Vi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2, n2) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t4, e2, r2, n2);
          }
          emplace(t4, e2, r2, n2, i3) {
            const a2 = 4 * t4;
            return this.int16[a2 + 0] = e2, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i3, t4;
          }
        }
        Vi.prototype.bytesPerElement = 8, $n("StructArrayLayout4i8", Vi);
        class Ei extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2, n2, i3, a2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t4, e2, r2, n2, i3, a2);
          }
          emplace(t4, e2, r2, n2, i3, a2, s2) {
            const o2 = 6 * t4;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i3, this.int16[o2 + 4] = a2, this.int16[o2 + 5] = s2, t4;
          }
        }
        Ei.prototype.bytesPerElement = 12, $n("StructArrayLayout2i4i12", Ei);
        class Fi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2, n2, i3, a2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t4, e2, r2, n2, i3, a2);
          }
          emplace(t4, e2, r2, n2, i3, a2, s2) {
            const o2 = 4 * t4, l2 = 8 * t4;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.uint8[l2 + 4] = n2, this.uint8[l2 + 5] = i3, this.uint8[l2 + 6] = a2, this.uint8[l2 + 7] = s2, t4;
          }
        }
        Fi.prototype.bytesPerElement = 8, $n("StructArrayLayout2i4ub8", Fi);
        class Ti extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t4, e2);
          }
          emplace(t4, e2, r2) {
            const n2 = 2 * t4;
            return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t4;
          }
        }
        Ti.prototype.bytesPerElement = 8, $n("StructArrayLayout2f8", Ti);
        class $i extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2, n2, i3, a2, s2, o2, l2, u2) {
            const c2 = this.length;
            return this.resize(c2 + 1), this.emplace(c2, t4, e2, r2, n2, i3, a2, s2, o2, l2, u2);
          }
          emplace(t4, e2, r2, n2, i3, a2, s2, o2, l2, u2, c2) {
            const h2 = 10 * t4;
            return this.uint16[h2 + 0] = e2, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i3, this.uint16[h2 + 4] = a2, this.uint16[h2 + 5] = s2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, t4;
          }
        }
        $i.prototype.bytesPerElement = 20, $n("StructArrayLayout10ui20", $i);
        class Li extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2) {
            const p2 = this.length;
            return this.resize(p2 + 1), this.emplace(p2, t4, e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2);
          }
          emplace(t4, e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2, p2) {
            const f2 = 12 * t4;
            return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i3, this.uint16[f2 + 4] = a2, this.uint16[f2 + 5] = s2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t4;
          }
        }
        Li.prototype.bytesPerElement = 24, $n("StructArrayLayout4i4ui4i24", Li);
        class Di extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t4, e2, r2);
          }
          emplace(t4, e2, r2, n2) {
            const i3 = 3 * t4;
            return this.float32[i3 + 0] = e2, this.float32[i3 + 1] = r2, this.float32[i3 + 2] = n2, t4;
          }
        }
        Di.prototype.bytesPerElement = 12, $n("StructArrayLayout3f12", Di);
        class Oi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t4) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t4);
          }
          emplace(t4, e2) {
            return this.uint32[1 * t4 + 0] = e2, t4;
          }
        }
        Oi.prototype.bytesPerElement = 4, $n("StructArrayLayout1ul4", Oi);
        class Ui extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2, n2, i3, a2, s2, o2, l2) {
            const u2 = this.length;
            return this.resize(u2 + 1), this.emplace(u2, t4, e2, r2, n2, i3, a2, s2, o2, l2);
          }
          emplace(t4, e2, r2, n2, i3, a2, s2, o2, l2, u2) {
            const c2 = 10 * t4, h2 = 5 * t4;
            return this.int16[c2 + 0] = e2, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i3, this.int16[c2 + 4] = a2, this.int16[c2 + 5] = s2, this.uint32[h2 + 3] = o2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = u2, t4;
          }
        }
        Ui.prototype.bytesPerElement = 20, $n("StructArrayLayout6i1ul2ui20", Ui);
        class Ri extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2, n2, i3, a2) {
            const s2 = this.length;
            return this.resize(s2 + 1), this.emplace(s2, t4, e2, r2, n2, i3, a2);
          }
          emplace(t4, e2, r2, n2, i3, a2, s2) {
            const o2 = 6 * t4;
            return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i3, this.int16[o2 + 4] = a2, this.int16[o2 + 5] = s2, t4;
          }
        }
        Ri.prototype.bytesPerElement = 12, $n("StructArrayLayout2i2i2i12", Ri);
        class qi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2, n2, i3) {
            const a2 = this.length;
            return this.resize(a2 + 1), this.emplace(a2, t4, e2, r2, n2, i3);
          }
          emplace(t4, e2, r2, n2, i3, a2) {
            const s2 = 4 * t4, o2 = 8 * t4;
            return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.int16[o2 + 6] = i3, this.int16[o2 + 7] = a2, t4;
          }
        }
        qi.prototype.bytesPerElement = 16, $n("StructArrayLayout2f1f2i16", qi);
        class ji extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2, n2) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t4, e2, r2, n2);
          }
          emplace(t4, e2, r2, n2, i3) {
            const a2 = 12 * t4, s2 = 3 * t4;
            return this.uint8[a2 + 0] = e2, this.uint8[a2 + 1] = r2, this.float32[s2 + 1] = n2, this.float32[s2 + 2] = i3, t4;
          }
        }
        ji.prototype.bytesPerElement = 12, $n("StructArrayLayout2ub2f12", ji);
        class Ni extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t4, e2, r2);
          }
          emplace(t4, e2, r2, n2) {
            const i3 = 3 * t4;
            return this.uint16[i3 + 0] = e2, this.uint16[i3 + 1] = r2, this.uint16[i3 + 2] = n2, t4;
          }
        }
        Ni.prototype.bytesPerElement = 6, $n("StructArrayLayout3ui6", Ni);
        class Zi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2) {
            const g2 = this.length;
            return this.resize(g2 + 1), this.emplace(g2, t4, e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2);
          }
          emplace(t4, e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2) {
            const x3 = 24 * t4, v2 = 12 * t4, b2 = 48 * t4;
            return this.int16[x3 + 0] = e2, this.int16[x3 + 1] = r2, this.uint16[x3 + 2] = n2, this.uint16[x3 + 3] = i3, this.uint32[v2 + 2] = a2, this.uint32[v2 + 3] = s2, this.uint32[v2 + 4] = o2, this.uint16[x3 + 10] = l2, this.uint16[x3 + 11] = u2, this.uint16[x3 + 12] = c2, this.float32[v2 + 7] = h2, this.float32[v2 + 8] = p2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y2, this.uint32[v2 + 10] = m2, this.int16[x3 + 22] = g2, t4;
          }
        }
        Zi.prototype.bytesPerElement = 48, $n("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Zi);
        class Ki extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x3, v2, b2, w2, _2, A3, S2, k2, I2, z2) {
            const M2 = this.length;
            return this.resize(M2 + 1), this.emplace(M2, t4, e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x3, v2, b2, w2, _2, A3, S2, k2, I2, z2);
          }
          emplace(t4, e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x3, v2, b2, w2, _2, A3, S2, k2, I2, z2, M2) {
            const C3 = 32 * t4, B3 = 16 * t4;
            return this.int16[C3 + 0] = e2, this.int16[C3 + 1] = r2, this.int16[C3 + 2] = n2, this.int16[C3 + 3] = i3, this.int16[C3 + 4] = a2, this.int16[C3 + 5] = s2, this.int16[C3 + 6] = o2, this.int16[C3 + 7] = l2, this.uint16[C3 + 8] = u2, this.uint16[C3 + 9] = c2, this.uint16[C3 + 10] = h2, this.uint16[C3 + 11] = p2, this.uint16[C3 + 12] = f2, this.uint16[C3 + 13] = d2, this.uint16[C3 + 14] = y2, this.uint16[C3 + 15] = m2, this.uint16[C3 + 16] = g2, this.uint16[C3 + 17] = x3, this.uint16[C3 + 18] = v2, this.uint16[C3 + 19] = b2, this.uint16[C3 + 20] = w2, this.uint16[C3 + 21] = _2, this.uint16[C3 + 22] = A3, this.uint32[B3 + 12] = S2, this.float32[B3 + 13] = k2, this.float32[B3 + 14] = I2, this.uint16[C3 + 30] = z2, this.uint16[C3 + 31] = M2, t4;
          }
        }
        Ki.prototype.bytesPerElement = 64, $n("StructArrayLayout8i15ui1ul2f2ui64", Ki);
        class Gi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t4);
          }
          emplace(t4, e2) {
            return this.float32[1 * t4 + 0] = e2, t4;
          }
        }
        Gi.prototype.bytesPerElement = 4, $n("StructArrayLayout1f4", Gi);
        class Ji extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t4, e2, r2);
          }
          emplace(t4, e2, r2, n2) {
            const i3 = 3 * t4;
            return this.uint16[6 * t4 + 0] = e2, this.float32[i3 + 1] = r2, this.float32[i3 + 2] = n2, t4;
          }
        }
        Ji.prototype.bytesPerElement = 12, $n("StructArrayLayout1ui2f12", Ji);
        class Xi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2) {
            const n2 = this.length;
            return this.resize(n2 + 1), this.emplace(n2, t4, e2, r2);
          }
          emplace(t4, e2, r2, n2) {
            const i3 = 4 * t4;
            return this.uint32[2 * t4 + 0] = e2, this.uint16[i3 + 2] = r2, this.uint16[i3 + 3] = n2, t4;
          }
        }
        Xi.prototype.bytesPerElement = 8, $n("StructArrayLayout1ul2ui8", Xi);
        class Yi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2) {
            const r2 = this.length;
            return this.resize(r2 + 1), this.emplace(r2, t4, e2);
          }
          emplace(t4, e2, r2) {
            const n2 = 2 * t4;
            return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t4;
          }
        }
        Yi.prototype.bytesPerElement = 4, $n("StructArrayLayout2ui4", Yi);
        class Hi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t4) {
            const e2 = this.length;
            return this.resize(e2 + 1), this.emplace(e2, t4);
          }
          emplace(t4, e2) {
            return this.uint16[1 * t4 + 0] = e2, t4;
          }
        }
        Hi.prototype.bytesPerElement = 2, $n("StructArrayLayout1ui2", Hi);
        class Wi extends zi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t4, e2, r2, n2) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t4, e2, r2, n2);
          }
          emplace(t4, e2, r2, n2, i3) {
            const a2 = 4 * t4;
            return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i3, t4;
          }
        }
        Wi.prototype.bytesPerElement = 16, $n("StructArrayLayout4f16", Wi);
        class Qi extends Ii {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new a(this.anchorPointX, this.anchorPointY);
          }
        }
        Qi.prototype.size = 20;
        class ta extends Ui {
          get(t4) {
            return new Qi(this, t4);
          }
        }
        $n("CollisionBoxArray", ta);
        class ea extends Ii {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t4) {
            this._structArray.uint8[this._pos1 + 37] = t4;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t4) {
            this._structArray.uint8[this._pos1 + 38] = t4;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t4) {
            this._structArray.uint32[this._pos4 + 10] = t4;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        ea.prototype.size = 48;
        class ra extends Zi {
          get(t4) {
            return new ea(this, t4);
          }
        }
        $n("PlacedSymbolArray", ra);
        class na extends Ii {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t4) {
            this._structArray.uint32[this._pos4 + 12] = t4;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        na.prototype.size = 64;
        class ia extends Ki {
          get(t4) {
            return new na(this, t4);
          }
        }
        $n("SymbolInstanceArray", ia);
        class aa extends Gi {
          getoffsetX(t4) {
            return this.float32[1 * t4 + 0];
          }
        }
        $n("GlyphOffsetArray", aa);
        class sa extends Pi {
          getx(t4) {
            return this.int16[3 * t4 + 0];
          }
          gety(t4) {
            return this.int16[3 * t4 + 1];
          }
          gettileUnitDistanceFromAnchor(t4) {
            return this.int16[3 * t4 + 2];
          }
        }
        $n("SymbolLineVertexArray", sa);
        class oa extends Ii {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        oa.prototype.size = 12;
        class la extends Ji {
          get(t4) {
            return new oa(this, t4);
          }
        }
        $n("TextAnchorOffsetArray", la);
        class ua extends Ii {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        ua.prototype.size = 8;
        class ca extends Xi {
          get(t4) {
            return new ua(this, t4);
          }
        }
        $n("FeatureIndexArray", ca);
        class ha extends Bi {
        }
        class pa extends Bi {
        }
        class fa extends Bi {
        }
        class da extends Ei {
        }
        class ya extends Fi {
        }
        class ma extends Ti {
        }
        class ga extends $i {
        }
        class xa extends Li {
        }
        class va extends Di {
        }
        class ba extends Oi {
        }
        class wa extends Ri {
        }
        class _a2 extends ji {
        }
        class Aa extends Ni {
        }
        class Sa extends Yi {
        }
        const ka = Mi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ia } = ka;
        class za {
          constructor(t4 = []) {
            this.segments = t4;
          }
          prepareSegment(t4, e2, r2, n2) {
            let i3 = this.segments[this.segments.length - 1];
            return t4 > za.MAX_VERTEX_ARRAY_LENGTH && A2(`Max vertices per segment is ${za.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t4}`), (!i3 || i3.vertexLength + t4 > za.MAX_VERTEX_ARRAY_LENGTH || i3.sortKey !== n2) && (i3 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i3.sortKey = n2), this.segments.push(i3)), i3;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t4 of this.segments)
              for (const e2 in t4.vaos)
                t4.vaos[e2].destroy();
          }
          static simpleSegment(t4, e2, r2, n2) {
            return new za([{ vertexOffset: t4, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
          }
        }
        function Ma(t4, e2) {
          return 256 * (t4 = y(Math.floor(t4), 0, 255)) + y(Math.floor(e2), 0, 255);
        }
        za.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, $n("SegmentVector", za);
        const Ca = Mi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var Ba = { exports: {} }, Pa = { exports: {} };
        Pa.exports = function(t4, e2) {
          var r2, n2, i3, a2, s2, o2, l2, u2;
          for (n2 = t4.length - (r2 = 3 & t4.length), i3 = e2, s2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
            l2 = 255 & t4.charCodeAt(u2) | (255 & t4.charCodeAt(++u2)) << 8 | (255 & t4.charCodeAt(++u2)) << 16 | (255 & t4.charCodeAt(++u2)) << 24, ++u2, i3 = 27492 + (65535 & (a2 = 5 * (65535 & (i3 = (i3 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * s2 + (((l2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i3 >>> 19)) + ((5 * (i3 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a2 >>> 16) & 65535) << 16);
          switch (l2 = 0, r2) {
            case 3:
              l2 ^= (255 & t4.charCodeAt(u2 + 2)) << 16;
            case 2:
              l2 ^= (255 & t4.charCodeAt(u2 + 1)) << 8;
            case 1:
              i3 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t4.charCodeAt(u2))) * s2 + (((l2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
          }
          return i3 ^= t4.length, i3 = 2246822507 * (65535 & (i3 ^= i3 >>> 16)) + ((2246822507 * (i3 >>> 16) & 65535) << 16) & 4294967295, i3 = 3266489909 * (65535 & (i3 ^= i3 >>> 13)) + ((3266489909 * (i3 >>> 16) & 65535) << 16) & 4294967295, (i3 ^= i3 >>> 16) >>> 0;
        };
        var Va = Pa.exports, Ea = { exports: {} };
        Ea.exports = function(t4, e2) {
          for (var r2, n2 = t4.length, i3 = e2 ^ n2, a2 = 0; n2 >= 4; )
            r2 = 1540483477 * (65535 & (r2 = 255 & t4.charCodeAt(a2) | (255 & t4.charCodeAt(++a2)) << 8 | (255 & t4.charCodeAt(++a2)) << 16 | (255 & t4.charCodeAt(++a2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i3 = 1540483477 * (65535 & i3) + ((1540483477 * (i3 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++a2;
          switch (n2) {
            case 3:
              i3 ^= (255 & t4.charCodeAt(a2 + 2)) << 16;
            case 2:
              i3 ^= (255 & t4.charCodeAt(a2 + 1)) << 8;
            case 1:
              i3 = 1540483477 * (65535 & (i3 ^= 255 & t4.charCodeAt(a2))) + ((1540483477 * (i3 >>> 16) & 65535) << 16);
          }
          return i3 = 1540483477 * (65535 & (i3 ^= i3 >>> 13)) + ((1540483477 * (i3 >>> 16) & 65535) << 16), (i3 ^= i3 >>> 15) >>> 0;
        };
        var Fa = Va, Ta = Ea.exports;
        Ba.exports = Fa, Ba.exports.murmur3 = Fa, Ba.exports.murmur2 = Ta;
        var $a = r(Ba.exports);
        class La {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t4, e2, r2, n2) {
            this.ids.push(Da(t4)), this.positions.push(e2, r2, n2);
          }
          getPositions(t4) {
            if (!this.indexed)
              throw new Error("Trying to get index, but feature positions are not indexed");
            const e2 = Da(t4);
            let r2 = 0, n2 = this.ids.length - 1;
            for (; r2 < n2; ) {
              const t5 = r2 + n2 >> 1;
              this.ids[t5] >= e2 ? n2 = t5 : r2 = t5 + 1;
            }
            const i3 = [];
            for (; this.ids[r2] === e2; )
              i3.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
            return i3;
          }
          static serialize(t4, e2) {
            const r2 = new Float64Array(t4.ids), n2 = new Uint32Array(t4.positions);
            return Oa(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
          }
          static deserialize(t4) {
            const e2 = new La();
            return e2.ids = t4.ids, e2.positions = t4.positions, e2.indexed = true, e2;
          }
        }
        function Da(t4) {
          const e2 = +t4;
          return !isNaN(e2) && e2 <= Number.MAX_SAFE_INTEGER ? e2 : $a(String(t4));
        }
        function Oa(t4, e2, r2, n2) {
          for (; r2 < n2; ) {
            const i3 = t4[r2 + n2 >> 1];
            let a2 = r2 - 1, s2 = n2 + 1;
            for (; ; ) {
              do {
                a2++;
              } while (t4[a2] < i3);
              do {
                s2--;
              } while (t4[s2] > i3);
              if (a2 >= s2)
                break;
              Ua(t4, a2, s2), Ua(e2, 3 * a2, 3 * s2), Ua(e2, 3 * a2 + 1, 3 * s2 + 1), Ua(e2, 3 * a2 + 2, 3 * s2 + 2);
            }
            s2 - r2 < n2 - s2 ? (Oa(t4, e2, r2, s2), r2 = s2 + 1) : (Oa(t4, e2, s2 + 1, n2), n2 = s2);
          }
        }
        function Ua(t4, e2, r2) {
          const n2 = t4[e2];
          t4[e2] = t4[r2], t4[r2] = n2;
        }
        $n("FeaturePositionMap", La);
        class Ra {
          constructor(t4, e2) {
            this.gl = t4.gl, this.location = e2;
          }
        }
        class qa extends Ra {
          constructor(t4, e2) {
            super(t4, e2), this.current = 0;
          }
          set(t4) {
            this.current !== t4 && (this.current = t4, this.gl.uniform1f(this.location, t4));
          }
        }
        class ja extends Ra {
          constructor(t4, e2) {
            super(t4, e2), this.current = [0, 0, 0, 0];
          }
          set(t4) {
            t4[0] === this.current[0] && t4[1] === this.current[1] && t4[2] === this.current[2] && t4[3] === this.current[3] || (this.current = t4, this.gl.uniform4f(this.location, t4[0], t4[1], t4[2], t4[3]));
          }
        }
        class Na extends Ra {
          constructor(t4, e2) {
            super(t4, e2), this.current = Yt.transparent;
          }
          set(t4) {
            t4.r === this.current.r && t4.g === this.current.g && t4.b === this.current.b && t4.a === this.current.a || (this.current = t4, this.gl.uniform4f(this.location, t4.r, t4.g, t4.b, t4.a));
          }
        }
        const Za = new Float32Array(16);
        function Ka(t4) {
          return [Ma(255 * t4.r, 255 * t4.g), Ma(255 * t4.b, 255 * t4.a)];
        }
        class Ga {
          constructor(t4, e2, r2) {
            this.value = t4, this.uniformNames = e2.map((t5) => `u_${t5}`), this.type = r2;
          }
          setUniform(t4, e2, r2) {
            t4.set(r2.constantOr(this.value));
          }
          getBinding(t4, e2, r2) {
            return "color" === this.type ? new Na(t4, e2) : new qa(t4, e2);
          }
        }
        class Ja {
          constructor(t4, e2) {
            this.uniformNames = e2.map((t5) => `u_${t5}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t4, e2) {
            this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t4.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t4.tlbr;
          }
          setUniform(t4, e2, r2, n2) {
            const i3 = "u_pattern_to" === n2 ? this.patternTo : "u_pattern_from" === n2 ? this.patternFrom : "u_pixel_ratio_to" === n2 ? this.pixelRatioTo : "u_pixel_ratio_from" === n2 ? this.pixelRatioFrom : null;
            i3 && t4.set(i3);
          }
          getBinding(t4, e2, r2) {
            return "u_pattern" === r2.substr(0, 9) ? new ja(t4, e2) : new qa(t4, e2);
          }
        }
        class Xa {
          constructor(t4, e2, r2, n2) {
            this.expression = t4, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t5) => ({ name: `a_${t5}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
          }
          populatePaintArray(t4, e2, r2, n2, i3) {
            const a2 = this.paintVertexArray.length, s2 = this.expression.evaluate(new li(0), e2, {}, n2, [], i3);
            this.paintVertexArray.resize(t4), this._setPaintValue(a2, t4, s2);
          }
          updatePaintArray(t4, e2, r2, n2) {
            const i3 = this.expression.evaluate({ zoom: 0 }, r2, n2);
            this._setPaintValue(t4, e2, i3);
          }
          _setPaintValue(t4, e2, r2) {
            if ("color" === this.type) {
              const n2 = Ka(r2);
              for (let r3 = t4; r3 < e2; r3++)
                this.paintVertexArray.emplace(r3, n2[0], n2[1]);
            } else {
              for (let n2 = t4; n2 < e2; n2++)
                this.paintVertexArray.emplace(n2, r2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2));
            }
          }
          upload(t4) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t4.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Ya {
          constructor(t4, e2, r2, n2, i3, a2) {
            this.expression = t4, this.uniformNames = e2.map((t5) => `u_${t5}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i3, this.maxValue = 0, this.paintVertexAttributes = e2.map((t5) => ({ name: `a_${t5}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new a2();
          }
          populatePaintArray(t4, e2, r2, n2, i3) {
            const a2 = this.expression.evaluate(new li(this.zoom), e2, {}, n2, [], i3), s2 = this.expression.evaluate(new li(this.zoom + 1), e2, {}, n2, [], i3), o2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t4), this._setPaintValue(o2, t4, a2, s2);
          }
          updatePaintArray(t4, e2, r2, n2) {
            const i3 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), a2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
            this._setPaintValue(t4, e2, i3, a2);
          }
          _setPaintValue(t4, e2, r2, n2) {
            if ("color" === this.type) {
              const i3 = Ka(r2), a2 = Ka(n2);
              for (let r3 = t4; r3 < e2; r3++)
                this.paintVertexArray.emplace(r3, i3[0], i3[1], a2[0], a2[1]);
            } else {
              for (let i3 = t4; i3 < e2; i3++)
                this.paintVertexArray.emplace(i3, r2, n2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
            }
          }
          upload(t4) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t4.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t4, e2) {
            const r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = y(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
            t4.set(n2);
          }
          getBinding(t4, e2, r2) {
            return new qa(t4, e2);
          }
        }
        class Ha {
          constructor(t4, e2, r2, n2, i3, a2) {
            this.expression = t4, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = a2, this.zoomInPaintVertexArray = new i3(), this.zoomOutPaintVertexArray = new i3();
          }
          populatePaintArray(t4, e2, r2) {
            const n2 = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t4), this.zoomOutPaintVertexArray.resize(t4), this._setPaintValues(n2, t4, e2.patterns && e2.patterns[this.layerId], r2);
          }
          updatePaintArray(t4, e2, r2, n2, i3) {
            this._setPaintValues(t4, e2, r2.patterns && r2.patterns[this.layerId], i3);
          }
          _setPaintValues(t4, e2, r2, n2) {
            if (!n2 || !r2)
              return;
            const { min: i3, mid: a2, max: s2 } = r2, o2 = n2[i3], l2 = n2[a2], u2 = n2[s2];
            if (o2 && l2 && u2)
              for (let r3 = t4; r3 < e2; r3++)
                this.zoomInPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], l2.pixelRatio, o2.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], u2.tl[0], u2.tl[1], u2.br[0], u2.br[1], l2.pixelRatio, u2.pixelRatio);
          }
          upload(t4) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t4.createVertexBuffer(this.zoomInPaintVertexArray, Ca.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t4.createVertexBuffer(this.zoomOutPaintVertexArray, Ca.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Wa {
          constructor(t4, e2, r2) {
            this.binders = {}, this._buffers = [];
            const n2 = [];
            for (const i3 in t4.paint._values) {
              if (!r2(i3))
                continue;
              const a2 = t4.paint.get(i3);
              if (!(a2 instanceof yi && _r(a2.property.specification)))
                continue;
              const s2 = ts(i3, t4.type), o2 = a2.value, l2 = a2.property.specification.type, u2 = a2.property.useIntegerZoom, c2 = a2.property.specification["property-type"], h2 = "cross-faded" === c2 || "cross-faded-data-driven" === c2;
              if ("constant" === o2.kind)
                this.binders[i3] = h2 ? new Ja(o2.value, s2) : new Ga(o2.value, s2, l2), n2.push(`/u_${i3}`);
              else if ("source" === o2.kind || h2) {
                const r3 = es(i3, l2, "source");
                this.binders[i3] = h2 ? new Ha(o2, l2, u2, e2, r3, t4.id) : new Xa(o2, s2, l2, r3), n2.push(`/a_${i3}`);
              } else {
                const t5 = es(i3, l2, "composite");
                this.binders[i3] = new Ya(o2, s2, l2, u2, e2, t5), n2.push(`/z_${i3}`);
              }
            }
            this.cacheKey = n2.sort().join("");
          }
          getMaxValue(t4) {
            const e2 = this.binders[t4];
            return e2 instanceof Xa || e2 instanceof Ya ? e2.maxValue : 0;
          }
          populatePaintArrays(t4, e2, r2, n2, i3) {
            for (const a2 in this.binders) {
              const s2 = this.binders[a2];
              (s2 instanceof Xa || s2 instanceof Ya || s2 instanceof Ha) && s2.populatePaintArray(t4, e2, r2, n2, i3);
            }
          }
          setConstantPatternPositions(t4, e2) {
            for (const r2 in this.binders) {
              const n2 = this.binders[r2];
              n2 instanceof Ja && n2.setConstantPatternPositions(t4, e2);
            }
          }
          updatePaintArrays(t4, e2, r2, n2, i3) {
            let a2 = false;
            for (const s2 in t4) {
              const o2 = e2.getPositions(s2);
              for (const e3 of o2) {
                const o3 = r2.feature(e3.index);
                for (const r3 in this.binders) {
                  const l2 = this.binders[r3];
                  if ((l2 instanceof Xa || l2 instanceof Ya || l2 instanceof Ha) && true === l2.expression.isStateDependent) {
                    const u2 = n2.paint.get(r3);
                    l2.expression = u2.value, l2.updatePaintArray(e3.start, e3.end, o3, t4[s2], i3), a2 = true;
                  }
                }
              }
            }
            return a2;
          }
          defines() {
            const t4 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              (r2 instanceof Ga || r2 instanceof Ja) && t4.push(...r2.uniformNames.map((t5) => `#define HAS_UNIFORM_${t5}`));
            }
            return t4;
          }
          getBinderAttributes() {
            const t4 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (r2 instanceof Xa || r2 instanceof Ya)
                for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++)
                  t4.push(r2.paintVertexAttributes[e3].name);
              else if (r2 instanceof Ha)
                for (let e3 = 0; e3 < Ca.members.length; e3++)
                  t4.push(Ca.members[e3].name);
            }
            return t4;
          }
          getBinderUniforms() {
            const t4 = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (r2 instanceof Ga || r2 instanceof Ja || r2 instanceof Ya)
                for (const e3 of r2.uniformNames)
                  t4.push(e3);
            }
            return t4;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t4, e2) {
            const r2 = [];
            for (const n2 in this.binders) {
              const i3 = this.binders[n2];
              if (i3 instanceof Ga || i3 instanceof Ja || i3 instanceof Ya) {
                for (const a2 of i3.uniformNames)
                  if (e2[a2]) {
                    const s2 = i3.getBinding(t4, e2[a2], a2);
                    r2.push({ name: a2, property: n2, binding: s2 });
                  }
              }
            }
            return r2;
          }
          setUniforms(t4, e2, r2, n2) {
            for (const { name: t5, property: i3, binding: a2 } of e2)
              this.binders[i3].setUniform(a2, n2, r2.get(i3), t5);
          }
          updatePaintBuffers(t4) {
            this._buffers = [];
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              if (t4 && r2 instanceof Ha) {
                const e3 = 2 === t4.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
                e3 && this._buffers.push(e3);
              } else
                (r2 instanceof Xa || r2 instanceof Ya) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
            }
          }
          upload(t4) {
            for (const e2 in this.binders) {
              const r2 = this.binders[e2];
              (r2 instanceof Xa || r2 instanceof Ya || r2 instanceof Ha) && r2.upload(t4);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t4 in this.binders) {
              const e2 = this.binders[t4];
              (e2 instanceof Xa || e2 instanceof Ya || e2 instanceof Ha) && e2.destroy();
            }
          }
        }
        class Qa {
          constructor(t4, e2, r2 = () => true) {
            this.programConfigurations = {};
            for (const n2 of t4)
              this.programConfigurations[n2.id] = new Wa(n2, e2, r2);
            this.needsUpload = false, this._featureMap = new La(), this._bufferOffset = 0;
          }
          populatePaintArrays(t4, e2, r2, n2, i3, a2) {
            for (const r3 in this.programConfigurations)
              this.programConfigurations[r3].populatePaintArrays(t4, e2, n2, i3, a2);
            void 0 !== e2.id && this._featureMap.add(e2.id, r2, this._bufferOffset, t4), this._bufferOffset = t4, this.needsUpload = true;
          }
          updatePaintArrays(t4, e2, r2, n2) {
            for (const i3 of r2)
              this.needsUpload = this.programConfigurations[i3.id].updatePaintArrays(t4, this._featureMap, e2, i3, n2) || this.needsUpload;
          }
          get(t4) {
            return this.programConfigurations[t4];
          }
          upload(t4) {
            if (this.needsUpload) {
              for (const e2 in this.programConfigurations)
                this.programConfigurations[e2].upload(t4);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t4 in this.programConfigurations)
              this.programConfigurations[t4].destroy();
          }
        }
        function ts(t4, e2) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t4] || [t4.replace(`${e2}-`, "").replace(/-/g, "_")];
        }
        function es(t4, e2, r2) {
          const n2 = { color: { source: Ti, composite: Wi }, number: { source: Gi, composite: Ti } }, i3 = function(t5) {
            return { "line-pattern": { source: ga, composite: ga }, "fill-pattern": { source: ga, composite: ga }, "fill-extrusion-pattern": { source: ga, composite: ga } }[t5];
          }(t4);
          return i3 && i3[r2] || n2[e2][r2];
        }
        $n("ConstantBinder", Ga), $n("CrossFadedConstantBinder", Ja), $n("SourceExpressionBinder", Xa), $n("CrossFadedCompositeBinder", Ha), $n("CompositeExpressionBinder", Ya), $n("ProgramConfiguration", Wa, { omit: ["_buffers"] }), $n("ProgramConfigurationSet", Qa);
        const rs = 8192, ns = Math.pow(2, 14) - 1, is = -ns - 1;
        function as(t4) {
          const e2 = rs / t4.extent, r2 = t4.loadGeometry();
          for (let t5 = 0; t5 < r2.length; t5++) {
            const n2 = r2[t5];
            for (let t6 = 0; t6 < n2.length; t6++) {
              const r3 = n2[t6], i3 = Math.round(r3.x * e2), a2 = Math.round(r3.y * e2);
              r3.x = y(i3, is, ns), r3.y = y(a2, is, ns), (i3 < r3.x || i3 > r3.x + 1 || a2 < r3.y || a2 > r3.y + 1) && A2("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r2;
        }
        function ss(t4, e2) {
          return { type: t4.type, id: t4.id, properties: t4.properties, geometry: e2 ? as(t4) : [] };
        }
        function os(t4, e2, r2, n2, i3) {
          t4.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i3 + 1) / 2);
        }
        class ls {
          constructor(t4) {
            this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.id), this.index = t4.index, this.hasPattern = false, this.layoutVertexArray = new pa(), this.indexArray = new Aa(), this.segments = new za(), this.programConfigurations = new Qa(t4.layers, t4.zoom), this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id);
          }
          populate(t4, e2, r2) {
            const n2 = this.layers[0], i3 = [];
            let a2 = null, s2 = false;
            "circle" === n2.type && (a2 = n2.layout.get("circle-sort-key"), s2 = !a2.isConstant());
            for (const { feature: e3, id: n3, index: o2, sourceLayerIndex: l2 } of t4) {
              const t5 = this.layers[0]._featureFilter.needGeometry, u2 = ss(e3, t5);
              if (!this.layers[0]._featureFilter.filter(new li(this.zoom), u2, r2))
                continue;
              const c2 = s2 ? a2.evaluate(u2, {}, r2) : void 0, h2 = { id: n3, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o2, geometry: t5 ? u2.geometry : as(e3), patterns: {}, sortKey: c2 };
              i3.push(h2);
            }
            s2 && i3.sort((t5, e3) => t5.sortKey - e3.sortKey);
            for (const n3 of i3) {
              const { geometry: i4, index: a3, sourceLayerIndex: s3 } = n3, o2 = t4[a3].feature;
              this.addFeature(n3, i4, a3, r2), e2.featureIndex.insert(o2, i4, a3, s3, this.index);
            }
          }
          update(t4, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t4, e2, this.stateDependentLayers, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t4) {
            this.uploaded || (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, Ia), this.indexBuffer = t4.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t4), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t4, e2, r2, n2) {
            for (const r3 of e2)
              for (const e3 of r3) {
                const r4 = e3.x, n3 = e3.y;
                if (r4 < 0 || r4 >= rs || n3 < 0 || n3 >= rs)
                  continue;
                const i3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t4.sortKey), a2 = i3.vertexLength;
                os(this.layoutVertexArray, r4, n3, -1, -1), os(this.layoutVertexArray, r4, n3, 1, -1), os(this.layoutVertexArray, r4, n3, 1, 1), os(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(a2, a2 + 1, a2 + 2), this.indexArray.emplaceBack(a2, a2 + 3, a2 + 2), i3.vertexLength += 4, i3.primitiveLength += 2;
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r2, {}, n2);
          }
        }
        function us(t4, e2) {
          for (let r2 = 0; r2 < t4.length; r2++)
            if (xs(e2, t4[r2]))
              return true;
          for (let r2 = 0; r2 < e2.length; r2++)
            if (xs(t4, e2[r2]))
              return true;
          return !!fs(t4, e2);
        }
        function cs(t4, e2, r2) {
          return !!xs(t4, e2) || !!ys(e2, t4, r2);
        }
        function hs(t4, e2) {
          if (1 === t4.length)
            return gs(e2, t4[0]);
          for (let r2 = 0; r2 < e2.length; r2++) {
            const n2 = e2[r2];
            for (let e3 = 0; e3 < n2.length; e3++)
              if (xs(t4, n2[e3]))
                return true;
          }
          for (let r2 = 0; r2 < t4.length; r2++)
            if (gs(e2, t4[r2]))
              return true;
          for (let r2 = 0; r2 < e2.length; r2++)
            if (fs(t4, e2[r2]))
              return true;
          return false;
        }
        function ps(t4, e2, r2) {
          if (t4.length > 1) {
            if (fs(t4, e2))
              return true;
            for (let n2 = 0; n2 < e2.length; n2++)
              if (ys(e2[n2], t4, r2))
                return true;
          }
          for (let n2 = 0; n2 < t4.length; n2++)
            if (ys(t4[n2], e2, r2))
              return true;
          return false;
        }
        function fs(t4, e2) {
          if (0 === t4.length || 0 === e2.length)
            return false;
          for (let r2 = 0; r2 < t4.length - 1; r2++) {
            const n2 = t4[r2], i3 = t4[r2 + 1];
            for (let t5 = 0; t5 < e2.length - 1; t5++)
              if (ds(n2, i3, e2[t5], e2[t5 + 1]))
                return true;
          }
          return false;
        }
        function ds(t4, e2, r2, n2) {
          return S(t4, r2, n2) !== S(e2, r2, n2) && S(t4, e2, r2) !== S(t4, e2, n2);
        }
        function ys(t4, e2, r2) {
          const n2 = r2 * r2;
          if (1 === e2.length)
            return t4.distSqr(e2[0]) < n2;
          for (let r3 = 1; r3 < e2.length; r3++)
            if (ms(t4, e2[r3 - 1], e2[r3]) < n2)
              return true;
          return false;
        }
        function ms(t4, e2, r2) {
          const n2 = e2.distSqr(r2);
          if (0 === n2)
            return t4.distSqr(e2);
          const i3 = ((t4.x - e2.x) * (r2.x - e2.x) + (t4.y - e2.y) * (r2.y - e2.y)) / n2;
          return t4.distSqr(i3 < 0 ? e2 : i3 > 1 ? r2 : r2.sub(e2)._mult(i3)._add(e2));
        }
        function gs(t4, e2) {
          let r2, n2, i3, a2 = false;
          for (let s2 = 0; s2 < t4.length; s2++) {
            r2 = t4[s2];
            for (let t5 = 0, s3 = r2.length - 1; t5 < r2.length; s3 = t5++)
              n2 = r2[t5], i3 = r2[s3], n2.y > e2.y != i3.y > e2.y && e2.x < (i3.x - n2.x) * (e2.y - n2.y) / (i3.y - n2.y) + n2.x && (a2 = !a2);
          }
          return a2;
        }
        function xs(t4, e2) {
          let r2 = false;
          for (let n2 = 0, i3 = t4.length - 1; n2 < t4.length; i3 = n2++) {
            const a2 = t4[n2], s2 = t4[i3];
            a2.y > e2.y != s2.y > e2.y && e2.x < (s2.x - a2.x) * (e2.y - a2.y) / (s2.y - a2.y) + a2.x && (r2 = !r2);
          }
          return r2;
        }
        function vs(t4, e2, r2) {
          const n2 = r2[0], i3 = r2[2];
          if (t4.x < n2.x && e2.x < n2.x || t4.x > i3.x && e2.x > i3.x || t4.y < n2.y && e2.y < n2.y || t4.y > i3.y && e2.y > i3.y)
            return false;
          const a2 = S(t4, e2, r2[0]);
          return a2 !== S(t4, e2, r2[1]) || a2 !== S(t4, e2, r2[2]) || a2 !== S(t4, e2, r2[3]);
        }
        function bs(t4, e2, r2) {
          const n2 = e2.paint.get(t4).value;
          return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t4);
        }
        function ws(t4) {
          return Math.sqrt(t4[0] * t4[0] + t4[1] * t4[1]);
        }
        function _s(t4, e2, r2, n2, i3) {
          if (!e2[0] && !e2[1])
            return t4;
          const s2 = a.convert(e2)._mult(i3);
          "viewport" === r2 && s2._rotate(-n2);
          const o2 = [];
          for (let e3 = 0; e3 < t4.length; e3++)
            o2.push(t4[e3].sub(s2));
          return o2;
        }
        let As, Ss;
        $n("CircleBucket", ls, { omit: ["layers"] });
        var ks = { get paint() {
          return Ss = Ss || new _i({ "circle-radius": new xi(X.paint_circle["circle-radius"]), "circle-color": new xi(X.paint_circle["circle-color"]), "circle-blur": new xi(X.paint_circle["circle-blur"]), "circle-opacity": new xi(X.paint_circle["circle-opacity"]), "circle-translate": new gi(X.paint_circle["circle-translate"]), "circle-translate-anchor": new gi(X.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new gi(X.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new gi(X.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new xi(X.paint_circle["circle-stroke-width"]), "circle-stroke-color": new xi(X.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new xi(X.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return As = As || new _i({ "circle-sort-key": new xi(X.layout_circle["circle-sort-key"]) });
        } }, Is = 1e-6, zs = "undefined" != typeof Float32Array ? Float32Array : Array;
        function Ms(t4) {
          return t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = 1, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = 1, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4;
        }
        function Cs(t4, e2, r2) {
          var n2 = e2[0], i3 = e2[1], a2 = e2[2], s2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x3 = e2[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
          return t4[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * y2, t4[1] = v2 * i3 + b2 * l2 + w2 * p2 + _2 * m2, t4[2] = v2 * a2 + b2 * u2 + w2 * f2 + _2 * g2, t4[3] = v2 * s2 + b2 * c2 + w2 * d2 + _2 * x3, t4[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y2, t4[5] = v2 * i3 + b2 * l2 + w2 * p2 + _2 * m2, t4[6] = v2 * a2 + b2 * u2 + w2 * f2 + _2 * g2, t4[7] = v2 * s2 + b2 * c2 + w2 * d2 + _2 * x3, t4[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y2, t4[9] = v2 * i3 + b2 * l2 + w2 * p2 + _2 * m2, t4[10] = v2 * a2 + b2 * u2 + w2 * f2 + _2 * g2, t4[11] = v2 * s2 + b2 * c2 + w2 * d2 + _2 * x3, t4[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y2, t4[13] = v2 * i3 + b2 * l2 + w2 * p2 + _2 * m2, t4[14] = v2 * a2 + b2 * u2 + w2 * f2 + _2 * g2, t4[15] = v2 * s2 + b2 * c2 + w2 * d2 + _2 * x3, t4;
        }
        Math.hypot || (Math.hypot = function() {
          for (var t4 = 0, e2 = arguments.length; e2--; )
            t4 += arguments[e2] * arguments[e2];
          return Math.sqrt(t4);
        });
        var Bs, Ps = Cs;
        function Vs(t4, e2, r2) {
          var n2 = e2[0], i3 = e2[1], a2 = e2[2], s2 = e2[3];
          return t4[0] = r2[0] * n2 + r2[4] * i3 + r2[8] * a2 + r2[12] * s2, t4[1] = r2[1] * n2 + r2[5] * i3 + r2[9] * a2 + r2[13] * s2, t4[2] = r2[2] * n2 + r2[6] * i3 + r2[10] * a2 + r2[14] * s2, t4[3] = r2[3] * n2 + r2[7] * i3 + r2[11] * a2 + r2[15] * s2, t4;
        }
        Bs = new zs(4), zs != Float32Array && (Bs[0] = 0, Bs[1] = 0, Bs[2] = 0, Bs[3] = 0);
        class Es extends Si {
          constructor(t4) {
            super(t4, ks);
          }
          createBucket(t4) {
            return new ls(t4);
          }
          queryRadius(t4) {
            const e2 = t4;
            return bs("circle-radius", this, e2) + bs("circle-stroke-width", this, e2) + ws(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t4, e2, r2, n2, i3, a2, s2, o2) {
            const l2 = _s(t4, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a2.angle, s2), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2), c2 = "map" === this.paint.get("circle-pitch-alignment"), h2 = c2 ? l2 : function(t5, e3) {
              return t5.map((t6) => Fs(t6, e3));
            }(l2, o2), p2 = c2 ? u2 * s2 : u2;
            for (const t5 of n2)
              for (const e3 of t5) {
                const t6 = c2 ? e3 : Fs(e3, o2);
                let r3 = p2;
                const n3 = Vs([], [e3.x, e3.y, 0, 1], o2);
                if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r3 *= n3[3] / a2.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r3 *= a2.cameraToCenterDistance / n3[3]), cs(h2, t6, r3))
                  return true;
              }
            return false;
          }
        }
        function Fs(t4, e2) {
          const r2 = Vs([], [t4.x, t4.y, 0, 1], e2);
          return new a(r2[0] / r2[3], r2[1] / r2[3]);
        }
        class Ts extends ls {
        }
        let $s;
        $n("HeatmapBucket", Ts, { omit: ["layers"] });
        var Ls = { get paint() {
          return $s = $s || new _i({ "heatmap-radius": new xi(X.paint_heatmap["heatmap-radius"]), "heatmap-weight": new xi(X.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new gi(X.paint_heatmap["heatmap-intensity"]), "heatmap-color": new wi(X.paint_heatmap["heatmap-color"]), "heatmap-opacity": new gi(X.paint_heatmap["heatmap-opacity"]) });
        } };
        function Ds(t4, { width: e2, height: r2 }, n2, i3) {
          if (i3) {
            if (i3 instanceof Uint8ClampedArray)
              i3 = new Uint8Array(i3.buffer);
            else if (i3.length !== e2 * r2 * n2)
              throw new RangeError(`mismatched image size. expected: ${i3.length} but got: ${e2 * r2 * n2}`);
          } else
            i3 = new Uint8Array(e2 * r2 * n2);
          return t4.width = e2, t4.height = r2, t4.data = i3, t4;
        }
        function Os(t4, { width: e2, height: r2 }, n2) {
          if (e2 === t4.width && r2 === t4.height)
            return;
          const i3 = Ds({}, { width: e2, height: r2 }, n2);
          Us(t4, i3, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t4.width, e2), height: Math.min(t4.height, r2) }, n2), t4.width = e2, t4.height = r2, t4.data = i3.data;
        }
        function Us(t4, e2, r2, n2, i3, a2) {
          if (0 === i3.width || 0 === i3.height)
            return e2;
          if (i3.width > t4.width || i3.height > t4.height || r2.x > t4.width - i3.width || r2.y > t4.height - i3.height)
            throw new RangeError("out of range source coordinates for image copy");
          if (i3.width > e2.width || i3.height > e2.height || n2.x > e2.width - i3.width || n2.y > e2.height - i3.height)
            throw new RangeError("out of range destination coordinates for image copy");
          const s2 = t4.data, o2 = e2.data;
          if (s2 === o2)
            throw new Error("srcData equals dstData, so image is already copied");
          for (let l2 = 0; l2 < i3.height; l2++) {
            const u2 = ((r2.y + l2) * t4.width + r2.x) * a2, c2 = ((n2.y + l2) * e2.width + n2.x) * a2;
            for (let t5 = 0; t5 < i3.width * a2; t5++)
              o2[c2 + t5] = s2[u2 + t5];
          }
          return e2;
        }
        class Rs {
          constructor(t4, e2) {
            Ds(this, t4, 1, e2);
          }
          resize(t4) {
            Os(this, t4, 1);
          }
          clone() {
            return new Rs({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t4, e2, r2, n2, i3) {
            Us(t4, e2, r2, n2, i3, 1);
          }
        }
        class qs {
          constructor(t4, e2) {
            Ds(this, t4, 4, e2);
          }
          resize(t4) {
            Os(this, t4, 4);
          }
          replace(t4, e2) {
            e2 ? this.data.set(t4) : this.data = t4 instanceof Uint8ClampedArray ? new Uint8Array(t4.buffer) : t4;
          }
          clone() {
            return new qs({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t4, e2, r2, n2, i3) {
            Us(t4, e2, r2, n2, i3, 4);
          }
        }
        function js(t4) {
          const e2 = {}, r2 = t4.resolution || 256, n2 = t4.clips ? t4.clips.length : 1, i3 = t4.image || new qs({ width: r2, height: n2 });
          if (Math.log(r2) / Math.LN2 % 1 != 0)
            throw new Error(`width is not a power of 2 - ${r2}`);
          const a2 = (r3, n3, a3) => {
            e2[t4.evaluationKey] = a3;
            const s2 = t4.expression.evaluate(e2);
            i3.data[r3 + n3 + 0] = Math.floor(255 * s2.r / s2.a), i3.data[r3 + n3 + 1] = Math.floor(255 * s2.g / s2.a), i3.data[r3 + n3 + 2] = Math.floor(255 * s2.b / s2.a), i3.data[r3 + n3 + 3] = Math.floor(255 * s2.a);
          };
          if (t4.clips)
            for (let e3 = 0, i4 = 0; e3 < n2; ++e3, i4 += 4 * r2)
              for (let n3 = 0, s2 = 0; n3 < r2; n3++, s2 += 4) {
                const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t4.clips[e3];
                a2(i4, s2, l2 * (1 - o2) + u2 * o2);
              }
          else
            for (let t5 = 0, e3 = 0; t5 < r2; t5++, e3 += 4)
              a2(0, e3, t5 / (r2 - 1));
          return i3;
        }
        $n("AlphaImage", Rs), $n("RGBAImage", qs);
        class Ns extends Si {
          createBucket(t4) {
            return new Ts(t4);
          }
          constructor(t4) {
            super(t4, Ls), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t4) {
            "heatmap-color" === t4 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = js({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
        }
        let Zs;
        var Ks = { get paint() {
          return Zs = Zs || new _i({ "hillshade-illumination-direction": new gi(X.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new gi(X.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new gi(X.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new gi(X.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new gi(X.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new gi(X.paint_hillshade["hillshade-accent-color"]) });
        } };
        class Gs extends Si {
          constructor(t4) {
            super(t4, Ks);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
        }
        const Js = Mi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Xs } = Js;
        var Ys = { exports: {} };
        function Hs(t4, e2, r2) {
          r2 = r2 || 2;
          var n2, i3, a2, s2, o2, l2, u2, c2 = e2 && e2.length, h2 = c2 ? e2[0] * r2 : t4.length, p2 = Ws(t4, 0, h2, r2, true), f2 = [];
          if (!p2 || p2.next === p2.prev)
            return f2;
          if (c2 && (p2 = function(t5, e3, r3, n3) {
            var i4, a3, s3, o3 = [];
            for (i4 = 0, a3 = e3.length; i4 < a3; i4++)
              (s3 = Ws(t5, e3[i4] * n3, i4 < a3 - 1 ? e3[i4 + 1] * n3 : t5.length, n3, false)) === s3.next && (s3.steiner = true), o3.push(uo(s3));
            for (o3.sort(ao), i4 = 0; i4 < o3.length; i4++)
              r3 = so(o3[i4], r3);
            return r3;
          }(t4, e2, p2, r2)), t4.length > 80 * r2) {
            n2 = a2 = t4[0], i3 = s2 = t4[1];
            for (var d2 = r2; d2 < h2; d2 += r2)
              (o2 = t4[d2]) < n2 && (n2 = o2), (l2 = t4[d2 + 1]) < i3 && (i3 = l2), o2 > a2 && (a2 = o2), l2 > s2 && (s2 = l2);
            u2 = 0 !== (u2 = Math.max(a2 - n2, s2 - i3)) ? 32767 / u2 : 0;
          }
          return to(p2, f2, r2, n2, i3, u2, 0), f2;
        }
        function Ws(t4, e2, r2, n2, i3) {
          var a2, s2;
          if (i3 === Ao(t4, e2, r2, n2) > 0)
            for (a2 = e2; a2 < r2; a2 += n2)
              s2 = bo(a2, t4[a2], t4[a2 + 1], s2);
          else
            for (a2 = r2 - n2; a2 >= e2; a2 -= n2)
              s2 = bo(a2, t4[a2], t4[a2 + 1], s2);
          return s2 && fo(s2, s2.next) && (wo(s2), s2 = s2.next), s2;
        }
        function Qs(t4, e2) {
          if (!t4)
            return t4;
          e2 || (e2 = t4);
          var r2, n2 = t4;
          do {
            if (r2 = false, n2.steiner || !fo(n2, n2.next) && 0 !== po(n2.prev, n2, n2.next))
              n2 = n2.next;
            else {
              if (wo(n2), (n2 = e2 = n2.prev) === n2.next)
                break;
              r2 = true;
            }
          } while (r2 || n2 !== e2);
          return e2;
        }
        function to(t4, e2, r2, n2, i3, a2, s2) {
          if (t4) {
            !s2 && a2 && function(t5, e3, r3, n3) {
              var i4 = t5;
              do {
                0 === i4.z && (i4.z = lo(i4.x, i4.y, e3, r3, n3)), i4.prevZ = i4.prev, i4.nextZ = i4.next, i4 = i4.next;
              } while (i4 !== t5);
              i4.prevZ.nextZ = null, i4.prevZ = null, function(t6) {
                var e4, r4, n4, i5, a3, s3, o3, l3, u3 = 1;
                do {
                  for (r4 = t6, t6 = null, a3 = null, s3 = 0; r4; ) {
                    for (s3++, n4 = r4, o3 = 0, e4 = 0; e4 < u3 && (o3++, n4 = n4.nextZ); e4++)
                      ;
                    for (l3 = u3; o3 > 0 || l3 > 0 && n4; )
                      0 !== o3 && (0 === l3 || !n4 || r4.z <= n4.z) ? (i5 = r4, r4 = r4.nextZ, o3--) : (i5 = n4, n4 = n4.nextZ, l3--), a3 ? a3.nextZ = i5 : t6 = i5, i5.prevZ = a3, a3 = i5;
                    r4 = n4;
                  }
                  a3.nextZ = null, u3 *= 2;
                } while (s3 > 1);
              }(i4);
            }(t4, n2, i3, a2);
            for (var o2, l2, u2 = t4; t4.prev !== t4.next; )
              if (o2 = t4.prev, l2 = t4.next, a2 ? ro(t4, n2, i3, a2) : eo(t4))
                e2.push(o2.i / r2 | 0), e2.push(t4.i / r2 | 0), e2.push(l2.i / r2 | 0), wo(t4), t4 = l2.next, u2 = l2.next;
              else if ((t4 = l2) === u2) {
                s2 ? 1 === s2 ? to(t4 = no(Qs(t4), e2, r2), e2, r2, n2, i3, a2, 2) : 2 === s2 && io(t4, e2, r2, n2, i3, a2) : to(Qs(t4), e2, r2, n2, i3, a2, 1);
                break;
              }
          }
        }
        function eo(t4) {
          var e2 = t4.prev, r2 = t4, n2 = t4.next;
          if (po(e2, r2, n2) >= 0)
            return false;
          for (var i3 = e2.x, a2 = r2.x, s2 = n2.x, o2 = e2.y, l2 = r2.y, u2 = n2.y, c2 = i3 < a2 ? i3 < s2 ? i3 : s2 : a2 < s2 ? a2 : s2, h2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, p2 = i3 > a2 ? i3 > s2 ? i3 : s2 : a2 > s2 ? a2 : s2, f2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, d2 = n2.next; d2 !== e2; ) {
            if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && co(i3, o2, a2, l2, s2, u2, d2.x, d2.y) && po(d2.prev, d2, d2.next) >= 0)
              return false;
            d2 = d2.next;
          }
          return true;
        }
        function ro(t4, e2, r2, n2) {
          var i3 = t4.prev, a2 = t4, s2 = t4.next;
          if (po(i3, a2, s2) >= 0)
            return false;
          for (var o2 = i3.x, l2 = a2.x, u2 = s2.x, c2 = i3.y, h2 = a2.y, p2 = s2.y, f2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, d2 = c2 < h2 ? c2 < p2 ? c2 : p2 : h2 < p2 ? h2 : p2, y2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, m2 = c2 > h2 ? c2 > p2 ? c2 : p2 : h2 > p2 ? h2 : p2, g2 = lo(f2, d2, e2, r2, n2), x3 = lo(y2, m2, e2, r2, n2), v2 = t4.prevZ, b2 = t4.nextZ; v2 && v2.z >= g2 && b2 && b2.z <= x3; ) {
            if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i3 && v2 !== s2 && co(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && po(v2.prev, v2, v2.next) >= 0)
              return false;
            if (v2 = v2.prevZ, b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i3 && b2 !== s2 && co(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && po(b2.prev, b2, b2.next) >= 0)
              return false;
            b2 = b2.nextZ;
          }
          for (; v2 && v2.z >= g2; ) {
            if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i3 && v2 !== s2 && co(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && po(v2.prev, v2, v2.next) >= 0)
              return false;
            v2 = v2.prevZ;
          }
          for (; b2 && b2.z <= x3; ) {
            if (b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i3 && b2 !== s2 && co(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && po(b2.prev, b2, b2.next) >= 0)
              return false;
            b2 = b2.nextZ;
          }
          return true;
        }
        function no(t4, e2, r2) {
          var n2 = t4;
          do {
            var i3 = n2.prev, a2 = n2.next.next;
            !fo(i3, a2) && yo(i3, n2, n2.next, a2) && xo(i3, a2) && xo(a2, i3) && (e2.push(i3.i / r2 | 0), e2.push(n2.i / r2 | 0), e2.push(a2.i / r2 | 0), wo(n2), wo(n2.next), n2 = t4 = a2), n2 = n2.next;
          } while (n2 !== t4);
          return Qs(n2);
        }
        function io(t4, e2, r2, n2, i3, a2) {
          var s2 = t4;
          do {
            for (var o2 = s2.next.next; o2 !== s2.prev; ) {
              if (s2.i !== o2.i && ho(s2, o2)) {
                var l2 = vo(s2, o2);
                return s2 = Qs(s2, s2.next), l2 = Qs(l2, l2.next), to(s2, e2, r2, n2, i3, a2, 0), void to(l2, e2, r2, n2, i3, a2, 0);
              }
              o2 = o2.next;
            }
            s2 = s2.next;
          } while (s2 !== t4);
        }
        function ao(t4, e2) {
          return t4.x - e2.x;
        }
        function so(t4, e2) {
          var r2 = function(t5, e3) {
            var r3, n3 = e3, i3 = t5.x, a2 = t5.y, s2 = -1 / 0;
            do {
              if (a2 <= n3.y && a2 >= n3.next.y && n3.next.y !== n3.y) {
                var o2 = n3.x + (a2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
                if (o2 <= i3 && o2 > s2 && (s2 = o2, r3 = n3.x < n3.next.x ? n3 : n3.next, o2 === i3))
                  return r3;
              }
              n3 = n3.next;
            } while (n3 !== e3);
            if (!r3)
              return null;
            var l2, u2 = r3, c2 = r3.x, h2 = r3.y, p2 = 1 / 0;
            n3 = r3;
            do {
              i3 >= n3.x && n3.x >= c2 && i3 !== n3.x && co(a2 < h2 ? i3 : s2, a2, c2, h2, a2 < h2 ? s2 : i3, a2, n3.x, n3.y) && (l2 = Math.abs(a2 - n3.y) / (i3 - n3.x), xo(n3, t5) && (l2 < p2 || l2 === p2 && (n3.x > r3.x || n3.x === r3.x && oo(r3, n3))) && (r3 = n3, p2 = l2)), n3 = n3.next;
            } while (n3 !== u2);
            return r3;
          }(t4, e2);
          if (!r2)
            return e2;
          var n2 = vo(r2, t4);
          return Qs(n2, n2.next), Qs(r2, r2.next);
        }
        function oo(t4, e2) {
          return po(t4.prev, t4, e2.prev) < 0 && po(e2.next, t4, t4.next) < 0;
        }
        function lo(t4, e2, r2, n2, i3) {
          return (t4 = 1431655765 & ((t4 = 858993459 & ((t4 = 252645135 & ((t4 = 16711935 & ((t4 = (t4 - r2) * i3 | 0) | t4 << 8)) | t4 << 4)) | t4 << 2)) | t4 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i3 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
        }
        function uo(t4) {
          var e2 = t4, r2 = t4;
          do {
            (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
          } while (e2 !== t4);
          return r2;
        }
        function co(t4, e2, r2, n2, i3, a2, s2, o2) {
          return (i3 - s2) * (e2 - o2) >= (t4 - s2) * (a2 - o2) && (t4 - s2) * (n2 - o2) >= (r2 - s2) * (e2 - o2) && (r2 - s2) * (a2 - o2) >= (i3 - s2) * (n2 - o2);
        }
        function ho(t4, e2) {
          return t4.next.i !== e2.i && t4.prev.i !== e2.i && !function(t5, e3) {
            var r2 = t5;
            do {
              if (r2.i !== t5.i && r2.next.i !== t5.i && r2.i !== e3.i && r2.next.i !== e3.i && yo(r2, r2.next, t5, e3))
                return true;
              r2 = r2.next;
            } while (r2 !== t5);
            return false;
          }(t4, e2) && (xo(t4, e2) && xo(e2, t4) && function(t5, e3) {
            var r2 = t5, n2 = false, i3 = (t5.x + e3.x) / 2, a2 = (t5.y + e3.y) / 2;
            do {
              r2.y > a2 != r2.next.y > a2 && r2.next.y !== r2.y && i3 < (r2.next.x - r2.x) * (a2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
            } while (r2 !== t5);
            return n2;
          }(t4, e2) && (po(t4.prev, t4, e2.prev) || po(t4, e2.prev, e2)) || fo(t4, e2) && po(t4.prev, t4, t4.next) > 0 && po(e2.prev, e2, e2.next) > 0);
        }
        function po(t4, e2, r2) {
          return (e2.y - t4.y) * (r2.x - e2.x) - (e2.x - t4.x) * (r2.y - e2.y);
        }
        function fo(t4, e2) {
          return t4.x === e2.x && t4.y === e2.y;
        }
        function yo(t4, e2, r2, n2) {
          var i3 = go(po(t4, e2, r2)), a2 = go(po(t4, e2, n2)), s2 = go(po(r2, n2, t4)), o2 = go(po(r2, n2, e2));
          return i3 !== a2 && s2 !== o2 || !(0 !== i3 || !mo(t4, r2, e2)) || !(0 !== a2 || !mo(t4, n2, e2)) || !(0 !== s2 || !mo(r2, t4, n2)) || !(0 !== o2 || !mo(r2, e2, n2));
        }
        function mo(t4, e2, r2) {
          return e2.x <= Math.max(t4.x, r2.x) && e2.x >= Math.min(t4.x, r2.x) && e2.y <= Math.max(t4.y, r2.y) && e2.y >= Math.min(t4.y, r2.y);
        }
        function go(t4) {
          return t4 > 0 ? 1 : t4 < 0 ? -1 : 0;
        }
        function xo(t4, e2) {
          return po(t4.prev, t4, t4.next) < 0 ? po(t4, e2, t4.next) >= 0 && po(t4, t4.prev, e2) >= 0 : po(t4, e2, t4.prev) < 0 || po(t4, t4.next, e2) < 0;
        }
        function vo(t4, e2) {
          var r2 = new _o(t4.i, t4.x, t4.y), n2 = new _o(e2.i, e2.x, e2.y), i3 = t4.next, a2 = e2.prev;
          return t4.next = e2, e2.prev = t4, r2.next = i3, i3.prev = r2, n2.next = r2, r2.prev = n2, a2.next = n2, n2.prev = a2, n2;
        }
        function bo(t4, e2, r2, n2) {
          var i3 = new _o(t4, e2, r2);
          return n2 ? (i3.next = n2.next, i3.prev = n2, n2.next.prev = i3, n2.next = i3) : (i3.prev = i3, i3.next = i3), i3;
        }
        function wo(t4) {
          t4.next.prev = t4.prev, t4.prev.next = t4.next, t4.prevZ && (t4.prevZ.nextZ = t4.nextZ), t4.nextZ && (t4.nextZ.prevZ = t4.prevZ);
        }
        function _o(t4, e2, r2) {
          this.i = t4, this.x = e2, this.y = r2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function Ao(t4, e2, r2, n2) {
          for (var i3 = 0, a2 = e2, s2 = r2 - n2; a2 < r2; a2 += n2)
            i3 += (t4[s2] - t4[a2]) * (t4[a2 + 1] + t4[s2 + 1]), s2 = a2;
          return i3;
        }
        Ys.exports = Hs, Ys.exports.default = Hs, Hs.deviation = function(t4, e2, r2, n2) {
          var i3 = e2 && e2.length, a2 = Math.abs(Ao(t4, 0, i3 ? e2[0] * r2 : t4.length, r2));
          if (i3)
            for (var s2 = 0, o2 = e2.length; s2 < o2; s2++)
              a2 -= Math.abs(Ao(t4, e2[s2] * r2, s2 < o2 - 1 ? e2[s2 + 1] * r2 : t4.length, r2));
          var l2 = 0;
          for (s2 = 0; s2 < n2.length; s2 += 3) {
            var u2 = n2[s2] * r2, c2 = n2[s2 + 1] * r2, h2 = n2[s2 + 2] * r2;
            l2 += Math.abs((t4[u2] - t4[h2]) * (t4[c2 + 1] - t4[u2 + 1]) - (t4[u2] - t4[c2]) * (t4[h2 + 1] - t4[u2 + 1]));
          }
          return 0 === a2 && 0 === l2 ? 0 : Math.abs((l2 - a2) / a2);
        }, Hs.flatten = function(t4) {
          for (var e2 = t4[0][0].length, r2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i3 = 0; i3 < t4.length; i3++) {
            for (var a2 = 0; a2 < t4[i3].length; a2++)
              for (var s2 = 0; s2 < e2; s2++)
                r2.vertices.push(t4[i3][a2][s2]);
            i3 > 0 && r2.holes.push(n2 += t4[i3 - 1].length);
          }
          return r2;
        };
        var So = r(Ys.exports);
        function ko(t4, e2, r2, n2, i3) {
          Io(t4, e2, r2 || 0, n2 || t4.length - 1, i3 || Mo);
        }
        function Io(t4, e2, r2, n2, i3) {
          for (; n2 > r2; ) {
            if (n2 - r2 > 600) {
              var a2 = n2 - r2 + 1, s2 = e2 - r2 + 1, o2 = Math.log(a2), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (a2 - l2) / a2) * (s2 - a2 / 2 < 0 ? -1 : 1);
              Io(t4, e2, Math.max(r2, Math.floor(e2 - s2 * l2 / a2 + u2)), Math.min(n2, Math.floor(e2 + (a2 - s2) * l2 / a2 + u2)), i3);
            }
            var c2 = t4[e2], h2 = r2, p2 = n2;
            for (zo(t4, r2, e2), i3(t4[n2], c2) > 0 && zo(t4, r2, n2); h2 < p2; ) {
              for (zo(t4, h2, p2), h2++, p2--; i3(t4[h2], c2) < 0; )
                h2++;
              for (; i3(t4[p2], c2) > 0; )
                p2--;
            }
            0 === i3(t4[r2], c2) ? zo(t4, r2, p2) : zo(t4, ++p2, n2), p2 <= e2 && (r2 = p2 + 1), e2 <= p2 && (n2 = p2 - 1);
          }
        }
        function zo(t4, e2, r2) {
          var n2 = t4[e2];
          t4[e2] = t4[r2], t4[r2] = n2;
        }
        function Mo(t4, e2) {
          return t4 < e2 ? -1 : t4 > e2 ? 1 : 0;
        }
        function Co(t4, e2) {
          const r2 = t4.length;
          if (r2 <= 1)
            return [t4];
          const n2 = [];
          let i3, a2;
          for (let e3 = 0; e3 < r2; e3++) {
            const r3 = k(t4[e3]);
            0 !== r3 && (t4[e3].area = Math.abs(r3), void 0 === a2 && (a2 = r3 < 0), a2 === r3 < 0 ? (i3 && n2.push(i3), i3 = [t4[e3]]) : i3.push(t4[e3]));
          }
          if (i3 && n2.push(i3), e2 > 1)
            for (let t5 = 0; t5 < n2.length; t5++)
              n2[t5].length <= e2 || (ko(n2[t5], e2, 1, n2[t5].length - 1, Bo), n2[t5] = n2[t5].slice(0, e2));
          return n2;
        }
        function Bo(t4, e2) {
          return e2.area - t4.area;
        }
        function Po(t4, e2, r2) {
          const n2 = r2.patternDependencies;
          let i3 = false;
          for (const r3 of e2) {
            const e3 = r3.paint.get(`${t4}-pattern`);
            e3.isConstant() || (i3 = true);
            const a2 = e3.constantOr(null);
            a2 && (i3 = true, n2[a2.to] = true, n2[a2.from] = true);
          }
          return i3;
        }
        function Vo(t4, e2, r2, n2, i3) {
          const a2 = i3.patternDependencies;
          for (const s2 of e2) {
            const e3 = s2.paint.get(`${t4}-pattern`).value;
            if ("constant" !== e3.kind) {
              let t5 = e3.evaluate({ zoom: n2 - 1 }, r2, {}, i3.availableImages), o2 = e3.evaluate({ zoom: n2 }, r2, {}, i3.availableImages), l2 = e3.evaluate({ zoom: n2 + 1 }, r2, {}, i3.availableImages);
              t5 = t5 && t5.name ? t5.name : t5, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, a2[t5] = true, a2[o2] = true, a2[l2] = true, r2.patterns[s2.id] = { min: t5, mid: o2, max: l2 };
            }
          }
          return r2;
        }
        class Eo {
          constructor(t4) {
            this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.id), this.index = t4.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new fa(), this.indexArray = new Aa(), this.indexArray2 = new Sa(), this.programConfigurations = new Qa(t4.layers, t4.zoom), this.segments = new za(), this.segments2 = new za(), this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id);
          }
          populate(t4, e2, r2) {
            this.hasPattern = Po("fill", this.layers, e2);
            const n2 = this.layers[0].layout.get("fill-sort-key"), i3 = !n2.isConstant(), a2 = [];
            for (const { feature: s2, id: o2, index: l2, sourceLayerIndex: u2 } of t4) {
              const t5 = this.layers[0]._featureFilter.needGeometry, c2 = ss(s2, t5);
              if (!this.layers[0]._featureFilter.filter(new li(this.zoom), c2, r2))
                continue;
              const h2 = i3 ? n2.evaluate(c2, {}, r2, e2.availableImages) : void 0, p2 = { id: o2, properties: s2.properties, type: s2.type, sourceLayerIndex: u2, index: l2, geometry: t5 ? c2.geometry : as(s2), patterns: {}, sortKey: h2 };
              a2.push(p2);
            }
            i3 && a2.sort((t5, e3) => t5.sortKey - e3.sortKey);
            for (const n3 of a2) {
              const { geometry: i4, index: a3, sourceLayerIndex: s2 } = n3;
              if (this.hasPattern) {
                const t5 = Vo("fill", this.layers, n3, this.zoom, e2);
                this.patternFeatures.push(t5);
              } else
                this.addFeature(n3, i4, a3, r2, {});
              e2.featureIndex.insert(t4[a3].feature, i4, a3, s2, this.index);
            }
          }
          update(t4, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t4, e2, this.stateDependentLayers, r2);
          }
          addFeatures(t4, e2, r2) {
            for (const t5 of this.patternFeatures)
              this.addFeature(t5, t5.geometry, t5.index, e2, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t4) {
            this.uploaded || (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, Xs), this.indexBuffer = t4.createIndexBuffer(this.indexArray), this.indexBuffer2 = t4.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t4), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t4, e2, r2, n2, i3) {
            for (const t5 of Co(e2, 500)) {
              let e3 = 0;
              for (const r4 of t5)
                e3 += r4.length;
              const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i4 = [], a2 = [];
              for (const e4 of t5) {
                if (0 === e4.length)
                  continue;
                e4 !== t5[0] && a2.push(i4.length / 2);
                const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
                this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i4.push(e4[0].x), i4.push(e4[0].y);
                for (let t6 = 1; t6 < e4.length; t6++)
                  this.layoutVertexArray.emplaceBack(e4[t6].x, e4[t6].y), this.indexArray2.emplaceBack(n4 + t6 - 1, n4 + t6), i4.push(e4[t6].x), i4.push(e4[t6].y);
                r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
              }
              const s2 = So(i4, a2);
              for (let t6 = 0; t6 < s2.length; t6 += 3)
                this.indexArray.emplaceBack(n3 + s2[t6], n3 + s2[t6 + 1], n3 + s2[t6 + 2]);
              r3.vertexLength += e3, r3.primitiveLength += s2.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r2, i3, n2);
          }
        }
        let Fo, To;
        $n("FillBucket", Eo, { omit: ["layers", "patternFeatures"] });
        var $o = { get paint() {
          return To = To || new _i({ "fill-antialias": new gi(X.paint_fill["fill-antialias"]), "fill-opacity": new xi(X.paint_fill["fill-opacity"]), "fill-color": new xi(X.paint_fill["fill-color"]), "fill-outline-color": new xi(X.paint_fill["fill-outline-color"]), "fill-translate": new gi(X.paint_fill["fill-translate"]), "fill-translate-anchor": new gi(X.paint_fill["fill-translate-anchor"]), "fill-pattern": new vi(X.paint_fill["fill-pattern"]) });
        }, get layout() {
          return Fo = Fo || new _i({ "fill-sort-key": new xi(X.layout_fill["fill-sort-key"]) });
        } };
        class Lo extends Si {
          constructor(t4) {
            super(t4, $o);
          }
          recalculate(t4, e2) {
            super.recalculate(t4, e2);
            const r2 = this.paint._values["fill-outline-color"];
            "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t4) {
            return new Eo(t4);
          }
          queryRadius() {
            return ws(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t4, e2, r2, n2, i3, a2, s2) {
            return hs(_s(t4, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a2.angle, s2), n2);
          }
          isTileClipped() {
            return true;
          }
        }
        const Do = Mi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Oo = Mi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Uo } = Do;
        var Ro = {}, qo = n, jo = No;
        function No(t4, e2, r2, n2, i3) {
          this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t4, this._geometry = -1, this._keys = n2, this._values = i3, t4.readFields(Zo, this, e2);
        }
        function Zo(t4, e2, r2) {
          1 == t4 ? e2.id = r2.readVarint() : 2 == t4 ? function(t5, e3) {
            for (var r3 = t5.readVarint() + t5.pos; t5.pos < r3; ) {
              var n2 = e3._keys[t5.readVarint()], i3 = e3._values[t5.readVarint()];
              e3.properties[n2] = i3;
            }
          }(r2, e2) : 3 == t4 ? e2.type = r2.readVarint() : 4 == t4 && (e2._geometry = r2.pos);
        }
        function Ko(t4) {
          for (var e2, r2, n2 = 0, i3 = 0, a2 = t4.length, s2 = a2 - 1; i3 < a2; s2 = i3++)
            n2 += ((r2 = t4[s2]).x - (e2 = t4[i3]).x) * (e2.y + r2.y);
          return n2;
        }
        No.types = ["Unknown", "Point", "LineString", "Polygon"], No.prototype.loadGeometry = function() {
          var t4 = this._pbf;
          t4.pos = this._geometry;
          for (var e2, r2 = t4.readVarint() + t4.pos, n2 = 1, i3 = 0, a2 = 0, s2 = 0, o2 = []; t4.pos < r2; ) {
            if (i3 <= 0) {
              var l2 = t4.readVarint();
              n2 = 7 & l2, i3 = l2 >> 3;
            }
            if (i3--, 1 === n2 || 2 === n2)
              a2 += t4.readSVarint(), s2 += t4.readSVarint(), 1 === n2 && (e2 && o2.push(e2), e2 = []), e2.push(new qo(a2, s2));
            else {
              if (7 !== n2)
                throw new Error("unknown command " + n2);
              e2 && e2.push(e2[0].clone());
            }
          }
          return e2 && o2.push(e2), o2;
        }, No.prototype.bbox = function() {
          var t4 = this._pbf;
          t4.pos = this._geometry;
          for (var e2 = t4.readVarint() + t4.pos, r2 = 1, n2 = 0, i3 = 0, a2 = 0, s2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t4.pos < e2; ) {
            if (n2 <= 0) {
              var c2 = t4.readVarint();
              r2 = 7 & c2, n2 = c2 >> 3;
            }
            if (n2--, 1 === r2 || 2 === r2)
              (i3 += t4.readSVarint()) < s2 && (s2 = i3), i3 > o2 && (o2 = i3), (a2 += t4.readSVarint()) < l2 && (l2 = a2), a2 > u2 && (u2 = a2);
            else if (7 !== r2)
              throw new Error("unknown command " + r2);
          }
          return [s2, l2, o2, u2];
        }, No.prototype.toGeoJSON = function(t4, e2, r2) {
          var n2, i3, a2 = this.extent * Math.pow(2, r2), s2 = this.extent * t4, o2 = this.extent * e2, l2 = this.loadGeometry(), u2 = No.types[this.type];
          function c2(t5) {
            for (var e3 = 0; e3 < t5.length; e3++) {
              var r3 = t5[e3];
              t5[e3] = [360 * (r3.x + s2) / a2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / a2) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h2 = [];
              for (n2 = 0; n2 < l2.length; n2++)
                h2[n2] = l2[n2][0];
              c2(l2 = h2);
              break;
            case 2:
              for (n2 = 0; n2 < l2.length; n2++)
                c2(l2[n2]);
              break;
            case 3:
              for (l2 = function(t5) {
                var e3 = t5.length;
                if (e3 <= 1)
                  return [t5];
                for (var r3, n3, i4 = [], a3 = 0; a3 < e3; a3++) {
                  var s3 = Ko(t5[a3]);
                  0 !== s3 && (void 0 === n3 && (n3 = s3 < 0), n3 === s3 < 0 ? (r3 && i4.push(r3), r3 = [t5[a3]]) : r3.push(t5[a3]));
                }
                return r3 && i4.push(r3), i4;
              }(l2), n2 = 0; n2 < l2.length; n2++)
                for (i3 = 0; i3 < l2[n2].length; i3++)
                  c2(l2[n2][i3]);
          }
          1 === l2.length ? l2 = l2[0] : u2 = "Multi" + u2;
          var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
          return "id" in this && (p2.id = this.id), p2;
        };
        var Go = jo, Jo = Xo;
        function Xo(t4, e2) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t4, this._keys = [], this._values = [], this._features = [], t4.readFields(Yo, this, e2), this.length = this._features.length;
        }
        function Yo(t4, e2, r2) {
          15 === t4 ? e2.version = r2.readVarint() : 1 === t4 ? e2.name = r2.readString() : 5 === t4 ? e2.extent = r2.readVarint() : 2 === t4 ? e2._features.push(r2.pos) : 3 === t4 ? e2._keys.push(r2.readString()) : 4 === t4 && e2._values.push(function(t5) {
            for (var e3 = null, r3 = t5.readVarint() + t5.pos; t5.pos < r3; ) {
              var n2 = t5.readVarint() >> 3;
              e3 = 1 === n2 ? t5.readString() : 2 === n2 ? t5.readFloat() : 3 === n2 ? t5.readDouble() : 4 === n2 ? t5.readVarint64() : 5 === n2 ? t5.readVarint() : 6 === n2 ? t5.readSVarint() : 7 === n2 ? t5.readBoolean() : null;
            }
            return e3;
          }(r2));
        }
        Xo.prototype.feature = function(t4) {
          if (t4 < 0 || t4 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t4];
          var e2 = this._pbf.readVarint() + this._pbf.pos;
          return new Go(this._pbf, e2, this.extent, this._keys, this._values);
        };
        var Ho = Jo;
        function Wo(t4, e2, r2) {
          if (3 === t4) {
            var n2 = new Ho(r2, r2.readVarint() + r2.pos);
            n2.length && (e2[n2.name] = n2);
          }
        }
        Ro.VectorTile = function(t4, e2) {
          this.layers = t4.readFields(Wo, {}, e2);
        }, Ro.VectorTileFeature = jo, Ro.VectorTileLayer = Jo;
        const Qo = Ro.VectorTileFeature.types, tl = Math.pow(2, 13);
        function el(t4, e2, r2, n2, i3, a2, s2, o2) {
          t4.emplaceBack(e2, r2, 2 * Math.floor(n2 * tl) + s2, i3 * tl * 2, a2 * tl * 2, Math.round(o2));
        }
        class rl {
          constructor(t4) {
            this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.id), this.index = t4.index, this.hasPattern = false, this.layoutVertexArray = new da(), this.centroidVertexArray = new ha(), this.indexArray = new Aa(), this.programConfigurations = new Qa(t4.layers, t4.zoom), this.segments = new za(), this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id);
          }
          populate(t4, e2, r2) {
            this.features = [], this.hasPattern = Po("fill-extrusion", this.layers, e2);
            for (const { feature: n2, id: i3, index: a2, sourceLayerIndex: s2 } of t4) {
              const t5 = this.layers[0]._featureFilter.needGeometry, o2 = ss(n2, t5);
              if (!this.layers[0]._featureFilter.filter(new li(this.zoom), o2, r2))
                continue;
              const l2 = { id: i3, sourceLayerIndex: s2, index: a2, geometry: t5 ? o2.geometry : as(n2), properties: n2.properties, type: n2.type, patterns: {} };
              this.hasPattern ? this.features.push(Vo("fill-extrusion", this.layers, l2, this.zoom, e2)) : this.addFeature(l2, l2.geometry, a2, r2, {}), e2.featureIndex.insert(n2, l2.geometry, a2, s2, this.index, true);
            }
          }
          addFeatures(t4, e2, r2) {
            for (const t5 of this.features) {
              const { geometry: n2 } = t5;
              this.addFeature(t5, n2, t5.index, e2, r2);
            }
          }
          update(t4, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t4, e2, this.stateDependentLayers, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t4) {
            this.uploaded || (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, Uo), this.centroidVertexBuffer = t4.createVertexBuffer(this.centroidVertexArray, Oo.members, true), this.indexBuffer = t4.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t4), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t4, e2, r2, n2, i3) {
            const a2 = { x: 0, y: 0, vertexCount: 0 };
            for (const r3 of Co(e2, 500)) {
              let e3 = 0;
              for (const t5 of r3)
                e3 += t5.length;
              let n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
              for (const t5 of r3) {
                if (0 === t5.length)
                  continue;
                if (il(t5))
                  continue;
                let e4 = 0;
                for (let r4 = 0; r4 < t5.length; r4++) {
                  const i5 = t5[r4];
                  if (r4 >= 1) {
                    const s3 = t5[r4 - 1];
                    if (!nl(i5, s3)) {
                      n3.vertexLength + 4 > za.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                      const t6 = i5.sub(s3)._perp()._unit(), r5 = s3.dist(i5);
                      e4 + r5 > 32768 && (e4 = 0), el(this.layoutVertexArray, i5.x, i5.y, t6.x, t6.y, 0, 0, e4), el(this.layoutVertexArray, i5.x, i5.y, t6.x, t6.y, 0, 1, e4), a2.x += 2 * i5.x, a2.y += 2 * i5.y, a2.vertexCount += 2, e4 += r5, el(this.layoutVertexArray, s3.x, s3.y, t6.x, t6.y, 0, 0, e4), el(this.layoutVertexArray, s3.x, s3.y, t6.x, t6.y, 0, 1, e4), a2.x += 2 * s3.x, a2.y += 2 * s3.y, a2.vertexCount += 2;
                      const o3 = n3.vertexLength;
                      this.indexArray.emplaceBack(o3, o3 + 2, o3 + 1), this.indexArray.emplaceBack(o3 + 1, o3 + 2, o3 + 3), n3.vertexLength += 4, n3.primitiveLength += 2;
                    }
                  }
                }
              }
              if (n3.vertexLength + e3 > za.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray)), "Polygon" !== Qo[t4.type])
                continue;
              const i4 = [], s2 = [], o2 = n3.vertexLength;
              for (const t5 of r3)
                if (0 !== t5.length) {
                  t5 !== r3[0] && s2.push(i4.length / 2);
                  for (let e4 = 0; e4 < t5.length; e4++) {
                    const r4 = t5[e4];
                    el(this.layoutVertexArray, r4.x, r4.y, 0, 0, 1, 1, 0), a2.x += r4.x, a2.y += r4.y, a2.vertexCount += 1, i4.push(r4.x), i4.push(r4.y);
                  }
                }
              const l2 = So(i4, s2);
              for (let t5 = 0; t5 < l2.length; t5 += 3)
                this.indexArray.emplaceBack(o2 + l2[t5], o2 + l2[t5 + 2], o2 + l2[t5 + 1]);
              n3.primitiveLength += l2.length / 3, n3.vertexLength += e3;
            }
            for (let t5 = 0; t5 < a2.vertexCount; t5++)
              this.centroidVertexArray.emplaceBack(Math.floor(a2.x / a2.vertexCount), Math.floor(a2.y / a2.vertexCount));
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r2, i3, n2);
          }
        }
        function nl(t4, e2) {
          return t4.x === e2.x && (t4.x < 0 || t4.x > rs) || t4.y === e2.y && (t4.y < 0 || t4.y > rs);
        }
        function il(t4) {
          return t4.every((t5) => t5.x < 0) || t4.every((t5) => t5.x > rs) || t4.every((t5) => t5.y < 0) || t4.every((t5) => t5.y > rs);
        }
        let al;
        $n("FillExtrusionBucket", rl, { omit: ["layers", "features"] });
        var sl = { get paint() {
          return al = al || new _i({ "fill-extrusion-opacity": new gi(X["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new xi(X["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new gi(X["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new gi(X["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new vi(X["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new xi(X["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new xi(X["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new gi(X["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class ol extends Si {
          constructor(t4) {
            super(t4, sl);
          }
          createBucket(t4) {
            return new rl(t4);
          }
          queryRadius() {
            return ws(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature(t4, e2, r2, n2, i3, s2, o2, l2) {
            const u2 = _s(t4, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s2.angle, o2), c2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), h2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), p2 = function(t5, e3, r3, n3) {
              const i4 = [];
              for (const r4 of t5) {
                const t6 = [r4.x, r4.y, 0, 1];
                Vs(t6, t6, e3), i4.push(new a(t6[0] / t6[3], t6[1] / t6[3]));
              }
              return i4;
            }(u2, l2), f2 = function(t5, e3, r3, n3) {
              const i4 = [], s3 = [], o3 = n3[8] * e3, l3 = n3[9] * e3, u3 = n3[10] * e3, c3 = n3[11] * e3, h3 = n3[8] * r3, p3 = n3[9] * r3, f3 = n3[10] * r3, d2 = n3[11] * r3;
              for (const e4 of t5) {
                const t6 = [], r4 = [];
                for (const i5 of e4) {
                  const e5 = i5.x, s4 = i5.y, y2 = n3[0] * e5 + n3[4] * s4 + n3[12], m2 = n3[1] * e5 + n3[5] * s4 + n3[13], g2 = n3[2] * e5 + n3[6] * s4 + n3[14], x3 = n3[3] * e5 + n3[7] * s4 + n3[15], v2 = g2 + u3, b2 = x3 + c3, w2 = y2 + h3, _2 = m2 + p3, A3 = g2 + f3, S2 = x3 + d2, k2 = new a((y2 + o3) / b2, (m2 + l3) / b2);
                  k2.z = v2 / b2, t6.push(k2);
                  const I2 = new a(w2 / S2, _2 / S2);
                  I2.z = A3 / S2, r4.push(I2);
                }
                i4.push(t6), s3.push(r4);
              }
              return [i4, s3];
            }(n2, h2, c2, l2);
            return function(t5, e3, r3) {
              let n3 = 1 / 0;
              hs(r3, e3) && (n3 = ul(r3, e3[0]));
              for (let i4 = 0; i4 < e3.length; i4++) {
                const a2 = e3[i4], s3 = t5[i4];
                for (let t6 = 0; t6 < a2.length - 1; t6++) {
                  const e4 = a2[t6], i5 = [e4, a2[t6 + 1], s3[t6 + 1], s3[t6], e4];
                  us(r3, i5) && (n3 = Math.min(n3, ul(r3, i5)));
                }
              }
              return n3 !== 1 / 0 && n3;
            }(f2[0], f2[1], p2);
          }
        }
        function ll(t4, e2) {
          return t4.x * e2.x + t4.y * e2.y;
        }
        function ul(t4, e2) {
          if (1 === t4.length) {
            let r2 = 0;
            const n2 = e2[r2++];
            let i3;
            for (; !i3 || n2.equals(i3); )
              if (i3 = e2[r2++], !i3)
                return 1 / 0;
            for (; r2 < e2.length; r2++) {
              const a2 = e2[r2], s2 = t4[0], o2 = i3.sub(n2), l2 = a2.sub(n2), u2 = s2.sub(n2), c2 = ll(o2, o2), h2 = ll(o2, l2), p2 = ll(l2, l2), f2 = ll(u2, o2), d2 = ll(u2, l2), y2 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y2, g2 = (c2 * d2 - h2 * f2) / y2, x3 = n2.z * (1 - m2 - g2) + i3.z * m2 + a2.z * g2;
              if (isFinite(x3))
                return x3;
            }
            return 1 / 0;
          }
          {
            let t5 = 1 / 0;
            for (const r2 of e2)
              t5 = Math.min(t5, r2.z);
            return t5;
          }
        }
        const cl = Mi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: hl } = cl, pl = Mi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: fl2 } = pl, dl = Ro.VectorTileFeature.types, yl = Math.cos(Math.PI / 180 * 37.5), ml = Math.pow(2, 14) / 0.5;
        class gl2 {
          constructor(t4) {
            this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.id), this.index = t4.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t5) => {
              this.gradients[t5.id] = {};
            }), this.layoutVertexArray = new ya(), this.layoutVertexArray2 = new ma(), this.indexArray = new Aa(), this.programConfigurations = new Qa(t4.layers, t4.zoom), this.segments = new za(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id);
          }
          populate(t4, e2, r2) {
            this.hasPattern = Po("line", this.layers, e2);
            const n2 = this.layers[0].layout.get("line-sort-key"), i3 = !n2.isConstant(), a2 = [];
            for (const { feature: e3, id: s2, index: o2, sourceLayerIndex: l2 } of t4) {
              const t5 = this.layers[0]._featureFilter.needGeometry, u2 = ss(e3, t5);
              if (!this.layers[0]._featureFilter.filter(new li(this.zoom), u2, r2))
                continue;
              const c2 = i3 ? n2.evaluate(u2, {}, r2) : void 0, h2 = { id: s2, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o2, geometry: t5 ? u2.geometry : as(e3), patterns: {}, sortKey: c2 };
              a2.push(h2);
            }
            i3 && a2.sort((t5, e3) => t5.sortKey - e3.sortKey);
            for (const n3 of a2) {
              const { geometry: i4, index: a3, sourceLayerIndex: s2 } = n3;
              if (this.hasPattern) {
                const t5 = Vo("line", this.layers, n3, this.zoom, e2);
                this.patternFeatures.push(t5);
              } else
                this.addFeature(n3, i4, a3, r2, {});
              e2.featureIndex.insert(t4[a3].feature, i4, a3, s2, this.index);
            }
          }
          update(t4, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t4, e2, this.stateDependentLayers, r2);
          }
          addFeatures(t4, e2, r2) {
            for (const t5 of this.patternFeatures)
              this.addFeature(t5, t5.geometry, t5.index, e2, r2);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t4) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t4.createVertexBuffer(this.layoutVertexArray2, fl2)), this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, hl), this.indexBuffer = t4.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t4), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t4) {
            if (t4.properties && Object.prototype.hasOwnProperty.call(t4.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t4.properties, "mapbox_clip_end"))
              return { start: +t4.properties.mapbox_clip_start, end: +t4.properties.mapbox_clip_end };
          }
          addFeature(t4, e2, r2, n2, i3) {
            const a2 = this.layers[0].layout, s2 = a2.get("line-join").evaluate(t4, {}), o2 = a2.get("line-cap"), l2 = a2.get("line-miter-limit"), u2 = a2.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t4);
            for (const r3 of e2)
              this.addLine(r3, t4, s2, o2, l2, u2);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r2, i3, n2);
          }
          addLine(t4, e2, r2, n2, i3, a2) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e3 = 0; e3 < t4.length - 1; e3++)
                this.totalDistance += t4[e3].dist(t4[e3 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const s2 = "Polygon" === dl[e2.type];
            let o2 = t4.length;
            for (; o2 >= 2 && t4[o2 - 1].equals(t4[o2 - 2]); )
              o2--;
            let l2 = 0;
            for (; l2 < o2 - 1 && t4[l2].equals(t4[l2 + 1]); )
              l2++;
            if (o2 < (s2 ? 3 : 2))
              return;
            "bevel" === r2 && (i3 = 1.05);
            const u2 = this.overscaling <= 16 ? 15 * rs / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
            let h2, p2, f2, d2, y2;
            this.e1 = this.e2 = -1, s2 && (h2 = t4[o2 - 2], y2 = t4[l2].sub(h2)._unit()._perp());
            for (let e3 = l2; e3 < o2; e3++) {
              if (f2 = e3 === o2 - 1 ? s2 ? t4[l2 + 1] : void 0 : t4[e3 + 1], f2 && t4[e3].equals(f2))
                continue;
              y2 && (d2 = y2), h2 && (p2 = h2), h2 = t4[e3], y2 = f2 ? f2.sub(h2)._unit()._perp() : d2, d2 = d2 || y2;
              let m2 = d2.add(y2);
              0 === m2.x && 0 === m2.y || m2._unit();
              const g2 = d2.x * y2.x + d2.y * y2.y, x3 = m2.x * y2.x + m2.y * y2.y, v2 = 0 !== x3 ? 1 / x3 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x3), w2 = x3 < yl && p2 && f2, _2 = d2.x * y2.y - d2.y * y2.x > 0;
              if (w2 && e3 > l2) {
                const t5 = h2.dist(p2);
                if (t5 > 2 * u2) {
                  const e4 = h2.sub(h2.sub(p2)._mult(u2 / t5)._round());
                  this.updateDistance(p2, e4), this.addCurrentVertex(e4, d2, 0, 0, c2), p2 = e4;
                }
              }
              const A3 = p2 && f2;
              let S2 = A3 ? r2 : s2 ? "butt" : n2;
              if (A3 && "round" === S2 && (v2 < a2 ? S2 = "miter" : v2 <= 2 && (S2 = "fakeround")), "miter" === S2 && v2 > i3 && (S2 = "bevel"), "bevel" === S2 && (v2 > 2 && (S2 = "flipbevel"), v2 < i3 && (S2 = "miter")), p2 && this.updateDistance(p2, h2), "miter" === S2)
                m2._mult(v2), this.addCurrentVertex(h2, m2, 0, 0, c2);
              else if ("flipbevel" === S2) {
                if (v2 > 100)
                  m2 = y2.mult(-1);
                else {
                  const t5 = v2 * d2.add(y2).mag() / d2.sub(y2).mag();
                  m2._perp()._mult(t5 * (_2 ? -1 : 1));
                }
                this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
              } else if ("bevel" === S2 || "fakeround" === S2) {
                const t5 = -Math.sqrt(v2 * v2 - 1), e4 = _2 ? t5 : 0, r3 = _2 ? 0 : t5;
                if (p2 && this.addCurrentVertex(h2, d2, e4, r3, c2), "fakeround" === S2) {
                  const t6 = Math.round(180 * b2 / Math.PI / 20);
                  for (let e5 = 1; e5 < t6; e5++) {
                    let r4 = e5 / t6;
                    if (0.5 !== r4) {
                      const t7 = r4 - 0.5;
                      r4 += r4 * t7 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t7 * t7 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                    }
                    const n3 = y2.sub(d2)._mult(r4)._add(d2)._unit()._mult(_2 ? -1 : 1);
                    this.addHalfVertex(h2, n3.x, n3.y, false, _2, 0, c2);
                  }
                }
                f2 && this.addCurrentVertex(h2, y2, -e4, -r3, c2);
              } else if ("butt" === S2)
                this.addCurrentVertex(h2, m2, 0, 0, c2);
              else if ("square" === S2) {
                const t5 = p2 ? 1 : -1;
                this.addCurrentVertex(h2, m2, t5, t5, c2);
              } else
                "round" === S2 && (p2 && (this.addCurrentVertex(h2, d2, 0, 0, c2), this.addCurrentVertex(h2, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h2, y2, -1, -1, c2, true), this.addCurrentVertex(h2, y2, 0, 0, c2)));
              if (w2 && e3 < o2 - 1) {
                const t5 = h2.dist(f2);
                if (t5 > 2 * u2) {
                  const e4 = h2.add(f2.sub(h2)._mult(u2 / t5)._round());
                  this.updateDistance(h2, e4), this.addCurrentVertex(e4, y2, 0, 0, c2), h2 = e4;
                }
              }
            }
          }
          addCurrentVertex(t4, e2, r2, n2, i3, a2 = false) {
            const s2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
            this.addHalfVertex(t4, e2.x + e2.y * r2, e2.y - e2.x * r2, a2, false, r2, i3), this.addHalfVertex(t4, s2, o2, a2, true, -n2, i3), this.distance > ml / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t4, e2, r2, n2, i3, a2));
          }
          addHalfVertex({ x: t4, y: e2 }, r2, n2, i3, a2, s2, o2) {
            const l2 = 0.5 * (this.lineClips ? this.scaledDistance * (ml - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t4 << 1) + (i3 ? 1 : 0), (e2 << 1) + (a2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === s2 ? 0 : s2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const u2 = o2.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), a2 ? this.e2 = u2 : this.e1 = u2;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t4, e2) {
            this.distance += t4.dist(e2), this.updateScaledDistance();
          }
        }
        let xl, vl;
        $n("LineBucket", gl2, { omit: ["layers", "patternFeatures"] });
        var bl = { get paint() {
          return vl = vl || new _i({ "line-opacity": new xi(X.paint_line["line-opacity"]), "line-color": new xi(X.paint_line["line-color"]), "line-translate": new gi(X.paint_line["line-translate"]), "line-translate-anchor": new gi(X.paint_line["line-translate-anchor"]), "line-width": new xi(X.paint_line["line-width"]), "line-gap-width": new xi(X.paint_line["line-gap-width"]), "line-offset": new xi(X.paint_line["line-offset"]), "line-blur": new xi(X.paint_line["line-blur"]), "line-dasharray": new bi(X.paint_line["line-dasharray"]), "line-pattern": new vi(X.paint_line["line-pattern"]), "line-gradient": new wi(X.paint_line["line-gradient"]) });
        }, get layout() {
          return xl = xl || new _i({ "line-cap": new gi(X.layout_line["line-cap"]), "line-join": new xi(X.layout_line["line-join"]), "line-miter-limit": new gi(X.layout_line["line-miter-limit"]), "line-round-limit": new gi(X.layout_line["line-round-limit"]), "line-sort-key": new xi(X.layout_line["line-sort-key"]) });
        } };
        class wl extends xi {
          possiblyEvaluate(t4, e2) {
            return e2 = new li(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t4, e2);
          }
          evaluate(t4, e2, r2, n2) {
            return e2 = g({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t4, e2, r2, n2);
          }
        }
        let _l;
        class Al extends Si {
          constructor(t4) {
            super(t4, bl), this.gradientVersion = 0, _l || (_l = new wl(bl.paint.properties["line-width"].specification), _l.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(t4) {
            if ("line-gradient" === t4) {
              const t5 = this.gradientExpression();
              this.stepInterpolant = !!function(t6) {
                return void 0 !== t6._styleExpression;
              }(t5) && t5._styleExpression.expression instanceof qe, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t4, e2) {
            super.recalculate(t4, e2), this.paint._values["line-floorwidth"] = _l.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t4);
          }
          createBucket(t4) {
            return new gl2(t4);
          }
          queryRadius(t4) {
            const e2 = t4, r2 = Sl(bs("line-width", this, e2), bs("line-gap-width", this, e2)), n2 = bs("line-offset", this, e2);
            return r2 / 2 + Math.abs(n2) + ws(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t4, e2, r2, n2, i3, s2, o2) {
            const l2 = _s(t4, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, o2), u2 = o2 / 2 * Sl(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), c2 = this.paint.get("line-offset").evaluate(e2, r2);
            return c2 && (n2 = function(t5, e3) {
              const r3 = [];
              for (let n3 = 0; n3 < t5.length; n3++) {
                const i4 = t5[n3], s3 = [];
                for (let t6 = 0; t6 < i4.length; t6++) {
                  const r4 = i4[t6 - 1], n4 = i4[t6], o3 = i4[t6 + 1], l3 = 0 === t6 ? new a(0, 0) : n4.sub(r4)._unit()._perp(), u3 = t6 === i4.length - 1 ? new a(0, 0) : o3.sub(n4)._unit()._perp(), c3 = l3._add(u3)._unit(), h2 = c3.x * u3.x + c3.y * u3.y;
                  0 !== h2 && c3._mult(1 / h2), s3.push(c3._mult(e3)._add(n4));
                }
                r3.push(s3);
              }
              return r3;
            }(n2, c2 * o2)), function(t5, e3, r3) {
              for (let n3 = 0; n3 < e3.length; n3++) {
                const i4 = e3[n3];
                if (t5.length >= 3) {
                  for (let e4 = 0; e4 < i4.length; e4++)
                    if (xs(t5, i4[e4]))
                      return true;
                }
                if (ps(t5, i4, r3))
                  return true;
              }
              return false;
            }(l2, n2, u2);
          }
          isTileClipped() {
            return true;
          }
        }
        function Sl(t4, e2) {
          return e2 > 0 ? e2 + 2 * t4 : t4;
        }
        const kl = Mi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Il = Mi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Mi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const zl = Mi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
        Mi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Ml = Mi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Cl = Mi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function Bl(t4, e2, r2) {
          return t4.sections.forEach((t5) => {
            t5.text = function(t6, e3, r3) {
              const n2 = e3.layout.get("text-transform").evaluate(r3, {});
              return "uppercase" === n2 ? t6 = t6.toLocaleUpperCase() : "lowercase" === n2 && (t6 = t6.toLocaleLowerCase()), oi.applyArabicShaping && (t6 = oi.applyArabicShaping(t6)), t6;
            }(t5.text, e2, r2);
          }), t4;
        }
        Mi([{ name: "triangle", components: 3, type: "Uint16" }]), Mi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Mi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Mi([{ type: "Float32", name: "offsetX" }]), Mi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Mi([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const Pl = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
        var Vl = 24, El = $l, Fl = function(t4, e2, r2, n2, i3) {
          var a2, s2, o2 = 8 * i3 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h2 = r2 ? i3 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t4[e2 + h2];
          for (h2 += p2, a2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; a2 = 256 * a2 + t4[e2 + h2], h2 += p2, c2 -= 8)
            ;
          for (s2 = a2 & (1 << -c2) - 1, a2 >>= -c2, c2 += n2; c2 > 0; s2 = 256 * s2 + t4[e2 + h2], h2 += p2, c2 -= 8)
            ;
          if (0 === a2)
            a2 = 1 - u2;
          else {
            if (a2 === l2)
              return s2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
            s2 += Math.pow(2, n2), a2 -= u2;
          }
          return (f2 ? -1 : 1) * s2 * Math.pow(2, a2 - n2);
        }, Tl = function(t4, e2, r2, n2, i3, a2) {
          var s2, o2, l2, u2 = 8 * a2 - i3 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = 23 === i3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : a2 - 1, d2 = n2 ? 1 : -1, y2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
          for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, s2 = c2) : (s2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -s2)) < 1 && (s2--, l2 *= 2), (e2 += s2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (s2++, l2 /= 2), s2 + h2 >= c2 ? (o2 = 0, s2 = c2) : s2 + h2 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i3), s2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i3), s2 = 0)); i3 >= 8; t4[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i3 -= 8)
            ;
          for (s2 = s2 << i3 | o2, u2 += i3; u2 > 0; t4[r2 + f2] = 255 & s2, f2 += d2, s2 /= 256, u2 -= 8)
            ;
          t4[r2 + f2 - d2] |= 128 * y2;
        };
        function $l(t4) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t4) ? t4 : new Uint8Array(t4 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        $l.Varint = 0, $l.Fixed64 = 1, $l.Bytes = 2, $l.Fixed32 = 5;
        var Ll = 4294967296, Dl = 1 / Ll, Ol = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function Ul(t4) {
          return t4.type === $l.Bytes ? t4.readVarint() + t4.pos : t4.pos + 1;
        }
        function Rl(t4, e2, r2) {
          return r2 ? 4294967296 * e2 + (t4 >>> 0) : 4294967296 * (e2 >>> 0) + (t4 >>> 0);
        }
        function ql(t4, e2, r2) {
          var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
          r2.realloc(n2);
          for (var i3 = r2.pos - 1; i3 >= t4; i3--)
            r2.buf[i3 + n2] = r2.buf[i3];
        }
        function jl(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeVarint(t4[r2]);
        }
        function Nl(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeSVarint(t4[r2]);
        }
        function Zl(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeFloat(t4[r2]);
        }
        function Kl(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeDouble(t4[r2]);
        }
        function Gl(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeBoolean(t4[r2]);
        }
        function Jl(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeFixed32(t4[r2]);
        }
        function Xl(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeSFixed32(t4[r2]);
        }
        function Yl(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeFixed64(t4[r2]);
        }
        function Hl(t4, e2) {
          for (var r2 = 0; r2 < t4.length; r2++)
            e2.writeSFixed64(t4[r2]);
        }
        function Wl(t4, e2) {
          return (t4[e2] | t4[e2 + 1] << 8 | t4[e2 + 2] << 16) + 16777216 * t4[e2 + 3];
        }
        function Ql(t4, e2, r2) {
          t4[r2] = e2, t4[r2 + 1] = e2 >>> 8, t4[r2 + 2] = e2 >>> 16, t4[r2 + 3] = e2 >>> 24;
        }
        function tu(t4, e2) {
          return (t4[e2] | t4[e2 + 1] << 8 | t4[e2 + 2] << 16) + (t4[e2 + 3] << 24);
        }
        $l.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t4, e2, r2) {
          for (r2 = r2 || this.length; this.pos < r2; ) {
            var n2 = this.readVarint(), i3 = n2 >> 3, a2 = this.pos;
            this.type = 7 & n2, t4(i3, e2, this), this.pos === a2 && this.skip(n2);
          }
          return e2;
        }, readMessage: function(t4, e2) {
          return this.readFields(t4, e2, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t4 = Wl(this.buf, this.pos);
          return this.pos += 4, t4;
        }, readSFixed32: function() {
          var t4 = tu(this.buf, this.pos);
          return this.pos += 4, t4;
        }, readFixed64: function() {
          var t4 = Wl(this.buf, this.pos) + Wl(this.buf, this.pos + 4) * Ll;
          return this.pos += 8, t4;
        }, readSFixed64: function() {
          var t4 = Wl(this.buf, this.pos) + tu(this.buf, this.pos + 4) * Ll;
          return this.pos += 8, t4;
        }, readFloat: function() {
          var t4 = Fl(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t4;
        }, readDouble: function() {
          var t4 = Fl(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t4;
        }, readVarint: function(t4) {
          var e2, r2, n2 = this.buf;
          return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t5, e3, r3) {
            var n3, i3, a2 = r3.buf;
            if (n3 = (112 & (i3 = a2[r3.pos++])) >> 4, i3 < 128)
              return Rl(t5, n3, e3);
            if (n3 |= (127 & (i3 = a2[r3.pos++])) << 3, i3 < 128)
              return Rl(t5, n3, e3);
            if (n3 |= (127 & (i3 = a2[r3.pos++])) << 10, i3 < 128)
              return Rl(t5, n3, e3);
            if (n3 |= (127 & (i3 = a2[r3.pos++])) << 17, i3 < 128)
              return Rl(t5, n3, e3);
            if (n3 |= (127 & (i3 = a2[r3.pos++])) << 24, i3 < 128)
              return Rl(t5, n3, e3);
            if (n3 |= (1 & (i3 = a2[r3.pos++])) << 31, i3 < 128)
              return Rl(t5, n3, e3);
            throw new Error("Expected varint not more than 10 bytes");
          }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t4, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t4 = this.readVarint();
          return t4 % 2 == 1 ? (t4 + 1) / -2 : t4 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t4 = this.readVarint() + this.pos, e2 = this.pos;
          return this.pos = t4, t4 - e2 >= 12 && Ol ? function(t5, e3, r2) {
            return Ol.decode(t5.subarray(e3, r2));
          }(this.buf, e2, t4) : function(t5, e3, r2) {
            for (var n2 = "", i3 = e3; i3 < r2; ) {
              var a2, s2, o2, l2 = t5[i3], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
              if (i3 + c2 > r2)
                break;
              1 === c2 ? l2 < 128 && (u2 = l2) : 2 === c2 ? 128 == (192 & (a2 = t5[i3 + 1])) && (u2 = (31 & l2) << 6 | 63 & a2) <= 127 && (u2 = null) : 3 === c2 ? (s2 = t5[i3 + 2], 128 == (192 & (a2 = t5[i3 + 1])) && 128 == (192 & s2) && ((u2 = (15 & l2) << 12 | (63 & a2) << 6 | 63 & s2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : 4 === c2 && (s2 = t5[i3 + 2], o2 = t5[i3 + 3], 128 == (192 & (a2 = t5[i3 + 1])) && 128 == (192 & s2) && 128 == (192 & o2) && ((u2 = (15 & l2) << 18 | (63 & a2) << 12 | (63 & s2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), null === u2 ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i3 += c2;
            }
            return n2;
          }(this.buf, e2, t4);
        }, readBytes: function() {
          var t4 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t4);
          return this.pos = t4, e2;
        }, readPackedVarint: function(t4, e2) {
          if (this.type !== $l.Bytes)
            return t4.push(this.readVarint(e2));
          var r2 = Ul(this);
          for (t4 = t4 || []; this.pos < r2; )
            t4.push(this.readVarint(e2));
          return t4;
        }, readPackedSVarint: function(t4) {
          if (this.type !== $l.Bytes)
            return t4.push(this.readSVarint());
          var e2 = Ul(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readSVarint());
          return t4;
        }, readPackedBoolean: function(t4) {
          if (this.type !== $l.Bytes)
            return t4.push(this.readBoolean());
          var e2 = Ul(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readBoolean());
          return t4;
        }, readPackedFloat: function(t4) {
          if (this.type !== $l.Bytes)
            return t4.push(this.readFloat());
          var e2 = Ul(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readFloat());
          return t4;
        }, readPackedDouble: function(t4) {
          if (this.type !== $l.Bytes)
            return t4.push(this.readDouble());
          var e2 = Ul(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readDouble());
          return t4;
        }, readPackedFixed32: function(t4) {
          if (this.type !== $l.Bytes)
            return t4.push(this.readFixed32());
          var e2 = Ul(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readFixed32());
          return t4;
        }, readPackedSFixed32: function(t4) {
          if (this.type !== $l.Bytes)
            return t4.push(this.readSFixed32());
          var e2 = Ul(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readSFixed32());
          return t4;
        }, readPackedFixed64: function(t4) {
          if (this.type !== $l.Bytes)
            return t4.push(this.readFixed64());
          var e2 = Ul(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readFixed64());
          return t4;
        }, readPackedSFixed64: function(t4) {
          if (this.type !== $l.Bytes)
            return t4.push(this.readSFixed64());
          var e2 = Ul(this);
          for (t4 = t4 || []; this.pos < e2; )
            t4.push(this.readSFixed64());
          return t4;
        }, skip: function(t4) {
          var e2 = 7 & t4;
          if (e2 === $l.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (e2 === $l.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (e2 === $l.Fixed32)
            this.pos += 4;
          else {
            if (e2 !== $l.Fixed64)
              throw new Error("Unimplemented type: " + e2);
            this.pos += 8;
          }
        }, writeTag: function(t4, e2) {
          this.writeVarint(t4 << 3 | e2);
        }, realloc: function(t4) {
          for (var e2 = this.length || 16; e2 < this.pos + t4; )
            e2 *= 2;
          if (e2 !== this.length) {
            var r2 = new Uint8Array(e2);
            r2.set(this.buf), this.buf = r2, this.length = e2;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t4) {
          this.realloc(4), Ql(this.buf, t4, this.pos), this.pos += 4;
        }, writeSFixed32: function(t4) {
          this.realloc(4), Ql(this.buf, t4, this.pos), this.pos += 4;
        }, writeFixed64: function(t4) {
          this.realloc(8), Ql(this.buf, -1 & t4, this.pos), Ql(this.buf, Math.floor(t4 * Dl), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t4) {
          this.realloc(8), Ql(this.buf, -1 & t4, this.pos), Ql(this.buf, Math.floor(t4 * Dl), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t4) {
          (t4 = +t4 || 0) > 268435455 || t4 < 0 ? function(t5, e2) {
            var r2, n2;
            if (t5 >= 0 ? (r2 = t5 % 4294967296 | 0, n2 = t5 / 4294967296 | 0) : (n2 = ~(-t5 / 4294967296), 4294967295 ^ (r2 = ~(-t5 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t5 >= 18446744073709552e3 || t5 < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e2.realloc(10), function(t6, e3, r3) {
              r3.buf[r3.pos++] = 127 & t6 | 128, t6 >>>= 7, r3.buf[r3.pos++] = 127 & t6 | 128, t6 >>>= 7, r3.buf[r3.pos++] = 127 & t6 | 128, t6 >>>= 7, r3.buf[r3.pos++] = 127 & t6 | 128, r3.buf[r3.pos] = 127 & (t6 >>>= 7);
            }(r2, 0, e2), function(t6, e3) {
              var r3 = (7 & t6) << 4;
              e3.buf[e3.pos++] |= r3 | ((t6 >>>= 3) ? 128 : 0), t6 && (e3.buf[e3.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e3.buf[e3.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e3.buf[e3.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e3.buf[e3.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e3.buf[e3.pos++] = 127 & t6)))));
            }(n2, e2);
          }(t4, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t4 | (t4 > 127 ? 128 : 0), t4 <= 127 || (this.buf[this.pos++] = 127 & (t4 >>>= 7) | (t4 > 127 ? 128 : 0), t4 <= 127 || (this.buf[this.pos++] = 127 & (t4 >>>= 7) | (t4 > 127 ? 128 : 0), t4 <= 127 || (this.buf[this.pos++] = t4 >>> 7 & 127))));
        }, writeSVarint: function(t4) {
          this.writeVarint(t4 < 0 ? 2 * -t4 - 1 : 2 * t4);
        }, writeBoolean: function(t4) {
          this.writeVarint(Boolean(t4));
        }, writeString: function(t4) {
          t4 = String(t4), this.realloc(4 * t4.length), this.pos++;
          var e2 = this.pos;
          this.pos = function(t5, e3, r3) {
            for (var n2, i3, a2 = 0; a2 < e3.length; a2++) {
              if ((n2 = e3.charCodeAt(a2)) > 55295 && n2 < 57344) {
                if (!i3) {
                  n2 > 56319 || a2 + 1 === e3.length ? (t5[r3++] = 239, t5[r3++] = 191, t5[r3++] = 189) : i3 = n2;
                  continue;
                }
                if (n2 < 56320) {
                  t5[r3++] = 239, t5[r3++] = 191, t5[r3++] = 189, i3 = n2;
                  continue;
                }
                n2 = i3 - 55296 << 10 | n2 - 56320 | 65536, i3 = null;
              } else
                i3 && (t5[r3++] = 239, t5[r3++] = 191, t5[r3++] = 189, i3 = null);
              n2 < 128 ? t5[r3++] = n2 : (n2 < 2048 ? t5[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t5[r3++] = n2 >> 12 | 224 : (t5[r3++] = n2 >> 18 | 240, t5[r3++] = n2 >> 12 & 63 | 128), t5[r3++] = n2 >> 6 & 63 | 128), t5[r3++] = 63 & n2 | 128);
            }
            return r3;
          }(this.buf, t4, this.pos);
          var r2 = this.pos - e2;
          r2 >= 128 && ql(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
        }, writeFloat: function(t4) {
          this.realloc(4), Tl(this.buf, t4, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t4) {
          this.realloc(8), Tl(this.buf, t4, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t4) {
          var e2 = t4.length;
          this.writeVarint(e2), this.realloc(e2);
          for (var r2 = 0; r2 < e2; r2++)
            this.buf[this.pos++] = t4[r2];
        }, writeRawMessage: function(t4, e2) {
          this.pos++;
          var r2 = this.pos;
          t4(e2, this);
          var n2 = this.pos - r2;
          n2 >= 128 && ql(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
        }, writeMessage: function(t4, e2, r2) {
          this.writeTag(t4, $l.Bytes), this.writeRawMessage(e2, r2);
        }, writePackedVarint: function(t4, e2) {
          e2.length && this.writeMessage(t4, jl, e2);
        }, writePackedSVarint: function(t4, e2) {
          e2.length && this.writeMessage(t4, Nl, e2);
        }, writePackedBoolean: function(t4, e2) {
          e2.length && this.writeMessage(t4, Gl, e2);
        }, writePackedFloat: function(t4, e2) {
          e2.length && this.writeMessage(t4, Zl, e2);
        }, writePackedDouble: function(t4, e2) {
          e2.length && this.writeMessage(t4, Kl, e2);
        }, writePackedFixed32: function(t4, e2) {
          e2.length && this.writeMessage(t4, Jl, e2);
        }, writePackedSFixed32: function(t4, e2) {
          e2.length && this.writeMessage(t4, Xl, e2);
        }, writePackedFixed64: function(t4, e2) {
          e2.length && this.writeMessage(t4, Yl, e2);
        }, writePackedSFixed64: function(t4, e2) {
          e2.length && this.writeMessage(t4, Hl, e2);
        }, writeBytesField: function(t4, e2) {
          this.writeTag(t4, $l.Bytes), this.writeBytes(e2);
        }, writeFixed32Field: function(t4, e2) {
          this.writeTag(t4, $l.Fixed32), this.writeFixed32(e2);
        }, writeSFixed32Field: function(t4, e2) {
          this.writeTag(t4, $l.Fixed32), this.writeSFixed32(e2);
        }, writeFixed64Field: function(t4, e2) {
          this.writeTag(t4, $l.Fixed64), this.writeFixed64(e2);
        }, writeSFixed64Field: function(t4, e2) {
          this.writeTag(t4, $l.Fixed64), this.writeSFixed64(e2);
        }, writeVarintField: function(t4, e2) {
          this.writeTag(t4, $l.Varint), this.writeVarint(e2);
        }, writeSVarintField: function(t4, e2) {
          this.writeTag(t4, $l.Varint), this.writeSVarint(e2);
        }, writeStringField: function(t4, e2) {
          this.writeTag(t4, $l.Bytes), this.writeString(e2);
        }, writeFloatField: function(t4, e2) {
          this.writeTag(t4, $l.Fixed32), this.writeFloat(e2);
        }, writeDoubleField: function(t4, e2) {
          this.writeTag(t4, $l.Fixed64), this.writeDouble(e2);
        }, writeBooleanField: function(t4, e2) {
          this.writeVarintField(t4, Boolean(e2));
        } };
        var eu = r(El);
        const ru = 3;
        function nu(t4, e2, r2) {
          1 === t4 && r2.readMessage(iu, e2);
        }
        function iu(t4, e2, r2) {
          if (3 === t4) {
            const { id: t5, bitmap: n2, width: i3, height: a2, left: s2, top: o2, advance: l2 } = r2.readMessage(au, {});
            e2.push({ id: t5, bitmap: new Rs({ width: i3 + 2 * ru, height: a2 + 2 * ru }, n2), metrics: { width: i3, height: a2, left: s2, top: o2, advance: l2 } });
          }
        }
        function au(t4, e2, r2) {
          1 === t4 ? e2.id = r2.readVarint() : 2 === t4 ? e2.bitmap = r2.readBytes() : 3 === t4 ? e2.width = r2.readVarint() : 4 === t4 ? e2.height = r2.readVarint() : 5 === t4 ? e2.left = r2.readSVarint() : 6 === t4 ? e2.top = r2.readSVarint() : 7 === t4 && (e2.advance = r2.readVarint());
        }
        const su = ru;
        function ou(t4) {
          let e2 = 0, r2 = 0;
          for (const n3 of t4)
            e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
          t4.sort((t5, e3) => e3.h - t5.h);
          const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
          let i3 = 0, a2 = 0;
          for (const e3 of t4)
            for (let t5 = n2.length - 1; t5 >= 0; t5--) {
              const r3 = n2[t5];
              if (!(e3.w > r3.w || e3.h > r3.h)) {
                if (e3.x = r3.x, e3.y = r3.y, a2 = Math.max(a2, e3.y + e3.h), i3 = Math.max(i3, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                  const e4 = n2.pop();
                  t5 < n2.length && (n2[t5] = e4);
                } else
                  e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
                break;
              }
            }
          return { w: i3, h: a2, fill: e2 / (i3 * a2) || 0 };
        }
        const lu = 1;
        class uu {
          constructor(t4, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i3, content: a2 }) {
            this.paddedRect = t4, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i3, this.content = a2, this.version = r2;
          }
          get tl() {
            return [this.paddedRect.x + lu, this.paddedRect.y + lu];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - lu, this.paddedRect.y + this.paddedRect.h - lu];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * lu) / this.pixelRatio, (this.paddedRect.h - 2 * lu) / this.pixelRatio];
          }
        }
        class cu {
          constructor(t4, e2) {
            const r2 = {}, n2 = {};
            this.haveRenderCallbacks = [];
            const i3 = [];
            this.addImages(t4, r2, i3), this.addImages(e2, n2, i3);
            const { w: a2, h: s2 } = ou(i3), o2 = new qs({ width: a2 || 1, height: s2 || 1 });
            for (const e3 in t4) {
              const n3 = t4[e3], i4 = r2[e3].paddedRect;
              qs.copy(n3.data, o2, { x: 0, y: 0 }, { x: i4.x + lu, y: i4.y + lu }, n3.data);
            }
            for (const t5 in e2) {
              const r3 = e2[t5], i4 = n2[t5].paddedRect, a3 = i4.x + lu, s3 = i4.y + lu, l2 = r3.data.width, u2 = r3.data.height;
              qs.copy(r3.data, o2, { x: 0, y: 0 }, { x: a3, y: s3 }, r3.data), qs.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: a3, y: s3 - 1 }, { width: l2, height: 1 }), qs.copy(r3.data, o2, { x: 0, y: 0 }, { x: a3, y: s3 + u2 }, { width: l2, height: 1 }), qs.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: a3 - 1, y: s3 }, { width: 1, height: u2 }), qs.copy(r3.data, o2, { x: 0, y: 0 }, { x: a3 + l2, y: s3 }, { width: 1, height: u2 });
            }
            this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
          }
          addImages(t4, e2, r2) {
            for (const n2 in t4) {
              const i3 = t4[n2], a2 = { x: 0, y: 0, w: i3.data.width + 2 * lu, h: i3.data.height + 2 * lu };
              r2.push(a2), e2[n2] = new uu(a2, i3), i3.hasRenderCallback && this.haveRenderCallbacks.push(n2);
            }
          }
          patchUpdatedImages(t4, e2) {
            t4.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r2 in t4.updatedImages)
              this.patchUpdatedImage(this.iconPositions[r2], t4.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t4.getImage(r2), e2);
          }
          patchUpdatedImage(t4, e2, r2) {
            if (!t4 || !e2)
              return;
            if (t4.version === e2.version)
              return;
            t4.version = e2.version;
            const [n2, i3] = t4.tl;
            r2.update(e2.data, void 0, { x: n2, y: i3 });
          }
        }
        var hu;
        $n("ImagePosition", uu), $n("ImageAtlas", cu), t.ai = void 0, (hu = t.ai || (t.ai = {}))[hu.none = 0] = "none", hu[hu.horizontal = 1] = "horizontal", hu[hu.vertical = 2] = "vertical", hu[hu.horizontalOnly = 3] = "horizontalOnly";
        const pu = -17;
        class fu {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t4, e2) {
            const r2 = new fu();
            return r2.scale = t4 || 1, r2.fontStack = e2, r2;
          }
          static forImage(t4) {
            const e2 = new fu();
            return e2.imageName = t4, e2;
          }
        }
        class du {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t4, e2) {
            const r2 = new du();
            for (let n2 = 0; n2 < t4.sections.length; n2++) {
              const i3 = t4.sections[n2];
              i3.image ? r2.addImageSection(i3) : r2.addTextSection(i3, e2);
            }
            return r2;
          }
          length() {
            return this.text.length;
          }
          getSection(t4) {
            return this.sections[this.sectionIndex[t4]];
          }
          getSectionIndex(t4) {
            return this.sectionIndex[t4];
          }
          getCharCode(t4) {
            return this.text.charCodeAt(t4);
          }
          verticalizePunctuation() {
            this.text = function(t4) {
              let e2 = "";
              for (let r2 = 0; r2 < t4.length; r2++) {
                const n2 = t4.charCodeAt(r2 + 1) || null, i3 = t4.charCodeAt(r2 - 1) || null;
                e2 += n2 && Kn(n2) && !Pl[t4[r2 + 1]] || i3 && Kn(i3) && !Pl[t4[r2 - 1]] || !Pl[t4[r2]] ? t4[r2] : Pl[t4[r2]];
              }
              return e2;
            }(this.text);
          }
          trim() {
            let t4 = 0;
            for (let e3 = 0; e3 < this.text.length && mu[this.text.charCodeAt(e3)]; e3++)
              t4++;
            let e2 = this.text.length;
            for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t4 && mu[this.text.charCodeAt(r2)]; r2--)
              e2--;
            this.text = this.text.substring(t4, e2), this.sectionIndex = this.sectionIndex.slice(t4, e2);
          }
          substring(t4, e2) {
            const r2 = new du();
            return r2.text = this.text.substring(t4, e2), r2.sectionIndex = this.sectionIndex.slice(t4, e2), r2.sections = this.sections, r2;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t4, e2) => Math.max(t4, this.sections[e2].scale), 0);
          }
          addTextSection(t4, e2) {
            this.text += t4.text, this.sections.push(fu.forText(t4.scale, t4.fontStack || e2));
            const r2 = this.sections.length - 1;
            for (let e3 = 0; e3 < t4.text.length; ++e3)
              this.sectionIndex.push(r2);
          }
          addImageSection(t4) {
            const e2 = t4.image ? t4.image.name : "";
            if (0 === e2.length)
              return void A2("Can't add FormattedSection with an empty image.");
            const r2 = this.getNextImageSectionCharCode();
            r2 ? (this.text += String.fromCharCode(r2), this.sections.push(fu.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : A2("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function yu(e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2) {
          const g2 = du.fromFeature(e2, a2);
          let x3;
          p2 === t.ai.vertical && g2.verticalizePunctuation();
          const { processBidirectionalText: v2, processStyledBidirectionalText: b2 } = oi;
          if (v2 && 1 === g2.sections.length) {
            x3 = [];
            const t4 = v2(g2.toString(), Au(g2, c2, s2, r2, i3, d2, y2));
            for (const e3 of t4) {
              const t5 = new du();
              t5.text = e3, t5.sections = g2.sections;
              for (let r3 = 0; r3 < e3.length; r3++)
                t5.sectionIndex.push(0);
              x3.push(t5);
            }
          } else if (b2) {
            x3 = [];
            const t4 = b2(g2.text, g2.sectionIndex, Au(g2, c2, s2, r2, i3, d2, y2));
            for (const e3 of t4) {
              const t5 = new du();
              t5.text = e3[0], t5.sectionIndex = e3[1], t5.sections = g2.sections, x3.push(t5);
            }
          } else
            x3 = function(t4, e3) {
              const r3 = [], n3 = t4.text;
              let i4 = 0;
              for (const n4 of e3)
                r3.push(t4.substring(i4, n4)), i4 = n4;
              return i4 < n3.length && r3.push(t4.substring(i4, n3.length)), r3;
            }(g2, Au(g2, c2, s2, r2, i3, d2, y2));
          const w2 = [], _2 = { positionedLines: w2, text: g2.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p2, iconsInText: false, verticalizable: false };
          return function(e3, r3, n3, i4, a3, s3, o3, l3, u3, c3, h3, p3) {
            let f3 = 0, d3 = pu, y3 = 0, m3 = 0;
            const g3 = "right" === l3 ? 1 : "left" === l3 ? 0 : 0.5;
            let x4 = 0;
            for (const o4 of a3) {
              o4.trim();
              const a4 = o4.getMaxScale(), l4 = (a4 - 1) * Vl, b4 = { positionedGlyphs: [], lineOffset: 0 };
              e3.positionedLines[x4] = b4;
              const w4 = b4.positionedGlyphs;
              let _4 = 0;
              if (!o4.length()) {
                d3 += s3, ++x4;
                continue;
              }
              for (let s4 = 0; s4 < o4.length(); s4++) {
                const y4 = o4.getSection(s4), m4 = o4.getSectionIndex(s4), g4 = o4.getCharCode(s4);
                let x5 = 0, b5 = null, A4 = null, S2 = null, k2 = Vl;
                const I2 = !(u3 === t.ai.horizontal || !h3 && !Zn2(g4) || h3 && (mu[g4] || (v3 = g4, Rn.Arabic(v3) || Rn["Arabic Supplement"](v3) || Rn["Arabic Extended-A"](v3) || Rn["Arabic Presentation Forms-A"](v3) || Rn["Arabic Presentation Forms-B"](v3))));
                if (y4.imageName) {
                  const t4 = i4[y4.imageName];
                  if (!t4)
                    continue;
                  S2 = y4.imageName, e3.iconsInText = e3.iconsInText || true, A4 = t4.paddedRect;
                  const r4 = t4.displaySize;
                  y4.scale = y4.scale * Vl / p3, b5 = { width: r4[0], height: r4[1], left: lu, top: -su, advance: I2 ? r4[1] : r4[0] }, x5 = l4 + (Vl - r4[1] * y4.scale), k2 = b5.advance;
                  const n4 = I2 ? r4[0] * y4.scale - Vl * a4 : r4[1] * y4.scale - Vl * a4;
                  n4 > 0 && n4 > _4 && (_4 = n4);
                } else {
                  const t4 = n3[y4.fontStack], e4 = t4 && t4[g4];
                  if (e4 && e4.rect)
                    A4 = e4.rect, b5 = e4.metrics;
                  else {
                    const t5 = r3[y4.fontStack], e5 = t5 && t5[g4];
                    if (!e5)
                      continue;
                    b5 = e5.metrics;
                  }
                  x5 = (a4 - y4.scale) * Vl;
                }
                I2 ? (e3.verticalizable = true, w4.push({ glyph: g4, imageName: S2, x: f3, y: d3 + x5, vertical: I2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m4, metrics: b5, rect: A4 }), f3 += k2 * y4.scale + c3) : (w4.push({ glyph: g4, imageName: S2, x: f3, y: d3 + x5, vertical: I2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m4, metrics: b5, rect: A4 }), f3 += b5.advance * y4.scale + c3);
              }
              0 !== w4.length && (y3 = Math.max(f3 - c3, y3), ku(w4, 0, w4.length - 1, g3, _4)), f3 = 0;
              const A3 = s3 * a4 + _4;
              b4.lineOffset = Math.max(_4, l4), d3 += A3, m3 = Math.max(A3, m3), ++x4;
            }
            var v3;
            const b3 = d3 - pu, { horizontalAlign: w3, verticalAlign: _3 } = Su(o3);
            (function(t4, e4, r4, n4, i5, a4, s4, o4, l4) {
              const u4 = (e4 - r4) * i5;
              let c4 = 0;
              c4 = a4 !== s4 ? -o4 * n4 - pu : (-n4 * l4 + 0.5) * s4;
              for (const e5 of t4)
                for (const t5 of e5.positionedGlyphs)
                  t5.x += u4, t5.y += c4;
            })(e3.positionedLines, g3, w3, _3, y3, m3, s3, b3, a3.length), e3.top += -_3 * b3, e3.bottom = e3.top + b3, e3.left += -w3 * y3, e3.right = e3.left + y3;
          }(_2, r2, n2, i3, x3, o2, l2, u2, p2, c2, f2, m2), !function(t4) {
            for (const e3 of t4)
              if (0 !== e3.positionedGlyphs.length)
                return false;
            return true;
          }(w2) && _2;
        }
        const mu = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, gu = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
        function xu(t4, e2, r2, n2, i3, a2) {
          if (e2.imageName) {
            const t5 = n2[e2.imageName];
            return t5 ? t5.displaySize[0] * e2.scale * Vl / a2 + i3 : 0;
          }
          {
            const n3 = r2[e2.fontStack], a3 = n3 && n3[t4];
            return a3 ? a3.metrics.advance * e2.scale + i3 : 0;
          }
        }
        function vu(t4, e2, r2, n2) {
          const i3 = Math.pow(t4 - e2, 2);
          return n2 ? t4 < e2 ? i3 / 2 : 2 * i3 : i3 + Math.abs(r2) * r2;
        }
        function bu(t4, e2, r2) {
          let n2 = 0;
          return 10 === t4 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t4 && 65288 !== t4 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
        }
        function wu(t4, e2, r2, n2, i3, a2) {
          let s2 = null, o2 = vu(e2, r2, i3, a2);
          for (const t5 of n2) {
            const n3 = vu(e2 - t5.x, r2, i3, a2) + t5.badness;
            n3 <= o2 && (s2 = t5, o2 = n3);
          }
          return { index: t4, x: e2, priorBreak: s2, badness: o2 };
        }
        function _u(t4) {
          return t4 ? _u(t4.priorBreak).concat(t4.index) : [];
        }
        function Au(t4, e2, r2, n2, i3, a2, s2) {
          if ("point" !== a2)
            return [];
          if (!t4)
            return [];
          const o2 = [], l2 = function(t5, e3, r3, n3, i4, a3) {
            let s3 = 0;
            for (let r4 = 0; r4 < t5.length(); r4++) {
              const o3 = t5.getSection(r4);
              s3 += xu(t5.getCharCode(r4), o3, n3, i4, e3, a3);
            }
            return s3 / Math.max(1, Math.ceil(s3 / r3));
          }(t4, e2, r2, n2, i3, s2), u2 = t4.text.indexOf("​") >= 0;
          let c2 = 0;
          for (let r3 = 0; r3 < t4.length(); r3++) {
            const a3 = t4.getSection(r3), p2 = t4.getCharCode(r3);
            if (mu[p2] || (c2 += xu(p2, a3, n2, i3, e2, s2)), r3 < t4.length() - 1) {
              const e3 = !((h2 = p2) < 11904 || !(Rn["Bopomofo Extended"](h2) || Rn.Bopomofo(h2) || Rn["CJK Compatibility Forms"](h2) || Rn["CJK Compatibility Ideographs"](h2) || Rn["CJK Compatibility"](h2) || Rn["CJK Radicals Supplement"](h2) || Rn["CJK Strokes"](h2) || Rn["CJK Symbols and Punctuation"](h2) || Rn["CJK Unified Ideographs Extension A"](h2) || Rn["CJK Unified Ideographs"](h2) || Rn["Enclosed CJK Letters and Months"](h2) || Rn["Halfwidth and Fullwidth Forms"](h2) || Rn.Hiragana(h2) || Rn["Ideographic Description Characters"](h2) || Rn["Kangxi Radicals"](h2) || Rn["Katakana Phonetic Extensions"](h2) || Rn.Katakana(h2) || Rn["Vertical Forms"](h2) || Rn["Yi Radicals"](h2) || Rn["Yi Syllables"](h2)));
              (gu[p2] || e3 || a3.imageName) && o2.push(wu(r3 + 1, c2, l2, o2, bu(p2, t4.getCharCode(r3 + 1), e3 && u2), false));
            }
          }
          var h2;
          return _u(wu(t4.length(), c2, l2, o2, 0, true));
        }
        function Su(t4) {
          let e2 = 0.5, r2 = 0.5;
          switch (t4) {
            case "right":
            case "top-right":
            case "bottom-right":
              e2 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e2 = 0;
          }
          switch (t4) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r2 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r2 = 0;
          }
          return { horizontalAlign: e2, verticalAlign: r2 };
        }
        function ku(t4, e2, r2, n2, i3) {
          if (!n2 && !i3)
            return;
          const a2 = t4[r2], s2 = (t4[r2].x + a2.metrics.advance * a2.scale) * n2;
          for (let n3 = e2; n3 <= r2; n3++)
            t4[n3].x -= s2, t4[n3].y += i3;
        }
        function Iu(t4, e2, r2) {
          const { horizontalAlign: n2, verticalAlign: i3 } = Su(r2), a2 = e2[0] - t4.displaySize[0] * n2, s2 = e2[1] - t4.displaySize[1] * i3;
          return { image: t4, top: s2, bottom: s2 + t4.displaySize[1], left: a2, right: a2 + t4.displaySize[0] };
        }
        function zu(t4, e2, r2, n2, i3, a2) {
          const s2 = t4.image;
          let o2;
          if (s2.content) {
            const t5 = s2.content, e3 = s2.pixelRatio || 1;
            o2 = [t5[0] / e3, t5[1] / e3, s2.displaySize[0] - t5[2] / e3, s2.displaySize[1] - t5[3] / e3];
          }
          const l2 = e2.left * a2, u2 = e2.right * a2;
          let c2, h2, p2, f2;
          "width" === r2 || "both" === r2 ? (f2 = i3[0] + l2 - n2[3], h2 = i3[0] + u2 + n2[1]) : (f2 = i3[0] + (l2 + u2 - s2.displaySize[0]) / 2, h2 = f2 + s2.displaySize[0]);
          const d2 = e2.top * a2, y2 = e2.bottom * a2;
          return "height" === r2 || "both" === r2 ? (c2 = i3[1] + d2 - n2[0], p2 = i3[1] + y2 + n2[2]) : (c2 = i3[1] + (d2 + y2 - s2.displaySize[1]) / 2, p2 = c2 + s2.displaySize[1]), { image: s2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
        }
        const Mu = 255, Cu = 128, Bu = Mu * Cu;
        function Pu(t4, e2) {
          const { expression: r2 } = e2;
          if ("constant" === r2.kind)
            return { kind: "constant", layoutSize: r2.evaluate(new li(t4 + 1)) };
          if ("source" === r2.kind)
            return { kind: "source" };
          {
            const { zoomStops: e3, interpolationType: n2 } = r2;
            let i3 = 0;
            for (; i3 < e3.length && e3[i3] <= t4; )
              i3++;
            i3 = Math.max(0, i3 - 1);
            let a2 = i3;
            for (; a2 < e3.length && e3[a2] < t4 + 1; )
              a2++;
            a2 = Math.min(e3.length - 1, a2);
            const s2 = e3[i3], o2 = e3[a2];
            return "composite" === r2.kind ? { kind: "composite", minZoom: s2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: s2, maxZoom: o2, minSize: r2.evaluate(new li(s2)), maxSize: r2.evaluate(new li(o2)), interpolationType: n2 };
          }
        }
        function Vu(t4, e2, r2) {
          let n2 = "never";
          const i3 = t4.get(e2);
          return i3 ? n2 = i3 : t4.get(r2) && (n2 = "always"), n2;
        }
        const Eu = Ro.VectorTileFeature.types, Fu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Tu(t4, e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2, p2) {
          const f2 = o2 ? Math.min(Bu, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(Bu, Math.round(o2[1])) : 0;
          t4.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i3), a2, s2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
        }
        function $u(t4, e2, r2) {
          t4.emplaceBack(e2.x, e2.y, r2), t4.emplaceBack(e2.x, e2.y, r2), t4.emplaceBack(e2.x, e2.y, r2), t4.emplaceBack(e2.x, e2.y, r2);
        }
        function Lu(t4) {
          for (const e2 of t4.sections)
            if (Xn2(e2.text))
              return true;
          return false;
        }
        class Du {
          constructor(t4) {
            this.layoutVertexArray = new xa(), this.indexArray = new Aa(), this.programConfigurations = t4, this.segments = new za(), this.dynamicLayoutVertexArray = new va(), this.opacityVertexArray = new ba(), this.hasVisibleVertices = false, this.placedSymbolArray = new ra();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }
          upload(t4, e2, r2, n2) {
            this.isEmpty() || (r2 && (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, kl.members), this.indexBuffer = t4.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t4.createVertexBuffer(this.dynamicLayoutVertexArray, Il.members, true), this.opacityVertexBuffer = t4.createVertexBuffer(this.opacityVertexArray, Fu, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t4));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        $n("SymbolBuffers", Du);
        class Ou {
          constructor(t4, e2, r2) {
            this.layoutVertexArray = new t4(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new za(), this.collisionVertexArray = new _a2();
          }
          upload(t4) {
            this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t4.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t4.createVertexBuffer(this.collisionVertexArray, zl.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        $n("CollisionBuffers", Ou);
        class Uu {
          constructor(e2) {
            this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Ms([]), this.placementViewportMatrix = Ms([]);
            const r2 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Pu(this.zoom, r2["text-size"]), this.iconSizeData = Pu(this.zoom, r2["icon-size"]);
            const n2 = this.layers[0].layout, i3 = n2.get("symbol-sort-key"), a2 = n2.get("symbol-z-order");
            this.canOverlap = "never" !== Vu(n2, "text-overlap", "text-allow-overlap") || "never" !== Vu(n2, "icon-overlap", "icon-allow-overlap") || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== a2 && !i3.isConstant(), this.sortFeaturesByY = ("viewport-y" === a2 || "auto" === a2 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n2.get("symbol-placement") && (this.writingModes = n2.get("text-writing-mode").map((e3) => t.ai[e3])), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.sourceID = e2.sourceID;
          }
          createArrays() {
            this.text = new Du(new Qa(this.layers, this.zoom, (t4) => /^text/.test(t4))), this.icon = new Du(new Qa(this.layers, this.zoom, (t4) => /^icon/.test(t4))), this.glyphOffsetArray = new aa(), this.lineVertexArray = new sa(), this.symbolInstances = new ia(), this.textAnchorOffsets = new la();
          }
          calculateGlyphDependencies(t4, e2, r2, n2, i3) {
            for (let a2 = 0; a2 < t4.length; a2++)
              if (e2[t4.charCodeAt(a2)] = true, (r2 || n2) && i3) {
                const r3 = Pl[t4.charAt(a2)];
                r3 && (e2[r3.charCodeAt(0)] = true);
              }
          }
          populate(e2, r2, n2) {
            const i3 = this.layers[0], a2 = i3.layout, s2 = a2.get("text-font"), o2 = a2.get("text-field"), l2 = a2.get("icon-image"), u2 = ("constant" !== o2.value.kind || o2.value.value instanceof Qt && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && ("constant" !== s2.value.kind || s2.value.value.length > 0), c2 = "constant" !== l2.value.kind || !!l2.value.value || Object.keys(l2.parameters).length > 0, h2 = a2.get("symbol-sort-key");
            if (this.features = [], !u2 && !c2)
              return;
            const p2 = r2.iconDependencies, f2 = r2.glyphDependencies, d2 = r2.availableImages, y2 = new li(this.zoom);
            for (const { feature: r3, id: o3, index: l3, sourceLayerIndex: m2 } of e2) {
              const e3 = i3._featureFilter.needGeometry, g2 = ss(r3, e3);
              if (!i3._featureFilter.filter(y2, g2, n2))
                continue;
              let x3, v2;
              if (e3 || (g2.geometry = as(r3)), u2) {
                const t4 = i3.getValueAndResolveTokens("text-field", g2, n2, d2), e4 = Qt.factory(t4);
                Lu(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === ai() || this.hasRTLText && oi.isParsed()) && (x3 = Bl(e4, i3, g2));
              }
              if (c2) {
                const t4 = i3.getValueAndResolveTokens("icon-image", g2, n2, d2);
                v2 = t4 instanceof ne ? t4 : ne.fromString(t4);
              }
              if (!x3 && !v2)
                continue;
              const b2 = this.sortFeaturesByKey ? h2.evaluate(g2, {}, n2) : void 0;
              if (this.features.push({ id: o3, text: x3, icon: v2, index: l3, sourceLayerIndex: m2, geometry: g2.geometry, properties: r3.properties, type: Eu[r3.type], sortKey: b2 }), v2 && (p2[v2.name] = true), x3) {
                const e4 = s2.evaluate(g2, {}, n2).join(","), r4 = "viewport" !== a2.get("text-rotation-alignment") && "point" !== a2.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.ai.vertical) >= 0;
                for (const t4 of x3.sections)
                  if (t4.image)
                    p2[t4.image.name] = true;
                  else {
                    const n3 = qn(x3.toString()), i4 = t4.fontStack || e4, a3 = f2[i4] = f2[i4] || {};
                    this.calculateGlyphDependencies(t4.text, a3, r4, this.allowVerticalPlacement, n3);
                  }
              }
            }
            "line" === a2.get("symbol-placement") && (this.features = function(t4) {
              const e3 = {}, r3 = {}, n3 = [];
              let i4 = 0;
              function a3(e4) {
                n3.push(t4[e4]), i4++;
              }
              function s3(t5, e4, i5) {
                const a4 = r3[t5];
                return delete r3[t5], r3[e4] = a4, n3[a4].geometry[0].pop(), n3[a4].geometry[0] = n3[a4].geometry[0].concat(i5[0]), a4;
              }
              function o3(t5, r4, i5) {
                const a4 = e3[r4];
                return delete e3[r4], e3[t5] = a4, n3[a4].geometry[0].shift(), n3[a4].geometry[0] = i5[0].concat(n3[a4].geometry[0]), a4;
              }
              function l3(t5, e4, r4) {
                const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                return `${t5}:${n4.x}:${n4.y}`;
              }
              for (let u3 = 0; u3 < t4.length; u3++) {
                const c3 = t4[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                if (!p3) {
                  a3(u3);
                  continue;
                }
                const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
                if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                  const t5 = o3(f3, d3, h3), i5 = s3(f3, d3, n3[t5].geometry);
                  delete e3[f3], delete r3[d3], r3[l3(p3, n3[i5].geometry, true)] = i5, n3[t5].geometry = null;
                } else
                  f3 in r3 ? s3(f3, d3, h3) : d3 in e3 ? o3(f3, d3, h3) : (a3(u3), e3[f3] = i4 - 1, r3[d3] = i4 - 1);
              }
              return n3.filter((t5) => t5.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t4, e3) => t4.sortKey - e3.sortKey);
          }
          update(t4, e2, r2) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t4, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t4, e2, this.layers, r2));
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t4) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t4), this.iconCollisionBox.upload(t4)), this.text.upload(t4, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t4, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t4, e2) {
            const r2 = this.lineVertexArray.length;
            if (void 0 !== t4.segment) {
              let r3 = t4.dist(e2[t4.segment + 1]), n2 = t4.dist(e2[t4.segment]);
              const i3 = {};
              for (let n3 = t4.segment + 1; n3 < e2.length; n3++)
                i3[n3] = { x: e2[n3].x, y: e2[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e2.length - 1 && (r3 += e2[n3 + 1].dist(e2[n3]));
              for (let r4 = t4.segment || 0; r4 >= 0; r4--)
                i3[r4] = { x: e2[r4].x, y: e2[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e2[r4 - 1].dist(e2[r4]));
              for (let t5 = 0; t5 < e2.length; t5++) {
                const e3 = i3[t5];
                this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
          }
          addSymbols(e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2, p2) {
            const f2 = e2.indexArray, d2 = e2.layoutVertexArray, y2 = e2.segments.prepareSegment(4 * r2.length, d2, f2, this.canOverlap ? s2.sortKey : void 0), m2 = this.glyphOffsetArray.length, g2 = y2.vertexLength, x3 = this.allowVerticalPlacement && o2 === t.ai.vertical ? Math.PI / 2 : 0, v2 = s2.text && s2.text.sections;
            for (let t4 = 0; t4 < r2.length; t4++) {
              const { tl: i4, tr: a3, bl: o3, br: u3, tex: c3, pixelOffsetTL: h3, pixelOffsetBR: m3, minFontScaleX: g3, minFontScaleY: b2, glyphOffset: w2, isSDF: _2, sectionIndex: A3 } = r2[t4], S2 = y2.vertexLength, k2 = w2[1];
              Tu(d2, l2.x, l2.y, i4.x, k2 + i4.y, c3.x, c3.y, n2, _2, h3.x, h3.y, g3, b2), Tu(d2, l2.x, l2.y, a3.x, k2 + a3.y, c3.x + c3.w, c3.y, n2, _2, m3.x, h3.y, g3, b2), Tu(d2, l2.x, l2.y, o3.x, k2 + o3.y, c3.x, c3.y + c3.h, n2, _2, h3.x, m3.y, g3, b2), Tu(d2, l2.x, l2.y, u3.x, k2 + u3.y, c3.x + c3.w, c3.y + c3.h, n2, _2, m3.x, m3.y, g3, b2), $u(e2.dynamicLayoutVertexArray, l2, x3), f2.emplaceBack(S2, S2 + 1, S2 + 2), f2.emplaceBack(S2 + 1, S2 + 2, S2 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), t4 !== r2.length - 1 && A3 === r2[t4 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(d2.length, s2, s2.index, {}, p2, v2 && v2[A3]);
            }
            e2.placedSymbolArray.emplaceBack(l2.x, l2.y, m2, this.glyphOffsetArray.length - m2, g2, u2, c2, l2.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i3[0], i3[1], o2, 0, false, 0, h2);
          }
          _addCollisionDebugVertex(t4, e2, r2, n2, i3, a2) {
            return e2.emplaceBack(0, 0), t4.emplaceBack(r2.x, r2.y, n2, i3, Math.round(a2.x), Math.round(a2.y));
          }
          addCollisionDebugVertices(t4, e2, r2, n2, i3, s2, o2) {
            const l2 = i3.segments.prepareSegment(4, i3.layoutVertexArray, i3.indexArray), u2 = l2.vertexLength, c2 = i3.layoutVertexArray, h2 = i3.collisionVertexArray, p2 = o2.anchorX, f2 = o2.anchorY;
            this._addCollisionDebugVertex(c2, h2, s2, p2, f2, new a(t4, e2)), this._addCollisionDebugVertex(c2, h2, s2, p2, f2, new a(r2, e2)), this._addCollisionDebugVertex(c2, h2, s2, p2, f2, new a(r2, n2)), this._addCollisionDebugVertex(c2, h2, s2, p2, f2, new a(t4, n2)), l2.vertexLength += 4;
            const d2 = i3.indexArray;
            d2.emplaceBack(u2, u2 + 1), d2.emplaceBack(u2 + 1, u2 + 2), d2.emplaceBack(u2 + 2, u2 + 3), d2.emplaceBack(u2 + 3, u2), l2.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t4, e2, r2, n2) {
            for (let i3 = t4; i3 < e2; i3++) {
              const t5 = this.collisionBoxArray.get(i3);
              this.addCollisionDebugVertices(t5.x1, t5.y1, t5.x2, t5.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, t5.anchorPoint, r2);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Ou(wa, Ml.members, Sa), this.iconCollisionBox = new Ou(wa, Ml.members, Sa);
            for (let t4 = 0; t4 < this.symbolInstances.length; t4++) {
              const e2 = this.symbolInstances.get(t4);
              this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t4, e2, r2, n2, i3, a2, s2, o2, l2) {
            const u2 = {};
            for (let n3 = e2; n3 < r2; n3++) {
              const e3 = t4.get(n3);
              u2.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, anchorPointX: e3.anchorPointX, anchorPointY: e3.anchorPointY }, u2.textFeatureIndex = e3.featureIndex;
              break;
            }
            for (let e3 = n2; e3 < i3; e3++) {
              const r3 = t4.get(e3);
              u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalTextFeatureIndex = r3.featureIndex;
              break;
            }
            for (let e3 = a2; e3 < s2; e3++) {
              const r3 = t4.get(e3);
              u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.iconFeatureIndex = r3.featureIndex;
              break;
            }
            for (let e3 = o2; e3 < l2; e3++) {
              const r3 = t4.get(e3);
              u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalIconFeatureIndex = r3.featureIndex;
              break;
            }
            return u2;
          }
          deserializeCollisionBoxes(t4) {
            this.collisionArrays = [];
            for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
              const r2 = this.symbolInstances.get(e2);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t4, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t4, e2) {
            const r2 = t4.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
            for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4)
              t4.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t4.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
          }
          getSortedSymbolIndexes(t4) {
            if (this.sortedAngle === t4 && void 0 !== this.symbolInstanceIndexes)
              return this.symbolInstanceIndexes;
            const e2 = Math.sin(t4), r2 = Math.cos(t4), n2 = [], i3 = [], a2 = [];
            for (let t5 = 0; t5 < this.symbolInstances.length; ++t5) {
              a2.push(t5);
              const s2 = this.symbolInstances.get(t5);
              n2.push(0 | Math.round(e2 * s2.anchorX + r2 * s2.anchorY)), i3.push(s2.featureIndex);
            }
            return a2.sort((t5, e3) => n2[t5] - n2[e3] || i3[e3] - i3[t5]), a2;
          }
          addToSortKeyRanges(t4, e2) {
            const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t4 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t4, symbolInstanceEnd: t4 + 1 });
          }
          sortFeatures(t4) {
            if (this.sortFeaturesByY && this.sortedAngle !== t4 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t4), this.sortedAngle = t4, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t5 of this.symbolInstanceIndexes) {
                const e2 = this.symbolInstances.get(t5);
                this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t6, e3, r2) => {
                  t6 >= 0 && r2.indexOf(t6) === e3 && this.addIndicesForPlacedSymbol(this.text, t6);
                }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let Ru, qu;
        $n("SymbolBucket", Uu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Uu.MAX_GLYPHS = 65535, Uu.addDynamicAttributes = $u;
        var ju = { get paint() {
          return qu = qu || new _i({ "icon-opacity": new xi(X.paint_symbol["icon-opacity"]), "icon-color": new xi(X.paint_symbol["icon-color"]), "icon-halo-color": new xi(X.paint_symbol["icon-halo-color"]), "icon-halo-width": new xi(X.paint_symbol["icon-halo-width"]), "icon-halo-blur": new xi(X.paint_symbol["icon-halo-blur"]), "icon-translate": new gi(X.paint_symbol["icon-translate"]), "icon-translate-anchor": new gi(X.paint_symbol["icon-translate-anchor"]), "text-opacity": new xi(X.paint_symbol["text-opacity"]), "text-color": new xi(X.paint_symbol["text-color"], { runtimeType: yt, getOverride: (t4) => t4.textColor, hasOverride: (t4) => !!t4.textColor }), "text-halo-color": new xi(X.paint_symbol["text-halo-color"]), "text-halo-width": new xi(X.paint_symbol["text-halo-width"]), "text-halo-blur": new xi(X.paint_symbol["text-halo-blur"]), "text-translate": new gi(X.paint_symbol["text-translate"]), "text-translate-anchor": new gi(X.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return Ru = Ru || new _i({ "symbol-placement": new gi(X.layout_symbol["symbol-placement"]), "symbol-spacing": new gi(X.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new gi(X.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new xi(X.layout_symbol["symbol-sort-key"]), "symbol-z-order": new gi(X.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new gi(X.layout_symbol["icon-allow-overlap"]), "icon-overlap": new gi(X.layout_symbol["icon-overlap"]), "icon-ignore-placement": new gi(X.layout_symbol["icon-ignore-placement"]), "icon-optional": new gi(X.layout_symbol["icon-optional"]), "icon-rotation-alignment": new gi(X.layout_symbol["icon-rotation-alignment"]), "icon-size": new xi(X.layout_symbol["icon-size"]), "icon-text-fit": new gi(X.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new gi(X.layout_symbol["icon-text-fit-padding"]), "icon-image": new xi(X.layout_symbol["icon-image"]), "icon-rotate": new xi(X.layout_symbol["icon-rotate"]), "icon-padding": new xi(X.layout_symbol["icon-padding"]), "icon-keep-upright": new gi(X.layout_symbol["icon-keep-upright"]), "icon-offset": new xi(X.layout_symbol["icon-offset"]), "icon-anchor": new xi(X.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new gi(X.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new gi(X.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new gi(X.layout_symbol["text-rotation-alignment"]), "text-field": new xi(X.layout_symbol["text-field"]), "text-font": new xi(X.layout_symbol["text-font"]), "text-size": new xi(X.layout_symbol["text-size"]), "text-max-width": new xi(X.layout_symbol["text-max-width"]), "text-line-height": new gi(X.layout_symbol["text-line-height"]), "text-letter-spacing": new xi(X.layout_symbol["text-letter-spacing"]), "text-justify": new xi(X.layout_symbol["text-justify"]), "text-radial-offset": new xi(X.layout_symbol["text-radial-offset"]), "text-variable-anchor": new gi(X.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new xi(X.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new xi(X.layout_symbol["text-anchor"]), "text-max-angle": new gi(X.layout_symbol["text-max-angle"]), "text-writing-mode": new gi(X.layout_symbol["text-writing-mode"]), "text-rotate": new xi(X.layout_symbol["text-rotate"]), "text-padding": new gi(X.layout_symbol["text-padding"]), "text-keep-upright": new gi(X.layout_symbol["text-keep-upright"]), "text-transform": new xi(X.layout_symbol["text-transform"]), "text-offset": new xi(X.layout_symbol["text-offset"]), "text-allow-overlap": new gi(X.layout_symbol["text-allow-overlap"]), "text-overlap": new gi(X.layout_symbol["text-overlap"]), "text-ignore-placement": new gi(X.layout_symbol["text-ignore-placement"]), "text-optional": new gi(X.layout_symbol["text-optional"]) });
        } };
        class Nu {
          constructor(t4) {
            if (void 0 === t4.property.overrides)
              throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t4.property.overrides ? t4.property.overrides.runtimeType : ht, this.defaultValue = t4;
          }
          evaluate(t4) {
            if (t4.formattedSection) {
              const e2 = this.defaultValue.property.overrides;
              if (e2 && e2.hasOverride(t4.formattedSection))
                return e2.getOverride(t4.formattedSection);
            }
            return t4.feature && t4.featureState ? this.defaultValue.evaluate(t4.feature, t4.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t4) {
            this.defaultValue.isConstant() || t4(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        $n("FormatSectionOverride", Nu, { omit: ["defaultValue"] });
        class Zu extends Si {
          constructor(t4) {
            super(t4, ju);
          }
          recalculate(t4, e2) {
            if (super.recalculate(t4, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
              const t5 = this.layout.get("text-writing-mode");
              if (t5) {
                const e3 = [];
                for (const r2 of t5)
                  e3.indexOf(r2) < 0 && e3.push(r2);
                this.layout._values["text-writing-mode"] = e3;
              } else
                this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t4, e2, r2, n2) {
            const i3 = this.layout.get(t4).evaluate(e2, {}, r2, n2), a2 = this._unevaluatedLayout._values[t4];
            return a2.isDataDriven() || Tr(a2.value) || !i3 ? i3 : function(t5, e3) {
              return e3.replace(/{([^{}]+)}/g, (e4, r3) => t5 && r3 in t5 ? String(t5[r3]) : "");
            }(e2.properties, i3);
          }
          createBucket(t4) {
            return new Uu(t4);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t4 of ju.paint.overridableProperties) {
              if (!Zu.hasPaintOverride(this.layout, t4))
                continue;
              const e2 = this.paint.get(t4), r2 = new Nu(e2), n2 = new Fr(r2, e2.property.specification);
              let i3 = null;
              i3 = "constant" === e2.value.kind || "source" === e2.value.kind ? new Lr("source", n2) : new Dr("composite", n2, e2.value.zoomStops), this.paint._values[t4] = new yi(e2.property, i3, e2.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t4, e2, r2) {
            return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && Zu.hasPaintOverride(this.layout, t4);
          }
          static hasPaintOverride(t4, e2) {
            const r2 = t4.get("text-field"), n2 = ju.paint.properties[e2];
            let i3 = false;
            const a2 = (t5) => {
              for (const e3 of t5)
                if (n2.overrides && n2.overrides.hasOverride(e3))
                  return void (i3 = true);
            };
            if ("constant" === r2.value.kind && r2.value.value instanceof Qt)
              a2(r2.value.value.sections);
            else if ("source" === r2.value.kind) {
              const t5 = (e4) => {
                i3 || (e4 instanceof le && se(e4.value) === vt ? a2(e4.value.sections) : e4 instanceof pr ? a2(e4.sections) : e4.eachChild(t5));
              }, e3 = r2.value;
              e3._styleExpression && t5(e3._styleExpression.expression);
            }
            return i3;
          }
        }
        let Ku;
        var Gu = { get paint() {
          return Ku = Ku || new _i({ "background-color": new gi(X.paint_background["background-color"]), "background-pattern": new bi(X.paint_background["background-pattern"]), "background-opacity": new gi(X.paint_background["background-opacity"]) });
        } };
        class Ju extends Si {
          constructor(t4) {
            super(t4, Gu);
          }
        }
        let Xu;
        var Yu = { get paint() {
          return Xu = Xu || new _i({ "raster-opacity": new gi(X.paint_raster["raster-opacity"]), "raster-hue-rotate": new gi(X.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new gi(X.paint_raster["raster-brightness-min"]), "raster-brightness-max": new gi(X.paint_raster["raster-brightness-max"]), "raster-saturation": new gi(X.paint_raster["raster-saturation"]), "raster-contrast": new gi(X.paint_raster["raster-contrast"]), "raster-resampling": new gi(X.paint_raster["raster-resampling"]), "raster-fade-duration": new gi(X.paint_raster["raster-fade-duration"]) });
        } };
        class Hu extends Si {
          constructor(t4) {
            super(t4, Yu);
          }
        }
        class Wu extends Si {
          constructor(t4) {
            super(t4, {}), this.onAdd = (t5) => {
              this.implementation.onAdd && this.implementation.onAdd(t5, t5.painter.context.gl);
            }, this.onRemove = (t5) => {
              this.implementation.onRemove && this.implementation.onRemove(t5, t5.painter.context.gl);
            }, this.implementation = t4;
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class Qu {
          constructor(t4) {
            this._callback = t4, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._callback();
            }, 0));
          }
          remove() {
            delete this._channel, this._callback = () => {
            };
          }
        }
        const tc = 63710088e-1;
        class ec2 {
          constructor(t4, e2) {
            if (isNaN(t4) || isNaN(e2))
              throw new Error(`Invalid LngLat object: (${t4}, ${e2})`);
            if (this.lng = +t4, this.lat = +e2, this.lat > 90 || this.lat < -90)
              throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new ec2(m(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t4) {
            const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t4.lat * e2, i3 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t4.lng - this.lng) * e2);
            return tc * Math.acos(Math.min(i3, 1));
          }
          static convert(t4) {
            if (t4 instanceof ec2)
              return t4;
            if (Array.isArray(t4) && (2 === t4.length || 3 === t4.length))
              return new ec2(Number(t4[0]), Number(t4[1]));
            if (!Array.isArray(t4) && "object" == typeof t4 && null !== t4)
              return new ec2(Number("lng" in t4 ? t4.lng : t4.lon), Number(t4.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const rc = 2 * Math.PI * tc;
        function nc(t4) {
          return rc * Math.cos(t4 * Math.PI / 180);
        }
        function ic(t4) {
          return (180 + t4) / 360;
        }
        function ac(t4) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t4 * Math.PI / 360))) / 360;
        }
        function sc(t4, e2) {
          return t4 / nc(e2);
        }
        function oc(t4) {
          return 360 * t4 - 180;
        }
        function lc(t4) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t4) * Math.PI / 180)) - 90;
        }
        class uc {
          constructor(t4, e2, r2 = 0) {
            this.x = +t4, this.y = +e2, this.z = +r2;
          }
          static fromLngLat(t4, e2 = 0) {
            const r2 = ec2.convert(t4);
            return new uc(ic(r2.lng), ac(r2.lat), sc(e2, r2.lat));
          }
          toLngLat() {
            return new ec2(oc(this.x), lc(this.y));
          }
          toAltitude() {
            return this.z * nc(lc(this.y));
          }
          meterInMercatorCoordinateUnits() {
            return 1 / rc * (t4 = lc(this.y), 1 / Math.cos(t4 * Math.PI / 180));
            var t4;
          }
        }
        function cc(t4, e2, r2) {
          var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
          return [t4 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
        }
        class hc {
          constructor(t4, e2, r2) {
            if (t4 < 0 || t4 > 25 || r2 < 0 || r2 >= Math.pow(2, t4) || e2 < 0 || e2 >= Math.pow(2, t4))
              throw new Error(`x=${e2}, y=${r2}, z=${t4} outside of bounds. 0<=x<${Math.pow(2, t4)}, 0<=y<${Math.pow(2, t4)} 0<=z<=25 `);
            this.z = t4, this.x = e2, this.y = r2, this.key = dc(0, t4, t4, e2, r2);
          }
          equals(t4) {
            return this.z === t4.z && this.x === t4.x && this.y === t4.y;
          }
          url(t4, e2, r2) {
            const n2 = (a2 = this.y, s2 = this.z, o2 = cc(256 * (i3 = this.x), 256 * (a2 = Math.pow(2, s2) - a2 - 1), s2), l2 = cc(256 * (i3 + 1), 256 * (a2 + 1), s2), o2[0] + "," + o2[1] + "," + l2[0] + "," + l2[1]);
            var i3, a2, s2, o2, l2;
            const u2 = function(t5, e3, r3) {
              let n3, i4 = "";
              for (let a3 = t5; a3 > 0; a3--)
                n3 = 1 << a3 - 1, i4 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
              return i4;
            }(this.z, this.x, this.y);
            return t4[(this.x + this.y) % t4.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e2 > 1 ? "@2x" : "").replace(/{quadkey}/g, u2).replace(/{bbox-epsg-3857}/g, n2);
          }
          isChildOf(t4) {
            const e2 = this.z - t4.z;
            return e2 > 0 && t4.x === this.x >> e2 && t4.y === this.y >> e2;
          }
          getTilePoint(t4) {
            const e2 = Math.pow(2, this.z);
            return new a((t4.x * e2 - this.x) * rs, (t4.y * e2 - this.y) * rs);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class pc {
          constructor(t4, e2) {
            this.wrap = t4, this.canonical = e2, this.key = dc(t4, e2.z, e2.z, e2.x, e2.y);
          }
        }
        class fc {
          constructor(t4, e2, r2, n2, i3) {
            if (t4 < r2)
              throw new Error(`overscaledZ should be >= z; overscaledZ = ${t4}; z = ${r2}`);
            this.overscaledZ = t4, this.wrap = e2, this.canonical = new hc(r2, +n2, +i3), this.key = dc(e2, t4, r2, n2, i3);
          }
          clone() {
            return new fc(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t4) {
            return this.overscaledZ === t4.overscaledZ && this.wrap === t4.wrap && this.canonical.equals(t4.canonical);
          }
          scaledTo(t4) {
            if (t4 > this.overscaledZ)
              throw new Error(`targetZ > this.overscaledZ; targetZ = ${t4}; overscaledZ = ${this.overscaledZ}`);
            const e2 = this.canonical.z - t4;
            return t4 > this.canonical.z ? new fc(t4, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new fc(t4, this.wrap, t4, this.canonical.x >> e2, this.canonical.y >> e2);
          }
          calculateScaledKey(t4, e2) {
            if (t4 > this.overscaledZ)
              throw new Error(`targetZ > this.overscaledZ; targetZ = ${t4}; overscaledZ = ${this.overscaledZ}`);
            const r2 = this.canonical.z - t4;
            return t4 > this.canonical.z ? dc(this.wrap * +e2, t4, this.canonical.z, this.canonical.x, this.canonical.y) : dc(this.wrap * +e2, t4, t4, this.canonical.x >> r2, this.canonical.y >> r2);
          }
          isChildOf(t4) {
            if (t4.wrap !== this.wrap)
              return false;
            const e2 = this.canonical.z - t4.canonical.z;
            return 0 === t4.overscaledZ || t4.overscaledZ < this.overscaledZ && t4.canonical.x === this.canonical.x >> e2 && t4.canonical.y === this.canonical.y >> e2;
          }
          children(t4) {
            if (this.overscaledZ >= t4)
              return [new fc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
            return [new fc(e2, this.wrap, e2, r2, n2), new fc(e2, this.wrap, e2, r2 + 1, n2), new fc(e2, this.wrap, e2, r2, n2 + 1), new fc(e2, this.wrap, e2, r2 + 1, n2 + 1)];
          }
          isLessThan(t4) {
            return this.wrap < t4.wrap || !(this.wrap > t4.wrap) && (this.overscaledZ < t4.overscaledZ || !(this.overscaledZ > t4.overscaledZ) && (this.canonical.x < t4.canonical.x || !(this.canonical.x > t4.canonical.x) && this.canonical.y < t4.canonical.y));
          }
          wrapped() {
            return new fc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t4) {
            return new fc(this.overscaledZ, t4, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new pc(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t4) {
            return this.canonical.getTilePoint(new uc(t4.x - this.wrap, t4.y));
          }
        }
        function dc(t4, e2, r2, n2, i3) {
          (t4 *= 2) < 0 && (t4 = -1 * t4 - 1);
          const a2 = 1 << r2;
          return (a2 * a2 * t4 + a2 * i3 + n2).toString(36) + r2.toString(36) + e2.toString(36);
        }
        $n("CanonicalTileID", hc), $n("OverscaledTileID", fc, { omit: ["posMatrix"] });
        class yc {
          constructor(t4, e2, r2, n2 = 1, i3 = 1, a2 = 1, s2 = 0) {
            if (this.uid = t4, e2.height !== e2.width)
              throw new RangeError("DEM tiles must be square");
            if (r2 && !["mapbox", "terrarium", "custom"].includes(r2))
              return void A2(`"${r2}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = e2.height;
            const o2 = this.dim = e2.height - 2;
            switch (this.data = new Uint32Array(e2.data.buffer), r2) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = n2, this.greenFactor = i3, this.blueFactor = a2, this.baseShift = s2;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let t5 = 0; t5 < o2; t5++)
              this.data[this._idx(-1, t5)] = this.data[this._idx(0, t5)], this.data[this._idx(o2, t5)] = this.data[this._idx(o2 - 1, t5)], this.data[this._idx(t5, -1)] = this.data[this._idx(t5, 0)], this.data[this._idx(t5, o2)] = this.data[this._idx(t5, o2 - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o2, -1)] = this.data[this._idx(o2 - 1, 0)], this.data[this._idx(-1, o2)] = this.data[this._idx(0, o2 - 1)], this.data[this._idx(o2, o2)] = this.data[this._idx(o2 - 1, o2 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let t5 = 0; t5 < o2; t5++)
              for (let e3 = 0; e3 < o2; e3++) {
                const r3 = this.get(t5, e3);
                r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
              }
          }
          get(t4, e2) {
            const r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t4, e2);
            return this.unpack(r2[n2], r2[n2 + 1], r2[n2 + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t4, e2) {
            if (t4 < -1 || t4 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
              throw new RangeError("out of range source coordinates for DEM data");
            return (e2 + 1) * this.stride + (t4 + 1);
          }
          unpack(t4, e2, r2) {
            return t4 * this.redFactor + e2 * this.greenFactor + r2 * this.blueFactor - this.baseShift;
          }
          getPixels() {
            return new qs({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t4, e2, r2) {
            if (this.dim !== t4.dim)
              throw new Error("dem dimension mismatch");
            let n2 = e2 * this.dim, i3 = e2 * this.dim + this.dim, a2 = r2 * this.dim, s2 = r2 * this.dim + this.dim;
            switch (e2) {
              case -1:
                n2 = i3 - 1;
                break;
              case 1:
                i3 = n2 + 1;
            }
            switch (r2) {
              case -1:
                a2 = s2 - 1;
                break;
              case 1:
                s2 = a2 + 1;
            }
            const o2 = -e2 * this.dim, l2 = -r2 * this.dim;
            for (let e3 = a2; e3 < s2; e3++)
              for (let r3 = n2; r3 < i3; r3++)
                this.data[this._idx(r3, e3)] = t4.data[this._idx(r3 + o2, e3 + l2)];
          }
        }
        $n("DEMData", yc);
        class mc {
          constructor(t4) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e2 = 0; e2 < t4.length; e2++) {
              const r2 = t4[e2];
              this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
            }
          }
          encode(t4) {
            return this._stringToNumber[t4];
          }
          decode(t4) {
            if (t4 >= this._numberToString.length)
              throw new Error(`Out of bounds. Index requested n=${t4} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t4];
          }
        }
        class gc {
          constructor(t4, e2, r2, n2, i3) {
            this.type = "Feature", this._vectorTileFeature = t4, t4._z = e2, t4._x = r2, t4._y = n2, this.properties = t4.properties, this.id = i3;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t4) {
            this._geometry = t4;
          }
          toJSON() {
            const t4 = { geometry: this.geometry };
            for (const e2 in this)
              "_geometry" !== e2 && "_vectorTileFeature" !== e2 && (t4[e2] = this[e2]);
            return t4;
          }
        }
        class xc {
          constructor(t4, e2) {
            this.tileID = t4, this.x = t4.canonical.x, this.y = t4.canonical.y, this.z = t4.canonical.z, this.grid = new Fn(rs, 16, 0), this.grid3D = new Fn(rs, 16, 0), this.featureIndexArray = new ca(), this.promoteId = e2;
          }
          insert(t4, e2, r2, n2, i3, a2) {
            const s2 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r2, n2, i3);
            const o2 = a2 ? this.grid3D : this.grid;
            for (let t5 = 0; t5 < e2.length; t5++) {
              const r3 = e2[t5], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t6 = 0; t6 < r3.length; t6++) {
                const e3 = r3[t6];
                n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
              }
              n3[0] < rs && n3[1] < rs && n3[2] >= 0 && n3[3] >= 0 && o2.insert(s2, n3[0], n3[1], n3[2], n3[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new Ro.VectorTile(new eu(this.rawTileData)).layers, this.sourceLayerCoder = new mc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t4, e2, r2, n2) {
            this.loadVTLayers();
            const i3 = t4.params || {}, s2 = rs / t4.tileSize / t4.scale, o2 = Nr(i3.filter), l2 = t4.queryGeometry, u2 = t4.queryPadding * s2, c2 = bc(l2), h2 = this.grid.query(c2.minX - u2, c2.minY - u2, c2.maxX + u2, c2.maxY + u2), p2 = bc(t4.cameraQueryGeometry), f2 = this.grid3D.query(p2.minX - u2, p2.minY - u2, p2.maxX + u2, p2.maxY + u2, (e3, r3, n3, i4) => function(t5, e4, r4, n4, i5) {
              for (const a2 of t5)
                if (e4 <= a2.x && r4 <= a2.y && n4 >= a2.x && i5 >= a2.y)
                  return true;
              const s3 = [new a(e4, r4), new a(e4, i5), new a(n4, i5), new a(n4, r4)];
              if (t5.length > 2) {
                for (const e5 of s3)
                  if (xs(t5, e5))
                    return true;
              }
              for (let e5 = 0; e5 < t5.length - 1; e5++)
                if (vs(t5[e5], t5[e5 + 1], s3))
                  return true;
              return false;
            }(t4.cameraQueryGeometry, e3 - u2, r3 - u2, n3 + u2, i4 + u2));
            for (const t5 of f2)
              h2.push(t5);
            h2.sort(wc);
            const d2 = {};
            let y2;
            for (let a2 = 0; a2 < h2.length; a2++) {
              const u3 = h2[a2];
              if (u3 === y2)
                continue;
              y2 = u3;
              const c3 = this.featureIndexArray.get(u3);
              let p3 = null;
              this.loadMatchingFeature(d2, c3.bucketIndex, c3.sourceLayerIndex, c3.featureIndex, o2, i3.layers, i3.availableImages, e2, r2, n2, (e3, r3, n3) => (p3 || (p3 = as(e3)), r3.queryIntersectsFeature(l2, e3, n3, p3, this.z, t4.transform, s2, t4.pixelPosMatrix)));
            }
            return d2;
          }
          loadMatchingFeature(t4, e2, r2, n2, i3, a2, s2, o2, l2, u2, c2) {
            const h2 = this.bucketLayerIDs[e2];
            if (a2 && !function(t5, e3) {
              for (let r3 = 0; r3 < t5.length; r3++)
                if (e3.indexOf(t5[r3]) >= 0)
                  return true;
              return false;
            }(a2, h2))
              return;
            const p2 = this.sourceLayerCoder.decode(r2), f2 = this.vtLayers[p2].feature(n2);
            if (i3.needGeometry) {
              const t5 = ss(f2, true);
              if (!i3.filter(new li(this.tileID.overscaledZ), t5, this.tileID.canonical))
                return;
            } else if (!i3.filter(new li(this.tileID.overscaledZ), f2))
              return;
            const d2 = this.getId(f2, p2);
            for (let e3 = 0; e3 < h2.length; e3++) {
              const r3 = h2[e3];
              if (a2 && a2.indexOf(r3) < 0)
                continue;
              const i4 = o2[r3];
              if (!i4)
                continue;
              let p3 = {};
              d2 && u2 && (p3 = u2.getState(i4.sourceLayer || "_geojsonTileLayer", d2));
              const y2 = g({}, l2[r3]);
              y2.paint = vc(y2.paint, i4.paint, f2, p3, s2), y2.layout = vc(y2.layout, i4.layout, f2, p3, s2);
              const m2 = !c2 || c2(f2, i4, p3);
              if (!m2)
                continue;
              const x3 = new gc(f2, this.z, this.x, this.y, d2);
              x3.layer = y2;
              let v2 = t4[r3];
              void 0 === v2 && (v2 = t4[r3] = []), v2.push({ featureIndex: n2, feature: x3, intersectionZ: m2 });
            }
          }
          lookupSymbolFeatures(t4, e2, r2, n2, i3, a2, s2, o2) {
            const l2 = {};
            this.loadVTLayers();
            const u2 = Nr(i3);
            for (const i4 of t4)
              this.loadMatchingFeature(l2, r2, n2, i4, u2, a2, s2, o2, e2);
            return l2;
          }
          hasLayer(t4) {
            for (const e2 of this.bucketLayerIDs)
              for (const r2 of e2)
                if (t4 === r2)
                  return true;
            return false;
          }
          getId(t4, e2) {
            let r2 = t4.id;
            return this.promoteId && (r2 = t4.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2]], "boolean" == typeof r2 && (r2 = Number(r2))), r2;
          }
        }
        function vc(t4, e2, r2, n2, i3) {
          return v(t4, (t5, a2) => {
            const s2 = e2 instanceof mi ? e2.get(a2) : null;
            return s2 && s2.evaluate ? s2.evaluate(r2, n2, i3) : s2;
          });
        }
        function bc(t4) {
          let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i3 = -1 / 0;
          for (const a2 of t4)
            e2 = Math.min(e2, a2.x), r2 = Math.min(r2, a2.y), n2 = Math.max(n2, a2.x), i3 = Math.max(i3, a2.y);
          return { minX: e2, minY: r2, maxX: n2, maxY: i3 };
        }
        function wc(t4, e2) {
          return e2 - t4;
        }
        function _c(t4, e2, r2, n2, i3) {
          const s2 = [];
          for (let o2 = 0; o2 < t4.length; o2++) {
            const l2 = t4[o2];
            let u2;
            for (let t5 = 0; t5 < l2.length - 1; t5++) {
              let o3 = l2[t5], c2 = l2[t5 + 1];
              o3.x < e2 && c2.x < e2 || (o3.x < e2 ? o3 = new a(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x < e2 && (c2 = new a(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y < r2 && c2.y < r2 || (o3.y < r2 ? o3 = new a(o3.x + (r2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r2)._round() : c2.y < r2 && (c2 = new a(o3.x + (r2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r2)._round()), o3.x >= n2 && c2.x >= n2 || (o3.x >= n2 ? o3 = new a(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x >= n2 && (c2 = new a(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y >= i3 && c2.y >= i3 || (o3.y >= i3 ? o3 = new a(o3.x + (i3 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), i3)._round() : c2.y >= i3 && (c2 = new a(o3.x + (i3 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), i3)._round()), u2 && o3.equals(u2[u2.length - 1]) || (u2 = [o3], s2.push(u2)), u2.push(c2)))));
            }
          }
          return s2;
        }
        $n("FeatureIndex", xc, { omit: ["rawTileData", "sourceLayerCoder"] });
        class Ac extends a {
          constructor(t4, e2, r2, n2) {
            super(t4, e2), this.angle = r2, void 0 !== n2 && (this.segment = n2);
          }
          clone() {
            return new Ac(this.x, this.y, this.angle, this.segment);
          }
        }
        function Sc(t4, e2, r2, n2, i3) {
          if (void 0 === e2.segment || 0 === r2)
            return true;
          let a2 = e2, s2 = e2.segment + 1, o2 = 0;
          for (; o2 > -r2 / 2; ) {
            if (s2--, s2 < 0)
              return false;
            o2 -= t4[s2].dist(a2), a2 = t4[s2];
          }
          o2 += t4[s2].dist(t4[s2 + 1]), s2++;
          const l2 = [];
          let u2 = 0;
          for (; o2 < r2 / 2; ) {
            const e3 = t4[s2], r3 = t4[s2 + 1];
            if (!r3)
              return false;
            let a3 = t4[s2 - 1].angleTo(e3) - e3.angleTo(r3);
            for (a3 = Math.abs((a3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: a3 }), u2 += a3; o2 - l2[0].distance > n2; )
              u2 -= l2.shift().angleDelta;
            if (u2 > i3)
              return false;
            s2++, o2 += e3.dist(r3);
          }
          return true;
        }
        function kc(t4) {
          let e2 = 0;
          for (let r2 = 0; r2 < t4.length - 1; r2++)
            e2 += t4[r2].dist(t4[r2 + 1]);
          return e2;
        }
        function Ic(t4, e2, r2) {
          return t4 ? 0.6 * e2 * r2 : 0;
        }
        function zc(t4, e2) {
          return Math.max(t4 ? t4.right - t4.left : 0, e2 ? e2.right - e2.left : 0);
        }
        function Mc(t4, e2, r2, n2, i3, a2) {
          const s2 = Ic(r2, i3, a2), o2 = zc(r2, n2) * a2;
          let l2 = 0;
          const u2 = kc(t4) / 2;
          for (let r3 = 0; r3 < t4.length - 1; r3++) {
            const n3 = t4[r3], i4 = t4[r3 + 1], a3 = n3.dist(i4);
            if (l2 + a3 > u2) {
              const c2 = (u2 - l2) / a3, h2 = Ze.number(n3.x, i4.x, c2), p2 = Ze.number(n3.y, i4.y, c2), f2 = new Ac(h2, p2, i4.angleTo(n3), r3);
              return f2._round(), !s2 || Sc(t4, f2, o2, s2, e2) ? f2 : void 0;
            }
            l2 += a3;
          }
        }
        function Cc(t4, e2, r2, n2, i3, a2, s2, o2, l2) {
          const u2 = Ic(n2, a2, s2), c2 = zc(n2, i3), h2 = c2 * s2, p2 = 0 === t4[0].x || t4[0].x === l2 || 0 === t4[0].y || t4[0].y === l2;
          return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), Bc(t4, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * a2) * s2 * o2 % e2, e2, u2, r2, h2, p2, false, l2);
        }
        function Bc(t4, e2, r2, n2, i3, a2, s2, o2, l2) {
          const u2 = a2 / 2, c2 = kc(t4);
          let h2 = 0, p2 = e2 - r2, f2 = [];
          for (let e3 = 0; e3 < t4.length - 1; e3++) {
            const s3 = t4[e3], o3 = t4[e3 + 1], d2 = s3.dist(o3), y2 = o3.angleTo(s3);
            for (; p2 + r2 < h2 + d2; ) {
              p2 += r2;
              const m2 = (p2 - h2) / d2, g2 = Ze.number(s3.x, o3.x, m2), x3 = Ze.number(s3.y, o3.y, m2);
              if (g2 >= 0 && g2 < l2 && x3 >= 0 && x3 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                const r3 = new Ac(g2, x3, y2, e3);
                r3._round(), n2 && !Sc(t4, r3, a2, n2, i3) || f2.push(r3);
              }
            }
            h2 += d2;
          }
          return o2 || f2.length || s2 || (f2 = Bc(t4, h2 / 2, r2, n2, i3, a2, s2, true, l2)), f2;
        }
        $n("Anchor", Ac);
        const Pc = lu;
        function Vc(t4, e2, r2, n2) {
          const i3 = [], s2 = t4.image, o2 = s2.pixelRatio, l2 = s2.paddedRect.w - 2 * Pc, u2 = s2.paddedRect.h - 2 * Pc, c2 = t4.right - t4.left, h2 = t4.bottom - t4.top, p2 = s2.stretchX || [[0, l2]], f2 = s2.stretchY || [[0, u2]], d2 = (t5, e3) => t5 + e3[1] - e3[0], y2 = p2.reduce(d2, 0), m2 = f2.reduce(d2, 0), g2 = l2 - y2, x3 = u2 - m2;
          let v2 = 0, b2 = y2, w2 = 0, _2 = m2, A3 = 0, S2 = g2, k2 = 0, I2 = x3;
          if (s2.content && n2) {
            const t5 = s2.content;
            v2 = Ec(p2, 0, t5[0]), w2 = Ec(f2, 0, t5[1]), b2 = Ec(p2, t5[0], t5[2]), _2 = Ec(f2, t5[1], t5[3]), A3 = t5[0] - v2, k2 = t5[1] - w2, S2 = t5[2] - t5[0] - b2, I2 = t5[3] - t5[1] - _2;
          }
          const z2 = (n3, i4, l3, u3) => {
            const p3 = Tc(n3.stretch - v2, b2, c2, t4.left), f3 = $c(n3.fixed - A3, S2, n3.stretch, y2), d3 = Tc(i4.stretch - w2, _2, h2, t4.top), g3 = $c(i4.fixed - k2, I2, i4.stretch, m2), x4 = Tc(l3.stretch - v2, b2, c2, t4.left), z3 = $c(l3.fixed - A3, S2, l3.stretch, y2), M2 = Tc(u3.stretch - w2, _2, h2, t4.top), C3 = $c(u3.fixed - k2, I2, u3.stretch, m2), B3 = new a(p3, d3), P2 = new a(x4, d3), V2 = new a(x4, M2), E3 = new a(p3, M2), F2 = new a(f3 / o2, g3 / o2), T3 = new a(z3 / o2, C3 / o2), $2 = e2 * Math.PI / 180;
            if ($2) {
              const t5 = Math.sin($2), e3 = Math.cos($2), r3 = [e3, -t5, t5, e3];
              B3._matMult(r3), P2._matMult(r3), E3._matMult(r3), V2._matMult(r3);
            }
            const L3 = n3.stretch + n3.fixed, D3 = i4.stretch + i4.fixed;
            return { tl: B3, tr: P2, bl: E3, br: V2, tex: { x: s2.paddedRect.x + Pc + L3, y: s2.paddedRect.y + Pc + D3, w: l3.stretch + l3.fixed - L3, h: u3.stretch + u3.fixed - D3 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F2, pixelOffsetBR: T3, minFontScaleX: S2 / o2 / c2, minFontScaleY: I2 / o2 / h2, isSDF: r2 };
          };
          if (n2 && (s2.stretchX || s2.stretchY)) {
            const t5 = Fc(p2, g2, y2), e3 = Fc(f2, x3, m2);
            for (let r3 = 0; r3 < t5.length - 1; r3++) {
              const n3 = t5[r3], a2 = t5[r3 + 1];
              for (let t6 = 0; t6 < e3.length - 1; t6++)
                i3.push(z2(n3, e3[t6], a2, e3[t6 + 1]));
            }
          } else
            i3.push(z2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l2 + 1 }, { fixed: 0, stretch: u2 + 1 }));
          return i3;
        }
        function Ec(t4, e2, r2) {
          let n2 = 0;
          for (const i3 of t4)
            n2 += Math.max(e2, Math.min(r2, i3[1])) - Math.max(e2, Math.min(r2, i3[0]));
          return n2;
        }
        function Fc(t4, e2, r2) {
          const n2 = [{ fixed: -Pc, stretch: 0 }];
          for (const [e3, r3] of t4) {
            const t5 = n2[n2.length - 1];
            n2.push({ fixed: e3 - t5.stretch, stretch: t5.stretch }), n2.push({ fixed: e3 - t5.stretch, stretch: t5.stretch + (r3 - e3) });
          }
          return n2.push({ fixed: e2 + Pc, stretch: r2 }), n2;
        }
        function Tc(t4, e2, r2, n2) {
          return t4 / e2 * r2 + n2;
        }
        function $c(t4, e2, r2, n2) {
          return t4 - e2 * r2 / n2;
        }
        class Lc {
          constructor(t4, e2, r2, n2, i3, s2, o2, l2, u2, c2) {
            if (this.boxStartIndex = t4.length, u2) {
              let t5 = s2.top, e3 = s2.bottom;
              const r3 = s2.collisionPadding;
              r3 && (t5 -= r3[1], e3 += r3[3]);
              let n3 = e3 - t5;
              n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
            } else {
              let u3 = s2.top * o2 - l2[0], h2 = s2.bottom * o2 + l2[2], p2 = s2.left * o2 - l2[3], f2 = s2.right * o2 + l2[1];
              const d2 = s2.collisionPadding;
              if (d2 && (p2 -= d2[0] * o2, u3 -= d2[1] * o2, f2 += d2[2] * o2, h2 += d2[3] * o2), c2) {
                const t5 = new a(p2, u3), e3 = new a(f2, u3), r3 = new a(p2, h2), n3 = new a(f2, h2), i4 = c2 * Math.PI / 180;
                t5._rotate(i4), e3._rotate(i4), r3._rotate(i4), n3._rotate(i4), p2 = Math.min(t5.x, e3.x, r3.x, n3.x), f2 = Math.max(t5.x, e3.x, r3.x, n3.x), u3 = Math.min(t5.y, e3.y, r3.y, n3.y), h2 = Math.max(t5.y, e3.y, r3.y, n3.y);
              }
              t4.emplaceBack(e2.x, e2.y, p2, u3, f2, h2, r2, n2, i3);
            }
            this.boxEndIndex = t4.length;
          }
        }
        class Dc {
          constructor(t4 = [], e2 = Oc) {
            if (this.data = t4, this.length = this.data.length, this.compare = e2, this.length > 0)
              for (let t5 = (this.length >> 1) - 1; t5 >= 0; t5--)
                this._down(t5);
          }
          push(t4) {
            this.data.push(t4), this.length++, this._up(this.length - 1);
          }
          pop() {
            if (0 === this.length)
              return;
            const t4 = this.data[0], e2 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t4;
          }
          peek() {
            return this.data[0];
          }
          _up(t4) {
            const { data: e2, compare: r2 } = this, n2 = e2[t4];
            for (; t4 > 0; ) {
              const i3 = t4 - 1 >> 1, a2 = e2[i3];
              if (r2(n2, a2) >= 0)
                break;
              e2[t4] = a2, t4 = i3;
            }
            e2[t4] = n2;
          }
          _down(t4) {
            const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i3 = e2[t4];
            for (; t4 < n2; ) {
              let n3 = 1 + (t4 << 1), a2 = e2[n3];
              const s2 = n3 + 1;
              if (s2 < this.length && r2(e2[s2], a2) < 0 && (n3 = s2, a2 = e2[s2]), r2(a2, i3) >= 0)
                break;
              e2[t4] = a2, t4 = n3;
            }
            e2[t4] = i3;
          }
        }
        function Oc(t4, e2) {
          return t4 < e2 ? -1 : t4 > e2 ? 1 : 0;
        }
        function Uc(t4, e2 = 1, r2 = false) {
          let n2 = 1 / 0, i3 = 1 / 0, s2 = -1 / 0, o2 = -1 / 0;
          const l2 = t4[0];
          for (let t5 = 0; t5 < l2.length; t5++) {
            const e3 = l2[t5];
            (!t5 || e3.x < n2) && (n2 = e3.x), (!t5 || e3.y < i3) && (i3 = e3.y), (!t5 || e3.x > s2) && (s2 = e3.x), (!t5 || e3.y > o2) && (o2 = e3.y);
          }
          const u2 = Math.min(s2 - n2, o2 - i3);
          let c2 = u2 / 2;
          const h2 = new Dc([], Rc);
          if (0 === u2)
            return new a(n2, i3);
          for (let e3 = n2; e3 < s2; e3 += u2)
            for (let r3 = i3; r3 < o2; r3 += u2)
              h2.push(new qc(e3 + c2, r3 + c2, c2, t4));
          let p2 = function(t5) {
            let e3 = 0, r3 = 0, n3 = 0;
            const i4 = t5[0];
            for (let t6 = 0, a2 = i4.length, s3 = a2 - 1; t6 < a2; s3 = t6++) {
              const a3 = i4[t6], o3 = i4[s3], l3 = a3.x * o3.y - o3.x * a3.y;
              r3 += (a3.x + o3.x) * l3, n3 += (a3.y + o3.y) * l3, e3 += 3 * l3;
            }
            return new qc(r3 / e3, n3 / e3, 0, t5);
          }(t4), f2 = h2.length;
          for (; h2.length; ) {
            const n3 = h2.pop();
            (n3.d > p2.d || !p2.d) && (p2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, f2)), n3.max - p2.d <= e2 || (c2 = n3.h / 2, h2.push(new qc(n3.p.x - c2, n3.p.y - c2, c2, t4)), h2.push(new qc(n3.p.x + c2, n3.p.y - c2, c2, t4)), h2.push(new qc(n3.p.x - c2, n3.p.y + c2, c2, t4)), h2.push(new qc(n3.p.x + c2, n3.p.y + c2, c2, t4)), f2 += 4);
          }
          return r2 && (console.log(`num probes: ${f2}`), console.log(`best distance: ${p2.d}`)), p2.p;
        }
        function Rc(t4, e2) {
          return e2.max - t4.max;
        }
        function qc(t4, e2, r2, n2) {
          this.p = new a(t4, e2), this.h = r2, this.d = function(t5, e3) {
            let r3 = false, n3 = 1 / 0;
            for (let i3 = 0; i3 < e3.length; i3++) {
              const a2 = e3[i3];
              for (let e4 = 0, i4 = a2.length, s2 = i4 - 1; e4 < i4; s2 = e4++) {
                const i5 = a2[e4], o2 = a2[s2];
                i5.y > t5.y != o2.y > t5.y && t5.x < (o2.x - i5.x) * (t5.y - i5.y) / (o2.y - i5.y) + i5.x && (r3 = !r3), n3 = Math.min(n3, ms(t5, i5, o2));
              }
            }
            return (r3 ? 1 : -1) * Math.sqrt(n3);
          }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
        }
        var jc;
        t.aq = void 0, (jc = t.aq || (t.aq = {}))[jc.center = 1] = "center", jc[jc.left = 2] = "left", jc[jc.right = 3] = "right", jc[jc.top = 4] = "top", jc[jc.bottom = 5] = "bottom", jc[jc["top-left"] = 6] = "top-left", jc[jc["top-right"] = 7] = "top-right", jc[jc["bottom-left"] = 8] = "bottom-left", jc[jc["bottom-right"] = 9] = "bottom-right";
        const Nc = 7, Zc = Number.POSITIVE_INFINITY;
        function Kc(t4, e2) {
          return e2[1] !== Zc ? function(t5, e3, r2) {
            let n2 = 0, i3 = 0;
            switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t5) {
              case "top-right":
              case "top-left":
              case "top":
                i3 = r2 - Nc;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i3 = -r2 + Nc;
            }
            switch (t5) {
              case "top-right":
              case "bottom-right":
              case "right":
                n2 = -e3;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n2 = e3;
            }
            return [n2, i3];
          }(t4, e2[0], e2[1]) : function(t5, e3) {
            let r2 = 0, n2 = 0;
            e3 < 0 && (e3 = 0);
            const i3 = e3 / Math.SQRT2;
            switch (t5) {
              case "top-right":
              case "top-left":
                n2 = i3 - Nc;
                break;
              case "bottom-right":
              case "bottom-left":
                n2 = -i3 + Nc;
                break;
              case "bottom":
                n2 = -e3 + Nc;
                break;
              case "top":
                n2 = e3 - Nc;
            }
            switch (t5) {
              case "top-right":
              case "bottom-right":
                r2 = -i3;
                break;
              case "top-left":
              case "bottom-left":
                r2 = i3;
                break;
              case "left":
                r2 = e3;
                break;
              case "right":
                r2 = -e3;
            }
            return [r2, n2];
          }(t4, e2[0]);
        }
        function Gc(t4, e2, r2) {
          var n2;
          const i3 = t4.layout, a2 = null === (n2 = i3.get("text-variable-anchor-offset")) || void 0 === n2 ? void 0 : n2.evaluate(e2, {}, r2);
          if (a2) {
            const t5 = a2.values, e3 = [];
            for (let r3 = 0; r3 < t5.length; r3 += 2) {
              const n3 = e3[r3] = t5[r3], i4 = t5[r3 + 1].map((t6) => t6 * Vl);
              n3.startsWith("top") ? i4[1] -= Nc : n3.startsWith("bottom") && (i4[1] += Nc), e3[r3 + 1] = i4;
            }
            return new re(e3);
          }
          const s2 = i3.get("text-variable-anchor");
          if (s2) {
            let n3;
            n3 = void 0 !== t4._unevaluatedLayout.getValue("text-radial-offset") ? [i3.get("text-radial-offset").evaluate(e2, {}, r2) * Vl, Zc] : i3.get("text-offset").evaluate(e2, {}, r2).map((t5) => t5 * Vl);
            const a3 = [];
            for (const t5 of s2)
              a3.push(t5, Kc(t5, n3));
            return new re(a3);
          }
          return null;
        }
        function Jc(t4) {
          switch (t4) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function Xc(e2, r2, n2, i3, a2, s2, o2, l2, u2, c2, h2) {
          let p2 = s2.textMaxSize.evaluate(r2, {});
          void 0 === p2 && (p2 = o2);
          const f2 = e2.layers[0].layout, d2 = f2.get("icon-offset").evaluate(r2, {}, h2), y2 = Hc(n2.horizontal), m2 = o2 / 24, g2 = e2.tilePixelRatio * m2, x3 = e2.tilePixelRatio * p2 / 24, v2 = e2.tilePixelRatio * l2, b2 = e2.tilePixelRatio * f2.get("symbol-spacing"), w2 = f2.get("text-padding") * e2.tilePixelRatio, _2 = function(t4, e3, r3, n3 = 1) {
            const i4 = t4.get("icon-padding").evaluate(e3, {}, r3), a3 = i4 && i4.values;
            return [a3[0] * n3, a3[1] * n3, a3[2] * n3, a3[3] * n3];
          }(f2, r2, h2, e2.tilePixelRatio), S2 = f2.get("text-max-angle") / 180 * Math.PI, k2 = "viewport" !== f2.get("text-rotation-alignment") && "point" !== f2.get("symbol-placement"), I2 = "map" === f2.get("icon-rotation-alignment") && "point" !== f2.get("symbol-placement"), z2 = f2.get("symbol-placement"), M2 = b2 / 2, C3 = f2.get("icon-text-fit");
          let B3;
          i3 && "none" !== C3 && (e2.allowVerticalPlacement && n2.vertical && (B3 = zu(i3, n2.vertical, C3, f2.get("icon-text-fit-padding"), d2, m2)), y2 && (i3 = zu(i3, y2, C3, f2.get("icon-text-fit-padding"), d2, m2)));
          const P2 = (l3, p3) => {
            p3.x < 0 || p3.x >= rs || p3.y < 0 || p3.y >= rs || function(e3, r3, n3, i4, a3, s3, o3, l4, u3, c3, h3, p4, f3, d3, y3, m3, g3, x4, v3, b3, w3, _3, S3, k3, I3) {
              const z3 = e3.addToLineVertexArray(r3, n3);
              let M3, C4, B4, P3, V2 = 0, E3 = 0, F2 = 0, T3 = 0, $2 = -1, L3 = -1;
              const D3 = {};
              let O2 = $a("");
              if (e3.allowVerticalPlacement && i4.vertical) {
                const t4 = l4.layout.get("text-rotate").evaluate(w3, {}, k3) + 90;
                B4 = new Lc(u3, r3, c3, h3, p4, i4.vertical, f3, d3, y3, t4), o3 && (P3 = new Lc(u3, r3, c3, h3, p4, o3, g3, x4, y3, t4));
              }
              if (a3) {
                const n4 = l4.layout.get("icon-rotate").evaluate(w3, {}), i5 = "none" !== l4.layout.get("icon-text-fit"), s4 = Vc(a3, n4, S3, i5), f4 = o3 ? Vc(o3, n4, S3, i5) : void 0;
                C4 = new Lc(u3, r3, c3, h3, p4, a3, g3, x4, false, n4), V2 = 4 * s4.length;
                const d4 = e3.iconSizeData;
                let y4 = null;
                "source" === d4.kind ? (y4 = [Cu * l4.layout.get("icon-size").evaluate(w3, {})], y4[0] > Bu && A2(`${e3.layerIds[0]}: Value for "icon-size" is >= ${Mu}. Reduce your "icon-size".`)) : "composite" === d4.kind && (y4 = [Cu * _3.compositeIconSizes[0].evaluate(w3, {}, k3), Cu * _3.compositeIconSizes[1].evaluate(w3, {}, k3)], (y4[0] > Bu || y4[1] > Bu) && A2(`${e3.layerIds[0]}: Value for "icon-size" is >= ${Mu}. Reduce your "icon-size".`)), e3.addSymbols(e3.icon, s4, y4, b3, v3, w3, t.ai.none, r3, z3.lineStartIndex, z3.lineLength, -1, k3), $2 = e3.icon.placedSymbolArray.length - 1, f4 && (E3 = 4 * f4.length, e3.addSymbols(e3.icon, f4, y4, b3, v3, w3, t.ai.vertical, r3, z3.lineStartIndex, z3.lineLength, -1, k3), L3 = e3.icon.placedSymbolArray.length - 1);
              }
              const U2 = Object.keys(i4.horizontal);
              for (const n4 of U2) {
                const a4 = i4.horizontal[n4];
                if (!M3) {
                  O2 = $a(a4.text);
                  const t4 = l4.layout.get("text-rotate").evaluate(w3, {}, k3);
                  M3 = new Lc(u3, r3, c3, h3, p4, a4, f3, d3, y3, t4);
                }
                const o4 = 1 === a4.positionedLines.length;
                if (F2 += Yc(e3, r3, a4, s3, l4, y3, w3, m3, z3, i4.vertical ? t.ai.horizontal : t.ai.horizontalOnly, o4 ? U2 : [n4], D3, $2, _3, k3), o4)
                  break;
              }
              i4.vertical && (T3 += Yc(e3, r3, i4.vertical, s3, l4, y3, w3, m3, z3, t.ai.vertical, ["vertical"], D3, L3, _3, k3));
              const R2 = M3 ? M3.boxStartIndex : e3.collisionBoxArray.length, q2 = M3 ? M3.boxEndIndex : e3.collisionBoxArray.length, j2 = B4 ? B4.boxStartIndex : e3.collisionBoxArray.length, N2 = B4 ? B4.boxEndIndex : e3.collisionBoxArray.length, Z2 = C4 ? C4.boxStartIndex : e3.collisionBoxArray.length, K3 = C4 ? C4.boxEndIndex : e3.collisionBoxArray.length, G2 = P3 ? P3.boxStartIndex : e3.collisionBoxArray.length, J2 = P3 ? P3.boxEndIndex : e3.collisionBoxArray.length;
              let X2 = -1;
              const Y2 = (t4, e4) => t4 && t4.circleDiameter ? Math.max(t4.circleDiameter, e4) : e4;
              X2 = Y2(M3, X2), X2 = Y2(B4, X2), X2 = Y2(C4, X2), X2 = Y2(P3, X2);
              const H2 = X2 > -1 ? 1 : 0;
              H2 && (X2 *= I3 / Vl), e3.glyphOffsetArray.length >= Uu.MAX_GLYPHS && A2("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w3.sortKey && e3.addToSortKeyRanges(e3.symbolInstances.length, w3.sortKey);
              const W2 = Gc(l4, w3, k3), [Q2, tt2] = function(e4, r4) {
                const n4 = e4.length, i5 = null == r4 ? void 0 : r4.values;
                if ((null == i5 ? void 0 : i5.length) > 0)
                  for (let r5 = 0; r5 < i5.length; r5 += 2) {
                    const n5 = i5[r5 + 1];
                    e4.emplaceBack(t.aq[i5[r5]], n5[0], n5[1]);
                  }
                return [n4, e4.length];
              }(e3.textAnchorOffsets, W2);
              e3.symbolInstances.emplaceBack(r3.x, r3.y, D3.right >= 0 ? D3.right : -1, D3.center >= 0 ? D3.center : -1, D3.left >= 0 ? D3.left : -1, D3.vertical || -1, $2, L3, O2, R2, q2, j2, N2, Z2, K3, G2, J2, c3, F2, T3, V2, E3, H2, 0, f3, X2, Q2, tt2);
            }(e2, p3, l3, n2, i3, a2, B3, e2.layers[0], e2.collisionBoxArray, r2.index, r2.sourceLayerIndex, e2.index, g2, [w2, w2, w2, w2], k2, u2, v2, _2, I2, d2, r2, s2, c2, h2, o2);
          };
          if ("line" === z2)
            for (const t4 of _c(r2.geometry, 0, 0, rs, rs)) {
              const r3 = Cc(t4, b2, S2, n2.vertical || y2, i3, 24, x3, e2.overscaling, rs);
              for (const n3 of r3)
                y2 && Wc(e2, y2.text, M2, n3) || P2(t4, n3);
            }
          else if ("line-center" === z2) {
            for (const t4 of r2.geometry)
              if (t4.length > 1) {
                const e3 = Mc(t4, S2, n2.vertical || y2, i3, 24, x3);
                e3 && P2(t4, e3);
              }
          } else if ("Polygon" === r2.type)
            for (const t4 of Co(r2.geometry, 0)) {
              const e3 = Uc(t4, 16);
              P2(t4[0], new Ac(e3.x, e3.y, 0));
            }
          else if ("LineString" === r2.type)
            for (const t4 of r2.geometry)
              P2(t4, new Ac(t4[0].x, t4[0].y, 0));
          else if ("Point" === r2.type)
            for (const t4 of r2.geometry)
              for (const e3 of t4)
                P2([e3], new Ac(e3.x, e3.y, 0));
        }
        function Yc(t4, e2, r2, n2, i3, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2) {
          const m2 = function(t5, e3, r3, n3, i4, s3, o3, l3) {
            const u3 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, c3 = [];
            for (const t6 of e3.positionedLines)
              for (const n4 of t6.positionedGlyphs) {
                if (!n4.rect)
                  continue;
                const s4 = n4.rect || {};
                let h3 = su + 1, p3 = true, f3 = 1, d3 = 0;
                const y3 = (i4 || l3) && n4.vertical, m3 = n4.metrics.advance * n4.scale / 2;
                if (l3 && e3.verticalizable && (d3 = t6.lineOffset / 2 - (n4.imageName ? -(Vl - n4.metrics.width * n4.scale) / 2 : (n4.scale - 1) * Vl)), n4.imageName) {
                  const t7 = o3[n4.imageName];
                  p3 = t7.sdf, f3 = t7.pixelRatio, h3 = lu / f3;
                }
                const g3 = i4 ? [n4.x + m3, n4.y] : [0, 0];
                let x4 = i4 ? [0, 0] : [n4.x + m3 + r3[0], n4.y + r3[1] - d3], v2 = [0, 0];
                y3 && (v2 = x4, x4 = [0, 0]);
                const b2 = n4.metrics.isDoubleResolution ? 2 : 1, w2 = (n4.metrics.left - h3) * n4.scale - m3 + x4[0], _2 = (-n4.metrics.top - h3) * n4.scale + x4[1], A3 = w2 + s4.w / b2 * n4.scale / f3, S2 = _2 + s4.h / b2 * n4.scale / f3, k2 = new a(w2, _2), I2 = new a(A3, _2), z2 = new a(w2, S2), M2 = new a(A3, S2);
                if (y3) {
                  const t7 = new a(-m3, m3 - pu), e4 = -Math.PI / 2, r4 = Vl / 2 - m3, i5 = new a(5 - pu - r4, -(n4.imageName ? r4 : 0)), s5 = new a(...v2);
                  k2._rotateAround(e4, t7)._add(i5)._add(s5), I2._rotateAround(e4, t7)._add(i5)._add(s5), z2._rotateAround(e4, t7)._add(i5)._add(s5), M2._rotateAround(e4, t7)._add(i5)._add(s5);
                }
                if (u3) {
                  const t7 = Math.sin(u3), e4 = Math.cos(u3), r4 = [e4, -t7, t7, e4];
                  k2._matMult(r4), I2._matMult(r4), z2._matMult(r4), M2._matMult(r4);
                }
                const C3 = new a(0, 0), B3 = new a(0, 0);
                c3.push({ tl: k2, tr: I2, bl: z2, br: M2, tex: s4, writingMode: e3.writingMode, glyphOffset: g3, sectionIndex: n4.sectionIndex, isSDF: p3, pixelOffsetTL: C3, pixelOffsetBR: B3, minFontScaleX: 0, minFontScaleY: 0 });
              }
            return c3;
          }(0, r2, l2, i3, s2, o2, n2, t4.allowVerticalPlacement), g2 = t4.textSizeData;
          let x3 = null;
          "source" === g2.kind ? (x3 = [Cu * i3.layout.get("text-size").evaluate(o2, {})], x3[0] > Bu && A2(`${t4.layerIds[0]}: Value for "text-size" is >= ${Mu}. Reduce your "text-size".`)) : "composite" === g2.kind && (x3 = [Cu * d2.compositeTextSizes[0].evaluate(o2, {}, y2), Cu * d2.compositeTextSizes[1].evaluate(o2, {}, y2)], (x3[0] > Bu || x3[1] > Bu) && A2(`${t4.layerIds[0]}: Value for "text-size" is >= ${Mu}. Reduce your "text-size".`)), t4.addSymbols(t4.text, m2, x3, l2, s2, o2, c2, e2, u2.lineStartIndex, u2.lineLength, f2, y2);
          for (const e3 of h2)
            p2[e3] = t4.text.placedSymbolArray.length - 1;
          return 4 * m2.length;
        }
        function Hc(t4) {
          for (const e2 in t4)
            return t4[e2];
          return null;
        }
        function Wc(t4, e2, r2, n2) {
          const i3 = t4.compareText;
          if (e2 in i3) {
            const t5 = i3[e2];
            for (let e3 = t5.length - 1; e3 >= 0; e3--)
              if (n2.dist(t5[e3]) < r2)
                return true;
          } else
            i3[e2] = [];
          return i3[e2].push(n2), false;
        }
        const Qc = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class th {
          static from(t4) {
            if (!(t4 instanceof ArrayBuffer))
              throw new Error("Data must be an instance of ArrayBuffer.");
            const [e2, r2] = new Uint8Array(t4, 0, 2);
            if (219 !== e2)
              throw new Error("Data does not appear to be in a KDBush format.");
            const n2 = r2 >> 4;
            if (1 !== n2)
              throw new Error(`Got v${n2} data when expected v1.`);
            const i3 = Qc[15 & r2];
            if (!i3)
              throw new Error("Unrecognized array type.");
            const [a2] = new Uint16Array(t4, 2, 1), [s2] = new Uint32Array(t4, 4, 1);
            return new th(s2, a2, i3, t4);
          }
          constructor(t4, e2 = 64, r2 = Float64Array, n2) {
            if (isNaN(t4) || t4 < 0)
              throw new Error(`Unpexpected numItems value: ${t4}.`);
            this.numItems = +t4, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t4 < 65536 ? Uint16Array : Uint32Array;
            const i3 = Qc.indexOf(this.ArrayType), a2 = 2 * t4 * this.ArrayType.BYTES_PER_ELEMENT, s2 = t4 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - s2 % 8) % 8;
            if (i3 < 0)
              throw new Error(`Unexpected typed array class: ${r2}.`);
            n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, t4), this.coords = new this.ArrayType(this.data, 8 + s2 + o2, 2 * t4), this._pos = 2 * t4, this._finished = true) : (this.data = new ArrayBuffer(8 + a2 + s2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t4), this.coords = new this.ArrayType(this.data, 8 + s2 + o2, 2 * t4), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i3]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t4);
          }
          add(t4, e2) {
            const r2 = this._pos >> 1;
            return this.ids[r2] = r2, this.coords[this._pos++] = t4, this.coords[this._pos++] = e2, r2;
          }
          finish() {
            const t4 = this._pos >> 1;
            if (t4 !== this.numItems)
              throw new Error(`Added ${t4} items when expected ${this.numItems}.`);
            return eh(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t4, e2, r2, n2) {
            if (!this._finished)
              throw new Error("Data not yet indexed - call index.finish().");
            const { ids: i3, coords: a2, nodeSize: s2 } = this, o2 = [0, i3.length - 1, 0], l2 = [];
            for (; o2.length; ) {
              const u2 = o2.pop() || 0, c2 = o2.pop() || 0, h2 = o2.pop() || 0;
              if (c2 - h2 <= s2) {
                for (let s3 = h2; s3 <= c2; s3++) {
                  const o3 = a2[2 * s3], u3 = a2[2 * s3 + 1];
                  o3 >= t4 && o3 <= r2 && u3 >= e2 && u3 <= n2 && l2.push(i3[s3]);
                }
                continue;
              }
              const p2 = h2 + c2 >> 1, f2 = a2[2 * p2], d2 = a2[2 * p2 + 1];
              f2 >= t4 && f2 <= r2 && d2 >= e2 && d2 <= n2 && l2.push(i3[p2]), (0 === u2 ? t4 <= f2 : e2 <= d2) && (o2.push(h2), o2.push(p2 - 1), o2.push(1 - u2)), (0 === u2 ? r2 >= f2 : n2 >= d2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u2));
            }
            return l2;
          }
          within(t4, e2, r2) {
            if (!this._finished)
              throw new Error("Data not yet indexed - call index.finish().");
            const { ids: n2, coords: i3, nodeSize: a2 } = this, s2 = [0, n2.length - 1, 0], o2 = [], l2 = r2 * r2;
            for (; s2.length; ) {
              const u2 = s2.pop() || 0, c2 = s2.pop() || 0, h2 = s2.pop() || 0;
              if (c2 - h2 <= a2) {
                for (let r3 = h2; r3 <= c2; r3++)
                  ah(i3[2 * r3], i3[2 * r3 + 1], t4, e2) <= l2 && o2.push(n2[r3]);
                continue;
              }
              const p2 = h2 + c2 >> 1, f2 = i3[2 * p2], d2 = i3[2 * p2 + 1];
              ah(f2, d2, t4, e2) <= l2 && o2.push(n2[p2]), (0 === u2 ? t4 - r2 <= f2 : e2 - r2 <= d2) && (s2.push(h2), s2.push(p2 - 1), s2.push(1 - u2)), (0 === u2 ? t4 + r2 >= f2 : e2 + r2 >= d2) && (s2.push(p2 + 1), s2.push(c2), s2.push(1 - u2));
            }
            return o2;
          }
        }
        function eh(t4, e2, r2, n2, i3, a2) {
          if (i3 - n2 <= r2)
            return;
          const s2 = n2 + i3 >> 1;
          rh(t4, e2, s2, n2, i3, a2), eh(t4, e2, r2, n2, s2 - 1, 1 - a2), eh(t4, e2, r2, s2 + 1, i3, 1 - a2);
        }
        function rh(t4, e2, r2, n2, i3, a2) {
          for (; i3 > n2; ) {
            if (i3 - n2 > 600) {
              const s3 = i3 - n2 + 1, o3 = r2 - n2 + 1, l3 = Math.log(s3), u2 = 0.5 * Math.exp(2 * l3 / 3), c2 = 0.5 * Math.sqrt(l3 * u2 * (s3 - u2) / s3) * (o3 - s3 / 2 < 0 ? -1 : 1);
              rh(t4, e2, r2, Math.max(n2, Math.floor(r2 - o3 * u2 / s3 + c2)), Math.min(i3, Math.floor(r2 + (s3 - o3) * u2 / s3 + c2)), a2);
            }
            const s2 = e2[2 * r2 + a2];
            let o2 = n2, l2 = i3;
            for (nh(t4, e2, n2, r2), e2[2 * i3 + a2] > s2 && nh(t4, e2, n2, i3); o2 < l2; ) {
              for (nh(t4, e2, o2, l2), o2++, l2--; e2[2 * o2 + a2] < s2; )
                o2++;
              for (; e2[2 * l2 + a2] > s2; )
                l2--;
            }
            e2[2 * n2 + a2] === s2 ? nh(t4, e2, n2, l2) : (l2++, nh(t4, e2, l2, i3)), l2 <= r2 && (n2 = l2 + 1), r2 <= l2 && (i3 = l2 - 1);
          }
        }
        function nh(t4, e2, r2, n2) {
          ih(t4, r2, n2), ih(e2, 2 * r2, 2 * n2), ih(e2, 2 * r2 + 1, 2 * n2 + 1);
        }
        function ih(t4, e2, r2) {
          const n2 = t4[e2];
          t4[e2] = t4[r2], t4[r2] = n2;
        }
        function ah(t4, e2, r2, n2) {
          const i3 = t4 - r2, a2 = e2 - n2;
          return i3 * i3 + a2 * a2;
        }
        var sh;
        t.bh = void 0, (sh = t.bh || (t.bh = {})).create = "create", sh.load = "load", sh.fullLoad = "fullLoad";
        let oh = null, lh = [];
        const uh = 1e3 / 60, ch = "loadTime", hh = "fullLoadTime", ph = { mark(t4) {
          performance.mark(t4);
        }, frame(t4) {
          const e2 = t4;
          null != oh && lh.push(e2 - oh), oh = e2;
        }, clearMetrics() {
          oh = null, lh = [], performance.clearMeasures(ch), performance.clearMeasures(hh);
          for (const e2 in t.bh)
            performance.clearMarks(t.bh[e2]);
        }, getPerformanceMetrics() {
          performance.measure(ch, t.bh.create, t.bh.load), performance.measure(hh, t.bh.create, t.bh.fullLoad);
          const e2 = performance.getEntriesByName(ch)[0].duration, r2 = performance.getEntriesByName(hh)[0].duration, n2 = lh.length, i3 = 1 / (lh.reduce((t4, e3) => t4 + e3, 0) / n2 / 1e3), a2 = lh.filter((t4) => t4 > uh).reduce((t4, e3) => t4 + (e3 - uh) / uh, 0);
          return { loadTime: e2, fullLoadTime: r2, fps: i3, percentDroppedFrames: a2 / (n2 + a2) * 100, totalFrames: n2 };
        } };
        t.$ = function(t4, e2, r2) {
          var n2, i3, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y2 = r2[0], m2 = r2[1], g2 = r2[2];
          return e2 === t4 ? (t4[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g2 + e2[12], t4[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g2 + e2[13], t4[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g2 + e2[14], t4[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i3 = e2[1], a2 = e2[2], s2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t4[0] = n2 = e2[0], t4[1] = i3, t4[2] = a2, t4[3] = s2, t4[4] = o2, t4[5] = l2, t4[6] = u2, t4[7] = c2, t4[8] = h2, t4[9] = p2, t4[10] = f2, t4[11] = d2, t4[12] = n2 * y2 + o2 * m2 + h2 * g2 + e2[12], t4[13] = i3 * y2 + l2 * m2 + p2 * g2 + e2[13], t4[14] = a2 * y2 + u2 * m2 + f2 * g2 + e2[14], t4[15] = s2 * y2 + c2 * m2 + d2 * g2 + e2[15]), t4;
        }, t.A = zs, t.B = Ze, t.C = class {
          constructor(t4, e2, r2) {
            this.receive = (t5) => {
              const e3 = t5.data, r3 = e3.id;
              if (r3 && (!e3.targetMapId || this.mapId === e3.targetMapId))
                if ("<cancel>" === e3.type) {
                  delete this.tasks[r3];
                  const t6 = this.cancelCallbacks[r3];
                  delete this.cancelCallbacks[r3], t6 && t6();
                } else
                  I() || e3.mustQueue ? (this.tasks[r3] = e3, this.taskQueue.push(r3), this.invoker.trigger()) : this.processTask(r3, e3);
            }, this.process = () => {
              if (!this.taskQueue.length)
                return;
              const t5 = this.taskQueue.shift(), e3 = this.tasks[t5];
              delete this.tasks[t5], this.taskQueue.length && this.invoker.trigger(), e3 && this.processTask(t5, e3);
            }, this.target = t4, this.parent = e2, this.mapId = r2, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, this.invoker = new Qu(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = I() ? t4 : window;
          }
          send(t4, e2, r2, n2, i3 = false) {
            const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r2 && (this.callbacks[a2] = r2);
            const s2 = [], o2 = { id: a2, type: t4, hasCallback: !!r2, targetMapId: n2, mustQueue: i3, sourceMapId: this.mapId, data: Dn(e2, s2) };
            return this.target.postMessage(o2, { transfer: s2 }), { cancel: () => {
              r2 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
            } };
          }
          processTask(t4, e2) {
            if ("<response>" === e2.type) {
              const r2 = this.callbacks[t4];
              delete this.callbacks[t4], r2 && (e2.error ? r2(On(e2.error)) : r2(null, On(e2.data)));
            } else {
              let r2 = false;
              const n2 = [], i3 = e2.hasCallback ? (e3, i4) => {
                r2 = true, delete this.cancelCallbacks[t4];
                const a3 = { id: t4, type: "<response>", sourceMapId: this.mapId, error: e3 ? Dn(e3) : null, data: Dn(i4, n2) };
                this.target.postMessage(a3, { transfer: n2 });
              } : (t5) => {
                r2 = true;
              };
              let a2 = null;
              const s2 = On(e2.data);
              if (this.parent[e2.type])
                a2 = this.parent[e2.type](e2.sourceMapId, s2, i3);
              else if ("getWorkerSource" in this.parent) {
                const t5 = e2.type.split(".");
                a2 = this.parent.getWorkerSource(e2.sourceMapId, t5[0], s2.source)[t5[1]](s2, i3);
              } else
                i3(new Error(`Could not find function ${e2.type}`));
              !r2 && a2 && a2.cancel && (this.cancelCallbacks[t4] = a2.cancel);
            }
          }
          remove() {
            this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
          }
        }, t.D = gi, t.E = J, t.F = function(t4, e2) {
          const r2 = {};
          for (let n2 = 0; n2 < e2.length; n2++) {
            const i3 = e2[n2];
            i3 in t4 && (r2[i3] = t4[i3]);
          }
          return r2;
        }, t.G = ic, t.H = ac, t.I = uu, t.J = h, t.K = p, t.L = ec2, t.M = B2, t.N = rs, t.O = fc, t.P = a, t.Q = Mi, t.R = qs, t.S = za, t.T = hi, t.U = uc, t.V = class extends Vi {
        }, t.W = hc, t.X = function(t4, e2) {
          const r2 = window.document.createElement("video");
          r2.muted = true, r2.onloadstart = function() {
            e2(null, r2);
          };
          for (let e3 = 0; e3 < t4.length; e3++) {
            const n2 = window.document.createElement("source");
            j(t4[e3]) || (r2.crossOrigin = "Anonymous"), n2.src = t4[e3], r2.appendChild(n2);
          }
          return { cancel: () => {
          } };
        }, t.Y = ot, t.Z = function() {
          var t4 = new zs(16);
          return zs != Float32Array && (t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0), t4[0] = 1, t4[5] = 1, t4[10] = 1, t4[15] = 1, t4;
        }, t._ = e, t.a = M, t.a$ = class extends Hi {
        }, t.a0 = function(t4, e2, r2) {
          var n2 = r2[0], i3 = r2[1], a2 = r2[2];
          return t4[0] = e2[0] * n2, t4[1] = e2[1] * n2, t4[2] = e2[2] * n2, t4[3] = e2[3] * n2, t4[4] = e2[4] * i3, t4[5] = e2[5] * i3, t4[6] = e2[6] * i3, t4[7] = e2[7] * i3, t4[8] = e2[8] * a2, t4[9] = e2[9] * a2, t4[10] = e2[10] * a2, t4[11] = e2[11] * a2, t4[12] = e2[12], t4[13] = e2[13], t4[14] = e2[14], t4[15] = e2[15], t4;
        }, t.a1 = Cs, t.a2 = function() {
          return x2++;
        }, t.a3 = ta, t.a4 = Uu, t.a5 = function() {
          oi.isLoading() || oi.isLoaded() || "deferred" !== ai() || si();
        }, t.a6 = Nr, t.a7 = ss, t.a8 = li, t.a9 = gc, t.aA = ri, t.aB = function(t4) {
          t4 = t4.slice();
          const e2 = /* @__PURE__ */ Object.create(null);
          for (let r2 = 0; r2 < t4.length; r2++)
            e2[t4[r2].id] = t4[r2];
          for (let r2 = 0; r2 < t4.length; r2++)
            "ref" in t4[r2] && (t4[r2] = H(t4[r2], e2[t4[r2].ref]));
          return t4;
        }, t.aC = function(t4) {
          if ("custom" === t4.type)
            return new Wu(t4);
          switch (t4.type) {
            case "background":
              return new Ju(t4);
            case "circle":
              return new Es(t4);
            case "fill":
              return new Lo(t4);
            case "fill-extrusion":
              return new ol(t4);
            case "heatmap":
              return new Ns(t4);
            case "hillshade":
              return new Gs(t4);
            case "line":
              return new Al(t4);
            case "raster":
              return new Hu(t4);
            case "symbol":
              return new Zu(t4);
          }
        }, t.aD = w, t.aE = function(t4, e2) {
          if (!t4)
            return [{ command: Q.setStyle, args: [e2] }];
          let r2 = [];
          try {
            if (!W(t4.version, e2.version))
              return [{ command: Q.setStyle, args: [e2] }];
            W(t4.center, e2.center) || r2.push({ command: Q.setCenter, args: [e2.center] }), W(t4.zoom, e2.zoom) || r2.push({ command: Q.setZoom, args: [e2.zoom] }), W(t4.bearing, e2.bearing) || r2.push({ command: Q.setBearing, args: [e2.bearing] }), W(t4.pitch, e2.pitch) || r2.push({ command: Q.setPitch, args: [e2.pitch] }), W(t4.sprite, e2.sprite) || r2.push({ command: Q.setSprite, args: [e2.sprite] }), W(t4.glyphs, e2.glyphs) || r2.push({ command: Q.setGlyphs, args: [e2.glyphs] }), W(t4.transition, e2.transition) || r2.push({ command: Q.setTransition, args: [e2.transition] }), W(t4.light, e2.light) || r2.push({ command: Q.setLight, args: [e2.light] });
            const n2 = {}, i3 = [];
            !function(t5, e3, r3, n3) {
              let i4;
              for (i4 in e3 = e3 || {}, t5 = t5 || {})
                Object.prototype.hasOwnProperty.call(t5, i4) && (Object.prototype.hasOwnProperty.call(e3, i4) || et2(i4, r3, n3));
              for (i4 in e3)
                Object.prototype.hasOwnProperty.call(e3, i4) && (Object.prototype.hasOwnProperty.call(t5, i4) ? W(t5[i4], e3[i4]) || ("geojson" === t5[i4].type && "geojson" === e3[i4].type && nt(t5, e3, i4) ? r3.push({ command: Q.setGeoJSONSourceData, args: [i4, e3[i4].data] }) : rt(i4, e3, r3, n3)) : tt(i4, e3, r3));
            }(t4.sources, e2.sources, i3, n2);
            const a2 = [];
            t4.layers && t4.layers.forEach((t5) => {
              n2[t5.source] ? r2.push({ command: Q.removeLayer, args: [t5.id] }) : a2.push(t5);
            }), r2 = r2.concat(i3), function(t5, e3, r3) {
              e3 = e3 || [];
              const n3 = (t5 = t5 || []).map(at), i4 = e3.map(at), a3 = t5.reduce(st, {}), s2 = e3.reduce(st, {}), o2 = n3.slice(), l2 = /* @__PURE__ */ Object.create(null);
              let u2, c2, h2, p2, f2, d2, y2;
              for (u2 = 0, c2 = 0; u2 < n3.length; u2++)
                h2 = n3[u2], Object.prototype.hasOwnProperty.call(s2, h2) ? c2++ : (r3.push({ command: Q.removeLayer, args: [h2] }), o2.splice(o2.indexOf(h2, c2), 1));
              for (u2 = 0, c2 = 0; u2 < i4.length; u2++)
                h2 = i4[i4.length - 1 - u2], o2[o2.length - 1 - u2] !== h2 && (Object.prototype.hasOwnProperty.call(a3, h2) ? (r3.push({ command: Q.removeLayer, args: [h2] }), o2.splice(o2.lastIndexOf(h2, o2.length - c2), 1)) : c2++, d2 = o2[o2.length - u2], r3.push({ command: Q.addLayer, args: [s2[h2], d2] }), o2.splice(o2.length - u2, 0, h2), l2[h2] = true);
              for (u2 = 0; u2 < i4.length; u2++)
                if (h2 = i4[u2], p2 = a3[h2], f2 = s2[h2], !l2[h2] && !W(p2, f2))
                  if (W(p2.source, f2.source) && W(p2["source-layer"], f2["source-layer"]) && W(p2.type, f2.type)) {
                    for (y2 in it(p2.layout, f2.layout, r3, h2, null, Q.setLayoutProperty), it(p2.paint, f2.paint, r3, h2, null, Q.setPaintProperty), W(p2.filter, f2.filter) || r3.push({ command: Q.setFilter, args: [h2, f2.filter] }), W(p2.minzoom, f2.minzoom) && W(p2.maxzoom, f2.maxzoom) || r3.push({ command: Q.setLayerZoomRange, args: [h2, f2.minzoom, f2.maxzoom] }), p2)
                      Object.prototype.hasOwnProperty.call(p2, y2) && "layout" !== y2 && "paint" !== y2 && "filter" !== y2 && "metadata" !== y2 && "minzoom" !== y2 && "maxzoom" !== y2 && (0 === y2.indexOf("paint.") ? it(p2[y2], f2[y2], r3, h2, y2.slice(6), Q.setPaintProperty) : W(p2[y2], f2[y2]) || r3.push({ command: Q.setLayerProperty, args: [h2, y2, f2[y2]] }));
                    for (y2 in f2)
                      Object.prototype.hasOwnProperty.call(f2, y2) && !Object.prototype.hasOwnProperty.call(p2, y2) && "layout" !== y2 && "paint" !== y2 && "filter" !== y2 && "metadata" !== y2 && "minzoom" !== y2 && "maxzoom" !== y2 && (0 === y2.indexOf("paint.") ? it(p2[y2], f2[y2], r3, h2, y2.slice(6), Q.setPaintProperty) : W(p2[y2], f2[y2]) || r3.push({ command: Q.setLayerProperty, args: [h2, y2, f2[y2]] }));
                  } else
                    r3.push({ command: Q.removeLayer, args: [h2] }), d2 = o2[o2.lastIndexOf(h2) + 1], r3.push({ command: Q.addLayer, args: [f2, d2] });
            }(a2, e2.layers, r2);
          } catch (t5) {
            console.warn("Unable to compute style diff:", t5), r2 = [{ command: Q.setStyle, args: [e2] }];
          }
          return r2;
        }, t.aF = function(t4) {
          const e2 = [], r2 = t4.id;
          return void 0 === r2 && e2.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t4.render && e2.push({ message: `layers.${r2}: missing required method "render"` }), t4.renderingMode && "2d" !== t4.renderingMode && "3d" !== t4.renderingMode && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
        }, t.aG = function t4(e2, r2) {
          if (Array.isArray(e2)) {
            if (!Array.isArray(r2) || e2.length !== r2.length)
              return false;
            for (let n2 = 0; n2 < e2.length; n2++)
              if (!t4(e2[n2], r2[n2]))
                return false;
            return true;
          }
          if ("object" == typeof e2 && null !== e2 && null !== r2) {
            if ("object" != typeof r2)
              return false;
            if (Object.keys(e2).length !== Object.keys(r2).length)
              return false;
            for (const n2 in e2)
              if (!t4(e2[n2], r2[n2]))
                return false;
            return true;
          }
          return e2 === r2;
        }, t.aH = v, t.aI = b, t.aJ = ii, t.aK = function(t4) {
          return t4({ pluginStatus: ti, pluginURL: ei }), ii.on("pluginStateChange", t4), t4;
        }, t.aL = class extends Ra {
          constructor(t4, e2) {
            super(t4, e2), this.current = 0;
          }
          set(t4) {
            this.current !== t4 && (this.current = t4, this.gl.uniform1i(this.location, t4));
          }
        }, t.aM = qa, t.aN = class extends Ra {
          constructor(t4, e2) {
            super(t4, e2), this.current = Za;
          }
          set(t4) {
            if (t4[12] !== this.current[12] || t4[0] !== this.current[0])
              return this.current = t4, void this.gl.uniformMatrix4fv(this.location, false, t4);
            for (let e2 = 1; e2 < 16; e2++)
              if (t4[e2] !== this.current[e2]) {
                this.current = t4, this.gl.uniformMatrix4fv(this.location, false, t4);
                break;
              }
          }
        }, t.aO = ja, t.aP = class extends Ra {
          constructor(t4, e2) {
            super(t4, e2), this.current = [0, 0, 0];
          }
          set(t4) {
            t4[0] === this.current[0] && t4[1] === this.current[1] && t4[2] === this.current[2] || (this.current = t4, this.gl.uniform3f(this.location, t4[0], t4[1], t4[2]));
          }
        }, t.aQ = class extends Ra {
          constructor(t4, e2) {
            super(t4, e2), this.current = [0, 0];
          }
          set(t4) {
            t4[0] === this.current[0] && t4[1] === this.current[1] || (this.current = t4, this.gl.uniform2f(this.location, t4[0], t4[1]));
          }
        }, t.aR = Na, t.aS = function(t4, e2, r2, n2, i3, a2, s2) {
          var o2 = 1 / (e2 - r2), l2 = 1 / (n2 - i3), u2 = 1 / (a2 - s2);
          return t4[0] = -2 * o2, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = -2 * l2, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = 2 * u2, t4[11] = 0, t4[12] = (e2 + r2) * o2, t4[13] = (i3 + n2) * l2, t4[14] = (s2 + a2) * u2, t4[15] = 1, t4;
        }, t.aT = Yt, t.aU = Ps, t.aV = class extends qi {
        }, t.aW = Cl, t.aX = class extends Ni {
        }, t.aY = function(t4) {
          return t4 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t4) / Math.LN2));
        }, t.aZ = js, t.a_ = ha, t.aa = function(t4) {
          const e2 = {};
          if (t4.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t5, r2, n2, i3) => {
            const a2 = n2 || i3;
            return e2[r2] = !a2 || a2.toLowerCase(), "";
          }), e2["max-age"]) {
            const t5 = parseInt(e2["max-age"], 10);
            isNaN(t5) ? delete e2["max-age"] : e2["max-age"] = t5;
          }
          return e2;
        }, t.ab = function(t4, e2) {
          const r2 = [];
          for (const n2 in t4)
            n2 in e2 || r2.push(n2);
          return r2;
        }, t.ac = function(t4) {
          if (null == z) {
            const e2 = t4.navigator ? t4.navigator.userAgent : null;
            z = !!t4.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
          }
          return z;
        }, t.ad = y, t.ae = function(t4, e2, r2) {
          var n2 = Math.sin(r2), i3 = Math.cos(r2), a2 = e2[0], s2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
          return e2 !== t4 && (t4[8] = e2[8], t4[9] = e2[9], t4[10] = e2[10], t4[11] = e2[11], t4[12] = e2[12], t4[13] = e2[13], t4[14] = e2[14], t4[15] = e2[15]), t4[0] = a2 * i3 + u2 * n2, t4[1] = s2 * i3 + c2 * n2, t4[2] = o2 * i3 + h2 * n2, t4[3] = l2 * i3 + p2 * n2, t4[4] = u2 * i3 - a2 * n2, t4[5] = c2 * i3 - s2 * n2, t4[6] = h2 * i3 - o2 * n2, t4[7] = p2 * i3 - l2 * n2, t4;
        }, t.af = function(t4) {
          var e2 = new zs(16);
          return e2[0] = t4[0], e2[1] = t4[1], e2[2] = t4[2], e2[3] = t4[3], e2[4] = t4[4], e2[5] = t4[5], e2[6] = t4[6], e2[7] = t4[7], e2[8] = t4[8], e2[9] = t4[9], e2[10] = t4[10], e2[11] = t4[11], e2[12] = t4[12], e2[13] = t4[13], e2[14] = t4[14], e2[15] = t4[15], e2;
        }, t.ag = Vs, t.ah = function(t4, e2) {
          let r2 = 0, n2 = 0;
          if ("constant" === t4.kind)
            n2 = t4.layoutSize;
          else if ("source" !== t4.kind) {
            const { interpolationType: i3, minZoom: a2, maxZoom: s2 } = t4, o2 = i3 ? y(Ke.interpolationFactor(i3, e2, a2, s2), 0, 1) : 0;
            "camera" === t4.kind ? n2 = Ze.number(t4.minSize, t4.maxSize, o2) : r2 = o2;
          }
          return { uSizeT: r2, uSize: n2 };
        }, t.aj = function(t4, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i3 }) {
          return "source" === t4.kind ? n2 / Cu : "composite" === t4.kind ? Ze.number(n2 / Cu, i3 / Cu, r2) : e2;
        }, t.ak = $u, t.al = function(t4, e2, r2, n2) {
          const i3 = e2.y - t4.y, s2 = e2.x - t4.x, o2 = n2.y - r2.y, l2 = n2.x - r2.x, u2 = o2 * s2 - l2 * i3;
          if (0 === u2)
            return null;
          const c2 = (l2 * (t4.y - r2.y) - o2 * (t4.x - r2.x)) / u2;
          return new a(t4.x + c2 * s2, t4.y + c2 * i3);
        }, t.am = _c, t.an = us, t.ao = Ms, t.ap = Vl, t.ar = Vu, t.as = function(t4, e2) {
          var r2 = e2[0], n2 = e2[1], i3 = e2[2], a2 = e2[3], s2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], y2 = e2[13], m2 = e2[14], g2 = e2[15], x3 = r2 * o2 - n2 * s2, v2 = r2 * l2 - i3 * s2, b2 = r2 * u2 - a2 * s2, w2 = n2 * l2 - i3 * o2, _2 = n2 * u2 - a2 * o2, A3 = i3 * u2 - a2 * l2, S2 = c2 * y2 - h2 * d2, k2 = c2 * m2 - p2 * d2, I2 = c2 * g2 - f2 * d2, z2 = h2 * m2 - p2 * y2, M2 = h2 * g2 - f2 * y2, C3 = p2 * g2 - f2 * m2, B3 = x3 * C3 - v2 * M2 + b2 * z2 + w2 * I2 - _2 * k2 + A3 * S2;
          return B3 ? (t4[0] = (o2 * C3 - l2 * M2 + u2 * z2) * (B3 = 1 / B3), t4[1] = (i3 * M2 - n2 * C3 - a2 * z2) * B3, t4[2] = (y2 * A3 - m2 * _2 + g2 * w2) * B3, t4[3] = (p2 * _2 - h2 * A3 - f2 * w2) * B3, t4[4] = (l2 * I2 - s2 * C3 - u2 * k2) * B3, t4[5] = (r2 * C3 - i3 * I2 + a2 * k2) * B3, t4[6] = (m2 * b2 - d2 * A3 - g2 * v2) * B3, t4[7] = (c2 * A3 - p2 * b2 + f2 * v2) * B3, t4[8] = (s2 * M2 - o2 * I2 + u2 * S2) * B3, t4[9] = (n2 * I2 - r2 * M2 - a2 * S2) * B3, t4[10] = (d2 * _2 - y2 * b2 + g2 * x3) * B3, t4[11] = (h2 * b2 - c2 * _2 - f2 * x3) * B3, t4[12] = (o2 * k2 - s2 * z2 - l2 * S2) * B3, t4[13] = (r2 * z2 - n2 * k2 + i3 * S2) * B3, t4[14] = (y2 * v2 - d2 * w2 - m2 * x3) * B3, t4[15] = (c2 * w2 - h2 * v2 + p2 * x3) * B3, t4) : null;
        }, t.at = Jc, t.au = Su, t.av = th, t.aw = function() {
          const t4 = {}, e2 = X.$version;
          for (const r2 in X.$root) {
            const n2 = X.$root[r2];
            if (n2.required) {
              let i3 = null;
              i3 = "version" === r2 ? e2 : "array" === n2.type ? [] : {}, null != i3 && (t4[r2] = i3);
            }
          }
          return t4;
        }, t.ax = Q, t.ay = Un, t.az = D2, t.b = function(t4, e2) {
          const r2 = new Blob([new Uint8Array(t4)], { type: "image/png" });
          createImageBitmap(r2).then((t5) => {
            e2(null, t5);
          }).catch((t5) => {
            e2(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
          });
        }, t.b0 = Aa, t.b1 = function(t4, e2) {
          var r2 = t4[0], n2 = t4[1], i3 = t4[2], a2 = t4[3], s2 = t4[4], o2 = t4[5], l2 = t4[6], u2 = t4[7], c2 = t4[8], h2 = t4[9], p2 = t4[10], f2 = t4[11], d2 = t4[12], y2 = t4[13], m2 = t4[14], g2 = t4[15], x3 = e2[0], v2 = e2[1], b2 = e2[2], w2 = e2[3], _2 = e2[4], A3 = e2[5], S2 = e2[6], k2 = e2[7], I2 = e2[8], z2 = e2[9], M2 = e2[10], C3 = e2[11], B3 = e2[12], P2 = e2[13], V2 = e2[14], E3 = e2[15];
          return Math.abs(r2 - x3) <= Is * Math.max(1, Math.abs(r2), Math.abs(x3)) && Math.abs(n2 - v2) <= Is * Math.max(1, Math.abs(n2), Math.abs(v2)) && Math.abs(i3 - b2) <= Is * Math.max(1, Math.abs(i3), Math.abs(b2)) && Math.abs(a2 - w2) <= Is * Math.max(1, Math.abs(a2), Math.abs(w2)) && Math.abs(s2 - _2) <= Is * Math.max(1, Math.abs(s2), Math.abs(_2)) && Math.abs(o2 - A3) <= Is * Math.max(1, Math.abs(o2), Math.abs(A3)) && Math.abs(l2 - S2) <= Is * Math.max(1, Math.abs(l2), Math.abs(S2)) && Math.abs(u2 - k2) <= Is * Math.max(1, Math.abs(u2), Math.abs(k2)) && Math.abs(c2 - I2) <= Is * Math.max(1, Math.abs(c2), Math.abs(I2)) && Math.abs(h2 - z2) <= Is * Math.max(1, Math.abs(h2), Math.abs(z2)) && Math.abs(p2 - M2) <= Is * Math.max(1, Math.abs(p2), Math.abs(M2)) && Math.abs(f2 - C3) <= Is * Math.max(1, Math.abs(f2), Math.abs(C3)) && Math.abs(d2 - B3) <= Is * Math.max(1, Math.abs(d2), Math.abs(B3)) && Math.abs(y2 - P2) <= Is * Math.max(1, Math.abs(y2), Math.abs(P2)) && Math.abs(m2 - V2) <= Is * Math.max(1, Math.abs(m2), Math.abs(V2)) && Math.abs(g2 - E3) <= Is * Math.max(1, Math.abs(g2), Math.abs(E3));
        }, t.b2 = function(t4, e2) {
          return t4[0] = e2[0], t4[1] = e2[1], t4[2] = e2[2], t4[3] = e2[3], t4[4] = e2[4], t4[5] = e2[5], t4[6] = e2[6], t4[7] = e2[7], t4[8] = e2[8], t4[9] = e2[9], t4[10] = e2[10], t4[11] = e2[11], t4[12] = e2[12], t4[13] = e2[13], t4[14] = e2[14], t4[15] = e2[15], t4;
        }, t.b3 = function(t4, e2, r2) {
          return t4[0] = e2[0] * r2[0], t4[1] = e2[1] * r2[1], t4[2] = e2[2] * r2[2], t4[3] = e2[3] * r2[3], t4;
        }, t.b4 = function(t4, e2) {
          return t4[0] * e2[0] + t4[1] * e2[1] + t4[2] * e2[2] + t4[3] * e2[3];
        }, t.b5 = m, t.b6 = pc, t.b7 = sc, t.b8 = function(t4, e2, r2, n2, i3) {
          var a2, s2 = 1 / Math.tan(e2 / 2);
          return t4[0] = s2 / r2, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = s2, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[11] = -1, t4[12] = 0, t4[13] = 0, t4[15] = 0, null != i3 && i3 !== 1 / 0 ? (t4[10] = (i3 + n2) * (a2 = 1 / (n2 - i3)), t4[14] = 2 * i3 * n2 * a2) : (t4[10] = -1, t4[14] = -2 * n2), t4;
        }, t.b9 = function(t4, e2, r2) {
          var n2 = Math.sin(r2), i3 = Math.cos(r2), a2 = e2[4], s2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
          return e2 !== t4 && (t4[0] = e2[0], t4[1] = e2[1], t4[2] = e2[2], t4[3] = e2[3], t4[12] = e2[12], t4[13] = e2[13], t4[14] = e2[14], t4[15] = e2[15]), t4[4] = a2 * i3 + u2 * n2, t4[5] = s2 * i3 + c2 * n2, t4[6] = o2 * i3 + h2 * n2, t4[7] = l2 * i3 + p2 * n2, t4[8] = u2 * i3 - a2 * n2, t4[9] = c2 * i3 - s2 * n2, t4[10] = h2 * i3 - o2 * n2, t4[11] = p2 * i3 - l2 * n2, t4;
        }, t.bA = n, t.bB = El, t.bC = $r, t.bD = oi, t.ba = f, t.bb = d, t.bc = function(t4, e2) {
          return t4[0] = e2[0], t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = e2[1], t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = e2[2], t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4;
        }, t.bd = class extends Pi {
        }, t.be = tc, t.bf = oc, t.bg = ph, t.bi = L2, t.bj = function(t4, e2, r2 = false) {
          if (ti === Yn2 || ti === Hn || ti === Wn)
            throw new Error("setRTLTextPlugin cannot be called multiple times.");
          ei = T2.resolveURL(t4), ti = Yn2, Qn = e2, ni(), r2 || si();
        }, t.bk = ai, t.bl = function(t4, e2) {
          const r2 = {};
          for (let n3 = 0; n3 < t4.length; n3++) {
            const i3 = e2 && e2[t4[n3].id] || Qr(t4[n3]);
            e2 && (e2[t4[n3].id] = i3);
            let a2 = r2[i3];
            a2 || (a2 = r2[i3] = []), a2.push(t4[n3]);
          }
          const n2 = [];
          for (const t5 in r2)
            n2.push(r2[t5]);
          return n2;
        }, t.bm = $n, t.bn = mc, t.bo = xc, t.bp = cu, t.bq = function(e2) {
          e2.bucket.createArrays(), e2.bucket.tilePixelRatio = rs / (512 * e2.bucket.overscaling), e2.bucket.compareText = {}, e2.bucket.iconsNeedLinear = false;
          const r2 = e2.bucket.layers[0], n2 = r2.layout, i3 = r2._unevaluatedLayout._values, a2 = { layoutIconSize: i3["icon-size"].possiblyEvaluate(new li(e2.bucket.zoom + 1), e2.canonical), layoutTextSize: i3["text-size"].possiblyEvaluate(new li(e2.bucket.zoom + 1), e2.canonical), textMaxSize: i3["text-size"].possiblyEvaluate(new li(18)) };
          if ("composite" === e2.bucket.textSizeData.kind) {
            const { minZoom: t4, maxZoom: r3 } = e2.bucket.textSizeData;
            a2.compositeTextSizes = [i3["text-size"].possiblyEvaluate(new li(t4), e2.canonical), i3["text-size"].possiblyEvaluate(new li(r3), e2.canonical)];
          }
          if ("composite" === e2.bucket.iconSizeData.kind) {
            const { minZoom: t4, maxZoom: r3 } = e2.bucket.iconSizeData;
            a2.compositeIconSizes = [i3["icon-size"].possiblyEvaluate(new li(t4), e2.canonical), i3["icon-size"].possiblyEvaluate(new li(r3), e2.canonical)];
          }
          const s2 = n2.get("text-line-height") * Vl, o2 = "viewport" !== n2.get("text-rotation-alignment") && "point" !== n2.get("symbol-placement"), l2 = n2.get("text-keep-upright"), u2 = n2.get("text-size");
          for (const i4 of e2.bucket.features) {
            const c2 = n2.get("text-font").evaluate(i4, {}, e2.canonical).join(","), h2 = u2.evaluate(i4, {}, e2.canonical), p2 = a2.layoutTextSize.evaluate(i4, {}, e2.canonical), f2 = a2.layoutIconSize.evaluate(i4, {}, e2.canonical), d2 = { horizontal: {}, vertical: void 0 }, y2 = i4.text;
            let m2, g2 = [0, 0];
            if (y2) {
              const a3 = y2.toString(), u3 = n2.get("text-letter-spacing").evaluate(i4, {}, e2.canonical) * Vl, f3 = jn(a3) ? u3 : 0, m3 = n2.get("text-anchor").evaluate(i4, {}, e2.canonical), x4 = Gc(r2, i4, e2.canonical);
              if (!x4) {
                const t4 = n2.get("text-radial-offset").evaluate(i4, {}, e2.canonical);
                g2 = t4 ? Kc(m3, [t4 * Vl, Zc]) : n2.get("text-offset").evaluate(i4, {}, e2.canonical).map((t5) => t5 * Vl);
              }
              let v3 = o2 ? "center" : n2.get("text-justify").evaluate(i4, {}, e2.canonical);
              const b2 = n2.get("symbol-placement"), w2 = "point" === b2 ? n2.get("text-max-width").evaluate(i4, {}, e2.canonical) * Vl : 0, _2 = () => {
                e2.bucket.allowVerticalPlacement && qn(a3) && (d2.vertical = yu(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, w2, s2, m3, "left", f3, g2, t.ai.vertical, true, b2, p2, h2));
              };
              if (!o2 && x4) {
                const r3 = /* @__PURE__ */ new Set();
                if ("auto" === v3)
                  for (let t4 = 0; t4 < x4.values.length; t4 += 2)
                    r3.add(Jc(x4.values[t4]));
                else
                  r3.add(v3);
                let n3 = false;
                for (const i5 of r3)
                  if (!d2.horizontal[i5])
                    if (n3)
                      d2.horizontal[i5] = d2.horizontal[0];
                    else {
                      const r4 = yu(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, w2, s2, "center", i5, f3, g2, t.ai.horizontal, false, b2, p2, h2);
                      r4 && (d2.horizontal[i5] = r4, n3 = 1 === r4.positionedLines.length);
                    }
                _2();
              } else {
                "auto" === v3 && (v3 = Jc(m3));
                const r3 = yu(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, w2, s2, m3, v3, f3, g2, t.ai.horizontal, false, b2, p2, h2);
                r3 && (d2.horizontal[v3] = r3), _2(), qn(a3) && o2 && l2 && (d2.vertical = yu(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, w2, s2, m3, v3, f3, g2, t.ai.vertical, false, b2, p2, h2));
              }
            }
            let x3 = false;
            if (i4.icon && i4.icon.name) {
              const t4 = e2.imageMap[i4.icon.name];
              t4 && (m2 = Iu(e2.imagePositions[i4.icon.name], n2.get("icon-offset").evaluate(i4, {}, e2.canonical), n2.get("icon-anchor").evaluate(i4, {}, e2.canonical)), x3 = !!t4.sdf, void 0 === e2.bucket.sdfIcons ? e2.bucket.sdfIcons = x3 : e2.bucket.sdfIcons !== x3 && A2("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t4.pixelRatio !== e2.bucket.pixelRatio || 0 !== n2.get("icon-rotate").constantOr(1)) && (e2.bucket.iconsNeedLinear = true));
            }
            const v2 = Hc(d2.horizontal) || d2.vertical;
            e2.bucket.iconsInText = !!v2 && v2.iconsInText, (v2 || m2) && Xc(e2.bucket, i4, d2, m2, e2.imageMap, a2, p2, f2, g2, x3, e2.canonical);
          }
          e2.showCollisionBoxes && e2.bucket.generateCollisionDebugBuffers();
        }, t.br = gl2, t.bs = Eo, t.bt = rl, t.bu = class {
          constructor(t4) {
            this._marks = { start: [t4.url, "start"].join("#"), end: [t4.url, "end"].join("#"), measure: t4.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let t4 = performance.getEntriesByName(this._marks.measure);
            return 0 === t4.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t4 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t4;
          }
        }, t.bv = eu, t.bw = Ro, t.bx = function(t4, r2, n2, i3, a2) {
          return e(this, void 0, void 0, function* () {
            if (p())
              try {
                return yield B2(t4, r2, n2, i3, a2);
              } catch (t5) {
              }
            return function(t5, e2, r3, n3, i4) {
              const a3 = t5.width, s2 = t5.height;
              P && V || (P = new OffscreenCanvas(a3, s2), V = P.getContext("2d", { willReadFrequently: true })), P.width = a3, P.height = s2, V.drawImage(t5, 0, 0, a3, s2);
              const o2 = V.getImageData(e2, r3, n3, i4);
              return V.clearRect(0, 0, a3, s2), o2.data;
            }(t4, r2, n2, i3, a2);
          });
        }, t.by = yc, t.bz = r, t.c = $, t.d = function(t4, e2) {
          const r2 = new Image();
          r2.onload = () => {
            e2(null, r2), URL.revokeObjectURL(r2.src), r2.onload = null, window.requestAnimationFrame(() => {
              r2.src = C2;
            });
          }, r2.onerror = () => e2(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const n2 = new Blob([new Uint8Array(t4)], { type: "image/png" });
          r2.src = t4.byteLength ? URL.createObjectURL(n2) : C2;
        }, t.e = g, t.f = function(t4, e2) {
          return R(g(t4, { type: "json" }), e2);
        }, t.g = O, t.h = T2, t.i = I, t.j = G, t.k = K2, t.l = q, t.m = R, t.n = function(t4) {
          return new eu(t4).readFields(nu, []);
        }, t.o = function(t4, e2, r2) {
          if (!t4.length)
            return r2(null, []);
          let n2 = t4.length;
          const i3 = new Array(t4.length);
          let a2 = null;
          t4.forEach((t5, s2) => {
            e2(t5, (t6, e3) => {
              t6 && (a2 = t6), i3[s2] = e3, 0 == --n2 && r2(a2, i3);
            });
          });
        }, t.p = ou, t.q = Rs, t.r = _i, t.s = j, t.t = Bn, t.u = Rn, t.v = X, t.w = A2, t.x = En, t.y = Cn, t.z = function([t4, e2, r2]) {
          return e2 += 90, e2 *= Math.PI / 180, r2 *= Math.PI / 180, { x: t4 * Math.cos(e2) * Math.sin(r2), y: t4 * Math.sin(e2) * Math.sin(r2), z: t4 * Math.cos(r2) };
        };
      });
      define2(["./shared"], function(e) {
        "use strict";
        class t {
          constructor(e2) {
            this.keyCache = {}, e2 && this.replace(e2);
          }
          replace(e2) {
            this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
          }
          update(t4, i3) {
            for (const i4 of t4) {
              this._layerConfigs[i4.id] = i4;
              const t5 = this._layers[i4.id] = e.aC(i4);
              t5._featureFilter = e.a6(t5.filter), this.keyCache[i4.id] && delete this.keyCache[i4.id];
            }
            for (const e2 of i3)
              delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
            this.familiesBySource = {};
            const o2 = e.bl(Object.values(this._layerConfigs), this.keyCache);
            for (const e2 of o2) {
              const t5 = e2.map((e3) => this._layers[e3.id]), i4 = t5[0];
              if ("none" === i4.visibility)
                continue;
              const o3 = i4.source || "";
              let r2 = this.familiesBySource[o3];
              r2 || (r2 = this.familiesBySource[o3] = {});
              const s2 = i4.sourceLayer || "_geojsonTileLayer";
              let n2 = r2[s2];
              n2 || (n2 = r2[s2] = []), n2.push(t5);
            }
          }
        }
        class i2 {
          constructor(t4) {
            const i3 = {}, o2 = [];
            for (const e2 in t4) {
              const r3 = t4[e2], s3 = i3[e2] = {};
              for (const e3 in r3) {
                const t5 = r3[+e3];
                if (!t5 || 0 === t5.bitmap.width || 0 === t5.bitmap.height)
                  continue;
                const i4 = { x: 0, y: 0, w: t5.bitmap.width + 2, h: t5.bitmap.height + 2 };
                o2.push(i4), s3[e3] = { rect: i4, metrics: t5.metrics };
              }
            }
            const { w: r2, h: s2 } = e.p(o2), n2 = new e.q({ width: r2 || 1, height: s2 || 1 });
            for (const o3 in t4) {
              const r3 = t4[o3];
              for (const t5 in r3) {
                const s3 = r3[+t5];
                if (!s3 || 0 === s3.bitmap.width || 0 === s3.bitmap.height)
                  continue;
                const a2 = i3[o3][t5].rect;
                e.q.copy(s3.bitmap, n2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, s3.bitmap);
              }
            }
            this.image = n2, this.positions = i3;
          }
        }
        e.bm("GlyphAtlas", i2);
        class o {
          constructor(t4) {
            this.tileID = new e.O(t4.tileID.overscaledZ, t4.tileID.wrap, t4.tileID.canonical.z, t4.tileID.canonical.x, t4.tileID.canonical.y), this.uid = t4.uid, this.zoom = t4.zoom, this.pixelRatio = t4.pixelRatio, this.tileSize = t4.tileSize, this.source = t4.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t4.showCollisionBoxes, this.collectResourceTiming = !!t4.collectResourceTiming, this.returnDependencies = !!t4.returnDependencies, this.promoteId = t4.promoteId, this.inFlightDependencies = [], this.dependencySentinel = -1;
          }
          parse(t4, o2, s2, n2, a2) {
            this.status = "parsing", this.data = t4, this.collisionBoxArray = new e.a3();
            const l2 = new e.bn(Object.keys(t4.layers).sort()), c2 = new e.bo(this.tileID, this.promoteId);
            c2.bucketLayerIDs = [];
            const h2 = {}, u2 = { featureIndex: c2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: s2 }, d2 = o2.familiesBySource[this.source];
            for (const i3 in d2) {
              const o3 = t4.layers[i3];
              if (!o3)
                continue;
              1 === o3.version && e.w(`Vector tile source "${this.source}" layer "${i3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const n3 = l2.encode(i3), a3 = [];
              for (let e2 = 0; e2 < o3.length; e2++) {
                const t5 = o3.feature(e2), r2 = c2.getId(t5, i3);
                a3.push({ feature: t5, id: r2, index: e2, sourceLayerIndex: n3 });
              }
              for (const t5 of d2[i3]) {
                const i4 = t5[0];
                i4.source !== this.source && e.w(`layer.source = ${i4.source} does not equal this.source = ${this.source}`), i4.minzoom && this.zoom < Math.floor(i4.minzoom) || i4.maxzoom && this.zoom >= i4.maxzoom || "none" !== i4.visibility && (r(t5, this.zoom, s2), (h2[i4.id] = i4.createBucket({ index: c2.bucketLayerIDs.length, layers: t5, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n3, sourceID: this.source })).populate(a3, u2, this.tileID.canonical), c2.bucketLayerIDs.push(t5.map((e2) => e2.id)));
              }
            }
            let p2, f2, g2, m2;
            const y2 = e.aH(u2.glyphDependencies, (e2) => Object.keys(e2).map(Number));
            this.inFlightDependencies.forEach((e2) => null == e2 ? void 0 : e2.cancel()), this.inFlightDependencies = [];
            const v2 = ++this.dependencySentinel;
            Object.keys(y2).length ? this.inFlightDependencies.push(n2.send("getGlyphs", { uid: this.uid, stacks: y2, source: this.source, tileID: this.tileID, type: "glyphs" }, (e2, t5) => {
              v2 === this.dependencySentinel && (p2 || (p2 = e2, f2 = t5, b2.call(this)));
            })) : f2 = {};
            const w2 = Object.keys(u2.iconDependencies);
            w2.length ? this.inFlightDependencies.push(n2.send("getImages", { icons: w2, source: this.source, tileID: this.tileID, type: "icons" }, (e2, t5) => {
              v2 === this.dependencySentinel && (p2 || (p2 = e2, g2 = t5, b2.call(this)));
            })) : g2 = {};
            const x3 = Object.keys(u2.patternDependencies);
            function b2() {
              if (p2)
                return a2(p2);
              if (f2 && g2 && m2) {
                const t5 = new i2(f2), o3 = new e.bp(g2, m2);
                for (const i3 in h2) {
                  const n3 = h2[i3];
                  n3 instanceof e.a4 ? (r(n3.layers, this.zoom, s2), e.bq({ bucket: n3, glyphMap: f2, glyphPositions: t5.positions, imageMap: g2, imagePositions: o3.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : n3.hasPattern && (n3 instanceof e.br || n3 instanceof e.bs || n3 instanceof e.bt) && (r(n3.layers, this.zoom, s2), n3.addFeatures(u2, this.tileID.canonical, o3.patternPositions));
                }
                this.status = "done", a2(null, { buckets: Object.values(h2).filter((e2) => !e2.isEmpty()), featureIndex: c2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t5.image, imageAtlas: o3, glyphMap: this.returnDependencies ? f2 : null, iconMap: this.returnDependencies ? g2 : null, glyphPositions: this.returnDependencies ? t5.positions : null });
              }
            }
            x3.length ? this.inFlightDependencies.push(n2.send("getImages", { icons: x3, source: this.source, tileID: this.tileID, type: "patterns" }, (e2, t5) => {
              v2 === this.dependencySentinel && (p2 || (p2 = e2, m2 = t5, b2.call(this)));
            })) : m2 = {}, b2.call(this);
          }
        }
        function r(t4, i3, o2) {
          const r2 = new e.a8(i3);
          for (const e2 of t4)
            e2.recalculate(r2, o2);
        }
        function s(t4, i3) {
          const o2 = e.l(t4.request, (o3, r2, s2, n2) => {
            if (o3)
              i3(o3);
            else if (r2)
              try {
                const t5 = new e.bw.VectorTile(new e.bv(r2));
                i3(null, { vectorTile: t5, rawData: r2, cacheControl: s2, expires: n2 });
              } catch (e2) {
                const o4 = new Uint8Array(r2);
                let s3 = `Unable to parse the tile at ${t4.request.url}, `;
                s3 += 31 === o4[0] && 139 === o4[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e2.messge}`, i3(new Error(s3));
              }
          });
          return () => {
            o2.cancel(), i3();
          };
        }
        class n {
          constructor(e2, t4, i3, o2) {
            this.actor = e2, this.layerIndex = t4, this.availableImages = i3, this.loadVectorData = o2 || s, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadTile(t4, i3) {
            const r2 = t4.uid;
            this.loading || (this.loading = {});
            const s2 = !!(t4 && t4.request && t4.request.collectResourceTiming) && new e.bu(t4.request), n2 = this.loading[r2] = new o(t4);
            n2.abort = this.loadVectorData(t4, (t5, o2) => {
              if (delete this.loading[r2], t5 || !o2)
                return n2.status = "done", this.loaded[r2] = n2, i3(t5);
              const a2 = o2.rawData, l2 = {};
              o2.expires && (l2.expires = o2.expires), o2.cacheControl && (l2.cacheControl = o2.cacheControl);
              const c2 = {};
              if (s2) {
                const e2 = s2.finish();
                e2 && (c2.resourceTiming = JSON.parse(JSON.stringify(e2)));
              }
              n2.vectorTile = o2.vectorTile, n2.parse(o2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t6, o3) => {
                if (delete this.fetching[r2], t6 || !o3)
                  return i3(t6);
                i3(null, e.e({ rawTileData: a2.slice(0) }, o3, l2, c2));
              }), this.loaded = this.loaded || {}, this.loaded[r2] = n2, this.fetching[r2] = { rawTileData: a2, cacheControl: l2, resourceTiming: c2 };
            });
          }
          reloadTile(t4, i3) {
            const o2 = this.loaded, r2 = t4.uid;
            if (o2 && o2[r2]) {
              const s2 = o2[r2];
              s2.showCollisionBoxes = t4.showCollisionBoxes, "parsing" === s2.status ? s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t5, o3) => {
                if (t5 || !o3)
                  return i3(t5, o3);
                let s3;
                if (this.fetching[r2]) {
                  const { rawTileData: t6, cacheControl: i4, resourceTiming: n2 } = this.fetching[r2];
                  delete this.fetching[r2], s3 = e.e({ rawTileData: t6.slice(0) }, o3, i4, n2);
                } else
                  s3 = o3;
                i3(null, s3);
              }) : "done" === s2.status && (s2.vectorTile ? s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, i3) : i3());
            }
          }
          abortTile(e2, t4) {
            const i3 = this.loading, o2 = e2.uid;
            i3 && i3[o2] && i3[o2].abort && (i3[o2].abort(), delete i3[o2]), t4();
          }
          removeTile(e2, t4) {
            const i3 = this.loaded, o2 = e2.uid;
            i3 && i3[o2] && delete i3[o2], t4();
          }
        }
        class a {
          constructor() {
            this.loaded = {};
          }
          loadTile(t4, i3) {
            return e._(this, void 0, void 0, function* () {
              const { uid: o2, encoding: r2, rawImageData: s2, redFactor: n2, greenFactor: a2, blueFactor: l2, baseShift: c2 } = t4, h2 = s2.width + 2, u2 = s2.height + 2, d2 = e.a(s2) ? new e.R({ width: h2, height: u2 }, yield e.bx(s2, -1, -1, h2, u2)) : s2, p2 = new e.by(o2, d2, r2, n2, a2, l2, c2);
              this.loaded = this.loaded || {}, this.loaded[o2] = p2, i3(null, p2);
            });
          }
          removeTile(e2) {
            const t4 = this.loaded, i3 = e2.uid;
            t4 && t4[i3] && delete t4[i3];
          }
        }
        function l(e2, t4) {
          if (0 !== e2.length) {
            c(e2[0], t4);
            for (var i3 = 1; i3 < e2.length; i3++)
              c(e2[i3], !t4);
          }
        }
        function c(e2, t4) {
          for (var i3 = 0, o2 = 0, r2 = 0, s2 = e2.length, n2 = s2 - 1; r2 < s2; n2 = r2++) {
            var a2 = (e2[r2][0] - e2[n2][0]) * (e2[n2][1] + e2[r2][1]), l2 = i3 + a2;
            o2 += Math.abs(i3) >= Math.abs(a2) ? i3 - l2 + a2 : a2 - l2 + i3, i3 = l2;
          }
          i3 + o2 >= 0 != !!t4 && e2.reverse();
        }
        var h = e.bz(function e2(t4, i3) {
          var o2, r2 = t4 && t4.type;
          if ("FeatureCollection" === r2)
            for (o2 = 0; o2 < t4.features.length; o2++)
              e2(t4.features[o2], i3);
          else if ("GeometryCollection" === r2)
            for (o2 = 0; o2 < t4.geometries.length; o2++)
              e2(t4.geometries[o2], i3);
          else if ("Feature" === r2)
            e2(t4.geometry, i3);
          else if ("Polygon" === r2)
            l(t4.coordinates, i3);
          else if ("MultiPolygon" === r2)
            for (o2 = 0; o2 < t4.coordinates.length; o2++)
              l(t4.coordinates[o2], i3);
          return t4;
        });
        const u = e.bw.VectorTileFeature.prototype.toGeoJSON;
        var d = { exports: {} }, p = e.bA, f = e.bw.VectorTileFeature, g = m;
        function m(e2, t4) {
          this.options = t4 || {}, this.features = e2, this.length = e2.length;
        }
        function y(e2, t4) {
          this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t4 || 4096;
        }
        m.prototype.feature = function(e2) {
          return new y(this.features[e2], this.options.extent);
        }, y.prototype.loadGeometry = function() {
          var e2 = this.rawGeometry;
          this.geometry = [];
          for (var t4 = 0; t4 < e2.length; t4++) {
            for (var i3 = e2[t4], o2 = [], r2 = 0; r2 < i3.length; r2++)
              o2.push(new p(i3[r2][0], i3[r2][1]));
            this.geometry.push(o2);
          }
          return this.geometry;
        }, y.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e2 = this.geometry, t4 = 1 / 0, i3 = -1 / 0, o2 = 1 / 0, r2 = -1 / 0, s2 = 0; s2 < e2.length; s2++)
            for (var n2 = e2[s2], a2 = 0; a2 < n2.length; a2++) {
              var l2 = n2[a2];
              t4 = Math.min(t4, l2.x), i3 = Math.max(i3, l2.x), o2 = Math.min(o2, l2.y), r2 = Math.max(r2, l2.y);
            }
          return [t4, o2, i3, r2];
        }, y.prototype.toGeoJSON = f.prototype.toGeoJSON;
        var v = e.bB, w = g;
        function x2(e2) {
          var t4 = new v();
          return function(e3, t5) {
            for (var i3 in e3.layers)
              t5.writeMessage(3, b, e3.layers[i3]);
          }(e2, t4), t4.finish();
        }
        function b(e2, t4) {
          var i3;
          t4.writeVarintField(15, e2.version || 1), t4.writeStringField(1, e2.name || ""), t4.writeVarintField(5, e2.extent || 4096);
          var o2 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (i3 = 0; i3 < e2.length; i3++)
            o2.feature = e2.feature(i3), t4.writeMessage(2, S, o2);
          var r2 = o2.keys;
          for (i3 = 0; i3 < r2.length; i3++)
            t4.writeStringField(3, r2[i3]);
          var s2 = o2.values;
          for (i3 = 0; i3 < s2.length; i3++)
            t4.writeMessage(4, _, s2[i3]);
        }
        function S(e2, t4) {
          var i3 = e2.feature;
          void 0 !== i3.id && t4.writeVarintField(1, i3.id), t4.writeMessage(2, M, e2), t4.writeVarintField(3, i3.type), t4.writeMessage(4, T2, i3);
        }
        function M(e2, t4) {
          var i3 = e2.feature, o2 = e2.keys, r2 = e2.values, s2 = e2.keycache, n2 = e2.valuecache;
          for (var a2 in i3.properties) {
            var l2 = i3.properties[a2], c2 = s2[a2];
            if (null !== l2) {
              void 0 === c2 && (o2.push(a2), s2[a2] = c2 = o2.length - 1), t4.writeVarint(c2);
              var h2 = typeof l2;
              "string" !== h2 && "boolean" !== h2 && "number" !== h2 && (l2 = JSON.stringify(l2));
              var u2 = h2 + ":" + l2, d2 = n2[u2];
              void 0 === d2 && (r2.push(l2), n2[u2] = d2 = r2.length - 1), t4.writeVarint(d2);
            }
          }
        }
        function I(e2, t4) {
          return (t4 << 3) + (7 & e2);
        }
        function P(e2) {
          return e2 << 1 ^ e2 >> 31;
        }
        function T2(e2, t4) {
          for (var i3 = e2.loadGeometry(), o2 = e2.type, r2 = 0, s2 = 0, n2 = i3.length, a2 = 0; a2 < n2; a2++) {
            var l2 = i3[a2], c2 = 1;
            1 === o2 && (c2 = l2.length), t4.writeVarint(I(1, c2));
            for (var h2 = 3 === o2 ? l2.length - 1 : l2.length, u2 = 0; u2 < h2; u2++) {
              1 === u2 && 1 !== o2 && t4.writeVarint(I(2, h2 - 1));
              var d2 = l2[u2].x - r2, p2 = l2[u2].y - s2;
              t4.writeVarint(P(d2)), t4.writeVarint(P(p2)), r2 += d2, s2 += p2;
            }
            3 === o2 && t4.writeVarint(I(7, 1));
          }
        }
        function _(e2, t4) {
          var i3 = typeof e2;
          "string" === i3 ? t4.writeStringField(1, e2) : "boolean" === i3 ? t4.writeBooleanField(7, e2) : "number" === i3 && (e2 % 1 != 0 ? t4.writeDoubleField(3, e2) : e2 < 0 ? t4.writeSVarintField(6, e2) : t4.writeVarintField(5, e2));
        }
        d.exports = x2, d.exports.fromVectorTileJs = x2, d.exports.fromGeojsonVt = function(e2, t4) {
          t4 = t4 || {};
          var i3 = {};
          for (var o2 in e2)
            i3[o2] = new w(e2[o2].features, t4), i3[o2].name = o2, i3[o2].version = t4.version, i3[o2].extent = t4.extent;
          return x2({ layers: i3 });
        }, d.exports.GeoJSONWrapper = w;
        var k = e.bz(d.exports);
        const D2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, O = Math.fround || (C2 = new Float32Array(1), (e2) => (C2[0] = +e2, C2[0]));
        var C2;
        const L2 = 3, F = 5, z = 6;
        class N {
          constructor(e2) {
            this.options = Object.assign(Object.create(D2), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(e2) {
            const { log: t4, minZoom: i3, maxZoom: o2 } = this.options;
            t4 && console.time("total time");
            const r2 = `prepare ${e2.length} points`;
            t4 && console.time(r2), this.points = e2;
            const s2 = [];
            for (let t5 = 0; t5 < e2.length; t5++) {
              const i4 = e2[t5];
              if (!i4.geometry)
                continue;
              const [o3, r3] = i4.geometry.coordinates, n3 = O(Z(o3)), a2 = O(G(r3));
              s2.push(n3, a2, 1 / 0, t5, -1, 1), this.options.reduce && s2.push(0);
            }
            let n2 = this.trees[o2 + 1] = this._createTree(s2);
            t4 && console.timeEnd(r2);
            for (let e3 = o2; e3 >= i3; e3--) {
              const i4 = +Date.now();
              n2 = this.trees[e3] = this._createTree(this._cluster(n2, e3)), t4 && console.log("z%d: %d clusters in %dms", e3, n2.numItems, +Date.now() - i4);
            }
            return t4 && console.timeEnd("total time"), this;
          }
          getClusters(e2, t4) {
            let i3 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
            const o2 = Math.max(-90, Math.min(90, e2[1]));
            let r2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
            const s2 = Math.max(-90, Math.min(90, e2[3]));
            if (e2[2] - e2[0] >= 360)
              i3 = -180, r2 = 180;
            else if (i3 > r2) {
              const e3 = this.getClusters([i3, o2, 180, s2], t4), n3 = this.getClusters([-180, o2, r2, s2], t4);
              return e3.concat(n3);
            }
            const n2 = this.trees[this._limitZoom(t4)], a2 = n2.range(Z(i3), G(s2), Z(r2), G(o2)), l2 = n2.data, c2 = [];
            for (const e3 of a2) {
              const t5 = this.stride * e3;
              c2.push(l2[t5 + F] > 1 ? E2(l2, t5, this.clusterProps) : this.points[l2[t5 + L2]]);
            }
            return c2;
          }
          getChildren(e2) {
            const t4 = this._getOriginId(e2), i3 = this._getOriginZoom(e2), o2 = "No cluster with the specified id.", r2 = this.trees[i3];
            if (!r2)
              throw new Error(o2);
            const s2 = r2.data;
            if (t4 * this.stride >= s2.length)
              throw new Error(o2);
            const n2 = this.options.radius / (this.options.extent * Math.pow(2, i3 - 1)), a2 = r2.within(s2[t4 * this.stride], s2[t4 * this.stride + 1], n2), l2 = [];
            for (const t5 of a2) {
              const i4 = t5 * this.stride;
              s2[i4 + 4] === e2 && l2.push(s2[i4 + F] > 1 ? E2(s2, i4, this.clusterProps) : this.points[s2[i4 + L2]]);
            }
            if (0 === l2.length)
              throw new Error(o2);
            return l2;
          }
          getLeaves(e2, t4, i3) {
            const o2 = [];
            return this._appendLeaves(o2, e2, t4 = t4 || 10, i3 = i3 || 0, 0), o2;
          }
          getTile(e2, t4, i3) {
            const o2 = this.trees[this._limitZoom(e2)], r2 = Math.pow(2, e2), { extent: s2, radius: n2 } = this.options, a2 = n2 / s2, l2 = (i3 - a2) / r2, c2 = (i3 + 1 + a2) / r2, h2 = { features: [] };
            return this._addTileFeatures(o2.range((t4 - a2) / r2, l2, (t4 + 1 + a2) / r2, c2), o2.data, t4, i3, r2, h2), 0 === t4 && this._addTileFeatures(o2.range(1 - a2 / r2, l2, 1, c2), o2.data, r2, i3, r2, h2), t4 === r2 - 1 && this._addTileFeatures(o2.range(0, l2, a2 / r2, c2), o2.data, -1, i3, r2, h2), h2.features.length ? h2 : null;
          }
          getClusterExpansionZoom(e2) {
            let t4 = this._getOriginZoom(e2) - 1;
            for (; t4 <= this.options.maxZoom; ) {
              const i3 = this.getChildren(e2);
              if (t4++, 1 !== i3.length)
                break;
              e2 = i3[0].properties.cluster_id;
            }
            return t4;
          }
          _appendLeaves(e2, t4, i3, o2, r2) {
            const s2 = this.getChildren(t4);
            for (const t5 of s2) {
              const s3 = t5.properties;
              if (s3 && s3.cluster ? r2 + s3.point_count <= o2 ? r2 += s3.point_count : r2 = this._appendLeaves(e2, s3.cluster_id, i3, o2, r2) : r2 < o2 ? r2++ : e2.push(t5), e2.length === i3)
                break;
            }
            return r2;
          }
          _createTree(t4) {
            const i3 = new e.av(t4.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e2 = 0; e2 < t4.length; e2 += this.stride)
              i3.add(t4[e2], t4[e2 + 1]);
            return i3.finish(), i3.data = t4, i3;
          }
          _addTileFeatures(e2, t4, i3, o2, r2, s2) {
            for (const n2 of e2) {
              const e3 = n2 * this.stride, a2 = t4[e3 + F] > 1;
              let l2, c2, h2;
              if (a2)
                l2 = j(t4, e3, this.clusterProps), c2 = t4[e3], h2 = t4[e3 + 1];
              else {
                const i4 = this.points[t4[e3 + L2]];
                l2 = i4.properties;
                const [o3, r3] = i4.geometry.coordinates;
                c2 = Z(o3), h2 = G(r3);
              }
              const u2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * r2 - i3)), Math.round(this.options.extent * (h2 * r2 - o2))]], tags: l2 };
              let d2;
              d2 = a2 || this.options.generateId ? t4[e3 + L2] : this.points[t4[e3 + L2]].id, void 0 !== d2 && (u2.id = d2), s2.features.push(u2);
            }
          }
          _limitZoom(e2) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
          }
          _cluster(e2, t4) {
            const { radius: i3, extent: o2, reduce: r2, minPoints: s2 } = this.options, n2 = i3 / (o2 * Math.pow(2, t4)), a2 = e2.data, l2 = [], c2 = this.stride;
            for (let i4 = 0; i4 < a2.length; i4 += c2) {
              if (a2[i4 + 2] <= t4)
                continue;
              a2[i4 + 2] = t4;
              const o3 = a2[i4], h2 = a2[i4 + 1], u2 = e2.within(a2[i4], a2[i4 + 1], n2), d2 = a2[i4 + F];
              let p2 = d2;
              for (const e3 of u2) {
                const i5 = e3 * c2;
                a2[i5 + 2] > t4 && (p2 += a2[i5 + F]);
              }
              if (p2 > d2 && p2 >= s2) {
                let e3, s3 = o3 * d2, n3 = h2 * d2, f2 = -1;
                const g2 = ((i4 / c2 | 0) << 5) + (t4 + 1) + this.points.length;
                for (const o4 of u2) {
                  const l3 = o4 * c2;
                  if (a2[l3 + 2] <= t4)
                    continue;
                  a2[l3 + 2] = t4;
                  const h3 = a2[l3 + F];
                  s3 += a2[l3] * h3, n3 += a2[l3 + 1] * h3, a2[l3 + 4] = g2, r2 && (e3 || (e3 = this._map(a2, i4, true), f2 = this.clusterProps.length, this.clusterProps.push(e3)), r2(e3, this._map(a2, l3)));
                }
                a2[i4 + 4] = g2, l2.push(s3 / p2, n3 / p2, 1 / 0, g2, -1, p2), r2 && l2.push(f2);
              } else {
                for (let e3 = 0; e3 < c2; e3++)
                  l2.push(a2[i4 + e3]);
                if (p2 > 1)
                  for (const e3 of u2) {
                    const i5 = e3 * c2;
                    if (!(a2[i5 + 2] <= t4)) {
                      a2[i5 + 2] = t4;
                      for (let e4 = 0; e4 < c2; e4++)
                        l2.push(a2[i5 + e4]);
                    }
                  }
              }
            }
            return l2;
          }
          _getOriginId(e2) {
            return e2 - this.points.length >> 5;
          }
          _getOriginZoom(e2) {
            return (e2 - this.points.length) % 32;
          }
          _map(e2, t4, i3) {
            if (e2[t4 + F] > 1) {
              const o3 = this.clusterProps[e2[t4 + z]];
              return i3 ? Object.assign({}, o3) : o3;
            }
            const o2 = this.points[e2[t4 + L2]].properties, r2 = this.options.map(o2);
            return i3 && r2 === o2 ? Object.assign({}, r2) : r2;
          }
        }
        function E2(e2, t4, i3) {
          return { type: "Feature", id: e2[t4 + L2], properties: j(e2, t4, i3), geometry: { type: "Point", coordinates: [(o2 = e2[t4], 360 * (o2 - 0.5)), J(e2[t4 + 1])] } };
          var o2;
        }
        function j(e2, t4, i3) {
          const o2 = e2[t4 + F], r2 = o2 >= 1e4 ? `${Math.round(o2 / 1e3)}k` : o2 >= 1e3 ? Math.round(o2 / 100) / 10 + "k" : o2, s2 = e2[t4 + z], n2 = -1 === s2 ? {} : Object.assign({}, i3[s2]);
          return Object.assign(n2, { cluster: true, cluster_id: e2[t4 + L2], point_count: o2, point_count_abbreviated: r2 });
        }
        function Z(e2) {
          return e2 / 360 + 0.5;
        }
        function G(e2) {
          const t4 = Math.sin(e2 * Math.PI / 180), i3 = 0.5 - 0.25 * Math.log((1 + t4) / (1 - t4)) / Math.PI;
          return i3 < 0 ? 0 : i3 > 1 ? 1 : i3;
        }
        function J(e2) {
          const t4 = (180 - 360 * e2) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t4)) / Math.PI - 90;
        }
        function Y(e2, t4, i3, o2) {
          for (var r2, s2 = o2, n2 = i3 - t4 >> 1, a2 = i3 - t4, l2 = e2[t4], c2 = e2[t4 + 1], h2 = e2[i3], u2 = e2[i3 + 1], d2 = t4 + 3; d2 < i3; d2 += 3) {
            var p2 = A2(e2[d2], e2[d2 + 1], l2, c2, h2, u2);
            if (p2 > s2)
              r2 = d2, s2 = p2;
            else if (p2 === s2) {
              var f2 = Math.abs(d2 - n2);
              f2 < a2 && (r2 = d2, a2 = f2);
            }
          }
          s2 > o2 && (r2 - t4 > 3 && Y(e2, t4, r2, o2), e2[r2 + 2] = s2, i3 - r2 > 3 && Y(e2, r2, i3, o2));
        }
        function A2(e2, t4, i3, o2, r2, s2) {
          var n2 = r2 - i3, a2 = s2 - o2;
          if (0 !== n2 || 0 !== a2) {
            var l2 = ((e2 - i3) * n2 + (t4 - o2) * a2) / (n2 * n2 + a2 * a2);
            l2 > 1 ? (i3 = r2, o2 = s2) : l2 > 0 && (i3 += n2 * l2, o2 += a2 * l2);
          }
          return (n2 = e2 - i3) * n2 + (a2 = t4 - o2) * a2;
        }
        function V(e2, t4, i3, o2) {
          var r2 = { id: void 0 === e2 ? null : e2, type: t4, geometry: i3, tags: o2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e3) {
            var t5 = e3.geometry, i4 = e3.type;
            if ("Point" === i4 || "MultiPoint" === i4 || "LineString" === i4)
              B2(e3, t5);
            else if ("Polygon" === i4 || "MultiLineString" === i4)
              for (var o3 = 0; o3 < t5.length; o3++)
                B2(e3, t5[o3]);
            else if ("MultiPolygon" === i4)
              for (o3 = 0; o3 < t5.length; o3++)
                for (var r3 = 0; r3 < t5[o3].length; r3++)
                  B2(e3, t5[o3][r3]);
          }(r2), r2;
        }
        function B2(e2, t4) {
          for (var i3 = 0; i3 < t4.length; i3 += 3)
            e2.minX = Math.min(e2.minX, t4[i3]), e2.minY = Math.min(e2.minY, t4[i3 + 1]), e2.maxX = Math.max(e2.maxX, t4[i3]), e2.maxY = Math.max(e2.maxY, t4[i3 + 1]);
        }
        function X(e2, t4, i3, o2) {
          if (t4.geometry) {
            var r2 = t4.geometry.coordinates, s2 = t4.geometry.type, n2 = Math.pow(i3.tolerance / ((1 << i3.maxZoom) * i3.extent), 2), a2 = [], l2 = t4.id;
            if (i3.promoteId ? l2 = t4.properties[i3.promoteId] : i3.generateId && (l2 = o2 || 0), "Point" === s2)
              q(r2, a2);
            else if ("MultiPoint" === s2)
              for (var c2 = 0; c2 < r2.length; c2++)
                q(r2[c2], a2);
            else if ("LineString" === s2)
              R(r2, a2, n2, false);
            else if ("MultiLineString" === s2) {
              if (i3.lineMetrics) {
                for (c2 = 0; c2 < r2.length; c2++)
                  R(r2[c2], a2 = [], n2, false), e2.push(V(l2, "LineString", a2, t4.properties));
                return;
              }
              W(r2, a2, n2, false);
            } else if ("Polygon" === s2)
              W(r2, a2, n2, true);
            else {
              if ("MultiPolygon" !== s2) {
                if ("GeometryCollection" === s2) {
                  for (c2 = 0; c2 < t4.geometry.geometries.length; c2++)
                    X(e2, { id: l2, geometry: t4.geometry.geometries[c2], properties: t4.properties }, i3, o2);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (c2 = 0; c2 < r2.length; c2++) {
                var h2 = [];
                W(r2[c2], h2, n2, true), a2.push(h2);
              }
            }
            e2.push(V(l2, s2, a2, t4.properties));
          }
        }
        function q(e2, t4) {
          t4.push($(e2[0])), t4.push(U(e2[1])), t4.push(0);
        }
        function R(e2, t4, i3, o2) {
          for (var r2, s2, n2 = 0, a2 = 0; a2 < e2.length; a2++) {
            var l2 = $(e2[a2][0]), c2 = U(e2[a2][1]);
            t4.push(l2), t4.push(c2), t4.push(0), a2 > 0 && (n2 += o2 ? (r2 * c2 - l2 * s2) / 2 : Math.sqrt(Math.pow(l2 - r2, 2) + Math.pow(c2 - s2, 2))), r2 = l2, s2 = c2;
          }
          var h2 = t4.length - 3;
          t4[2] = 1, Y(t4, 0, h2, i3), t4[h2 + 2] = 1, t4.size = Math.abs(n2), t4.start = 0, t4.end = t4.size;
        }
        function W(e2, t4, i3, o2) {
          for (var r2 = 0; r2 < e2.length; r2++) {
            var s2 = [];
            R(e2[r2], s2, i3, o2), t4.push(s2);
          }
        }
        function $(e2) {
          return e2 / 360 + 0.5;
        }
        function U(e2) {
          var t4 = Math.sin(e2 * Math.PI / 180), i3 = 0.5 - 0.25 * Math.log((1 + t4) / (1 - t4)) / Math.PI;
          return i3 < 0 ? 0 : i3 > 1 ? 1 : i3;
        }
        function H(e2, t4, i3, o2, r2, s2, n2, a2) {
          if (o2 /= t4, s2 >= (i3 /= t4) && n2 < o2)
            return e2;
          if (n2 < i3 || s2 >= o2)
            return null;
          for (var l2 = [], c2 = 0; c2 < e2.length; c2++) {
            var h2 = e2[c2], u2 = h2.geometry, d2 = h2.type, p2 = 0 === r2 ? h2.minX : h2.minY, f2 = 0 === r2 ? h2.maxX : h2.maxY;
            if (p2 >= i3 && f2 < o2)
              l2.push(h2);
            else if (!(f2 < i3 || p2 >= o2)) {
              var g2 = [];
              if ("Point" === d2 || "MultiPoint" === d2)
                K2(u2, g2, i3, o2, r2);
              else if ("LineString" === d2)
                Q(u2, g2, i3, o2, r2, false, a2.lineMetrics);
              else if ("MultiLineString" === d2)
                te(u2, g2, i3, o2, r2, false);
              else if ("Polygon" === d2)
                te(u2, g2, i3, o2, r2, true);
              else if ("MultiPolygon" === d2)
                for (var m2 = 0; m2 < u2.length; m2++) {
                  var y2 = [];
                  te(u2[m2], y2, i3, o2, r2, true), y2.length && g2.push(y2);
                }
              if (g2.length) {
                if (a2.lineMetrics && "LineString" === d2) {
                  for (m2 = 0; m2 < g2.length; m2++)
                    l2.push(V(h2.id, d2, g2[m2], h2.tags));
                  continue;
                }
                "LineString" !== d2 && "MultiLineString" !== d2 || (1 === g2.length ? (d2 = "LineString", g2 = g2[0]) : d2 = "MultiLineString"), "Point" !== d2 && "MultiPoint" !== d2 || (d2 = 3 === g2.length ? "Point" : "MultiPoint"), l2.push(V(h2.id, d2, g2, h2.tags));
              }
            }
          }
          return l2.length ? l2 : null;
        }
        function K2(e2, t4, i3, o2, r2) {
          for (var s2 = 0; s2 < e2.length; s2 += 3) {
            var n2 = e2[s2 + r2];
            n2 >= i3 && n2 <= o2 && (t4.push(e2[s2]), t4.push(e2[s2 + 1]), t4.push(e2[s2 + 2]));
          }
        }
        function Q(e2, t4, i3, o2, r2, s2, n2) {
          for (var a2, l2, c2 = ee(e2), h2 = 0 === r2 ? oe : re, u2 = e2.start, d2 = 0; d2 < e2.length - 3; d2 += 3) {
            var p2 = e2[d2], f2 = e2[d2 + 1], g2 = e2[d2 + 2], m2 = e2[d2 + 3], y2 = e2[d2 + 4], v2 = 0 === r2 ? p2 : f2, w2 = 0 === r2 ? m2 : y2, x3 = false;
            n2 && (a2 = Math.sqrt(Math.pow(p2 - m2, 2) + Math.pow(f2 - y2, 2))), v2 < i3 ? w2 > i3 && (l2 = h2(c2, p2, f2, m2, y2, i3), n2 && (c2.start = u2 + a2 * l2)) : v2 > o2 ? w2 < o2 && (l2 = h2(c2, p2, f2, m2, y2, o2), n2 && (c2.start = u2 + a2 * l2)) : ie(c2, p2, f2, g2), w2 < i3 && v2 >= i3 && (l2 = h2(c2, p2, f2, m2, y2, i3), x3 = true), w2 > o2 && v2 <= o2 && (l2 = h2(c2, p2, f2, m2, y2, o2), x3 = true), !s2 && x3 && (n2 && (c2.end = u2 + a2 * l2), t4.push(c2), c2 = ee(e2)), n2 && (u2 += a2);
          }
          var b2 = e2.length - 3;
          p2 = e2[b2], f2 = e2[b2 + 1], g2 = e2[b2 + 2], (v2 = 0 === r2 ? p2 : f2) >= i3 && v2 <= o2 && ie(c2, p2, f2, g2), b2 = c2.length - 3, s2 && b2 >= 3 && (c2[b2] !== c2[0] || c2[b2 + 1] !== c2[1]) && ie(c2, c2[0], c2[1], c2[2]), c2.length && t4.push(c2);
        }
        function ee(e2) {
          var t4 = [];
          return t4.size = e2.size, t4.start = e2.start, t4.end = e2.end, t4;
        }
        function te(e2, t4, i3, o2, r2, s2) {
          for (var n2 = 0; n2 < e2.length; n2++)
            Q(e2[n2], t4, i3, o2, r2, s2, false);
        }
        function ie(e2, t4, i3, o2) {
          e2.push(t4), e2.push(i3), e2.push(o2);
        }
        function oe(e2, t4, i3, o2, r2, s2) {
          var n2 = (s2 - t4) / (o2 - t4);
          return e2.push(s2), e2.push(i3 + (r2 - i3) * n2), e2.push(1), n2;
        }
        function re(e2, t4, i3, o2, r2, s2) {
          var n2 = (s2 - i3) / (r2 - i3);
          return e2.push(t4 + (o2 - t4) * n2), e2.push(s2), e2.push(1), n2;
        }
        function se(e2, t4) {
          for (var i3 = [], o2 = 0; o2 < e2.length; o2++) {
            var r2, s2 = e2[o2], n2 = s2.type;
            if ("Point" === n2 || "MultiPoint" === n2 || "LineString" === n2)
              r2 = ne(s2.geometry, t4);
            else if ("MultiLineString" === n2 || "Polygon" === n2) {
              r2 = [];
              for (var a2 = 0; a2 < s2.geometry.length; a2++)
                r2.push(ne(s2.geometry[a2], t4));
            } else if ("MultiPolygon" === n2)
              for (r2 = [], a2 = 0; a2 < s2.geometry.length; a2++) {
                for (var l2 = [], c2 = 0; c2 < s2.geometry[a2].length; c2++)
                  l2.push(ne(s2.geometry[a2][c2], t4));
                r2.push(l2);
              }
            i3.push(V(s2.id, n2, r2, s2.tags));
          }
          return i3;
        }
        function ne(e2, t4) {
          var i3 = [];
          i3.size = e2.size, void 0 !== e2.start && (i3.start = e2.start, i3.end = e2.end);
          for (var o2 = 0; o2 < e2.length; o2 += 3)
            i3.push(e2[o2] + t4, e2[o2 + 1], e2[o2 + 2]);
          return i3;
        }
        function ae(e2, t4) {
          if (e2.transformed)
            return e2;
          var i3, o2, r2, s2 = 1 << e2.z, n2 = e2.x, a2 = e2.y;
          for (i3 = 0; i3 < e2.features.length; i3++) {
            var l2 = e2.features[i3], c2 = l2.geometry, h2 = l2.type;
            if (l2.geometry = [], 1 === h2)
              for (o2 = 0; o2 < c2.length; o2 += 2)
                l2.geometry.push(le(c2[o2], c2[o2 + 1], t4, s2, n2, a2));
            else
              for (o2 = 0; o2 < c2.length; o2++) {
                var u2 = [];
                for (r2 = 0; r2 < c2[o2].length; r2 += 2)
                  u2.push(le(c2[o2][r2], c2[o2][r2 + 1], t4, s2, n2, a2));
                l2.geometry.push(u2);
              }
          }
          return e2.transformed = true, e2;
        }
        function le(e2, t4, i3, o2, r2, s2) {
          return [Math.round(i3 * (e2 * o2 - r2)), Math.round(i3 * (t4 * o2 - s2))];
        }
        function ce(e2, t4, i3, o2, r2) {
          for (var s2 = t4 === r2.maxZoom ? 0 : r2.tolerance / ((1 << t4) * r2.extent), n2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: i3, y: o2, z: t4, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e2.length; a2++) {
            n2.numFeatures++, he(n2, e2[a2], s2, r2);
            var l2 = e2[a2].minX, c2 = e2[a2].minY, h2 = e2[a2].maxX, u2 = e2[a2].maxY;
            l2 < n2.minX && (n2.minX = l2), c2 < n2.minY && (n2.minY = c2), h2 > n2.maxX && (n2.maxX = h2), u2 > n2.maxY && (n2.maxY = u2);
          }
          return n2;
        }
        function he(e2, t4, i3, o2) {
          var r2 = t4.geometry, s2 = t4.type, n2 = [];
          if ("Point" === s2 || "MultiPoint" === s2)
            for (var a2 = 0; a2 < r2.length; a2 += 3)
              n2.push(r2[a2]), n2.push(r2[a2 + 1]), e2.numPoints++, e2.numSimplified++;
          else if ("LineString" === s2)
            ue(n2, r2, e2, i3, false, false);
          else if ("MultiLineString" === s2 || "Polygon" === s2)
            for (a2 = 0; a2 < r2.length; a2++)
              ue(n2, r2[a2], e2, i3, "Polygon" === s2, 0 === a2);
          else if ("MultiPolygon" === s2)
            for (var l2 = 0; l2 < r2.length; l2++) {
              var c2 = r2[l2];
              for (a2 = 0; a2 < c2.length; a2++)
                ue(n2, c2[a2], e2, i3, true, 0 === a2);
            }
          if (n2.length) {
            var h2 = t4.tags || null;
            if ("LineString" === s2 && o2.lineMetrics) {
              for (var u2 in h2 = {}, t4.tags)
                h2[u2] = t4.tags[u2];
              h2.mapbox_clip_start = r2.start / r2.size, h2.mapbox_clip_end = r2.end / r2.size;
            }
            var d2 = { geometry: n2, type: "Polygon" === s2 || "MultiPolygon" === s2 ? 3 : "LineString" === s2 || "MultiLineString" === s2 ? 2 : 1, tags: h2 };
            null !== t4.id && (d2.id = t4.id), e2.features.push(d2);
          }
        }
        function ue(e2, t4, i3, o2, r2, s2) {
          var n2 = o2 * o2;
          if (o2 > 0 && t4.size < (r2 ? n2 : o2))
            i3.numPoints += t4.length / 3;
          else {
            for (var a2 = [], l2 = 0; l2 < t4.length; l2 += 3)
              (0 === o2 || t4[l2 + 2] > n2) && (i3.numSimplified++, a2.push(t4[l2]), a2.push(t4[l2 + 1])), i3.numPoints++;
            r2 && function(e3, t5) {
              for (var i4 = 0, o3 = 0, r3 = e3.length, s3 = r3 - 2; o3 < r3; s3 = o3, o3 += 2)
                i4 += (e3[o3] - e3[s3]) * (e3[o3 + 1] + e3[s3 + 1]);
              if (i4 > 0 === t5)
                for (o3 = 0, r3 = e3.length; o3 < r3 / 2; o3 += 2) {
                  var n3 = e3[o3], a3 = e3[o3 + 1];
                  e3[o3] = e3[r3 - 2 - o3], e3[o3 + 1] = e3[r3 - 1 - o3], e3[r3 - 2 - o3] = n3, e3[r3 - 1 - o3] = a3;
                }
            }(a2, s2), e2.push(a2);
          }
        }
        function de(e2, t4) {
          var i3 = (t4 = this.options = function(e3, t5) {
            for (var i4 in t5)
              e3[i4] = t5[i4];
            return e3;
          }(Object.create(this.options), t4)).debug;
          if (i3 && console.time("preprocess data"), t4.maxZoom < 0 || t4.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t4.promoteId && t4.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          var o2 = function(e3, t5) {
            var i4 = [];
            if ("FeatureCollection" === e3.type)
              for (var o3 = 0; o3 < e3.features.length; o3++)
                X(i4, e3.features[o3], t5, o3);
            else
              X(i4, "Feature" === e3.type ? e3 : { geometry: e3 }, t5);
            return i4;
          }(e2, t4);
          this.tiles = {}, this.tileCoords = [], i3 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t4.indexMaxZoom, t4.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o2 = function(e3, t5) {
            var i4 = t5.buffer / t5.extent, o3 = e3, r2 = H(e3, 1, -1 - i4, i4, 0, -1, 2, t5), s2 = H(e3, 1, 1 - i4, 2 + i4, 0, -1, 2, t5);
            return (r2 || s2) && (o3 = H(e3, 1, -i4, 1 + i4, 0, -1, 2, t5) || [], r2 && (o3 = se(r2, 1).concat(o3)), s2 && (o3 = o3.concat(se(s2, -1)))), o3;
          }(o2, t4), o2.length && this.splitTile(o2, 0, 0, 0), i3 && (o2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function pe(e2, t4, i3) {
          return 32 * ((1 << e2) * i3 + t4) + e2;
        }
        function fe(e2, t4) {
          return t4 ? e2.properties[t4] : e2.id;
        }
        function ge(e2, t4) {
          if (null == e2)
            return true;
          if ("Feature" === e2.type)
            return null != fe(e2, t4);
          if ("FeatureCollection" === e2.type) {
            const i3 = /* @__PURE__ */ new Set();
            for (const o2 of e2.features) {
              const e3 = fe(o2, t4);
              if (null == e3)
                return false;
              if (i3.has(e3))
                return false;
              i3.add(e3);
            }
            return true;
          }
          return false;
        }
        function me(e2, t4) {
          const i3 = /* @__PURE__ */ new Map();
          if (null == e2)
            ;
          else if ("Feature" === e2.type)
            i3.set(fe(e2, t4), e2);
          else
            for (const o2 of e2.features)
              i3.set(fe(o2, t4), o2);
          return i3;
        }
        de.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, de.prototype.splitTile = function(e2, t4, i3, o2, r2, s2, n2) {
          for (var a2 = [e2, t4, i3, o2], l2 = this.options, c2 = l2.debug; a2.length; ) {
            o2 = a2.pop(), i3 = a2.pop(), t4 = a2.pop(), e2 = a2.pop();
            var h2 = 1 << t4, u2 = pe(t4, i3, o2), d2 = this.tiles[u2];
            if (!d2 && (c2 > 1 && console.time("creation"), d2 = this.tiles[u2] = ce(e2, t4, i3, o2, l2), this.tileCoords.push({ z: t4, x: i3, y: o2 }), c2)) {
              c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t4, i3, o2, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
              var p2 = "z" + t4;
              this.stats[p2] = (this.stats[p2] || 0) + 1, this.total++;
            }
            if (d2.source = e2, r2) {
              if (t4 === l2.maxZoom || t4 === r2)
                continue;
              var f2 = 1 << r2 - t4;
              if (i3 !== Math.floor(s2 / f2) || o2 !== Math.floor(n2 / f2))
                continue;
            } else if (t4 === l2.indexMaxZoom || d2.numPoints <= l2.indexMaxPoints)
              continue;
            if (d2.source = null, 0 !== e2.length) {
              c2 > 1 && console.time("clipping");
              var g2, m2, y2, v2, w2, x3, b2 = 0.5 * l2.buffer / l2.extent, S2 = 0.5 - b2, M2 = 0.5 + b2, I2 = 1 + b2;
              g2 = m2 = y2 = v2 = null, w2 = H(e2, h2, i3 - b2, i3 + M2, 0, d2.minX, d2.maxX, l2), x3 = H(e2, h2, i3 + S2, i3 + I2, 0, d2.minX, d2.maxX, l2), e2 = null, w2 && (g2 = H(w2, h2, o2 - b2, o2 + M2, 1, d2.minY, d2.maxY, l2), m2 = H(w2, h2, o2 + S2, o2 + I2, 1, d2.minY, d2.maxY, l2), w2 = null), x3 && (y2 = H(x3, h2, o2 - b2, o2 + M2, 1, d2.minY, d2.maxY, l2), v2 = H(x3, h2, o2 + S2, o2 + I2, 1, d2.minY, d2.maxY, l2), x3 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(g2 || [], t4 + 1, 2 * i3, 2 * o2), a2.push(m2 || [], t4 + 1, 2 * i3, 2 * o2 + 1), a2.push(y2 || [], t4 + 1, 2 * i3 + 1, 2 * o2), a2.push(v2 || [], t4 + 1, 2 * i3 + 1, 2 * o2 + 1);
            }
          }
        }, de.prototype.getTile = function(e2, t4, i3) {
          var o2 = this.options, r2 = o2.extent, s2 = o2.debug;
          if (e2 < 0 || e2 > 24)
            return null;
          var n2 = 1 << e2, a2 = pe(e2, t4 = (t4 % n2 + n2) % n2, i3);
          if (this.tiles[a2])
            return ae(this.tiles[a2], r2);
          s2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t4, i3);
          for (var l2, c2 = e2, h2 = t4, u2 = i3; !l2 && c2 > 0; )
            c2--, h2 = Math.floor(h2 / 2), u2 = Math.floor(u2 / 2), l2 = this.tiles[pe(c2, h2, u2)];
          return l2 && l2.source ? (s2 > 1 && console.log("found parent tile z%d-%d-%d", c2, h2, u2), s2 > 1 && console.time("drilling down"), this.splitTile(l2.source, c2, h2, u2, e2, t4, i3), s2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ae(this.tiles[a2], r2) : null) : null;
        };
        class ye extends n {
          constructor(t4, i3, o2, r2) {
            super(t4, i3, o2), this._dataUpdateable = /* @__PURE__ */ new Map(), this.loadGeoJSON = (t5, i4) => {
              const { promoteId: o3 } = t5;
              if (t5.request)
                return e.f(t5.request, (e2, t6, r3, s2) => {
                  this._dataUpdateable = ge(t6, o3) ? me(t6, o3) : void 0, i4(e2, t6, r3, s2);
                });
              if ("string" == typeof t5.data)
                try {
                  const e2 = JSON.parse(t5.data);
                  this._dataUpdateable = ge(e2, o3) ? me(e2, o3) : void 0, i4(null, e2);
                } catch (e2) {
                  i4(new Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`));
                }
              else
                t5.dataDiff ? this._dataUpdateable ? (function(e2, t6, i5) {
                  var o4, r3, s2, n2;
                  if (t6.removeAll && e2.clear(), t6.remove)
                    for (const i6 of t6.remove)
                      e2.delete(i6);
                  if (t6.add)
                    for (const o5 of t6.add) {
                      const t7 = fe(o5, i5);
                      null != t7 && e2.set(t7, o5);
                    }
                  if (t6.update)
                    for (const i6 of t6.update) {
                      let t7 = e2.get(i6.id);
                      if (null == t7)
                        continue;
                      const a2 = !i6.removeAllProperties && ((null === (o4 = i6.removeProperties) || void 0 === o4 ? void 0 : o4.length) > 0 || (null === (r3 = i6.addOrUpdateProperties) || void 0 === r3 ? void 0 : r3.length) > 0);
                      if ((i6.newGeometry || i6.removeAllProperties || a2) && (t7 = Object.assign({}, t7), e2.set(i6.id, t7), a2 && (t7.properties = Object.assign({}, t7.properties))), i6.newGeometry && (t7.geometry = i6.newGeometry), i6.removeAllProperties)
                        t7.properties = {};
                      else if ((null === (s2 = i6.removeProperties) || void 0 === s2 ? void 0 : s2.length) > 0)
                        for (const e3 of i6.removeProperties)
                          Object.prototype.hasOwnProperty.call(t7.properties, e3) && delete t7.properties[e3];
                      if ((null === (n2 = i6.addOrUpdateProperties) || void 0 === n2 ? void 0 : n2.length) > 0)
                        for (const { key: e3, value: o5 } of i6.addOrUpdateProperties)
                          t7.properties[e3] = o5;
                    }
                }(this._dataUpdateable, t5.dataDiff, o3), i4(null, { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) })) : i4(new Error(`Cannot update existing geojson data in ${t5.source}`)) : i4(new Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`));
              return { cancel: () => {
              } };
            }, this.loadVectorData = this.loadGeoJSONTile, r2 && (this.loadGeoJSON = r2);
          }
          loadGeoJSONTile(t4, i3) {
            const o2 = t4.tileID.canonical;
            if (!this._geoJSONIndex)
              return i3(null, null);
            const r2 = this._geoJSONIndex.getTile(o2.z, o2.x, o2.y);
            if (!r2)
              return i3(null, null);
            const s2 = new class {
              constructor(t5) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.N, this.length = t5.length, this._features = t5;
              }
              feature(t5) {
                return new class {
                  constructor(t6) {
                    this._feature = t6, this.extent = e.N, this.type = t6.type, this.properties = t6.tags, "id" in t6 && !isNaN(t6.id) && (this.id = parseInt(t6.id, 10));
                  }
                  loadGeometry() {
                    if (1 === this._feature.type) {
                      const t6 = [];
                      for (const i4 of this._feature.geometry)
                        t6.push([new e.P(i4[0], i4[1])]);
                      return t6;
                    }
                    {
                      const t6 = [];
                      for (const i4 of this._feature.geometry) {
                        const o3 = [];
                        for (const t7 of i4)
                          o3.push(new e.P(t7[0], t7[1]));
                        t6.push(o3);
                      }
                      return t6;
                    }
                  }
                  toGeoJSON(e2, t6, i4) {
                    return u.call(this, e2, t6, i4);
                  }
                }(this._features[t5]);
              }
            }(r2.features);
            let n2 = k(s2);
            0 === n2.byteOffset && n2.byteLength === n2.buffer.byteLength || (n2 = new Uint8Array(n2)), i3(null, { vectorTile: s2, rawData: n2.buffer });
          }
          loadData(t4, i3) {
            var o2;
            null === (o2 = this._pendingRequest) || void 0 === o2 || o2.cancel(), this._pendingCallback && this._pendingCallback(null, { abandoned: true });
            const r2 = !!(t4 && t4.request && t4.request.collectResourceTiming) && new e.bu(t4.request);
            this._pendingCallback = i3, this._pendingRequest = this.loadGeoJSON(t4, (o3, s2) => {
              if (delete this._pendingCallback, delete this._pendingRequest, o3 || !s2)
                return i3(o3);
              if ("object" != typeof s2)
                return i3(new Error(`Input data given to '${t4.source}' is not a valid GeoJSON object.`));
              {
                h(s2, true);
                try {
                  if (t4.filter) {
                    const i4 = e.bC(t4.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                    if ("error" === i4.result)
                      throw new Error(i4.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                    const o4 = s2.features.filter((e2) => i4.value.evaluate({ zoom: 0 }, e2));
                    s2 = { type: "FeatureCollection", features: o4 };
                  }
                  this._geoJSONIndex = t4.cluster ? new N(function({ superclusterOptions: t5, clusterProperties: i4 }) {
                    if (!i4 || !t5)
                      return t5;
                    const o4 = {}, r3 = {}, s3 = { accumulated: null, zoom: 0 }, n3 = { properties: null }, a2 = Object.keys(i4);
                    for (const t6 of a2) {
                      const [s4, n4] = i4[t6], a3 = e.bC(n4), l2 = e.bC("string" == typeof s4 ? [s4, ["accumulated"], ["get", t6]] : s4);
                      o4[t6] = a3.value, r3[t6] = l2.value;
                    }
                    return t5.map = (e2) => {
                      n3.properties = e2;
                      const t6 = {};
                      for (const e3 of a2)
                        t6[e3] = o4[e3].evaluate(s3, n3);
                      return t6;
                    }, t5.reduce = (e2, t6) => {
                      n3.properties = t6;
                      for (const t7 of a2)
                        s3.accumulated = e2[t7], e2[t7] = r3[t7].evaluate(s3, n3);
                    }, t5;
                  }(t4)).load(s2.features) : function(e2, t5) {
                    return new de(e2, t5);
                  }(s2, t4.geojsonVtOptions);
                } catch (o4) {
                  return i3(o4);
                }
                this.loaded = {};
                const n2 = {};
                if (r2) {
                  const e2 = r2.finish();
                  e2 && (n2.resourceTiming = {}, n2.resourceTiming[t4.source] = JSON.parse(JSON.stringify(e2)));
                }
                i3(null, n2);
              }
            });
          }
          reloadTile(e2, t4) {
            const i3 = this.loaded;
            return i3 && i3[e2.uid] ? super.reloadTile(e2, t4) : this.loadTile(e2, t4);
          }
          removeSource(e2, t4) {
            this._pendingCallback && this._pendingCallback(null, { abandoned: true }), t4();
          }
          getClusterExpansionZoom(e2, t4) {
            try {
              t4(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
            } catch (e3) {
              t4(e3);
            }
          }
          getClusterChildren(e2, t4) {
            try {
              t4(null, this._geoJSONIndex.getChildren(e2.clusterId));
            } catch (e3) {
              t4(e3);
            }
          }
          getClusterLeaves(e2, t4) {
            try {
              t4(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
            } catch (e3) {
              t4(e3);
            }
          }
        }
        class ve {
          constructor(t4) {
            this.self = t4, this.actor = new e.C(t4, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: n, geojson: ye }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t5) => {
              if (this.workerSourceTypes[e2])
                throw new Error(`Worker source with name "${e2}" already registered.`);
              this.workerSourceTypes[e2] = t5;
            }, this.self.registerRTLTextPlugin = (t5) => {
              if (e.bD.isParsed())
                throw new Error("RTL text plugin already registered.");
              e.bD.applyArabicShaping = t5.applyArabicShaping, e.bD.processBidirectionalText = t5.processBidirectionalText, e.bD.processStyledBidirectionalText = t5.processStyledBidirectionalText;
            };
          }
          setReferrer(e2, t4) {
            this.referrer = t4;
          }
          setImages(e2, t4, i3) {
            this.availableImages[e2] = t4;
            for (const i4 in this.workerSources[e2]) {
              const o2 = this.workerSources[e2][i4];
              for (const e3 in o2)
                o2[e3].availableImages = t4;
            }
            i3();
          }
          setLayers(e2, t4, i3) {
            this.getLayerIndex(e2).replace(t4), i3();
          }
          updateLayers(e2, t4, i3) {
            this.getLayerIndex(e2).update(t4.layers, t4.removedIds), i3();
          }
          loadTile(e2, t4, i3) {
            this.getWorkerSource(e2, t4.type, t4.source).loadTile(t4, i3);
          }
          loadDEMTile(e2, t4, i3) {
            this.getDEMWorkerSource(e2, t4.source).loadTile(t4, i3);
          }
          reloadTile(e2, t4, i3) {
            this.getWorkerSource(e2, t4.type, t4.source).reloadTile(t4, i3);
          }
          abortTile(e2, t4, i3) {
            this.getWorkerSource(e2, t4.type, t4.source).abortTile(t4, i3);
          }
          removeTile(e2, t4, i3) {
            this.getWorkerSource(e2, t4.type, t4.source).removeTile(t4, i3);
          }
          removeDEMTile(e2, t4) {
            this.getDEMWorkerSource(e2, t4.source).removeTile(t4);
          }
          removeSource(e2, t4, i3) {
            if (!this.workerSources[e2] || !this.workerSources[e2][t4.type] || !this.workerSources[e2][t4.type][t4.source])
              return;
            const o2 = this.workerSources[e2][t4.type][t4.source];
            delete this.workerSources[e2][t4.type][t4.source], void 0 !== o2.removeSource ? o2.removeSource(t4, i3) : i3();
          }
          loadWorkerSource(e2, t4, i3) {
            try {
              this.self.importScripts(t4.url), i3();
            } catch (e3) {
              i3(e3.toString());
            }
          }
          syncRTLPluginState(t4, i3, o2) {
            try {
              e.bD.setState(i3);
              const t5 = e.bD.getPluginURL();
              if (e.bD.isLoaded() && !e.bD.isParsed() && null != t5) {
                this.self.importScripts(t5);
                const i4 = e.bD.isParsed();
                o2(i4 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t5}`), i4);
              }
            } catch (e2) {
              o2(e2.toString());
            }
          }
          getAvailableImages(e2) {
            let t4 = this.availableImages[e2];
            return t4 || (t4 = []), t4;
          }
          getLayerIndex(e2) {
            let i3 = this.layerIndexes[e2];
            return i3 || (i3 = this.layerIndexes[e2] = new t()), i3;
          }
          getWorkerSource(e2, t4, i3) {
            return this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t4] || (this.workerSources[e2][t4] = {}), this.workerSources[e2][t4][i3] || (this.workerSources[e2][t4][i3] = new this.workerSourceTypes[t4]({ send: (t5, i4, o2) => {
              this.actor.send(t5, i4, o2, e2);
            } }, this.getLayerIndex(e2), this.getAvailableImages(e2))), this.workerSources[e2][t4][i3];
          }
          getDEMWorkerSource(e2, t4) {
            return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t4] || (this.demWorkerSources[e2][t4] = new a()), this.demWorkerSources[e2][t4];
          }
        }
        return e.i() && (self.worker = new ve(self)), ve;
      });
      define2(["./shared"], function(t) {
        "use strict";
        var e = "3.6.2";
        class i2 {
          static testProp(t4) {
            if (!i2.docStyle)
              return t4[0];
            for (let e2 = 0; e2 < t4.length; e2++)
              if (t4[e2] in i2.docStyle)
                return t4[e2];
            return t4[0];
          }
          static create(t4, e2, i3) {
            const s2 = window.document.createElement(t4);
            return void 0 !== e2 && (s2.className = e2), i3 && i3.appendChild(s2), s2;
          }
          static createNS(t4, e2) {
            return window.document.createElementNS(t4, e2);
          }
          static disableDrag() {
            i2.docStyle && i2.selectProp && (i2.userSelect = i2.docStyle[i2.selectProp], i2.docStyle[i2.selectProp] = "none");
          }
          static enableDrag() {
            i2.docStyle && i2.selectProp && (i2.docStyle[i2.selectProp] = i2.userSelect);
          }
          static setTransform(t4, e2) {
            t4.style[i2.transformProp] = e2;
          }
          static addEventListener(t4, e2, i3, s2 = {}) {
            t4.addEventListener(e2, i3, "passive" in s2 ? s2 : s2.capture);
          }
          static removeEventListener(t4, e2, i3, s2 = {}) {
            t4.removeEventListener(e2, i3, "passive" in s2 ? s2 : s2.capture);
          }
          static suppressClickInternal(t4) {
            t4.preventDefault(), t4.stopPropagation(), window.removeEventListener("click", i2.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", i2.suppressClickInternal, true), window.setTimeout(() => {
              window.removeEventListener("click", i2.suppressClickInternal, true);
            }, 0);
          }
          static mousePos(e2, i3) {
            const s2 = e2.getBoundingClientRect();
            return new t.P(i3.clientX - s2.left - e2.clientLeft, i3.clientY - s2.top - e2.clientTop);
          }
          static touchPos(e2, i3) {
            const s2 = e2.getBoundingClientRect(), a2 = [];
            for (let o2 = 0; o2 < i3.length; o2++)
              a2.push(new t.P(i3[o2].clientX - s2.left - e2.clientLeft, i3[o2].clientY - s2.top - e2.clientTop));
            return a2;
          }
          static mouseButton(t4) {
            return t4.button;
          }
          static remove(t4) {
            t4.parentNode && t4.parentNode.removeChild(t4);
          }
        }
        i2.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, i2.selectProp = i2.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), i2.transformProp = i2.testProp(["transform", "WebkitTransform"]);
        const s = { supported: false, testSupport: function(t4) {
          !r && o && (n ? l(t4) : a = t4);
        } };
        let a, o, r = false, n = false;
        function l(t4) {
          const e2 = t4.createTexture();
          t4.bindTexture(t4.TEXTURE_2D, e2);
          try {
            if (t4.texImage2D(t4.TEXTURE_2D, 0, t4.RGBA, t4.RGBA, t4.UNSIGNED_BYTE, o), t4.isContextLost())
              return;
            s.supported = true;
          } catch (t5) {
          }
          t4.deleteTexture(e2), r = true;
        }
        var h, c;
        "undefined" != typeof document && (o = document.createElement("img"), o.onload = function() {
          a && l(a), a = null, n = true;
        }, o.onerror = function() {
          r = true, a = null;
        }, o.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e2) {
          let i3, a2, o2, r2;
          e2.resetRequestQueue = () => {
            i3 = [], a2 = 0, o2 = 0, r2 = {};
          }, e2.addThrottleControl = (t4) => {
            const e3 = o2++;
            return r2[e3] = t4, e3;
          }, e2.removeThrottleControl = (t4) => {
            delete r2[t4], h2();
          }, e2.getImage = (t4, e3, o3 = true) => {
            s.supported && (t4.headers || (t4.headers = {}), t4.headers.accept = "image/webp,*/*");
            const r3 = { requestParameters: t4, supportImageRefresh: o3, callback: e3, cancelled: false, completed: false, cancel: () => {
              r3.completed || r3.cancelled || (r3.cancelled = true, r3.innerRequest && (r3.innerRequest.cancel(), a2--), h2());
            } };
            return i3.push(r3), h2(), r3;
          };
          const n2 = (e3) => {
            const { requestParameters: i4, supportImageRefresh: s2, callback: a3 } = e3;
            return t.e(i4, { type: "image" }), (false !== s2 || t.i() || t.g(i4.url) || i4.headers && !Object.keys(i4.headers).reduce((t4, e4) => t4 && "accept" === e4, true) ? t.m : c2)(i4, (t4, i5, s3, o3) => {
              l2(e3, a3, t4, i5, s3, o3);
            });
          }, l2 = (e3, i4, s2, o3, r3, n3) => {
            s2 ? i4(s2) : o3 instanceof HTMLImageElement || t.a(o3) ? i4(null, o3) : o3 && ((e4, i5) => {
              "function" == typeof createImageBitmap ? t.b(e4, i5) : t.d(e4, i5);
            })(o3, (t4, e4) => {
              null != t4 ? i4(t4) : null != e4 && i4(null, e4, { cacheControl: r3, expires: n3 });
            }), e3.cancelled || (e3.completed = true, a2--, h2());
          }, h2 = () => {
            const e3 = (() => {
              const t4 = Object.keys(r2);
              let e4 = false;
              if (t4.length > 0) {
                for (const i4 of t4)
                  if (e4 = r2[i4](), e4)
                    break;
              }
              return e4;
            })() ? t.c.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t.c.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let t4 = a2; t4 < e3 && i3.length > 0; t4++) {
              const e4 = i3.shift();
              if (e4.cancelled) {
                t4--;
                continue;
              }
              const s2 = n2(e4);
              a2++, e4.innerRequest = s2;
            }
          }, c2 = (e3, i4) => {
            const s2 = new Image(), a3 = e3.url;
            let o3 = false;
            const r3 = e3.credentials;
            return r3 && "include" === r3 ? s2.crossOrigin = "use-credentials" : (r3 && "same-origin" === r3 || !t.s(a3)) && (s2.crossOrigin = "anonymous"), s2.fetchPriority = "high", s2.onload = () => {
              i4(null, s2), s2.onerror = s2.onload = null;
            }, s2.onerror = () => {
              o3 || i4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")), s2.onerror = s2.onload = null;
            }, s2.src = a3, { cancel: () => {
              o3 = true, s2.src = "";
            } };
          };
        }(h || (h = {})), h.resetRequestQueue(), function(t4) {
          t4.Glyphs = "Glyphs", t4.Image = "Image", t4.Source = "Source", t4.SpriteImage = "SpriteImage", t4.SpriteJSON = "SpriteJSON", t4.Style = "Style", t4.Tile = "Tile", t4.Unknown = "Unknown";
        }(c || (c = {}));
        class u {
          constructor(t4) {
            this._transformRequestFn = t4;
          }
          transformRequest(t4, e2) {
            return this._transformRequestFn && this._transformRequestFn(t4, e2) || { url: t4 };
          }
          normalizeSpriteURL(t4, e2, i3) {
            const s2 = function(t5) {
              const e3 = t5.match(d);
              if (!e3)
                throw new Error(`Unable to parse URL "${t5}"`);
              return { protocol: e3[1], authority: e3[2], path: e3[3] || "/", params: e3[4] ? e3[4].split("&") : [] };
            }(t4);
            return s2.path += `${e2}${i3}`, function(t5) {
              const e3 = t5.params.length ? `?${t5.params.join("&")}` : "";
              return `${t5.protocol}://${t5.authority}${t5.path}${e3}`;
            }(s2);
          }
          setTransformRequest(t4) {
            this._transformRequestFn = t4;
          }
        }
        const d = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function _(e2) {
          var i3 = new t.A(3);
          return i3[0] = e2[0], i3[1] = e2[1], i3[2] = e2[2], i3;
        }
        var p, m = function(t4, e2, i3) {
          return t4[0] = e2[0] - i3[0], t4[1] = e2[1] - i3[1], t4[2] = e2[2] - i3[2], t4;
        };
        p = new t.A(3), t.A != Float32Array && (p[0] = 0, p[1] = 0, p[2] = 0);
        var f = function(t4) {
          var e2 = t4[0], i3 = t4[1];
          return e2 * e2 + i3 * i3;
        };
        function g(t4) {
          const e2 = [];
          if ("string" == typeof t4)
            e2.push({ id: "default", url: t4 });
          else if (t4 && t4.length > 0) {
            const i3 = [];
            for (const { id: s2, url: a2 } of t4) {
              const t5 = `${s2}${a2}`;
              -1 === i3.indexOf(t5) && (i3.push(t5), e2.push({ id: s2, url: a2 }));
            }
          }
          return e2;
        }
        function v(e2, i3, s2, a2, o2) {
          if (a2)
            return void e2(a2);
          if (o2 !== Object.values(i3).length || o2 !== Object.values(s2).length)
            return;
          const r2 = {};
          for (const e3 in i3) {
            r2[e3] = {};
            const a3 = t.h.getImageCanvasContext(s2[e3]), o3 = i3[e3];
            for (const t4 in o3) {
              const { width: i4, height: s3, x: n2, y: l2, sdf: h2, pixelRatio: c2, stretchX: u2, stretchY: d2, content: _2 } = o3[t4];
              r2[e3][t4] = { data: null, pixelRatio: c2, sdf: h2, stretchX: u2, stretchY: d2, content: _2, spriteData: { width: i4, height: s3, x: n2, y: l2, context: a3 } };
            }
          }
          e2(null, r2);
        }
        !function() {
          var e2 = new t.A(2);
          t.A != Float32Array && (e2[0] = 0, e2[1] = 0);
        }();
        class x2 {
          constructor(t4, e2, i3, s2) {
            this.context = t4, this.format = i3, this.texture = t4.gl.createTexture(), this.update(e2, s2);
          }
          update(e2, i3, s2) {
            const { width: a2, height: o2 } = e2, r2 = !(this.size && this.size[0] === a2 && this.size[1] === o2 || s2), { context: n2 } = this, { gl: l2 } = n2;
            if (this.useMipmap = Boolean(i3 && i3.useMipmap), l2.bindTexture(l2.TEXTURE_2D, this.texture), n2.pixelStoreUnpackFlipY.set(false), n2.pixelStoreUnpack.set(1), n2.pixelStoreUnpackPremultiplyAlpha.set(this.format === l2.RGBA && (!i3 || false !== i3.premultiply)), r2)
              this.size = [a2, o2], e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t.a(e2) ? l2.texImage2D(l2.TEXTURE_2D, 0, this.format, this.format, l2.UNSIGNED_BYTE, e2) : l2.texImage2D(l2.TEXTURE_2D, 0, this.format, a2, o2, 0, this.format, l2.UNSIGNED_BYTE, e2.data);
            else {
              const { x: i4, y: r3 } = s2 || { x: 0, y: 0 };
              e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t.a(e2) ? l2.texSubImage2D(l2.TEXTURE_2D, 0, i4, r3, l2.RGBA, l2.UNSIGNED_BYTE, e2) : l2.texSubImage2D(l2.TEXTURE_2D, 0, i4, r3, a2, o2, l2.RGBA, l2.UNSIGNED_BYTE, e2.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && l2.generateMipmap(l2.TEXTURE_2D);
          }
          bind(t4, e2, i3) {
            const { context: s2 } = this, { gl: a2 } = s2;
            a2.bindTexture(a2.TEXTURE_2D, this.texture), i3 !== a2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i3 = a2.LINEAR), t4 !== this.filter && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MAG_FILTER, t4), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MIN_FILTER, i3 || t4), this.filter = t4), e2 !== this.wrap && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_S, e2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_T, e2), this.wrap = e2);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t4 } = this.context;
            t4.deleteTexture(this.texture), this.texture = null;
          }
        }
        function y(t4) {
          const { userImage: e2 } = t4;
          return !!(e2 && e2.render && e2.render()) && (t4.data.replace(new Uint8Array(e2.data.buffer)), true);
        }
        class b extends t.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(t4) {
            if (this.loaded !== t4 && (this.loaded = t4, t4)) {
              for (const { ids: t5, callback: e2 } of this.requestors)
                this._notify(t5, e2);
              this.requestors = [];
            }
          }
          getImage(e2) {
            const i3 = this.images[e2];
            if (i3 && !i3.data && i3.spriteData) {
              const e3 = i3.spriteData;
              i3.data = new t.R({ width: e3.width, height: e3.height }, e3.context.getImageData(e3.x, e3.y, e3.width, e3.height).data), i3.spriteData = null;
            }
            return i3;
          }
          addImage(t4, e2) {
            if (this.images[t4])
              throw new Error(`Image id ${t4} already exist, use updateImage instead`);
            this._validate(t4, e2) && (this.images[t4] = e2);
          }
          _validate(e2, i3) {
            let s2 = true;
            const a2 = i3.data || i3.spriteData;
            return this._validateStretch(i3.stretchX, a2 && a2.width) || (this.fire(new t.j(new Error(`Image "${e2}" has invalid "stretchX" value`))), s2 = false), this._validateStretch(i3.stretchY, a2 && a2.height) || (this.fire(new t.j(new Error(`Image "${e2}" has invalid "stretchY" value`))), s2 = false), this._validateContent(i3.content, i3) || (this.fire(new t.j(new Error(`Image "${e2}" has invalid "content" value`))), s2 = false), s2;
          }
          _validateStretch(t4, e2) {
            if (!t4)
              return true;
            let i3 = 0;
            for (const s2 of t4) {
              if (s2[0] < i3 || s2[1] < s2[0] || e2 < s2[1])
                return false;
              i3 = s2[1];
            }
            return true;
          }
          _validateContent(t4, e2) {
            if (!t4)
              return true;
            if (4 !== t4.length)
              return false;
            const i3 = e2.spriteData, s2 = i3 && i3.width || e2.data.width, a2 = i3 && i3.height || e2.data.height;
            return !(t4[0] < 0 || s2 < t4[0] || t4[1] < 0 || a2 < t4[1] || t4[2] < 0 || s2 < t4[2] || t4[3] < 0 || a2 < t4[3] || t4[2] < t4[0] || t4[3] < t4[1]);
          }
          updateImage(t4, e2, i3 = true) {
            const s2 = this.getImage(t4);
            if (i3 && (s2.data.width !== e2.data.width || s2.data.height !== e2.data.height))
              throw new Error(`size mismatch between old image (${s2.data.width}x${s2.data.height}) and new image (${e2.data.width}x${e2.data.height}).`);
            e2.version = s2.version + 1, this.images[t4] = e2, this.updatedImages[t4] = true;
          }
          removeImage(t4) {
            const e2 = this.images[t4];
            delete this.images[t4], delete this.patterns[t4], e2.userImage && e2.userImage.onRemove && e2.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(t4, e2) {
            let i3 = true;
            if (!this.isLoaded())
              for (const e3 of t4)
                this.images[e3] || (i3 = false);
            this.isLoaded() || i3 ? this._notify(t4, e2) : this.requestors.push({ ids: t4, callback: e2 });
          }
          _notify(e2, i3) {
            const s2 = {};
            for (const i4 of e2) {
              let e3 = this.getImage(i4);
              e3 || (this.fire(new t.k("styleimagemissing", { id: i4 })), e3 = this.getImage(i4)), e3 ? s2[i4] = { data: e3.data.clone(), pixelRatio: e3.pixelRatio, sdf: e3.sdf, version: e3.version, stretchX: e3.stretchX, stretchY: e3.stretchY, content: e3.content, hasRenderCallback: Boolean(e3.userImage && e3.userImage.render) } : t.w(`Image "${i4}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            i3(null, s2);
          }
          getPixelSize() {
            const { width: t4, height: e2 } = this.atlasImage;
            return { width: t4, height: e2 };
          }
          getPattern(e2) {
            const i3 = this.patterns[e2], s2 = this.getImage(e2);
            if (!s2)
              return null;
            if (i3 && i3.position.version === s2.version)
              return i3.position;
            if (i3)
              i3.position.version = s2.version;
            else {
              const i4 = { w: s2.data.width + 2, h: s2.data.height + 2, x: 0, y: 0 }, a2 = new t.I(i4, s2);
              this.patterns[e2] = { bin: i4, position: a2 };
            }
            return this._updatePatternAtlas(), this.patterns[e2].position;
          }
          bind(t4) {
            const e2 = t4.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new x2(t4, this.atlasImage, e2.RGBA), this.atlasTexture.bind(e2.LINEAR, e2.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e2 = [];
            for (const t4 in this.patterns)
              e2.push(this.patterns[t4].bin);
            const { w: i3, h: s2 } = t.p(e2), a2 = this.atlasImage;
            a2.resize({ width: i3 || 1, height: s2 || 1 });
            for (const e3 in this.patterns) {
              const { bin: i4 } = this.patterns[e3], s3 = i4.x + 1, o2 = i4.y + 1, r2 = this.getImage(e3).data, n2 = r2.width, l2 = r2.height;
              t.R.copy(r2, a2, { x: 0, y: 0 }, { x: s3, y: o2 }, { width: n2, height: l2 }), t.R.copy(r2, a2, { x: 0, y: l2 - 1 }, { x: s3, y: o2 - 1 }, { width: n2, height: 1 }), t.R.copy(r2, a2, { x: 0, y: 0 }, { x: s3, y: o2 + l2 }, { width: n2, height: 1 }), t.R.copy(r2, a2, { x: n2 - 1, y: 0 }, { x: s3 - 1, y: o2 }, { width: 1, height: l2 }), t.R.copy(r2, a2, { x: 0, y: 0 }, { x: s3 + n2, y: o2 }, { width: 1, height: l2 });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e2) {
            for (const i3 of e2) {
              if (this.callbackDispatchedThisFrame[i3])
                continue;
              this.callbackDispatchedThisFrame[i3] = true;
              const e3 = this.getImage(i3);
              e3 || t.w(`Image with ID: "${i3}" was not found`), y(e3) && this.updateImage(i3, e3);
            }
          }
        }
        const w = 1e20;
        function T2(t4, e2, i3, s2, a2, o2, r2, n2, l2) {
          for (let h2 = e2; h2 < e2 + s2; h2++)
            I(t4, i3 * o2 + h2, o2, a2, r2, n2, l2);
          for (let h2 = i3; h2 < i3 + a2; h2++)
            I(t4, h2 * o2 + e2, 1, s2, r2, n2, l2);
        }
        function I(t4, e2, i3, s2, a2, o2, r2) {
          o2[0] = 0, r2[0] = -w, r2[1] = w, a2[0] = t4[e2];
          for (let n2 = 1, l2 = 0, h2 = 0; n2 < s2; n2++) {
            a2[n2] = t4[e2 + n2 * i3];
            const s3 = n2 * n2;
            do {
              const t5 = o2[l2];
              h2 = (a2[n2] - a2[t5] + s3 - t5 * t5) / (n2 - t5) / 2;
            } while (h2 <= r2[l2] && --l2 > -1);
            l2++, o2[l2] = n2, r2[l2] = h2, r2[l2 + 1] = w;
          }
          for (let n2 = 0, l2 = 0; n2 < s2; n2++) {
            for (; r2[l2 + 1] < n2; )
              l2++;
            const s3 = o2[l2], h2 = n2 - s3;
            t4[e2 + n2 * i3] = a2[s3] + h2 * h2;
          }
        }
        class E2 {
          constructor(t4, e2) {
            this.requestManager = t4, this.localIdeographFontFamily = e2, this.entries = {};
          }
          setURL(t4) {
            this.url = t4;
          }
          getGlyphs(e2, i3) {
            const s2 = [];
            for (const t4 in e2)
              for (const i4 of e2[t4])
                s2.push({ stack: t4, id: i4 });
            t.o(s2, ({ stack: t4, id: e3 }, i4) => {
              let s3 = this.entries[t4];
              s3 || (s3 = this.entries[t4] = { glyphs: {}, requests: {}, ranges: {} });
              let a2 = s3.glyphs[e3];
              if (void 0 !== a2)
                return void i4(null, { stack: t4, id: e3, glyph: a2 });
              if (a2 = this._tinySDF(s3, t4, e3), a2)
                return s3.glyphs[e3] = a2, void i4(null, { stack: t4, id: e3, glyph: a2 });
              const o2 = Math.floor(e3 / 256);
              if (256 * o2 > 65535)
                return void i4(new Error("glyphs > 65535 not supported"));
              if (s3.ranges[o2])
                return void i4(null, { stack: t4, id: e3, glyph: a2 });
              if (!this.url)
                return void i4(new Error("glyphsUrl is not set"));
              let r2 = s3.requests[o2];
              r2 || (r2 = s3.requests[o2] = [], E2.loadGlyphRange(t4, o2, this.url, this.requestManager, (t5, e4) => {
                if (e4) {
                  for (const t6 in e4)
                    this._doesCharSupportLocalGlyph(+t6) || (s3.glyphs[+t6] = e4[+t6]);
                  s3.ranges[o2] = true;
                }
                for (const i5 of r2)
                  i5(t5, e4);
                delete s3.requests[o2];
              })), r2.push((s4, a3) => {
                s4 ? i4(s4) : a3 && i4(null, { stack: t4, id: e3, glyph: a3[e3] || null });
              });
            }, (t4, e3) => {
              if (t4)
                i3(t4);
              else if (e3) {
                const t5 = {};
                for (const { stack: i4, id: s3, glyph: a2 } of e3)
                  (t5[i4] || (t5[i4] = {}))[s3] = a2 && { id: a2.id, bitmap: a2.bitmap.clone(), metrics: a2.metrics };
                i3(null, t5);
              }
            });
          }
          _doesCharSupportLocalGlyph(e2) {
            return !!this.localIdeographFontFamily && (t.u["CJK Unified Ideographs"](e2) || t.u["Hangul Syllables"](e2) || t.u.Hiragana(e2) || t.u.Katakana(e2));
          }
          _tinySDF(e2, i3, s2) {
            const a2 = this.localIdeographFontFamily;
            if (!a2)
              return;
            if (!this._doesCharSupportLocalGlyph(s2))
              return;
            let o2 = e2.tinySDF;
            if (!o2) {
              let t4 = "400";
              /bold/i.test(i3) ? t4 = "900" : /medium/i.test(i3) ? t4 = "500" : /light/i.test(i3) && (t4 = "200"), o2 = e2.tinySDF = new E2.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: a2, fontWeight: t4 });
            }
            const r2 = o2.draw(String.fromCharCode(s2));
            return { id: s2, bitmap: new t.q({ width: r2.width || 60, height: r2.height || 60 }, r2.data), metrics: { width: r2.glyphWidth / 2 || 24, height: r2.glyphHeight / 2 || 24, left: r2.glyphLeft / 2 + 0.5 || 0, top: r2.glyphTop / 2 - 27.5 || -8, advance: r2.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
        }
        E2.loadGlyphRange = function(e2, i3, s2, a2, o2) {
          const r2 = 256 * i3, n2 = r2 + 255, l2 = a2.transformRequest(s2.replace("{fontstack}", e2).replace("{range}", `${r2}-${n2}`), c.Glyphs);
          t.l(l2, (e3, i4) => {
            if (e3)
              o2(e3);
            else if (i4) {
              const e4 = {};
              for (const s3 of t.n(i4))
                e4[s3.id] = s3;
              o2(null, e4);
            }
          });
        }, E2.TinySDF = class {
          constructor({ fontSize: t4 = 24, buffer: e2 = 3, radius: i3 = 8, cutoff: s2 = 0.25, fontFamily: a2 = "sans-serif", fontWeight: o2 = "normal", fontStyle: r2 = "normal" } = {}) {
            this.buffer = e2, this.cutoff = s2, this.radius = i3;
            const n2 = this.size = t4 + 4 * e2, l2 = this._createCanvas(n2), h2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
            h2.font = `${r2} ${o2} ${t4}px ${a2}`, h2.textBaseline = "alphabetic", h2.textAlign = "left", h2.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Uint16Array(n2);
          }
          _createCanvas(t4) {
            const e2 = document.createElement("canvas");
            return e2.width = e2.height = t4, e2;
          }
          draw(t4) {
            const { width: e2, actualBoundingBoxAscent: i3, actualBoundingBoxDescent: s2, actualBoundingBoxLeft: a2, actualBoundingBoxRight: o2 } = this.ctx.measureText(t4), r2 = Math.ceil(i3), n2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o2 - a2))), l2 = Math.min(this.size - this.buffer, r2 + Math.ceil(s2)), h2 = n2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, u2 = Math.max(h2 * c2, 0), d2 = new Uint8ClampedArray(u2), _2 = { data: d2, width: h2, height: c2, glyphWidth: n2, glyphHeight: l2, glyphTop: r2, glyphLeft: 0, glyphAdvance: e2 };
            if (0 === n2 || 0 === l2)
              return _2;
            const { ctx: p2, buffer: m2, gridInner: f2, gridOuter: g2 } = this;
            p2.clearRect(m2, m2, n2, l2), p2.fillText(t4, m2, m2 + r2);
            const v2 = p2.getImageData(m2, m2, n2, l2);
            g2.fill(w, 0, u2), f2.fill(0, 0, u2);
            for (let t5 = 0; t5 < l2; t5++)
              for (let e3 = 0; e3 < n2; e3++) {
                const i4 = v2.data[4 * (t5 * n2 + e3) + 3] / 255;
                if (0 === i4)
                  continue;
                const s3 = (t5 + m2) * h2 + e3 + m2;
                if (1 === i4)
                  g2[s3] = 0, f2[s3] = w;
                else {
                  const t6 = 0.5 - i4;
                  g2[s3] = t6 > 0 ? t6 * t6 : 0, f2[s3] = t6 < 0 ? t6 * t6 : 0;
                }
              }
            T2(g2, 0, 0, h2, c2, h2, this.f, this.v, this.z), T2(f2, m2, m2, n2, l2, h2, this.f, this.v, this.z);
            for (let t5 = 0; t5 < u2; t5++) {
              const e3 = Math.sqrt(g2[t5]) - Math.sqrt(f2[t5]);
              d2[t5] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
            }
            return _2;
          }
        };
        class S {
          constructor() {
            this.specification = t.v.light.position;
          }
          possiblyEvaluate(e2, i3) {
            return t.z(e2.expression.evaluate(i3));
          }
          interpolate(e2, i3, s2) {
            return { x: t.B.number(e2.x, i3.x, s2), y: t.B.number(e2.y, i3.y, s2), z: t.B.number(e2.z, i3.z, s2) };
          }
        }
        let C2;
        class P extends t.E {
          constructor(e2) {
            super(), C2 = C2 || new t.r({ anchor: new t.D(t.v.light.anchor), position: new S(), color: new t.D(t.v.light.color), intensity: new t.D(t.v.light.intensity) }), this._transitionable = new t.T(C2), this.setLight(e2), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e2, i3 = {}) {
            if (!this._validate(t.t, e2, i3))
              for (const t4 in e2) {
                const i4 = e2[t4];
                t4.endsWith("-transition") ? this._transitionable.setTransition(t4.slice(0, -11), i4) : this._transitionable.setValue(t4, i4);
              }
          }
          updateTransitions(t4) {
            this._transitioning = this._transitionable.transitioned(t4, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t4) {
            this.properties = this._transitioning.possiblyEvaluate(t4);
          }
          _validate(e2, i3, s2) {
            return (!s2 || false !== s2.validate) && t.x(this, e2.call(t.y, t.e({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: t.v })));
          }
        }
        class D2 {
          constructor(t4, e2) {
            this.width = t4, this.height = e2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(t4, e2) {
            const i3 = t4.join(",") + String(e2);
            return this.dashEntry[i3] || (this.dashEntry[i3] = this.addDash(t4, e2)), this.dashEntry[i3];
          }
          getDashRanges(t4, e2, i3) {
            const s2 = [];
            let a2 = t4.length % 2 == 1 ? -t4[t4.length - 1] * i3 : 0, o2 = t4[0] * i3, r2 = true;
            s2.push({ left: a2, right: o2, isDash: r2, zeroLength: 0 === t4[0] });
            let n2 = t4[0];
            for (let e3 = 1; e3 < t4.length; e3++) {
              r2 = !r2;
              const l2 = t4[e3];
              a2 = n2 * i3, n2 += l2, o2 = n2 * i3, s2.push({ left: a2, right: o2, isDash: r2, zeroLength: 0 === l2 });
            }
            return s2;
          }
          addRoundDash(t4, e2, i3) {
            const s2 = e2 / 2;
            for (let e3 = -i3; e3 <= i3; e3++) {
              const a2 = this.width * (this.nextRow + i3 + e3);
              let o2 = 0, r2 = t4[o2];
              for (let n2 = 0; n2 < this.width; n2++) {
                n2 / r2.right > 1 && (r2 = t4[++o2]);
                const l2 = Math.abs(n2 - r2.left), h2 = Math.abs(n2 - r2.right), c2 = Math.min(l2, h2);
                let u2;
                const d2 = e3 / i3 * (s2 + 1);
                if (r2.isDash) {
                  const t5 = s2 - Math.abs(d2);
                  u2 = Math.sqrt(c2 * c2 + t5 * t5);
                } else
                  u2 = s2 - Math.sqrt(c2 * c2 + d2 * d2);
                this.data[a2 + n2] = Math.max(0, Math.min(255, u2 + 128));
              }
            }
          }
          addRegularDash(t4) {
            for (let e3 = t4.length - 1; e3 >= 0; --e3) {
              const i4 = t4[e3], s3 = t4[e3 + 1];
              i4.zeroLength ? t4.splice(e3, 1) : s3 && s3.isDash === i4.isDash && (s3.left = i4.left, t4.splice(e3, 1));
            }
            const e2 = t4[0], i3 = t4[t4.length - 1];
            e2.isDash === i3.isDash && (e2.left = i3.left - this.width, i3.right = e2.right + this.width);
            const s2 = this.width * this.nextRow;
            let a2 = 0, o2 = t4[a2];
            for (let e3 = 0; e3 < this.width; e3++) {
              e3 / o2.right > 1 && (o2 = t4[++a2]);
              const i4 = Math.abs(e3 - o2.left), r2 = Math.abs(e3 - o2.right), n2 = Math.min(i4, r2);
              this.data[s2 + e3] = Math.max(0, Math.min(255, (o2.isDash ? n2 : -n2) + 128));
            }
          }
          addDash(e2, i3) {
            const s2 = i3 ? 7 : 0, a2 = 2 * s2 + 1;
            if (this.nextRow + a2 > this.height)
              return t.w("LineAtlas out of space"), null;
            let o2 = 0;
            for (let t4 = 0; t4 < e2.length; t4++)
              o2 += e2[t4];
            if (0 !== o2) {
              const t4 = this.width / o2, a3 = this.getDashRanges(e2, this.width, t4);
              i3 ? this.addRoundDash(a3, t4, s2) : this.addRegularDash(a3);
            }
            const r2 = { y: (this.nextRow + s2 + 0.5) / this.height, height: 2 * s2 / this.height, width: o2 };
            return this.nextRow += a2, this.dirty = true, r2;
          }
          bind(t4) {
            const e2 = t4.gl;
            this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.ALPHA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.ALPHA, this.width, this.height, 0, e2.ALPHA, e2.UNSIGNED_BYTE, this.data));
          }
        }
        class M {
          constructor(e2, i3, s2) {
            this.workerPool = e2, this.actors = [], this.currentActor = 0, this.id = s2;
            const a2 = this.workerPool.acquire(s2);
            for (let e3 = 0; e3 < a2.length; e3++) {
              const o2 = new t.C(a2[e3], i3, s2);
              o2.name = `Worker ${e3}`, this.actors.push(o2);
            }
            if (!this.actors.length)
              throw new Error("No actors found");
          }
          broadcast(e2, i3, s2) {
            t.o(this.actors, (t4, s3) => {
              t4.send(e2, i3, s3);
            }, s2 = s2 || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(t4 = true) {
            this.actors.forEach((t5) => {
              t5.remove();
            }), this.actors = [], t4 && this.workerPool.release(this.id);
          }
        }
        function z(e2, i3, s2) {
          const a2 = function(i4, a3) {
            if (i4)
              return s2(i4);
            if (a3) {
              const i5 = t.F(t.e(a3, e2), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
              a3.vector_layers && (i5.vectorLayers = a3.vector_layers, i5.vectorLayerIds = i5.vectorLayers.map((t4) => t4.id)), s2(null, i5);
            }
          };
          return e2.url ? t.f(i3.transformRequest(e2.url, c.Source), a2) : t.h.frame(() => a2(null, e2));
        }
        class L2 {
          constructor(t4, e2) {
            t4 && (e2 ? this.setSouthWest(t4).setNorthEast(e2) : Array.isArray(t4) && (4 === t4.length ? this.setSouthWest([t4[0], t4[1]]).setNorthEast([t4[2], t4[3]]) : this.setSouthWest(t4[0]).setNorthEast(t4[1])));
          }
          setNorthEast(e2) {
            return this._ne = e2 instanceof t.L ? new t.L(e2.lng, e2.lat) : t.L.convert(e2), this;
          }
          setSouthWest(e2) {
            return this._sw = e2 instanceof t.L ? new t.L(e2.lng, e2.lat) : t.L.convert(e2), this;
          }
          extend(e2) {
            const i3 = this._sw, s2 = this._ne;
            let a2, o2;
            if (e2 instanceof t.L)
              a2 = e2, o2 = e2;
            else {
              if (!(e2 instanceof L2))
                return Array.isArray(e2) ? 4 === e2.length || e2.every(Array.isArray) ? this.extend(L2.convert(e2)) : this.extend(t.L.convert(e2)) : e2 && ("lng" in e2 || "lon" in e2) && "lat" in e2 ? this.extend(t.L.convert(e2)) : this;
              if (a2 = e2._sw, o2 = e2._ne, !a2 || !o2)
                return this;
            }
            return i3 || s2 ? (i3.lng = Math.min(a2.lng, i3.lng), i3.lat = Math.min(a2.lat, i3.lat), s2.lng = Math.max(o2.lng, s2.lng), s2.lat = Math.max(o2.lat, s2.lat)) : (this._sw = new t.L(a2.lng, a2.lat), this._ne = new t.L(o2.lng, o2.lat)), this;
          }
          getCenter() {
            return new t.L((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new t.L(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new t.L(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e2) {
            const { lng: i3, lat: s2 } = t.L.convert(e2);
            let a2 = this._sw.lng <= i3 && i3 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (a2 = this._sw.lng >= i3 && i3 >= this._ne.lng), this._sw.lat <= s2 && s2 <= this._ne.lat && a2;
          }
          static convert(t4) {
            return t4 instanceof L2 ? t4 : t4 ? new L2(t4) : t4;
          }
          static fromLngLat(e2, i3 = 0) {
            const s2 = 360 * i3 / 40075017, a2 = s2 / Math.cos(Math.PI / 180 * e2.lat);
            return new L2(new t.L(e2.lng - a2, e2.lat - s2), new t.L(e2.lng + a2, e2.lat + s2));
          }
        }
        class A2 {
          constructor(t4, e2, i3) {
            this.bounds = L2.convert(this.validateBounds(t4)), this.minzoom = e2 || 0, this.maxzoom = i3 || 24;
          }
          validateBounds(t4) {
            return Array.isArray(t4) && 4 === t4.length ? [Math.max(-180, t4[0]), Math.max(-90, t4[1]), Math.min(180, t4[2]), Math.min(90, t4[3])] : [-180, -90, 180, 90];
          }
          contains(e2) {
            const i3 = Math.pow(2, e2.z), s2 = Math.floor(t.G(this.bounds.getWest()) * i3), a2 = Math.floor(t.H(this.bounds.getNorth()) * i3), o2 = Math.ceil(t.G(this.bounds.getEast()) * i3), r2 = Math.ceil(t.H(this.bounds.getSouth()) * i3);
            return e2.x >= s2 && e2.x < o2 && e2.y >= a2 && e2.y < r2;
          }
        }
        class R extends t.E {
          constructor(e2, i3, s2, a2) {
            if (super(), this.load = () => {
              this._loaded = false, this.fire(new t.k("dataloading", { dataType: "source" })), this._tileJSONRequest = z(this._options, this.map._requestManager, (e3, i4) => {
                this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e3 ? this.fire(new t.j(e3)) : i4 && (t.e(this, i4), i4.bounds && (this.tileBounds = new A2(i4.bounds, this.minzoom, this.maxzoom)), this.fire(new t.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.k("data", { dataType: "source", sourceDataType: "content" })));
              });
            }, this.serialize = () => t.e({}, this._options), this.id = e2, this.dispatcher = s2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.e(this, t.F(i3, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.e({ type: "vector" }, i3), this._collectResourceTiming = i3.collectResourceTiming, 512 !== this.tileSize)
              throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(a2);
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t4) {
            return !this.tileBounds || this.tileBounds.contains(t4.canonical);
          }
          onAdd(t4) {
            this.map = t4, this.load();
          }
          setSourceProperty(t4) {
            this._tileJSONRequest && this._tileJSONRequest.cancel(), t4(), this.load();
          }
          setTiles(t4) {
            return this.setSourceProperty(() => {
              this._options.tiles = t4;
            }), this;
          }
          setUrl(t4) {
            return this.setSourceProperty(() => {
              this.url = t4, this._options.url = t4;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          loadTile(t4, e2) {
            const i3 = t4.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s2 = { request: this.map._requestManager.transformRequest(i3, c.Tile), uid: t4.uid, tileID: t4.tileID, zoom: t4.tileID.overscaledZ, tileSize: this.tileSize * t4.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            function a2(i4, s3) {
              return delete t4.request, t4.aborted ? e2(null) : i4 && 404 !== i4.status ? e2(i4) : (s3 && s3.resourceTiming && (t4.resourceTiming = s3.resourceTiming), this.map._refreshExpiredTiles && s3 && t4.setExpiryData(s3), t4.loadVectorData(s3, this.map.painter), e2(null), void (t4.reloadCallback && (this.loadTile(t4, t4.reloadCallback), t4.reloadCallback = null)));
            }
            s2.request.collectResourceTiming = this._collectResourceTiming, t4.actor && "expired" !== t4.state ? "loading" === t4.state ? t4.reloadCallback = e2 : t4.request = t4.actor.send("reloadTile", s2, a2.bind(this)) : (t4.actor = this.dispatcher.getActor(), t4.request = t4.actor.send("loadTile", s2, a2.bind(this)));
          }
          abortTile(t4) {
            t4.request && (t4.request.cancel(), delete t4.request), t4.actor && t4.actor.send("abortTile", { uid: t4.uid, type: this.type, source: this.id }, void 0);
          }
          unloadTile(t4) {
            t4.unloadVectorData(), t4.actor && t4.actor.send("removeTile", { uid: t4.uid, type: this.type, source: this.id }, void 0);
          }
          hasTransition() {
            return false;
          }
        }
        class k extends t.E {
          constructor(e2, i3, s2, a2) {
            super(), this.id = e2, this.dispatcher = s2, this.setEventedParent(a2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.e({ type: "raster" }, i3), t.e(this, t.F(i3, ["url", "scheme", "tileSize"]));
          }
          load() {
            this._loaded = false, this.fire(new t.k("dataloading", { dataType: "source" })), this._tileJSONRequest = z(this._options, this.map._requestManager, (e2, i3) => {
              this._tileJSONRequest = null, this._loaded = true, e2 ? this.fire(new t.j(e2)) : i3 && (t.e(this, i3), i3.bounds && (this.tileBounds = new A2(i3.bounds, this.minzoom, this.maxzoom)), this.fire(new t.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.k("data", { dataType: "source", sourceDataType: "content" })));
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t4) {
            this.map = t4, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          setSourceProperty(t4) {
            this._tileJSONRequest && this._tileJSONRequest.cancel(), t4(), this.load();
          }
          setTiles(t4) {
            return this.setSourceProperty(() => {
              this._options.tiles = t4;
            }), this;
          }
          serialize() {
            return t.e({}, this._options);
          }
          hasTile(t4) {
            return !this.tileBounds || this.tileBounds.contains(t4.canonical);
          }
          loadTile(t4, e2) {
            const i3 = t4.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            t4.request = h.getImage(this.map._requestManager.transformRequest(i3, c.Tile), (i4, s2, a2) => {
              if (delete t4.request, t4.aborted)
                t4.state = "unloaded", e2(null);
              else if (i4)
                t4.state = "errored", e2(i4);
              else if (s2) {
                this.map._refreshExpiredTiles && a2 && t4.setExpiryData(a2);
                const i5 = this.map.painter.context, o2 = i5.gl;
                t4.texture = this.map.painter.getTileTexture(s2.width), t4.texture ? t4.texture.update(s2, { useMipmap: true }) : (t4.texture = new x2(i5, s2, o2.RGBA, { useMipmap: true }), t4.texture.bind(o2.LINEAR, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), i5.extTextureFilterAnisotropic && o2.texParameterf(o2.TEXTURE_2D, i5.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, i5.extTextureFilterAnisotropicMax)), t4.state = "loaded", e2(null);
              }
            }, this.map._refreshExpiredTiles);
          }
          abortTile(t4, e2) {
            t4.request && (t4.request.cancel(), delete t4.request), e2();
          }
          unloadTile(t4, e2) {
            t4.texture && this.map.painter.saveTileTexture(t4.texture), e2();
          }
          hasTransition() {
            return false;
          }
        }
        class F extends k {
          constructor(e2, i3, s2, a2) {
            super(e2, i3, s2, a2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.e({ type: "raster-dem" }, i3), this.encoding = i3.encoding || "mapbox", this.redFactor = i3.redFactor, this.greenFactor = i3.greenFactor, this.blueFactor = i3.blueFactor, this.baseShift = i3.baseShift;
          }
          loadTile(e2, i3) {
            const s2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a2 = this.map._requestManager.transformRequest(s2, c.Tile);
            function o2(t4, s3) {
              t4 && (e2.state = "errored", i3(t4)), s3 && (e2.dem = s3, e2.needsHillshadePrepare = true, e2.needsTerrainPrepare = true, e2.state = "loaded", i3(null));
            }
            e2.neighboringTiles = this._getNeighboringTiles(e2.tileID), e2.request = h.getImage(a2, (s3, a3, r2) => t._(this, void 0, void 0, function* () {
              if (delete e2.request, e2.aborted)
                e2.state = "unloaded", i3(null);
              else if (s3)
                e2.state = "errored", i3(s3);
              else if (a3) {
                this.map._refreshExpiredTiles && e2.setExpiryData(r2);
                const i4 = t.a(a3) && t.J() ? a3 : yield function(e3) {
                  return t._(this, void 0, void 0, function* () {
                    if ("undefined" != typeof VideoFrame && t.K()) {
                      const i5 = e3.width + 2, s5 = e3.height + 2;
                      try {
                        return new t.R({ width: i5, height: s5 }, yield t.M(e3, -1, -1, i5, s5));
                      } catch (t4) {
                      }
                    }
                    return t.h.getImageData(e3, 1);
                  });
                }(a3), s4 = { uid: e2.uid, coord: e2.tileID, source: this.id, rawImageData: i4, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                e2.actor && "expired" !== e2.state || (e2.actor = this.dispatcher.getActor(), e2.actor.send("loadDEMTile", s4, o2));
              }
            }), this.map._refreshExpiredTiles);
          }
          _getNeighboringTiles(e2) {
            const i3 = e2.canonical, s2 = Math.pow(2, i3.z), a2 = (i3.x - 1 + s2) % s2, o2 = 0 === i3.x ? e2.wrap - 1 : e2.wrap, r2 = (i3.x + 1 + s2) % s2, n2 = i3.x + 1 === s2 ? e2.wrap + 1 : e2.wrap, l2 = {};
            return l2[new t.O(e2.overscaledZ, o2, i3.z, a2, i3.y).key] = { backfilled: false }, l2[new t.O(e2.overscaledZ, n2, i3.z, r2, i3.y).key] = { backfilled: false }, i3.y > 0 && (l2[new t.O(e2.overscaledZ, o2, i3.z, a2, i3.y - 1).key] = { backfilled: false }, l2[new t.O(e2.overscaledZ, e2.wrap, i3.z, i3.x, i3.y - 1).key] = { backfilled: false }, l2[new t.O(e2.overscaledZ, n2, i3.z, r2, i3.y - 1).key] = { backfilled: false }), i3.y + 1 < s2 && (l2[new t.O(e2.overscaledZ, o2, i3.z, a2, i3.y + 1).key] = { backfilled: false }, l2[new t.O(e2.overscaledZ, e2.wrap, i3.z, i3.x, i3.y + 1).key] = { backfilled: false }, l2[new t.O(e2.overscaledZ, n2, i3.z, r2, i3.y + 1).key] = { backfilled: false }), l2;
          }
          unloadTile(t4) {
            t4.demTexture && this.map.painter.saveTileTexture(t4.demTexture), t4.fbo && (t4.fbo.destroy(), delete t4.fbo), t4.dem && delete t4.dem, delete t4.neighboringTiles, t4.state = "unloaded", t4.actor && t4.actor.send("removeDEMTile", { uid: t4.uid, source: this.id });
          }
        }
        class B2 extends t.E {
          constructor(e2, i3, s2, a2) {
            super(), this.load = () => {
              this._updateWorkerData();
            }, this.serialize = () => t.e({}, this._options, { type: this.type, data: this._data }), this.id = e2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = s2.getActor(), this.setEventedParent(a2), this._data = i3.data, this._options = t.e({}, i3), this._collectResourceTiming = i3.collectResourceTiming, void 0 !== i3.maxzoom && (this.maxzoom = i3.maxzoom), i3.type && (this.type = i3.type), i3.attribution && (this.attribution = i3.attribution), this.promoteId = i3.promoteId;
            const o2 = t.N / this.tileSize;
            this.workerOptions = t.e({ source: this.id, cluster: i3.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i3.buffer ? i3.buffer : 128) * o2, tolerance: (void 0 !== i3.tolerance ? i3.tolerance : 0.375) * o2, extent: t.N, maxZoom: this.maxzoom, lineMetrics: i3.lineMetrics || false, generateId: i3.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i3.clusterMaxZoom ? i3.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i3.clusterMinPoints || 2), extent: t.N, radius: (i3.clusterRadius || 50) * o2, log: false, generateId: i3.generateId || false }, clusterProperties: i3.clusterProperties, filter: i3.filter }, i3.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
          }
          onAdd(t4) {
            this.map = t4, this.load();
          }
          setData(t4) {
            return this._data = t4, this._updateWorkerData(), this;
          }
          updateData(t4) {
            return this._updateWorkerData(t4), this;
          }
          setClusterOptions(t4) {
            return this.workerOptions.cluster = t4.cluster, t4 && (void 0 !== t4.clusterRadius && (this.workerOptions.superclusterOptions.radius = t4.clusterRadius), void 0 !== t4.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = t4.clusterMaxZoom)), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(t4, e2) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t4, source: this.id }, e2), this;
          }
          getClusterChildren(t4, e2) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: t4, source: this.id }, e2), this;
          }
          getClusterLeaves(t4, e2, i3, s2) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t4, limit: e2, offset: i3 }, s2), this;
          }
          _updateWorkerData(e2) {
            const i3 = t.e({}, this.workerOptions);
            e2 ? i3.dataDiff = e2 : "string" == typeof this._data ? (i3.request = this.map._requestManager.transformRequest(t.h.resolveURL(this._data), c.Source), i3.request.collectResourceTiming = this._collectResourceTiming) : i3.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new t.k("dataloading", { dataType: "source" })), this.actor.send(`${this.type}.loadData`, i3, (e3, i4) => {
              if (this._pendingLoads--, this._removed || i4 && i4.abandoned)
                return void this.fire(new t.k("dataabort", { dataType: "source" }));
              let s2 = null;
              if (i4 && i4.resourceTiming && i4.resourceTiming[this.id] && (s2 = i4.resourceTiming[this.id].slice(0)), e3)
                return void this.fire(new t.j(e3));
              const a2 = { dataType: "source" };
              this._collectResourceTiming && s2 && s2.length > 0 && t.e(a2, { resourceTiming: s2 }), this.fire(new t.k("data", Object.assign(Object.assign({}, a2), { sourceDataType: "metadata" }))), this.fire(new t.k("data", Object.assign(Object.assign({}, a2), { sourceDataType: "content" })));
            });
          }
          loaded() {
            return 0 === this._pendingLoads;
          }
          loadTile(t4, e2) {
            const i3 = t4.actor ? "reloadTile" : "loadTile";
            t4.actor = this.actor;
            const s2 = { type: this.type, uid: t4.uid, tileID: t4.tileID, zoom: t4.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            t4.request = this.actor.send(i3, s2, (s3, a2) => (delete t4.request, t4.unloadVectorData(), t4.aborted ? e2(null) : s3 ? e2(s3) : (t4.loadVectorData(a2, this.map.painter, "reloadTile" === i3), e2(null))));
          }
          abortTile(t4) {
            t4.request && (t4.request.cancel(), delete t4.request), t4.aborted = true;
          }
          unloadTile(t4) {
            t4.unloadVectorData(), this.actor.send("removeTile", { uid: t4.uid, type: this.type, source: this.id });
          }
          onRemove() {
            this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
          }
          hasTransition() {
            return false;
          }
        }
        var O = t.Q([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class N extends t.E {
          constructor(e2, i3, s2, a2) {
            super(), this.load = (e3, i4) => {
              this._loaded = false, this.fire(new t.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = h.getImage(this.map._requestManager.transformRequest(this.url, c.Image), (s3, a3) => {
                this._request = null, this._loaded = true, s3 ? this.fire(new t.j(s3)) : a3 && (this.image = a3, e3 && (this.coordinates = e3), i4 && i4(), this._finishLoading());
              });
            }, this.prepare = () => {
              if (0 === Object.keys(this.tiles).length || !this.image)
                return;
              const e3 = this.map.painter.context, i4 = e3.gl;
              this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, O.members)), this.boundsSegments || (this.boundsSegments = t.S.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new x2(e3, this.image, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE));
              let s3 = false;
              for (const t4 in this.tiles) {
                const e4 = this.tiles[t4];
                "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture, s3 = true);
              }
              s3 && this.fire(new t.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
            }, this.serialize = () => ({ type: "image", url: this.options.url, coordinates: this.coordinates }), this.id = e2, this.dispatcher = s2, this.coordinates = i3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(a2), this.options = i3;
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t4) {
            return t4.url ? (this._request && (this._request.cancel(), this._request = null), this.options.url = t4.url, this.load(t4.coordinates, () => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new t.k("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t4) {
            this.map = t4, this.load();
          }
          onRemove() {
            this._request && (this._request.cancel(), this._request = null);
          }
          setCoordinates(e2) {
            this.coordinates = e2;
            const i3 = e2.map(t.U.fromLngLat);
            this.tileID = function(e3) {
              let i4 = 1 / 0, s3 = 1 / 0, a2 = -1 / 0, o2 = -1 / 0;
              for (const t4 of e3)
                i4 = Math.min(i4, t4.x), s3 = Math.min(s3, t4.y), a2 = Math.max(a2, t4.x), o2 = Math.max(o2, t4.y);
              const r2 = Math.max(a2 - i4, o2 - s3), n2 = Math.max(0, Math.floor(-Math.log(r2) / Math.LN2)), l2 = Math.pow(2, n2);
              return new t.W(n2, Math.floor((i4 + a2) / 2 * l2), Math.floor((s3 + o2) / 2 * l2));
            }(i3), this.minzoom = this.maxzoom = this.tileID.z;
            const s2 = i3.map((t4) => this.tileID.getTilePoint(t4)._round());
            return this._boundsArray = new t.V(), this._boundsArray.emplaceBack(s2[0].x, s2[0].y, 0, 0), this._boundsArray.emplaceBack(s2[1].x, s2[1].y, t.N, 0), this._boundsArray.emplaceBack(s2[3].x, s2[3].y, 0, t.N), this._boundsArray.emplaceBack(s2[2].x, s2[2].y, t.N, t.N), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.k("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          loadTile(t4, e2) {
            this.tileID && this.tileID.equals(t4.tileID.canonical) ? (this.tiles[String(t4.tileID.wrap)] = t4, t4.buckets = {}, e2(null)) : (t4.state = "errored", e2(null));
          }
          hasTransition() {
            return false;
          }
        }
        class U extends N {
          constructor(e2, i3, s2, a2) {
            super(e2, i3, s2, a2), this.load = () => {
              this._loaded = false;
              const e3 = this.options;
              this.urls = [];
              for (const t4 of e3.urls)
                this.urls.push(this.map._requestManager.transformRequest(t4, c.Source).url);
              t.X(this.urls, (e4, i4) => {
                this._loaded = true, e4 ? this.fire(new t.j(e4)) : i4 && (this.video = i4, this.video.loop = true, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading());
              });
            }, this.prepare = () => {
              if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
                return;
              const e3 = this.map.painter.context, i4 = e3.gl;
              this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, O.members)), this.boundsSegments || (this.boundsSegments = t.S.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE), i4.texSubImage2D(i4.TEXTURE_2D, 0, 0, 0, i4.RGBA, i4.UNSIGNED_BYTE, this.video)) : (this.texture = new x2(e3, this.video, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE));
              let s3 = false;
              for (const t4 in this.tiles) {
                const e4 = this.tiles[t4];
                "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture, s3 = true);
              }
              s3 && this.fire(new t.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
            }, this.serialize = () => ({ type: "video", urls: this.urls, coordinates: this.coordinates }), this.roundZoom = true, this.type = "video", this.options = i3;
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e2) {
            if (this.video) {
              const i3 = this.video.seekable;
              e2 < i3.start(0) || e2 > i3.end(0) ? this.fire(new t.j(new t.Y(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i3.start(0)} and ${i3.end(0)}-second mark.`))) : this.video.currentTime = e2;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(t4) {
            this.map || (this.map = t4, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class Z extends N {
          constructor(e2, i3, s2, a2) {
            super(e2, i3, s2, a2), this.load = () => {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }, this.prepare = () => {
              let e3 = false;
              if (this.canvas.width !== this.width && (this.width = this.canvas.width, e3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e3 = true), this._hasInvalidDimensions())
                return;
              if (0 === Object.keys(this.tiles).length)
                return;
              const i4 = this.map.painter.context, s3 = i4.gl;
              this.boundsBuffer || (this.boundsBuffer = i4.createVertexBuffer(this._boundsArray, O.members)), this.boundsSegments || (this.boundsSegments = t.S.simpleSegment(0, 0, 4, 2)), this.texture ? (e3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new x2(i4, this.canvas, s3.RGBA, { premultiply: true });
              let a3 = false;
              for (const t4 in this.tiles) {
                const e4 = this.tiles[t4];
                "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture, a3 = true);
              }
              a3 && this.fire(new t.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
            }, this.serialize = () => ({ type: "canvas", coordinates: this.coordinates }), i3.coordinates ? Array.isArray(i3.coordinates) && 4 === i3.coordinates.length && !i3.coordinates.some((t4) => !Array.isArray(t4) || 2 !== t4.length || t4.some((t5) => "number" != typeof t5)) || this.fire(new t.j(new t.Y(`sources.${e2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.j(new t.Y(`sources.${e2}`, null, 'missing required property "coordinates"'))), i3.animate && "boolean" != typeof i3.animate && this.fire(new t.j(new t.Y(`sources.${e2}`, null, 'optional "animate" property must be a boolean value'))), i3.canvas ? "string" == typeof i3.canvas || i3.canvas instanceof HTMLCanvasElement || this.fire(new t.j(new t.Y(`sources.${e2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.j(new t.Y(`sources.${e2}`, null, 'missing required property "canvas"'))), this.options = i3, this.animate = void 0 === i3.animate || i3.animate;
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(t4) {
            this.map = t4, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const t4 of [this.canvas.width, this.canvas.height])
              if (isNaN(t4) || t4 <= 0)
                return true;
            return false;
          }
        }
        const G = {}, j = (t4) => {
          switch (t4) {
            case "geojson":
              return B2;
            case "image":
              return N;
            case "raster":
              return k;
            case "raster-dem":
              return F;
            case "vector":
              return R;
            case "video":
              return U;
            case "canvas":
              return Z;
          }
          return G[t4];
        };
        function V(e2, i3) {
          const s2 = t.Z();
          return t.$(s2, s2, [1, 1, 0]), t.a0(s2, s2, [0.5 * e2.width, 0.5 * e2.height, 1]), t.a1(s2, s2, e2.calculatePosMatrix(i3.toUnwrapped()));
        }
        function q(t4, e2, i3, s2, a2, o2) {
          const r2 = function(t5, e3, i4) {
            if (t5)
              for (const s3 of t5) {
                const t6 = e3[s3];
                if (t6 && t6.source === i4 && "fill-extrusion" === t6.type)
                  return true;
              }
            else
              for (const t6 in e3) {
                const s3 = e3[t6];
                if (s3.source === i4 && "fill-extrusion" === s3.type)
                  return true;
              }
            return false;
          }(a2 && a2.layers, e2, t4.id), n2 = o2.maxPitchScaleFactor(), l2 = t4.tilesIn(s2, n2, r2);
          l2.sort($);
          const h2 = [];
          for (const s3 of l2)
            h2.push({ wrappedTileID: s3.tileID.wrapped().key, queryResults: s3.tile.queryRenderedFeatures(e2, i3, t4._state, s3.queryGeometry, s3.cameraQueryGeometry, s3.scale, a2, o2, n2, V(t4.transform, s3.tileID)) });
          const c2 = function(t5) {
            const e3 = {}, i4 = {};
            for (const s3 of t5) {
              const t6 = s3.queryResults, a3 = s3.wrappedTileID, o3 = i4[a3] = i4[a3] || {};
              for (const i5 in t6) {
                const s4 = t6[i5], a4 = o3[i5] = o3[i5] || {}, r3 = e3[i5] = e3[i5] || [];
                for (const t7 of s4)
                  a4[t7.featureIndex] || (a4[t7.featureIndex] = true, r3.push(t7));
              }
            }
            return e3;
          }(h2);
          for (const e3 in c2)
            c2[e3].forEach((e4) => {
              const i4 = e4.feature, s3 = t4.getFeatureState(i4.layer["source-layer"], i4.id);
              i4.source = i4.layer.source, i4.layer["source-layer"] && (i4.sourceLayer = i4.layer["source-layer"]), i4.state = s3;
            });
          return c2;
        }
        function $(t4, e2) {
          const i3 = t4.tileID, s2 = e2.tileID;
          return i3.overscaledZ - s2.overscaledZ || i3.canonical.y - s2.canonical.y || i3.wrap - s2.wrap || i3.canonical.x - s2.canonical.x;
        }
        class W {
          constructor(e2, i3) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e2, this.uid = t.a2(), this.uses = 0, this.tileSize = i3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(t4) {
            const e2 = t4 + this.timeAdded;
            e2 < this.fadeEndTime || (this.fadeEndTime = e2);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          clearTextures(t4) {
            this.demTexture && t4.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e2, i3, s2) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e2) {
              e2.featureIndex && (this.latestFeatureIndex = e2.featureIndex, e2.rawTileData ? (this.latestRawTileData = e2.rawTileData, this.latestFeatureIndex.rawTileData = e2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e2.collisionBoxArray, this.buckets = function(t4, e3) {
                const i4 = {};
                if (!e3)
                  return i4;
                for (const s3 of t4) {
                  const t5 = s3.layerIds.map((t6) => e3.getLayer(t6)).filter(Boolean);
                  if (0 !== t5.length) {
                    s3.layers = t5, s3.stateDependentLayerIds && (s3.stateDependentLayers = s3.stateDependentLayerIds.map((e4) => t5.filter((t6) => t6.id === e4)[0]));
                    for (const e4 of t5)
                      i4[e4.id] = s3;
                  }
                }
                return i4;
              }(e2.buckets, i3.style), this.hasSymbolBuckets = false;
              for (const e3 in this.buckets) {
                const i4 = this.buckets[e3];
                if (i4 instanceof t.a4) {
                  if (this.hasSymbolBuckets = true, !s2)
                    break;
                  i4.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets)
                for (const e3 in this.buckets) {
                  const i4 = this.buckets[e3];
                  if (i4 instanceof t.a4 && i4.hasRTLText) {
                    this.hasRTLText = true, t.a5();
                    break;
                  }
                }
              this.queryPadding = 0;
              for (const t4 in this.buckets) {
                const e3 = this.buckets[t4];
                this.queryPadding = Math.max(this.queryPadding, i3.style.getLayer(t4).queryRadius(e3));
              }
              e2.imageAtlas && (this.imageAtlas = e2.imageAtlas), e2.glyphAtlasImage && (this.glyphAtlasImage = e2.glyphAtlasImage);
            } else
              this.collisionBoxArray = new t.a3();
          }
          unloadVectorData() {
            for (const t4 in this.buckets)
              this.buckets[t4].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(t4) {
            return this.buckets[t4.id];
          }
          upload(t4) {
            for (const e3 in this.buckets) {
              const i3 = this.buckets[e3];
              i3.uploadPending() && i3.upload(t4);
            }
            const e2 = t4.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new x2(t4, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new x2(t4, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(t4) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t4, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t4, e2, i3, s2, a2, o2, r2, n2, l2, h2) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: s2, cameraQueryGeometry: a2, scale: o2, tileSize: this.tileSize, pixelPosMatrix: h2, transform: n2, params: r2, queryPadding: this.queryPadding * l2 }, t4, e2, i3) : {};
          }
          querySourceFeatures(e2, i3) {
            const s2 = this.latestFeatureIndex;
            if (!s2 || !s2.rawTileData)
              return;
            const a2 = s2.loadVTLayers(), o2 = i3 && i3.sourceLayer ? i3.sourceLayer : "", r2 = a2._geojsonTileLayer || a2[o2];
            if (!r2)
              return;
            const n2 = t.a6(i3 && i3.filter), { z: l2, x: h2, y: c2 } = this.tileID.canonical, u2 = { z: l2, x: h2, y: c2 };
            for (let i4 = 0; i4 < r2.length; i4++) {
              const a3 = r2.feature(i4);
              if (n2.needGeometry) {
                const e3 = t.a7(a3, true);
                if (!n2.filter(new t.a8(this.tileID.overscaledZ), e3, this.tileID.canonical))
                  continue;
              } else if (!n2.filter(new t.a8(this.tileID.overscaledZ), a3))
                continue;
              const d2 = s2.getId(a3, o2), _2 = new t.a9(a3, l2, h2, c2, d2);
              _2.tile = u2, e2.push(_2);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e2) {
            const i3 = this.expirationTime;
            if (e2.cacheControl) {
              const i4 = t.aa(e2.cacheControl);
              i4["max-age"] && (this.expirationTime = Date.now() + 1e3 * i4["max-age"]);
            } else
              e2.expires && (this.expirationTime = new Date(e2.expires).getTime());
            if (this.expirationTime) {
              const t4 = Date.now();
              let e3 = false;
              if (this.expirationTime > t4)
                e3 = false;
              else if (i3)
                if (this.expirationTime < i3)
                  e3 = true;
                else {
                  const s2 = this.expirationTime - i3;
                  s2 ? this.expirationTime = t4 + Math.max(s2, 3e4) : e3 = true;
                }
              else
                e3 = true;
              e3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime)
              return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t4, e2) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t4).length)
              return;
            const i3 = this.latestFeatureIndex.loadVTLayers();
            for (const s2 in this.buckets) {
              if (!e2.style.hasLayer(s2))
                continue;
              const a2 = this.buckets[s2], o2 = a2.layers[0].sourceLayer || "_geojsonTileLayer", r2 = i3[o2], n2 = t4[o2];
              if (!r2 || !n2 || 0 === Object.keys(n2).length)
                continue;
              a2.update(n2, r2, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const l2 = e2 && e2.style && e2.style.getLayer(s2);
              l2 && (this.queryPadding = Math.max(this.queryPadding, l2.queryRadius(a2)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < t.h.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e2) {
            this.symbolFadeHoldUntil = t.h.now() + e2;
          }
          setDependencies(t4, e2) {
            const i3 = {};
            for (const t5 of e2)
              i3[t5] = true;
            this.dependencies[t4] = i3;
          }
          hasDependency(t4, e2) {
            for (const i3 of t4) {
              const t5 = this.dependencies[i3];
              if (t5) {
                for (const i4 of e2)
                  if (t5[i4])
                    return true;
              }
            }
            return false;
          }
        }
        class H {
          constructor(t4, e2) {
            this.max = t4, this.onRemove = e2, this.reset();
          }
          reset() {
            for (const t4 in this.data)
              for (const e2 of this.data[t4])
                e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
            return this.data = {}, this.order = [], this;
          }
          add(t4, e2, i3) {
            const s2 = t4.wrapped().key;
            void 0 === this.data[s2] && (this.data[s2] = []);
            const a2 = { value: e2, timeout: void 0 };
            if (void 0 !== i3 && (a2.timeout = setTimeout(() => {
              this.remove(t4, a2);
            }, i3)), this.data[s2].push(a2), this.order.push(s2), this.order.length > this.max) {
              const t5 = this._getAndRemoveByKey(this.order[0]);
              t5 && this.onRemove(t5);
            }
            return this;
          }
          has(t4) {
            return t4.wrapped().key in this.data;
          }
          getAndRemove(t4) {
            return this.has(t4) ? this._getAndRemoveByKey(t4.wrapped().key) : null;
          }
          _getAndRemoveByKey(t4) {
            const e2 = this.data[t4].shift();
            return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t4].length && delete this.data[t4], this.order.splice(this.order.indexOf(t4), 1), e2.value;
          }
          getByKey(t4) {
            const e2 = this.data[t4];
            return e2 ? e2[0].value : null;
          }
          get(t4) {
            return this.has(t4) ? this.data[t4.wrapped().key][0].value : null;
          }
          remove(t4, e2) {
            if (!this.has(t4))
              return this;
            const i3 = t4.wrapped().key, s2 = void 0 === e2 ? 0 : this.data[i3].indexOf(e2), a2 = this.data[i3][s2];
            return this.data[i3].splice(s2, 1), a2.timeout && clearTimeout(a2.timeout), 0 === this.data[i3].length && delete this.data[i3], this.onRemove(a2.value), this.order.splice(this.order.indexOf(i3), 1), this;
          }
          setMaxSize(t4) {
            for (this.max = t4; this.order.length > this.max; ) {
              const t5 = this._getAndRemoveByKey(this.order[0]);
              t5 && this.onRemove(t5);
            }
            return this;
          }
          filter(t4) {
            const e2 = [];
            for (const i3 in this.data)
              for (const s2 of this.data[i3])
                t4(s2.value) || e2.push(s2);
            for (const t5 of e2)
              this.remove(t5.value.tileID, t5);
          }
        }
        class X {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e2, i3, s2) {
            const a2 = String(i3);
            if (this.stateChanges[e2] = this.stateChanges[e2] || {}, this.stateChanges[e2][a2] = this.stateChanges[e2][a2] || {}, t.e(this.stateChanges[e2][a2], s2), null === this.deletedStates[e2]) {
              this.deletedStates[e2] = {};
              for (const t4 in this.state[e2])
                t4 !== a2 && (this.deletedStates[e2][t4] = null);
            } else if (this.deletedStates[e2] && null === this.deletedStates[e2][a2]) {
              this.deletedStates[e2][a2] = {};
              for (const t4 in this.state[e2][a2])
                s2[t4] || (this.deletedStates[e2][a2][t4] = null);
            } else
              for (const t4 in s2)
                this.deletedStates[e2] && this.deletedStates[e2][a2] && null === this.deletedStates[e2][a2][t4] && delete this.deletedStates[e2][a2][t4];
          }
          removeFeatureState(t4, e2, i3) {
            if (null === this.deletedStates[t4])
              return;
            const s2 = String(e2);
            if (this.deletedStates[t4] = this.deletedStates[t4] || {}, i3 && void 0 !== e2)
              null !== this.deletedStates[t4][s2] && (this.deletedStates[t4][s2] = this.deletedStates[t4][s2] || {}, this.deletedStates[t4][s2][i3] = null);
            else if (void 0 !== e2)
              if (this.stateChanges[t4] && this.stateChanges[t4][s2])
                for (i3 in this.deletedStates[t4][s2] = {}, this.stateChanges[t4][s2])
                  this.deletedStates[t4][s2][i3] = null;
              else
                this.deletedStates[t4][s2] = null;
            else
              this.deletedStates[t4] = null;
          }
          getState(e2, i3) {
            const s2 = String(i3), a2 = t.e({}, (this.state[e2] || {})[s2], (this.stateChanges[e2] || {})[s2]);
            if (null === this.deletedStates[e2])
              return {};
            if (this.deletedStates[e2]) {
              const t4 = this.deletedStates[e2][i3];
              if (null === t4)
                return {};
              for (const e3 in t4)
                delete a2[e3];
            }
            return a2;
          }
          initializeTileState(t4, e2) {
            t4.setFeatureState(this.state, e2);
          }
          coalesceChanges(e2, i3) {
            const s2 = {};
            for (const e3 in this.stateChanges) {
              this.state[e3] = this.state[e3] || {};
              const i4 = {};
              for (const s3 in this.stateChanges[e3])
                this.state[e3][s3] || (this.state[e3][s3] = {}), t.e(this.state[e3][s3], this.stateChanges[e3][s3]), i4[s3] = this.state[e3][s3];
              s2[e3] = i4;
            }
            for (const e3 in this.deletedStates) {
              this.state[e3] = this.state[e3] || {};
              const i4 = {};
              if (null === this.deletedStates[e3])
                for (const t4 in this.state[e3])
                  i4[t4] = {}, this.state[e3][t4] = {};
              else
                for (const t4 in this.deletedStates[e3]) {
                  if (null === this.deletedStates[e3][t4])
                    this.state[e3][t4] = {};
                  else
                    for (const i5 of Object.keys(this.deletedStates[e3][t4]))
                      delete this.state[e3][t4][i5];
                  i4[t4] = this.state[e3][t4];
                }
              s2[e3] = s2[e3] || {}, t.e(s2[e3], i4);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(s2).length)
              for (const t4 in e2)
                e2[t4].setFeatureState(s2, i3);
          }
        }
        class K2 extends t.E {
          constructor(t4, e2, i3) {
            super(), this.id = t4, this.dispatcher = i3, this.on("data", (t5) => {
              "source" === t5.dataType && "metadata" === t5.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t5.dataType && "content" === t5.sourceDataType && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
            }), this.on("dataloading", () => {
              this._sourceErrored = false;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = ((t5, e3, i4, s2) => {
              const a2 = new (j(e3.type))(t5, e3, i4, s2);
              if (a2.id !== t5)
                throw new Error(`Expected Source id to be ${t5} instead of ${a2.id}`);
              return a2;
            })(t4, e2, i3, this), this._tiles = {}, this._cache = new H(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new X(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(t4) {
            this.map = t4, this._maxTileCacheSize = t4 ? t4._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t4 ? t4._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t4);
          }
          onRemove(t4) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t4);
          }
          loaded() {
            if (this._sourceErrored)
              return true;
            if (!this._sourceLoaded)
              return false;
            if (!this._source.loaded())
              return false;
            if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain))
              return true;
            if (!this._updated)
              return false;
            for (const t4 in this._tiles) {
              const e2 = this._tiles[t4];
              if ("loaded" !== e2.state && "errored" !== e2.state)
                return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused)
              return;
            const t4 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, t4 && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(t4, e2) {
            return this._source.loadTile(t4, e2);
          }
          _unloadTile(t4) {
            if (this._source.unloadTile)
              return this._source.unloadTile(t4, () => {
              });
          }
          _abortTile(e2) {
            this._source.abortTile && this._source.abortTile(e2, () => {
            }), this._source.fire(new t.k("dataabort", { tile: e2, coord: e2.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t4) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const e2 in this._tiles) {
              const i3 = this._tiles[e2];
              i3.upload(t4), i3.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((t4) => t4.tileID).sort(Q).map((t4) => t4.key);
          }
          getRenderableIds(e2) {
            const i3 = [];
            for (const t4 in this._tiles)
              this._isIdRenderable(t4, e2) && i3.push(this._tiles[t4]);
            return e2 ? i3.sort((e3, i4) => {
              const s2 = e3.tileID, a2 = i4.tileID, o2 = new t.P(s2.canonical.x, s2.canonical.y)._rotate(this.transform.angle), r2 = new t.P(a2.canonical.x, a2.canonical.y)._rotate(this.transform.angle);
              return s2.overscaledZ - a2.overscaledZ || r2.y - o2.y || r2.x - o2.x;
            }).map((t4) => t4.tileID.key) : i3.map((t4) => t4.tileID).sort(Q).map((t4) => t4.key);
          }
          hasRenderableParent(t4) {
            const e2 = this.findLoadedParent(t4, 0);
            return !!e2 && this._isIdRenderable(e2.tileID.key);
          }
          _isIdRenderable(t4, e2) {
            return this._tiles[t4] && this._tiles[t4].hasData() && !this._coveredTiles[t4] && (e2 || !this._tiles[t4].holdingForFade());
          }
          reload() {
            if (this._paused)
              this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const t4 in this._tiles)
                "errored" !== this._tiles[t4].state && this._reloadTile(t4, "reloading");
            }
          }
          _reloadTile(t4, e2) {
            const i3 = this._tiles[t4];
            i3 && ("loading" !== i3.state && (i3.state = e2), this._loadTile(i3, this._tileLoaded.bind(this, i3, t4, e2)));
          }
          _tileLoaded(e2, i3, s2, a2) {
            if (a2)
              return e2.state = "errored", void (404 !== a2.status ? this._source.fire(new t.j(a2, { tile: e2 })) : this.update(this.transform, this.terrain));
            e2.timeAdded = t.h.now(), "expired" === s2 && (e2.refreshedUponExpiration = true), this._setTileReloadTimer(i3, e2), "raster-dem" === this.getSource().type && e2.dem && this._backfillDEM(e2), this._state.initializeTileState(e2, this.map ? this.map.painter : null), e2.aborted || this._source.fire(new t.k("data", { dataType: "source", tile: e2, coord: e2.tileID }));
          }
          _backfillDEM(t4) {
            const e2 = this.getRenderableIds();
            for (let s2 = 0; s2 < e2.length; s2++) {
              const a2 = e2[s2];
              if (t4.neighboringTiles && t4.neighboringTiles[a2]) {
                const e3 = this.getTileByID(a2);
                i3(t4, e3), i3(e3, t4);
              }
            }
            function i3(t5, e3) {
              t5.needsHillshadePrepare = true, t5.needsTerrainPrepare = true;
              let i4 = e3.tileID.canonical.x - t5.tileID.canonical.x;
              const s2 = e3.tileID.canonical.y - t5.tileID.canonical.y, a2 = Math.pow(2, t5.tileID.canonical.z), o2 = e3.tileID.key;
              0 === i4 && 0 === s2 || Math.abs(s2) > 1 || (Math.abs(i4) > 1 && (1 === Math.abs(i4 + a2) ? i4 += a2 : 1 === Math.abs(i4 - a2) && (i4 -= a2)), e3.dem && t5.dem && (t5.dem.backfillBorder(e3.dem, i4, s2), t5.neighboringTiles && t5.neighboringTiles[o2] && (t5.neighboringTiles[o2].backfilled = true)));
            }
          }
          getTile(t4) {
            return this.getTileByID(t4.key);
          }
          getTileByID(t4) {
            return this._tiles[t4];
          }
          _retainLoadedChildren(t4, e2, i3, s2) {
            for (const a2 in this._tiles) {
              let o2 = this._tiles[a2];
              if (s2[a2] || !o2.hasData() || o2.tileID.overscaledZ <= e2 || o2.tileID.overscaledZ > i3)
                continue;
              let r2 = o2.tileID;
              for (; o2 && o2.tileID.overscaledZ > e2 + 1; ) {
                const t5 = o2.tileID.scaledTo(o2.tileID.overscaledZ - 1);
                o2 = this._tiles[t5.key], o2 && o2.hasData() && (r2 = t5);
              }
              let n2 = r2;
              for (; n2.overscaledZ > e2; )
                if (n2 = n2.scaledTo(n2.overscaledZ - 1), t4[n2.key]) {
                  s2[r2.key] = r2;
                  break;
                }
            }
          }
          findLoadedParent(t4, e2) {
            if (t4.key in this._loadedParentTiles) {
              const i3 = this._loadedParentTiles[t4.key];
              return i3 && i3.tileID.overscaledZ >= e2 ? i3 : null;
            }
            for (let i3 = t4.overscaledZ - 1; i3 >= e2; i3--) {
              const e3 = t4.scaledTo(i3), s2 = this._getLoadedTile(e3);
              if (s2)
                return s2;
            }
          }
          _getLoadedTile(t4) {
            const e2 = this._tiles[t4.key];
            return e2 && e2.hasData() ? e2 : this._cache.getByKey(t4.wrapped().key);
          }
          updateCacheSize(e2) {
            const i3 = Math.ceil(e2.width / this._source.tileSize) + 1, s2 = Math.ceil(e2.height / this._source.tileSize) + 1, a2 = Math.floor(i3 * s2 * (null === this._maxTileCacheZoomLevels ? t.c.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, a2) : a2;
            this._cache.setMaxSize(o2);
          }
          handleWrapJump(t4) {
            const e2 = Math.round((t4 - (void 0 === this._prevLng ? t4 : this._prevLng)) / 360);
            if (this._prevLng = t4, e2) {
              const t5 = {};
              for (const i3 in this._tiles) {
                const s2 = this._tiles[i3];
                s2.tileID = s2.tileID.unwrapTo(s2.tileID.wrap + e2), t5[s2.tileID.key] = s2;
              }
              this._tiles = t5;
              for (const t6 in this._timers)
                clearTimeout(this._timers[t6]), delete this._timers[t6];
              for (const t6 in this._tiles)
                this._setTileReloadTimer(t6, this._tiles[t6]);
            }
          }
          update(e2, i3) {
            if (this.transform = e2, this.terrain = i3, !this._sourceLoaded || this._paused)
              return;
            let s2;
            this.updateCacheSize(e2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? s2 = e2.getVisibleUnwrappedCoordinates(this._source.tileID).map((e3) => new t.O(e3.canonical.z, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y)) : (s2 = e2.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i3 }), this._source.hasTile && (s2 = s2.filter((t4) => this._source.hasTile(t4)))) : s2 = [];
            const a2 = e2.coveringZoomLevel(this._source), o2 = Math.max(a2 - K2.maxOverzooming, this._source.minzoom), r2 = Math.max(a2 + K2.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const t4 = {};
              for (const e3 of s2)
                if (e3.canonical.z > this._source.minzoom) {
                  const i4 = e3.scaledTo(e3.canonical.z - 1);
                  t4[i4.key] = i4;
                  const s3 = e3.scaledTo(Math.max(this._source.minzoom, Math.min(e3.canonical.z, 5)));
                  t4[s3.key] = s3;
                }
              s2 = s2.concat(Object.values(t4));
            }
            const n2 = 0 === s2.length && !this._updated && this._didEmitContent;
            this._updated = true, n2 && this.fire(new t.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const l2 = this._updateRetainedTiles(s2, a2);
            if (Y(this._source.type)) {
              const e3 = {}, n3 = {}, h3 = Object.keys(l2), c2 = t.h.now();
              for (const t4 of h3) {
                const i4 = l2[t4], s3 = this._tiles[t4];
                if (!s3 || 0 !== s3.fadeEndTime && s3.fadeEndTime <= c2)
                  continue;
                const a3 = this.findLoadedParent(i4, o2);
                a3 && (this._addTile(a3.tileID), e3[a3.tileID.key] = a3.tileID), n3[t4] = i4;
              }
              this._retainLoadedChildren(n3, a2, r2, l2);
              for (const t4 in e3)
                l2[t4] || (this._coveredTiles[t4] = true, l2[t4] = e3[t4]);
              if (i3) {
                const t4 = {}, e4 = {};
                for (const i4 of s2)
                  this._tiles[i4.key].hasData() ? t4[i4.key] = i4 : e4[i4.key] = i4;
                for (const i4 in e4) {
                  const s3 = e4[i4].children(this._source.maxzoom);
                  this._tiles[s3[0].key] && this._tiles[s3[1].key] && this._tiles[s3[2].key] && this._tiles[s3[3].key] && (t4[s3[0].key] = l2[s3[0].key] = s3[0], t4[s3[1].key] = l2[s3[1].key] = s3[1], t4[s3[2].key] = l2[s3[2].key] = s3[2], t4[s3[3].key] = l2[s3[3].key] = s3[3], delete e4[i4]);
                }
                for (const i4 in e4) {
                  const s3 = this.findLoadedParent(e4[i4], this._source.minzoom);
                  if (s3) {
                    t4[s3.tileID.key] = l2[s3.tileID.key] = s3.tileID;
                    for (const e5 in t4)
                      t4[e5].isChildOf(s3.tileID) && delete t4[e5];
                  }
                }
                for (const e5 in this._tiles)
                  t4[e5] || (this._coveredTiles[e5] = true);
              }
            }
            for (const t4 in l2)
              this._tiles[t4].clearFadeHold();
            const h2 = t.ab(this._tiles, l2);
            for (const t4 of h2) {
              const e3 = this._tiles[t4];
              e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(t4);
            }
            this._updateLoadedParentTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const t4 in this._tiles)
              this._tiles[t4].holdingForFade() && this._removeTile(t4);
          }
          _updateRetainedTiles(t4, e2) {
            const i3 = {}, s2 = {}, a2 = Math.max(e2 - K2.maxOverzooming, this._source.minzoom), o2 = Math.max(e2 + K2.maxUnderzooming, this._source.minzoom), r2 = {};
            for (const s3 of t4) {
              const t5 = this._addTile(s3);
              i3[s3.key] = s3, t5.hasData() || e2 < this._source.maxzoom && (r2[s3.key] = s3);
            }
            this._retainLoadedChildren(r2, e2, o2, i3);
            for (const o3 of t4) {
              let t5 = this._tiles[o3.key];
              if (t5.hasData())
                continue;
              if (e2 + 1 > this._source.maxzoom) {
                const t6 = o3.children(this._source.maxzoom)[0], e3 = this.getTile(t6);
                if (e3 && e3.hasData()) {
                  i3[t6.key] = t6;
                  continue;
                }
              } else {
                const t6 = o3.children(this._source.maxzoom);
                if (i3[t6[0].key] && i3[t6[1].key] && i3[t6[2].key] && i3[t6[3].key])
                  continue;
              }
              let r3 = t5.wasRequested();
              for (let e3 = o3.overscaledZ - 1; e3 >= a2; --e3) {
                const a3 = o3.scaledTo(e3);
                if (s2[a3.key])
                  break;
                if (s2[a3.key] = true, t5 = this.getTile(a3), !t5 && r3 && (t5 = this._addTile(a3)), t5) {
                  const e4 = t5.hasData();
                  if ((r3 || e4) && (i3[a3.key] = a3), r3 = t5.wasRequested(), e4)
                    break;
                }
              }
            }
            return i3;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const t4 in this._tiles) {
              const e2 = [];
              let i3, s2 = this._tiles[t4].tileID;
              for (; s2.overscaledZ > 0; ) {
                if (s2.key in this._loadedParentTiles) {
                  i3 = this._loadedParentTiles[s2.key];
                  break;
                }
                e2.push(s2.key);
                const t5 = s2.scaledTo(s2.overscaledZ - 1);
                if (i3 = this._getLoadedTile(t5), i3)
                  break;
                s2 = t5;
              }
              for (const t5 of e2)
                this._loadedParentTiles[t5] = i3;
            }
          }
          _addTile(e2) {
            let i3 = this._tiles[e2.key];
            if (i3)
              return i3;
            i3 = this._cache.getAndRemove(e2), i3 && (this._setTileReloadTimer(e2.key, i3), i3.tileID = e2, this._state.initializeTileState(i3, this.map ? this.map.painter : null), this._cacheTimers[e2.key] && (clearTimeout(this._cacheTimers[e2.key]), delete this._cacheTimers[e2.key], this._setTileReloadTimer(e2.key, i3)));
            const s2 = i3;
            return i3 || (i3 = new W(e2, this._source.tileSize * e2.overscaleFactor()), this._loadTile(i3, this._tileLoaded.bind(this, i3, e2.key, i3.state))), i3.uses++, this._tiles[e2.key] = i3, s2 || this._source.fire(new t.k("dataloading", { tile: i3, coord: i3.tileID, dataType: "source" })), i3;
          }
          _setTileReloadTimer(t4, e2) {
            t4 in this._timers && (clearTimeout(this._timers[t4]), delete this._timers[t4]);
            const i3 = e2.getExpiryTimeout();
            i3 && (this._timers[t4] = setTimeout(() => {
              this._reloadTile(t4, "expired"), delete this._timers[t4];
            }, i3));
          }
          _removeTile(t4) {
            const e2 = this._tiles[t4];
            e2 && (e2.uses--, delete this._tiles[t4], this._timers[t4] && (clearTimeout(this._timers[t4]), delete this._timers[t4]), e2.uses > 0 || (e2.hasData() && "reloading" !== e2.state ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const t4 in this._tiles)
              this._removeTile(t4);
            this._cache.reset();
          }
          tilesIn(e2, i3, s2) {
            const a2 = [], o2 = this.transform;
            if (!o2)
              return a2;
            const r2 = s2 ? o2.getCameraQueryGeometry(e2) : e2, n2 = e2.map((t4) => o2.pointCoordinate(t4, this.terrain)), l2 = r2.map((t4) => o2.pointCoordinate(t4, this.terrain)), h2 = this.getIds();
            let c2 = 1 / 0, u2 = 1 / 0, d2 = -1 / 0, _2 = -1 / 0;
            for (const t4 of l2)
              c2 = Math.min(c2, t4.x), u2 = Math.min(u2, t4.y), d2 = Math.max(d2, t4.x), _2 = Math.max(_2, t4.y);
            for (let e3 = 0; e3 < h2.length; e3++) {
              const s3 = this._tiles[h2[e3]];
              if (s3.holdingForFade())
                continue;
              const r3 = s3.tileID, p2 = Math.pow(2, o2.zoom - s3.tileID.overscaledZ), m2 = i3 * s3.queryPadding * t.N / s3.tileSize / p2, f2 = [r3.getTilePoint(new t.U(c2, u2)), r3.getTilePoint(new t.U(d2, _2))];
              if (f2[0].x - m2 < t.N && f2[0].y - m2 < t.N && f2[1].x + m2 >= 0 && f2[1].y + m2 >= 0) {
                const t4 = n2.map((t5) => r3.getTilePoint(t5)), e4 = l2.map((t5) => r3.getTilePoint(t5));
                a2.push({ tile: s3, tileID: r3, queryGeometry: t4, cameraQueryGeometry: e4, scale: p2 });
              }
            }
            return a2;
          }
          getVisibleCoordinates(t4) {
            const e2 = this.getRenderableIds(t4).map((t5) => this._tiles[t5].tileID);
            for (const t5 of e2)
              t5.posMatrix = this.transform.calculatePosMatrix(t5.toUnwrapped());
            return e2;
          }
          hasTransition() {
            if (this._source.hasTransition())
              return true;
            if (Y(this._source.type)) {
              const e2 = t.h.now();
              for (const t4 in this._tiles)
                if (this._tiles[t4].fadeEndTime >= e2)
                  return true;
            }
            return false;
          }
          setFeatureState(t4, e2, i3) {
            this._state.updateState(t4 = t4 || "_geojsonTileLayer", e2, i3);
          }
          removeFeatureState(t4, e2, i3) {
            this._state.removeFeatureState(t4 = t4 || "_geojsonTileLayer", e2, i3);
          }
          getFeatureState(t4, e2) {
            return this._state.getState(t4 = t4 || "_geojsonTileLayer", e2);
          }
          setDependencies(t4, e2, i3) {
            const s2 = this._tiles[t4];
            s2 && s2.setDependencies(e2, i3);
          }
          reloadTilesForDependencies(t4, e2) {
            for (const i3 in this._tiles)
              this._tiles[i3].hasDependency(t4, e2) && this._reloadTile(i3, "reloading");
            this._cache.filter((i3) => !i3.hasDependency(t4, e2));
          }
        }
        function Q(t4, e2) {
          const i3 = Math.abs(2 * t4.wrap) - +(t4.wrap < 0), s2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
          return t4.overscaledZ - e2.overscaledZ || s2 - i3 || e2.canonical.y - t4.canonical.y || e2.canonical.x - t4.canonical.x;
        }
        function Y(t4) {
          return "raster" === t4 || "image" === t4 || "video" === t4;
        }
        K2.maxOverzooming = 10, K2.maxUnderzooming = 3;
        const J = "mapboxgl_preloaded_worker_pool";
        class tt {
          constructor() {
            this.active = {};
          }
          acquire(e2) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < tt.workerCount; )
                this.workers.push(new Worker(t.c.WORKER_URL));
            return this.active[e2] = true, this.workers.slice();
          }
          release(t4) {
            delete this.active[t4], 0 === this.numActive() && (this.workers.forEach((t5) => {
              t5.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[J];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const et2 = Math.floor(t.h.hardwareConcurrency / 2);
        let it;
        function st() {
          return it || (it = new tt()), it;
        }
        tt.workerCount = t.ac(globalThis) ? Math.max(Math.min(et2, 3), 1) : 1;
        class at {
          constructor(t4, e2) {
            this.reset(t4, e2);
          }
          reset(t4, e2) {
            this.points = t4 || [], this._distances = [0];
            for (let t5 = 1; t5 < this.points.length; t5++)
              this._distances[t5] = this._distances[t5 - 1] + this.points[t5].dist(this.points[t5 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e2) {
            if (1 === this.points.length)
              return this.points[0];
            e2 = t.ad(e2, 0, 1);
            let i3 = 1, s2 = this._distances[i3];
            const a2 = e2 * this.paddedLength + this.padding;
            for (; s2 < a2 && i3 < this._distances.length; )
              s2 = this._distances[++i3];
            const o2 = i3 - 1, r2 = this._distances[o2], n2 = s2 - r2, l2 = n2 > 0 ? (a2 - r2) / n2 : 0;
            return this.points[o2].mult(1 - l2).add(this.points[i3].mult(l2));
          }
        }
        function ot(t4, e2) {
          let i3 = true;
          return "always" === t4 || "never" !== t4 && "never" !== e2 || (i3 = false), i3;
        }
        class rt {
          constructor(t4, e2, i3) {
            const s2 = this.boxCells = [], a2 = this.circleCells = [];
            this.xCellCount = Math.ceil(t4 / i3), this.yCellCount = Math.ceil(e2 / i3);
            for (let t5 = 0; t5 < this.xCellCount * this.yCellCount; t5++)
              s2.push([]), a2.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t4, this.height = e2, this.xScale = this.xCellCount / t4, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t4, e2, i3, s2, a2) {
            this._forEachCell(e2, i3, s2, a2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t4), this.bboxes.push(e2), this.bboxes.push(i3), this.bboxes.push(s2), this.bboxes.push(a2);
          }
          insertCircle(t4, e2, i3, s2) {
            this._forEachCell(e2 - s2, i3 - s2, e2 + s2, i3 + s2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t4), this.circles.push(e2), this.circles.push(i3), this.circles.push(s2);
          }
          _insertBoxCell(t4, e2, i3, s2, a2, o2) {
            this.boxCells[a2].push(o2);
          }
          _insertCircleCell(t4, e2, i3, s2, a2, o2) {
            this.circleCells[a2].push(o2);
          }
          _query(t4, e2, i3, s2, a2, o2, r2) {
            if (i3 < 0 || t4 > this.width || s2 < 0 || e2 > this.height)
              return [];
            const n2 = [];
            if (t4 <= 0 && e2 <= 0 && this.width <= i3 && this.height <= s2) {
              if (a2)
                return [{ key: null, x1: t4, y1: e2, x2: i3, y2: s2 }];
              for (let t5 = 0; t5 < this.boxKeys.length; t5++)
                n2.push({ key: this.boxKeys[t5], x1: this.bboxes[4 * t5], y1: this.bboxes[4 * t5 + 1], x2: this.bboxes[4 * t5 + 2], y2: this.bboxes[4 * t5 + 3] });
              for (let t5 = 0; t5 < this.circleKeys.length; t5++) {
                const e3 = this.circles[3 * t5], i4 = this.circles[3 * t5 + 1], s3 = this.circles[3 * t5 + 2];
                n2.push({ key: this.circleKeys[t5], x1: e3 - s3, y1: i4 - s3, x2: e3 + s3, y2: i4 + s3 });
              }
            } else
              this._forEachCell(t4, e2, i3, s2, this._queryCell, n2, { hitTest: a2, overlapMode: o2, seenUids: { box: {}, circle: {} } }, r2);
            return n2;
          }
          query(t4, e2, i3, s2) {
            return this._query(t4, e2, i3, s2, false, null);
          }
          hitTest(t4, e2, i3, s2, a2, o2) {
            return this._query(t4, e2, i3, s2, true, a2, o2).length > 0;
          }
          hitTestCircle(t4, e2, i3, s2, a2) {
            const o2 = t4 - i3, r2 = t4 + i3, n2 = e2 - i3, l2 = e2 + i3;
            if (r2 < 0 || o2 > this.width || l2 < 0 || n2 > this.height)
              return false;
            const h2 = [];
            return this._forEachCell(o2, n2, r2, l2, this._queryCellCircle, h2, { hitTest: true, overlapMode: s2, circle: { x: t4, y: e2, radius: i3 }, seenUids: { box: {}, circle: {} } }, a2), h2.length > 0;
          }
          _queryCell(t4, e2, i3, s2, a2, o2, r2, n2) {
            const { seenUids: l2, hitTest: h2, overlapMode: c2 } = r2, u2 = this.boxCells[a2];
            if (null !== u2) {
              const a3 = this.bboxes;
              for (const r3 of u2)
                if (!l2.box[r3]) {
                  l2.box[r3] = true;
                  const u3 = 4 * r3, d3 = this.boxKeys[r3];
                  if (t4 <= a3[u3 + 2] && e2 <= a3[u3 + 3] && i3 >= a3[u3 + 0] && s2 >= a3[u3 + 1] && (!n2 || n2(d3)) && (!h2 || !ot(c2, d3.overlapMode)) && (o2.push({ key: d3, x1: a3[u3], y1: a3[u3 + 1], x2: a3[u3 + 2], y2: a3[u3 + 3] }), h2))
                    return true;
                }
            }
            const d2 = this.circleCells[a2];
            if (null !== d2) {
              const a3 = this.circles;
              for (const r3 of d2)
                if (!l2.circle[r3]) {
                  l2.circle[r3] = true;
                  const u3 = 3 * r3, d3 = this.circleKeys[r3];
                  if (this._circleAndRectCollide(a3[u3], a3[u3 + 1], a3[u3 + 2], t4, e2, i3, s2) && (!n2 || n2(d3)) && (!h2 || !ot(c2, d3.overlapMode))) {
                    const t5 = a3[u3], e3 = a3[u3 + 1], i4 = a3[u3 + 2];
                    if (o2.push({ key: d3, x1: t5 - i4, y1: e3 - i4, x2: t5 + i4, y2: e3 + i4 }), h2)
                      return true;
                  }
                }
            }
            return false;
          }
          _queryCellCircle(t4, e2, i3, s2, a2, o2, r2, n2) {
            const { circle: l2, seenUids: h2, overlapMode: c2 } = r2, u2 = this.boxCells[a2];
            if (null !== u2) {
              const t5 = this.bboxes;
              for (const e3 of u2)
                if (!h2.box[e3]) {
                  h2.box[e3] = true;
                  const i4 = 4 * e3, s3 = this.boxKeys[e3];
                  if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, t5[i4 + 0], t5[i4 + 1], t5[i4 + 2], t5[i4 + 3]) && (!n2 || n2(s3)) && !ot(c2, s3.overlapMode))
                    return o2.push(true), true;
                }
            }
            const d2 = this.circleCells[a2];
            if (null !== d2) {
              const t5 = this.circles;
              for (const e3 of d2)
                if (!h2.circle[e3]) {
                  h2.circle[e3] = true;
                  const i4 = 3 * e3, s3 = this.circleKeys[e3];
                  if (this._circlesCollide(t5[i4], t5[i4 + 1], t5[i4 + 2], l2.x, l2.y, l2.radius) && (!n2 || n2(s3)) && !ot(c2, s3.overlapMode))
                    return o2.push(true), true;
                }
            }
          }
          _forEachCell(t4, e2, i3, s2, a2, o2, r2, n2) {
            const l2 = this._convertToXCellCoord(t4), h2 = this._convertToYCellCoord(e2), c2 = this._convertToXCellCoord(i3), u2 = this._convertToYCellCoord(s2);
            for (let d2 = l2; d2 <= c2; d2++)
              for (let l3 = h2; l3 <= u2; l3++)
                if (a2.call(this, t4, e2, i3, s2, this.xCellCount * l3 + d2, o2, r2, n2))
                  return;
          }
          _convertToXCellCoord(t4) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t4 * this.xScale)));
          }
          _convertToYCellCoord(t4) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t4 * this.yScale)));
          }
          _circlesCollide(t4, e2, i3, s2, a2, o2) {
            const r2 = s2 - t4, n2 = a2 - e2, l2 = i3 + o2;
            return l2 * l2 > r2 * r2 + n2 * n2;
          }
          _circleAndRectCollide(t4, e2, i3, s2, a2, o2, r2) {
            const n2 = (o2 - s2) / 2, l2 = Math.abs(t4 - (s2 + n2));
            if (l2 > n2 + i3)
              return false;
            const h2 = (r2 - a2) / 2, c2 = Math.abs(e2 - (a2 + h2));
            if (c2 > h2 + i3)
              return false;
            if (l2 <= n2 || c2 <= h2)
              return true;
            const u2 = l2 - n2, d2 = c2 - h2;
            return u2 * u2 + d2 * d2 <= i3 * i3;
          }
        }
        function nt(e2, i3, s2, a2, o2) {
          const r2 = t.Z();
          return i3 ? (t.a0(r2, r2, [1 / o2, 1 / o2, 1]), s2 || t.ae(r2, r2, a2.angle)) : t.a1(r2, a2.labelPlaneMatrix, e2), r2;
        }
        function lt(e2, i3, s2, a2, o2) {
          if (i3) {
            const i4 = t.af(e2);
            return t.a0(i4, i4, [o2, o2, 1]), s2 || t.ae(i4, i4, -a2.angle), i4;
          }
          return a2.glCoordMatrix;
        }
        function ht(e2, i3, s2) {
          let a2;
          s2 ? (a2 = [e2.x, e2.y, s2(e2.x, e2.y), 1], t.ag(a2, a2, i3)) : (a2 = [e2.x, e2.y, 0, 1], Tt(a2, a2, i3));
          const o2 = a2[3];
          return { point: new t.P(a2[0] / o2, a2[1] / o2), signedDistanceFromCamera: o2 };
        }
        function ct(t4, e2) {
          return 0.5 + t4 / e2 * 0.5;
        }
        function ut(t4, e2) {
          const i3 = t4[0] / t4[3], s2 = t4[1] / t4[3];
          return i3 >= -e2[0] && i3 <= e2[0] && s2 >= -e2[1] && s2 <= e2[1];
        }
        function dt(e2, i3, s2, a2, o2, r2, n2, l2, h2, c2) {
          const u2 = a2 ? e2.textSizeData : e2.iconSizeData, d2 = t.ah(u2, s2.transform.zoom), _2 = [256 / s2.width * 2 + 1, 256 / s2.height * 2 + 1], p2 = a2 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
          p2.clear();
          const m2 = e2.lineVertexArray, f2 = a2 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, g2 = s2.transform.width / s2.transform.height;
          let v2 = false;
          for (let a3 = 0; a3 < f2.length; a3++) {
            const x3 = f2.get(a3);
            if (x3.hidden || x3.writingMode === t.ai.vertical && !v2) {
              wt(x3.numGlyphs, p2);
              continue;
            }
            let y2;
            if (v2 = false, c2 ? (y2 = [x3.anchorX, x3.anchorY, c2(x3.anchorX, x3.anchorY), 1], t.ag(y2, y2, i3)) : (y2 = [x3.anchorX, x3.anchorY, 0, 1], Tt(y2, y2, i3)), !ut(y2, _2)) {
              wt(x3.numGlyphs, p2);
              continue;
            }
            const b2 = ct(s2.transform.cameraToCenterDistance, y2[3]), w2 = t.aj(u2, d2, x3), T3 = n2 ? w2 / b2 : w2 * b2, I2 = new t.P(x3.anchorX, x3.anchorY), E3 = ht(I2, o2, c2).point, S2 = { projections: {}, offsets: {} }, C3 = mt(x3, T3, false, l2, i3, o2, r2, e2.glyphOffsetArray, m2, p2, E3, I2, S2, g2, h2, c2);
            v2 = C3.useVertical, (C3.notEnoughRoom || v2 || C3.needsFlipping && mt(x3, T3, true, l2, i3, o2, r2, e2.glyphOffsetArray, m2, p2, E3, I2, S2, g2, h2, c2).notEnoughRoom) && wt(x3.numGlyphs, p2);
          }
          a2 ? e2.text.dynamicLayoutVertexBuffer.updateData(p2) : e2.icon.dynamicLayoutVertexBuffer.updateData(p2);
        }
        function _t(t4, e2, i3, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2) {
          const _2 = n2.glyphStartIndex + n2.numGlyphs, p2 = n2.lineStartIndex, m2 = n2.lineStartIndex + n2.lineLength, f2 = e2.getoffsetX(n2.glyphStartIndex), g2 = e2.getoffsetX(_2 - 1), v2 = yt(t4 * f2, i3, s2, a2, o2, r2, n2.segment, p2, m2, l2, h2, c2, u2, d2);
          if (!v2)
            return null;
          const x3 = yt(t4 * g2, i3, s2, a2, o2, r2, n2.segment, p2, m2, l2, h2, c2, u2, d2);
          return x3 ? { first: v2, last: x3 } : null;
        }
        function pt(e2, i3, s2, a2) {
          return e2 === t.ai.horizontal && Math.abs(s2.y - i3.y) > Math.abs(s2.x - i3.x) * a2 ? { useVertical: true } : (e2 === t.ai.vertical ? i3.y < s2.y : i3.x > s2.x) ? { needsFlipping: true } : null;
        }
        function mt(e2, i3, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2, m2, f2) {
          const g2 = i3 / 24, v2 = e2.lineOffsetX * g2, x3 = e2.lineOffsetY * g2;
          let y2;
          if (e2.numGlyphs > 1) {
            const t4 = e2.glyphStartIndex + e2.numGlyphs, i4 = e2.lineStartIndex, o3 = e2.lineStartIndex + e2.lineLength, c3 = _t(g2, l2, v2, x3, s2, u2, d2, e2, h2, r2, _2, m2, f2);
            if (!c3)
              return { notEnoughRoom: true };
            const b2 = ht(c3.first.point, n2, f2).point, w2 = ht(c3.last.point, n2, f2).point;
            if (a2 && !s2) {
              const t5 = pt(e2.writingMode, b2, w2, p2);
              if (t5)
                return t5;
            }
            y2 = [c3.first];
            for (let a3 = e2.glyphStartIndex + 1; a3 < t4 - 1; a3++)
              y2.push(yt(g2 * l2.getoffsetX(a3), v2, x3, s2, u2, d2, e2.segment, i4, o3, h2, r2, _2, m2, f2));
            y2.push(c3.last);
          } else {
            if (a2 && !s2) {
              const i5 = ht(d2, o2, f2).point, s3 = e2.lineStartIndex + e2.segment + 1, a3 = new t.P(h2.getx(s3), h2.gety(s3)), r3 = ht(a3, o2, f2), n3 = r3.signedDistanceFromCamera > 0 ? r3.point : ft(d2, a3, i5, 1, o2, f2), l3 = pt(e2.writingMode, i5, n3, p2);
              if (l3)
                return l3;
            }
            const i4 = yt(g2 * l2.getoffsetX(e2.glyphStartIndex), v2, x3, s2, u2, d2, e2.segment, e2.lineStartIndex, e2.lineStartIndex + e2.lineLength, h2, r2, _2, m2, f2);
            if (!i4)
              return { notEnoughRoom: true };
            y2 = [i4];
          }
          for (const e3 of y2)
            t.ak(c2, e3.point, e3.angle);
          return {};
        }
        function ft(t4, e2, i3, s2, a2, o2) {
          const r2 = ht(t4.add(t4.sub(e2)._unit()), a2, o2).point, n2 = i3.sub(r2);
          return i3.add(n2._mult(s2 / n2.mag()));
        }
        function gt(e2, i3) {
          const { projectionCache: s2, lineVertexArray: a2, labelPlaneMatrix: o2, tileAnchorPoint: r2, distanceFromAnchor: n2, getElevation: l2, previousVertex: h2, direction: c2, absOffsetX: u2 } = i3;
          if (s2.projections[e2])
            return s2.projections[e2];
          const d2 = new t.P(a2.getx(e2), a2.gety(e2)), _2 = ht(d2, o2, l2);
          if (_2.signedDistanceFromCamera > 0)
            return s2.projections[e2] = _2.point, _2.point;
          const p2 = e2 - c2;
          return ft(0 === n2 ? r2 : new t.P(a2.getx(p2), a2.gety(p2)), d2, h2, u2 - n2 + 1, o2, l2);
        }
        function vt(t4, e2, i3) {
          return t4._unit()._perp()._mult(e2 * i3);
        }
        function xt(e2, i3, s2, a2, o2, r2, n2, l2) {
          const { projectionCache: h2, direction: c2 } = l2;
          if (h2.offsets[e2])
            return h2.offsets[e2];
          const u2 = s2.add(i3);
          if (e2 + c2 < a2 || e2 + c2 >= o2)
            return h2.offsets[e2] = u2, u2;
          const d2 = gt(e2 + c2, l2), _2 = vt(d2.sub(s2), n2, c2), p2 = s2.add(_2), m2 = d2.add(_2);
          return h2.offsets[e2] = t.al(r2, u2, p2, m2) || u2, h2.offsets[e2];
        }
        function yt(t4, e2, i3, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2, _2) {
          const p2 = s2 ? t4 - e2 : t4 + e2;
          let m2 = p2 > 0 ? 1 : -1, f2 = 0;
          s2 && (m2 *= -1, f2 = Math.PI), m2 < 0 && (f2 += Math.PI);
          let g2, v2, x3 = m2 > 0 ? n2 + r2 : n2 + r2 + 1, y2 = a2, b2 = a2, w2 = 0, T3 = 0;
          const I2 = Math.abs(p2), E3 = [];
          let S2;
          for (; w2 + T3 <= I2; ) {
            if (x3 += m2, x3 < n2 || x3 >= l2)
              return null;
            w2 += T3, b2 = y2, v2 = g2;
            const t5 = { projectionCache: u2, lineVertexArray: h2, labelPlaneMatrix: c2, tileAnchorPoint: o2, distanceFromAnchor: w2, getElevation: _2, previousVertex: b2, direction: m2, absOffsetX: I2 };
            if (y2 = gt(x3, t5), 0 === i3)
              E3.push(b2), S2 = y2.sub(b2);
            else {
              let e3;
              const s3 = y2.sub(b2);
              e3 = 0 === s3.mag() ? vt(gt(x3 + m2, t5).sub(y2), i3, m2) : vt(s3, i3, m2), v2 || (v2 = b2.add(e3)), g2 = xt(x3, e3, y2, n2, l2, v2, i3, t5), E3.push(v2), S2 = g2.sub(v2);
            }
            T3 = S2.mag();
          }
          const C3 = S2._mult((I2 - w2) / T3)._add(v2 || b2), P2 = f2 + Math.atan2(y2.y - b2.y, y2.x - b2.x);
          return E3.push(C3), { point: C3, angle: d2 ? P2 : 0, path: E3 };
        }
        const bt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function wt(t4, e2) {
          for (let i3 = 0; i3 < t4; i3++) {
            const t5 = e2.length;
            e2.resize(t5 + 4), e2.float32.set(bt, 3 * t5);
          }
        }
        function Tt(t4, e2, i3) {
          const s2 = e2[0], a2 = e2[1];
          return t4[0] = i3[0] * s2 + i3[4] * a2 + i3[12], t4[1] = i3[1] * s2 + i3[5] * a2 + i3[13], t4[3] = i3[3] * s2 + i3[7] * a2 + i3[15], t4;
        }
        const It = 100;
        class Et {
          constructor(t4, e2 = new rt(t4.width + 200, t4.height + 200, 25), i3 = new rt(t4.width + 200, t4.height + 200, 25)) {
            this.transform = t4, this.grid = e2, this.ignoredGrid = i3, this.pitchfactor = Math.cos(t4._pitch) * t4.cameraToCenterDistance, this.screenRightBoundary = t4.width + It, this.screenBottomBoundary = t4.height + It, this.gridRightBoundary = t4.width + 200, this.gridBottomBoundary = t4.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(t4, e2, i3, s2, a2, o2) {
            const r2 = this.projectAndGetPerspectiveRatio(s2, t4.anchorPointX, t4.anchorPointY, o2), n2 = i3 * r2.perspectiveRatio, l2 = t4.x1 * n2 + r2.point.x, h2 = t4.y1 * n2 + r2.point.y, c2 = t4.x2 * n2 + r2.point.x, u2 = t4.y2 * n2 + r2.point.y;
            return !this.isInsideGrid(l2, h2, c2, u2) || "always" !== e2 && this.grid.hitTest(l2, h2, c2, u2, e2, a2) || r2.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [l2, h2, c2, u2], offscreen: this.isOffscreen(l2, h2, c2, u2) };
          }
          placeCollisionCircles(e2, i3, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2) {
            const m2 = [], f2 = new t.P(i3.anchorX, i3.anchorY), g2 = ht(f2, r2, p2), v2 = ct(this.transform.cameraToCenterDistance, g2.signedDistanceFromCamera), x3 = (c2 ? o2 / v2 : o2 * v2) / t.ap, y2 = ht(f2, n2, p2).point, b2 = _t(x3, a2, i3.lineOffsetX * x3, i3.lineOffsetY * x3, false, y2, f2, i3, s2, n2, { projections: {}, offsets: {} }, false, p2);
            let w2 = false, T3 = false, I2 = true;
            if (b2) {
              const i4 = 0.5 * d2 * v2 + _2, s3 = new t.P(-100, -100), a3 = new t.P(this.screenRightBoundary, this.screenBottomBoundary), o3 = new at(), r3 = b2.first, n3 = b2.last;
              let c3 = [];
              for (let t4 = r3.path.length - 1; t4 >= 1; t4--)
                c3.push(r3.path[t4]);
              for (let t4 = 1; t4 < n3.path.length; t4++)
                c3.push(n3.path[t4]);
              const f3 = 2.5 * i4;
              if (l2) {
                const t4 = c3.map((t5) => ht(t5, l2, p2));
                c3 = t4.some((t5) => t5.signedDistanceFromCamera <= 0) ? [] : t4.map((t5) => t5.point);
              }
              let g3 = [];
              if (c3.length > 0) {
                const e3 = c3[0].clone(), i5 = c3[0].clone();
                for (let t4 = 1; t4 < c3.length; t4++)
                  e3.x = Math.min(e3.x, c3[t4].x), e3.y = Math.min(e3.y, c3[t4].y), i5.x = Math.max(i5.x, c3[t4].x), i5.y = Math.max(i5.y, c3[t4].y);
                g3 = e3.x >= s3.x && i5.x <= a3.x && e3.y >= s3.y && i5.y <= a3.y ? [c3] : i5.x < s3.x || e3.x > a3.x || i5.y < s3.y || e3.y > a3.y ? [] : t.am([c3], s3.x, s3.y, a3.x, a3.y);
              }
              for (const t4 of g3) {
                o3.reset(t4, 0.25 * i4);
                let s4 = 0;
                s4 = o3.length <= 0.5 * i4 ? 1 : Math.ceil(o3.paddedLength / f3) + 1;
                for (let t5 = 0; t5 < s4; t5++) {
                  const a4 = t5 / Math.max(s4 - 1, 1), r4 = o3.lerp(a4), n4 = r4.x + It, l3 = r4.y + It;
                  m2.push(n4, l3, i4, 0);
                  const c4 = n4 - i4, d3 = l3 - i4, _3 = n4 + i4, p3 = l3 + i4;
                  if (I2 = I2 && this.isOffscreen(c4, d3, _3, p3), T3 = T3 || this.isInsideGrid(c4, d3, _3, p3), "always" !== e2 && this.grid.hitTestCircle(n4, l3, i4, e2, u2) && (w2 = true, !h2))
                    return { circles: [], offscreen: false, collisionDetected: w2 };
                }
              }
            }
            return { circles: !h2 && w2 || !T3 || v2 < this.perspectiveRatioCutoff ? [] : m2, offscreen: I2, collisionDetected: w2 };
          }
          queryRenderedSymbols(e2) {
            if (0 === e2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
              return {};
            const i3 = [];
            let s2 = 1 / 0, a2 = 1 / 0, o2 = -1 / 0, r2 = -1 / 0;
            for (const n3 of e2) {
              const e3 = new t.P(n3.x + It, n3.y + It);
              s2 = Math.min(s2, e3.x), a2 = Math.min(a2, e3.y), o2 = Math.max(o2, e3.x), r2 = Math.max(r2, e3.y), i3.push(e3);
            }
            const n2 = this.grid.query(s2, a2, o2, r2).concat(this.ignoredGrid.query(s2, a2, o2, r2)), l2 = {}, h2 = {};
            for (const e3 of n2) {
              const s3 = e3.key;
              if (void 0 === l2[s3.bucketInstanceId] && (l2[s3.bucketInstanceId] = {}), l2[s3.bucketInstanceId][s3.featureIndex])
                continue;
              const a3 = [new t.P(e3.x1, e3.y1), new t.P(e3.x2, e3.y1), new t.P(e3.x2, e3.y2), new t.P(e3.x1, e3.y2)];
              t.an(i3, a3) && (l2[s3.bucketInstanceId][s3.featureIndex] = true, void 0 === h2[s3.bucketInstanceId] && (h2[s3.bucketInstanceId] = []), h2[s3.bucketInstanceId].push(s3.featureIndex));
            }
            return h2;
          }
          insertCollisionBox(t4, e2, i3, s2, a2, o2) {
            (i3 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: s2, featureIndex: a2, collisionGroupID: o2, overlapMode: e2 }, t4[0], t4[1], t4[2], t4[3]);
          }
          insertCollisionCircles(t4, e2, i3, s2, a2, o2) {
            const r2 = i3 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: s2, featureIndex: a2, collisionGroupID: o2, overlapMode: e2 };
            for (let e3 = 0; e3 < t4.length; e3 += 4)
              r2.insertCircle(n2, t4[e3], t4[e3 + 1], t4[e3 + 2]);
          }
          projectAndGetPerspectiveRatio(e2, i3, s2, a2) {
            let o2;
            return a2 ? (o2 = [i3, s2, a2(i3, s2), 1], t.ag(o2, o2, e2)) : (o2 = [i3, s2, 0, 1], Tt(o2, o2, e2)), { point: new t.P((o2[0] / o2[3] + 1) / 2 * this.transform.width + It, (-o2[1] / o2[3] + 1) / 2 * this.transform.height + It), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / o2[3] * 0.5 };
          }
          isOffscreen(t4, e2, i3, s2) {
            return i3 < It || t4 >= this.screenRightBoundary || s2 < It || e2 > this.screenBottomBoundary;
          }
          isInsideGrid(t4, e2, i3, s2) {
            return i3 >= 0 && t4 < this.gridRightBoundary && s2 >= 0 && e2 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e2 = t.ao([]);
            return t.$(e2, e2, [-100, -100, 0]), e2;
          }
        }
        function St(e2, i3, s2) {
          return i3 * (t.N / (e2.tileSize * Math.pow(2, s2 - e2.tileID.overscaledZ)));
        }
        class Ct {
          constructor(t4, e2, i3, s2) {
            this.opacity = t4 ? Math.max(0, Math.min(1, t4.opacity + (t4.placed ? e2 : -e2))) : s2 && i3 ? 1 : 0, this.placed = i3;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class Pt {
          constructor(t4, e2, i3, s2, a2) {
            this.text = new Ct(t4 ? t4.text : null, e2, i3, a2), this.icon = new Ct(t4 ? t4.icon : null, e2, s2, a2);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Dt {
          constructor(t4, e2, i3) {
            this.text = t4, this.icon = e2, this.skipFade = i3;
          }
        }
        class Mt {
          constructor() {
            this.invProjMatrix = t.Z(), this.viewportMatrix = t.Z(), this.circles = [];
          }
        }
        class zt {
          constructor(t4, e2, i3, s2, a2) {
            this.bucketInstanceId = t4, this.featureIndex = e2, this.sourceLayerIndex = i3, this.bucketIndex = s2, this.tileID = a2;
          }
        }
        class Lt {
          constructor(t4) {
            this.crossSourceCollisions = t4, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(t4) {
            if (this.crossSourceCollisions)
              return { ID: 0, predicate: null };
            if (!this.collisionGroups[t4]) {
              const e2 = ++this.maxGroupID;
              this.collisionGroups[t4] = { ID: e2, predicate: (t5) => t5.collisionGroupID === e2 };
            }
            return this.collisionGroups[t4];
          }
        }
        function At(e2, i3, s2, a2, o2) {
          const { horizontalAlign: r2, verticalAlign: n2 } = t.au(e2);
          return new t.P(-(r2 - 0.5) * i3 + a2[0] * o2, -(n2 - 0.5) * s2 + a2[1] * o2);
        }
        function Rt(e2, i3, s2, a2, o2, r2) {
          const { x1: n2, x2: l2, y1: h2, y2: c2, anchorPointX: u2, anchorPointY: d2 } = e2, _2 = new t.P(i3, s2);
          return a2 && _2._rotate(o2 ? r2 : -r2), { x1: n2 + _2.x, y1: h2 + _2.y, x2: l2 + _2.x, y2: c2 + _2.y, anchorPointX: u2, anchorPointY: d2 };
        }
        class kt {
          constructor(t4, e2, i3, s2, a2) {
            this.transform = t4.clone(), this.terrain = e2, this.collisionIndex = new Et(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i3, this.retainedQueryData = {}, this.collisionGroups = new Lt(s2), this.collisionCircleArrays = {}, this.prevPlacement = a2, a2 && (a2.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(e2, i3, s2, a2) {
            const o2 = s2.getBucket(i3), r2 = s2.latestFeatureIndex;
            if (!o2 || !r2 || i3.id !== o2.layerIds[0])
              return;
            const n2 = s2.collisionBoxArray, l2 = o2.layers[0].layout, h2 = Math.pow(2, this.transform.zoom - s2.tileID.overscaledZ), c2 = s2.tileSize / t.N, u2 = this.transform.calculatePosMatrix(s2.tileID.toUnwrapped()), d2 = "map" === l2.get("text-pitch-alignment"), _2 = "map" === l2.get("text-rotation-alignment"), p2 = St(s2, 1, this.transform.zoom), m2 = nt(u2, d2, _2, this.transform, p2);
            let f2 = null;
            if (d2) {
              const e3 = lt(u2, d2, _2, this.transform, p2);
              f2 = t.a1([], this.transform.labelPlaneMatrix, e3);
            }
            this.retainedQueryData[o2.bucketInstanceId] = new zt(o2.bucketInstanceId, r2, o2.sourceLayerIndex, o2.index, s2.tileID);
            const g2 = { bucket: o2, layout: l2, posMatrix: u2, textLabelPlaneMatrix: m2, labelToScreenMatrix: f2, scale: h2, textPixelRatio: c2, holdingForFade: s2.holdingForFade(), collisionBoxArray: n2, partiallyEvaluatedTextSize: t.ah(o2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o2.sourceID) };
            if (a2)
              for (const t4 of o2.sortKeyRanges) {
                const { sortKey: i4, symbolInstanceStart: s3, symbolInstanceEnd: a3 } = t4;
                e2.push({ sortKey: i4, symbolInstanceStart: s3, symbolInstanceEnd: a3, parameters: g2 });
              }
            else
              e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: o2.symbolInstances.length, parameters: g2 });
          }
          attemptAnchorPlacement(e2, i3, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2, m2, f2) {
            const g2 = t.aq[e2.textAnchor], v2 = [e2.textOffset0, e2.textOffset1], x3 = At(g2, s2, a2, v2, o2), y2 = this.collisionIndex.placeCollisionBox(Rt(i3, x3.x, x3.y, r2, n2, this.transform.angle), u2, l2, h2, c2.predicate, f2);
            if ((!m2 || 0 !== this.collisionIndex.placeCollisionBox(Rt(m2, x3.x, x3.y, r2, n2, this.transform.angle), u2, l2, h2, c2.predicate, f2).box.length) && y2.box.length > 0) {
              let t4;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[d2.crossTileID] && this.prevPlacement.placements[d2.crossTileID] && this.prevPlacement.placements[d2.crossTileID].text && (t4 = this.prevPlacement.variableOffsets[d2.crossTileID].anchor), 0 === d2.crossTileID)
                throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[d2.crossTileID] = { textOffset: v2, width: s2, height: a2, anchor: g2, textBoxScale: o2, prevAnchor: t4 }, this.markUsedJustification(_2, g2, d2, p2), _2.allowVerticalPlacement && (this.markUsedOrientation(_2, p2, d2), this.placedOrientations[d2.crossTileID] = p2), { shift: x3, placedGlyphBoxes: y2 };
            }
          }
          placeLayerBucketPart(e2, i3, s2) {
            const { bucket: a2, layout: o2, posMatrix: r2, textLabelPlaneMatrix: n2, labelToScreenMatrix: l2, textPixelRatio: h2, holdingForFade: c2, collisionBoxArray: u2, partiallyEvaluatedTextSize: d2, collisionGroup: _2 } = e2.parameters, p2 = o2.get("text-optional"), m2 = o2.get("icon-optional"), f2 = t.ar(o2, "text-overlap", "text-allow-overlap"), g2 = "always" === f2, v2 = t.ar(o2, "icon-overlap", "icon-allow-overlap"), x3 = "always" === v2, y2 = "map" === o2.get("text-rotation-alignment"), b2 = "map" === o2.get("text-pitch-alignment"), w2 = "none" !== o2.get("icon-text-fit"), T3 = "viewport-y" === o2.get("symbol-z-order"), I2 = g2 && (x3 || !a2.hasIconData() || m2), E3 = x3 && (g2 || !a2.hasTextData() || p2);
            !a2.collisionArrays && u2 && a2.deserializeCollisionBoxes(u2);
            const S2 = this.retainedQueryData[a2.bucketInstanceId].tileID, C3 = this.terrain ? (t4, e3) => this.terrain.getElevation(S2, t4, e3) : null, P2 = (e3, u3) => {
              var x4, T4;
              if (i3[e3.crossTileID])
                return;
              if (c2)
                return void (this.placements[e3.crossTileID] = new Dt(false, false, false));
              let S3 = false, P3 = false, D3 = true, M2 = null, z2 = { box: null, offscreen: null }, L3 = { box: null, offscreen: null }, A3 = null, R2 = null, k2 = null, F2 = 0, B3 = 0, O2 = 0;
              u3.textFeatureIndex ? F2 = u3.textFeatureIndex : e3.useRuntimeCollisionCircles && (F2 = e3.featureIndex), u3.verticalTextFeatureIndex && (B3 = u3.verticalTextFeatureIndex);
              const N2 = u3.textBox;
              if (N2) {
                const i4 = (i5) => {
                  let s4 = t.ai.horizontal;
                  if (a2.allowVerticalPlacement && !i5 && this.prevPlacement) {
                    const t4 = this.prevPlacement.placedOrientations[e3.crossTileID];
                    t4 && (this.placedOrientations[e3.crossTileID] = t4, s4 = t4, this.markUsedOrientation(a2, s4, e3));
                  }
                  return s4;
                }, s3 = (i5, s4) => {
                  if (a2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && u3.verticalTextBox) {
                    for (const e4 of a2.writingModes)
                      if (e4 === t.ai.vertical ? (z2 = s4(), L3 = z2) : z2 = i5(), z2 && z2.box && z2.box.length)
                        break;
                  } else
                    z2 = i5();
                }, o3 = e3.textAnchorOffsetStartIndex, n3 = e3.textAnchorOffsetEndIndex;
                if (n3 === o3) {
                  const o4 = (t4, i5) => {
                    const s4 = this.collisionIndex.placeCollisionBox(t4, f2, h2, r2, _2.predicate, C3);
                    return s4 && s4.box && s4.box.length && (this.markUsedOrientation(a2, i5, e3), this.placedOrientations[e3.crossTileID] = i5), s4;
                  };
                  s3(() => o4(N2, t.ai.horizontal), () => {
                    const i5 = u3.verticalTextBox;
                    return a2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i5 ? o4(i5, t.ai.vertical) : { box: null, offscreen: null };
                  }), i4(z2 && z2.box && z2.box.length);
                } else {
                  let l3 = t.aq[null === (T4 = null === (x4 = this.prevPlacement) || void 0 === x4 ? void 0 : x4.variableOffsets[e3.crossTileID]) || void 0 === T4 ? void 0 : T4.anchor];
                  const c3 = (t4, i5, s4) => {
                    const c4 = t4.x2 - t4.x1, u4 = t4.y2 - t4.y1, d4 = e3.textBoxScale, p3 = w2 && "never" === v2 ? i5 : null;
                    let m3 = { box: [], offscreen: false }, g3 = "never" === f2 ? 1 : 2, x5 = "never";
                    l3 && g3++;
                    for (let i6 = 0; i6 < g3; i6++) {
                      for (let i7 = o3; i7 < n3; i7++) {
                        const o4 = a2.textAnchorOffsets.get(i7);
                        if (l3 && o4.textAnchor !== l3)
                          continue;
                        const n4 = this.attemptAnchorPlacement(o4, t4, c4, u4, d4, y2, b2, h2, r2, _2, x5, e3, a2, s4, p3, C3);
                        if (n4 && (m3 = n4.placedGlyphBoxes, m3 && m3.box && m3.box.length))
                          return S3 = true, M2 = n4.shift, m3;
                      }
                      l3 ? l3 = null : x5 = f2;
                    }
                    return m3;
                  };
                  s3(() => c3(N2, u3.iconBox, t.ai.horizontal), () => {
                    const i5 = u3.verticalTextBox;
                    return a2.allowVerticalPlacement && !(z2 && z2.box && z2.box.length) && e3.numVerticalGlyphVertices > 0 && i5 ? c3(i5, u3.verticalIconBox, t.ai.vertical) : { box: null, offscreen: null };
                  }), z2 && (S3 = z2.box, D3 = z2.offscreen);
                  const d3 = i4(z2 && z2.box);
                  if (!S3 && this.prevPlacement) {
                    const t4 = this.prevPlacement.variableOffsets[e3.crossTileID];
                    t4 && (this.variableOffsets[e3.crossTileID] = t4, this.markUsedJustification(a2, t4.anchor, e3, d3));
                  }
                }
              }
              if (A3 = z2, S3 = A3 && A3.box && A3.box.length > 0, D3 = A3 && A3.offscreen, e3.useRuntimeCollisionCircles) {
                const i4 = a2.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex), h3 = t.aj(a2.textSizeData, d2, i4), c3 = o2.get("text-padding");
                R2 = this.collisionIndex.placeCollisionCircles(f2, i4, a2.lineVertexArray, a2.glyphOffsetArray, h3, r2, n2, l2, s2, b2, _2.predicate, e3.collisionCircleDiameter, c3, C3), R2.circles.length && R2.collisionDetected && !s2 && t.w("Collisions detected, but collision boxes are not shown"), S3 = g2 || R2.circles.length > 0 && !R2.collisionDetected, D3 = D3 && R2.offscreen;
              }
              if (u3.iconFeatureIndex && (O2 = u3.iconFeatureIndex), u3.iconBox) {
                const t4 = (t5) => {
                  const e4 = w2 && M2 ? Rt(t5, M2.x, M2.y, y2, b2, this.transform.angle) : t5;
                  return this.collisionIndex.placeCollisionBox(e4, v2, h2, r2, _2.predicate, C3);
                };
                L3 && L3.box && L3.box.length && u3.verticalIconBox ? (k2 = t4(u3.verticalIconBox), P3 = k2.box.length > 0) : (k2 = t4(u3.iconBox), P3 = k2.box.length > 0), D3 = D3 && k2.offscreen;
              }
              const U2 = p2 || 0 === e3.numHorizontalGlyphVertices && 0 === e3.numVerticalGlyphVertices, Z2 = m2 || 0 === e3.numIconVertices;
              if (U2 || Z2 ? Z2 ? U2 || (P3 = P3 && S3) : S3 = P3 && S3 : P3 = S3 = P3 && S3, S3 && A3 && A3.box && this.collisionIndex.insertCollisionBox(A3.box, f2, o2.get("text-ignore-placement"), a2.bucketInstanceId, L3 && L3.box && B3 ? B3 : F2, _2.ID), P3 && k2 && this.collisionIndex.insertCollisionBox(k2.box, v2, o2.get("icon-ignore-placement"), a2.bucketInstanceId, O2, _2.ID), R2 && (S3 && this.collisionIndex.insertCollisionCircles(R2.circles, f2, o2.get("text-ignore-placement"), a2.bucketInstanceId, F2, _2.ID), s2)) {
                const t4 = a2.bucketInstanceId;
                let e4 = this.collisionCircleArrays[t4];
                void 0 === e4 && (e4 = this.collisionCircleArrays[t4] = new Mt());
                for (let t5 = 0; t5 < R2.circles.length; t5 += 4)
                  e4.circles.push(R2.circles[t5 + 0]), e4.circles.push(R2.circles[t5 + 1]), e4.circles.push(R2.circles[t5 + 2]), e4.circles.push(R2.collisionDetected ? 1 : 0);
              }
              if (0 === e3.crossTileID)
                throw new Error("symbolInstance.crossTileID can't be 0");
              if (0 === a2.bucketInstanceId)
                throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[e3.crossTileID] = new Dt(S3 || I2, P3 || E3, D3 || a2.justReloaded), i3[e3.crossTileID] = true;
            };
            if (T3) {
              if (0 !== e2.symbolInstanceStart)
                throw new Error("bucket.bucketInstanceId should be 0");
              const t4 = a2.getSortedSymbolIndexes(this.transform.angle);
              for (let e3 = t4.length - 1; e3 >= 0; --e3) {
                const i4 = t4[e3];
                P2(a2.symbolInstances.get(i4), a2.collisionArrays[i4]);
              }
            } else
              for (let t4 = e2.symbolInstanceStart; t4 < e2.symbolInstanceEnd; t4++)
                P2(a2.symbolInstances.get(t4), a2.collisionArrays[t4]);
            if (s2 && a2.bucketInstanceId in this.collisionCircleArrays) {
              const e3 = this.collisionCircleArrays[a2.bucketInstanceId];
              t.as(e3.invProjMatrix, r2), e3.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            a2.justReloaded = false;
          }
          markUsedJustification(e2, i3, s2, a2) {
            let o2;
            o2 = a2 === t.ai.vertical ? s2.verticalPlacedTextSymbolIndex : { left: s2.leftJustifiedTextSymbolIndex, center: s2.centerJustifiedTextSymbolIndex, right: s2.rightJustifiedTextSymbolIndex }[t.at(i3)];
            const r2 = [s2.leftJustifiedTextSymbolIndex, s2.centerJustifiedTextSymbolIndex, s2.rightJustifiedTextSymbolIndex, s2.verticalPlacedTextSymbolIndex];
            for (const t4 of r2)
              t4 >= 0 && (e2.text.placedSymbolArray.get(t4).crossTileID = o2 >= 0 && t4 !== o2 ? 0 : s2.crossTileID);
          }
          markUsedOrientation(e2, i3, s2) {
            const a2 = i3 === t.ai.horizontal || i3 === t.ai.horizontalOnly ? i3 : 0, o2 = i3 === t.ai.vertical ? i3 : 0, r2 = [s2.leftJustifiedTextSymbolIndex, s2.centerJustifiedTextSymbolIndex, s2.rightJustifiedTextSymbolIndex];
            for (const t4 of r2)
              e2.text.placedSymbolArray.get(t4).placedOrientation = a2;
            s2.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(s2.verticalPlacedTextSymbolIndex).placedOrientation = o2);
          }
          commit(t4) {
            this.commitTime = t4, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const e2 = this.prevPlacement;
            let i3 = false;
            this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
            const s2 = e2 ? e2.symbolFadeChange(t4) : 1, a2 = e2 ? e2.opacities : {}, o2 = e2 ? e2.variableOffsets : {}, r2 = e2 ? e2.placedOrientations : {};
            for (const t5 in this.placements) {
              const e3 = this.placements[t5], o3 = a2[t5];
              o3 ? (this.opacities[t5] = new Pt(o3, s2, e3.text, e3.icon), i3 = i3 || e3.text !== o3.text.placed || e3.icon !== o3.icon.placed) : (this.opacities[t5] = new Pt(null, s2, e3.text, e3.icon, e3.skipFade), i3 = i3 || e3.text || e3.icon);
            }
            for (const t5 in a2) {
              const e3 = a2[t5];
              if (!this.opacities[t5]) {
                const a3 = new Pt(e3, s2, false, false);
                a3.isHidden() || (this.opacities[t5] = a3, i3 = i3 || e3.text.placed || e3.icon.placed);
              }
            }
            for (const t5 in o2)
              this.variableOffsets[t5] || !this.opacities[t5] || this.opacities[t5].isHidden() || (this.variableOffsets[t5] = o2[t5]);
            for (const t5 in r2)
              this.placedOrientations[t5] || !this.opacities[t5] || this.opacities[t5].isHidden() || (this.placedOrientations[t5] = r2[t5]);
            if (e2 && void 0 === e2.lastPlacementChangeTime)
              throw new Error("Last placement time for previous placement is not defined");
            i3 ? this.lastPlacementChangeTime = t4 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t4);
          }
          updateLayerOpacities(t4, e2) {
            const i3 = {};
            for (const s2 of e2) {
              const e3 = s2.getBucket(t4);
              e3 && s2.latestFeatureIndex && t4.id === e3.layerIds[0] && this.updateBucketOpacities(e3, i3, s2.collisionBoxArray);
            }
          }
          updateBucketOpacities(e2, i3, s2) {
            e2.hasTextData() && (e2.text.opacityVertexArray.clear(), e2.text.hasVisibleVertices = false), e2.hasIconData() && (e2.icon.opacityVertexArray.clear(), e2.icon.hasVisibleVertices = false), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
            const a2 = e2.layers[0], o2 = a2.layout, r2 = new Pt(null, 0, false, false, true), n2 = o2.get("text-allow-overlap"), l2 = o2.get("icon-allow-overlap"), h2 = a2._unevaluatedLayout.hasValue("text-variable-anchor") || a2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), c2 = "map" === o2.get("text-rotation-alignment"), u2 = "map" === o2.get("text-pitch-alignment"), d2 = "none" !== o2.get("icon-text-fit"), _2 = new Pt(null, 0, n2 && (l2 || !e2.hasIconData() || o2.get("icon-optional")), l2 && (n2 || !e2.hasTextData() || o2.get("text-optional")), true);
            !e2.collisionArrays && s2 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(s2);
            const p2 = (t4, e3, i4) => {
              for (let s3 = 0; s3 < e3 / 4; s3++)
                t4.opacityVertexArray.emplaceBack(i4);
              t4.hasVisibleVertices = t4.hasVisibleVertices || i4 !== qt;
            };
            for (let s3 = 0; s3 < e2.symbolInstances.length; s3++) {
              const a3 = e2.symbolInstances.get(s3), { numHorizontalGlyphVertices: o3, numVerticalGlyphVertices: n3, crossTileID: l3 } = a3;
              let m2 = this.opacities[l3];
              i3[l3] ? m2 = r2 : m2 || (m2 = _2, this.opacities[l3] = m2), i3[l3] = true;
              const f2 = a3.numIconVertices > 0, g2 = this.placedOrientations[a3.crossTileID], v2 = g2 === t.ai.vertical, x3 = g2 === t.ai.horizontal || g2 === t.ai.horizontalOnly;
              if (o3 > 0 || n3 > 0) {
                const t4 = Vt(m2.text);
                p2(e2.text, o3, v2 ? qt : t4), p2(e2.text, n3, x3 ? qt : t4);
                const i4 = m2.text.isHidden();
                [a3.rightJustifiedTextSymbolIndex, a3.centerJustifiedTextSymbolIndex, a3.leftJustifiedTextSymbolIndex].forEach((t5) => {
                  t5 >= 0 && (e2.text.placedSymbolArray.get(t5).hidden = i4 || v2 ? 1 : 0);
                }), a3.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(a3.verticalPlacedTextSymbolIndex).hidden = i4 || x3 ? 1 : 0);
                const s4 = this.variableOffsets[a3.crossTileID];
                s4 && this.markUsedJustification(e2, s4.anchor, a3, g2);
                const r3 = this.placedOrientations[a3.crossTileID];
                r3 && (this.markUsedJustification(e2, "left", a3, r3), this.markUsedOrientation(e2, r3, a3));
              }
              if (f2) {
                const t4 = Vt(m2.icon), i4 = !(d2 && a3.verticalPlacedIconSymbolIndex && v2);
                a3.placedIconSymbolIndex >= 0 && (p2(e2.icon, a3.numIconVertices, i4 ? t4 : qt), e2.icon.placedSymbolArray.get(a3.placedIconSymbolIndex).hidden = m2.icon.isHidden()), a3.verticalPlacedIconSymbolIndex >= 0 && (p2(e2.icon, a3.numVerticalIconVertices, i4 ? qt : t4), e2.icon.placedSymbolArray.get(a3.verticalPlacedIconSymbolIndex).hidden = m2.icon.isHidden());
              }
              if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
                const i4 = e2.collisionArrays[s3];
                if (i4) {
                  let s4 = new t.P(0, 0);
                  if (i4.textBox || i4.verticalTextBox) {
                    let t4 = true;
                    if (h2) {
                      const e3 = this.variableOffsets[l3];
                      e3 ? (s4 = At(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textBoxScale), c2 && s4._rotate(u2 ? this.transform.angle : -this.transform.angle)) : t4 = false;
                    }
                    i4.textBox && Ft(e2.textCollisionBox.collisionVertexArray, m2.text.placed, !t4 || v2, s4.x, s4.y), i4.verticalTextBox && Ft(e2.textCollisionBox.collisionVertexArray, m2.text.placed, !t4 || x3, s4.x, s4.y);
                  }
                  const a4 = Boolean(!x3 && i4.verticalIconBox);
                  i4.iconBox && Ft(e2.iconCollisionBox.collisionVertexArray, m2.icon.placed, a4, d2 ? s4.x : 0, d2 ? s4.y : 0), i4.verticalIconBox && Ft(e2.iconCollisionBox.collisionVertexArray, m2.icon.placed, !a4, d2 ? s4.x : 0, d2 ? s4.y : 0);
                }
              }
            }
            if (e2.sortFeatures(this.transform.angle), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.text.opacityVertexArray.length !== e2.text.layoutVertexArray.length / 4)
              throw new Error(`bucket.text.opacityVertexArray.length (= ${e2.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e2.text.layoutVertexArray.length}) / 4`);
            if (e2.icon.opacityVertexArray.length !== e2.icon.layoutVertexArray.length / 4)
              throw new Error(`bucket.icon.opacityVertexArray.length (= ${e2.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e2.icon.layoutVertexArray.length}) / 4`);
            if (e2.bucketInstanceId in this.collisionCircleArrays) {
              const t4 = this.collisionCircleArrays[e2.bucketInstanceId];
              e2.placementInvProjMatrix = t4.invProjMatrix, e2.placementViewportMatrix = t4.viewportMatrix, e2.collisionCircleArray = t4.circles, delete this.collisionCircleArrays[e2.bucketInstanceId];
            }
          }
          symbolFadeChange(t4) {
            return 0 === this.fadeDuration ? 1 : (t4 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(t4) {
            return Math.max(0, (this.transform.zoom - t4) / 1.5);
          }
          hasTransitions(t4) {
            return this.stale || t4 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(t4, e2) {
            const i3 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
            return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i3 > t4;
          }
          setStale() {
            this.stale = true;
          }
        }
        function Ft(t4, e2, i3, s2, a2) {
          t4.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, s2 || 0, a2 || 0), t4.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, s2 || 0, a2 || 0), t4.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, s2 || 0, a2 || 0), t4.emplaceBack(e2 ? 1 : 0, i3 ? 1 : 0, s2 || 0, a2 || 0);
        }
        const Bt = Math.pow(2, 25), Ot = Math.pow(2, 24), Nt = Math.pow(2, 17), Ut = Math.pow(2, 16), Zt = Math.pow(2, 9), Gt = Math.pow(2, 8), jt = Math.pow(2, 1);
        function Vt(t4) {
          if (0 === t4.opacity && !t4.placed)
            return 0;
          if (1 === t4.opacity && t4.placed)
            return 4294967295;
          const e2 = t4.placed ? 1 : 0, i3 = Math.floor(127 * t4.opacity);
          return i3 * Bt + e2 * Ot + i3 * Nt + e2 * Ut + i3 * Zt + e2 * Gt + i3 * jt + e2;
        }
        const qt = 0;
        class $t {
          constructor(t4) {
            this._sortAcrossTiles = "viewport-y" !== t4.layout.get("symbol-z-order") && !t4.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(t4, e2, i3, s2, a2) {
            const o2 = this._bucketParts;
            for (; this._currentTileIndex < t4.length; )
              if (e2.getBucketParts(o2, s2, t4[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a2())
                return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o2.sort((t5, e3) => t5.sortKey - e3.sortKey)); this._currentPartIndex < o2.length; )
              if (e2.placeLayerBucketPart(o2[this._currentPartIndex], this._seenCrossTileIDs, i3), this._currentPartIndex++, a2())
                return true;
            return false;
          }
        }
        class Wt {
          constructor(t4, e2, i3, s2, a2, o2, r2, n2) {
            this.placement = new kt(t4, e2, o2, r2, n2), this._currentPlacementIndex = i3.length - 1, this._forceFullPlacement = s2, this._showCollisionBoxes = a2, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e2, i3, s2) {
            const a2 = t.h.now(), o2 = () => !this._forceFullPlacement && t.h.now() - a2 > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const t4 = i3[e2[this._currentPlacementIndex]], a3 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === t4.type && (!t4.minzoom || t4.minzoom <= a3) && (!t4.maxzoom || t4.maxzoom > a3)) {
                if (this._inProgressLayer || (this._inProgressLayer = new $t(t4)), this._inProgressLayer.continuePlacement(s2[t4.source], this.placement, this._showCollisionBoxes, t4, o2))
                  return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(t4) {
            return this.placement.commit(t4), this.placement;
          }
        }
        const Ht = 512 / t.N / 2;
        class Xt {
          constructor(e2, i3, s2) {
            this.tileID = e2, this.bucketInstanceId = s2, this._symbolsByKey = {};
            const a2 = /* @__PURE__ */ new Map();
            for (let t4 = 0; t4 < i3.length; t4++) {
              const e3 = i3.get(t4), s3 = e3.key, o2 = a2.get(s3);
              o2 ? o2.push(e3) : a2.set(s3, [e3]);
            }
            for (const [e3, i4] of a2) {
              const s3 = { positions: i4.map((t4) => ({ x: Math.floor(t4.anchorX * Ht), y: Math.floor(t4.anchorY * Ht) })), crossTileIDs: i4.map((t4) => t4.crossTileID) };
              if (s3.positions.length > 128) {
                const e4 = new t.av(s3.positions.length, 16, Uint16Array);
                for (const { x: t4, y: i5 } of s3.positions)
                  e4.add(t4, i5);
                e4.finish(), delete s3.positions, s3.index = e4;
              }
              this._symbolsByKey[e3] = s3;
            }
          }
          getScaledCoordinates(e2, i3) {
            const { x: s2, y: a2, z: o2 } = this.tileID.canonical, { x: r2, y: n2, z: l2 } = i3.canonical, h2 = Ht / Math.pow(2, l2 - o2), c2 = (n2 * t.N + e2.anchorY) * h2, u2 = a2 * t.N * Ht;
            return { x: Math.floor((r2 * t.N + e2.anchorX) * h2 - s2 * t.N * Ht), y: Math.floor(c2 - u2) };
          }
          findMatches(t4, e2, i3) {
            const s2 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z);
            for (let a2 = 0; a2 < t4.length; a2++) {
              const o2 = t4.get(a2);
              if (o2.crossTileID)
                continue;
              const r2 = this._symbolsByKey[o2.key];
              if (!r2)
                continue;
              const n2 = this.getScaledCoordinates(o2, e2);
              if (r2.index) {
                const t5 = r2.index.range(n2.x - s2, n2.y - s2, n2.x + s2, n2.y + s2).sort();
                for (const e3 of t5) {
                  const t6 = r2.crossTileIDs[e3];
                  if (!i3[t6]) {
                    i3[t6] = true, o2.crossTileID = t6;
                    break;
                  }
                }
              } else if (r2.positions)
                for (let t5 = 0; t5 < r2.positions.length; t5++) {
                  const e3 = r2.positions[t5], a3 = r2.crossTileIDs[t5];
                  if (Math.abs(e3.x - n2.x) <= s2 && Math.abs(e3.y - n2.y) <= s2 && !i3[a3]) {
                    i3[a3] = true, o2.crossTileID = a3;
                    break;
                  }
                }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map(({ crossTileIDs: t4 }) => t4);
          }
        }
        class Kt {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Qt {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(t4) {
            const e2 = Math.round((t4 - this.lng) / 360);
            if (0 !== e2)
              for (const t5 in this.indexes) {
                const i3 = this.indexes[t5], s2 = {};
                for (const t6 in i3) {
                  const a2 = i3[t6];
                  a2.tileID = a2.tileID.unwrapTo(a2.tileID.wrap + e2), s2[a2.tileID.key] = a2;
                }
                this.indexes[t5] = s2;
              }
            this.lng = t4;
          }
          addBucket(t4, e2, i3) {
            if (this.indexes[t4.overscaledZ] && this.indexes[t4.overscaledZ][t4.key]) {
              if (this.indexes[t4.overscaledZ][t4.key].bucketInstanceId === e2.bucketInstanceId)
                return false;
              this.removeBucketCrossTileIDs(t4.overscaledZ, this.indexes[t4.overscaledZ][t4.key]);
            }
            for (let t5 = 0; t5 < e2.symbolInstances.length; t5++)
              e2.symbolInstances.get(t5).crossTileID = 0;
            this.usedCrossTileIDs[t4.overscaledZ] || (this.usedCrossTileIDs[t4.overscaledZ] = {});
            const s2 = this.usedCrossTileIDs[t4.overscaledZ];
            for (const i4 in this.indexes) {
              const a2 = this.indexes[i4];
              if (Number(i4) > t4.overscaledZ)
                for (const i5 in a2) {
                  const o2 = a2[i5];
                  o2.tileID.isChildOf(t4) && o2.findMatches(e2.symbolInstances, t4, s2);
                }
              else {
                const o2 = a2[t4.scaledTo(Number(i4)).key];
                o2 && o2.findMatches(e2.symbolInstances, t4, s2);
              }
            }
            for (let t5 = 0; t5 < e2.symbolInstances.length; t5++) {
              const a2 = e2.symbolInstances.get(t5);
              a2.crossTileID || (a2.crossTileID = i3.generate(), s2[a2.crossTileID] = true);
            }
            return void 0 === this.indexes[t4.overscaledZ] && (this.indexes[t4.overscaledZ] = {}), this.indexes[t4.overscaledZ][t4.key] = new Xt(t4, e2.symbolInstances, e2.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(t4, e2) {
            for (const i3 of e2.getCrossTileIDsLists())
              for (const e3 of i3)
                delete this.usedCrossTileIDs[t4][e3];
          }
          removeStaleBuckets(t4) {
            let e2 = false;
            for (const i3 in this.indexes) {
              const s2 = this.indexes[i3];
              for (const a2 in s2)
                t4[s2[a2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i3, s2[a2]), delete s2[a2], e2 = true);
            }
            return e2;
          }
        }
        class Yt {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Kt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(t4, e2, i3) {
            let s2 = this.layerIndexes[t4.id];
            void 0 === s2 && (s2 = this.layerIndexes[t4.id] = new Qt());
            let a2 = false;
            const o2 = {};
            s2.handleWrapJump(i3);
            for (const i4 of e2) {
              const e3 = i4.getBucket(t4);
              e3 && t4.id === e3.layerIds[0] && (e3.bucketInstanceId || (e3.bucketInstanceId = ++this.maxBucketInstanceId), s2.addBucket(i4.tileID, e3, this.crossTileIDs) && (a2 = true), o2[e3.bucketInstanceId] = true);
            }
            return s2.removeStaleBuckets(o2) && (a2 = true), a2;
          }
          pruneUnusedLayers(t4) {
            const e2 = {};
            t4.forEach((t5) => {
              e2[t5] = true;
            });
            for (const t5 in this.layerIndexes)
              e2[t5] || delete this.layerIndexes[t5];
          }
        }
        const Jt = (e2, i3) => t.x(e2, i3 && i3.filter((t4) => "source.canvas" !== t4.identifier)), te = t.F(t.ax, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setGlyphs", "setSprite"]), ee = t.F(t.ax, ["setCenter", "setZoom", "setBearing", "setPitch"]), ie = t.aw();
        class se extends t.E {
          constructor(e2, i3 = {}) {
            super(), this.map = e2, this.dispatcher = new M(st(), this, e2._getMapId()), this.imageManager = new b(), this.imageManager.setEventedParent(this), this.glyphManager = new E2(e2._requestManager, i3.localIdeographFontFamily), this.lineAtlas = new D2(256, 512), this.crossTileSymbolIndex = new Yt(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ay(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.az());
            const s2 = this;
            this._rtlTextPluginCallback = se.registerForPluginStateChange((e3) => {
              s2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e3.pluginStatus, pluginURL: e3.pluginURL }, (e4, i4) => {
                if (t.aA(e4), i4 && i4.every((t4) => t4))
                  for (const t4 in s2.sourceCaches) {
                    const e5 = s2.sourceCaches[t4].getSource().type;
                    "vector" !== e5 && "geojson" !== e5 || s2.sourceCaches[t4].reload();
                  }
              });
            }), this.on("data", (t4) => {
              if ("source" !== t4.dataType || "metadata" !== t4.sourceDataType)
                return;
              const e3 = this.sourceCaches[t4.sourceId];
              if (!e3)
                return;
              const i4 = e3.getSource();
              if (i4 && i4.vectorLayerIds)
                for (const t5 in this._layers) {
                  const e4 = this._layers[t5];
                  e4.source === i4.id && this._validateLayer(e4);
                }
            });
          }
          loadURL(e2, i3 = {}, s2) {
            this.fire(new t.k("dataloading", { dataType: "style" })), i3.validate = "boolean" != typeof i3.validate || i3.validate;
            const a2 = this.map._requestManager.transformRequest(e2, c.Style);
            this._request = t.f(a2, (e3, a3) => {
              this._request = null, e3 ? this.fire(new t.j(e3)) : a3 && this._load(a3, i3, s2);
            });
          }
          loadJSON(e2, i3 = {}, s2) {
            this.fire(new t.k("dataloading", { dataType: "style" })), this._request = t.h.frame(() => {
              this._request = null, i3.validate = false !== i3.validate, this._load(e2, i3, s2);
            });
          }
          loadEmpty() {
            this.fire(new t.k("dataloading", { dataType: "style" })), this._load(ie, { validate: false });
          }
          _load(e2, i3, s2) {
            var a2;
            const o2 = i3.transformStyle ? i3.transformStyle(s2, e2) : e2;
            if (!i3.validate || !Jt(this, t.y(o2))) {
              this._loaded = true, this.stylesheet = o2;
              for (const t4 in o2.sources)
                this.addSource(t4, o2.sources[t4], { validate: false });
              o2.sprite ? this._loadSprite(o2.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o2.glyphs), this._createLayers(), this.light = new P(this.stylesheet.light), this.map.setTerrain(null !== (a2 = this.stylesheet.terrain) && void 0 !== a2 ? a2 : null), this.fire(new t.k("data", { dataType: "style" })), this.fire(new t.k("style.load"));
            }
          }
          _createLayers() {
            const e2 = t.aB(this.stylesheet.layers);
            this.dispatcher.broadcast("setLayers", e2), this._order = e2.map((t4) => t4.id), this._layers = {}, this._serializedLayers = null;
            for (const i3 of e2) {
              const e3 = t.aC(i3);
              e3.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = e3;
            }
          }
          _loadSprite(e2, i3 = false, s2 = void 0) {
            this.imageManager.setLoaded(false), this._spriteRequest = function(e3, i4, s3, a2) {
              const o2 = g(e3), r2 = o2.length, n2 = s3 > 1 ? "@2x" : "", l2 = {}, u2 = {}, d2 = {};
              for (const { id: e4, url: s4 } of o2) {
                const o3 = i4.transformRequest(i4.normalizeSpriteURL(s4, n2, ".json"), c.SpriteJSON), _2 = `${e4}_${o3.url}`;
                l2[_2] = t.f(o3, (t4, i5) => {
                  delete l2[_2], u2[e4] = i5, v(a2, u2, d2, t4, r2);
                });
                const p2 = i4.transformRequest(i4.normalizeSpriteURL(s4, n2, ".png"), c.SpriteImage), m2 = `${e4}_${p2.url}`;
                l2[m2] = h.getImage(p2, (t4, i5) => {
                  delete l2[m2], d2[e4] = i5, v(a2, u2, d2, t4, r2);
                });
              }
              return { cancel() {
                for (const t4 of Object.values(l2))
                  t4.cancel();
              } };
            }(e2, this.map._requestManager, this.map.getPixelRatio(), (e3, a2) => {
              if (this._spriteRequest = null, e3)
                this.fire(new t.j(e3));
              else if (a2)
                for (const t4 in a2) {
                  this._spritesImagesIds[t4] = [];
                  const e4 = this._spritesImagesIds[t4] ? this._spritesImagesIds[t4].filter((t5) => !(t5 in a2)) : [];
                  for (const t5 of e4)
                    this.imageManager.removeImage(t5), this._changedImages[t5] = true;
                  for (const e5 in a2[t4]) {
                    const s3 = "default" === t4 ? e5 : `${t4}:${e5}`;
                    this._spritesImagesIds[t4].push(s3), s3 in this.imageManager.images ? this.imageManager.updateImage(s3, a2[t4][e5], false) : this.imageManager.addImage(s3, a2[t4][e5]), i3 && (this._changedImages[s3] = true);
                  }
                }
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i3 && (this._changed = true), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.k("data", { dataType: "style" })), s2 && s2(e3);
            });
          }
          _unloadSprite() {
            for (const t4 of Object.values(this._spritesImagesIds).flat())
              this.imageManager.removeImage(t4), this._changedImages[t4] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.k("data", { dataType: "style" }));
          }
          _validateLayer(e2) {
            const i3 = this.sourceCaches[e2.source];
            if (!i3)
              return;
            const s2 = e2.sourceLayer;
            if (!s2)
              return;
            const a2 = i3.getSource();
            ("geojson" === a2.type || a2.vectorLayerIds && -1 === a2.vectorLayerIds.indexOf(s2)) && this.fire(new t.j(new Error(`Source layer "${s2}" does not exist on source "${a2.id}" as specified by style layer "${e2.id}".`)));
          }
          loaded() {
            if (!this._loaded)
              return false;
            if (Object.keys(this._updatedSources).length)
              return false;
            for (const t4 in this.sourceCaches)
              if (!this.sourceCaches[t4].loaded())
                return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(t4) {
            const e2 = this._serializedAllLayers();
            if (!t4 || 0 === t4.length)
              return Object.values(e2);
            const i3 = [];
            for (const s2 of t4)
              e2[s2] && i3.push(e2[s2]);
            return i3;
          }
          _serializedAllLayers() {
            let t4 = this._serializedLayers;
            if (t4)
              return t4;
            t4 = this._serializedLayers = {};
            const e2 = Object.keys(this._layers);
            for (const i3 of e2) {
              const e3 = this._layers[i3];
              "custom" !== e3.type && (t4[i3] = e3.serialize());
            }
            return t4;
          }
          hasTransitions() {
            if (this.light && this.light.hasTransition())
              return true;
            for (const t4 in this.sourceCaches)
              if (this.sourceCaches[t4].hasTransition())
                return true;
            for (const t4 in this._layers)
              if (this._layers[t4].hasTransition())
                return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded)
              throw new Error("Style is not done loading.");
          }
          update(e2) {
            if (!this._loaded)
              return;
            const i3 = this._changed;
            if (this._changed) {
              const t4 = Object.keys(this._updatedLayers), i4 = Object.keys(this._removedLayers);
              (t4.length || i4.length) && this._updateWorkerLayers(t4, i4);
              for (const t5 in this._updatedSources) {
                const e3 = this._updatedSources[t5];
                if ("reload" === e3)
                  this._reloadSource(t5);
                else {
                  if ("clear" !== e3)
                    throw new Error(`Invalid action ${e3}`);
                  this._clearSource(t5);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const t5 in this._updatedPaintProps)
                this._layers[t5].updateTransitions(e2);
              this.light.updateTransitions(e2), this._resetUpdates();
            }
            const s2 = {};
            for (const t4 in this.sourceCaches) {
              const e3 = this.sourceCaches[t4];
              s2[t4] = e3.used, e3.used = false;
            }
            for (const t4 of this._order) {
              const i4 = this._layers[t4];
              i4.recalculate(e2, this._availableImages), !i4.isHidden(e2.zoom) && i4.source && (this.sourceCaches[i4.source].used = true);
            }
            for (const e3 in s2) {
              const i4 = this.sourceCaches[e3];
              s2[e3] !== i4.used && i4.fire(new t.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: e3 }));
            }
            this.light.recalculate(e2), this.z = e2.zoom, i3 && this.fire(new t.k("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const t4 = Object.keys(this._changedImages);
            if (t4.length) {
              for (const e2 in this.sourceCaches)
                this.sourceCaches[e2].reloadTilesForDependencies(["icons", "patterns"], t4);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const t4 in this.sourceCaches)
                this.sourceCaches[t4].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(t4, e2) {
            this.dispatcher.broadcast("updateLayers", { layers: this._serializeByIds(t4), removedIds: e2 });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(e2, i3 = {}) {
            this._checkLoaded();
            const s2 = this.serialize();
            if (e2 = i3.transformStyle ? i3.transformStyle(s2, e2) : e2, Jt(this, t.y(e2)))
              return false;
            (e2 = t.aD(e2)).layers = t.aB(e2.layers);
            const a2 = t.aE(s2, e2).filter((t4) => !(t4.command in ee));
            if (0 === a2.length)
              return false;
            const o2 = a2.filter((t4) => !(t4.command in te));
            if (o2.length > 0)
              throw new Error(`Unimplemented: ${o2.map((t4) => t4.command).join(", ")}.`);
            for (const t4 of a2)
              "setTransition" !== t4.command && this[t4.command].apply(this, t4.args);
            return this.stylesheet = e2, this._serializedLayers = null, true;
          }
          addImage(e2, i3) {
            if (this.getImage(e2))
              return this.fire(new t.j(new Error(`An image named "${e2}" already exists.`)));
            this.imageManager.addImage(e2, i3), this._afterImageUpdated(e2);
          }
          updateImage(t4, e2) {
            this.imageManager.updateImage(t4, e2);
          }
          getImage(t4) {
            return this.imageManager.getImage(t4);
          }
          removeImage(e2) {
            if (!this.getImage(e2))
              return this.fire(new t.j(new Error(`An image named "${e2}" does not exist.`)));
            this.imageManager.removeImage(e2), this._afterImageUpdated(e2);
          }
          _afterImageUpdated(e2) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e2] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.k("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e2, i3, s2 = {}) {
            if (this._checkLoaded(), void 0 !== this.sourceCaches[e2])
              throw new Error(`Source "${e2}" already exists.`);
            if (!i3.type)
              throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i3).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i3.type) >= 0 && this._validate(t.y.source, `sources.${e2}`, i3, null, s2))
              return;
            this.map && this.map._collectResourceTiming && (i3.collectResourceTiming = true);
            const a2 = this.sourceCaches[e2] = new K2(e2, i3, this.dispatcher);
            a2.style = this, a2.setEventedParent(this, () => ({ isSourceLoaded: a2.loaded(), source: a2.serialize(), sourceId: e2 })), a2.onAdd(this.map), this._changed = true;
          }
          removeSource(e2) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[e2])
              throw new Error("There is no source with this ID");
            for (const i4 in this._layers)
              if (this._layers[i4].source === e2)
                return this.fire(new t.j(new Error(`Source "${e2}" cannot be removed while layer "${i4}" is using it.`)));
            const i3 = this.sourceCaches[e2];
            delete this.sourceCaches[e2], delete this._updatedSources[e2], i3.fire(new t.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: e2 })), i3.setEventedParent(null), i3.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(t4, e2) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[t4])
              throw new Error(`There is no source with this ID=${t4}`);
            const i3 = this.sourceCaches[t4].getSource();
            if ("geojson" !== i3.type)
              throw new Error(`geojsonSource.type is ${i3.type}, which is !== 'geojson`);
            i3.setData(e2), this._changed = true;
          }
          getSource(t4) {
            return this.sourceCaches[t4] && this.sourceCaches[t4].getSource();
          }
          addLayer(e2, i3, s2 = {}) {
            this._checkLoaded();
            const a2 = e2.id;
            if (this.getLayer(a2))
              return void this.fire(new t.j(new Error(`Layer "${a2}" already exists on this map.`)));
            let o2;
            if ("custom" === e2.type) {
              if (Jt(this, t.aF(e2)))
                return;
              o2 = t.aC(e2);
            } else {
              if ("source" in e2 && "object" == typeof e2.source && (this.addSource(a2, e2.source), e2 = t.aD(e2), e2 = t.e(e2, { source: a2 })), this._validate(t.y.layer, `layers.${a2}`, e2, { arrayIndex: -1 }, s2))
                return;
              o2 = t.aC(e2), this._validateLayer(o2), o2.setEventedParent(this, { layer: { id: a2 } });
            }
            const r2 = i3 ? this._order.indexOf(i3) : this._order.length;
            if (i3 && -1 === r2)
              this.fire(new t.j(new Error(`Cannot add layer "${a2}" before non-existing layer "${i3}".`)));
            else {
              if (this._order.splice(r2, 0, a2), this._layerOrderChanged = true, this._layers[a2] = o2, this._removedLayers[a2] && o2.source && "custom" !== o2.type) {
                const t4 = this._removedLayers[a2];
                delete this._removedLayers[a2], t4.type !== o2.type ? this._updatedSources[o2.source] = "clear" : (this._updatedSources[o2.source] = "reload", this.sourceCaches[o2.source].pause());
              }
              this._updateLayer(o2), o2.onAdd && o2.onAdd(this.map);
            }
          }
          moveLayer(e2, i3) {
            if (this._checkLoaded(), this._changed = true, !this._layers[e2])
              return void this.fire(new t.j(new Error(`The layer '${e2}' does not exist in the map's style and cannot be moved.`)));
            if (e2 === i3)
              return;
            const s2 = this._order.indexOf(e2);
            this._order.splice(s2, 1);
            const a2 = i3 ? this._order.indexOf(i3) : this._order.length;
            i3 && -1 === a2 ? this.fire(new t.j(new Error(`Cannot move layer "${e2}" before non-existing layer "${i3}".`))) : (this._order.splice(a2, 0, e2), this._layerOrderChanged = true);
          }
          removeLayer(e2) {
            this._checkLoaded();
            const i3 = this._layers[e2];
            if (!i3)
              return void this.fire(new t.j(new Error(`Cannot remove non-existing layer "${e2}".`)));
            i3.setEventedParent(null);
            const s2 = this._order.indexOf(e2);
            this._order.splice(s2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e2] = i3, delete this._layers[e2], this._serializedLayers && delete this._serializedLayers[e2], delete this._updatedLayers[e2], delete this._updatedPaintProps[e2], i3.onRemove && i3.onRemove(this.map);
          }
          getLayer(t4) {
            return this._layers[t4];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(t4) {
            return t4 in this._layers;
          }
          setLayerZoomRange(e2, i3, s2) {
            this._checkLoaded();
            const a2 = this.getLayer(e2);
            a2 ? a2.minzoom === i3 && a2.maxzoom === s2 || (null != i3 && (a2.minzoom = i3), null != s2 && (a2.maxzoom = s2), this._updateLayer(a2)) : this.fire(new t.j(new Error(`Cannot set the zoom range of non-existing layer "${e2}".`)));
          }
          setFilter(e2, i3, s2 = {}) {
            this._checkLoaded();
            const a2 = this.getLayer(e2);
            if (a2) {
              if (!t.aG(a2.filter, i3))
                return null == i3 ? (a2.filter = void 0, void this._updateLayer(a2)) : void (this._validate(t.y.filter, `layers.${a2.id}.filter`, i3, null, s2) || (a2.filter = t.aD(i3), this._updateLayer(a2)));
            } else
              this.fire(new t.j(new Error(`Cannot filter non-existing layer "${e2}".`)));
          }
          getFilter(e2) {
            return t.aD(this.getLayer(e2).filter);
          }
          setLayoutProperty(e2, i3, s2, a2 = {}) {
            this._checkLoaded();
            const o2 = this.getLayer(e2);
            o2 ? t.aG(o2.getLayoutProperty(i3), s2) || (o2.setLayoutProperty(i3, s2, a2), this._updateLayer(o2)) : this.fire(new t.j(new Error(`Cannot style non-existing layer "${e2}".`)));
          }
          getLayoutProperty(e2, i3) {
            const s2 = this.getLayer(e2);
            if (s2)
              return s2.getLayoutProperty(i3);
            this.fire(new t.j(new Error(`Cannot get style of non-existing layer "${e2}".`)));
          }
          setPaintProperty(e2, i3, s2, a2 = {}) {
            this._checkLoaded();
            const o2 = this.getLayer(e2);
            o2 ? t.aG(o2.getPaintProperty(i3), s2) || (o2.setPaintProperty(i3, s2, a2) && this._updateLayer(o2), this._changed = true, this._updatedPaintProps[e2] = true) : this.fire(new t.j(new Error(`Cannot style non-existing layer "${e2}".`)));
          }
          getPaintProperty(t4, e2) {
            return this.getLayer(t4).getPaintProperty(e2);
          }
          setFeatureState(e2, i3) {
            this._checkLoaded();
            const s2 = e2.source, a2 = e2.sourceLayer, o2 = this.sourceCaches[s2];
            if (void 0 === o2)
              return void this.fire(new t.j(new Error(`The source '${s2}' does not exist in the map's style.`)));
            const r2 = o2.getSource().type;
            "geojson" === r2 && a2 ? this.fire(new t.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== r2 || a2 ? (void 0 === e2.id && this.fire(new t.j(new Error("The feature id parameter must be provided."))), o2.setFeatureState(a2, e2.id, i3)) : this.fire(new t.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e2, i3) {
            this._checkLoaded();
            const s2 = e2.source, a2 = this.sourceCaches[s2];
            if (void 0 === a2)
              return void this.fire(new t.j(new Error(`The source '${s2}' does not exist in the map's style.`)));
            const o2 = a2.getSource().type, r2 = "vector" === o2 ? e2.sourceLayer : void 0;
            "vector" !== o2 || r2 ? i3 && "string" != typeof e2.id && "number" != typeof e2.id ? this.fire(new t.j(new Error("A feature id is required to remove its specific state property."))) : a2.removeFeatureState(r2, e2.id, i3) : this.fire(new t.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e2) {
            this._checkLoaded();
            const i3 = e2.source, s2 = e2.sourceLayer, a2 = this.sourceCaches[i3];
            if (void 0 !== a2)
              return "vector" !== a2.getSource().type || s2 ? (void 0 === e2.id && this.fire(new t.j(new Error("The feature id parameter must be provided."))), a2.getFeatureState(s2, e2.id)) : void this.fire(new t.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new t.j(new Error(`The source '${i3}' does not exist in the map's style.`)));
          }
          getTransition() {
            return t.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded)
              return;
            const e2 = t.aH(this.sourceCaches, (t4) => t4.serialize()), i3 = this._serializeByIds(this._order), s2 = this.map.getTerrain() || void 0, a2 = this.stylesheet;
            return t.aI({ version: a2.version, name: a2.name, metadata: a2.metadata, light: a2.light, center: a2.center, zoom: a2.zoom, bearing: a2.bearing, pitch: a2.pitch, sprite: a2.sprite, glyphs: a2.glyphs, transition: a2.transition, sources: e2, layers: i3, terrain: s2 }, (t4) => void 0 !== t4);
          }
          _updateLayer(t4) {
            this._updatedLayers[t4.id] = true, t4.source && !this._updatedSources[t4.source] && "raster" !== this.sourceCaches[t4.source].getSource().type && (this._updatedSources[t4.source] = "reload", this.sourceCaches[t4.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(t4) {
            const e2 = (t5) => "fill-extrusion" === this._layers[t5].type, i3 = {}, s2 = [];
            for (let a3 = this._order.length - 1; a3 >= 0; a3--) {
              const o2 = this._order[a3];
              if (e2(o2)) {
                i3[o2] = a3;
                for (const e3 of t4) {
                  const t5 = e3[o2];
                  if (t5)
                    for (const e4 of t5)
                      s2.push(e4);
                }
              }
            }
            s2.sort((t5, e3) => e3.intersectionZ - t5.intersectionZ);
            const a2 = [];
            for (let o2 = this._order.length - 1; o2 >= 0; o2--) {
              const r2 = this._order[o2];
              if (e2(r2))
                for (let t5 = s2.length - 1; t5 >= 0; t5--) {
                  const e3 = s2[t5].feature;
                  if (i3[e3.layer.id] < o2)
                    break;
                  a2.push(e3), s2.pop();
                }
              else
                for (const e3 of t4) {
                  const t5 = e3[r2];
                  if (t5)
                    for (const e4 of t5)
                      a2.push(e4.feature);
                }
            }
            return a2;
          }
          queryRenderedFeatures(e2, i3, s2) {
            i3 && i3.filter && this._validate(t.y.filter, "queryRenderedFeatures.filter", i3.filter, null, i3);
            const a2 = {};
            if (i3 && i3.layers) {
              if (!Array.isArray(i3.layers))
                return this.fire(new t.j(new Error("parameters.layers must be an Array."))), [];
              for (const e3 of i3.layers) {
                const i4 = this._layers[e3];
                if (!i4)
                  return this.fire(new t.j(new Error(`The layer '${e3}' does not exist in the map's style and cannot be queried for features.`))), [];
                a2[i4.source] = true;
              }
            }
            const o2 = [];
            i3.availableImages = this._availableImages;
            const r2 = this._serializedAllLayers();
            for (const t4 in this.sourceCaches)
              i3.layers && !a2[t4] || o2.push(q(this.sourceCaches[t4], this._layers, r2, e2, i3, s2));
            return this.placement && o2.push(function(t4, e3, i4, s3, a3, o3, r3) {
              const n2 = {}, l2 = o3.queryRenderedSymbols(s3), h2 = [];
              for (const t5 of Object.keys(l2).map(Number))
                h2.push(r3[t5]);
              h2.sort($);
              for (const i5 of h2) {
                const s4 = i5.featureIndex.lookupSymbolFeatures(l2[i5.bucketInstanceId], e3, i5.bucketIndex, i5.sourceLayerIndex, a3.filter, a3.layers, a3.availableImages, t4);
                for (const t5 in s4) {
                  const e4 = n2[t5] = n2[t5] || [], a4 = s4[t5];
                  a4.sort((t6, e5) => {
                    const s5 = i5.featureSortOrder;
                    if (s5) {
                      const i6 = s5.indexOf(t6.featureIndex);
                      return s5.indexOf(e5.featureIndex) - i6;
                    }
                    return e5.featureIndex - t6.featureIndex;
                  });
                  for (const t6 of a4)
                    e4.push(t6);
                }
              }
              for (const e4 in n2)
                n2[e4].forEach((s4) => {
                  const a4 = s4.feature, o4 = i4[t4[e4].source].getFeatureState(a4.layer["source-layer"], a4.id);
                  a4.source = a4.layer.source, a4.layer["source-layer"] && (a4.sourceLayer = a4.layer["source-layer"]), a4.state = o4;
                });
              return n2;
            }(this._layers, r2, this.sourceCaches, e2, i3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o2);
          }
          querySourceFeatures(e2, i3) {
            i3 && i3.filter && this._validate(t.y.filter, "querySourceFeatures.filter", i3.filter, null, i3);
            const s2 = this.sourceCaches[e2];
            return s2 ? function(t4, e3) {
              const i4 = t4.getRenderableIds().map((e4) => t4.getTileByID(e4)), s3 = [], a2 = {};
              for (let t5 = 0; t5 < i4.length; t5++) {
                const o2 = i4[t5], r2 = o2.tileID.canonical.key;
                a2[r2] || (a2[r2] = true, o2.querySourceFeatures(s3, e3));
              }
              return s3;
            }(s2, i3) : [];
          }
          addSourceType(t4, e2, i3) {
            return j(t4) ? i3(new Error(`A source type called "${t4}" already exists.`)) : (((t5, e3) => {
              G[t5] = e3;
            })(t4, e2), e2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t4, url: e2.workerSourceURL }, i3) : i3(null, null));
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e2, i3 = {}) {
            this._checkLoaded();
            const s2 = this.light.getLight();
            let a2 = false;
            for (const i4 in e2)
              if (!t.aG(e2[i4], s2[i4])) {
                a2 = true;
                break;
              }
            if (!a2)
              return;
            const o2 = { now: t.h.now(), transition: t.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e2, i3), this.light.updateTransitions(o2);
          }
          _validate(e2, i3, s2, a2, o2 = {}) {
            return (!o2 || false !== o2.validate) && Jt(this, e2.call(t.y, t.e({ key: i3, style: this.serialize(), value: s2, styleSpec: t.v }, a2)));
          }
          _remove(e2 = true) {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.aJ.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const t4 in this._layers)
              this._layers[t4].setEventedParent(null);
            for (const t4 in this.sourceCaches) {
              const e3 = this.sourceCaches[t4];
              e3.setEventedParent(null), e3.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove(e2);
          }
          _clearSource(t4) {
            this.sourceCaches[t4].clearTiles();
          }
          _reloadSource(t4) {
            this.sourceCaches[t4].resume(), this.sourceCaches[t4].reload();
          }
          _updateSources(t4) {
            for (const e2 in this.sourceCaches)
              this.sourceCaches[e2].update(t4, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const t4 in this.sourceCaches)
              this._reloadSource(t4);
          }
          _updatePlacement(e2, i3, s2, a2, o2 = false) {
            let r2 = false, n2 = false;
            const l2 = {};
            for (const t4 of this._order) {
              const i4 = this._layers[t4];
              if ("symbol" !== i4.type)
                continue;
              if (!l2[i4.source]) {
                const t5 = this.sourceCaches[i4.source];
                l2[i4.source] = t5.getRenderableIds(true).map((e3) => t5.getTileByID(e3)).sort((t6, e3) => e3.tileID.overscaledZ - t6.tileID.overscaledZ || (t6.tileID.isLessThan(e3.tileID) ? -1 : 1));
              }
              const s3 = this.crossTileSymbolIndex.addLayer(i4, l2[i4.source], e2.center.lng);
              r2 = r2 || s3;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((o2 = o2 || this._layerOrderChanged || 0 === s2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.h.now(), e2.zoom)) && (this.pauseablePlacement = new Wt(e2, this.map.terrain, this._order, o2, i3, s2, a2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.h.now()), n2 = true), r2 && this.pauseablePlacement.placement.setStale()), n2 || r2)
              for (const t4 of this._order) {
                const e3 = this._layers[t4];
                "symbol" === e3.type && this.placement.updateLayerOpacities(e3, l2[e3.source]);
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.h.now());
          }
          _releaseSymbolFadeTiles() {
            for (const t4 in this.sourceCaches)
              this.sourceCaches[t4].releaseSymbolFadeTiles();
          }
          getImages(t4, e2, i3) {
            this.imageManager.getImages(e2.icons, i3), this._updateTilesForChangedImages();
            const s2 = this.sourceCaches[e2.source];
            s2 && s2.setDependencies(e2.tileID.key, e2.type, e2.icons);
          }
          getGlyphs(t4, e2, i3) {
            this.glyphManager.getGlyphs(e2.stacks, i3);
            const s2 = this.sourceCaches[e2.source];
            s2 && s2.setDependencies(e2.tileID.key, e2.type, [""]);
          }
          getResource(e2, i3, s2) {
            return t.m(i3, s2);
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e2, i3 = {}) {
            this._checkLoaded(), e2 && this._validate(t.y.glyphs, "glyphs", e2, null, i3) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e2, this.glyphManager.entries = {}, this.glyphManager.setURL(e2));
          }
          addSprite(e2, i3, s2 = {}, a2) {
            this._checkLoaded();
            const o2 = [{ id: e2, url: i3 }], r2 = [...g(this.stylesheet.sprite), ...o2];
            this._validate(t.y.sprite, "sprite", r2, null, s2) || (this.stylesheet.sprite = r2, this._loadSprite(o2, true, a2));
          }
          removeSprite(e2) {
            this._checkLoaded();
            const i3 = g(this.stylesheet.sprite);
            if (i3.find((t4) => t4.id === e2)) {
              if (this._spritesImagesIds[e2])
                for (const t4 of this._spritesImagesIds[e2])
                  this.imageManager.removeImage(t4), this._changedImages[t4] = true;
              i3.splice(i3.findIndex((t4) => t4.id === e2), 1), this.stylesheet.sprite = i3.length > 0 ? i3 : void 0, delete this._spritesImagesIds[e2], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.k("data", { dataType: "style" }));
            } else
              this.fire(new t.j(new Error(`Sprite "${e2}" doesn't exists on this map.`)));
          }
          getSprite() {
            return g(this.stylesheet.sprite);
          }
          setSprite(e2, i3 = {}, s2) {
            this._checkLoaded(), e2 && this._validate(t.y.sprite, "sprite", e2, null, i3) || (this.stylesheet.sprite = e2, e2 ? this._loadSprite(e2, true, s2) : (this._unloadSprite(), s2 && s2(null)));
          }
        }
        se.registerForPluginStateChange = t.aK;
        var ae = t.Q([{ name: "a_pos", type: "Int16", components: 2 }]), oe = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
        const re = { prelude: ne("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}"), background: ne("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: ne("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: ne("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: ne("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: ne("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), heatmapTexture: ne("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: ne("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: ne("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: ne("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: ne("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), fillOutline: ne("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillOutlinePattern: ne("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillPattern: ne("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: ne("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: ne("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: ne("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: ne("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: ne("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: ne("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: ne("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: ne("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: ne("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: ne("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: ne("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: ne("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: ne("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", oe), terrainDepth: ne("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", oe), terrainCoords: ne("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", oe) };
        function ne(t4, e2) {
          const i3 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, s2 = e2.match(/attribute ([\w]+) ([\w]+)/g), a2 = t4.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r2 = o2 ? o2.concat(a2) : a2, n2 = {};
          return { fragmentSource: t4 = t4.replace(i3, (t5, e3, i4, s3, a3) => (n2[a3] = true, "define" === e3 ? `
#ifndef HAS_UNIFORM_u_${a3}
varying ${i4} ${s3} ${a3};
#else
uniform ${i4} ${s3} u_${a3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${a3}
    ${i4} ${s3} ${a3} = u_${a3};
#endif
`)), vertexSource: e2 = e2.replace(i3, (t5, e3, i4, s3, a3) => {
            const o3 = "float" === s3 ? "vec2" : "vec4", r3 = a3.match(/color/) ? "color" : o3;
            return n2[a3] ? "define" === e3 ? `
#ifndef HAS_UNIFORM_u_${a3}
uniform lowp float u_${a3}_t;
attribute ${i4} ${o3} a_${a3};
varying ${i4} ${s3} ${a3};
#else
uniform ${i4} ${s3} u_${a3};
#endif
` : "vec4" === r3 ? `
#ifndef HAS_UNIFORM_u_${a3}
    ${a3} = a_${a3};
#else
    ${i4} ${s3} ${a3} = u_${a3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a3}
    ${a3} = unpack_mix_${r3}(a_${a3}, u_${a3}_t);
#else
    ${i4} ${s3} ${a3} = u_${a3};
#endif
` : "define" === e3 ? `
#ifndef HAS_UNIFORM_u_${a3}
uniform lowp float u_${a3}_t;
attribute ${i4} ${o3} a_${a3};
#else
uniform ${i4} ${s3} u_${a3};
#endif
` : "vec4" === r3 ? `
#ifndef HAS_UNIFORM_u_${a3}
    ${i4} ${s3} ${a3} = a_${a3};
#else
    ${i4} ${s3} ${a3} = u_${a3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a3}
    ${i4} ${s3} ${a3} = unpack_mix_${r3}(a_${a3}, u_${a3}_t);
#else
    ${i4} ${s3} ${a3} = u_${a3};
#endif
`;
          }), staticAttributes: s2, staticUniforms: r2 };
        }
        class le {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(t4, e2, i3, s2, a2, o2, r2, n2, l2) {
            this.context = t4;
            let h2 = this.boundPaintVertexBuffers.length !== s2.length;
            for (let t5 = 0; !h2 && t5 < s2.length; t5++)
              this.boundPaintVertexBuffers[t5] !== s2[t5] && (h2 = true);
            !this.vao || this.boundProgram !== e2 || this.boundLayoutVertexBuffer !== i3 || h2 || this.boundIndexBuffer !== a2 || this.boundVertexOffset !== o2 || this.boundDynamicVertexBuffer !== r2 || this.boundDynamicVertexBuffer2 !== n2 || this.boundDynamicVertexBuffer3 !== l2 ? this.freshBind(e2, i3, s2, a2, o2, r2, n2, l2) : (t4.bindVertexArray.set(this.vao), r2 && r2.bind(), a2 && a2.dynamicDraw && a2.bind(), n2 && n2.bind(), l2 && l2.bind());
          }
          freshBind(t4, e2, i3, s2, a2, o2, r2, n2) {
            const l2 = t4.numAttributes, h2 = this.context, c2 = h2.gl;
            this.vao && this.destroy(), this.vao = h2.createVertexArray(), h2.bindVertexArray.set(this.vao), this.boundProgram = t4, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i3, this.boundIndexBuffer = s2, this.boundVertexOffset = a2, this.boundDynamicVertexBuffer = o2, this.boundDynamicVertexBuffer2 = r2, this.boundDynamicVertexBuffer3 = n2, e2.enableAttributes(c2, t4);
            for (const e3 of i3)
              e3.enableAttributes(c2, t4);
            o2 && o2.enableAttributes(c2, t4), r2 && r2.enableAttributes(c2, t4), n2 && n2.enableAttributes(c2, t4), e2.bind(), e2.setVertexAttribPointers(c2, t4, a2);
            for (const e3 of i3)
              e3.bind(), e3.setVertexAttribPointers(c2, t4, a2);
            o2 && (o2.bind(), o2.setVertexAttribPointers(c2, t4, a2)), s2 && s2.bind(), r2 && (r2.bind(), r2.setVertexAttribPointers(c2, t4, a2)), n2 && (n2.bind(), n2.setVertexAttribPointers(c2, t4, a2)), h2.currentNumAttributes = l2;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        function he(t4) {
          const e2 = [];
          for (let i3 = 0; i3 < t4.length; i3++) {
            if (null === t4[i3])
              continue;
            const s2 = t4[i3].split(" ");
            e2.push(s2.pop());
          }
          return e2;
        }
        class ce {
          constructor(e2, i3, s2, a2, o2, r2) {
            const n2 = e2.gl;
            this.program = n2.createProgram();
            const l2 = he(i3.staticAttributes), h2 = s2 ? s2.getBinderAttributes() : [], c2 = l2.concat(h2), u2 = re.prelude.staticUniforms ? he(re.prelude.staticUniforms) : [], d2 = i3.staticUniforms ? he(i3.staticUniforms) : [], _2 = s2 ? s2.getBinderUniforms() : [], p2 = u2.concat(d2).concat(_2), m2 = [];
            for (const t4 of p2)
              m2.indexOf(t4) < 0 && m2.push(t4);
            const f2 = s2 ? s2.defines() : [];
            o2 && f2.push("#define OVERDRAW_INSPECTOR;"), r2 && f2.push("#define TERRAIN3D;");
            const g2 = f2.concat(re.prelude.fragmentSource, i3.fragmentSource).join("\n"), v2 = f2.concat(re.prelude.vertexSource, i3.vertexSource).join("\n"), x3 = n2.createShader(n2.FRAGMENT_SHADER);
            if (n2.isContextLost())
              return void (this.failedToCreate = true);
            if (n2.shaderSource(x3, g2), n2.compileShader(x3), !n2.getShaderParameter(x3, n2.COMPILE_STATUS))
              throw new Error(`Could not compile fragment shader: ${n2.getShaderInfoLog(x3)}`);
            n2.attachShader(this.program, x3);
            const y2 = n2.createShader(n2.VERTEX_SHADER);
            if (n2.isContextLost())
              return void (this.failedToCreate = true);
            if (n2.shaderSource(y2, v2), n2.compileShader(y2), !n2.getShaderParameter(y2, n2.COMPILE_STATUS))
              throw new Error(`Could not compile vertex shader: ${n2.getShaderInfoLog(y2)}`);
            n2.attachShader(this.program, y2), this.attributes = {};
            const b2 = {};
            this.numAttributes = c2.length;
            for (let t4 = 0; t4 < this.numAttributes; t4++)
              c2[t4] && (n2.bindAttribLocation(this.program, t4, c2[t4]), this.attributes[c2[t4]] = t4);
            if (n2.linkProgram(this.program), !n2.getProgramParameter(this.program, n2.LINK_STATUS))
              throw new Error(`Program failed to link: ${n2.getProgramInfoLog(this.program)}`);
            n2.deleteShader(y2), n2.deleteShader(x3);
            for (let t4 = 0; t4 < m2.length; t4++) {
              const e3 = m2[t4];
              if (e3 && !b2[e3]) {
                const t5 = n2.getUniformLocation(this.program, e3);
                t5 && (b2[e3] = t5);
              }
            }
            this.fixedUniforms = a2(e2, b2), this.terrainUniforms = ((e3, i4) => ({ u_depth: new t.aL(e3, i4.u_depth), u_terrain: new t.aL(e3, i4.u_terrain), u_terrain_dim: new t.aM(e3, i4.u_terrain_dim), u_terrain_matrix: new t.aN(e3, i4.u_terrain_matrix), u_terrain_unpack: new t.aO(e3, i4.u_terrain_unpack), u_terrain_exaggeration: new t.aM(e3, i4.u_terrain_exaggeration) }))(e2, b2), this.binderUniforms = s2 ? s2.getUniforms(e2, b2) : [];
          }
          draw(t4, e2, i3, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2, m2, f2, g2) {
            const v2 = t4.gl;
            if (this.failedToCreate)
              return;
            if (t4.program.set(this.program), t4.setDepthMode(i3), t4.setStencilMode(s2), t4.setColorMode(a2), t4.setCullFace(o2), n2) {
              t4.activeTexture.set(v2.TEXTURE2), v2.bindTexture(v2.TEXTURE_2D, n2.depthTexture), t4.activeTexture.set(v2.TEXTURE3), v2.bindTexture(v2.TEXTURE_2D, n2.texture);
              for (const t5 in this.terrainUniforms)
                this.terrainUniforms[t5].set(n2[t5]);
            }
            for (const t5 in this.fixedUniforms)
              this.fixedUniforms[t5].set(r2[t5]);
            p2 && p2.setUniforms(t4, this.binderUniforms, d2, { zoom: _2 });
            let x3 = 0;
            switch (e2) {
              case v2.LINES:
                x3 = 2;
                break;
              case v2.TRIANGLES:
                x3 = 3;
                break;
              case v2.LINE_STRIP:
                x3 = 1;
            }
            for (const i4 of u2.get()) {
              const s3 = i4.vaos || (i4.vaos = {});
              (s3[l2] || (s3[l2] = new le())).bind(t4, this, h2, p2 ? p2.getPaintVertexBuffers() : [], c2, i4.vertexOffset, m2, f2, g2), v2.drawElements(e2, i4.primitiveLength * x3, v2.UNSIGNED_SHORT, i4.primitiveOffset * x3 * 2);
            }
          }
        }
        function ue(t4, e2, i3) {
          const s2 = 1 / St(i3, 1, e2.transform.tileZoom), a2 = Math.pow(2, i3.tileID.overscaledZ), o2 = i3.tileSize * Math.pow(2, e2.transform.tileZoom) / a2, r2 = o2 * (i3.tileID.canonical.x + i3.tileID.wrap * a2), n2 = o2 * i3.tileID.canonical.y;
          return { u_image: 0, u_texsize: i3.imageAtlasTexture.size, u_scale: [s2, t4.fromScale, t4.toScale], u_fade: t4.t, u_pixel_coord_upper: [r2 >> 16, n2 >> 16], u_pixel_coord_lower: [65535 & r2, 65535 & n2] };
        }
        const de = (e2, i3, s2, a2) => {
          const o2 = i3.style.light, r2 = o2.properties.get("position"), n2 = [r2.x, r2.y, r2.z], l2 = function() {
            var e3 = new t.A(9);
            return t.A != Float32Array && (e3[1] = 0, e3[2] = 0, e3[3] = 0, e3[5] = 0, e3[6] = 0, e3[7] = 0), e3[0] = 1, e3[4] = 1, e3[8] = 1, e3;
          }();
          "viewport" === o2.properties.get("anchor") && function(t4, e3) {
            var i4 = Math.sin(e3), s3 = Math.cos(e3);
            t4[0] = s3, t4[1] = i4, t4[2] = 0, t4[3] = -i4, t4[4] = s3, t4[5] = 0, t4[6] = 0, t4[7] = 0, t4[8] = 1;
          }(l2, -i3.transform.angle), function(t4, e3, i4) {
            var s3 = e3[0], a3 = e3[1], o3 = e3[2];
            t4[0] = s3 * i4[0] + a3 * i4[3] + o3 * i4[6], t4[1] = s3 * i4[1] + a3 * i4[4] + o3 * i4[7], t4[2] = s3 * i4[2] + a3 * i4[5] + o3 * i4[8];
          }(n2, n2, l2);
          const h2 = o2.properties.get("color");
          return { u_matrix: e2, u_lightpos: n2, u_lightintensity: o2.properties.get("intensity"), u_lightcolor: [h2.r, h2.g, h2.b], u_vertical_gradient: +s2, u_opacity: a2 };
        }, _e = (e2, i3, s2, a2, o2, r2, n2) => t.e(de(e2, i3, s2, a2), ue(r2, i3, n2), { u_height_factor: -Math.pow(2, o2.overscaledZ) / n2.tileSize / 8 }), pe = (t4) => ({ u_matrix: t4 }), me = (e2, i3, s2, a2) => t.e(pe(e2), ue(s2, i3, a2)), fe = (t4, e2) => ({ u_matrix: t4, u_world: e2 }), ge = (e2, i3, s2, a2, o2) => t.e(me(e2, i3, s2, a2), { u_world: o2 }), ve = (t4, e2, i3, s2) => {
          const a2 = t4.transform;
          let o2, r2;
          if ("map" === s2.paint.get("circle-pitch-alignment")) {
            const t5 = St(i3, 1, a2.zoom);
            o2 = true, r2 = [t5, t5];
          } else
            o2 = false, r2 = a2.pixelsToGLUnits;
          return { u_camera_to_center_distance: a2.cameraToCenterDistance, u_scale_with_map: +("map" === s2.paint.get("circle-pitch-scale")), u_matrix: t4.translatePosMatrix(e2.posMatrix, i3, s2.paint.get("circle-translate"), s2.paint.get("circle-translate-anchor")), u_pitch_with_map: +o2, u_device_pixel_ratio: t4.pixelRatio, u_extrude_scale: r2 };
        }, xe = (t4, e2, i3) => {
          const s2 = St(i3, 1, e2.zoom), a2 = Math.pow(2, e2.zoom - i3.tileID.overscaledZ), o2 = i3.tileID.overscaleFactor();
          return { u_matrix: t4, u_camera_to_center_distance: e2.cameraToCenterDistance, u_pixels_to_tile_units: s2, u_extrude_scale: [e2.pixelsToGLUnits[0] / (s2 * a2), e2.pixelsToGLUnits[1] / (s2 * a2)], u_overscale_factor: o2 };
        }, ye = (t4, e2, i3 = 1) => ({ u_matrix: t4, u_color: e2, u_overlay: 0, u_overlay_scale: i3 }), be = (t4) => ({ u_matrix: t4 }), we = (t4, e2, i3, s2) => ({ u_matrix: t4, u_extrude_scale: St(e2, 1, i3), u_intensity: s2 });
        function Te(e2, i3) {
          const s2 = Math.pow(2, i3.canonical.z), a2 = i3.canonical.y;
          return [new t.U(0, a2 / s2).toLngLat().lat, new t.U(0, (a2 + 1) / s2).toLngLat().lat];
        }
        const Ie = (t4, e2, i3, s2) => {
          const a2 = t4.transform;
          return { u_matrix: De(t4, e2, i3, s2), u_ratio: 1 / St(e2, 1, a2.zoom), u_device_pixel_ratio: t4.pixelRatio, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
        }, Ee = (e2, i3, s2, a2, o2) => t.e(Ie(e2, i3, s2, o2), { u_image: 0, u_image_height: a2 }), Se = (t4, e2, i3, s2, a2) => {
          const o2 = t4.transform, r2 = Pe(e2, o2);
          return { u_matrix: De(t4, e2, i3, a2), u_texsize: e2.imageAtlasTexture.size, u_ratio: 1 / St(e2, 1, o2.zoom), u_device_pixel_ratio: t4.pixelRatio, u_image: 0, u_scale: [r2, s2.fromScale, s2.toScale], u_fade: s2.t, u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]] };
        }, Ce = (e2, i3, s2, a2, o2, r2) => {
          const n2 = e2.lineAtlas, l2 = Pe(i3, e2.transform), h2 = "round" === s2.layout.get("line-cap"), c2 = n2.getDash(a2.from, h2), u2 = n2.getDash(a2.to, h2), d2 = c2.width * o2.fromScale, _2 = u2.width * o2.toScale;
          return t.e(Ie(e2, i3, s2, r2), { u_patternscale_a: [l2 / d2, -c2.height / 2], u_patternscale_b: [l2 / _2, -u2.height / 2], u_sdfgamma: n2.width / (256 * Math.min(d2, _2) * e2.pixelRatio) / 2, u_image: 0, u_tex_y_a: c2.y, u_tex_y_b: u2.y, u_mix: o2.t });
        };
        function Pe(t4, e2) {
          return 1 / St(t4, 1, e2.tileZoom);
        }
        function De(t4, e2, i3, s2) {
          return t4.translatePosMatrix(s2 ? s2.posMatrix : e2.tileID.posMatrix, e2, i3.paint.get("line-translate"), i3.paint.get("line-translate-anchor"));
        }
        const Me = (t4, e2, i3, s2, a2) => {
          return { u_matrix: t4, u_tl_parent: e2, u_scale_parent: i3, u_buffer_scale: 1, u_fade_t: s2.mix, u_opacity: s2.opacity * a2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a2.paint.get("raster-brightness-min"), u_brightness_high: a2.paint.get("raster-brightness-max"), u_saturation_factor: (r2 = a2.paint.get("raster-saturation"), r2 > 0 ? 1 - 1 / (1.001 - r2) : -r2), u_contrast_factor: (o2 = a2.paint.get("raster-contrast"), o2 > 0 ? 1 / (1 - o2) : 1 + o2), u_spin_weights: ze(a2.paint.get("raster-hue-rotate")) };
          var o2, r2;
        };
        function ze(t4) {
          t4 *= Math.PI / 180;
          const e2 = Math.sin(t4), i3 = Math.cos(t4);
          return [(2 * i3 + 1) / 3, (-Math.sqrt(3) * e2 - i3 + 1) / 3, (Math.sqrt(3) * e2 - i3 + 1) / 3];
        }
        const Le = (t4, e2, i3, s2, a2, o2, r2, n2, l2, h2) => {
          const c2 = a2.transform;
          return { u_is_size_zoom_constant: +("constant" === t4 || "source" === t4), u_is_size_feature_constant: +("constant" === t4 || "camera" === t4), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: c2.cameraToCenterDistance, u_pitch: c2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i3, u_aspect_ratio: c2.width / c2.height, u_fade_change: a2.options.fadeDuration ? a2.symbolFadeChange : 1, u_matrix: o2, u_label_plane_matrix: r2, u_coord_matrix: n2, u_is_text: +l2, u_pitch_with_map: +s2, u_texsize: h2, u_texture: 0 };
        }, Ae = (e2, i3, s2, a2, o2, r2, n2, l2, h2, c2, u2) => {
          const d2 = o2.transform;
          return t.e(Le(e2, i3, s2, a2, o2, r2, n2, l2, h2, c2), { u_gamma_scale: a2 ? Math.cos(d2._pitch) * d2.cameraToCenterDistance : 1, u_device_pixel_ratio: o2.pixelRatio, u_is_halo: +u2 });
        }, Re = (e2, i3, s2, a2, o2, r2, n2, l2, h2, c2) => t.e(Ae(e2, i3, s2, a2, o2, r2, n2, l2, true, h2, true), { u_texsize_icon: c2, u_texture_icon: 1 }), ke = (t4, e2, i3) => ({ u_matrix: t4, u_opacity: e2, u_color: i3 }), Fe = (e2, i3, s2, a2, o2, r2) => t.e(function(t4, e3, i4, s3) {
          const a3 = i4.imageManager.getPattern(t4.from.toString()), o3 = i4.imageManager.getPattern(t4.to.toString()), { width: r3, height: n2 } = i4.imageManager.getPixelSize(), l2 = Math.pow(2, s3.tileID.overscaledZ), h2 = s3.tileSize * Math.pow(2, i4.transform.tileZoom) / l2, c2 = h2 * (s3.tileID.canonical.x + s3.tileID.wrap * l2), u2 = h2 * s3.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: a3.tl, u_pattern_br_a: a3.br, u_pattern_tl_b: o3.tl, u_pattern_br_b: o3.br, u_texsize: [r3, n2], u_mix: e3.t, u_pattern_size_a: a3.displaySize, u_pattern_size_b: o3.displaySize, u_scale_a: e3.fromScale, u_scale_b: e3.toScale, u_tile_units_to_pixels: 1 / St(s3, 1, i4.transform.tileZoom), u_pixel_coord_upper: [c2 >> 16, u2 >> 16], u_pixel_coord_lower: [65535 & c2, 65535 & u2] };
        }(a2, r2, s2, o2), { u_matrix: e2, u_opacity: i3 }), Be = { fillExtrusion: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_lightpos: new t.aP(e2, i3.u_lightpos), u_lightintensity: new t.aM(e2, i3.u_lightintensity), u_lightcolor: new t.aP(e2, i3.u_lightcolor), u_vertical_gradient: new t.aM(e2, i3.u_vertical_gradient), u_opacity: new t.aM(e2, i3.u_opacity) }), fillExtrusionPattern: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_lightpos: new t.aP(e2, i3.u_lightpos), u_lightintensity: new t.aM(e2, i3.u_lightintensity), u_lightcolor: new t.aP(e2, i3.u_lightcolor), u_vertical_gradient: new t.aM(e2, i3.u_vertical_gradient), u_height_factor: new t.aM(e2, i3.u_height_factor), u_image: new t.aL(e2, i3.u_image), u_texsize: new t.aQ(e2, i3.u_texsize), u_pixel_coord_upper: new t.aQ(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t.aQ(e2, i3.u_pixel_coord_lower), u_scale: new t.aP(e2, i3.u_scale), u_fade: new t.aM(e2, i3.u_fade), u_opacity: new t.aM(e2, i3.u_opacity) }), fill: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix) }), fillPattern: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_image: new t.aL(e2, i3.u_image), u_texsize: new t.aQ(e2, i3.u_texsize), u_pixel_coord_upper: new t.aQ(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t.aQ(e2, i3.u_pixel_coord_lower), u_scale: new t.aP(e2, i3.u_scale), u_fade: new t.aM(e2, i3.u_fade) }), fillOutline: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_world: new t.aQ(e2, i3.u_world) }), fillOutlinePattern: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_world: new t.aQ(e2, i3.u_world), u_image: new t.aL(e2, i3.u_image), u_texsize: new t.aQ(e2, i3.u_texsize), u_pixel_coord_upper: new t.aQ(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t.aQ(e2, i3.u_pixel_coord_lower), u_scale: new t.aP(e2, i3.u_scale), u_fade: new t.aM(e2, i3.u_fade) }), circle: (e2, i3) => ({ u_camera_to_center_distance: new t.aM(e2, i3.u_camera_to_center_distance), u_scale_with_map: new t.aL(e2, i3.u_scale_with_map), u_pitch_with_map: new t.aL(e2, i3.u_pitch_with_map), u_extrude_scale: new t.aQ(e2, i3.u_extrude_scale), u_device_pixel_ratio: new t.aM(e2, i3.u_device_pixel_ratio), u_matrix: new t.aN(e2, i3.u_matrix) }), collisionBox: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_camera_to_center_distance: new t.aM(e2, i3.u_camera_to_center_distance), u_pixels_to_tile_units: new t.aM(e2, i3.u_pixels_to_tile_units), u_extrude_scale: new t.aQ(e2, i3.u_extrude_scale), u_overscale_factor: new t.aM(e2, i3.u_overscale_factor) }), collisionCircle: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_inv_matrix: new t.aN(e2, i3.u_inv_matrix), u_camera_to_center_distance: new t.aM(e2, i3.u_camera_to_center_distance), u_viewport_size: new t.aQ(e2, i3.u_viewport_size) }), debug: (e2, i3) => ({ u_color: new t.aR(e2, i3.u_color), u_matrix: new t.aN(e2, i3.u_matrix), u_overlay: new t.aL(e2, i3.u_overlay), u_overlay_scale: new t.aM(e2, i3.u_overlay_scale) }), clippingMask: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix) }), heatmap: (e2, i3) => ({ u_extrude_scale: new t.aM(e2, i3.u_extrude_scale), u_intensity: new t.aM(e2, i3.u_intensity), u_matrix: new t.aN(e2, i3.u_matrix) }), heatmapTexture: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_world: new t.aQ(e2, i3.u_world), u_image: new t.aL(e2, i3.u_image), u_color_ramp: new t.aL(e2, i3.u_color_ramp), u_opacity: new t.aM(e2, i3.u_opacity) }), hillshade: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_image: new t.aL(e2, i3.u_image), u_latrange: new t.aQ(e2, i3.u_latrange), u_light: new t.aQ(e2, i3.u_light), u_shadow: new t.aR(e2, i3.u_shadow), u_highlight: new t.aR(e2, i3.u_highlight), u_accent: new t.aR(e2, i3.u_accent) }), hillshadePrepare: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_image: new t.aL(e2, i3.u_image), u_dimension: new t.aQ(e2, i3.u_dimension), u_zoom: new t.aM(e2, i3.u_zoom), u_unpack: new t.aO(e2, i3.u_unpack) }), line: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_ratio: new t.aM(e2, i3.u_ratio), u_device_pixel_ratio: new t.aM(e2, i3.u_device_pixel_ratio), u_units_to_pixels: new t.aQ(e2, i3.u_units_to_pixels) }), lineGradient: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_ratio: new t.aM(e2, i3.u_ratio), u_device_pixel_ratio: new t.aM(e2, i3.u_device_pixel_ratio), u_units_to_pixels: new t.aQ(e2, i3.u_units_to_pixels), u_image: new t.aL(e2, i3.u_image), u_image_height: new t.aM(e2, i3.u_image_height) }), linePattern: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_texsize: new t.aQ(e2, i3.u_texsize), u_ratio: new t.aM(e2, i3.u_ratio), u_device_pixel_ratio: new t.aM(e2, i3.u_device_pixel_ratio), u_image: new t.aL(e2, i3.u_image), u_units_to_pixels: new t.aQ(e2, i3.u_units_to_pixels), u_scale: new t.aP(e2, i3.u_scale), u_fade: new t.aM(e2, i3.u_fade) }), lineSDF: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_ratio: new t.aM(e2, i3.u_ratio), u_device_pixel_ratio: new t.aM(e2, i3.u_device_pixel_ratio), u_units_to_pixels: new t.aQ(e2, i3.u_units_to_pixels), u_patternscale_a: new t.aQ(e2, i3.u_patternscale_a), u_patternscale_b: new t.aQ(e2, i3.u_patternscale_b), u_sdfgamma: new t.aM(e2, i3.u_sdfgamma), u_image: new t.aL(e2, i3.u_image), u_tex_y_a: new t.aM(e2, i3.u_tex_y_a), u_tex_y_b: new t.aM(e2, i3.u_tex_y_b), u_mix: new t.aM(e2, i3.u_mix) }), raster: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_tl_parent: new t.aQ(e2, i3.u_tl_parent), u_scale_parent: new t.aM(e2, i3.u_scale_parent), u_buffer_scale: new t.aM(e2, i3.u_buffer_scale), u_fade_t: new t.aM(e2, i3.u_fade_t), u_opacity: new t.aM(e2, i3.u_opacity), u_image0: new t.aL(e2, i3.u_image0), u_image1: new t.aL(e2, i3.u_image1), u_brightness_low: new t.aM(e2, i3.u_brightness_low), u_brightness_high: new t.aM(e2, i3.u_brightness_high), u_saturation_factor: new t.aM(e2, i3.u_saturation_factor), u_contrast_factor: new t.aM(e2, i3.u_contrast_factor), u_spin_weights: new t.aP(e2, i3.u_spin_weights) }), symbolIcon: (e2, i3) => ({ u_is_size_zoom_constant: new t.aL(e2, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t.aL(e2, i3.u_is_size_feature_constant), u_size_t: new t.aM(e2, i3.u_size_t), u_size: new t.aM(e2, i3.u_size), u_camera_to_center_distance: new t.aM(e2, i3.u_camera_to_center_distance), u_pitch: new t.aM(e2, i3.u_pitch), u_rotate_symbol: new t.aL(e2, i3.u_rotate_symbol), u_aspect_ratio: new t.aM(e2, i3.u_aspect_ratio), u_fade_change: new t.aM(e2, i3.u_fade_change), u_matrix: new t.aN(e2, i3.u_matrix), u_label_plane_matrix: new t.aN(e2, i3.u_label_plane_matrix), u_coord_matrix: new t.aN(e2, i3.u_coord_matrix), u_is_text: new t.aL(e2, i3.u_is_text), u_pitch_with_map: new t.aL(e2, i3.u_pitch_with_map), u_texsize: new t.aQ(e2, i3.u_texsize), u_texture: new t.aL(e2, i3.u_texture) }), symbolSDF: (e2, i3) => ({ u_is_size_zoom_constant: new t.aL(e2, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t.aL(e2, i3.u_is_size_feature_constant), u_size_t: new t.aM(e2, i3.u_size_t), u_size: new t.aM(e2, i3.u_size), u_camera_to_center_distance: new t.aM(e2, i3.u_camera_to_center_distance), u_pitch: new t.aM(e2, i3.u_pitch), u_rotate_symbol: new t.aL(e2, i3.u_rotate_symbol), u_aspect_ratio: new t.aM(e2, i3.u_aspect_ratio), u_fade_change: new t.aM(e2, i3.u_fade_change), u_matrix: new t.aN(e2, i3.u_matrix), u_label_plane_matrix: new t.aN(e2, i3.u_label_plane_matrix), u_coord_matrix: new t.aN(e2, i3.u_coord_matrix), u_is_text: new t.aL(e2, i3.u_is_text), u_pitch_with_map: new t.aL(e2, i3.u_pitch_with_map), u_texsize: new t.aQ(e2, i3.u_texsize), u_texture: new t.aL(e2, i3.u_texture), u_gamma_scale: new t.aM(e2, i3.u_gamma_scale), u_device_pixel_ratio: new t.aM(e2, i3.u_device_pixel_ratio), u_is_halo: new t.aL(e2, i3.u_is_halo) }), symbolTextAndIcon: (e2, i3) => ({ u_is_size_zoom_constant: new t.aL(e2, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t.aL(e2, i3.u_is_size_feature_constant), u_size_t: new t.aM(e2, i3.u_size_t), u_size: new t.aM(e2, i3.u_size), u_camera_to_center_distance: new t.aM(e2, i3.u_camera_to_center_distance), u_pitch: new t.aM(e2, i3.u_pitch), u_rotate_symbol: new t.aL(e2, i3.u_rotate_symbol), u_aspect_ratio: new t.aM(e2, i3.u_aspect_ratio), u_fade_change: new t.aM(e2, i3.u_fade_change), u_matrix: new t.aN(e2, i3.u_matrix), u_label_plane_matrix: new t.aN(e2, i3.u_label_plane_matrix), u_coord_matrix: new t.aN(e2, i3.u_coord_matrix), u_is_text: new t.aL(e2, i3.u_is_text), u_pitch_with_map: new t.aL(e2, i3.u_pitch_with_map), u_texsize: new t.aQ(e2, i3.u_texsize), u_texsize_icon: new t.aQ(e2, i3.u_texsize_icon), u_texture: new t.aL(e2, i3.u_texture), u_texture_icon: new t.aL(e2, i3.u_texture_icon), u_gamma_scale: new t.aM(e2, i3.u_gamma_scale), u_device_pixel_ratio: new t.aM(e2, i3.u_device_pixel_ratio), u_is_halo: new t.aL(e2, i3.u_is_halo) }), background: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_opacity: new t.aM(e2, i3.u_opacity), u_color: new t.aR(e2, i3.u_color) }), backgroundPattern: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_opacity: new t.aM(e2, i3.u_opacity), u_image: new t.aL(e2, i3.u_image), u_pattern_tl_a: new t.aQ(e2, i3.u_pattern_tl_a), u_pattern_br_a: new t.aQ(e2, i3.u_pattern_br_a), u_pattern_tl_b: new t.aQ(e2, i3.u_pattern_tl_b), u_pattern_br_b: new t.aQ(e2, i3.u_pattern_br_b), u_texsize: new t.aQ(e2, i3.u_texsize), u_mix: new t.aM(e2, i3.u_mix), u_pattern_size_a: new t.aQ(e2, i3.u_pattern_size_a), u_pattern_size_b: new t.aQ(e2, i3.u_pattern_size_b), u_scale_a: new t.aM(e2, i3.u_scale_a), u_scale_b: new t.aM(e2, i3.u_scale_b), u_pixel_coord_upper: new t.aQ(e2, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t.aQ(e2, i3.u_pixel_coord_lower), u_tile_units_to_pixels: new t.aM(e2, i3.u_tile_units_to_pixels) }), terrain: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_texture: new t.aL(e2, i3.u_texture), u_ele_delta: new t.aM(e2, i3.u_ele_delta) }), terrainDepth: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_ele_delta: new t.aM(e2, i3.u_ele_delta) }), terrainCoords: (e2, i3) => ({ u_matrix: new t.aN(e2, i3.u_matrix), u_texture: new t.aL(e2, i3.u_texture), u_terrain_coords_id: new t.aM(e2, i3.u_terrain_coords_id), u_ele_delta: new t.aM(e2, i3.u_ele_delta) }) };
        class Oe {
          constructor(t4, e2, i3) {
            this.context = t4;
            const s2 = t4.gl;
            this.buffer = s2.createBuffer(), this.dynamicDraw = Boolean(i3), this.context.unbindVAO(), t4.bindElementBuffer.set(this.buffer), s2.bufferData(s2.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? s2.DYNAMIC_DRAW : s2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t4) {
            const e2 = this.context.gl;
            if (!this.dynamicDraw)
              throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t4.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Ne = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Ue {
          constructor(t4, e2, i3, s2) {
            this.length = e2.length, this.attributes = i3, this.itemSize = e2.bytesPerElement, this.dynamicDraw = s2, this.context = t4;
            const a2 = t4.gl;
            this.buffer = a2.createBuffer(), t4.bindVertexBuffer.set(this.buffer), a2.bufferData(a2.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t4) {
            if (t4.length !== this.length)
              throw new Error(`Length of new data is ${t4.length}, which doesn't match current length of ${this.length}`);
            const e2 = this.context.gl;
            this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t4.arrayBuffer);
          }
          enableAttributes(t4, e2) {
            for (let i3 = 0; i3 < this.attributes.length; i3++) {
              const s2 = e2.attributes[this.attributes[i3].name];
              void 0 !== s2 && t4.enableVertexAttribArray(s2);
            }
          }
          setVertexAttribPointers(t4, e2, i3) {
            for (let s2 = 0; s2 < this.attributes.length; s2++) {
              const a2 = this.attributes[s2], o2 = e2.attributes[a2.name];
              void 0 !== o2 && t4.vertexAttribPointer(o2, a2.components, t4[Ne[a2.type]], false, this.itemSize, a2.offset + this.itemSize * (i3 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Ze = /* @__PURE__ */ new WeakMap();
        function Ge(t4) {
          var e2;
          if (Ze.has(t4))
            return Ze.get(t4);
          {
            const i3 = null === (e2 = t4.getParameter(t4.VERSION)) || void 0 === e2 ? void 0 : e2.startsWith("WebGL 2.0");
            return Ze.set(t4, i3), i3;
          }
        }
        class je {
          constructor(t4) {
            this.gl = t4.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(t4) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Ve extends je {
          getDefault() {
            return t.aT.transparent;
          }
          set(t4) {
            const e2 = this.current;
            (t4.r !== e2.r || t4.g !== e2.g || t4.b !== e2.b || t4.a !== e2.a || this.dirty) && (this.gl.clearColor(t4.r, t4.g, t4.b, t4.a), this.current = t4, this.dirty = false);
          }
        }
        class qe extends je {
          getDefault() {
            return 1;
          }
          set(t4) {
            (t4 !== this.current || this.dirty) && (this.gl.clearDepth(t4), this.current = t4, this.dirty = false);
          }
        }
        class $e extends je {
          getDefault() {
            return 0;
          }
          set(t4) {
            (t4 !== this.current || this.dirty) && (this.gl.clearStencil(t4), this.current = t4, this.dirty = false);
          }
        }
        class We extends je {
          getDefault() {
            return [true, true, true, true];
          }
          set(t4) {
            const e2 = this.current;
            (t4[0] !== e2[0] || t4[1] !== e2[1] || t4[2] !== e2[2] || t4[3] !== e2[3] || this.dirty) && (this.gl.colorMask(t4[0], t4[1], t4[2], t4[3]), this.current = t4, this.dirty = false);
          }
        }
        class He extends je {
          getDefault() {
            return true;
          }
          set(t4) {
            (t4 !== this.current || this.dirty) && (this.gl.depthMask(t4), this.current = t4, this.dirty = false);
          }
        }
        class Xe extends je {
          getDefault() {
            return 255;
          }
          set(t4) {
            (t4 !== this.current || this.dirty) && (this.gl.stencilMask(t4), this.current = t4, this.dirty = false);
          }
        }
        class Ke extends je {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t4) {
            const e2 = this.current;
            (t4.func !== e2.func || t4.ref !== e2.ref || t4.mask !== e2.mask || this.dirty) && (this.gl.stencilFunc(t4.func, t4.ref, t4.mask), this.current = t4, this.dirty = false);
          }
        }
        class Qe extends je {
          getDefault() {
            const t4 = this.gl;
            return [t4.KEEP, t4.KEEP, t4.KEEP];
          }
          set(t4) {
            const e2 = this.current;
            (t4[0] !== e2[0] || t4[1] !== e2[1] || t4[2] !== e2[2] || this.dirty) && (this.gl.stencilOp(t4[0], t4[1], t4[2]), this.current = t4, this.dirty = false);
          }
        }
        class Ye extends je {
          getDefault() {
            return false;
          }
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            t4 ? e2.enable(e2.STENCIL_TEST) : e2.disable(e2.STENCIL_TEST), this.current = t4, this.dirty = false;
          }
        }
        class Je extends je {
          getDefault() {
            return [0, 1];
          }
          set(t4) {
            const e2 = this.current;
            (t4[0] !== e2[0] || t4[1] !== e2[1] || this.dirty) && (this.gl.depthRange(t4[0], t4[1]), this.current = t4, this.dirty = false);
          }
        }
        class ti extends je {
          getDefault() {
            return false;
          }
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            t4 ? e2.enable(e2.DEPTH_TEST) : e2.disable(e2.DEPTH_TEST), this.current = t4, this.dirty = false;
          }
        }
        class ei extends je {
          getDefault() {
            return this.gl.LESS;
          }
          set(t4) {
            (t4 !== this.current || this.dirty) && (this.gl.depthFunc(t4), this.current = t4, this.dirty = false);
          }
        }
        class ii extends je {
          getDefault() {
            return false;
          }
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            t4 ? e2.enable(e2.BLEND) : e2.disable(e2.BLEND), this.current = t4, this.dirty = false;
          }
        }
        class si extends je {
          getDefault() {
            const t4 = this.gl;
            return [t4.ONE, t4.ZERO];
          }
          set(t4) {
            const e2 = this.current;
            (t4[0] !== e2[0] || t4[1] !== e2[1] || this.dirty) && (this.gl.blendFunc(t4[0], t4[1]), this.current = t4, this.dirty = false);
          }
        }
        class ai extends je {
          getDefault() {
            return t.aT.transparent;
          }
          set(t4) {
            const e2 = this.current;
            (t4.r !== e2.r || t4.g !== e2.g || t4.b !== e2.b || t4.a !== e2.a || this.dirty) && (this.gl.blendColor(t4.r, t4.g, t4.b, t4.a), this.current = t4, this.dirty = false);
          }
        }
        class oi extends je {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t4) {
            (t4 !== this.current || this.dirty) && (this.gl.blendEquation(t4), this.current = t4, this.dirty = false);
          }
        }
        class ri extends je {
          getDefault() {
            return false;
          }
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            t4 ? e2.enable(e2.CULL_FACE) : e2.disable(e2.CULL_FACE), this.current = t4, this.dirty = false;
          }
        }
        class ni extends je {
          getDefault() {
            return this.gl.BACK;
          }
          set(t4) {
            (t4 !== this.current || this.dirty) && (this.gl.cullFace(t4), this.current = t4, this.dirty = false);
          }
        }
        class li extends je {
          getDefault() {
            return this.gl.CCW;
          }
          set(t4) {
            (t4 !== this.current || this.dirty) && (this.gl.frontFace(t4), this.current = t4, this.dirty = false);
          }
        }
        class hi extends je {
          getDefault() {
            return null;
          }
          set(t4) {
            (t4 !== this.current || this.dirty) && (this.gl.useProgram(t4), this.current = t4, this.dirty = false);
          }
        }
        class ci extends je {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t4) {
            (t4 !== this.current || this.dirty) && (this.gl.activeTexture(t4), this.current = t4, this.dirty = false);
          }
        }
        class ui extends je {
          getDefault() {
            const t4 = this.gl;
            return [0, 0, t4.drawingBufferWidth, t4.drawingBufferHeight];
          }
          set(t4) {
            const e2 = this.current;
            (t4[0] !== e2[0] || t4[1] !== e2[1] || t4[2] !== e2[2] || t4[3] !== e2[3] || this.dirty) && (this.gl.viewport(t4[0], t4[1], t4[2], t4[3]), this.current = t4, this.dirty = false);
          }
        }
        class di extends je {
          getDefault() {
            return null;
          }
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.bindFramebuffer(e2.FRAMEBUFFER, t4), this.current = t4, this.dirty = false;
          }
        }
        class _i extends je {
          getDefault() {
            return null;
          }
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.bindRenderbuffer(e2.RENDERBUFFER, t4), this.current = t4, this.dirty = false;
          }
        }
        class pi extends je {
          getDefault() {
            return null;
          }
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.bindTexture(e2.TEXTURE_2D, t4), this.current = t4, this.dirty = false;
          }
        }
        class mi extends je {
          getDefault() {
            return null;
          }
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.bindBuffer(e2.ARRAY_BUFFER, t4), this.current = t4, this.dirty = false;
          }
        }
        class fi extends je {
          getDefault() {
            return null;
          }
          set(t4) {
            const e2 = this.gl;
            e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, t4), this.current = t4, this.dirty = false;
          }
        }
        class gi extends je {
          getDefault() {
            return null;
          }
          set(t4) {
            var e2;
            if (t4 === this.current && !this.dirty)
              return;
            const i3 = this.gl;
            Ge(i3) ? i3.bindVertexArray(t4) : null === (e2 = i3.getExtension("OES_vertex_array_object")) || void 0 === e2 || e2.bindVertexArrayOES(t4), this.current = t4, this.dirty = false;
          }
        }
        class vi extends je {
          getDefault() {
            return 4;
          }
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_ALIGNMENT, t4), this.current = t4, this.dirty = false;
          }
        }
        class xi extends je {
          getDefault() {
            return false;
          }
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t4), this.current = t4, this.dirty = false;
          }
        }
        class yi extends je {
          getDefault() {
            return false;
          }
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            const e2 = this.gl;
            e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, t4), this.current = t4, this.dirty = false;
          }
        }
        class bi extends je {
          constructor(t4, e2) {
            super(t4), this.context = t4, this.parent = e2;
          }
          getDefault() {
            return null;
          }
        }
        class wi extends bi {
          setDirty() {
            this.dirty = true;
          }
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const e2 = this.gl;
            e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t4, 0), this.current = t4, this.dirty = false;
          }
        }
        class Ti extends bi {
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const e2 = this.gl;
            e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_ATTACHMENT, e2.RENDERBUFFER, t4), this.current = t4, this.dirty = false;
          }
        }
        class Ii extends bi {
          set(t4) {
            if (t4 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const e2 = this.gl;
            e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_STENCIL_ATTACHMENT, e2.RENDERBUFFER, t4), this.current = t4, this.dirty = false;
          }
        }
        class Ei {
          constructor(t4, e2, i3, s2, a2) {
            this.context = t4, this.width = e2, this.height = i3;
            const o2 = t4.gl, r2 = this.framebuffer = o2.createFramebuffer();
            if (this.colorAttachment = new wi(t4, r2), s2)
              this.depthAttachment = a2 ? new Ii(t4, r2) : new Ti(t4, r2);
            else if (a2)
              throw new Error("Stencil cannot be setted without depth");
            if (o2.checkFramebufferStatus(o2.FRAMEBUFFER) !== o2.FRAMEBUFFER_COMPLETE)
              throw new Error("Framebuffer is not complete");
          }
          destroy() {
            const t4 = this.context.gl, e2 = this.colorAttachment.get();
            if (e2 && t4.deleteTexture(e2), this.depthAttachment) {
              const e3 = this.depthAttachment.get();
              e3 && t4.deleteRenderbuffer(e3);
            }
            t4.deleteFramebuffer(this.framebuffer);
          }
        }
        class Si {
          constructor(t4, e2, i3) {
            this.blendFunction = t4, this.blendColor = e2, this.mask = i3;
          }
        }
        Si.Replace = [1, 0], Si.disabled = new Si(Si.Replace, t.aT.transparent, [false, false, false, false]), Si.unblended = new Si(Si.Replace, t.aT.transparent, [true, true, true, true]), Si.alphaBlended = new Si([1, 771], t.aT.transparent, [true, true, true, true]);
        class Ci {
          constructor(t4) {
            var e2, i3;
            if (this.gl = t4, this.clearColor = new Ve(this), this.clearDepth = new qe(this), this.clearStencil = new $e(this), this.colorMask = new We(this), this.depthMask = new He(this), this.stencilMask = new Xe(this), this.stencilFunc = new Ke(this), this.stencilOp = new Qe(this), this.stencilTest = new Ye(this), this.depthRange = new Je(this), this.depthTest = new ti(this), this.depthFunc = new ei(this), this.blend = new ii(this), this.blendFunc = new si(this), this.blendColor = new ai(this), this.blendEquation = new oi(this), this.cullFace = new ri(this), this.cullFaceSide = new ni(this), this.frontFace = new li(this), this.program = new hi(this), this.activeTexture = new ci(this), this.viewport = new ui(this), this.bindFramebuffer = new di(this), this.bindRenderbuffer = new _i(this), this.bindTexture = new pi(this), this.bindVertexBuffer = new mi(this), this.bindElementBuffer = new fi(this), this.bindVertexArray = new gi(this), this.pixelStoreUnpack = new vi(this), this.pixelStoreUnpackPremultiplyAlpha = new xi(this), this.pixelStoreUnpackFlipY = new yi(this), this.extTextureFilterAnisotropic = t4.getExtension("EXT_texture_filter_anisotropic") || t4.getExtension("MOZ_EXT_texture_filter_anisotropic") || t4.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t4.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t4.getParameter(t4.MAX_TEXTURE_SIZE), Ge(t4)) {
              this.HALF_FLOAT = t4.HALF_FLOAT;
              const s2 = t4.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = null !== (e2 = t4.RGBA16F) && void 0 !== e2 ? e2 : null == s2 ? void 0 : s2.RGBA16F_EXT, this.RGB16F = null !== (i3 = t4.RGB16F) && void 0 !== i3 ? i3 : null == s2 ? void 0 : s2.RGB16F_EXT, t4.getExtension("EXT_color_buffer_float");
            } else {
              t4.getExtension("EXT_color_buffer_half_float"), t4.getExtension("OES_texture_half_float_linear");
              const e3 = t4.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = null == e3 ? void 0 : e3.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(t4, e2) {
            return new Oe(this, t4, e2);
          }
          createVertexBuffer(t4, e2, i3) {
            return new Ue(this, t4, e2, i3);
          }
          createRenderbuffer(t4, e2, i3) {
            const s2 = this.gl, a2 = s2.createRenderbuffer();
            return this.bindRenderbuffer.set(a2), s2.renderbufferStorage(s2.RENDERBUFFER, t4, e2, i3), this.bindRenderbuffer.set(null), a2;
          }
          createFramebuffer(t4, e2, i3, s2) {
            return new Ei(this, t4, e2, i3, s2);
          }
          clear({ color: t4, depth: e2, stencil: i3 }) {
            const s2 = this.gl;
            let a2 = 0;
            t4 && (a2 |= s2.COLOR_BUFFER_BIT, this.clearColor.set(t4), this.colorMask.set([true, true, true, true])), void 0 !== e2 && (a2 |= s2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e2), this.depthMask.set(true)), void 0 !== i3 && (a2 |= s2.STENCIL_BUFFER_BIT, this.clearStencil.set(i3), this.stencilMask.set(255)), s2.clear(a2);
          }
          setCullFace(t4) {
            false === t4.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t4.mode), this.frontFace.set(t4.frontFace));
          }
          setDepthMode(t4) {
            t4.func !== this.gl.ALWAYS || t4.mask ? (this.depthTest.set(true), this.depthFunc.set(t4.func), this.depthMask.set(t4.mask), this.depthRange.set(t4.range)) : this.depthTest.set(false);
          }
          setStencilMode(t4) {
            t4.test.func !== this.gl.ALWAYS || t4.mask ? (this.stencilTest.set(true), this.stencilMask.set(t4.mask), this.stencilOp.set([t4.fail, t4.depthFail, t4.pass]), this.stencilFunc.set({ func: t4.test.func, ref: t4.ref, mask: t4.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(e2) {
            t.aG(e2.blendFunction, Si.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
          }
          createVertexArray() {
            var t4;
            return Ge(this.gl) ? this.gl.createVertexArray() : null === (t4 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t4 ? void 0 : t4.createVertexArrayOES();
          }
          deleteVertexArray(t4) {
            var e2;
            return Ge(this.gl) ? this.gl.deleteVertexArray(t4) : null === (e2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e2 ? void 0 : e2.deleteVertexArrayOES(t4);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        class Pi {
          constructor(t4, e2, i3) {
            this.func = t4, this.mask = e2, this.range = i3;
          }
        }
        Pi.ReadOnly = false, Pi.ReadWrite = true, Pi.disabled = new Pi(519, Pi.ReadOnly, [0, 1]);
        const Di = 7680;
        class Mi {
          constructor(t4, e2, i3, s2, a2, o2) {
            this.test = t4, this.ref = e2, this.mask = i3, this.fail = s2, this.depthFail = a2, this.pass = o2;
          }
        }
        Mi.disabled = new Mi({ func: 519, mask: 0 }, 0, 0, Di, Di, Di);
        class zi {
          constructor(t4, e2, i3) {
            this.enable = t4, this.mode = e2, this.frontFace = i3;
          }
        }
        let Li;
        function Ai(e2, i3, s2, a2, o2, r2, n2) {
          const l2 = e2.context, h2 = l2.gl, c2 = e2.useProgram("collisionBox"), u2 = [];
          let d2 = 0, _2 = 0;
          for (let p3 = 0; p3 < a2.length; p3++) {
            const m3 = a2[p3], f3 = i3.getTile(m3), g3 = f3.getBucket(s2);
            if (!g3)
              continue;
            let v3 = m3.posMatrix;
            0 === o2[0] && 0 === o2[1] || (v3 = e2.translatePosMatrix(m3.posMatrix, f3, o2, r2));
            const x4 = n2 ? g3.textCollisionBox : g3.iconCollisionBox, y2 = g3.collisionCircleArray;
            if (y2.length > 0) {
              const i4 = t.Z(), s3 = v3;
              t.aU(i4, g3.placementInvProjMatrix, e2.transform.glCoordMatrix), t.aU(i4, i4, g3.placementViewportMatrix), u2.push({ circleArray: y2, circleOffset: _2, transform: s3, invTransform: i4, coord: m3 }), d2 += y2.length / 4, _2 = d2;
            }
            x4 && c2.draw(l2, h2.LINES, Pi.disabled, Mi.disabled, e2.colorModeForRenderPass(), zi.disabled, xe(v3, e2.transform, f3), e2.style.map.terrain && e2.style.map.terrain.getTerrainData(m3), s2.id, x4.layoutVertexBuffer, x4.indexBuffer, x4.segments, null, e2.transform.zoom, null, null, x4.collisionVertexBuffer);
          }
          if (!n2 || !u2.length)
            return;
          const p2 = e2.useProgram("collisionCircle"), m2 = new t.aV();
          m2.resize(4 * d2), m2._trim();
          let f2 = 0;
          for (const t4 of u2)
            for (let e3 = 0; e3 < t4.circleArray.length / 4; e3++) {
              const i4 = 4 * e3, s3 = t4.circleArray[i4 + 0], a3 = t4.circleArray[i4 + 1], o3 = t4.circleArray[i4 + 2], r3 = t4.circleArray[i4 + 3];
              m2.emplace(f2++, s3, a3, o3, r3, 0), m2.emplace(f2++, s3, a3, o3, r3, 1), m2.emplace(f2++, s3, a3, o3, r3, 2), m2.emplace(f2++, s3, a3, o3, r3, 3);
            }
          (!Li || Li.length < 2 * d2) && (Li = function(e3) {
            const i4 = 2 * e3, s3 = new t.aX();
            s3.resize(i4), s3._trim();
            for (let t4 = 0; t4 < i4; t4++) {
              const e4 = 6 * t4;
              s3.uint16[e4 + 0] = 4 * t4 + 0, s3.uint16[e4 + 1] = 4 * t4 + 1, s3.uint16[e4 + 2] = 4 * t4 + 2, s3.uint16[e4 + 3] = 4 * t4 + 2, s3.uint16[e4 + 4] = 4 * t4 + 3, s3.uint16[e4 + 5] = 4 * t4 + 0;
            }
            return s3;
          }(d2));
          const g2 = l2.createIndexBuffer(Li, true), v2 = l2.createVertexBuffer(m2, t.aW.members, true);
          for (const i4 of u2) {
            const a3 = { u_matrix: i4.transform, u_inv_matrix: i4.invTransform, u_camera_to_center_distance: (x3 = e2.transform).cameraToCenterDistance, u_viewport_size: [x3.width, x3.height] };
            p2.draw(l2, h2.TRIANGLES, Pi.disabled, Mi.disabled, e2.colorModeForRenderPass(), zi.disabled, a3, e2.style.map.terrain && e2.style.map.terrain.getTerrainData(i4.coord), s2.id, v2, g2, t.S.simpleSegment(0, 2 * i4.circleOffset, i4.circleArray.length, i4.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
          }
          var x3;
          v2.destroy(), g2.destroy();
        }
        zi.disabled = new zi(false, 1029, 2305), zi.backCCW = new zi(true, 1029, 2305);
        const Ri = t.ao(new Float32Array(16));
        function ki(e2, i3, s2, a2, o2, r2) {
          const { horizontalAlign: n2, verticalAlign: l2 } = t.au(e2);
          return new t.P((-(n2 - 0.5) * i3 / o2 + a2[0]) * r2, (-(l2 - 0.5) * s2 / o2 + a2[1]) * r2);
        }
        function Fi(e2, i3, s2, a2, o2, r2, n2, l2, h2, c2, u2) {
          const d2 = e2.text.placedSymbolArray, _2 = e2.text.dynamicLayoutVertexArray, p2 = e2.icon.dynamicLayoutVertexArray, m2 = {};
          _2.clear();
          for (let p3 = 0; p3 < d2.length; p3++) {
            const f2 = d2.get(p3), g2 = f2.hidden || !f2.crossTileID || e2.allowVerticalPlacement && !f2.placedOrientation ? null : a2[f2.crossTileID];
            if (g2) {
              const a3 = new t.P(f2.anchorX, f2.anchorY), d3 = ht(a3, s2 ? n2 : r2, u2), p4 = ct(o2.cameraToCenterDistance, d3.signedDistanceFromCamera);
              let v2 = t.aj(e2.textSizeData, h2, f2) * p4 / t.ap;
              s2 && (v2 *= e2.tilePixelRatio / l2);
              const { width: x3, height: y2, anchor: b2, textOffset: w2, textBoxScale: T3 } = g2, I2 = ki(b2, x3, y2, w2, T3, v2), E3 = s2 ? ht(a3.add(I2), r2, u2).point : d3.point.add(i3 ? I2.rotate(-o2.angle) : I2), S2 = e2.allowVerticalPlacement && f2.placedOrientation === t.ai.vertical ? Math.PI / 2 : 0;
              for (let e3 = 0; e3 < f2.numGlyphs; e3++)
                t.ak(_2, E3, S2);
              c2 && f2.associatedIconIndex >= 0 && (m2[f2.associatedIconIndex] = { shiftedAnchor: E3, angle: S2 });
            } else
              wt(f2.numGlyphs, _2);
          }
          if (c2) {
            p2.clear();
            const i4 = e2.icon.placedSymbolArray;
            for (let e3 = 0; e3 < i4.length; e3++) {
              const s3 = i4.get(e3);
              if (s3.hidden)
                wt(s3.numGlyphs, p2);
              else {
                const i5 = m2[e3];
                if (i5)
                  for (let e4 = 0; e4 < s3.numGlyphs; e4++)
                    t.ak(p2, i5.shiftedAnchor, i5.angle);
                else
                  wt(s3.numGlyphs, p2);
              }
            }
            e2.icon.dynamicLayoutVertexBuffer.updateData(p2);
          }
          e2.text.dynamicLayoutVertexBuffer.updateData(_2);
        }
        function Bi(t4, e2, i3) {
          return i3.iconsInText && e2 ? "symbolTextAndIcon" : t4 ? "symbolSDF" : "symbolIcon";
        }
        function Oi(e2, i3, s2, a2, o2, r2, n2, l2, h2, c2, u2, d2) {
          const _2 = e2.context, p2 = _2.gl, m2 = e2.transform, f2 = "map" === l2, g2 = "map" === h2, v2 = "viewport" !== l2 && "point" !== s2.layout.get("symbol-placement"), x3 = f2 && !g2 && !v2, y2 = !s2.layout.get("symbol-sort-key").isConstant();
          let b2 = false;
          const w2 = e2.depthModeForSublayer(0, Pi.ReadOnly), T3 = s2._unevaluatedLayout.hasValue("text-variable-anchor") || s2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), I2 = [];
          for (const l3 of a2) {
            const a3 = i3.getTile(l3), h3 = a3.getBucket(s2);
            if (!h3)
              continue;
            const u3 = o2 ? h3.text : h3.icon;
            if (!u3 || !u3.segments.get().length || !u3.hasVisibleVertices)
              continue;
            const d3 = u3.programConfigurations.get(s2.id), _3 = o2 || h3.sdfIcons, w3 = o2 ? h3.textSizeData : h3.iconSizeData, E3 = g2 || 0 !== m2.pitch, S2 = e2.useProgram(Bi(_3, o2, h3), d3), C3 = t.ah(w3, m2.zoom), P2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(l3);
            let D3, M2, z2, L3, A3 = [0, 0], R2 = null;
            if (o2)
              M2 = a3.glyphAtlasTexture, z2 = p2.LINEAR, D3 = a3.glyphAtlasTexture.size, h3.iconsInText && (A3 = a3.imageAtlasTexture.size, R2 = a3.imageAtlasTexture, L3 = E3 || e2.options.rotating || e2.options.zooming || "composite" === w3.kind || "camera" === w3.kind ? p2.LINEAR : p2.NEAREST);
            else {
              const t4 = 1 !== s2.layout.get("icon-size").constantOr(0) || h3.iconsNeedLinear;
              M2 = a3.imageAtlasTexture, z2 = _3 || e2.options.rotating || e2.options.zooming || t4 || E3 ? p2.LINEAR : p2.NEAREST, D3 = a3.imageAtlasTexture.size;
            }
            const k2 = St(a3, 1, e2.transform.zoom), F2 = nt(l3.posMatrix, g2, f2, e2.transform, k2), B3 = lt(l3.posMatrix, g2, f2, e2.transform, k2), O2 = T3 && h3.hasTextData(), N2 = "none" !== s2.layout.get("icon-text-fit") && O2 && h3.hasIconData();
            if (v2) {
              const t4 = e2.style.map.terrain ? (t5, i5) => e2.style.map.terrain.getElevation(l3, t5, i5) : null, i4 = "map" === s2.layout.get("text-rotation-alignment");
              dt(h3, l3.posMatrix, e2, o2, F2, B3, g2, c2, i4, t4);
            }
            const U2 = e2.translatePosMatrix(l3.posMatrix, a3, r2, n2), Z2 = v2 || o2 && T3 || N2 ? Ri : F2, G2 = e2.translatePosMatrix(B3, a3, r2, n2, true), j2 = _3 && 0 !== s2.paint.get(o2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
            let V2;
            V2 = _3 ? h3.iconsInText ? Re(w3.kind, C3, x3, g2, e2, U2, Z2, G2, D3, A3) : Ae(w3.kind, C3, x3, g2, e2, U2, Z2, G2, o2, D3, true) : Le(w3.kind, C3, x3, g2, e2, U2, Z2, G2, o2, D3);
            const q2 = { program: S2, buffers: u3, uniformValues: V2, atlasTexture: M2, atlasTextureIcon: R2, atlasInterpolation: z2, atlasInterpolationIcon: L3, isSDF: _3, hasHalo: j2 };
            if (y2 && h3.canOverlap) {
              b2 = true;
              const e3 = u3.segments.get();
              for (const i4 of e3)
                I2.push({ segments: new t.S([i4]), sortKey: i4.sortKey, state: q2, terrainData: P2 });
            } else
              I2.push({ segments: u3.segments, sortKey: 0, state: q2, terrainData: P2 });
          }
          b2 && I2.sort((t4, e3) => t4.sortKey - e3.sortKey);
          for (const t4 of I2) {
            const i4 = t4.state;
            if (_2.activeTexture.set(p2.TEXTURE0), i4.atlasTexture.bind(i4.atlasInterpolation, p2.CLAMP_TO_EDGE), i4.atlasTextureIcon && (_2.activeTexture.set(p2.TEXTURE1), i4.atlasTextureIcon && i4.atlasTextureIcon.bind(i4.atlasInterpolationIcon, p2.CLAMP_TO_EDGE)), i4.isSDF) {
              const a3 = i4.uniformValues;
              i4.hasHalo && (a3.u_is_halo = 1, Ni(i4.buffers, t4.segments, s2, e2, i4.program, w2, u2, d2, a3, t4.terrainData)), a3.u_is_halo = 0;
            }
            Ni(i4.buffers, t4.segments, s2, e2, i4.program, w2, u2, d2, i4.uniformValues, t4.terrainData);
          }
        }
        function Ni(t4, e2, i3, s2, a2, o2, r2, n2, l2, h2) {
          const c2 = s2.context;
          a2.draw(c2, c2.gl.TRIANGLES, o2, r2, n2, zi.disabled, l2, h2, i3.id, t4.layoutVertexBuffer, t4.indexBuffer, e2, i3.paint, s2.transform.zoom, t4.programConfigurations.get(i3.id), t4.dynamicLayoutVertexBuffer, t4.opacityVertexBuffer);
        }
        function Ui(t4, e2, i3, s2, a2) {
          if (!i3 || !s2 || !s2.imageAtlas)
            return;
          const o2 = s2.imageAtlas.patternPositions;
          let r2 = o2[i3.to.toString()], n2 = o2[i3.from.toString()];
          if (!r2 && n2 && (r2 = n2), !n2 && r2 && (n2 = r2), !r2 || !n2) {
            const t5 = a2.getPaintProperty(e2);
            r2 = o2[t5], n2 = o2[t5];
          }
          r2 && n2 && t4.setConstantPatternPositions(r2, n2);
        }
        function Zi(t4, e2, i3, s2, a2, o2, r2) {
          const n2 = t4.context.gl, l2 = "fill-pattern", h2 = i3.paint.get(l2), c2 = h2 && h2.constantOr(1), u2 = i3.getCrossfadeParameters();
          let d2, _2, p2, m2, f2;
          r2 ? (_2 = c2 && !i3.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d2 = n2.LINES) : (_2 = c2 ? "fillPattern" : "fill", d2 = n2.TRIANGLES);
          const g2 = h2.constantOr(null);
          for (const h3 of s2) {
            const s3 = e2.getTile(h3);
            if (c2 && !s3.patternsLoaded())
              continue;
            const v2 = s3.getBucket(i3);
            if (!v2)
              continue;
            const x3 = v2.programConfigurations.get(i3.id), y2 = t4.useProgram(_2, x3), b2 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(h3);
            c2 && (t4.context.activeTexture.set(n2.TEXTURE0), s3.imageAtlasTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), x3.updatePaintBuffers(u2)), Ui(x3, l2, g2, s3, i3);
            const w2 = b2 ? h3 : null, T3 = t4.translatePosMatrix(w2 ? w2.posMatrix : h3.posMatrix, s3, i3.paint.get("fill-translate"), i3.paint.get("fill-translate-anchor"));
            if (r2) {
              m2 = v2.indexBuffer2, f2 = v2.segments2;
              const e3 = [n2.drawingBufferWidth, n2.drawingBufferHeight];
              p2 = "fillOutlinePattern" === _2 && c2 ? ge(T3, t4, u2, s3, e3) : fe(T3, e3);
            } else
              m2 = v2.indexBuffer, f2 = v2.segments, p2 = c2 ? me(T3, t4, u2, s3) : pe(T3);
            y2.draw(t4.context, d2, a2, t4.stencilModeForClipping(h3), o2, zi.disabled, p2, b2, i3.id, v2.layoutVertexBuffer, m2, f2, i3.paint, t4.transform.zoom, x3);
          }
        }
        function Gi(t4, e2, i3, s2, a2, o2, r2) {
          const n2 = t4.context, l2 = n2.gl, h2 = "fill-extrusion-pattern", c2 = i3.paint.get(h2), u2 = c2.constantOr(1), d2 = i3.getCrossfadeParameters(), _2 = i3.paint.get("fill-extrusion-opacity"), p2 = c2.constantOr(null);
          for (const c3 of s2) {
            const s3 = e2.getTile(c3), m2 = s3.getBucket(i3);
            if (!m2)
              continue;
            const f2 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(c3), g2 = m2.programConfigurations.get(i3.id), v2 = t4.useProgram(u2 ? "fillExtrusionPattern" : "fillExtrusion", g2);
            u2 && (t4.context.activeTexture.set(l2.TEXTURE0), s3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), g2.updatePaintBuffers(d2)), Ui(g2, h2, p2, s3, i3);
            const x3 = t4.translatePosMatrix(c3.posMatrix, s3, i3.paint.get("fill-extrusion-translate"), i3.paint.get("fill-extrusion-translate-anchor")), y2 = i3.paint.get("fill-extrusion-vertical-gradient"), b2 = u2 ? _e(x3, t4, y2, _2, c3, d2, s3) : de(x3, t4, y2, _2);
            v2.draw(n2, n2.gl.TRIANGLES, a2, o2, r2, zi.backCCW, b2, f2, i3.id, m2.layoutVertexBuffer, m2.indexBuffer, m2.segments, i3.paint, t4.transform.zoom, g2, t4.style.map.terrain && m2.centroidVertexBuffer);
          }
        }
        function ji(t4, e2, i3, s2, a2, o2, r2) {
          const n2 = t4.context, l2 = n2.gl, h2 = i3.fbo;
          if (!h2)
            return;
          const c2 = t4.useProgram("hillshade"), u2 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(e2);
          n2.activeTexture.set(l2.TEXTURE0), l2.bindTexture(l2.TEXTURE_2D, h2.colorAttachment.get()), c2.draw(n2, l2.TRIANGLES, a2, o2, r2, zi.disabled, ((t5, e3, i4, s3) => {
            const a3 = i4.paint.get("hillshade-shadow-color"), o3 = i4.paint.get("hillshade-highlight-color"), r3 = i4.paint.get("hillshade-accent-color");
            let n3 = i4.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            "viewport" === i4.paint.get("hillshade-illumination-anchor") && (n3 -= t5.transform.angle);
            const l3 = !t5.options.moving;
            return { u_matrix: s3 ? s3.posMatrix : t5.transform.calculatePosMatrix(e3.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: Te(0, e3.tileID), u_light: [i4.paint.get("hillshade-exaggeration"), n3], u_shadow: a3, u_highlight: o3, u_accent: r3 };
          })(t4, i3, s2, u2 ? e2 : null), u2, s2.id, t4.rasterBoundsBuffer, t4.quadTriangleIndexBuffer, t4.rasterBoundsSegments);
        }
        function Vi(e2, i3, s2, a2, o2, r2) {
          const n2 = e2.context, l2 = n2.gl, h2 = i3.dem;
          if (h2 && h2.data) {
            const c2 = h2.dim, u2 = h2.stride, d2 = h2.getPixels();
            if (n2.activeTexture.set(l2.TEXTURE1), n2.pixelStoreUnpackPremultiplyAlpha.set(false), i3.demTexture = i3.demTexture || e2.getTileTexture(u2), i3.demTexture) {
              const t4 = i3.demTexture;
              t4.update(d2, { premultiply: false }), t4.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
            } else
              i3.demTexture = new x2(n2, d2, l2.RGBA, { premultiply: false }), i3.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
            n2.activeTexture.set(l2.TEXTURE0);
            let _2 = i3.fbo;
            if (!_2) {
              const t4 = new x2(n2, { width: c2, height: c2, data: null }, l2.RGBA);
              t4.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), _2 = i3.fbo = n2.createFramebuffer(c2, c2, true, false), _2.colorAttachment.set(t4.texture);
            }
            n2.bindFramebuffer.set(_2.framebuffer), n2.viewport.set([0, 0, c2, c2]), e2.useProgram("hillshadePrepare").draw(n2, l2.TRIANGLES, a2, o2, r2, zi.disabled, ((e3, i4) => {
              const s3 = i4.stride, a3 = t.Z();
              return t.aS(a3, 0, t.N, -t.N, 0, 0, 1), t.$(a3, a3, [0, -t.N, 0]), { u_matrix: a3, u_image: 1, u_dimension: [s3, s3], u_zoom: e3.overscaledZ, u_unpack: i4.getUnpackVector() };
            })(i3.tileID, h2), null, s2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments), i3.needsHillshadePrepare = false;
          }
        }
        function qi(e2, i3, s2, a2, o2, r2) {
          const n2 = a2.paint.get("raster-fade-duration");
          if (!r2 && n2 > 0) {
            const a3 = t.h.now(), r3 = (a3 - e2.timeAdded) / n2, l2 = i3 ? (a3 - i3.timeAdded) / n2 : -1, h2 = s2.getSource(), c2 = o2.coveringZoomLevel({ tileSize: h2.tileSize, roundZoom: h2.roundZoom }), u2 = !i3 || Math.abs(i3.tileID.overscaledZ - c2) > Math.abs(e2.tileID.overscaledZ - c2), d2 = u2 && e2.refreshedUponExpiration ? 1 : t.ad(u2 ? r3 : 1 - l2, 0, 1);
            return e2.refreshedUponExpiration && r3 >= 1 && (e2.refreshedUponExpiration = false), i3 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const $i = new t.aT(1, 0, 0, 1), Wi = new t.aT(0, 1, 0, 1), Hi = new t.aT(0, 0, 1, 1), Xi = new t.aT(1, 0, 1, 1), Ki = new t.aT(0, 1, 1, 1);
        function Qi(t4, e2, i3, s2) {
          Ji(t4, 0, e2 + i3 / 2, t4.transform.width, i3, s2);
        }
        function Yi(t4, e2, i3, s2) {
          Ji(t4, e2 - i3 / 2, 0, i3, t4.transform.height, s2);
        }
        function Ji(t4, e2, i3, s2, a2, o2) {
          const r2 = t4.context, n2 = r2.gl;
          n2.enable(n2.SCISSOR_TEST), n2.scissor(e2 * t4.pixelRatio, i3 * t4.pixelRatio, s2 * t4.pixelRatio, a2 * t4.pixelRatio), r2.clear({ color: o2 }), n2.disable(n2.SCISSOR_TEST);
        }
        function ts(e2, i3, s2) {
          const a2 = e2.context, o2 = a2.gl, r2 = s2.posMatrix, n2 = e2.useProgram("debug"), l2 = Pi.disabled, h2 = Mi.disabled, c2 = e2.colorModeForRenderPass(), u2 = "$debug", d2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(s2);
          a2.activeTexture.set(o2.TEXTURE0);
          const _2 = i3.getTileByID(s2.key).latestRawTileData, p2 = Math.floor((_2 && _2.byteLength || 0) / 1024), m2 = i3.getTile(s2).tileSize, f2 = 512 / Math.min(m2, 512) * (s2.overscaledZ / e2.transform.zoom) * 0.5;
          let g2 = s2.canonical.toString();
          s2.overscaledZ !== s2.canonical.z && (g2 += ` => ${s2.overscaledZ}`), function(t4, e3) {
            t4.initDebugOverlayCanvas();
            const i4 = t4.debugOverlayCanvas, s3 = t4.context.gl, a3 = t4.debugOverlayCanvas.getContext("2d");
            a3.clearRect(0, 0, i4.width, i4.height), a3.shadowColor = "white", a3.shadowBlur = 2, a3.lineWidth = 1.5, a3.strokeStyle = "white", a3.textBaseline = "top", a3.font = "bold 36px Open Sans, sans-serif", a3.fillText(e3, 5, 5), a3.strokeText(e3, 5, 5), t4.debugOverlayTexture.update(i4), t4.debugOverlayTexture.bind(s3.LINEAR, s3.CLAMP_TO_EDGE);
          }(e2, `${g2} ${p2}kB`), n2.draw(a2, o2.TRIANGLES, l2, h2, Si.alphaBlended, zi.disabled, ye(r2, t.aT.transparent, f2), null, u2, e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments), n2.draw(a2, o2.LINE_STRIP, l2, h2, c2, zi.disabled, ye(r2, t.aT.red), d2, u2, e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
        }
        function es(t4, e2, i3) {
          const s2 = t4.context, a2 = s2.gl, o2 = t4.colorModeForRenderPass(), r2 = new Pi(a2.LEQUAL, Pi.ReadWrite, t4.depthRangeFor3D), n2 = t4.useProgram("terrain"), l2 = e2.getTerrainMesh();
          s2.bindFramebuffer.set(null), s2.viewport.set([0, 0, t4.width, t4.height]);
          for (const h2 of i3) {
            const i4 = t4.renderToTexture.getTexture(h2), c2 = e2.getTerrainData(h2.tileID);
            s2.activeTexture.set(a2.TEXTURE0), a2.bindTexture(a2.TEXTURE_2D, i4.texture);
            const u2 = { u_matrix: t4.transform.calculatePosMatrix(h2.tileID.toUnwrapped()), u_texture: 0, u_ele_delta: e2.getMeshFrameDelta(t4.transform.zoom) };
            n2.draw(s2, a2.TRIANGLES, r2, Mi.disabled, o2, zi.backCCW, u2, c2, "terrain", l2.vertexBuffer, l2.indexBuffer, l2.segments);
          }
        }
        class is {
          constructor(e2, i3) {
            this.context = new Ci(e2), this.transform = i3, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t.Z(), renderTime: 0 }, this.setup(), this.numSublayers = K2.maxUnderzooming + K2.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Yt();
          }
          resize(t4, e2, i3) {
            if (this.width = Math.floor(t4 * i3), this.height = Math.floor(e2 * i3), this.pixelRatio = i3, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const t5 of this.style._order)
                this.style._layers[t5].resize();
          }
          setup() {
            const e2 = this.context, i3 = new t.a_();
            i3.emplaceBack(0, 0), i3.emplaceBack(t.N, 0), i3.emplaceBack(0, t.N), i3.emplaceBack(t.N, t.N), this.tileExtentBuffer = e2.createVertexBuffer(i3, ae.members), this.tileExtentSegments = t.S.simpleSegment(0, 0, 4, 2);
            const s2 = new t.a_();
            s2.emplaceBack(0, 0), s2.emplaceBack(t.N, 0), s2.emplaceBack(0, t.N), s2.emplaceBack(t.N, t.N), this.debugBuffer = e2.createVertexBuffer(s2, ae.members), this.debugSegments = t.S.simpleSegment(0, 0, 4, 5);
            const a2 = new t.V();
            a2.emplaceBack(0, 0, 0, 0), a2.emplaceBack(t.N, 0, t.N, 0), a2.emplaceBack(0, t.N, 0, t.N), a2.emplaceBack(t.N, t.N, t.N, t.N), this.rasterBoundsBuffer = e2.createVertexBuffer(a2, O.members), this.rasterBoundsSegments = t.S.simpleSegment(0, 0, 4, 2);
            const o2 = new t.a_();
            o2.emplaceBack(0, 0), o2.emplaceBack(1, 0), o2.emplaceBack(0, 1), o2.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(o2, ae.members), this.viewportSegments = t.S.simpleSegment(0, 0, 4, 2);
            const r2 = new t.a$();
            r2.emplaceBack(0), r2.emplaceBack(1), r2.emplaceBack(3), r2.emplaceBack(2), r2.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(r2);
            const n2 = new t.b0();
            n2.emplaceBack(0, 1, 2), n2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(n2);
            const l2 = this.context.gl;
            this.stencilClearMode = new Mi({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO);
          }
          clearStencil() {
            const e2 = this.context, i3 = e2.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const s2 = t.Z();
            t.aS(s2, 0, this.width, this.height, 0, 0, 1), t.a0(s2, s2, [i3.drawingBufferWidth, i3.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e2, i3.TRIANGLES, Pi.disabled, this.stencilClearMode, Si.disabled, zi.disabled, be(s2), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(t4, e2) {
            if (this.currentStencilSource === t4.source || !t4.isTileClipped() || !e2 || !e2.length)
              return;
            this.currentStencilSource = t4.source;
            const i3 = this.context, s2 = i3.gl;
            this.nextStencilID + e2.length > 256 && this.clearStencil(), i3.setColorMode(Si.disabled), i3.setDepthMode(Pi.disabled);
            const a2 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const t5 of e2) {
              const e3 = this._tileClippingMaskIDs[t5.key] = this.nextStencilID++, o2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(t5);
              a2.draw(i3, s2.TRIANGLES, Pi.disabled, new Mi({ func: s2.ALWAYS, mask: 0 }, e3, 255, s2.KEEP, s2.KEEP, s2.REPLACE), Si.disabled, zi.disabled, be(t5.posMatrix), o2, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t4 = this.nextStencilID++, e2 = this.context.gl;
            return new Mi({ func: e2.NOTEQUAL, mask: 255 }, t4, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
          }
          stencilModeForClipping(t4) {
            const e2 = this.context.gl;
            return new Mi({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t4.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
          }
          stencilConfigForOverlap(t4) {
            const e2 = this.context.gl, i3 = t4.sort((t5, e3) => e3.overscaledZ - t5.overscaledZ), s2 = i3[i3.length - 1].overscaledZ, a2 = i3[0].overscaledZ - s2 + 1;
            if (a2 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + a2 > 256 && this.clearStencil();
              const t5 = {};
              for (let i4 = 0; i4 < a2; i4++)
                t5[i4 + s2] = new Mi({ func: e2.GEQUAL, mask: 255 }, i4 + this.nextStencilID, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
              return this.nextStencilID += a2, [t5, i3];
            }
            return [{ [s2]: Mi.disabled }, i3];
          }
          colorModeForRenderPass() {
            const e2 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i3 = 1 / 8;
              return new Si([e2.CONSTANT_COLOR, e2.ONE], new t.aT(i3, i3, i3, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? Si.unblended : Si.alphaBlended;
          }
          depthModeForSublayer(t4, e2, i3) {
            if (!this.opaquePassEnabledForLayer())
              return Pi.disabled;
            const s2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t4) * this.depthEpsilon;
            return new Pi(i3 || this.context.gl.LEQUAL, e2, [s2, s2]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e2, i3) {
            this.style = e2, this.options = i3, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(t.h.now()), this.imageManager.beginFrame();
            const s2 = this.style._order, a2 = this.style.sourceCaches, o2 = {}, r2 = {}, n2 = {};
            for (const t4 in a2) {
              const e3 = a2[t4];
              e3.used && e3.prepare(this.context), o2[t4] = e3.getVisibleCoordinates(), r2[t4] = o2[t4].slice().reverse(), n2[t4] = e3.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let t4 = 0; t4 < s2.length; t4++)
              if (this.style._layers[s2[t4]].is3D()) {
                this.opaquePassCutoff = t4;
                break;
              }
            if (this.renderToTexture) {
              this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0;
              const e3 = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
              (this.terrainFacilitator.dirty || !t.b1(this.terrainFacilitator.matrix, this.transform.projMatrix) || e3.length) && (t.b2(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(e4, i4) {
                const s3 = e4.context, a3 = s3.gl, o3 = Si.unblended, r3 = new Pi(a3.LEQUAL, Pi.ReadWrite, [0, 1]), n3 = i4.getTerrainMesh(), l2 = i4.sourceCache.getRenderableTiles(), h2 = e4.useProgram("terrainDepth");
                s3.bindFramebuffer.set(i4.getFramebuffer("depth").framebuffer), s3.viewport.set([0, 0, e4.width / devicePixelRatio, e4.height / devicePixelRatio]), s3.clear({ color: t.aT.transparent, depth: 1 });
                for (const t4 of l2) {
                  const l3 = i4.getTerrainData(t4.tileID), c2 = { u_matrix: e4.transform.calculatePosMatrix(t4.tileID.toUnwrapped()), u_ele_delta: i4.getMeshFrameDelta(e4.transform.zoom) };
                  h2.draw(s3, a3.TRIANGLES, r3, Mi.disabled, o3, zi.backCCW, c2, l3, "terrain", n3.vertexBuffer, n3.indexBuffer, n3.segments);
                }
                s3.bindFramebuffer.set(null), s3.viewport.set([0, 0, e4.width, e4.height]);
              }(this, this.style.map.terrain), function(e4, i4) {
                const s3 = e4.context, a3 = s3.gl, o3 = Si.unblended, r3 = new Pi(a3.LEQUAL, Pi.ReadWrite, [0, 1]), n3 = i4.getTerrainMesh(), l2 = i4.getCoordsTexture(), h2 = i4.sourceCache.getRenderableTiles(), c2 = e4.useProgram("terrainCoords");
                s3.bindFramebuffer.set(i4.getFramebuffer("coords").framebuffer), s3.viewport.set([0, 0, e4.width / devicePixelRatio, e4.height / devicePixelRatio]), s3.clear({ color: t.aT.transparent, depth: 1 }), i4.coordsIndex = [];
                for (const t4 of h2) {
                  const h3 = i4.getTerrainData(t4.tileID);
                  s3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, l2.texture);
                  const u2 = { u_matrix: e4.transform.calculatePosMatrix(t4.tileID.toUnwrapped()), u_terrain_coords_id: (255 - i4.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i4.getMeshFrameDelta(e4.transform.zoom) };
                  c2.draw(s3, a3.TRIANGLES, r3, Mi.disabled, o3, zi.backCCW, u2, h3, "terrain", n3.vertexBuffer, n3.indexBuffer, n3.segments), i4.coordsIndex.push(t4.tileID.key);
                }
                s3.bindFramebuffer.set(null), s3.viewport.set([0, 0, e4.width, e4.height]);
              }(this, this.style.map.terrain));
            }
            this.renderPass = "offscreen";
            for (const t4 of s2) {
              const e3 = this.style._layers[t4];
              if (!e3.hasOffscreenPass() || e3.isHidden(this.transform.zoom))
                continue;
              const i4 = r2[e3.source];
              ("custom" === e3.type || i4.length) && this.renderLayer(this, a2[e3.source], e3, i4);
            }
            if (this.context.bindFramebuffer.set(null), this.context.clear({ color: i3.showOverdrawInspector ? t.aT.black : t.aT.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i3.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
              for (this.renderPass = "opaque", this.currentLayer = s2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const t4 = this.style._layers[s2[this.currentLayer]], e3 = a2[t4.source], i4 = o2[t4.source];
                this._renderTileClippingMasks(t4, i4), this.renderLayer(this, e3, t4, i4);
              }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < s2.length; this.currentLayer++) {
              const t4 = this.style._layers[s2[this.currentLayer]], e3 = a2[t4.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(t4))
                continue;
              const i4 = ("symbol" === t4.type ? n2 : r2)[t4.source];
              this._renderTileClippingMasks(t4, o2[t4.source]), this.renderLayer(this, e3, t4, i4);
            }
            if (this.options.showTileBoundaries) {
              const t4 = function(t5, e3) {
                let i4 = null;
                const s3 = Object.values(t5._layers).flatMap((i5) => i5.source && !i5.isHidden(e3) ? [t5.sourceCaches[i5.source]] : []), a3 = s3.filter((t6) => "vector" === t6.getSource().type), o3 = s3.filter((t6) => "vector" !== t6.getSource().type), r3 = (t6) => {
                  (!i4 || i4.getSource().maxzoom < t6.getSource().maxzoom) && (i4 = t6);
                };
                return a3.forEach((t6) => r3(t6)), i4 || o3.forEach((t6) => r3(t6)), i4;
              }(this.style, this.transform.zoom);
              t4 && function(t5, e3, i4) {
                for (let s3 = 0; s3 < i4.length; s3++)
                  ts(t5, e3, i4[s3]);
              }(this, t4, t4.getVisibleCoordinates());
            }
            this.options.showPadding && function(t4) {
              const e3 = t4.transform.padding;
              Qi(t4, t4.transform.height - (e3.top || 0), 3, $i), Qi(t4, e3.bottom || 0, 3, Wi), Yi(t4, e3.left || 0, 3, Hi), Yi(t4, t4.transform.width - (e3.right || 0), 3, Xi);
              const i4 = t4.transform.centerPoint;
              !function(t5, e4, i5, s3) {
                Ji(t5, e4 - 1, i5 - 10, 2, 20, s3), Ji(t5, e4 - 10, i5 - 1, 20, 2, s3);
              }(t4, i4.x, t4.transform.height - i4.y, Ki);
            }(this), this.context.setDefault();
          }
          renderLayer(e2, i3, s2, a2) {
            if (!s2.isHidden(this.transform.zoom) && ("background" === s2.type || "custom" === s2.type || (a2 || []).length))
              switch (this.id = s2.id, s2.type) {
                case "symbol":
                  !function(e3, i4, s3, a3, o2) {
                    if ("translucent" !== e3.renderPass)
                      return;
                    const r2 = Mi.disabled, n2 = e3.colorModeForRenderPass();
                    (s3._unevaluatedLayout.hasValue("text-variable-anchor") || s3._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e4, i5, s4, a4, o3, r3, n3) {
                      const l2 = i5.transform, h2 = "map" === o3, c2 = "map" === r3;
                      for (const o4 of e4) {
                        const e5 = a4.getTile(o4), r4 = e5.getBucket(s4);
                        if (!r4 || !r4.text || !r4.text.segments.get().length)
                          continue;
                        const u2 = t.ah(r4.textSizeData, l2.zoom), d2 = St(e5, 1, i5.transform.zoom), _2 = nt(o4.posMatrix, c2, h2, i5.transform, d2), p2 = "none" !== s4.layout.get("icon-text-fit") && r4.hasIconData();
                        if (u2) {
                          const t4 = Math.pow(2, l2.zoom - e5.tileID.overscaledZ);
                          Fi(r4, h2, c2, n3, l2, _2, o4.posMatrix, t4, u2, p2, i5.style.map.terrain ? (t5, e6) => i5.style.map.terrain.getElevation(o4, t5, e6) : null);
                        }
                      }
                    }(a3, e3, s3, i4, s3.layout.get("text-rotation-alignment"), s3.layout.get("text-pitch-alignment"), o2), 0 !== s3.paint.get("icon-opacity").constantOr(1) && Oi(e3, i4, s3, a3, false, s3.paint.get("icon-translate"), s3.paint.get("icon-translate-anchor"), s3.layout.get("icon-rotation-alignment"), s3.layout.get("icon-pitch-alignment"), s3.layout.get("icon-keep-upright"), r2, n2), 0 !== s3.paint.get("text-opacity").constantOr(1) && Oi(e3, i4, s3, a3, true, s3.paint.get("text-translate"), s3.paint.get("text-translate-anchor"), s3.layout.get("text-rotation-alignment"), s3.layout.get("text-pitch-alignment"), s3.layout.get("text-keep-upright"), r2, n2), i4.map.showCollisionBoxes && (Ai(e3, i4, s3, a3, s3.paint.get("text-translate"), s3.paint.get("text-translate-anchor"), true), Ai(e3, i4, s3, a3, s3.paint.get("icon-translate"), s3.paint.get("icon-translate-anchor"), false));
                  }(e2, i3, s2, a2, this.style.placement.variableOffsets);
                  break;
                case "circle":
                  !function(e3, i4, s3, a3) {
                    if ("translucent" !== e3.renderPass)
                      return;
                    const o2 = s3.paint.get("circle-opacity"), r2 = s3.paint.get("circle-stroke-width"), n2 = s3.paint.get("circle-stroke-opacity"), l2 = !s3.layout.get("circle-sort-key").isConstant();
                    if (0 === o2.constantOr(1) && (0 === r2.constantOr(1) || 0 === n2.constantOr(1)))
                      return;
                    const h2 = e3.context, c2 = h2.gl, u2 = e3.depthModeForSublayer(0, Pi.ReadOnly), d2 = Mi.disabled, _2 = e3.colorModeForRenderPass(), p2 = [];
                    for (let o3 = 0; o3 < a3.length; o3++) {
                      const r3 = a3[o3], n3 = i4.getTile(r3), h3 = n3.getBucket(s3);
                      if (!h3)
                        continue;
                      const c3 = h3.programConfigurations.get(s3.id), u3 = e3.useProgram("circle", c3), d3 = h3.layoutVertexBuffer, _3 = h3.indexBuffer, m2 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(r3), f2 = { programConfiguration: c3, program: u3, layoutVertexBuffer: d3, indexBuffer: _3, uniformValues: ve(e3, r3, n3, s3), terrainData: m2 };
                      if (l2) {
                        const e4 = h3.segments.get();
                        for (const i5 of e4)
                          p2.push({ segments: new t.S([i5]), sortKey: i5.sortKey, state: f2 });
                      } else
                        p2.push({ segments: h3.segments, sortKey: 0, state: f2 });
                    }
                    l2 && p2.sort((t4, e4) => t4.sortKey - e4.sortKey);
                    for (const t4 of p2) {
                      const { programConfiguration: i5, program: a4, layoutVertexBuffer: o3, indexBuffer: r3, uniformValues: n3, terrainData: l3 } = t4.state;
                      a4.draw(h2, c2.TRIANGLES, u2, d2, _2, zi.disabled, n3, l3, s3.id, o3, r3, t4.segments, s3.paint, e3.transform.zoom, i5);
                    }
                  }(e2, i3, s2, a2);
                  break;
                case "heatmap":
                  !function(e3, i4, s3, a3) {
                    if (0 !== s3.paint.get("heatmap-opacity"))
                      if ("offscreen" === e3.renderPass) {
                        const o2 = e3.context, r2 = o2.gl, n2 = Mi.disabled, l2 = new Si([r2.ONE, r2.ONE], t.aT.transparent, [true, true, true, true]);
                        !function(t4, e4, i5) {
                          const s4 = t4.gl;
                          t4.activeTexture.set(s4.TEXTURE1), t4.viewport.set([0, 0, e4.width / 4, e4.height / 4]);
                          let a4 = i5.heatmapFbo;
                          if (a4)
                            s4.bindTexture(s4.TEXTURE_2D, a4.colorAttachment.get()), t4.bindFramebuffer.set(a4.framebuffer);
                          else {
                            const o3 = s4.createTexture();
                            s4.bindTexture(s4.TEXTURE_2D, o3), s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_WRAP_S, s4.CLAMP_TO_EDGE), s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_WRAP_T, s4.CLAMP_TO_EDGE), s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_MIN_FILTER, s4.LINEAR), s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_MAG_FILTER, s4.LINEAR), a4 = i5.heatmapFbo = t4.createFramebuffer(e4.width / 4, e4.height / 4, false, false), function(t5, e5, i6, s5) {
                              var a5, o4;
                              const r3 = t5.gl, n3 = null !== (a5 = t5.HALF_FLOAT) && void 0 !== a5 ? a5 : r3.UNSIGNED_BYTE, l3 = null !== (o4 = t5.RGBA16F) && void 0 !== o4 ? o4 : r3.RGBA;
                              r3.texImage2D(r3.TEXTURE_2D, 0, l3, e5.width / 4, e5.height / 4, 0, r3.RGBA, n3, null), s5.colorAttachment.set(i6);
                            }(t4, e4, o3, a4);
                          }
                        }(o2, e3, s3), o2.clear({ color: t.aT.transparent });
                        for (let t4 = 0; t4 < a3.length; t4++) {
                          const h2 = a3[t4];
                          if (i4.hasRenderableParent(h2))
                            continue;
                          const c2 = i4.getTile(h2), u2 = c2.getBucket(s3);
                          if (!u2)
                            continue;
                          const d2 = u2.programConfigurations.get(s3.id), _2 = e3.useProgram("heatmap", d2), { zoom: p2 } = e3.transform;
                          _2.draw(o2, r2.TRIANGLES, Pi.disabled, n2, l2, zi.disabled, we(h2.posMatrix, c2, p2, s3.paint.get("heatmap-intensity")), null, s3.id, u2.layoutVertexBuffer, u2.indexBuffer, u2.segments, s3.paint, e3.transform.zoom, d2);
                        }
                        o2.viewport.set([0, 0, e3.width, e3.height]);
                      } else
                        "translucent" === e3.renderPass && (e3.context.setColorMode(e3.colorModeForRenderPass()), function(e4, i5) {
                          const s4 = e4.context, a4 = s4.gl, o2 = i5.heatmapFbo;
                          if (!o2)
                            return;
                          s4.activeTexture.set(a4.TEXTURE0), a4.bindTexture(a4.TEXTURE_2D, o2.colorAttachment.get()), s4.activeTexture.set(a4.TEXTURE1);
                          let r2 = i5.colorRampTexture;
                          r2 || (r2 = i5.colorRampTexture = new x2(s4, i5.colorRamp, a4.RGBA)), r2.bind(a4.LINEAR, a4.CLAMP_TO_EDGE), e4.useProgram("heatmapTexture").draw(s4, a4.TRIANGLES, Pi.disabled, Mi.disabled, e4.colorModeForRenderPass(), zi.disabled, ((e5, i6, s5, a5) => {
                            const o3 = t.Z();
                            t.aS(o3, 0, e5.width, e5.height, 0, 0, 1);
                            const r3 = e5.context.gl;
                            return { u_matrix: o3, u_world: [r3.drawingBufferWidth, r3.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i6.paint.get("heatmap-opacity") };
                          })(e4, i5), null, i5.id, e4.viewportBuffer, e4.quadTriangleIndexBuffer, e4.viewportSegments, i5.paint, e4.transform.zoom);
                        }(e3, s3));
                  }(e2, i3, s2, a2);
                  break;
                case "line":
                  !function(e3, i4, s3, a3) {
                    if ("translucent" !== e3.renderPass)
                      return;
                    const o2 = s3.paint.get("line-opacity"), r2 = s3.paint.get("line-width");
                    if (0 === o2.constantOr(1) || 0 === r2.constantOr(1))
                      return;
                    const n2 = e3.depthModeForSublayer(0, Pi.ReadOnly), l2 = e3.colorModeForRenderPass(), h2 = s3.paint.get("line-dasharray"), c2 = s3.paint.get("line-pattern"), u2 = c2.constantOr(1), d2 = s3.paint.get("line-gradient"), _2 = s3.getCrossfadeParameters(), p2 = u2 ? "linePattern" : h2 ? "lineSDF" : d2 ? "lineGradient" : "line", m2 = e3.context, f2 = m2.gl;
                    let g2 = true;
                    for (const o3 of a3) {
                      const a4 = i4.getTile(o3);
                      if (u2 && !a4.patternsLoaded())
                        continue;
                      const r3 = a4.getBucket(s3);
                      if (!r3)
                        continue;
                      const v2 = r3.programConfigurations.get(s3.id), y2 = e3.context.program.get(), b2 = e3.useProgram(p2, v2), w2 = g2 || b2.program !== y2, T3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(o3), I2 = c2.constantOr(null);
                      if (I2 && a4.imageAtlas) {
                        const t4 = a4.imageAtlas, e4 = t4.patternPositions[I2.to.toString()], i5 = t4.patternPositions[I2.from.toString()];
                        e4 && i5 && v2.setConstantPatternPositions(e4, i5);
                      }
                      const E3 = T3 ? o3 : null, S2 = u2 ? Se(e3, a4, s3, _2, E3) : h2 ? Ce(e3, a4, s3, h2, _2, E3) : d2 ? Ee(e3, a4, s3, r3.lineClipsArray.length, E3) : Ie(e3, a4, s3, E3);
                      if (u2)
                        m2.activeTexture.set(f2.TEXTURE0), a4.imageAtlasTexture.bind(f2.LINEAR, f2.CLAMP_TO_EDGE), v2.updatePaintBuffers(_2);
                      else if (h2 && (w2 || e3.lineAtlas.dirty))
                        m2.activeTexture.set(f2.TEXTURE0), e3.lineAtlas.bind(m2);
                      else if (d2) {
                        const a5 = r3.gradients[s3.id];
                        let n3 = a5.texture;
                        if (s3.gradientVersion !== a5.version) {
                          let l3 = 256;
                          if (s3.stepInterpolant) {
                            const s4 = i4.getSource().maxzoom, a6 = o3.canonical.z === s4 ? Math.ceil(1 << e3.transform.maxZoom - o3.canonical.z) : 1;
                            l3 = t.ad(t.aY(r3.maxLineLength / t.N * 1024 * a6), 256, m2.maxTextureSize);
                          }
                          a5.gradient = t.aZ({ expression: s3.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: a5.gradient || void 0, clips: r3.lineClipsArray }), a5.texture ? a5.texture.update(a5.gradient) : a5.texture = new x2(m2, a5.gradient, f2.RGBA), a5.version = s3.gradientVersion, n3 = a5.texture;
                        }
                        m2.activeTexture.set(f2.TEXTURE0), n3.bind(s3.stepInterpolant ? f2.NEAREST : f2.LINEAR, f2.CLAMP_TO_EDGE);
                      }
                      b2.draw(m2, f2.TRIANGLES, n2, e3.stencilModeForClipping(o3), l2, zi.disabled, S2, T3, s3.id, r3.layoutVertexBuffer, r3.indexBuffer, r3.segments, s3.paint, e3.transform.zoom, v2, r3.layoutVertexBuffer2), g2 = false;
                    }
                  }(e2, i3, s2, a2);
                  break;
                case "fill":
                  !function(e3, i4, s3, a3) {
                    const o2 = s3.paint.get("fill-color"), r2 = s3.paint.get("fill-opacity");
                    if (0 === r2.constantOr(1))
                      return;
                    const n2 = e3.colorModeForRenderPass(), l2 = s3.paint.get("fill-pattern"), h2 = e3.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === o2.constantOr(t.aT.transparent).a && 1 === r2.constantOr(0) ? "opaque" : "translucent";
                    if (e3.renderPass === h2) {
                      const t4 = e3.depthModeForSublayer(1, "opaque" === e3.renderPass ? Pi.ReadWrite : Pi.ReadOnly);
                      Zi(e3, i4, s3, a3, t4, n2, false);
                    }
                    if ("translucent" === e3.renderPass && s3.paint.get("fill-antialias")) {
                      const t4 = e3.depthModeForSublayer(s3.getPaintProperty("fill-outline-color") ? 2 : 0, Pi.ReadOnly);
                      Zi(e3, i4, s3, a3, t4, n2, true);
                    }
                  }(e2, i3, s2, a2);
                  break;
                case "fill-extrusion":
                  !function(t4, e3, i4, s3) {
                    const a3 = i4.paint.get("fill-extrusion-opacity");
                    if (0 !== a3 && "translucent" === t4.renderPass) {
                      const o2 = new Pi(t4.context.gl.LEQUAL, Pi.ReadWrite, t4.depthRangeFor3D);
                      if (1 !== a3 || i4.paint.get("fill-extrusion-pattern").constantOr(1))
                        Gi(t4, e3, i4, s3, o2, Mi.disabled, Si.disabled), Gi(t4, e3, i4, s3, o2, t4.stencilModeFor3D(), t4.colorModeForRenderPass());
                      else {
                        const a4 = t4.colorModeForRenderPass();
                        Gi(t4, e3, i4, s3, o2, Mi.disabled, a4);
                      }
                    }
                  }(e2, i3, s2, a2);
                  break;
                case "hillshade":
                  !function(t4, e3, i4, s3) {
                    if ("offscreen" !== t4.renderPass && "translucent" !== t4.renderPass)
                      return;
                    const a3 = t4.context, o2 = t4.depthModeForSublayer(0, Pi.ReadOnly), r2 = t4.colorModeForRenderPass(), [n2, l2] = "translucent" === t4.renderPass ? t4.stencilConfigForOverlap(s3) : [{}, s3];
                    for (const s4 of l2) {
                      const a4 = e3.getTile(s4);
                      void 0 !== a4.needsHillshadePrepare && a4.needsHillshadePrepare && "offscreen" === t4.renderPass ? Vi(t4, a4, i4, o2, Mi.disabled, r2) : "translucent" === t4.renderPass && ji(t4, s4, a4, i4, o2, n2[s4.overscaledZ], r2);
                    }
                    a3.viewport.set([0, 0, t4.width, t4.height]);
                  }(e2, i3, s2, a2);
                  break;
                case "raster":
                  !function(t4, e3, i4, s3) {
                    if ("translucent" !== t4.renderPass)
                      return;
                    if (0 === i4.paint.get("raster-opacity"))
                      return;
                    if (!s3.length)
                      return;
                    const a3 = t4.context, o2 = a3.gl, r2 = e3.getSource(), n2 = t4.useProgram("raster"), l2 = t4.colorModeForRenderPass(), [h2, c2] = r2 instanceof N ? [{}, s3] : t4.stencilConfigForOverlap(s3), u2 = c2[c2.length - 1].overscaledZ, d2 = !t4.options.moving;
                    for (const s4 of c2) {
                      const c3 = t4.depthModeForSublayer(s4.overscaledZ - u2, 1 === i4.paint.get("raster-opacity") ? Pi.ReadWrite : Pi.ReadOnly, o2.LESS), _2 = e3.getTile(s4);
                      _2.registerFadeDuration(i4.paint.get("raster-fade-duration"));
                      const p2 = e3.findLoadedParent(s4, 0), m2 = qi(_2, p2, e3, i4, t4.transform, t4.style.map.terrain);
                      let f2, g2;
                      const v2 = "nearest" === i4.paint.get("raster-resampling") ? o2.NEAREST : o2.LINEAR;
                      a3.activeTexture.set(o2.TEXTURE0), _2.texture.bind(v2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), a3.activeTexture.set(o2.TEXTURE1), p2 ? (p2.texture.bind(v2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), f2 = Math.pow(2, p2.tileID.overscaledZ - _2.tileID.overscaledZ), g2 = [_2.tileID.canonical.x * f2 % 1, _2.tileID.canonical.y * f2 % 1]) : _2.texture.bind(v2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST);
                      const x3 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(s4), y2 = x3 ? s4 : null, b2 = y2 ? y2.posMatrix : t4.transform.calculatePosMatrix(s4.toUnwrapped(), d2), w2 = Me(b2, g2 || [0, 0], f2 || 1, m2, i4);
                      r2 instanceof N ? n2.draw(a3, o2.TRIANGLES, c3, Mi.disabled, l2, zi.disabled, w2, x3, i4.id, r2.boundsBuffer, t4.quadTriangleIndexBuffer, r2.boundsSegments) : n2.draw(a3, o2.TRIANGLES, c3, h2[s4.overscaledZ], l2, zi.disabled, w2, x3, i4.id, t4.rasterBoundsBuffer, t4.quadTriangleIndexBuffer, t4.rasterBoundsSegments);
                    }
                  }(e2, i3, s2, a2);
                  break;
                case "background":
                  !function(t4, e3, i4, s3) {
                    const a3 = i4.paint.get("background-color"), o2 = i4.paint.get("background-opacity");
                    if (0 === o2)
                      return;
                    const r2 = t4.context, n2 = r2.gl, l2 = t4.transform, h2 = l2.tileSize, c2 = i4.paint.get("background-pattern");
                    if (t4.isPatternMissing(c2))
                      return;
                    const u2 = !c2 && 1 === a3.a && 1 === o2 && t4.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                    if (t4.renderPass !== u2)
                      return;
                    const d2 = Mi.disabled, _2 = t4.depthModeForSublayer(0, "opaque" === u2 ? Pi.ReadWrite : Pi.ReadOnly), p2 = t4.colorModeForRenderPass(), m2 = t4.useProgram(c2 ? "backgroundPattern" : "background"), f2 = s3 || l2.coveringTiles({ tileSize: h2, terrain: t4.style.map.terrain });
                    c2 && (r2.activeTexture.set(n2.TEXTURE0), t4.imageManager.bind(t4.context));
                    const g2 = i4.getCrossfadeParameters();
                    for (const e4 of f2) {
                      const l3 = s3 ? e4.posMatrix : t4.transform.calculatePosMatrix(e4.toUnwrapped()), u3 = c2 ? Fe(l3, o2, t4, c2, { tileID: e4, tileSize: h2 }, g2) : ke(l3, o2, a3), f3 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(e4);
                      m2.draw(r2, n2.TRIANGLES, _2, d2, p2, zi.disabled, u3, f3, i4.id, t4.tileExtentBuffer, t4.quadTriangleIndexBuffer, t4.tileExtentSegments);
                    }
                  }(e2, 0, s2, a2);
                  break;
                case "custom":
                  !function(t4, e3, i4) {
                    const s3 = t4.context, a3 = i4.implementation;
                    if ("offscreen" === t4.renderPass) {
                      const e4 = a3.prerender;
                      e4 && (t4.setCustomLayerDefaults(), s3.setColorMode(t4.colorModeForRenderPass()), e4.call(a3, s3.gl, t4.transform.customLayerMatrix()), s3.setDirty(), t4.setBaseState());
                    } else if ("translucent" === t4.renderPass) {
                      t4.setCustomLayerDefaults(), s3.setColorMode(t4.colorModeForRenderPass()), s3.setStencilMode(Mi.disabled);
                      const e4 = "3d" === a3.renderingMode ? new Pi(t4.context.gl.LEQUAL, Pi.ReadWrite, t4.depthRangeFor3D) : t4.depthModeForSublayer(0, Pi.ReadOnly);
                      s3.setDepthMode(e4), a3.render(s3.gl, t4.transform.customLayerMatrix()), s3.setDirty(), t4.setBaseState(), s3.bindFramebuffer.set(null);
                    }
                  }(e2, 0, s2);
              }
          }
          translatePosMatrix(e2, i3, s2, a2, o2) {
            if (!s2[0] && !s2[1])
              return e2;
            const r2 = o2 ? "map" === a2 ? this.transform.angle : 0 : "viewport" === a2 ? -this.transform.angle : 0;
            if (r2) {
              const t4 = Math.sin(r2), e3 = Math.cos(r2);
              s2 = [s2[0] * e3 - s2[1] * t4, s2[0] * t4 + s2[1] * e3];
            }
            const n2 = [o2 ? s2[0] : St(i3, s2[0], this.transform.zoom), o2 ? s2[1] : St(i3, s2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
            return t.$(l2, e2, n2), l2;
          }
          saveTileTexture(t4) {
            const e2 = this._tileTextures[t4.size[0]];
            e2 ? e2.push(t4) : this._tileTextures[t4.size[0]] = [t4];
          }
          getTileTexture(t4) {
            const e2 = this._tileTextures[t4];
            return e2 && e2.length > 0 ? e2.pop() : null;
          }
          isPatternMissing(t4) {
            if (!t4)
              return false;
            if (!t4.from || !t4.to)
              return true;
            const e2 = this.imageManager.getPattern(t4.from.toString()), i3 = this.imageManager.getPattern(t4.to.toString());
            return !e2 || !i3;
          }
          useProgram(t4, e2) {
            this.cache = this.cache || {};
            const i3 = t4 + (e2 ? e2.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
            return this.cache[i3] || (this.cache[i3] = new ce(this.context, re[t4], e2, Be[t4], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i3];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const t4 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t4.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new x2(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: t4, drawingBufferHeight: e2 } = this.context.gl;
            return this.width !== t4 || this.height !== e2;
          }
        }
        class ss {
          constructor(t4, e2) {
            this.points = t4, this.planes = e2;
          }
          static fromInvProjectionMatrix(e2, i3, s2) {
            const a2 = Math.pow(2, s2), o2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((s3) => {
              const o3 = 1 / (s3 = t.ag([], s3, e2))[3] / i3 * a2;
              return t.b3(s3, s3, [o3, o3, 1 / s3[3], o3]);
            }), r2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t4) => {
              const e3 = function(t5, e4) {
                var i5 = e4[0], s4 = e4[1], a4 = e4[2], o3 = i5 * i5 + s4 * s4 + a4 * a4;
                return o3 > 0 && (o3 = 1 / Math.sqrt(o3)), t5[0] = e4[0] * o3, t5[1] = e4[1] * o3, t5[2] = e4[2] * o3, t5;
              }([], function(t5, e4, i5) {
                var s4 = e4[0], a4 = e4[1], o3 = e4[2], r3 = i5[0], n2 = i5[1], l2 = i5[2];
                return t5[0] = a4 * l2 - o3 * n2, t5[1] = o3 * r3 - s4 * l2, t5[2] = s4 * n2 - a4 * r3, t5;
              }([], m([], o2[t4[0]], o2[t4[1]]), m([], o2[t4[2]], o2[t4[1]]))), i4 = -((s3 = e3)[0] * (a3 = o2[t4[1]])[0] + s3[1] * a3[1] + s3[2] * a3[2]);
              var s3, a3;
              return e3.concat(i4);
            });
            return new ss(o2, r2);
          }
        }
        class as {
          constructor(t4, e2) {
            this.min = t4, this.max = e2, this.center = function(t5, e3, i3) {
              return t5[0] = 0.5 * e3[0], t5[1] = 0.5 * e3[1], t5[2] = 0.5 * e3[2], t5;
            }([], function(t5, e3, i3) {
              return t5[0] = e3[0] + i3[0], t5[1] = e3[1] + i3[1], t5[2] = e3[2] + i3[2], t5;
            }([], this.min, this.max));
          }
          quadrant(t4) {
            const e2 = [t4 % 2 == 0, t4 < 2], i3 = _(this.min), s2 = _(this.max);
            for (let t5 = 0; t5 < e2.length; t5++)
              i3[t5] = e2[t5] ? this.min[t5] : this.center[t5], s2[t5] = e2[t5] ? this.center[t5] : this.max[t5];
            return s2[2] = this.max[2], new as(i3, s2);
          }
          distanceX(t4) {
            return Math.max(Math.min(this.max[0], t4[0]), this.min[0]) - t4[0];
          }
          distanceY(t4) {
            return Math.max(Math.min(this.max[1], t4[1]), this.min[1]) - t4[1];
          }
          intersects(e2) {
            const i3 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
            let s2 = true;
            for (let a2 = 0; a2 < e2.planes.length; a2++) {
              const o2 = e2.planes[a2];
              let r2 = 0;
              for (let e3 = 0; e3 < i3.length; e3++)
                t.b4(o2, i3[e3]) >= 0 && r2++;
              if (0 === r2)
                return 0;
              r2 !== i3.length && (s2 = false);
            }
            if (s2)
              return 2;
            for (let t4 = 0; t4 < 3; t4++) {
              let i4 = Number.MAX_VALUE, s3 = -Number.MAX_VALUE;
              for (let a2 = 0; a2 < e2.points.length; a2++) {
                const o2 = e2.points[a2][t4] - this.min[t4];
                i4 = Math.min(i4, o2), s3 = Math.max(s3, o2);
              }
              if (s3 < 0 || i4 > this.max[t4] - this.min[t4])
                return 0;
            }
            return 1;
          }
        }
        class os {
          constructor(t4 = 0, e2 = 0, i3 = 0, s2 = 0) {
            if (isNaN(t4) || t4 < 0 || isNaN(e2) || e2 < 0 || isNaN(i3) || i3 < 0 || isNaN(s2) || s2 < 0)
              throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t4, this.bottom = e2, this.left = i3, this.right = s2;
          }
          interpolate(e2, i3, s2) {
            return null != i3.top && null != e2.top && (this.top = t.B.number(e2.top, i3.top, s2)), null != i3.bottom && null != e2.bottom && (this.bottom = t.B.number(e2.bottom, i3.bottom, s2)), null != i3.left && null != e2.left && (this.left = t.B.number(e2.left, i3.left, s2)), null != i3.right && null != e2.right && (this.right = t.B.number(e2.right, i3.right, s2)), this;
          }
          getCenter(e2, i3) {
            const s2 = t.ad((this.left + e2 - this.right) / 2, 0, e2), a2 = t.ad((this.top + i3 - this.bottom) / 2, 0, i3);
            return new t.P(s2, a2);
          }
          equals(t4) {
            return this.top === t4.top && this.bottom === t4.bottom && this.left === t4.left && this.right === t4.right;
          }
          clone() {
            return new os(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        class rs {
          constructor(e2, i3, s2, a2, o2) {
            this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === o2 || !!o2, this._minZoom = e2 || 0, this._maxZoom = i3 || 22, this._minPitch = null == s2 ? 0 : s2, this._maxPitch = null == a2 ? 60 : a2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.L(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new os(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._minEleveationForCurrentTile = 0;
          }
          clone() {
            const t4 = new rs(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
            return t4.apply(this), t4;
          }
          apply(t4) {
            this.tileSize = t4.tileSize, this.latRange = t4.latRange, this.width = t4.width, this.height = t4.height, this._center = t4._center, this._elevation = t4._elevation, this._minEleveationForCurrentTile = t4._minEleveationForCurrentTile, this.zoom = t4.zoom, this.angle = t4.angle, this._fov = t4._fov, this._pitch = t4._pitch, this._unmodified = t4._unmodified, this._edgeInsets = t4._edgeInsets.clone(), this._calcMatrices();
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(t4) {
            this._minZoom !== t4 && (this._minZoom = t4, this.zoom = Math.max(this.zoom, t4));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(t4) {
            this._maxZoom !== t4 && (this._maxZoom = t4, this.zoom = Math.min(this.zoom, t4));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(t4) {
            this._minPitch !== t4 && (this._minPitch = t4, this.pitch = Math.max(this.pitch, t4));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(t4) {
            this._maxPitch !== t4 && (this._maxPitch = t4, this.pitch = Math.min(this.pitch, t4));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          set renderWorldCopies(t4) {
            void 0 === t4 ? t4 = true : null === t4 && (t4 = false), this._renderWorldCopies = t4;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new t.P(this.width, this.height);
          }
          get bearing() {
            return -this.angle / Math.PI * 180;
          }
          set bearing(e2) {
            const i3 = -t.b5(e2, -180, 180) * Math.PI / 180;
            this.angle !== i3 && (this._unmodified = false, this.angle = i3, this._calcMatrices(), this.rotationMatrix = function() {
              var e3 = new t.A(4);
              return t.A != Float32Array && (e3[1] = 0, e3[2] = 0), e3[0] = 1, e3[3] = 1, e3;
            }(), function(t4, e3, i4) {
              var s2 = e3[0], a2 = e3[1], o2 = e3[2], r2 = e3[3], n2 = Math.sin(i4), l2 = Math.cos(i4);
              t4[0] = s2 * l2 + o2 * n2, t4[1] = a2 * l2 + r2 * n2, t4[2] = s2 * -n2 + o2 * l2, t4[3] = a2 * -n2 + r2 * l2;
            }(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(e2) {
            const i3 = t.ad(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i3 && (this._unmodified = false, this._pitch = i3, this._calcMatrices());
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          set fov(t4) {
            t4 = Math.max(0.01, Math.min(60, t4)), this._fov !== t4 && (this._unmodified = false, this._fov = t4 / 180 * Math.PI, this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(t4) {
            const e2 = Math.min(Math.max(t4, this.minZoom), this.maxZoom);
            this._zoom !== e2 && (this._unmodified = false, this._zoom = e2, this.tileZoom = Math.max(0, Math.floor(e2)), this.scale = this.zoomScale(e2), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          set center(t4) {
            t4.lat === this._center.lat && t4.lng === this._center.lng || (this._unmodified = false, this._center = t4, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(t4) {
            t4 !== this._elevation && (this._elevation = t4, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(t4) {
            this._edgeInsets.equals(t4) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t4, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          isPaddingEqual(t4) {
            return this._edgeInsets.equals(t4);
          }
          interpolatePadding(t4, e2, i3) {
            this._unmodified = false, this._edgeInsets.interpolate(t4, e2, i3), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(t4) {
            const e2 = (t4.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t4.tileSize));
            return Math.max(0, e2);
          }
          getVisibleUnwrappedCoordinates(e2) {
            const i3 = [new t.b6(0, e2)];
            if (this._renderWorldCopies) {
              const s2 = this.pointCoordinate(new t.P(0, 0)), a2 = this.pointCoordinate(new t.P(this.width, 0)), o2 = this.pointCoordinate(new t.P(this.width, this.height)), r2 = this.pointCoordinate(new t.P(0, this.height)), n2 = Math.floor(Math.min(s2.x, a2.x, o2.x, r2.x)), l2 = Math.floor(Math.max(s2.x, a2.x, o2.x, r2.x)), h2 = 1;
              for (let s3 = n2 - h2; s3 <= l2 + h2; s3++)
                0 !== s3 && i3.push(new t.b6(s3, e2));
            }
            return i3;
          }
          coveringTiles(e2) {
            var i3, s2;
            let a2 = this.coveringZoomLevel(e2);
            const o2 = a2;
            if (void 0 !== e2.minzoom && a2 < e2.minzoom)
              return [];
            void 0 !== e2.maxzoom && a2 > e2.maxzoom && (a2 = e2.maxzoom);
            const r2 = this.pointCoordinate(this.getCameraPoint()), n2 = t.U.fromLngLat(this.center), l2 = Math.pow(2, a2), h2 = [l2 * r2.x, l2 * r2.y, 0], c2 = [l2 * n2.x, l2 * n2.y, 0], u2 = ss.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, a2);
            let d2 = e2.minzoom || 0;
            !e2.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (d2 = a2);
            const _2 = e2.terrain ? 2 / Math.min(this.tileSize, e2.tileSize) * this.tileSize : 3, p2 = (t4) => ({ aabb: new as([t4 * l2, 0, 0], [(t4 + 1) * l2, l2, 0]), zoom: 0, x: 0, y: 0, wrap: t4, fullyVisible: false }), m2 = [], g2 = [], v2 = a2, x3 = e2.reparseOverscaled ? o2 : a2;
            if (this._renderWorldCopies)
              for (let t4 = 1; t4 <= 3; t4++)
                m2.push(p2(-t4)), m2.push(p2(t4));
            for (m2.push(p2(0)); m2.length > 0; ) {
              const a3 = m2.pop(), o3 = a3.x, r3 = a3.y;
              let n3 = a3.fullyVisible;
              if (!n3) {
                const t4 = a3.aabb.intersects(u2);
                if (0 === t4)
                  continue;
                n3 = 2 === t4;
              }
              const l3 = e2.terrain ? h2 : c2, p3 = a3.aabb.distanceX(l3), y2 = a3.aabb.distanceY(l3), b2 = Math.max(Math.abs(p3), Math.abs(y2));
              if (a3.zoom === v2 || b2 > _2 + (1 << v2 - a3.zoom) - 2 && a3.zoom >= d2) {
                const e3 = v2 - a3.zoom, i4 = h2[0] - 0.5 - (o3 << e3), s3 = h2[1] - 0.5 - (r3 << e3);
                g2.push({ tileID: new t.O(a3.zoom === v2 ? x3 : a3.zoom, a3.wrap, a3.zoom, o3, r3), distanceSq: f([c2[0] - 0.5 - o3, c2[1] - 0.5 - r3]), tileDistanceToCamera: Math.sqrt(i4 * i4 + s3 * s3) });
              } else
                for (let l4 = 0; l4 < 4; l4++) {
                  const h3 = (o3 << 1) + l4 % 2, c3 = (r3 << 1) + (l4 >> 1), u3 = a3.zoom + 1;
                  let d3 = a3.aabb.quadrant(l4);
                  if (e2.terrain) {
                    const o4 = new t.O(u3, a3.wrap, u3, h3, c3), r4 = e2.terrain.getMinMaxElevation(o4), n4 = null !== (i3 = r4.minElevation) && void 0 !== i3 ? i3 : this.elevation, l5 = null !== (s2 = r4.maxElevation) && void 0 !== s2 ? s2 : this.elevation;
                    d3 = new as([d3.min[0], d3.min[1], n4], [d3.max[0], d3.max[1], l5]);
                  }
                  m2.push({ aabb: d3, zoom: u3, x: h3, y: c3, wrap: a3.wrap, fullyVisible: n3 });
                }
            }
            return g2.sort((t4, e3) => t4.distanceSq - e3.distanceSq).map((t4) => t4.tileID);
          }
          resize(t4, e2) {
            this.width = t4, this.height = e2, this.pixelsToGLUnits = [2 / t4, -2 / e2], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(t4) {
            return Math.pow(2, t4);
          }
          scaleZoom(t4) {
            return Math.log(t4) / Math.LN2;
          }
          project(e2) {
            const i3 = t.ad(e2.lat, -this.maxValidLatitude, this.maxValidLatitude);
            return new t.P(t.G(e2.lng) * this.worldSize, t.H(i3) * this.worldSize);
          }
          unproject(e2) {
            return new t.U(e2.x / this.worldSize, e2.y / this.worldSize).toLngLat();
          }
          get point() {
            return this.project(this.center);
          }
          getCameraPosition() {
            return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
          }
          recalculateZoom(e2) {
            const i3 = this.pointLocation(this.centerPoint, e2), s2 = e2.getElevationForLngLatZoom(i3, this.tileZoom);
            if (!(this.elevation - s2))
              return;
            const a2 = this.getCameraPosition(), o2 = t.U.fromLngLat(a2.lngLat, a2.altitude), r2 = t.U.fromLngLat(i3, s2), n2 = o2.x - r2.x, l2 = o2.y - r2.y, h2 = o2.z - r2.z, c2 = Math.sqrt(n2 * n2 + l2 * l2 + h2 * h2), u2 = this.scaleZoom(this.cameraToCenterDistance / c2 / this.tileSize);
            this._elevation = s2, this._center = i3, this.zoom = u2;
          }
          setLocationAtPoint(e2, i3) {
            const s2 = this.pointCoordinate(i3), a2 = this.pointCoordinate(this.centerPoint), o2 = this.locationCoordinate(e2), r2 = new t.U(o2.x - (s2.x - a2.x), o2.y - (s2.y - a2.y));
            this.center = this.coordinateLocation(r2), this._renderWorldCopies && (this.center = this.center.wrap());
          }
          locationPoint(t4, e2) {
            return e2 ? this.coordinatePoint(this.locationCoordinate(t4), e2.getElevationForLngLatZoom(t4, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t4));
          }
          pointLocation(t4, e2) {
            return this.coordinateLocation(this.pointCoordinate(t4, e2));
          }
          locationCoordinate(e2) {
            return t.U.fromLngLat(e2);
          }
          coordinateLocation(t4) {
            return t4 && t4.toLngLat();
          }
          pointCoordinate(e2, i3) {
            if (i3) {
              const t4 = i3.pointCoordinate(e2);
              if (null != t4)
                return t4;
            }
            const s2 = [e2.x, e2.y, 0, 1], a2 = [e2.x, e2.y, 1, 1];
            t.ag(s2, s2, this.pixelMatrixInverse), t.ag(a2, a2, this.pixelMatrixInverse);
            const o2 = s2[3], r2 = a2[3], n2 = s2[1] / o2, l2 = a2[1] / r2, h2 = s2[2] / o2, c2 = a2[2] / r2, u2 = h2 === c2 ? 0 : (0 - h2) / (c2 - h2);
            return new t.U(t.B.number(s2[0] / o2, a2[0] / r2, u2) / this.worldSize, t.B.number(n2, l2, u2) / this.worldSize);
          }
          coordinatePoint(e2, i3 = 0, s2 = this.pixelMatrix) {
            const a2 = [e2.x * this.worldSize, e2.y * this.worldSize, i3, 1];
            return t.ag(a2, a2, s2), new t.P(a2[0] / a2[3], a2[1] / a2[3]);
          }
          getBounds() {
            const e2 = Math.max(0, this.height / 2 - this.getHorizon());
            return new L2().extend(this.pointLocation(new t.P(0, e2))).extend(this.pointLocation(new t.P(this.width, e2))).extend(this.pointLocation(new t.P(this.width, this.height))).extend(this.pointLocation(new t.P(0, this.height)));
          }
          getMaxBounds() {
            return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new L2([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
          }
          getHorizon() {
            return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
          }
          setMaxBounds(t4) {
            t4 ? (this.lngRange = [t4.getWest(), t4.getEast()], this.latRange = [t4.getSouth(), t4.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
          }
          calculatePosMatrix(e2, i3 = false) {
            const s2 = e2.key, a2 = i3 ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (a2[s2])
              return a2[s2];
            const o2 = e2.canonical, r2 = this.worldSize / this.zoomScale(o2.z), n2 = o2.x + Math.pow(2, o2.z) * e2.wrap, l2 = t.ao(new Float64Array(16));
            return t.$(l2, l2, [n2 * r2, o2.y * r2, 0]), t.a0(l2, l2, [r2 / t.N, r2 / t.N, 1]), t.a1(l2, i3 ? this.alignedProjMatrix : this.projMatrix, l2), a2[s2] = new Float32Array(l2), a2[s2];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining)
              return;
            this._constraining = true;
            let e2, i3, s2, a2, o2 = -90, r2 = 90, n2 = -180, l2 = 180;
            const h2 = this.size, c2 = this._unmodified;
            if (this.latRange) {
              const i4 = this.latRange;
              o2 = t.H(i4[1]) * this.worldSize, r2 = t.H(i4[0]) * this.worldSize, e2 = r2 - o2 < h2.y ? h2.y / (r2 - o2) : 0;
            }
            if (this.lngRange) {
              const e3 = this.lngRange;
              n2 = t.b5(t.G(e3[0]) * this.worldSize, 0, this.worldSize), l2 = t.b5(t.G(e3[1]) * this.worldSize, 0, this.worldSize), l2 < n2 && (l2 += this.worldSize), i3 = l2 - n2 < h2.x ? h2.x / (l2 - n2) : 0;
            }
            const u2 = this.point, d2 = Math.max(i3 || 0, e2 || 0);
            if (d2)
              return this.center = this.unproject(new t.P(i3 ? (l2 + n2) / 2 : u2.x, e2 ? (r2 + o2) / 2 : u2.y)), this.zoom += this.scaleZoom(d2), this._unmodified = c2, void (this._constraining = false);
            if (this.latRange) {
              const t4 = u2.y, e3 = h2.y / 2;
              t4 - e3 < o2 && (a2 = o2 + e3), t4 + e3 > r2 && (a2 = r2 - e3);
            }
            if (this.lngRange) {
              const e3 = (n2 + l2) / 2, i4 = t.b5(u2.x, e3 - this.worldSize / 2, e3 + this.worldSize / 2), a3 = h2.x / 2;
              i4 - a3 < n2 && (s2 = n2 + a3), i4 + a3 > l2 && (s2 = l2 - a3);
            }
            void 0 === s2 && void 0 === a2 || (this.center = this.unproject(new t.P(void 0 !== s2 ? s2 : u2.x, void 0 !== a2 ? a2 : u2.y)).wrap()), this._unmodified = c2, this._constraining = false;
          }
          _calcMatrices() {
            if (!this.height)
              return;
            const e2 = this.centerOffset, i3 = this.point.x, s2 = this.point.y;
            this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = t.b7(1, this.center.lat) * this.worldSize;
            let a2 = t.ao(new Float64Array(16));
            t.a0(a2, a2, [this.width / 2, -this.height / 2, 1]), t.$(a2, a2, [1, -1, 0]), this.labelPlaneMatrix = a2, a2 = t.ao(new Float64Array(16)), t.a0(a2, a2, [1, -1, 1]), t.$(a2, a2, [-1, -1, 0]), t.a0(a2, a2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a2;
            const o2 = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), r2 = Math.min(this.elevation, this._minEleveationForCurrentTile), n2 = o2 - r2 * this._pixelPerMeter / Math.cos(this._pitch), l2 = r2 < 0 ? n2 : o2, h2 = Math.PI / 2 + this._pitch, c2 = this._fov * (0.5 + e2.y / this.height), u2 = Math.sin(c2) * l2 / Math.sin(t.ad(Math.PI - h2 - c2, 0.01, Math.PI - 0.01)), d2 = this.getHorizon(), _2 = 2 * Math.atan(d2 / this.cameraToCenterDistance) * (0.5 + e2.y / (2 * d2)), p2 = Math.sin(_2) * l2 / Math.sin(t.ad(Math.PI - h2 - _2, 0.01, Math.PI - 0.01)), m2 = Math.min(u2, p2), f2 = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * m2 + l2), g2 = this.height / 50;
            a2 = new Float64Array(16), t.b8(a2, this._fov, this.width / this.height, g2, f2), a2[8] = 2 * -e2.x / this.width, a2[9] = 2 * e2.y / this.height, t.a0(a2, a2, [1, -1, 1]), t.$(a2, a2, [0, 0, -this.cameraToCenterDistance]), t.b9(a2, a2, this._pitch), t.ae(a2, a2, this.angle), t.$(a2, a2, [-i3, -s2, 0]), this.mercatorMatrix = t.a0([], a2, [this.worldSize, this.worldSize, this.worldSize]), t.a0(a2, a2, [1, 1, this._pixelPerMeter]), this.pixelMatrix = t.a1(new Float64Array(16), this.labelPlaneMatrix, a2), t.$(a2, a2, [0, 0, -this.elevation]), this.projMatrix = a2, this.invProjMatrix = t.as([], a2), this.pixelMatrix3D = t.a1(new Float64Array(16), this.labelPlaneMatrix, a2);
            const v2 = this.width % 2 / 2, x3 = this.height % 2 / 2, y2 = Math.cos(this.angle), b2 = Math.sin(this.angle), w2 = i3 - Math.round(i3) + y2 * v2 + b2 * x3, T3 = s2 - Math.round(s2) + y2 * x3 + b2 * v2, I2 = new Float64Array(a2);
            if (t.$(I2, I2, [w2 > 0.5 ? w2 - 1 : w2, T3 > 0.5 ? T3 - 1 : T3, 0]), this.alignedProjMatrix = I2, a2 = t.as(new Float64Array(16), this.pixelMatrix), !a2)
              throw new Error("failed to invert matrix");
            this.pixelMatrixInverse = a2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
          }
          maxPitchScaleFactor() {
            if (!this.pixelMatrixInverse)
              return 1;
            const e2 = this.pointCoordinate(new t.P(0, 0)), i3 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
            return t.ag(i3, i3, this.pixelMatrix)[3] / this.cameraToCenterDistance;
          }
          getCameraPoint() {
            const e2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new t.P(0, e2));
          }
          getCameraQueryGeometry(e2) {
            const i3 = this.getCameraPoint();
            if (1 === e2.length)
              return [e2[0], i3];
            {
              let s2 = i3.x, a2 = i3.y, o2 = i3.x, r2 = i3.y;
              for (const t4 of e2)
                s2 = Math.min(s2, t4.x), a2 = Math.min(a2, t4.y), o2 = Math.max(o2, t4.x), r2 = Math.max(r2, t4.y);
              return [new t.P(s2, a2), new t.P(o2, a2), new t.P(o2, r2), new t.P(s2, r2), new t.P(s2, a2)];
            }
          }
        }
        function ns(t4, e2) {
          let i3, s2 = false, a2 = null, o2 = null;
          const r2 = () => {
            a2 = null, s2 && (t4.apply(o2, i3), a2 = setTimeout(r2, e2), s2 = false);
          };
          return (...t5) => (s2 = true, o2 = this, i3 = t5, a2 || r2(), a2);
        }
        class ls {
          constructor(t4) {
            this._getCurrentHash = () => {
              const t5 = window.location.hash.replace("#", "");
              if (this._hashName) {
                let e2;
                return t5.split("&").map((t6) => t6.split("=")).forEach((t6) => {
                  t6[0] === this._hashName && (e2 = t6);
                }), (e2 && e2[1] || "").split("/");
              }
              return t5.split("/");
            }, this._onHashChange = () => {
              const t5 = this._getCurrentHash();
              if (t5.length >= 3 && !t5.some((t6) => isNaN(t6))) {
                const e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t5[3] || 0) : this._map.getBearing();
                return this._map.jumpTo({ center: [+t5[2], +t5[1]], zoom: +t5[0], bearing: e2, pitch: +(t5[4] || 0) }), true;
              }
              return false;
            }, this._updateHashUnthrottled = () => {
              const t5 = window.location.href.replace(/(#.+)?$/, this.getHashString());
              try {
                window.history.replaceState(window.history.state, null, t5);
              } catch (t6) {
              }
            }, this._updateHash = ns(this._updateHashUnthrottled, 300), this._hashName = t4 && encodeURIComponent(t4);
          }
          addTo(t4) {
            return this._map = t4, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
          }
          getHashString(t4) {
            const e2 = this._map.getCenter(), i3 = Math.round(100 * this._map.getZoom()) / 100, s2 = Math.ceil((i3 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a2 = Math.pow(10, s2), o2 = Math.round(e2.lng * a2) / a2, r2 = Math.round(e2.lat * a2) / a2, n2 = this._map.getBearing(), l2 = this._map.getPitch();
            let h2 = "";
            if (h2 += t4 ? `/${o2}/${r2}/${i3}` : `${i3}/${r2}/${o2}`, (n2 || l2) && (h2 += "/" + Math.round(10 * n2) / 10), l2 && (h2 += `/${Math.round(l2)}`), this._hashName) {
              const t5 = this._hashName;
              let e3 = false;
              const i4 = window.location.hash.slice(1).split("&").map((i5) => {
                const s3 = i5.split("=")[0];
                return s3 === t5 ? (e3 = true, `${s3}=${h2}`) : i5;
              }).filter((t6) => t6);
              return e3 || i4.push(`${t5}=${h2}`), `#${i4.join("&")}`;
            }
            return `#${h2}`;
          }
        }
        const hs = { linearity: 0.3, easing: t.ba(0, 0, 0.3, 1) }, cs = t.e({ deceleration: 2500, maxSpeed: 1400 }, hs), us = t.e({ deceleration: 20, maxSpeed: 1400 }, hs), ds = t.e({ deceleration: 1e3, maxSpeed: 360 }, hs), _s = t.e({ deceleration: 1e3, maxSpeed: 90 }, hs);
        class ps {
          constructor(t4) {
            this._map = t4, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e2) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t.h.now(), settings: e2 });
          }
          _drainInertiaBuffer() {
            const e2 = this._inertiaBuffer, i3 = t.h.now();
            for (; e2.length > 0 && i3 - e2[0].time > 160; )
              e2.shift();
          }
          _onMoveEnd(e2) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
              return;
            const i3 = { zoom: 0, bearing: 0, pitch: 0, pan: new t.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: t4 } of this._inertiaBuffer)
              i3.zoom += t4.zoomDelta || 0, i3.bearing += t4.bearingDelta || 0, i3.pitch += t4.pitchDelta || 0, t4.panDelta && i3.pan._add(t4.panDelta), t4.around && (i3.around = t4.around), t4.pinchAround && (i3.pinchAround = t4.pinchAround);
            const s2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a2 = {};
            if (i3.pan.mag()) {
              const o2 = fs(i3.pan.mag(), s2, t.e({}, cs, e2 || {}));
              a2.offset = i3.pan.mult(o2.amount / i3.pan.mag()), a2.center = this._map.transform.center, ms(a2, o2);
            }
            if (i3.zoom) {
              const t4 = fs(i3.zoom, s2, us);
              a2.zoom = this._map.transform.zoom + t4.amount, ms(a2, t4);
            }
            if (i3.bearing) {
              const e3 = fs(i3.bearing, s2, ds);
              a2.bearing = this._map.transform.bearing + t.ad(e3.amount, -179, 179), ms(a2, e3);
            }
            if (i3.pitch) {
              const t4 = fs(i3.pitch, s2, _s);
              a2.pitch = this._map.transform.pitch + t4.amount, ms(a2, t4);
            }
            if (a2.zoom || a2.bearing) {
              const t4 = void 0 === i3.pinchAround ? i3.around : i3.pinchAround;
              a2.around = t4 ? this._map.unproject(t4) : this._map.getCenter();
            }
            return this.clear(), t.e(a2, { noMoveStart: true });
          }
        }
        function ms(t4, e2) {
          (!t4.duration || t4.duration < e2.duration) && (t4.duration = e2.duration, t4.easing = e2.easing);
        }
        function fs(e2, i3, s2) {
          const { maxSpeed: a2, linearity: o2, deceleration: r2 } = s2, n2 = t.ad(e2 * o2 / (i3 / 1e3), -a2, a2), l2 = Math.abs(n2) / (r2 * o2);
          return { easing: s2.easing, duration: 1e3 * l2, amount: n2 * (l2 / 2) };
        }
        class gs extends t.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e2, s2, a2, o2 = {}) {
            const r2 = i2.mousePos(s2.getCanvasContainer(), a2), n2 = s2.unproject(r2);
            super(e2, t.e({ point: r2, lngLat: n2, originalEvent: a2 }, o2)), this._defaultPrevented = false, this.target = s2;
          }
        }
        class vs extends t.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e2, s2, a2) {
            const o2 = "touchend" === e2 ? a2.changedTouches : a2.touches, r2 = i2.touchPos(s2.getCanvasContainer(), o2), n2 = r2.map((t4) => s2.unproject(t4)), l2 = r2.reduce((t4, e3, i3, s3) => t4.add(e3.div(s3.length)), new t.P(0, 0));
            super(e2, { points: r2, point: l2, lngLats: n2, lngLat: s2.unproject(l2), originalEvent: a2 }), this._defaultPrevented = false;
          }
        }
        class xs extends t.k {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t4, e2, i3) {
            super(t4, { originalEvent: i3 }), this._defaultPrevented = false;
          }
        }
        class ys {
          constructor(t4, e2) {
            this._map = t4, this._clickTolerance = e2.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(t4) {
            return this._firePreventable(new xs(t4.type, this._map, t4));
          }
          mousedown(t4, e2) {
            return this._mousedownPos = e2, this._firePreventable(new gs(t4.type, this._map, t4));
          }
          mouseup(t4) {
            this._map.fire(new gs(t4.type, this._map, t4));
          }
          click(t4, e2) {
            this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new gs(t4.type, this._map, t4));
          }
          dblclick(t4) {
            return this._firePreventable(new gs(t4.type, this._map, t4));
          }
          mouseover(t4) {
            this._map.fire(new gs(t4.type, this._map, t4));
          }
          mouseout(t4) {
            this._map.fire(new gs(t4.type, this._map, t4));
          }
          touchstart(t4) {
            return this._firePreventable(new vs(t4.type, this._map, t4));
          }
          touchmove(t4) {
            this._map.fire(new vs(t4.type, this._map, t4));
          }
          touchend(t4) {
            this._map.fire(new vs(t4.type, this._map, t4));
          }
          touchcancel(t4) {
            this._map.fire(new vs(t4.type, this._map, t4));
          }
          _firePreventable(t4) {
            if (this._map.fire(t4), t4.defaultPrevented)
              return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class bs {
          constructor(t4) {
            this._map = t4;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(t4) {
            this._map.fire(new gs(t4.type, this._map, t4));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new gs("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(t4) {
            this._delayContextMenu ? this._contextMenuEvent = t4 : this._ignoreContextMenu || this._map.fire(new gs(t4.type, this._map, t4)), this._map.listens("contextmenu") && t4.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class ws {
          constructor(t4) {
            this._map = t4;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e2) {
            return this.transform.pointLocation(t.P.convert(e2), this._map.terrain);
          }
        }
        class Ts {
          constructor(t4, e2) {
            this._map = t4, this._tr = new ws(t4), this._el = t4.getCanvasContainer(), this._container = t4.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(t4, e2) {
            this.isEnabled() && t4.shiftKey && 0 === t4.button && (i2.disableDrag(), this._startPos = this._lastPos = e2, this._active = true);
          }
          mousemoveWindow(t4, e2) {
            if (!this._active)
              return;
            const s2 = e2;
            if (this._lastPos.equals(s2) || !this._box && s2.dist(this._startPos) < this._clickTolerance)
              return;
            const a2 = this._startPos;
            this._lastPos = s2, this._box || (this._box = i2.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t4));
            const o2 = Math.min(a2.x, s2.x), r2 = Math.max(a2.x, s2.x), n2 = Math.min(a2.y, s2.y), l2 = Math.max(a2.y, s2.y);
            i2.setTransform(this._box, `translate(${o2}px,${n2}px)`), this._box.style.width = r2 - o2 + "px", this._box.style.height = l2 - n2 + "px";
          }
          mouseupWindow(e2, s2) {
            if (!this._active)
              return;
            if (0 !== e2.button)
              return;
            const a2 = this._startPos, o2 = s2;
            if (this.reset(), i2.suppressClick(), a2.x !== o2.x || a2.y !== o2.y)
              return this._map.fire(new t.k("boxzoomend", { originalEvent: e2 })), { cameraAnimation: (t4) => t4.fitScreenCoordinates(a2, o2, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", e2);
          }
          keydown(t4) {
            this._active && 27 === t4.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t4));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (i2.remove(this._box), this._box = null), i2.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e2, i3) {
            return this._map.fire(new t.k(e2, { originalEvent: i3 }));
          }
        }
        function Is(t4, e2) {
          if (t4.length !== e2.length)
            throw new Error(`The number of touches and points are not equal - touches ${t4.length}, points ${e2.length}`);
          const i3 = {};
          for (let s2 = 0; s2 < t4.length; s2++)
            i3[t4[s2].identifier] = e2[s2];
          return i3;
        }
        class Es {
          constructor(t4) {
            this.reset(), this.numTouches = t4.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(e2, i3, s2) {
            (this.centroid || s2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e2.timeStamp), s2.length === this.numTouches && (this.centroid = function(e3) {
              const i4 = new t.P(0, 0);
              for (const t4 of e3)
                i4._add(t4);
              return i4.div(e3.length);
            }(i3), this.touches = Is(s2, i3)));
          }
          touchmove(t4, e2, i3) {
            if (this.aborted || !this.centroid)
              return;
            const s2 = Is(i3, e2);
            for (const t5 in this.touches) {
              const e3 = s2[t5];
              (!e3 || e3.dist(this.touches[t5]) > 30) && (this.aborted = true);
            }
          }
          touchend(t4, e2, i3) {
            if ((!this.centroid || t4.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i3.length) {
              const t5 = !this.aborted && this.centroid;
              if (this.reset(), t5)
                return t5;
            }
          }
        }
        class Ss {
          constructor(t4) {
            this.singleTap = new Es(t4), this.numTaps = t4.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(t4, e2, i3) {
            this.singleTap.touchstart(t4, e2, i3);
          }
          touchmove(t4, e2, i3) {
            this.singleTap.touchmove(t4, e2, i3);
          }
          touchend(t4, e2, i3) {
            const s2 = this.singleTap.touchend(t4, e2, i3);
            if (s2) {
              const e3 = t4.timeStamp - this.lastTime < 500, i4 = !this.lastTap || this.lastTap.dist(s2) < 30;
              if (e3 && i4 || this.reset(), this.count++, this.lastTime = t4.timeStamp, this.lastTap = s2, this.count === this.numTaps)
                return this.reset(), s2;
            }
          }
        }
        class Cs {
          constructor(t4) {
            this._tr = new ws(t4), this._zoomIn = new Ss({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Ss({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t4, e2, i3) {
            this._zoomIn.touchstart(t4, e2, i3), this._zoomOut.touchstart(t4, e2, i3);
          }
          touchmove(t4, e2, i3) {
            this._zoomIn.touchmove(t4, e2, i3), this._zoomOut.touchmove(t4, e2, i3);
          }
          touchend(t4, e2, i3) {
            const s2 = this._zoomIn.touchend(t4, e2, i3), a2 = this._zoomOut.touchend(t4, e2, i3), o2 = this._tr;
            return s2 ? (this._active = true, t4.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o2.zoom + 1, around: o2.unproject(s2) }, { originalEvent: t4 }) }) : a2 ? (this._active = true, t4.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o2.zoom - 1, around: o2.unproject(a2) }, { originalEvent: t4 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ps {
          constructor(t4) {
            this._enabled = !!t4.enable, this._moveStateManager = t4.moveStateManager, this._clickTolerance = t4.clickTolerance || 1, this._moveFunction = t4.move, this._activateOnStart = !!t4.activateOnStart, t4.assignEvents(this), this.reset();
          }
          reset(t4) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(t4);
          }
          _move(...t4) {
            const e2 = this._moveFunction(...t4);
            if (e2.bearingDelta || e2.pitchDelta || e2.around || e2.panDelta)
              return this._active = true, e2;
          }
          dragStart(t4, e2) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t4) && (this._moveStateManager.startMove(t4), this._lastPoint = e2.length ? e2[0] : e2, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(t4, e2) {
            if (!this.isEnabled())
              return;
            const i3 = this._lastPoint;
            if (!i3)
              return;
            if (t4.preventDefault(), !this._moveStateManager.isValidMoveEvent(t4))
              return void this.reset(t4);
            const s2 = e2.length ? e2[0] : e2;
            return !this._moved && s2.dist(i3) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = s2, this._move(i3, s2));
          }
          dragEnd(t4) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t4) && (this._moved && i2.suppressClick(), this.reset(t4));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Ds = { 0: 1, 2: 2 };
        class Ms {
          constructor(t4) {
            this._correctEvent = t4.checkCorrectEvent;
          }
          startMove(t4) {
            const e2 = i2.mouseButton(t4);
            this._eventButton = e2;
          }
          endMove(t4) {
            delete this._eventButton;
          }
          isValidStartEvent(t4) {
            return this._correctEvent(t4);
          }
          isValidMoveEvent(t4) {
            return !function(t5, e2) {
              const i3 = Ds[e2];
              return void 0 === t5.buttons || (t5.buttons & i3) !== i3;
            }(t4, this._eventButton);
          }
          isValidEndEvent(t4) {
            return i2.mouseButton(t4) === this._eventButton;
          }
        }
        class zs {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(t4) {
            return 1 === t4.targetTouches.length;
          }
          _isSameTouchEvent(t4) {
            return t4.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(t4) {
            this._firstTouch = t4.targetTouches[0].identifier;
          }
          endMove(t4) {
            delete this._firstTouch;
          }
          isValidStartEvent(t4) {
            return this._isOneFingerTouch(t4);
          }
          isValidMoveEvent(t4) {
            return this._isOneFingerTouch(t4) && this._isSameTouchEvent(t4);
          }
          isValidEndEvent(t4) {
            return this._isOneFingerTouch(t4) && this._isSameTouchEvent(t4);
          }
        }
        const Ls = (t4) => {
          t4.mousedown = t4.dragStart, t4.mousemoveWindow = t4.dragMove, t4.mouseup = t4.dragEnd, t4.contextmenu = function(t5) {
            t5.preventDefault();
          };
        }, As = ({ enable: t4, clickTolerance: e2, bearingDegreesPerPixelMoved: s2 = 0.8 }) => {
          const a2 = new Ms({ checkCorrectEvent: (t5) => 0 === i2.mouseButton(t5) && t5.ctrlKey || 2 === i2.mouseButton(t5) });
          return new Ps({ clickTolerance: e2, move: (t5, e3) => ({ bearingDelta: (e3.x - t5.x) * s2 }), moveStateManager: a2, enable: t4, assignEvents: Ls });
        }, Rs = ({ enable: t4, clickTolerance: e2, pitchDegreesPerPixelMoved: s2 = -0.5 }) => {
          const a2 = new Ms({ checkCorrectEvent: (t5) => 0 === i2.mouseButton(t5) && t5.ctrlKey || 2 === i2.mouseButton(t5) });
          return new Ps({ clickTolerance: e2, move: (t5, e3) => ({ pitchDelta: (e3.y - t5.y) * s2 }), moveStateManager: a2, enable: t4, assignEvents: Ls });
        };
        class ks {
          constructor(t4, e2) {
            this._minTouches = t4.cooperativeGestures ? 2 : 1, this._clickTolerance = t4.clickTolerance || 1, this._map = e2, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new t.P(0, 0), setTimeout(() => {
              this._cancelCooperativeMessage = false;
            }, 200);
          }
          touchstart(t4, e2, i3) {
            return this._calculateTransform(t4, e2, i3);
          }
          touchmove(t4, e2, i3) {
            if (this._map._cooperativeGestures && (2 === this._minTouches && i3.length < 2 && !this._cancelCooperativeMessage ? this._map._onCooperativeGesture(t4, false, i3.length) : this._cancelCooperativeMessage || (this._cancelCooperativeMessage = true)), this._active && !(i3.length < this._minTouches))
              return t4.preventDefault(), this._calculateTransform(t4, e2, i3);
          }
          touchend(t4, e2, i3) {
            this._calculateTransform(t4, e2, i3), this._active && i3.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e2, i3, s2) {
            s2.length > 0 && (this._active = true);
            const a2 = Is(s2, i3), o2 = new t.P(0, 0), r2 = new t.P(0, 0);
            let n2 = 0;
            for (const t4 in a2) {
              const e3 = a2[t4], i4 = this._touches[t4];
              i4 && (o2._add(e3), r2._add(e3.sub(i4)), n2++, a2[t4] = e3);
            }
            if (this._touches = a2, n2 < this._minTouches || !r2.mag())
              return;
            const l2 = r2.div(n2);
            return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: o2.div(n2), panDelta: l2 };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Fs {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(t4, e2, i3) {
            this._firstTwoTouches || i3.length < 2 || (this._firstTwoTouches = [i3[0].identifier, i3[1].identifier], this._start([e2[0], e2[1]]));
          }
          touchmove(t4, e2, i3) {
            if (!this._firstTwoTouches)
              return;
            t4.preventDefault();
            const [s2, a2] = this._firstTwoTouches, o2 = Bs(i3, e2, s2), r2 = Bs(i3, e2, a2);
            if (!o2 || !r2)
              return;
            const n2 = this._aroundCenter ? null : o2.add(r2).div(2);
            return this._move([o2, r2], n2, t4);
          }
          touchend(t4, e2, s2) {
            if (!this._firstTwoTouches)
              return;
            const [a2, o2] = this._firstTwoTouches, r2 = Bs(s2, e2, a2), n2 = Bs(s2, e2, o2);
            r2 && n2 || (this._active && i2.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t4) {
            this._enabled = true, this._aroundCenter = !!t4 && "center" === t4.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function Bs(t4, e2, i3) {
          for (let s2 = 0; s2 < t4.length; s2++)
            if (t4[s2].identifier === i3)
              return e2[s2];
        }
        function Os(t4, e2) {
          return Math.log(t4 / e2) / Math.LN2;
        }
        class Ns extends Fs {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(t4) {
            this._startDistance = this._distance = t4[0].dist(t4[1]);
          }
          _move(t4, e2) {
            const i3 = this._distance;
            if (this._distance = t4[0].dist(t4[1]), this._active || !(Math.abs(Os(this._distance, this._startDistance)) < 0.1))
              return this._active = true, { zoomDelta: Os(this._distance, i3), pinchAround: e2 };
          }
        }
        function Us(t4, e2) {
          return 180 * t4.angleWith(e2) / Math.PI;
        }
        class Zs extends Fs {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(t4) {
            this._startVector = this._vector = t4[0].sub(t4[1]), this._minDiameter = t4[0].dist(t4[1]);
          }
          _move(t4, e2) {
            const i3 = this._vector;
            if (this._vector = t4[0].sub(t4[1]), this._active || !this._isBelowThreshold(this._vector))
              return this._active = true, { bearingDelta: Us(this._vector, i3), pinchAround: e2 };
          }
          _isBelowThreshold(t4) {
            this._minDiameter = Math.min(this._minDiameter, t4.mag());
            const e2 = 25 / (Math.PI * this._minDiameter) * 360, i3 = Us(t4, this._startVector);
            return Math.abs(i3) < e2;
          }
        }
        function Gs(t4) {
          return Math.abs(t4.y) > Math.abs(t4.x);
        }
        class js extends Fs {
          constructor(t4) {
            super(), this._map = t4;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(t4, e2, i3) {
            super.touchstart(t4, e2, i3), this._currentTouchCount = i3.length;
          }
          _start(t4) {
            this._lastPoints = t4, Gs(t4[0].sub(t4[1])) && (this._valid = false);
          }
          _move(t4, e2, i3) {
            if (this._map._cooperativeGestures && this._currentTouchCount < 3)
              return;
            const s2 = t4[0].sub(this._lastPoints[0]), a2 = t4[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(s2, a2, i3.timeStamp), this._valid ? (this._lastPoints = t4, this._active = true, { pitchDelta: (s2.y + a2.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(t4, e2, i3) {
            if (void 0 !== this._valid)
              return this._valid;
            const s2 = t4.mag() >= 2, a2 = e2.mag() >= 2;
            if (!s2 && !a2)
              return;
            if (!s2 || !a2)
              return void 0 === this._firstMove && (this._firstMove = i3), i3 - this._firstMove < 100 && void 0;
            const o2 = t4.y > 0 == e2.y > 0;
            return Gs(t4) && Gs(e2) && o2;
          }
        }
        const Vs = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class qs {
          constructor(t4) {
            this._tr = new ws(t4);
            const e2 = Vs;
            this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(t4) {
            if (t4.altKey || t4.ctrlKey || t4.metaKey)
              return;
            let e2 = 0, i3 = 0, s2 = 0, a2 = 0, o2 = 0;
            switch (t4.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                e2 = 1;
                break;
              case 189:
              case 109:
              case 173:
                e2 = -1;
                break;
              case 37:
                t4.shiftKey ? i3 = -1 : (t4.preventDefault(), a2 = -1);
                break;
              case 39:
                t4.shiftKey ? i3 = 1 : (t4.preventDefault(), a2 = 1);
                break;
              case 38:
                t4.shiftKey ? s2 = 1 : (t4.preventDefault(), o2 = -1);
                break;
              case 40:
                t4.shiftKey ? s2 = -1 : (t4.preventDefault(), o2 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i3 = 0, s2 = 0), { cameraAnimation: (r2) => {
              const n2 = this._tr;
              r2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: $s, zoom: e2 ? Math.round(n2.zoom) + e2 * (t4.shiftKey ? 2 : 1) : n2.zoom, bearing: n2.bearing + i3 * this._bearingStep, pitch: n2.pitch + s2 * this._pitchStep, offset: [-a2 * this._panStep, -o2 * this._panStep], center: n2.center }, { originalEvent: t4 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function $s(t4) {
          return t4 * (2 - t4);
        }
        const Ws = 4.000244140625;
        class Hs {
          constructor(t4, e2) {
            this._onTimeout = (t5) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t5);
            }, this._map = t4, this._tr = new ws(t4), this._el = t4.getCanvasContainer(), this._triggerRenderFrame = e2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
          }
          setZoomRate(t4) {
            this._defaultZoomRate = t4;
          }
          setWheelZoomRate(t4) {
            this._wheelZoomRate = t4;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t4) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!t4 && "center" === t4.around);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          wheel(e2) {
            if (!this.isEnabled())
              return;
            if (this._map._cooperativeGestures) {
              if (!e2[this._map._metaKey])
                return;
              e2.preventDefault();
            }
            let i3 = e2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY;
            const s2 = t.h.now(), a2 = s2 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = s2, 0 !== i3 && i3 % Ws == 0 ? this._type = "wheel" : 0 !== i3 && Math.abs(i3) < 4 ? this._type = "trackpad" : a2 > 400 ? (this._type = null, this._lastValue = i3, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(a2 * i3) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i3 += this._lastValue)), e2.shiftKey && i3 && (i3 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= i3, this._active || this._start(e2)), e2.preventDefault();
          }
          _start(e2) {
            if (!this._delta)
              return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const s2 = i2.mousePos(this._el, e2), a2 = this._tr;
            this._around = t.L.convert(this._aroundCenter ? a2.center : a2.unproject(s2)), this._aroundPoint = a2.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId)
              return;
            if (this._frameId = null, !this.isActive())
              return;
            const e2 = this._tr.transform;
            if (0 !== this._delta) {
              const t4 = "wheel" === this._type && Math.abs(this._delta) > Ws ? this._wheelZoomRate : this._defaultZoomRate;
              let i4 = 2 / (1 + Math.exp(-Math.abs(this._delta * t4)));
              this._delta < 0 && 0 !== i4 && (i4 = 1 / i4);
              const s3 = "number" == typeof this._targetZoom ? e2.zoomScale(this._targetZoom) : e2.scale;
              this._targetZoom = Math.min(e2.maxZoom, Math.max(e2.minZoom, e2.scaleZoom(s3 * i4))), "wheel" === this._type && (this._startZoom = e2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const i3 = "number" == typeof this._targetZoom ? this._targetZoom : e2.zoom, s2 = this._startZoom, a2 = this._easing;
            let o2, r2 = false;
            if ("wheel" === this._type && s2 && a2) {
              const e3 = Math.min((t.h.now() - this._lastWheelEventTime) / 200, 1), n2 = a2(e3);
              o2 = t.B.number(s2, i3, n2), e3 < 1 ? this._frameId || (this._frameId = true) : r2 = true;
            } else
              o2 = i3, r2 = true;
            return this._active = true, r2 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200)), { noInertia: true, needsRenderFrame: !r2, zoomDelta: o2 - e2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e2) {
            let i3 = t.bb;
            if (this._prevEase) {
              const e3 = this._prevEase, s2 = (t.h.now() - e3.start) / e3.duration, a2 = e3.easing(s2 + 0.01) - e3.easing(s2), o2 = 0.27 / Math.sqrt(a2 * a2 + 1e-4) * 0.01, r2 = Math.sqrt(0.0729 - o2 * o2);
              i3 = t.ba(o2, r2, 0.25, 1);
            }
            return this._prevEase = { start: t.h.now(), duration: e2, easing: i3 }, i3;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Xs {
          constructor(t4, e2) {
            this._clickZoom = t4, this._tapZoom = e2;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Ks {
          constructor(t4) {
            this._tr = new ws(t4), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(t4, e2) {
            return t4.preventDefault(), { cameraAnimation: (i3) => {
              i3.easeTo({ duration: 300, zoom: this._tr.zoom + (t4.shiftKey ? -1 : 1), around: this._tr.unproject(e2) }, { originalEvent: t4 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Qs {
          constructor() {
            this._tap = new Ss({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(t4, e2, i3) {
            if (!this._swipePoint)
              if (this._tapTime) {
                const s2 = e2[0], a2 = t4.timeStamp - this._tapTime < 500, o2 = this._tapPoint.dist(s2) < 30;
                a2 && o2 ? i3.length > 0 && (this._swipePoint = s2, this._swipeTouch = i3[0].identifier) : this.reset();
              } else
                this._tap.touchstart(t4, e2, i3);
          }
          touchmove(t4, e2, i3) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i3[0].identifier !== this._swipeTouch)
                  return;
                const s2 = e2[0], a2 = s2.y - this._swipePoint.y;
                return this._swipePoint = s2, t4.preventDefault(), this._active = true, { zoomDelta: a2 / 128 };
              }
            } else
              this._tap.touchmove(t4, e2, i3);
          }
          touchend(t4, e2, i3) {
            if (this._tapTime)
              this._swipePoint && 0 === i3.length && this.reset();
            else {
              const s2 = this._tap.touchend(t4, e2, i3);
              s2 && (this._tapTime = t4.timeStamp, this._tapPoint = s2);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ys {
          constructor(t4, e2, i3) {
            this._el = t4, this._mousePan = e2, this._touchPan = i3;
          }
          enable(t4) {
            this._inertiaOptions = t4 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Js {
          constructor(t4, e2, i3) {
            this._pitchWithRotate = t4.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i3;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class ta {
          constructor(t4, e2, i3, s2) {
            this._el = t4, this._touchZoom = e2, this._touchRotate = i3, this._tapDragZoom = s2, this._rotationDisabled = false, this._enabled = true;
          }
          enable(t4) {
            this._touchZoom.enable(t4), this._rotationDisabled || this._touchRotate.enable(t4), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const ea = (t4) => t4.zoom || t4.drag || t4.pitch || t4.rotate;
        class ia extends t.k {
        }
        function sa(t4) {
          return t4.panDelta && t4.panDelta.mag() || t4.zoomDelta || t4.bearingDelta || t4.pitchDelta;
        }
        class aa {
          constructor(t4, e2) {
            this.handleWindowEvent = (t5) => {
              this.handleEvent(t5, `${t5.type}Window`);
            }, this.handleEvent = (t5, e3) => {
              if ("blur" === t5.type)
                return void this.stop(true);
              this._updatingCamera = true;
              const s3 = "renderFrame" === t5.type ? void 0 : t5, a2 = { needsRenderFrame: false }, o2 = {}, r2 = {}, n2 = t5.touches, l2 = n2 ? this._getMapTouches(n2) : void 0, h2 = l2 ? i2.touchPos(this._el, l2) : i2.mousePos(this._el, t5);
              for (const { handlerName: i3, handler: n3, allowed: c3 } of this._handlers) {
                if (!n3.isEnabled())
                  continue;
                let u3;
                this._blockedByActive(r2, c3, i3) ? n3.reset() : n3[e3 || t5.type] && (u3 = n3[e3 || t5.type](t5, h2, l2), this.mergeHandlerResult(a2, o2, u3, i3, s3), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || n3.isActive()) && (r2[i3] = n3);
              }
              const c2 = {};
              for (const t6 in this._previousActiveHandlers)
                r2[t6] || (c2[t6] = s3);
              this._previousActiveHandlers = r2, (Object.keys(c2).length || sa(a2)) && (this._changes.push([a2, o2, c2]), this._triggerRenderFrame()), (Object.keys(r2).length || sa(a2)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: u2 } = a2;
              u2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u2(this._map));
            }, this._map = t4, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ps(t4), this._bearingSnap = e2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(e2);
            const s2 = this._el;
            this._listeners = [[s2, "touchstart", { passive: true }], [s2, "touchmove", { passive: false }], [s2, "touchend", void 0], [s2, "touchcancel", void 0], [s2, "mousedown", void 0], [s2, "mousemove", void 0], [s2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [s2, "mouseover", void 0], [s2, "mouseout", void 0], [s2, "dblclick", void 0], [s2, "click", void 0], [s2, "keydown", { capture: false }], [s2, "keyup", void 0], [s2, "wheel", { passive: false }], [s2, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [t5, e3, s3] of this._listeners)
              i2.addEventListener(t5, e3, t5 === document ? this.handleWindowEvent : this.handleEvent, s3);
          }
          destroy() {
            for (const [t4, e2, s2] of this._listeners)
              i2.removeEventListener(t4, e2, t4 === document ? this.handleWindowEvent : this.handleEvent, s2);
          }
          _addDefaultHandlers(t4) {
            const e2 = this._map, s2 = e2.getCanvasContainer();
            this._add("mapEvent", new ys(e2, t4));
            const a2 = e2.boxZoom = new Ts(e2, t4);
            this._add("boxZoom", a2), t4.interactive && t4.boxZoom && a2.enable();
            const o2 = new Cs(e2), r2 = new Ks(e2);
            e2.doubleClickZoom = new Xs(r2, o2), this._add("tapZoom", o2), this._add("clickZoom", r2), t4.interactive && t4.doubleClickZoom && e2.doubleClickZoom.enable();
            const n2 = new Qs();
            this._add("tapDragZoom", n2);
            const l2 = e2.touchPitch = new js(e2);
            this._add("touchPitch", l2), t4.interactive && t4.touchPitch && e2.touchPitch.enable(t4.touchPitch);
            const h2 = As(t4), c2 = Rs(t4);
            e2.dragRotate = new Js(t4, h2, c2), this._add("mouseRotate", h2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]), t4.interactive && t4.dragRotate && e2.dragRotate.enable();
            const u2 = (({ enable: t5, clickTolerance: e3 }) => {
              const s3 = new Ms({ checkCorrectEvent: (t6) => 0 === i2.mouseButton(t6) && !t6.ctrlKey });
              return new Ps({ clickTolerance: e3, move: (t6, e4) => ({ around: e4, panDelta: e4.sub(t6) }), activateOnStart: true, moveStateManager: s3, enable: t5, assignEvents: Ls });
            })(t4), d2 = new ks(t4, e2);
            e2.dragPan = new Ys(s2, u2, d2), this._add("mousePan", u2), this._add("touchPan", d2, ["touchZoom", "touchRotate"]), t4.interactive && t4.dragPan && e2.dragPan.enable(t4.dragPan);
            const _2 = new Zs(), p2 = new Ns();
            e2.touchZoomRotate = new ta(s2, p2, _2, n2), this._add("touchRotate", _2, ["touchPan", "touchZoom"]), this._add("touchZoom", p2, ["touchPan", "touchRotate"]), t4.interactive && t4.touchZoomRotate && e2.touchZoomRotate.enable(t4.touchZoomRotate);
            const m2 = e2.scrollZoom = new Hs(e2, () => this._triggerRenderFrame());
            this._add("scrollZoom", m2, ["mousePan"]), t4.interactive && t4.scrollZoom && e2.scrollZoom.enable(t4.scrollZoom);
            const f2 = e2.keyboard = new qs(e2);
            this._add("keyboard", f2), t4.interactive && t4.keyboard && e2.keyboard.enable(), this._add("blockableMapEvent", new bs(e2));
          }
          _add(t4, e2, i3) {
            this._handlers.push({ handlerName: t4, handler: e2, allowed: i3 }), this._handlersById[t4] = e2;
          }
          stop(t4) {
            if (!this._updatingCamera) {
              for (const { handler: t5 } of this._handlers)
                t5.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t4), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: t4 } of this._handlers)
              if (t4.isActive())
                return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean(ea(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(t4, e2, i3) {
            for (const s2 in t4)
              if (s2 !== i3 && (!e2 || e2.indexOf(s2) < 0))
                return true;
            return false;
          }
          _getMapTouches(t4) {
            const e2 = [];
            for (const i3 of t4)
              this._el.contains(i3.target) && e2.push(i3);
            return e2;
          }
          mergeHandlerResult(e2, i3, s2, a2, o2) {
            if (!s2)
              return;
            t.e(e2, s2);
            const r2 = { handlerName: a2, originalEvent: s2.originalEvent || o2 };
            void 0 !== s2.zoomDelta && (i3.zoom = r2), void 0 !== s2.panDelta && (i3.drag = r2), void 0 !== s2.pitchDelta && (i3.pitch = r2), void 0 !== s2.bearingDelta && (i3.rotate = r2);
          }
          _applyChanges() {
            const e2 = {}, i3 = {}, s2 = {};
            for (const [a2, o2, r2] of this._changes)
              a2.panDelta && (e2.panDelta = (e2.panDelta || new t.P(0, 0))._add(a2.panDelta)), a2.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + a2.zoomDelta), a2.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + a2.bearingDelta), a2.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + a2.pitchDelta), void 0 !== a2.around && (e2.around = a2.around), void 0 !== a2.pinchAround && (e2.pinchAround = a2.pinchAround), a2.noInertia && (e2.noInertia = a2.noInertia), t.e(i3, o2), t.e(s2, r2);
            this._updateMapTransform(e2, i3, s2), this._changes = [];
          }
          _updateMapTransform(t4, e2, i3) {
            const s2 = this._map, a2 = s2._getTransformForUpdate(), o2 = s2.terrain;
            if (!(sa(t4) || o2 && this._terrainMovement))
              return this._fireEvents(e2, i3, true);
            let { panDelta: r2, zoomDelta: n2, bearingDelta: l2, pitchDelta: h2, around: c2, pinchAround: u2 } = t4;
            void 0 !== u2 && (c2 = u2), s2._stop(true), c2 = c2 || s2.transform.centerPoint;
            const d2 = a2.pointLocation(r2 ? c2.sub(r2) : c2);
            l2 && (a2.bearing += l2), h2 && (a2.pitch += h2), n2 && (a2.zoom += n2), o2 ? this._terrainMovement || !e2.drag && !e2.zoom ? e2.drag && this._terrainMovement ? a2.center = a2.pointLocation(a2.centerPoint.sub(r2)) : a2.setLocationAtPoint(d2, c2) : (this._terrainMovement = true, this._map._elevationFreeze = true, a2.setLocationAtPoint(d2, c2), this._map.once("moveend", () => {
              this._map._elevationFreeze = false, this._terrainMovement = false, a2.recalculateZoom(s2.terrain);
            })) : a2.setLocationAtPoint(d2, c2), s2._applyUpdatedTransform(a2), this._map._update(), t4.noInertia || this._inertia.record(t4), this._fireEvents(e2, i3, true);
          }
          _fireEvents(e2, i3, s2) {
            const a2 = ea(this._eventsInProgress), o2 = ea(e2), r2 = {};
            for (const t4 in e2) {
              const { originalEvent: i4 } = e2[t4];
              this._eventsInProgress[t4] || (r2[`${t4}start`] = i4), this._eventsInProgress[t4] = e2[t4];
            }
            !a2 && o2 && this._fireEvent("movestart", o2.originalEvent);
            for (const t4 in r2)
              this._fireEvent(t4, r2[t4]);
            o2 && this._fireEvent("move", o2.originalEvent);
            for (const t4 in e2) {
              const { originalEvent: i4 } = e2[t4];
              this._fireEvent(t4, i4);
            }
            const n2 = {};
            let l2;
            for (const t4 in this._eventsInProgress) {
              const { handlerName: e3, originalEvent: s3 } = this._eventsInProgress[t4];
              this._handlersById[e3].isActive() || (delete this._eventsInProgress[t4], l2 = i3[e3] || s3, n2[`${t4}end`] = l2);
            }
            for (const t4 in n2)
              this._fireEvent(t4, n2[t4]);
            const h2 = ea(this._eventsInProgress);
            if (s2 && (a2 || o2) && !h2) {
              this._updatingCamera = true;
              const e3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i4 = (t4) => 0 !== t4 && -this._bearingSnap < t4 && t4 < this._bearingSnap;
              !e3 || !e3.essential && t.h.prefersReducedMotion ? (this._map.fire(new t.k("moveend", { originalEvent: l2 })), i4(this._map.getBearing()) && this._map.resetNorth()) : (i4(e3.bearing || this._map.getBearing()) && (e3.bearing = 0), e3.freezeElevation = true, this._map.easeTo(e3, { originalEvent: l2 })), this._updatingCamera = false;
            }
          }
          _fireEvent(e2, i3) {
            this._map.fire(new t.k(e2, i3 ? { originalEvent: i3 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t4) => {
              delete this._frameId, this.handleEvent(new ia("renderFrame", { timeStamp: t4 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        class oa extends t.E {
          constructor(e2, i3) {
            super(), this._renderFrameCallback = () => {
              const e3 = Math.min((t.h.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = e2, this._bearingSnap = i3.bearingSnap, this.on("moveend", () => {
              delete this._requestedCameraState;
            });
          }
          getCenter() {
            return new t.L(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(t4, e2) {
            return this.jumpTo({ center: t4 }, e2);
          }
          panBy(e2, i3, s2) {
            return e2 = t.P.convert(e2).mult(-1), this.panTo(this.transform.center, t.e({ offset: e2 }, i3), s2);
          }
          panTo(e2, i3, s2) {
            return this.easeTo(t.e({ center: e2 }, i3), s2);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t4, e2) {
            return this.jumpTo({ zoom: t4 }, e2), this;
          }
          zoomTo(e2, i3, s2) {
            return this.easeTo(t.e({ zoom: e2 }, i3), s2);
          }
          zoomIn(t4, e2) {
            return this.zoomTo(this.getZoom() + 1, t4, e2), this;
          }
          zoomOut(t4, e2) {
            return this.zoomTo(this.getZoom() - 1, t4, e2), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(t4, e2) {
            return this.jumpTo({ bearing: t4 }, e2), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t4, e2) {
            return this.jumpTo({ padding: t4 }, e2), this;
          }
          rotateTo(e2, i3, s2) {
            return this.easeTo(t.e({ bearing: e2 }, i3), s2);
          }
          resetNorth(e2, i3) {
            return this.rotateTo(0, t.e({ duration: 1e3 }, e2), i3), this;
          }
          resetNorthPitch(e2, i3) {
            return this.easeTo(t.e({ bearing: 0, pitch: 0, duration: 1e3 }, e2), i3), this;
          }
          snapToNorth(t4, e2) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t4, e2) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t4, e2) {
            return this.jumpTo({ pitch: t4 }, e2), this;
          }
          cameraForBounds(t4, e2) {
            t4 = L2.convert(t4);
            const i3 = e2 && e2.bearing || 0;
            return this._cameraForBoxAndBearing(t4.getNorthWest(), t4.getSouthEast(), i3, e2);
          }
          _cameraForBoxAndBearing(e2, i3, s2, a2) {
            const o2 = { top: 0, bottom: 0, right: 0, left: 0 };
            if ("number" == typeof (a2 = t.e({ padding: o2, offset: [0, 0], maxZoom: this.transform.maxZoom }, a2)).padding) {
              const t4 = a2.padding;
              a2.padding = { top: t4, bottom: t4, right: t4, left: t4 };
            }
            a2.padding = t.e(o2, a2.padding);
            const r2 = this.transform, n2 = r2.padding, l2 = r2.project(t.L.convert(e2)), h2 = r2.project(t.L.convert(i3)), c2 = l2.rotate(-s2 * Math.PI / 180), u2 = h2.rotate(-s2 * Math.PI / 180), d2 = new t.P(Math.max(c2.x, u2.x), Math.max(c2.y, u2.y)), _2 = new t.P(Math.min(c2.x, u2.x), Math.min(c2.y, u2.y)), p2 = d2.sub(_2), m2 = (r2.width - (n2.left + n2.right + a2.padding.left + a2.padding.right)) / p2.x, f2 = (r2.height - (n2.top + n2.bottom + a2.padding.top + a2.padding.bottom)) / p2.y;
            if (f2 < 0 || m2 < 0)
              return void t.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            const g2 = Math.min(r2.scaleZoom(r2.scale * Math.min(m2, f2)), a2.maxZoom), v2 = t.P.convert(a2.offset), x3 = new t.P((a2.padding.left - a2.padding.right) / 2, (a2.padding.top - a2.padding.bottom) / 2).rotate(s2 * Math.PI / 180), y2 = v2.add(x3).mult(r2.scale / r2.zoomScale(g2));
            return { center: r2.unproject(l2.add(h2).div(2).sub(y2)), zoom: g2, bearing: s2 };
          }
          fitBounds(t4, e2, i3) {
            return this._fitInternal(this.cameraForBounds(t4, e2), e2, i3);
          }
          fitScreenCoordinates(e2, i3, s2, a2, o2) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.P.convert(e2)), this.transform.pointLocation(t.P.convert(i3)), s2, a2), a2, o2);
          }
          _fitInternal(e2, i3, s2) {
            return e2 ? (delete (i3 = t.e(e2, i3)).padding, i3.linear ? this.easeTo(i3, s2) : this.flyTo(i3, s2)) : this;
          }
          jumpTo(e2, i3) {
            this.stop();
            const s2 = this._getTransformForUpdate();
            let a2 = false, o2 = false, r2 = false;
            return "zoom" in e2 && s2.zoom !== +e2.zoom && (a2 = true, s2.zoom = +e2.zoom), void 0 !== e2.center && (s2.center = t.L.convert(e2.center)), "bearing" in e2 && s2.bearing !== +e2.bearing && (o2 = true, s2.bearing = +e2.bearing), "pitch" in e2 && s2.pitch !== +e2.pitch && (r2 = true, s2.pitch = +e2.pitch), null == e2.padding || s2.isPaddingEqual(e2.padding) || (s2.padding = e2.padding), this._applyUpdatedTransform(s2), this.fire(new t.k("movestart", i3)).fire(new t.k("move", i3)), a2 && this.fire(new t.k("zoomstart", i3)).fire(new t.k("zoom", i3)).fire(new t.k("zoomend", i3)), o2 && this.fire(new t.k("rotatestart", i3)).fire(new t.k("rotate", i3)).fire(new t.k("rotateend", i3)), r2 && this.fire(new t.k("pitchstart", i3)).fire(new t.k("pitch", i3)).fire(new t.k("pitchend", i3)), this.fire(new t.k("moveend", i3));
          }
          calculateCameraOptionsFromTo(e2, i3, s2, a2 = 0) {
            const o2 = t.U.fromLngLat(e2, i3), r2 = t.U.fromLngLat(s2, a2), n2 = r2.x - o2.x, l2 = r2.y - o2.y, h2 = r2.z - o2.z, c2 = Math.hypot(n2, l2, h2);
            if (0 === c2)
              throw new Error("Can't calculate camera options with same From and To");
            const u2 = Math.hypot(n2, l2), d2 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / c2 / this.transform.tileSize), _2 = 180 * Math.atan2(n2, -l2) / Math.PI;
            let p2 = 180 * Math.acos(u2 / c2) / Math.PI;
            return p2 = h2 < 0 ? 90 - p2 : 90 + p2, { center: r2.toLngLat(), zoom: d2, pitch: p2, bearing: _2 };
          }
          easeTo(e2, i3) {
            this._stop(false, e2.easeId), (false === (e2 = t.e({ offset: [0, 0], duration: 500, easing: t.bb }, e2)).animate || !e2.essential && t.h.prefersReducedMotion) && (e2.duration = 0);
            const s2 = this._getTransformForUpdate(), a2 = this.getZoom(), o2 = this.getBearing(), r2 = this.getPitch(), n2 = this.getPadding(), l2 = "zoom" in e2 ? +e2.zoom : a2, h2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, o2) : o2, c2 = "pitch" in e2 ? +e2.pitch : r2, u2 = "padding" in e2 ? e2.padding : s2.padding, d2 = t.P.convert(e2.offset);
            let _2 = s2.centerPoint.add(d2);
            const p2 = s2.pointLocation(_2), m2 = t.L.convert(e2.center || p2);
            this._normalizeCenter(m2);
            const f2 = s2.project(p2), g2 = s2.project(m2).sub(f2), v2 = s2.zoomScale(l2 - a2);
            let x3, y2;
            e2.around && (x3 = t.L.convert(e2.around), y2 = s2.locationPoint(x3));
            const b2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = this._zooming || l2 !== a2, this._rotating = this._rotating || o2 !== h2, this._pitching = this._pitching || c2 !== r2, this._padding = !s2.isPaddingEqual(u2), this._easeId = e2.easeId, this._prepareEase(i3, e2.noMoveStart, b2), this.terrain && this._prepareElevation(m2), this._ease((p3) => {
              if (this._zooming && (s2.zoom = t.B.number(a2, l2, p3)), this._rotating && (s2.bearing = t.B.number(o2, h2, p3)), this._pitching && (s2.pitch = t.B.number(r2, c2, p3)), this._padding && (s2.interpolatePadding(n2, u2, p3), _2 = s2.centerPoint.add(d2)), this.terrain && !e2.freezeElevation && this._updateElevation(p3), x3)
                s2.setLocationAtPoint(x3, y2);
              else {
                const t4 = s2.zoomScale(s2.zoom - a2), e3 = l2 > a2 ? Math.min(2, v2) : Math.max(0.5, v2), i4 = Math.pow(e3, 1 - p3), o3 = s2.unproject(f2.add(g2.mult(p3 * i4)).mult(t4));
                s2.setLocationAtPoint(s2.renderWorldCopies ? o3.wrap() : o3, _2);
              }
              this._applyUpdatedTransform(s2), this._fireMoveEvents(i3);
            }, (t4) => {
              this.terrain && this._finalizeElevation(), this._afterEase(i3, t4);
            }, e2), this;
          }
          _prepareEase(e2, i3, s2 = {}) {
            this._moving = true, i3 || s2.moving || this.fire(new t.k("movestart", e2)), this._zooming && !s2.zooming && this.fire(new t.k("zoomstart", e2)), this._rotating && !s2.rotating && this.fire(new t.k("rotatestart", e2)), this._pitching && !s2.pitching && this.fire(new t.k("pitchstart", e2));
          }
          _prepareElevation(t4) {
            this._elevationCenter = t4, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t4, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(e2) {
            this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            const i3 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e2 < 1 && i3 !== this._elevationTarget) {
              const t4 = this._elevationTarget - this._elevationStart;
              this._elevationStart += e2 * (t4 - (i3 - (t4 * e2 + this._elevationStart)) / (1 - e2)), this._elevationTarget = i3;
            }
            this.transform.elevation = t.B.number(this._elevationStart, this._elevationTarget, e2);
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.transform.recalculateZoom(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _applyUpdatedTransform(t4) {
            if (!this.transformCameraUpdate)
              return;
            const e2 = t4.clone(), { center: i3, zoom: s2, pitch: a2, bearing: o2, elevation: r2 } = this.transformCameraUpdate(e2);
            i3 && (e2.center = i3), void 0 !== s2 && (e2.zoom = s2), void 0 !== a2 && (e2.pitch = a2), void 0 !== o2 && (e2.bearing = o2), void 0 !== r2 && (e2.elevation = r2), this.transform.apply(e2);
          }
          _fireMoveEvents(e2) {
            this.fire(new t.k("move", e2)), this._zooming && this.fire(new t.k("zoom", e2)), this._rotating && this.fire(new t.k("rotate", e2)), this._pitching && this.fire(new t.k("pitch", e2));
          }
          _afterEase(e2, i3) {
            if (this._easeId && i3 && this._easeId === i3)
              return;
            delete this._easeId;
            const s2 = this._zooming, a2 = this._rotating, o2 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, s2 && this.fire(new t.k("zoomend", e2)), a2 && this.fire(new t.k("rotateend", e2)), o2 && this.fire(new t.k("pitchend", e2)), this.fire(new t.k("moveend", e2));
          }
          flyTo(e2, i3) {
            if (!e2.essential && t.h.prefersReducedMotion) {
              const s3 = t.F(e2, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(s3, i3);
            }
            this.stop(), e2 = t.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.bb }, e2);
            const s2 = this._getTransformForUpdate(), a2 = this.getZoom(), o2 = this.getBearing(), r2 = this.getPitch(), n2 = this.getPadding(), l2 = "zoom" in e2 ? t.ad(+e2.zoom, s2.minZoom, s2.maxZoom) : a2, h2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, o2) : o2, c2 = "pitch" in e2 ? +e2.pitch : r2, u2 = "padding" in e2 ? e2.padding : s2.padding, d2 = s2.zoomScale(l2 - a2), _2 = t.P.convert(e2.offset);
            let p2 = s2.centerPoint.add(_2);
            const m2 = s2.pointLocation(p2), f2 = t.L.convert(e2.center || m2);
            this._normalizeCenter(f2);
            const g2 = s2.project(m2), v2 = s2.project(f2).sub(g2);
            let x3 = e2.curve;
            const y2 = Math.max(s2.width, s2.height), b2 = y2 / d2, w2 = v2.mag();
            if ("minZoom" in e2) {
              const i4 = t.ad(Math.min(e2.minZoom, a2, l2), s2.minZoom, s2.maxZoom), o3 = y2 / s2.zoomScale(i4 - a2);
              x3 = Math.sqrt(o3 / w2 * 2);
            }
            const T3 = x3 * x3;
            function I2(t4) {
              const e3 = (b2 * b2 - y2 * y2 + (t4 ? -1 : 1) * T3 * T3 * w2 * w2) / (2 * (t4 ? b2 : y2) * T3 * w2);
              return Math.log(Math.sqrt(e3 * e3 + 1) - e3);
            }
            function E3(t4) {
              return (Math.exp(t4) - Math.exp(-t4)) / 2;
            }
            function S2(t4) {
              return (Math.exp(t4) + Math.exp(-t4)) / 2;
            }
            const C3 = I2(false);
            let P2 = function(t4) {
              return S2(C3) / S2(C3 + x3 * t4);
            }, D3 = function(t4) {
              return y2 * ((S2(C3) * (E3(e3 = C3 + x3 * t4) / S2(e3)) - E3(C3)) / T3) / w2;
              var e3;
            }, M2 = (I2(true) - C3) / x3;
            if (Math.abs(w2) < 1e-6 || !isFinite(M2)) {
              if (Math.abs(y2 - b2) < 1e-6)
                return this.easeTo(e2, i3);
              const t4 = b2 < y2 ? -1 : 1;
              M2 = Math.abs(Math.log(b2 / y2)) / x3, D3 = function() {
                return 0;
              }, P2 = function(e3) {
                return Math.exp(t4 * x3 * e3);
              };
            }
            return e2.duration = "duration" in e2 ? +e2.duration : 1e3 * M2 / ("screenSpeed" in e2 ? +e2.screenSpeed / x3 : +e2.speed), e2.maxDuration && e2.duration > e2.maxDuration && (e2.duration = 0), this._zooming = true, this._rotating = o2 !== h2, this._pitching = c2 !== r2, this._padding = !s2.isPaddingEqual(u2), this._prepareEase(i3, false), this.terrain && this._prepareElevation(f2), this._ease((d3) => {
              const m3 = d3 * M2, x4 = 1 / P2(m3);
              s2.zoom = 1 === d3 ? l2 : a2 + s2.scaleZoom(x4), this._rotating && (s2.bearing = t.B.number(o2, h2, d3)), this._pitching && (s2.pitch = t.B.number(r2, c2, d3)), this._padding && (s2.interpolatePadding(n2, u2, d3), p2 = s2.centerPoint.add(_2)), this.terrain && !e2.freezeElevation && this._updateElevation(d3);
              const y3 = 1 === d3 ? f2 : s2.unproject(g2.add(v2.mult(D3(m3))).mult(x4));
              s2.setLocationAtPoint(s2.renderWorldCopies ? y3.wrap() : y3, p2), this._applyUpdatedTransform(s2), this._fireMoveEvents(i3);
            }, () => {
              this.terrain && this._finalizeElevation(), this._afterEase(i3);
            }, e2), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(t4, e2) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const t5 = this._onEaseEnd;
              delete this._onEaseEnd, t5.call(this, e2);
            }
            if (!t4) {
              const t5 = this.handlers;
              t5 && t5.stop(false);
            }
            return this;
          }
          _ease(e2, i3, s2) {
            false === s2.animate || 0 === s2.duration ? (e2(1), i3()) : (this._easeStart = t.h.now(), this._easeOptions = s2, this._onEaseFrame = e2, this._onEaseEnd = i3, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e2, i3) {
            e2 = t.b5(e2, -180, 180);
            const s2 = Math.abs(e2 - i3);
            return Math.abs(e2 - 360 - i3) < s2 && (e2 -= 360), Math.abs(e2 + 360 - i3) < s2 && (e2 += 360), e2;
          }
          _normalizeCenter(t4) {
            const e2 = this.transform;
            if (!e2.renderWorldCopies || e2.lngRange)
              return;
            const i3 = t4.lng - e2.center.lng;
            t4.lng += i3 > 180 ? -360 : i3 < -180 ? 360 : 0;
          }
          queryTerrainElevation(e2) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(t.L.convert(e2), this.transform.tileZoom) - this.transform.elevation : null;
          }
        }
        class ra {
          constructor(t4 = {}) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (t5) => {
              !t5 || "metadata" !== t5.sourceDataType && "visibility" !== t5.sourceDataType && "style" !== t5.dataType && "terrain" !== t5.type || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = t4;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(t4) {
            return this._map = t4, this._compact = this.options && this.options.compact, this._container = i2.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = i2.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = i2.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            i2.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(t4, e2) {
            const i3 = this._map._getUIString(`AttributionControl.${e2}`);
            t4.title = i3, t4.setAttribute("aria-label", i3);
          }
          _updateAttributions() {
            if (!this._map.style)
              return;
            let t4 = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t4 = t4.concat(this.options.customAttribution.map((t5) => "string" != typeof t5 ? "" : t5)) : "string" == typeof this.options.customAttribution && t4.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const t5 = this._map.style.stylesheet;
              this.styleOwner = t5.owner, this.styleId = t5.id;
            }
            const e2 = this._map.style.sourceCaches;
            for (const i4 in e2) {
              const s2 = e2[i4];
              if (s2.used || s2.usedForTerrain) {
                const e3 = s2.getSource();
                e3.attribution && t4.indexOf(e3.attribution) < 0 && t4.push(e3.attribution);
              }
            }
            t4 = t4.filter((t5) => String(t5).trim()), t4.sort((t5, e3) => t5.length - e3.length), t4 = t4.filter((e3, i4) => {
              for (let s2 = i4 + 1; s2 < t4.length; s2++)
                if (t4[s2].indexOf(e3) >= 0)
                  return false;
              return true;
            });
            const i3 = t4.join(" | ");
            i3 !== this._attribHTML && (this._attribHTML = i3, t4.length ? (this._innerContainer.innerHTML = i3, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class na {
          constructor(t4 = {}) {
            this._updateCompact = () => {
              const t5 = this._container.children;
              if (t5.length) {
                const e2 = t5[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && e2.classList.add("maplibregl-compact") : e2.classList.remove("maplibregl-compact");
              }
            }, this.options = t4;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t4) {
            this._map = t4, this._compact = this.options && this.options.compact, this._container = i2.create("div", "maplibregl-ctrl");
            const e2 = i2.create("a", "maplibregl-ctrl-logo");
            return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://maplibre.org/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            i2.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class la {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(t4) {
            const e2 = ++this._id;
            return this._queue.push({ callback: t4, id: e2, cancelled: false }), e2;
          }
          remove(t4) {
            const e2 = this._currentlyRunning, i3 = e2 ? this._queue.concat(e2) : this._queue;
            for (const e3 of i3)
              if (e3.id === t4)
                return void (e3.cancelled = true);
          }
          run(t4 = 0) {
            if (this._currentlyRunning)
              throw new Error("Attempting to run(), but is already running.");
            const e2 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i3 of e2)
              if (!i3.cancelled && (i3.callback(t4), this._cleared))
                break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        const ha = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.enableTerrain": "Enable terrain", "TerrainControl.disableTerrain": "Disable terrain" };
        var ca = t.Q([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class ua extends t.E {
          constructor(t4) {
            super(), this.sourceCache = t4, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t4.usedForTerrain = true, t4.tileSize = this.tileSize * 2 ** this.deltaZoom;
          }
          destruct() {
            this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
          }
          update(e2, i3) {
            this.sourceCache.update(e2, i3), this._renderableTilesKeys = [];
            const s2 = {};
            for (const a2 of e2.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i3 }))
              s2[a2.key] = true, this._renderableTilesKeys.push(a2.key), this._tiles[a2.key] || (a2.posMatrix = new Float64Array(16), t.aS(a2.posMatrix, 0, t.N, 0, t.N, 0, 1), this._tiles[a2.key] = new W(a2, this.tileSize));
            for (const t4 in this._tiles)
              s2[t4] || delete this._tiles[t4];
          }
          freeRtt(t4) {
            for (const e2 in this._tiles) {
              const i3 = this._tiles[e2];
              (!t4 || i3.tileID.equals(t4) || i3.tileID.isChildOf(t4) || t4.isChildOf(i3.tileID)) && (i3.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((t4) => this.getTileByID(t4));
          }
          getTileByID(t4) {
            return this._tiles[t4];
          }
          getTerrainCoords(e2) {
            const i3 = {};
            for (const s2 of this._renderableTilesKeys) {
              const a2 = this._tiles[s2].tileID;
              if (a2.canonical.equals(e2.canonical)) {
                const a3 = e2.clone();
                a3.posMatrix = new Float64Array(16), t.aS(a3.posMatrix, 0, t.N, 0, t.N, 0, 1), i3[s2] = a3;
              } else if (a2.canonical.isChildOf(e2.canonical)) {
                const o2 = e2.clone();
                o2.posMatrix = new Float64Array(16);
                const r2 = a2.canonical.z - e2.canonical.z, n2 = a2.canonical.x - (a2.canonical.x >> r2 << r2), l2 = a2.canonical.y - (a2.canonical.y >> r2 << r2), h2 = t.N >> r2;
                t.aS(o2.posMatrix, 0, h2, 0, h2, 0, 1), t.$(o2.posMatrix, o2.posMatrix, [-n2 * h2, -l2 * h2, 0]), i3[s2] = o2;
              } else if (e2.canonical.isChildOf(a2.canonical)) {
                const o2 = e2.clone();
                o2.posMatrix = new Float64Array(16);
                const r2 = e2.canonical.z - a2.canonical.z, n2 = e2.canonical.x - (e2.canonical.x >> r2 << r2), l2 = e2.canonical.y - (e2.canonical.y >> r2 << r2), h2 = t.N >> r2;
                t.aS(o2.posMatrix, 0, t.N, 0, t.N, 0, 1), t.$(o2.posMatrix, o2.posMatrix, [n2 * h2, l2 * h2, 0]), t.a0(o2.posMatrix, o2.posMatrix, [1 / 2 ** r2, 1 / 2 ** r2, 0]), i3[s2] = o2;
              }
            }
            return i3;
          }
          getSourceTile(t4, e2) {
            const i3 = this.sourceCache._source;
            let s2 = t4.overscaledZ - this.deltaZoom;
            if (s2 > i3.maxzoom && (s2 = i3.maxzoom), s2 < i3.minzoom)
              return null;
            this._sourceTileCache[t4.key] || (this._sourceTileCache[t4.key] = t4.scaledTo(s2).key);
            let a2 = this.sourceCache.getTileByID(this._sourceTileCache[t4.key]);
            if ((!a2 || !a2.dem) && e2)
              for (; s2 >= i3.minzoom && (!a2 || !a2.dem); )
                a2 = this.sourceCache.getTileByID(t4.scaledTo(s2--).key);
            return a2;
          }
          tilesAfterTime(t4 = Date.now()) {
            return Object.values(this._tiles).filter((e2) => e2.timeAdded >= t4);
          }
        }
        class da {
          constructor(t4, e2, i3) {
            this.painter = t4, this.sourceCache = new ua(e2), this.options = i3, this.exaggeration = "number" == typeof i3.exaggeration ? i3.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e2, i3, s2, a2 = t.N) {
            var o2;
            if (!(i3 >= 0 && i3 < a2 && s2 >= 0 && s2 < a2))
              return 0;
            const r2 = this.getTerrainData(e2), n2 = null === (o2 = r2.tile) || void 0 === o2 ? void 0 : o2.dem;
            if (!n2)
              return 0;
            const l2 = function(t4, e3, i4) {
              var s3 = e3[0], a3 = e3[1];
              return t4[0] = i4[0] * s3 + i4[4] * a3 + i4[12], t4[1] = i4[1] * s3 + i4[5] * a3 + i4[13], t4;
            }([], [i3 / a2 * t.N, s2 / a2 * t.N], r2.u_terrain_matrix), h2 = [l2[0] * n2.dim, l2[1] * n2.dim], c2 = Math.floor(h2[0]), u2 = Math.floor(h2[1]), d2 = h2[0] - c2, _2 = h2[1] - u2;
            return n2.get(c2, u2) * (1 - d2) * (1 - _2) + n2.get(c2 + 1, u2) * d2 * (1 - _2) + n2.get(c2, u2 + 1) * (1 - d2) * _2 + n2.get(c2 + 1, u2 + 1) * d2 * _2;
          }
          getElevationForLngLatZoom(e2, i3) {
            const { tileID: s2, mercatorX: a2, mercatorY: o2 } = this._getOverscaledTileIDFromLngLatZoom(e2, i3);
            return this.getElevation(s2, a2 % t.N, o2 % t.N, t.N);
          }
          getElevation(e2, i3, s2, a2 = t.N) {
            return this.getDEMElevation(e2, i3, s2, a2) * this.exaggeration;
          }
          getTerrainData(e2) {
            if (!this._emptyDemTexture) {
              const e3 = this.painter.context, i4 = new t.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new x2(e3, i4, e3.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new x2(e3, new t.R({ width: 1, height: 1 }), e3.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.ao([]);
            }
            const i3 = this.sourceCache.getSourceTile(e2, true);
            if (i3 && i3.dem && (!i3.demTexture || i3.needsTerrainPrepare)) {
              const t4 = this.painter.context;
              i3.demTexture = this.painter.getTileTexture(i3.dem.stride), i3.demTexture ? i3.demTexture.update(i3.dem.getPixels(), { premultiply: false }) : i3.demTexture = new x2(t4, i3.dem.getPixels(), t4.gl.RGBA, { premultiply: false }), i3.demTexture.bind(t4.gl.NEAREST, t4.gl.CLAMP_TO_EDGE), i3.needsTerrainPrepare = false;
            }
            const s2 = i3 && i3 + i3.tileID.key + e2.key;
            if (s2 && !this._demMatrixCache[s2]) {
              const s3 = this.sourceCache.sourceCache._source.maxzoom;
              let a2 = e2.canonical.z - i3.tileID.canonical.z;
              e2.overscaledZ > e2.canonical.z && (e2.canonical.z >= s3 ? a2 = e2.canonical.z - s3 : t.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const o2 = e2.canonical.x - (e2.canonical.x >> a2 << a2), r2 = e2.canonical.y - (e2.canonical.y >> a2 << a2), n2 = t.bc(new Float64Array(16), [1 / (t.N << a2), 1 / (t.N << a2), 0]);
              t.$(n2, n2, [o2 * t.N, r2 * t.N, 0]), this._demMatrixCache[e2.key] = { matrix: n2, coord: e2 };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: i3 && i3.dem && i3.dem.dim || 1, u_terrain_matrix: s2 ? this._demMatrixCache[e2.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i3 && i3.dem && i3.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i3 && i3.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i3 };
          }
          getFramebuffer(t4) {
            const e2 = this.painter, i3 = e2.width / devicePixelRatio, s2 = e2.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === i3 && this._fbo.height === s2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new x2(e2.context, { width: i3, height: s2, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new x2(e2.context, { width: i3, height: s2, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e2.context.createFramebuffer(i3, s2, true, false), this._fbo.depthAttachment.set(e2.context.createRenderbuffer(e2.context.gl.DEPTH_COMPONENT16, i3, s2))), this._fbo.colorAttachment.set("coords" === t4 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e2 = this.painter.context;
            if (this._coordsTexture)
              return this._coordsTexture;
            const i3 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let t4 = 0, e3 = 0; t4 < this._coordsTextureSize; t4++)
              for (let s3 = 0; s3 < this._coordsTextureSize; s3++, e3 += 4)
                i3[e3 + 0] = 255 & s3, i3[e3 + 1] = 255 & t4, i3[e3 + 2] = s3 >> 8 << 4 | t4 >> 8, i3[e3 + 3] = 0;
            const s2 = new t.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i3.buffer)), a2 = new x2(e2, s2, e2.gl.RGBA, { premultiply: false });
            return a2.bind(e2.gl.NEAREST, e2.gl.CLAMP_TO_EDGE), this._coordsTexture = a2, a2;
          }
          pointCoordinate(e2) {
            const i3 = new Uint8Array(4), s2 = this.painter.context, a2 = s2.gl;
            s2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), a2.readPixels(e2.x, this.painter.height / devicePixelRatio - e2.y - 1, 1, 1, a2.RGBA, a2.UNSIGNED_BYTE, i3), s2.bindFramebuffer.set(null);
            const o2 = i3[0] + (i3[2] >> 4 << 8), r2 = i3[1] + ((15 & i3[2]) << 8), n2 = this.coordsIndex[255 - i3[3]], l2 = n2 && this.sourceCache.getTileByID(n2);
            if (!l2)
              return null;
            const h2 = this._coordsTextureSize, c2 = (1 << l2.tileID.canonical.z) * h2;
            return new t.U(this._allowMercatorOverflow(e2, (l2.tileID.canonical.x * h2 + o2) / c2), (l2.tileID.canonical.y * h2 + r2) / c2, this.getElevation(l2.tileID, o2, r2, h2));
          }
          getTerrainMesh() {
            if (this._mesh)
              return this._mesh;
            const e2 = this.painter.context, i3 = new t.bd(), s2 = new t.b0(), a2 = this.meshSize, o2 = t.N / a2, r2 = a2 * a2;
            for (let t4 = 0; t4 <= a2; t4++)
              for (let e3 = 0; e3 <= a2; e3++)
                i3.emplaceBack(e3 * o2, t4 * o2, 0);
            for (let t4 = 0; t4 < r2; t4 += a2 + 1)
              for (let e3 = 0; e3 < a2; e3++)
                s2.emplaceBack(e3 + t4, a2 + e3 + t4 + 1, a2 + e3 + t4 + 2), s2.emplaceBack(e3 + t4, a2 + e3 + t4 + 2, e3 + t4 + 1);
            const n2 = i3.length, l2 = n2 + 2 * (a2 + 1);
            for (const e3 of [0, 1])
              for (let s3 = 0; s3 <= a2; s3++)
                for (const a3 of [0, 1])
                  i3.emplaceBack(s3 * o2, e3 * t.N, a3);
            for (let t4 = 0; t4 < 2 * a2; t4 += 2)
              s2.emplaceBack(l2 + t4, l2 + t4 + 1, l2 + t4 + 3), s2.emplaceBack(l2 + t4, l2 + t4 + 3, l2 + t4 + 2), s2.emplaceBack(n2 + t4, n2 + t4 + 3, n2 + t4 + 1), s2.emplaceBack(n2 + t4, n2 + t4 + 2, n2 + t4 + 3);
            const h2 = i3.length, c2 = h2 + 2 * (a2 + 1);
            for (const e3 of [0, 1])
              for (let s3 = 0; s3 <= a2; s3++)
                for (const a3 of [0, 1])
                  i3.emplaceBack(e3 * t.N, s3 * o2, a3);
            for (let t4 = 0; t4 < 2 * a2; t4 += 2)
              s2.emplaceBack(h2 + t4, h2 + t4 + 1, h2 + t4 + 3), s2.emplaceBack(h2 + t4, h2 + t4 + 3, h2 + t4 + 2), s2.emplaceBack(c2 + t4, c2 + t4 + 3, c2 + t4 + 1), s2.emplaceBack(c2 + t4, c2 + t4 + 2, c2 + t4 + 3);
            return this._mesh = { indexBuffer: e2.createIndexBuffer(s2), vertexBuffer: e2.createVertexBuffer(i3, ca.members), segments: t.S.simpleSegment(0, 0, i3.length, s2.length) }, this._mesh;
          }
          getMeshFrameDelta(e2) {
            return 2 * Math.PI * t.be / Math.pow(2, e2) / 5;
          }
          getMinTileElevationForLngLatZoom(t4, e2) {
            var i3;
            const { tileID: s2 } = this._getOverscaledTileIDFromLngLatZoom(t4, e2);
            return null !== (i3 = this.getMinMaxElevation(s2).minElevation) && void 0 !== i3 ? i3 : 0;
          }
          getMinMaxElevation(t4) {
            const e2 = this.getTerrainData(t4).tile, i3 = { minElevation: null, maxElevation: null };
            return e2 && e2.dem && (i3.minElevation = e2.dem.min * this.exaggeration, i3.maxElevation = e2.dem.max * this.exaggeration), i3;
          }
          _getOverscaledTileIDFromLngLatZoom(e2, i3) {
            const s2 = t.U.fromLngLat(e2.wrap()), a2 = (1 << i3) * t.N, o2 = s2.x * a2, r2 = s2.y * a2, n2 = Math.floor(o2 / t.N), l2 = Math.floor(r2 / t.N);
            return { tileID: new t.O(i3, 0, i3, n2, l2), mercatorX: o2, mercatorY: r2 };
          }
          _allowMercatorOverflow(e2, i3) {
            const s2 = e2.x < this.painter.width / 2;
            let a2 = t.bf(i3);
            const o2 = this.painter.transform.center.lng;
            return s2 && Math.sign(a2) > 0 && Math.sign(o2) < 0 || !s2 && Math.sign(a2) < 0 && Math.sign(o2) > 0 ? (a2 = 360 * Math.sign(o2) + a2, t.G(a2)) : i3;
          }
        }
        class _a2 {
          constructor(t4, e2, i3) {
            this._context = t4, this._size = e2, this._tileSize = i3, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const t4 of this._objects)
              t4.texture.destroy(), t4.fbo.destroy();
          }
          _createObject(t4) {
            const e2 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i3 = new x2(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return i3.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), e2.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), e2.colorAttachment.set(i3.texture), { id: t4, fbo: e2, texture: i3, stamp: -1, inUse: false };
          }
          getObjectForId(t4) {
            return this._objects[t4];
          }
          useObject(t4) {
            t4.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((e2) => t4.id !== e2), this._recentlyUsed.push(t4.id);
          }
          stampObject(t4) {
            t4.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const t5 of this._recentlyUsed)
              if (!this._objects[t5].inUse)
                return this._objects[t5];
            if (this._objects.length >= this._size)
              throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const t4 = this._createObject(this._objects.length);
            return this._objects.push(t4), t4;
          }
          freeObject(t4) {
            t4.inUse = false;
          }
          freeAllObjects() {
            for (const t4 of this._objects)
              this.freeObject(t4);
          }
          isFull() {
            return !(this._objects.length < this._size) && false === this._objects.some((t4) => !t4.inUse);
          }
        }
        const pa = { background: true, fill: true, line: true, raster: true, hillshade: true };
        class ma {
          constructor(t4, e2) {
            this.painter = t4, this.terrain = e2, this.pool = new _a2(t4.context, 30, e2.sourceCache.tileSize * e2.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(t4) {
            return this.pool.getObjectForId(t4.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(t4, e2) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t4._order.filter((i3) => !t4._layers[i3].isHidden(e2)), this._coordsDescendingInv = {};
            for (const e3 in t4.sourceCaches) {
              this._coordsDescendingInv[e3] = {};
              const i3 = t4.sourceCaches[e3].getVisibleCoordinates();
              for (const t5 of i3) {
                const i4 = this.terrain.sourceCache.getTerrainCoords(t5);
                for (const t6 in i4)
                  this._coordsDescendingInv[e3][t6] || (this._coordsDescendingInv[e3][t6] = []), this._coordsDescendingInv[e3][t6].push(i4[t6]);
              }
            }
            this._coordsDescendingInvStr = {};
            for (const e3 of t4._order) {
              const i3 = t4._layers[e3], s2 = i3.source;
              if (pa[i3.type] && !this._coordsDescendingInvStr[s2]) {
                this._coordsDescendingInvStr[s2] = {};
                for (const t5 in this._coordsDescendingInv[s2])
                  this._coordsDescendingInvStr[s2][t5] = this._coordsDescendingInv[s2][t5].map((t6) => t6.key).sort().join();
              }
            }
            for (const t5 of this._renderableTiles)
              for (const e3 in this._coordsDescendingInvStr) {
                const i3 = this._coordsDescendingInvStr[e3][t5.tileID.key];
                i3 && i3 !== t5.rttCoords[e3] && (t5.rtt = []);
              }
          }
          renderLayer(e2) {
            if (e2.isHidden(this.painter.transform.zoom))
              return false;
            const i3 = e2.type, s2 = this.painter, a2 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e2.id;
            if (pa[i3] && (this._prevType && pa[this._prevType] || this._stacks.push([]), this._prevType = i3, this._stacks[this._stacks.length - 1].push(e2.id), !a2))
              return true;
            if (pa[this._prevType] || pa[i3] && a2) {
              this._prevType = i3;
              const e3 = this._stacks.length - 1, a3 = this._stacks[e3] || [];
              for (const i4 of this._renderableTiles) {
                if (this.pool.isFull() && (es(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(i4), i4.rtt[e3]) {
                  const t4 = this.pool.getObjectForId(i4.rtt[e3].id);
                  if (t4.stamp === i4.rtt[e3].stamp) {
                    this.pool.useObject(t4);
                    continue;
                  }
                }
                const o2 = this.pool.getOrCreateFreeObject();
                this.pool.useObject(o2), this.pool.stampObject(o2), i4.rtt[e3] = { id: o2.id, stamp: o2.stamp }, s2.context.bindFramebuffer.set(o2.fbo.framebuffer), s2.context.clear({ color: t.aT.transparent, stencil: 0 }), s2.currentStencilSource = void 0;
                for (let t4 = 0; t4 < a3.length; t4++) {
                  const e4 = s2.style._layers[a3[t4]], r2 = e4.source ? this._coordsDescendingInv[e4.source][i4.tileID.key] : [i4.tileID];
                  s2.context.viewport.set([0, 0, o2.fbo.width, o2.fbo.height]), s2._renderTileClippingMasks(e4, r2), s2.renderLayer(s2, s2.style.sourceCaches[e4.source], e4, r2), e4.source && (i4.rttCoords[e4.source] = this._coordsDescendingInvStr[e4.source][i4.tileID.key]);
                }
              }
              return es(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), pa[i3];
            }
            return false;
          }
        }
        const fa = e, ga = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: void 0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, maxTileCacheZoomLevels: t.c.MAX_TILE_CACHE_ZOOM_LEVELS, localIdeographFontFamily: "sans-serif", transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, validateStyle: true, maxCanvasSize: [4096, 4096] }, va = (t4) => {
          t4.touchstart = t4.dragStart, t4.touchmoveWindow = t4.dragMove, t4.touchend = t4.dragEnd;
        }, xa = { showCompass: true, showZoom: true, visualizePitch: false };
        class ya {
          constructor(e2, s2, a2 = false) {
            this.mousedown = (e3) => {
              this.startMouse(t.e({}, e3, { ctrlKey: true, preventDefault: () => e3.preventDefault() }), i2.mousePos(this.element, e3)), i2.addEventListener(window, "mousemove", this.mousemove), i2.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (t4) => {
              this.moveMouse(t4, i2.mousePos(this.element, t4));
            }, this.mouseup = (t4) => {
              this.mouseRotate.dragEnd(t4), this.mousePitch && this.mousePitch.dragEnd(t4), this.offTemp();
            }, this.touchstart = (t4) => {
              1 !== t4.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = i2.touchPos(this.element, t4.targetTouches)[0], this.startTouch(t4, this._startPos), i2.addEventListener(window, "touchmove", this.touchmove, { passive: false }), i2.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (t4) => {
              1 !== t4.targetTouches.length ? this.reset() : (this._lastPos = i2.touchPos(this.element, t4.targetTouches)[0], this.moveTouch(t4, this._lastPos));
            }, this.touchend = (t4) => {
              0 === t4.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10;
            const o2 = e2.dragRotate._mouseRotate.getClickTolerance(), r2 = e2.dragRotate._mousePitch.getClickTolerance();
            this.element = s2, this.mouseRotate = As({ clickTolerance: o2, enable: true }), this.touchRotate = (({ enable: t4, clickTolerance: e3, bearingDegreesPerPixelMoved: i3 = 0.8 }) => {
              const s3 = new zs();
              return new Ps({ clickTolerance: e3, move: (t5, e4) => ({ bearingDelta: (e4.x - t5.x) * i3 }), moveStateManager: s3, enable: t4, assignEvents: va });
            })({ clickTolerance: o2, enable: true }), this.map = e2, a2 && (this.mousePitch = Rs({ clickTolerance: r2, enable: true }), this.touchPitch = (({ enable: t4, clickTolerance: e3, pitchDegreesPerPixelMoved: i3 = -0.5 }) => {
              const s3 = new zs();
              return new Ps({ clickTolerance: e3, move: (t5, e4) => ({ pitchDelta: (e4.y - t5.y) * i3 }), moveStateManager: s3, enable: t4, assignEvents: va });
            })({ clickTolerance: r2, enable: true })), i2.addEventListener(s2, "mousedown", this.mousedown), i2.addEventListener(s2, "touchstart", this.touchstart, { passive: false }), i2.addEventListener(s2, "touchcancel", this.reset);
          }
          startMouse(t4, e2) {
            this.mouseRotate.dragStart(t4, e2), this.mousePitch && this.mousePitch.dragStart(t4, e2), i2.disableDrag();
          }
          startTouch(t4, e2) {
            this.touchRotate.dragStart(t4, e2), this.touchPitch && this.touchPitch.dragStart(t4, e2), i2.disableDrag();
          }
          moveMouse(t4, e2) {
            const i3 = this.map, { bearingDelta: s2 } = this.mouseRotate.dragMove(t4, e2) || {};
            if (s2 && i3.setBearing(i3.getBearing() + s2), this.mousePitch) {
              const { pitchDelta: s3 } = this.mousePitch.dragMove(t4, e2) || {};
              s3 && i3.setPitch(i3.getPitch() + s3);
            }
          }
          moveTouch(t4, e2) {
            const i3 = this.map, { bearingDelta: s2 } = this.touchRotate.dragMove(t4, e2) || {};
            if (s2 && i3.setBearing(i3.getBearing() + s2), this.touchPitch) {
              const { pitchDelta: s3 } = this.touchPitch.dragMove(t4, e2) || {};
              s3 && i3.setPitch(i3.getPitch() + s3);
            }
          }
          off() {
            const t4 = this.element;
            i2.removeEventListener(t4, "mousedown", this.mousedown), i2.removeEventListener(t4, "touchstart", this.touchstart, { passive: false }), i2.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), i2.removeEventListener(window, "touchend", this.touchend), i2.removeEventListener(t4, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            i2.enableDrag(), i2.removeEventListener(window, "mousemove", this.mousemove), i2.removeEventListener(window, "mouseup", this.mouseup), i2.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), i2.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let ba;
        function wa(e2, i3, s2) {
          if (e2 = new t.L(e2.lng, e2.lat), i3) {
            const a2 = new t.L(e2.lng - 360, e2.lat), o2 = new t.L(e2.lng + 360, e2.lat), r2 = s2.locationPoint(e2).distSqr(i3);
            s2.locationPoint(a2).distSqr(i3) < r2 ? e2 = a2 : s2.locationPoint(o2).distSqr(i3) < r2 && (e2 = o2);
          }
          for (; Math.abs(e2.lng - s2.center.lng) > 180; ) {
            const t4 = s2.locationPoint(e2);
            if (t4.x >= 0 && t4.y >= 0 && t4.x <= s2.width && t4.y <= s2.height)
              break;
            e2.lng > s2.center.lng ? e2.lng -= 360 : e2.lng += 360;
          }
          return e2;
        }
        const Ta = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function Ia(t4, e2, i3) {
          const s2 = t4.classList;
          for (const t5 in Ta)
            s2.remove(`maplibregl-${i3}-anchor-${t5}`);
          s2.add(`maplibregl-${i3}-anchor-${e2}`);
        }
        class Ea extends t.E {
          constructor(e2) {
            if (super(), this._onKeyPress = (t4) => {
              const e3 = t4.code, i3 = t4.charCode || t4.keyCode;
              "Space" !== e3 && "Enter" !== e3 && 32 !== i3 && 13 !== i3 || this.togglePopup();
            }, this._onMapClick = (t4) => {
              const e3 = t4.originalEvent.target, i3 = this._element;
              this._popup && (e3 === i3 || i3.contains(e3)) && this.togglePopup();
            }, this._update = (t4) => {
              if (!this._map)
                return;
              const e3 = this._map.loaded() && !this._map.isMoving();
              ("terrain" === (null == t4 ? void 0 : t4.type) || "render" === (null == t4 ? void 0 : t4.type) && !e3) && this._map.once("render", this._update), this._map.transform.renderWorldCopies && (this._lngLat = wa(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
              let s2 = "";
              "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? s2 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (s2 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let a2 = "";
              "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? a2 = "rotateX(0deg)" : "map" === this._pitchAlignment && (a2 = `rotateX(${this._map.getPitch()}deg)`), t4 && "moveend" !== t4.type || (this._pos = this._pos.round()), i2.setTransform(this._element, `${Ta[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${a2} ${s2}`), this._map.terrain && !this._opacityTimeout && (this._opacityTimeout = setTimeout(() => {
                const t5 = this._map.unproject(this._pos), e4 = 40075016686e-3 * Math.abs(Math.cos(this._lngLat.lat * Math.PI / 180)) / Math.pow(2, this._map.transform.tileZoom + 8);
                this._element.style.opacity = t5.distanceTo(this._lngLat) > 20 * e4 ? "0.2" : "1.0", this._opacityTimeout = null;
              }, 100));
            }, this._onMove = (e3) => {
              if (!this._isDragging) {
                const t4 = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = e3.point.dist(this._pointerdownPos) >= t4;
              }
              this._isDragging && (this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.k("dragstart"))), this.fire(new t.k("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.k("dragend")), this._state = "inactive";
            }, this._addDragHandler = (t4) => {
              this._element.contains(t4.originalEvent.target) && (t4.preventDefault(), this._positionDelta = t4.point.sub(this._pos).add(this._offset), this._pointerdownPos = t4.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e2 && e2.anchor || "center", this._color = e2 && e2.color || "#3FB1CE", this._scale = e2 && e2.scale || 1, this._draggable = e2 && e2.draggable || false, this._clickTolerance = e2 && e2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = e2 && e2.rotation || 0, this._rotationAlignment = e2 && e2.rotationAlignment || "auto", this._pitchAlignment = e2 && e2.pitchAlignment && "auto" !== e2.pitchAlignment ? e2.pitchAlignment : this._rotationAlignment, e2 && e2.element)
              this._element = e2.element, this._offset = t.P.convert(e2 && e2.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = i2.create("div"), this._element.setAttribute("aria-label", "Map marker");
              const s2 = i2.createNS("http://www.w3.org/2000/svg", "svg"), a2 = 41, o2 = 27;
              s2.setAttributeNS(null, "display", "block"), s2.setAttributeNS(null, "height", `${a2}px`), s2.setAttributeNS(null, "width", `${o2}px`), s2.setAttributeNS(null, "viewBox", `0 0 ${o2} ${a2}`);
              const r2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              r2.setAttributeNS(null, "stroke", "none"), r2.setAttributeNS(null, "stroke-width", "1"), r2.setAttributeNS(null, "fill", "none"), r2.setAttributeNS(null, "fill-rule", "evenodd");
              const n2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              n2.setAttributeNS(null, "fill-rule", "nonzero");
              const l2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
              const h2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const t4 of h2) {
                const e3 = i2.createNS("http://www.w3.org/2000/svg", "ellipse");
                e3.setAttributeNS(null, "opacity", "0.04"), e3.setAttributeNS(null, "cx", "10.5"), e3.setAttributeNS(null, "cy", "5.80029008"), e3.setAttributeNS(null, "rx", t4.rx), e3.setAttributeNS(null, "ry", t4.ry), l2.appendChild(e3);
              }
              const c2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              c2.setAttributeNS(null, "fill", this._color);
              const u2 = i2.createNS("http://www.w3.org/2000/svg", "path");
              u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c2.appendChild(u2);
              const d2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
              const _2 = i2.createNS("http://www.w3.org/2000/svg", "path");
              _2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(_2);
              const p2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              p2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p2.setAttributeNS(null, "fill", "#FFFFFF");
              const m2 = i2.createNS("http://www.w3.org/2000/svg", "g");
              m2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const f2 = i2.createNS("http://www.w3.org/2000/svg", "circle");
              f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
              const g2 = i2.createNS("http://www.w3.org/2000/svg", "circle");
              g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), m2.appendChild(f2), m2.appendChild(g2), n2.appendChild(l2), n2.appendChild(c2), n2.appendChild(d2), n2.appendChild(p2), n2.appendChild(m2), s2.appendChild(n2), s2.setAttributeNS(null, "height", a2 * this._scale + "px"), s2.setAttributeNS(null, "width", o2 * this._scale + "px"), this._element.appendChild(s2), this._offset = t.P.convert(e2 && e2.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (t4) => {
              t4.preventDefault();
            }), this._element.addEventListener("mousedown", (t4) => {
              t4.preventDefault();
            }), Ia(this._element, this._anchor, "marker"), e2 && e2.className)
              for (const t4 of e2.className.split(" "))
                this._element.classList.add(t4);
            this._popup = null;
          }
          addTo(t4) {
            return this.remove(), this._map = t4, t4.getCanvasContainer().appendChild(this._element), t4.on("move", this._update), t4.on("moveend", this._update), t4.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i2.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e2) {
            return this._lngLat = t.L.convert(e2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(t4) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t4) {
              if (!("offset" in t4.options)) {
                const e2 = 38.1, i3 = 13.5, s2 = Math.abs(i3) / Math.SQRT2;
                t4.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -e2], "bottom-left": [s2, -1 * (e2 - i3 + s2)], "bottom-right": [-s2, -1 * (e2 - i3 + s2)], left: [i3, -1 * (e2 - i3)], right: [-i3, -1 * (e2 - i3)] } : this._offset;
              }
              this._popup = t4, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const t4 = this._popup;
            return t4 ? (t4.isOpen() ? t4.remove() : t4.addTo(this._map), this) : this;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e2) {
            return this._offset = t.P.convert(e2), this._update(), this;
          }
          addClassName(t4) {
            this._element.classList.add(t4);
          }
          removeClassName(t4) {
            this._element.classList.remove(t4);
          }
          toggleClassName(t4) {
            return this._element.classList.toggle(t4);
          }
          setDraggable(t4) {
            return this._draggable = !!t4, this._map && (t4 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t4) {
            return this._rotation = t4 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t4) {
            return this._rotationAlignment = t4 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(t4) {
            return this._pitchAlignment = t4 && "auto" !== t4 ? t4 : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
        }
        const Sa = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let Ca = 0, Pa = false;
        const Da = { maxWidth: 100, unit: "metric" };
        function Ma(t4, e2, i3) {
          const s2 = i3 && i3.maxWidth || 100, a2 = t4._container.clientHeight / 2, o2 = t4.unproject([0, a2]), r2 = t4.unproject([s2, a2]), n2 = o2.distanceTo(r2);
          if (i3 && "imperial" === i3.unit) {
            const i4 = 3.2808 * n2;
            i4 > 5280 ? za(e2, s2, i4 / 5280, t4._getUIString("ScaleControl.Miles")) : za(e2, s2, i4, t4._getUIString("ScaleControl.Feet"));
          } else
            i3 && "nautical" === i3.unit ? za(e2, s2, n2 / 1852, t4._getUIString("ScaleControl.NauticalMiles")) : n2 >= 1e3 ? za(e2, s2, n2 / 1e3, t4._getUIString("ScaleControl.Kilometers")) : za(e2, s2, n2, t4._getUIString("ScaleControl.Meters"));
        }
        function za(t4, e2, i3, s2) {
          const a2 = function(t5) {
            const e3 = Math.pow(10, `${Math.floor(t5)}`.length - 1);
            let i4 = t5 / e3;
            return i4 = i4 >= 10 ? 10 : i4 >= 5 ? 5 : i4 >= 3 ? 3 : i4 >= 2 ? 2 : i4 >= 1 ? 1 : function(t6) {
              const e4 = Math.pow(10, Math.ceil(-Math.log(t6) / Math.LN10));
              return Math.round(t6 * e4) / e4;
            }(i4), e3 * i4;
          }(i3);
          t4.style.width = e2 * (a2 / i3) + "px", t4.innerHTML = `${a2}&nbsp;${s2}`;
        }
        const La = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, Aa = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function Ra(e2) {
          if (e2) {
            if ("number" == typeof e2) {
              const i3 = Math.round(Math.abs(e2) / Math.SQRT2);
              return { center: new t.P(0, 0), top: new t.P(0, e2), "top-left": new t.P(i3, i3), "top-right": new t.P(-i3, i3), bottom: new t.P(0, -e2), "bottom-left": new t.P(i3, -i3), "bottom-right": new t.P(-i3, -i3), left: new t.P(e2, 0), right: new t.P(-e2, 0) };
            }
            if (e2 instanceof t.P || Array.isArray(e2)) {
              const i3 = t.P.convert(e2);
              return { center: i3, top: i3, "top-left": i3, "top-right": i3, bottom: i3, "bottom-left": i3, "bottom-right": i3, left: i3, right: i3 };
            }
            return { center: t.P.convert(e2.center || [0, 0]), top: t.P.convert(e2.top || [0, 0]), "top-left": t.P.convert(e2["top-left"] || [0, 0]), "top-right": t.P.convert(e2["top-right"] || [0, 0]), bottom: t.P.convert(e2.bottom || [0, 0]), "bottom-left": t.P.convert(e2["bottom-left"] || [0, 0]), "bottom-right": t.P.convert(e2["bottom-right"] || [0, 0]), left: t.P.convert(e2.left || [0, 0]), right: t.P.convert(e2.right || [0, 0]) };
          }
          return Ra(new t.P(0, 0));
        }
        const ka = { extend: (e2, ...i3) => t.e(e2, ...i3), run(t4) {
          t4();
        }, logToElement(t4, e2 = false, i3 = "log") {
          const s2 = window.document.getElementById(i3);
          s2 && (e2 && (s2.innerHTML = ""), s2.innerHTML += `<br>${t4}`);
        } }, Fa = e;
        class Ba {
          static get version() {
            return Fa;
          }
          static get workerCount() {
            return tt.workerCount;
          }
          static set workerCount(t4) {
            tt.workerCount = t4;
          }
          static get maxParallelImageRequests() {
            return t.c.MAX_PARALLEL_IMAGE_REQUESTS;
          }
          static set maxParallelImageRequests(e2) {
            t.c.MAX_PARALLEL_IMAGE_REQUESTS = e2;
          }
          static get workerUrl() {
            return t.c.WORKER_URL;
          }
          static set workerUrl(e2) {
            t.c.WORKER_URL = e2;
          }
          static addProtocol(e2, i3) {
            t.c.REGISTERED_PROTOCOLS[e2] = i3;
          }
          static removeProtocol(e2) {
            delete t.c.REGISTERED_PROTOCOLS[e2];
          }
        }
        return Ba.Map = class extends oa {
          constructor(e2) {
            if (t.bg.mark(t.bh.create), null != (e2 = t.e({}, ga, e2)).minZoom && null != e2.maxZoom && e2.minZoom > e2.maxZoom)
              throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != e2.minPitch && null != e2.maxPitch && e2.minPitch > e2.maxPitch)
              throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != e2.minPitch && e2.minPitch < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (null != e2.maxPitch && e2.maxPitch > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (super(new rs(e2.minZoom, e2.maxZoom, e2.minPitch, e2.maxPitch, e2.renderWorldCopies), { bearingSnap: e2.bearingSnap }), this._cooperativeGesturesOnWheel = (t4) => {
              this._onCooperativeGesture(t4, t4[this._metaKey], 1);
            }, this._contextLost = (e3) => {
              e3.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.k("webglcontextlost", { originalEvent: e3 }));
            }, this._contextRestored = (e3) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new t.k("webglcontextrestored", { originalEvent: e3 }));
            }, this._onMapScroll = (t4) => {
              if (t4.target === this._container)
                return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = e2.interactive, this._cooperativeGestures = e2.cooperativeGestures, this._metaKey = 0 === navigator.platform.indexOf("Mac") ? "metaKey" : "ctrlKey", this._maxTileCacheSize = e2.maxTileCacheSize, this._maxTileCacheZoomLevels = e2.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = e2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e2.preserveDrawingBuffer, this._antialias = e2.antialias, this._trackResize = e2.trackResize, this._bearingSnap = e2.bearingSnap, this._refreshExpiredTiles = e2.refreshExpiredTiles, this._fadeDuration = e2.fadeDuration, this._crossSourceCollisions = e2.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e2.collectResourceTiming, this._renderTaskQueue = new la(), this._controls = [], this._mapId = t.a2(), this._locale = t.e({}, ha, e2.locale), this._clickTolerance = e2.clickTolerance, this._overridePixelRatio = e2.pixelRatio, this._maxCanvasSize = e2.maxCanvasSize, this.transformCameraUpdate = e2.transformCameraUpdate, this._imageQueueHandle = h.addThrottleControl(() => this.isMoving()), this._requestManager = new u(e2.transformRequest), "string" == typeof e2.container) {
              if (this._container = document.getElementById(e2.container), !this._container)
                throw new Error(`Container '${e2.container}' not found.`);
            } else {
              if (!(e2.container instanceof HTMLElement))
                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = e2.container;
            }
            if (e2.maxBounds && this.setMaxBounds(e2.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            }), this.once("idle", () => {
              this._idleTriggered = true;
            }), "undefined" != typeof window) {
              addEventListener("online", this._onWindowOnline, false);
              let t4 = false;
              const e3 = ns((t5) => {
                this._trackResize && !this._removed && this.resize(t5)._update();
              }, 50);
              this._resizeObserver = new ResizeObserver((i3) => {
                t4 ? e3(i3) : t4 = true;
              }), this._resizeObserver.observe(this._container);
            }
            this.handlers = new aa(this, e2), this._cooperativeGestures && this._setupCooperativeGestures(), this._hash = e2.hash && new ls("string" == typeof e2.hash && e2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e2.center, zoom: e2.zoom, bearing: e2.bearing, pitch: e2.pitch }), e2.bounds && (this.resize(), this.fitBounds(e2.bounds, t.e({}, e2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e2.localIdeographFontFamily, this._validateStyle = e2.validateStyle, e2.style && this.setStyle(e2.style, { localIdeographFontFamily: e2.localIdeographFontFamily }), e2.attributionControl && this.addControl(new ra({ customAttribution: e2.customAttribution })), e2.maplibreLogo && this.addControl(new na(), e2.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet);
            }), this.on("data", (e3) => {
              this._update("style" === e3.dataType), this.fire(new t.k(`${e3.dataType}data`, e3));
            }), this.on("dataloading", (e3) => {
              this.fire(new t.k(`${e3.dataType}dataloading`, e3));
            }), this.on("dataabort", (e3) => {
              this.fire(new t.k("sourcedataabort", e3));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(e2, i3) {
            if (void 0 === i3 && (i3 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd)
              return this.fire(new t.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const s2 = e2.onAdd(this);
            this._controls.push(e2);
            const a2 = this._controlPositions[i3];
            return -1 !== i3.indexOf("bottom") ? a2.insertBefore(s2, a2.firstChild) : a2.appendChild(s2), this;
          }
          removeControl(e2) {
            if (!e2 || !e2.onRemove)
              return this.fire(new t.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i3 = this._controls.indexOf(e2);
            return i3 > -1 && this._controls.splice(i3, 1), e2.onRemove(this), this;
          }
          hasControl(t4) {
            return this._controls.indexOf(t4) > -1;
          }
          calculateCameraOptionsFromTo(t4, e2, i3, s2) {
            return null == s2 && this.terrain && (s2 = this.terrain.getElevationForLngLatZoom(i3, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(t4, e2, i3, s2);
          }
          resize(e2) {
            var i3;
            const s2 = this._containerDimensions(), a2 = s2[0], o2 = s2[1], r2 = this._getClampedPixelRatio(a2, o2);
            if (this._resizeCanvas(a2, o2, r2), this.painter.resize(a2, o2, r2), this.painter.overLimit()) {
              const t4 = this.painter.context.gl;
              this._maxCanvasSize = [t4.drawingBufferWidth, t4.drawingBufferHeight];
              const e3 = this._getClampedPixelRatio(a2, o2);
              this._resizeCanvas(a2, o2, e3), this.painter.resize(a2, o2, e3);
            }
            this.transform.resize(a2, o2), null === (i3 = this._requestedCameraState) || void 0 === i3 || i3.resize(a2, o2);
            const n2 = !this._moving;
            return n2 && (this.stop(), this.fire(new t.k("movestart", e2)).fire(new t.k("move", e2))), this.fire(new t.k("resize", e2)), n2 && this.fire(new t.k("moveend", e2)), this;
          }
          _getClampedPixelRatio(t4, e2) {
            const { 0: i3, 1: s2 } = this._maxCanvasSize, a2 = this.getPixelRatio(), o2 = t4 * a2, r2 = e2 * a2;
            return Math.min(o2 > i3 ? i3 / o2 : 1, r2 > s2 ? s2 / r2 : 1) * a2;
          }
          getPixelRatio() {
            var t4;
            return null !== (t4 = this._overridePixelRatio) && void 0 !== t4 ? t4 : devicePixelRatio;
          }
          setPixelRatio(t4) {
            this._overridePixelRatio = t4, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(t4) {
            return this.transform.setMaxBounds(L2.convert(t4)), this._update();
          }
          setMinZoom(t4) {
            if ((t4 = null == t4 ? -2 : t4) >= -2 && t4 <= this.transform.maxZoom)
              return this.transform.minZoom = t4, this._update(), this.getZoom() < t4 && this.setZoom(t4), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t4) {
            if ((t4 = null == t4 ? 22 : t4) >= this.transform.minZoom)
              return this.transform.maxZoom = t4, this._update(), this.getZoom() > t4 && this.setZoom(t4), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t4) {
            if ((t4 = null == t4 ? 0 : t4) < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (t4 >= 0 && t4 <= this.transform.maxPitch)
              return this.transform.minPitch = t4, this._update(), this.getPitch() < t4 && this.setPitch(t4), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t4) {
            if ((t4 = null == t4 ? 60 : t4) > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t4 >= this.transform.minPitch)
              return this.transform.maxPitch = t4, this._update(), this.getPitch() > t4 && this.setPitch(t4), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(t4) {
            return this.transform.renderWorldCopies = t4, this._update();
          }
          getCooperativeGestures() {
            return this._cooperativeGestures;
          }
          setCooperativeGestures(t4) {
            return this._cooperativeGestures = t4, this._cooperativeGestures ? this._setupCooperativeGestures() : this._destroyCooperativeGestures(), this;
          }
          project(e2) {
            return this.transform.locationPoint(t.L.convert(e2), this.style && this.terrain);
          }
          unproject(e2) {
            return this.transform.pointLocation(t.P.convert(e2), this.terrain);
          }
          isMoving() {
            var t4;
            return this._moving || (null === (t4 = this.handlers) || void 0 === t4 ? void 0 : t4.isMoving());
          }
          isZooming() {
            var t4;
            return this._zooming || (null === (t4 = this.handlers) || void 0 === t4 ? void 0 : t4.isZooming());
          }
          isRotating() {
            var t4;
            return this._rotating || (null === (t4 = this.handlers) || void 0 === t4 ? void 0 : t4.isRotating());
          }
          _createDelegatedListener(t4, e2, i3) {
            if ("mouseenter" === t4 || "mouseover" === t4) {
              let s2 = false;
              const a2 = (a3) => {
                const o2 = this.getLayer(e2) ? this.queryRenderedFeatures(a3.point, { layers: [e2] }) : [];
                o2.length ? s2 || (s2 = true, i3.call(this, new gs(t4, this, a3.originalEvent, { features: o2 }))) : s2 = false;
              };
              return { layer: e2, listener: i3, delegates: { mousemove: a2, mouseout: () => {
                s2 = false;
              } } };
            }
            if ("mouseleave" === t4 || "mouseout" === t4) {
              let s2 = false;
              const a2 = (a3) => {
                (this.getLayer(e2) ? this.queryRenderedFeatures(a3.point, { layers: [e2] }) : []).length ? s2 = true : s2 && (s2 = false, i3.call(this, new gs(t4, this, a3.originalEvent)));
              }, o2 = (e3) => {
                s2 && (s2 = false, i3.call(this, new gs(t4, this, e3.originalEvent)));
              };
              return { layer: e2, listener: i3, delegates: { mousemove: a2, mouseout: o2 } };
            }
            {
              const s2 = (t5) => {
                const s3 = this.getLayer(e2) ? this.queryRenderedFeatures(t5.point, { layers: [e2] }) : [];
                s3.length && (t5.features = s3, i3.call(this, t5), delete t5.features);
              };
              return { layer: e2, listener: i3, delegates: { [t4]: s2 } };
            }
          }
          on(t4, e2, i3) {
            if (void 0 === i3)
              return super.on(t4, e2);
            const s2 = this._createDelegatedListener(t4, e2, i3);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t4] = this._delegatedListeners[t4] || [], this._delegatedListeners[t4].push(s2);
            for (const t5 in s2.delegates)
              this.on(t5, s2.delegates[t5]);
            return this;
          }
          once(t4, e2, i3) {
            if (void 0 === i3)
              return super.once(t4, e2);
            const s2 = this._createDelegatedListener(t4, e2, i3);
            for (const t5 in s2.delegates)
              this.once(t5, s2.delegates[t5]);
            return this;
          }
          off(t4, e2, i3) {
            return void 0 === i3 ? super.off(t4, e2) : (this._delegatedListeners && this._delegatedListeners[t4] && ((s2) => {
              const a2 = this._delegatedListeners[t4];
              for (let t5 = 0; t5 < a2.length; t5++) {
                const s3 = a2[t5];
                if (s3.layer === e2 && s3.listener === i3) {
                  for (const t6 in s3.delegates)
                    this.off(t6, s3.delegates[t6]);
                  return a2.splice(t5, 1), this;
                }
              }
            })(), this);
          }
          queryRenderedFeatures(e2, i3) {
            if (!this.style)
              return [];
            let s2;
            const a2 = e2 instanceof t.P || Array.isArray(e2), o2 = a2 ? e2 : [[0, 0], [this.transform.width, this.transform.height]];
            if (i3 = i3 || (a2 ? {} : e2) || {}, o2 instanceof t.P || "number" == typeof o2[0])
              s2 = [t.P.convert(o2)];
            else {
              const e3 = t.P.convert(o2[0]), i4 = t.P.convert(o2[1]);
              s2 = [e3, new t.P(i4.x, e3.y), i4, new t.P(e3.x, i4.y), e3];
            }
            return this.style.queryRenderedFeatures(s2, i3, this.transform);
          }
          querySourceFeatures(t4, e2) {
            return this.style.querySourceFeatures(t4, e2);
          }
          setStyle(e2, i3) {
            return false !== (i3 = t.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i3)).diff && i3.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i3), this) : (this._localIdeographFontFamily = i3.localIdeographFontFamily, this._updateStyle(e2, i3));
          }
          setTransformRequest(t4) {
            return this._requestManager.setTransformRequest(t4), this;
          }
          _getUIString(t4) {
            const e2 = this._locale[t4];
            if (null == e2)
              throw new Error(`Missing UI string '${t4}'`);
            return e2;
          }
          _updateStyle(t4, e2) {
            if (e2.transformStyle && this.style && !this.style._loaded)
              return void this.style.once("style.load", () => this._updateStyle(t4, e2));
            const i3 = this.style && e2.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!t4)), t4 ? (this.style = new se(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t4 ? this.style.loadURL(t4, e2, i3) : this.style.loadJSON(t4, e2, i3), this) : (delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new se(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(e2, i3) {
            if ("string" == typeof e2) {
              const s2 = this._requestManager.transformRequest(e2, c.Style);
              t.f(s2, (e3, s3) => {
                e3 ? this.fire(new t.j(e3)) : s3 && this._updateDiff(s3, i3);
              });
            } else
              "object" == typeof e2 && this._updateDiff(e2, i3);
          }
          _updateDiff(e2, i3) {
            try {
              this.style.setState(e2, i3) && this._update(true);
            } catch (s2) {
              t.w(`Unable to perform style diff: ${s2.message || s2.error || s2}.  Rebuilding the style from scratch.`), this._updateStyle(e2, i3);
            }
          }
          getStyle() {
            if (this.style)
              return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : t.w("There is no style added to the map.");
          }
          addSource(t4, e2) {
            return this._lazyInitEmptyStyle(), this.style.addSource(t4, e2), this._update(true);
          }
          isSourceLoaded(e2) {
            const i3 = this.style && this.style.sourceCaches[e2];
            if (void 0 !== i3)
              return i3.loaded();
            this.fire(new t.j(new Error(`There is no source with ID '${e2}'`)));
          }
          setTerrain(e2) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e2) {
              const i3 = this.style.sourceCaches[e2.source];
              if (!i3)
                throw new Error(`cannot load terrain, because there exists no source with ID: ${e2.source}`);
              for (const i4 in this.style._layers) {
                const s2 = this.style._layers[i4];
                "hillshade" === s2.type && s2.source === e2.source && t.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new da(this.painter, i3, e2), this.painter.renderToTexture = new ma(this.painter, this.terrain), this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (t4) => {
                "style" === t4.dataType ? this.terrain.sourceCache.freeRtt() : "source" === t4.dataType && t4.tile && (t4.sourceId !== e2.source || this._elevationFreeze || (this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(t4.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else
              this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform._minEleveationForCurrentTile = 0, this.transform.elevation = 0;
            return this.fire(new t.k("terrain", { terrain: e2 })), this;
          }
          getTerrain() {
            var t4, e2;
            return null !== (e2 = null === (t4 = this.terrain) || void 0 === t4 ? void 0 : t4.options) && void 0 !== e2 ? e2 : null;
          }
          areTilesLoaded() {
            const t4 = this.style && this.style.sourceCaches;
            for (const e2 in t4) {
              const i3 = t4[e2]._tiles;
              for (const t5 in i3) {
                const e3 = i3[t5];
                if ("loaded" !== e3.state && "errored" !== e3.state)
                  return false;
              }
            }
            return true;
          }
          addSourceType(t4, e2, i3) {
            return this._lazyInitEmptyStyle(), this.style.addSourceType(t4, e2, i3);
          }
          removeSource(t4) {
            return this.style.removeSource(t4), this._update(true);
          }
          getSource(t4) {
            return this.style.getSource(t4);
          }
          addImage(e2, i3, s2 = {}) {
            const { pixelRatio: a2 = 1, sdf: o2 = false, stretchX: r2, stretchY: n2, content: l2 } = s2;
            if (this._lazyInitEmptyStyle(), !(i3 instanceof HTMLImageElement || t.a(i3))) {
              if (void 0 === i3.width || void 0 === i3.height)
                return this.fire(new t.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: s3, height: h2, data: c2 } = i3, u2 = i3;
                return this.style.addImage(e2, { data: new t.R({ width: s3, height: h2 }, new Uint8Array(c2)), pixelRatio: a2, stretchX: r2, stretchY: n2, content: l2, sdf: o2, version: 0, userImage: u2 }), u2.onAdd && u2.onAdd(this, e2), this;
              }
            }
            {
              const { width: s3, height: h2, data: c2 } = t.h.getImageData(i3);
              this.style.addImage(e2, { data: new t.R({ width: s3, height: h2 }, c2), pixelRatio: a2, stretchX: r2, stretchY: n2, content: l2, sdf: o2, version: 0 });
            }
          }
          updateImage(e2, i3) {
            const s2 = this.style.getImage(e2);
            if (!s2)
              return this.fire(new t.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const a2 = i3 instanceof HTMLImageElement || t.a(i3) ? t.h.getImageData(i3) : i3, { width: o2, height: r2, data: n2 } = a2;
            if (void 0 === o2 || void 0 === r2)
              return this.fire(new t.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (o2 !== s2.data.width || r2 !== s2.data.height)
              return this.fire(new t.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const l2 = !(i3 instanceof HTMLImageElement || t.a(i3));
            return s2.data.replace(n2, l2), this.style.updateImage(e2, s2), this;
          }
          getImage(t4) {
            return this.style.getImage(t4);
          }
          hasImage(e2) {
            return e2 ? !!this.style.getImage(e2) : (this.fire(new t.j(new Error("Missing required image id"))), false);
          }
          removeImage(t4) {
            this.style.removeImage(t4);
          }
          loadImage(t4, e2) {
            h.getImage(this._requestManager.transformRequest(t4, c.Image), e2);
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(t4, e2) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(t4, e2), this._update(true);
          }
          moveLayer(t4, e2) {
            return this.style.moveLayer(t4, e2), this._update(true);
          }
          removeLayer(t4) {
            return this.style.removeLayer(t4), this._update(true);
          }
          getLayer(t4) {
            return this.style.getLayer(t4);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(t4, e2, i3) {
            return this.style.setLayerZoomRange(t4, e2, i3), this._update(true);
          }
          setFilter(t4, e2, i3 = {}) {
            return this.style.setFilter(t4, e2, i3), this._update(true);
          }
          getFilter(t4) {
            return this.style.getFilter(t4);
          }
          setPaintProperty(t4, e2, i3, s2 = {}) {
            return this.style.setPaintProperty(t4, e2, i3, s2), this._update(true);
          }
          getPaintProperty(t4, e2) {
            return this.style.getPaintProperty(t4, e2);
          }
          setLayoutProperty(t4, e2, i3, s2 = {}) {
            return this.style.setLayoutProperty(t4, e2, i3, s2), this._update(true);
          }
          getLayoutProperty(t4, e2) {
            return this.style.getLayoutProperty(t4, e2);
          }
          setGlyphs(t4, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(t4, e2), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(t4, e2, i3 = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(t4, e2, i3, (t5) => {
              t5 || this._update(true);
            }), this;
          }
          removeSprite(t4) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(t4), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(t4, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(t4, e2, (t5) => {
              t5 || this._update(true);
            }), this;
          }
          setLight(t4, e2 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(t4, e2), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setFeatureState(t4, e2) {
            return this.style.setFeatureState(t4, e2), this._update();
          }
          removeFeatureState(t4, e2) {
            return this.style.removeFeatureState(t4, e2), this._update();
          }
          getFeatureState(t4) {
            return this.style.getFeatureState(t4);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let t4 = 0, e2 = 0;
            return this._container && (t4 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t4, e2];
          }
          _setupContainer() {
            const t4 = this._container;
            t4.classList.add("maplibregl-map");
            const e2 = this._canvasContainer = i2.create("div", "maplibregl-canvas-container", t4);
            this._interactive && e2.classList.add("maplibregl-interactive"), this._canvas = i2.create("canvas", "maplibregl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
            const s2 = this._containerDimensions(), a2 = this._getClampedPixelRatio(s2[0], s2[1]);
            this._resizeCanvas(s2[0], s2[1], a2);
            const o2 = this._controlContainer = i2.create("div", "maplibregl-control-container", t4), r2 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t5) => {
              r2[t5] = i2.create("div", `maplibregl-ctrl-${t5} `, o2);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _setupCooperativeGestures() {
            this._cooperativeGesturesScreen = i2.create("div", "maplibregl-cooperative-gesture-screen", this._container);
            let t4 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.windowsHelpText ? this._cooperativeGestures.windowsHelpText : "Use Ctrl + scroll to zoom the map";
            0 === navigator.platform.indexOf("Mac") && (t4 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.macHelpText ? this._cooperativeGestures.macHelpText : "Use ⌘ + scroll to zoom the map"), this._cooperativeGesturesScreen.innerHTML = `
            <div class="maplibregl-desktop-message">${t4}</div>
            <div class="maplibregl-mobile-message">${"boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.mobileHelpText ? this._cooperativeGestures.mobileHelpText : "Use two fingers to move the map"}</div>
        `, this._cooperativeGesturesScreen.setAttribute("aria-hidden", "true"), this._canvasContainer.addEventListener("wheel", this._cooperativeGesturesOnWheel, false), this._canvasContainer.classList.add("maplibregl-cooperative-gestures");
          }
          _destroyCooperativeGestures() {
            i2.remove(this._cooperativeGesturesScreen), this._canvasContainer.removeEventListener("wheel", this._cooperativeGesturesOnWheel, false), this._canvasContainer.classList.remove("maplibregl-cooperative-gestures");
          }
          _resizeCanvas(t4, e2, i3) {
            this._canvas.width = Math.floor(i3 * t4), this._canvas.height = Math.floor(i3 * e2), this._canvas.style.width = `${t4}px`, this._canvas.style.height = `${e2}px`;
          }
          _setupPainter() {
            const t4 = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false };
            let e2 = null;
            this._canvas.addEventListener("webglcontextcreationerror", (i4) => {
              e2 = { requestedAttributes: t4 }, i4 && (e2.statusMessage = i4.statusMessage, e2.type = i4.type);
            }, { once: true });
            const i3 = this._canvas.getContext("webgl2", t4) || this._canvas.getContext("webgl", t4);
            if (!i3) {
              const t5 = "Failed to initialize WebGL";
              throw e2 ? (e2.message = t5, new Error(JSON.stringify(e2))) : new Error(t5);
            }
            this.painter = new is(i3, this.transform), s.testSupport(i3);
          }
          _onCooperativeGesture(t4, e2, i3) {
            return !e2 && i3 < 2 && (this._cooperativeGesturesScreen.classList.add("maplibregl-show"), setTimeout(() => {
              this._cooperativeGesturesScreen.classList.remove("maplibregl-show");
            }, 100)), false;
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(t4) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || t4, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(t4) {
            return this._update(), this._renderTaskQueue.add(t4);
          }
          _cancelRenderFrame(t4) {
            this._renderTaskQueue.remove(t4);
          }
          _render(e2) {
            const i3 = this._idleTriggered ? this._fadeDuration : 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), this._removed)
              return;
            let s2 = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const e3 = this.transform.zoom, a3 = t.h.now();
              this.style.zoomHistory.update(e3, a3);
              const o2 = new t.a8(e3, { now: a3, fadeDuration: i3, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), r2 = o2.crossFadingFactor();
              1 === r2 && r2 === this._crossFadingFactor || (s2 = true, this._crossFadingFactor = r2), this.style.update(o2);
            }
            this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform._minEleveationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i3, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: i3, showPadding: this.showPadding }), this.fire(new t.k("render")), this.loaded() && !this._loaded && (this._loaded = true, t.bg.mark(t.bh.load), this.fire(new t.k("load"))), this.style && (this.style.hasTransitions() || s2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const a2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return a2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.k("idle")), !this._loaded || this._fullyLoaded || a2 || (this._fullyLoaded = true, t.bg.mark(t.bh.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
          }
          remove() {
            var e2;
            this._hash && this._hash.remove();
            for (const t4 of this._controls)
              t4.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), h.removeThrottleControl(this._imageQueueHandle), null === (e2 = this._resizeObserver) || void 0 === e2 || e2.disconnect();
            const s2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            s2 && s2.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), i2.remove(this._canvasContainer), i2.remove(this._controlContainer), this._cooperativeGestures && this._destroyCooperativeGestures(), this._container.classList.remove("maplibregl-map"), t.bg.clearMetrics(), this._removed = true, this.fire(new t.k("remove"));
          }
          triggerRepaint() {
            this.style && !this._frame && (this._frame = t.h.frame((e2) => {
              t.bg.frame(e2), this._frame = null, this._render(e2);
            }));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(t4) {
            this._showTileBoundaries !== t4 && (this._showTileBoundaries = t4, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(t4) {
            this._showPadding !== t4 && (this._showPadding = t4, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(t4) {
            this._showCollisionBoxes !== t4 && (this._showCollisionBoxes = t4, t4 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(t4) {
            this._showOverdrawInspector !== t4 && (this._showOverdrawInspector = t4, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(t4) {
            this._repaint !== t4 && (this._repaint = t4, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(t4) {
            this._vertices = t4, this._update();
          }
          get version() {
            return fa;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
        }, Ba.NavigationControl = class {
          constructor(e2) {
            this._updateZoomButtons = () => {
              const t4 = this._map.getZoom(), e3 = t4 === this._map.getMaxZoom(), i3 = t4 === this._map.getMinZoom();
              this._zoomInButton.disabled = e3, this._zoomOutButton.disabled = i3, this._zoomInButton.setAttribute("aria-disabled", e3.toString()), this._zoomOutButton.setAttribute("aria-disabled", i3.toString());
            }, this._rotateCompassArrow = () => {
              const t4 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
              this._compassIcon.style.transform = t4;
            }, this._setButtonTitle = (t4, e3) => {
              const i3 = this._map._getUIString(`NavigationControl.${e3}`);
              t4.title = i3, t4.setAttribute("aria-label", i3);
            }, this.options = t.e({}, xa, e2), this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t4) => t4.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t4) => this._map.zoomIn({}, { originalEvent: t4 })), i2.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t4) => this._map.zoomOut({}, { originalEvent: t4 })), i2.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t4) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t4 }) : this._map.resetNorth({}, { originalEvent: t4 });
            }), this._compassIcon = i2.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(t4) {
            return this._map = t4, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ya(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            i2.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(t4, e2) {
            const s2 = i2.create("button", t4, this._container);
            return s2.type = "button", s2.addEventListener("click", e2), s2;
          }
        }, Ba.GeolocateControl = class extends t.E {
          constructor(e2) {
            super(), this._onSuccess = (e3) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e3))
                  return this._setErrorState(), this.fire(new t.k("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation)
                  switch (this._lastKnownPosition = e3, this._watchState) {
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                      this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                      break;
                    case "BACKGROUND":
                    case "BACKGROUND_ERROR":
                      this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                      break;
                    default:
                      throw new Error(`Unexpected watchState ${this._watchState}`);
                  }
                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t.k("geolocate", e3)), this._finish();
              }
            }, this._updateCamera = (e3) => {
              const i3 = new t.L(e3.coords.longitude, e3.coords.latitude), s2 = e3.coords.accuracy, a2 = this._map.getBearing(), o2 = t.e({ bearing: a2 }, this.options.fitBoundsOptions), r2 = L2.fromLngLat(i3, s2);
              this._map.fitBounds(r2, o2, { geolocateSource: true });
            }, this._updateMarker = (e3) => {
              if (e3) {
                const i3 = new t.L(e3.coords.longitude, e3.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i3).addTo(this._map), this._userLocationDotMarker.setLngLat(i3).addTo(this._map), this._accuracy = e3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else
                this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = (e3) => {
              if (this._map) {
                if (this.options.trackUserLocation)
                  if (1 === e3.code) {
                    this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                    const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4), void 0 !== this._geolocationWatchID && this._clearWatch();
                  } else {
                    if (3 === e3.code && Pa)
                      return;
                    this._setErrorState();
                  }
                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t.k("error", e3)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = (e3) => {
              if (this._map) {
                if (this._container.addEventListener("contextmenu", (t4) => t4.preventDefault()), this._geolocateButton = i2.create("button", "maplibregl-ctrl-geolocate", this._container), i2.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === e3) {
                  t.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
                } else {
                  const t4 = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i2.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ea({ element: this._dotElement }), this._circleElement = i2.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ea({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e4) => {
                  e4.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e4.originalEvent && "resize" === e4.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t.k("trackuserlocationend")));
                });
              }
            }, this.options = t.e({}, Sa, e2);
          }
          onAdd(t4) {
            return this._map = t4, this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), function(t5, e2 = false) {
              void 0 === ba || e2 ? void 0 !== window.navigator.permissions ? window.navigator.permissions.query({ name: "geolocation" }).then((e3) => {
                ba = "denied" !== e3.state, t5(ba);
              }).catch(() => {
                ba = !!window.navigator.geolocation, t5(ba);
              }) : (ba = !!window.navigator.geolocation, t5(ba)) : t5(ba);
            }(this._setupUI), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), i2.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ca = 0, Pa = false;
          }
          _isOutOfMapMaxBounds(t4) {
            const e2 = this._map.getMaxBounds(), i3 = t4.coords;
            return e2 && (i3.longitude < e2.getWest() || i3.longitude > e2.getEast() || i3.latitude < e2.getSouth() || i3.latitude > e2.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadius() {
            const t4 = this._map.getBounds(), e2 = t4.getSouthEast(), i3 = t4.getNorthEast(), s2 = e2.distanceTo(i3), a2 = Math.ceil(this._accuracy / (s2 / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${a2}px`, this._circleElement.style.height = `${a2}px`;
          }
          trigger() {
            if (!this._setup)
              return t.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new t.k("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Ca--, Pa = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t.k("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.k("trackuserlocationstart"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let t4;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ca++, Ca > 1 ? (t4 = { maximumAge: 6e5, timeout: 0 }, Pa = true) : (t4 = this.options.positionOptions, Pa = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t4);
              }
            } else
              window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, Ba.AttributionControl = ra, Ba.LogoControl = na, Ba.ScaleControl = class {
          constructor(e2) {
            this._onMove = () => {
              Ma(this._map, this._container, this.options);
            }, this.setUnit = (t4) => {
              this.options.unit = t4, Ma(this._map, this._container, this.options);
            }, this.options = t.e({}, Da, e2);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t4) {
            return this._map = t4, this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", t4.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            i2.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, Ba.FullscreenControl = class extends t.E {
          constructor(e2 = {}) {
            super(), this._onFullscreenChange = () => {
              (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, e2 && e2.container && (e2.container instanceof HTMLElement ? this._container = e2.container : t.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(t4) {
            return this._map = t4, this._container || (this._container = this._map.getContainer()), this._controlContainer = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            i2.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const t4 = this._fullscreenButton = i2.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            i2.create("span", "maplibregl-ctrl-icon", t4).setAttribute("aria-hidden", "true"), t4.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const t4 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", t4), this._fullscreenButton.title = t4;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t.k("fullscreenstart")), this._map._cooperativeGestures && (this._prevCooperativeGestures = this._map._cooperativeGestures, this._map.setCooperativeGestures())) : (this.fire(new t.k("fullscreenend")), this._prevCooperativeGestures && (this._map.setCooperativeGestures(this._prevCooperativeGestures), delete this._prevCooperativeGestures));
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, Ba.TerrainControl = class {
          constructor(t4) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.disableTerrain")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.enableTerrain"));
            }, this.options = t4;
          }
          onAdd(t4) {
            return this._map = t4, this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = i2.create("button", "maplibregl-ctrl-terrain", this._container), i2.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            i2.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, Ba.Popup = class extends t.E {
          constructor(e2) {
            super(), this.remove = () => (this._content && i2.remove(this._content), this._container && (i2.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.k("close")), this), this._onMouseUp = (t4) => {
              this._update(t4.point);
            }, this._onMouseMove = (t4) => {
              this._update(t4.point);
            }, this._onDrag = (t4) => {
              this._update(t4.point);
            }, this._update = (t4) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
                return;
              if (!this._container) {
                if (this._container = i2.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = i2.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                  for (const t5 of this.options.className.split(" "))
                    this._container.classList.add(t5);
                this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = wa(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !t4)
                return;
              const e3 = this._pos = this._trackPointer && t4 ? t4 : this._map.project(this._lngLat);
              let s2 = this.options.anchor;
              const a2 = Ra(this.options.offset);
              if (!s2) {
                const t5 = this._container.offsetWidth, i3 = this._container.offsetHeight;
                let o3;
                o3 = e3.y + a2.bottom.y < i3 ? ["top"] : e3.y > this._map.transform.height - i3 ? ["bottom"] : [], e3.x < t5 / 2 ? o3.push("left") : e3.x > this._map.transform.width - t5 / 2 && o3.push("right"), s2 = 0 === o3.length ? "bottom" : o3.join("-");
              }
              const o2 = e3.add(a2[s2]).round();
              i2.setTransform(this._container, `${Ta[s2]} translate(${o2.x}px,${o2.y}px)`), Ia(this._container, s2, "popup");
            }, this._onClose = () => {
              this.remove();
            }, this.options = t.e(Object.create(La), e2);
          }
          addTo(e2) {
            return this._map && this.remove(), this._map = e2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.k("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e2) {
            return this._lngLat = t.L.convert(e2), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(t4) {
            return this.setDOMContent(document.createTextNode(t4));
          }
          setHTML(t4) {
            const e2 = document.createDocumentFragment(), i3 = document.createElement("body");
            let s2;
            for (i3.innerHTML = t4; s2 = i3.firstChild, s2; )
              e2.appendChild(s2);
            return this.setDOMContent(e2);
          }
          getMaxWidth() {
            var t4;
            return null === (t4 = this._container) || void 0 === t4 ? void 0 : t4.style.maxWidth;
          }
          setMaxWidth(t4) {
            return this.options.maxWidth = t4, this._update(), this;
          }
          setDOMContent(t4) {
            if (this._content)
              for (; this._content.hasChildNodes(); )
                this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else
              this._content = i2.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(t4), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(t4) {
            this._container && this._container.classList.add(t4);
          }
          removeClassName(t4) {
            this._container && this._container.classList.remove(t4);
          }
          setOffset(t4) {
            return this.options.offset = t4, this._update(), this;
          }
          toggleClassName(t4) {
            if (this._container)
              return this._container.classList.toggle(t4);
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = i2.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container)
              return;
            const t4 = this._container.querySelector(Aa);
            t4 && t4.focus();
          }
        }, Ba.Marker = Ea, Ba.Style = se, Ba.LngLat = t.L, Ba.LngLatBounds = L2, Ba.Point = t.P, Ba.MercatorCoordinate = t.U, Ba.Evented = t.E, Ba.AJAXError = t.bi, Ba.config = t.c, Ba.CanvasSource = Z, Ba.GeoJSONSource = B2, Ba.ImageSource = N, Ba.RasterDEMTileSource = F, Ba.RasterTileSource = k, Ba.VectorTileSource = R, Ba.VideoSource = U, Ba.setRTLTextPlugin = t.bj, Ba.getRTLTextPluginStatus = t.bk, Ba.prewarm = function() {
          st().acquire(J);
        }, Ba.clearPrewarmedResources = function() {
          const t4 = it;
          t4 && (t4.isPreloaded() && 1 === t4.numActive() ? (t4.release(J), it = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, ka.extend(Ba, { isSafari: t.ac, getPerformanceMetrics: t.bg.getPerformanceMetrics }), Ba;
      });
      var maplibregl$1 = maplibregl2;
      return maplibregl$1;
    });
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof(i2))
      return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i2 = toPrimitive(t, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}

// node_modules/@antv/l7-maps/es/utils/BaseMapWrapper.js
var BaseMapWrapper = class {
  constructor(config4) {
    _defineProperty(this, "configService", void 0);
    _defineProperty(this, "config", void 0);
    this.config = config4;
  }
  setContainer(sceneContainer, id2) {
    this.configService = sceneContainer.globalConfigService;
    sceneContainer.mapConfig = _objectSpread2(_objectSpread2({}, this.config), {}, {
      id: id2
    });
    sceneContainer.mapService = new (this.getServiceConstructor())(sceneContainer);
  }
  getServiceConstructor() {
    throw new Error("Method not implemented.");
  }
};

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r)
    return {};
  var t = {};
  for (var n in r)
    if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n))
        continue;
      t[n] = r[n];
    }
  return t;
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e, t) {
  if (null == e)
    return {};
  var o, r, i2 = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++)
      o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i2[o] = e[o]);
  }
  return i2;
}

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i2 = n[a](c), u = i2.value;
  } catch (n2) {
    return void e(n2);
  }
  i2.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function() {
    var t = this, e = arguments;
    return new Promise(function(r, o) {
      var a = n.apply(t, e);
      function _next(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
      }
      function _throw(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
      }
      _next(void 0);
    });
  };
}

// node_modules/@antv/l7-maps/es/amap-next/map.js
var import_amap_jsapi_loader = __toESM(require_dist());

// node_modules/@antv/l7-utils/es/config.js
var SceneConifg = {
  REGISTERED_PROTOCOLS: {}
};

// node_modules/@antv/l7-utils/es/ajax.js
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var getProtocolAction = (url) => SceneConifg.REGISTERED_PROTOCOLS[url.substring(0, url.indexOf("://"))];
var AJAXError = class extends Error {
  constructor(status, statusText, url, body) {
    super(`AJAXError: ${statusText} (${status}): ${url}`);
    this.status = status;
    this.statusText = statusText;
    this.url = url;
    this.body = body;
  }
};
function makeXMLHttpRequest(requestParameters, callback) {
  const xhr = new XMLHttpRequest();
  const url = Array.isArray(requestParameters.url) ? requestParameters.url[0] : requestParameters.url;
  xhr.open(requestParameters.method || "GET", url, true);
  if (requestParameters.type === "arrayBuffer") {
    xhr.responseType = "arraybuffer";
  }
  for (const k in requestParameters.headers) {
    if (requestParameters.headers.hasOwnProperty(k)) {
      xhr.setRequestHeader(k, requestParameters.headers[k]);
    }
  }
  if (requestParameters.type === "json") {
    xhr.responseType = "text";
    xhr.setRequestHeader("Accept", "application/json");
  }
  xhr.withCredentials = requestParameters.credentials === "include";
  xhr.onerror = () => {
    callback(new Error(xhr.statusText));
  };
  xhr.onload = () => {
    if ((xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) && xhr.response !== null) {
      let data = xhr.response;
      if (requestParameters.type === "json") {
        try {
          data = JSON.parse(xhr.response);
        } catch (err2) {
          return callback(err2);
        }
      }
      callback(
        null,
        data,
        xhr.getResponseHeader("Cache-Control"),
        xhr.getResponseHeader("Expires"),
        xhr
      );
    } else {
      const body = new Blob([xhr.response], {
        type: xhr.getResponseHeader("Content-Type")
      });
      callback(new AJAXError(xhr.status, xhr.statusText, url.toString(), body));
    }
  };
  xhr.cancel = xhr.abort;
  xhr.send(requestParameters.body);
  return xhr;
}
function makeXMLHttpRequestPromise(requestParameters) {
  return new Promise((resolve, reject) => {
    makeXMLHttpRequest(requestParameters, (error, data, cacheControl, expires, xhr) => {
      if (error) {
        reject({
          err: error,
          data: null,
          xhr
        });
      } else {
        resolve({
          err: null,
          data,
          cacheControl,
          expires,
          xhr
        });
      }
    });
  });
}
function makeRequest(requestParameters, callback) {
  return makeXMLHttpRequest(requestParameters, callback);
}
var getJSON = (requestParameters, callback) => {
  const action = getProtocolAction(requestParameters.url) || makeRequest;
  return action(__spreadProps(__spreadValues({}, requestParameters), { type: "json" }), callback);
};
var getArrayBuffer = (requestParameters, callback) => {
  const action = getProtocolAction(requestParameters.url) || makeRequest;
  return action(__spreadProps(__spreadValues({}, requestParameters), { type: "arrayBuffer" }), callback);
};
var postData = (requestParameters, callback) => {
  return makeRequest(__spreadProps(__spreadValues({}, requestParameters), { method: "POST" }), callback);
};
var getData = (requestParameters, callback) => {
  return makeRequest(__spreadProps(__spreadValues({}, requestParameters), { method: "GET" }), callback);
};
function sameOrigin(url) {
  const a = window.document.createElement("a");
  a.href = url;
  return a.protocol === window.document.location.protocol && a.host === window.document.location.host;
}
var transparentPngUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
function arrayBufferToImage(data, callback) {
  const img = new window.Image();
  const URL2 = window.URL || window.webkitURL;
  img.crossOrigin = "anonymous";
  img.onload = () => {
    callback(null, img);
    URL2.revokeObjectURL(img.src);
    img.onload = null;
    window.requestAnimationFrame(() => {
      img.src = transparentPngUrl;
    });
  };
  img.onerror = () => callback(
    new Error(
      "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
    )
  );
  const blob = new Blob([new Uint8Array(data)], { type: "image/png" });
  img.src = data.byteLength ? URL2.createObjectURL(blob) : transparentPngUrl;
}
function arrayBufferToImageBitmap(data, callback) {
  const blob = new Blob([new Uint8Array(data)], { type: "image/png" });
  createImageBitmap(blob).then((imgBitmap) => {
    callback(null, imgBitmap);
  }).catch((e) => {
    callback(
      new Error(
        `Could not load image because of ${e.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
      )
    );
  });
}
var getImage = (requestParameters, callback, transformResponse) => {
  const optionFunc = (err2, imgData) => {
    if (err2) {
      callback(err2);
    } else if (imgData) {
      const imageBitmapSupported = typeof createImageBitmap === "function";
      const transformImgData = transformResponse ? transformResponse(imgData) : imgData;
      if (imageBitmapSupported) {
        arrayBufferToImageBitmap(transformImgData, callback);
      } else {
        arrayBufferToImage(transformImgData, callback);
      }
    }
  };
  if (requestParameters.type === "json") {
    return getJSON(requestParameters, optionFunc);
  } else {
    return getArrayBuffer(requestParameters, optionFunc);
  }
};
var formatImage = (imgData, callback) => {
  const imageBitmapSupported = typeof createImageBitmap === "function";
  if (imageBitmapSupported) {
    arrayBufferToImageBitmap(imgData, callback);
  } else {
    arrayBufferToImage(imgData, callback);
  }
};

// node_modules/@antv/l7-utils/es/anchor.js
var anchorType = ((anchorType2) => {
  anchorType2["CENTER"] = "center";
  anchorType2["TOP"] = "top";
  anchorType2["TOP-LEFT"] = "top-left";
  anchorType2["TOP-RIGHT"] = "top-right";
  anchorType2["BOTTOM"] = "bottom";
  anchorType2["BOTTOM-LEFT"] = "bottom-left";
  anchorType2["BOTTOM-RIGHT"] = "bottom-right";
  anchorType2["LEFT"] = "left";
  anchorType2["RIGHT"] = "right";
  return anchorType2;
})(anchorType || {});
var anchorTranslate = {
  center: "translate(-50%,-50%)",
  top: "translate(-50%,0)",
  "top-left": "translate(0,0)",
  "top-right": "translate(-100%,0)",
  bottom: "translate(-50%,-100%)",
  "bottom-left": "translate(0,-100%)",
  "bottom-right": "translate(-100%,-100%)",
  left: "translate(0,-50%)",
  right: "translate(-100%,-50%)"
};
function applyAnchorClass(element, anchor, prefix) {
  const classList = element.classList;
  for (const key in anchorTranslate) {
    if (anchorTranslate.hasOwnProperty(key)) {
      classList.remove(`l7-${prefix}-anchor-${key}`);
    }
  }
  classList.add(`l7-${prefix}-anchor-${anchor}`);
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min5 = Math.min(r, g, b), max6 = Math.max(r, g, b), h = NaN, s = max6 - min5, l = (max6 + min5) / 2;
  if (s) {
    if (r === max6)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max6)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max6 + min5 : 2 - max6 - min5;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x2, z;
  if (r === g && g === b)
    x2 = z = y;
  else {
    x2 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x2 - y), 200 * (y - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116, x2 = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x2 = Xn * lab2xyz(x2);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x2 - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x2 - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

// node_modules/@antv/l7-utils/es/color.js
function isColor(str6) {
  if (typeof str6 === "string") {
    return !!color(str6);
  } else {
    return false;
  }
}
function rgb2arr(str6) {
  const color2 = color(str6);
  const arr = [0, 0, 0, 0];
  if (color2 != null) {
    arr[0] = color2.r / 255;
    arr[1] = color2.g / 255;
    arr[2] = color2.b / 255;
    arr[3] = color2.opacity;
  }
  return arr;
}
function decodePickingColor(color2) {
  const i1 = color2 && color2[0];
  const i2 = color2 && color2[1];
  const i3 = color2 && color2[2];
  const index = i1 + i2 * 256 + i3 * 65536 - 1;
  return index;
}
function encodePickingColor(featureIdx) {
  return [
    featureIdx + 1 & 255,
    featureIdx + 1 >> 8 & 255,
    featureIdx + 1 >> 8 >> 8 & 255
  ];
}
function generateColorRamp(colorRamp) {
  let canvas = window.document.createElement("canvas");
  let ctx = canvas.getContext("2d");
  canvas.width = 256;
  canvas.height = 1;
  let data = null;
  const gradient = ctx.createLinearGradient(0, 0, 256, 1);
  const min5 = colorRamp.positions[0];
  const max6 = colorRamp.positions[colorRamp.positions.length - 1];
  for (let i2 = 0; i2 < colorRamp.colors.length; ++i2) {
    const value = (colorRamp.positions[i2] - min5) / (max6 - min5);
    gradient.addColorStop(value, colorRamp.colors[i2]);
  }
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 256, 1);
  data = new Uint8ClampedArray(ctx.getImageData(0, 0, 256, 1).data);
  canvas = null;
  ctx = null;
  return { data, width: 256, height: 1 };
}
function generateLinearRamp(colorRamp, domain) {
  let canvas = window.document.createElement("canvas");
  let ctx = canvas.getContext("2d");
  canvas.width = 256;
  canvas.height = 1;
  const gradient = ctx.createLinearGradient(0, 0, 256, 1);
  const step = domain[1] - domain[0];
  for (let i2 = 0; i2 < colorRamp.colors.length; ++i2) {
    const value = Math.max((colorRamp.positions[i2] - domain[0]) / step, 0);
    gradient.addColorStop(value, colorRamp.colors[i2]);
  }
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 256, 1);
  const data = ctx.getImageData(0, 0, 256, 1).data;
  const imageData = toIEIMageData(ctx, data);
  canvas = null;
  ctx = null;
  return imageData;
}
function generateCatRamp(colorRamp) {
  let canvas = window.document.createElement("canvas");
  let ctx = canvas.getContext("2d");
  canvas.width = 256;
  canvas.height = 1;
  const imageData = ctx.createImageData(256, 1);
  imageData.data.fill(0);
  colorRamp.positions.forEach((p, index) => {
    const colorArray = rgb2arr(colorRamp.colors[index]);
    imageData.data[p * 4 + 0] = colorArray[0] * 255;
    imageData.data[p * 4 + 1] = colorArray[1] * 255;
    imageData.data[p * 4 + 2] = colorArray[2] * 255;
    imageData.data[p * 4 + 3] = colorArray[3] * 255;
  });
  canvas = null;
  ctx = null;
  return imageData;
}
function generateQuantizeRamp(colorRamp) {
  let canvas = window.document.createElement("canvas");
  let ctx = canvas.getContext("2d");
  ctx.globalAlpha = 1;
  canvas.width = 256;
  canvas.height = 1;
  const step = 256 / colorRamp.colors.length;
  for (let i2 = 0; i2 < colorRamp.colors.length; i2++) {
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.strokeStyle = colorRamp.colors[i2];
    ctx.moveTo(i2 * step, 0);
    ctx.lineTo((i2 + 1) * step, 0);
    ctx.stroke();
  }
  const data = ctx.getImageData(0, 0, 256, 1).data;
  const imageData = toIEIMageData(ctx, data);
  canvas = null;
  ctx = null;
  return imageData;
}
function generateCustomRamp(colorRamp, domain) {
  let canvas = window.document.createElement("canvas");
  let ctx = canvas.getContext("2d");
  ctx.globalAlpha = 1;
  canvas.width = 256;
  canvas.height = 1;
  const step = domain[1] - domain[0];
  if (colorRamp.positions.length - colorRamp.colors.length !== 1) {
    console.warn(
      "positions 的数字个数应当比 colors 的样式多一个,poisitions 的首尾值一般为数据的最大最新值"
    );
  }
  for (let i2 = 0; i2 < colorRamp.colors.length; i2++) {
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.strokeStyle = colorRamp.colors[i2];
    ctx.moveTo((colorRamp.positions[i2] - domain[0]) / step * 255, 0);
    ctx.lineTo((colorRamp.positions[i2 + 1] - domain[0]) / step * 255, 0);
    ctx.stroke();
  }
  const data = ctx.getImageData(0, 0, 256, 1).data;
  const imageData = toIEIMageData(ctx, data);
  canvas = null;
  ctx = null;
  return imageData;
}
function toIEIMageData(ctx, data) {
  const imageData = ctx.createImageData(256, 1);
  for (let i2 = 0; i2 < imageData.data.length; i2 += 4) {
    imageData.data[i2 + 0] = data[i2 + 0];
    imageData.data[i2 + 1] = data[i2 + 1];
    imageData.data[i2 + 2] = data[i2 + 2];
    imageData.data[i2 + 3] = data[i2 + 3];
  }
  return imageData;
}
function getDefaultDomain(rampColors) {
  switch (rampColors == null ? void 0 : rampColors.type) {
    case "cat":
      return [0, 255];
    default:
      return [0, 1];
  }
}

// node_modules/@antv/l7-utils/es/dom.js
var dom_exports = {};
__export(dom_exports, {
  DPR: () => DPR,
  addClass: () => addClass,
  addStyle: () => addStyle,
  appendElementType: () => appendElementType,
  clearChildren: () => clearChildren,
  create: () => create,
  css2Style: () => css2Style,
  empty: () => empty,
  findParentElement: () => findParentElement,
  getClass: () => getClass,
  getContainer: () => getContainer,
  getDiffRect: () => getDiffRect,
  getStyleList: () => getStyleList,
  getViewPortScale: () => getViewPortScale,
  hasClass: () => hasClass,
  printCanvas: () => printCanvas,
  remove: () => remove,
  removeClass: () => removeClass,
  removeStyle: () => removeStyle,
  setChecked: () => setChecked,
  setClass: () => setClass,
  setTransform: () => setTransform,
  setUnDraggable: () => setUnDraggable,
  splitWords: () => splitWords,
  toggleClass: () => toggleClass,
  triggerResize: () => triggerResize,
  trim: () => trim
});

// node_modules/@antv/l7-utils/es/lodash-adapter.js
var import_clamp = __toESM(require_clamp());
var import_cloneDeep = __toESM(require_cloneDeep());
var import_debounce = __toESM(require_debounce());
var import_get = __toESM(require_get());
var import_isBoolean = __toESM(require_isBoolean());
var import_isEqual = __toESM(require_isEqual());
var import_isNil = __toESM(require_isNil());
var import_isNumber = __toESM(require_isNumber());
var import_isPlainObject = __toESM(require_isPlainObject());
var import_isString = __toESM(require_isString());
var import_isTypedArray = __toESM(require_isTypedArray());
var import_merge = __toESM(require_merge());
var import_mergeWith = __toESM(require_mergeWith());
var import_pull = __toESM(require_pull());
var import_throttle = __toESM(require_throttle());
var import_uniq = __toESM(require_uniq());
var import_upperFirst = __toESM(require_upperFirst());
var import_isFunction = __toESM(require_isFunction());
var import_isObject = __toESM(require_isObject());
var import_isUndefined = __toESM(require_isUndefined());
var import_camelCase = __toESM(require_camelCase());
var import_uniqueId = __toESM(require_uniqueId());
var lodashUtil = {
  isNil: import_isNil.default,
  merge: import_merge.default,
  throttle: import_throttle.default,
  isString: import_isString.default,
  debounce: import_debounce.default,
  pull: import_pull.default,
  isTypedArray: import_isTypedArray.default,
  isPlainObject: import_isPlainObject.default,
  isNumber: import_isNumber.default,
  isBoolean: import_isBoolean.default,
  isEqual: import_isEqual.default,
  cloneDeep: import_cloneDeep.default,
  uniq: import_uniq.default,
  clamp: import_clamp.default,
  upperFirst: import_upperFirst.default,
  get: import_get.default,
  mergeWith: import_mergeWith.default,
  isFunction: import_isFunction.default,
  isObject: import_isObject.default,
  isUndefined: import_isUndefined.default,
  camelCase: import_camelCase.default,
  uniqueId: import_uniqueId.default
};

// node_modules/@antv/l7-utils/es/dom.js
var { pull: pull2 } = lodashUtil;
function getContainer(domId) {
  let $dom = domId;
  if (typeof domId === "string") {
    $dom = window.document.getElementById(domId);
  }
  return $dom;
}
function trim(str6) {
  return str6.trim ? str6.trim() : str6.replace(/^\s+|\s+$/g, "");
}
function splitWords(str6) {
  return trim(str6).split(/\s+/);
}
function testProp(props) {
  var _a2;
  const docStyle = (_a2 = document == null ? void 0 : document.documentElement) == null ? void 0 : _a2.style;
  if (!docStyle) {
    return props[0];
  }
  for (const i2 in props) {
    if (props[i2] && props[i2] in docStyle) {
      return props[i2];
    }
  }
  return props[0];
}
function create(tagName, className, container) {
  const el = window.document.createElement(tagName);
  if (className) {
    el.className = className || "";
  }
  if (container) {
    container.appendChild(el);
  }
  return el;
}
function remove(el) {
  const parent = el.parentNode;
  if (parent) {
    parent.removeChild(el);
  }
}
function addClass(el, name) {
  if (el.classList !== void 0) {
    const classes = splitWords(name);
    for (let i2 = 0, len4 = classes.length; i2 < len4; i2++) {
      el.classList.add(classes[i2]);
    }
  } else if (!hasClass(el, name)) {
    const className = getClass(el);
    setClass(el, (className ? className + " " : "") + name);
  }
}
function removeClass(el, name) {
  if (el.classList !== void 0) {
    const classes = splitWords(name);
    classes.forEach((className) => {
      el.classList.remove(className);
    });
  } else {
    setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
  }
}
function hasClass(el, name) {
  if (el.classList !== void 0) {
    return el.classList.contains(name);
  }
  const className = getClass(el);
  return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
}
function setClass(el, name) {
  if (el instanceof HTMLElement) {
    el.className = name;
  } else {
    el.className.baseVal = name;
  }
}
function toggleClass(el, className, force) {
  if (force === void 0) {
    if (hasClass(el, className)) {
      removeClass(el, className);
    } else {
      addClass(el, className);
    }
  } else if (force) {
    addClass(el, className);
  } else {
    removeClass(el, className);
  }
}
function getClass(el) {
  if (el instanceof SVGElement) {
    el = el.correspondingElement;
  }
  return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
}
function empty(el) {
  while (el && el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
var transformProp = testProp(["transform", "WebkitTransform"]);
function setTransform(el, value) {
  el.style[transformProp] = value;
}
function triggerResize() {
  if (typeof Event === "function") {
    window.dispatchEvent(new Event("resize"));
  } else {
    const evt = window.document.createEvent("UIEvents");
    evt.initUIEvent("resize", true, false, window, 0);
    window.dispatchEvent(evt);
  }
}
function printCanvas(canvas) {
  const css = [
    "padding: " + (canvas.height / 2 - 8) + "px " + canvas.width / 2 + "px;",
    "line-height: " + canvas.height + "px;",
    "background-image: url(" + canvas.toDataURL() + ");"
  ];
  console.log("%c\n", css.join(""));
}
function getViewPortScale() {
  var _a2;
  const meta = window.document.querySelector('meta[name="viewport"]');
  if (!meta) {
    return 1;
  }
  const contentItems = (_a2 = meta.content) == null ? void 0 : _a2.split(",");
  const scale6 = contentItems.find((item) => {
    const [key] = item.split("=");
    return key === "initial-scale";
  });
  return scale6 ? scale6.split("=")[1] * 1 : 1;
}
var DPR = getViewPortScale() < 1 ? 1 : window.devicePixelRatio;
function addStyle(el, style) {
  el.setAttribute("style", `${el.style.cssText}${style}`);
}
function getStyleList(style) {
  return style.split(";").map((item) => item.trim()).filter((item) => item);
}
function removeStyle(el, style) {
  var _a2;
  const oldStyleList = getStyleList((_a2 = el.getAttribute("style")) != null ? _a2 : "");
  const targetStyleList = getStyleList(style);
  const newStyleList = pull2(oldStyleList, ...targetStyleList);
  el.setAttribute("style", newStyleList.join(";"));
}
function css2Style(obj) {
  return Object.entries(obj).map(([key, value]) => `${key}: ${value}`).join(";");
}
function getDiffRect(dom1Rect, dom2Rect) {
  return {
    left: dom1Rect.left - dom2Rect.left,
    top: dom1Rect.top - dom2Rect.top,
    right: dom2Rect.left + dom2Rect.width - dom1Rect.left - dom1Rect.width,
    bottom: dom2Rect.top + dom2Rect.height - dom1Rect.top - dom1Rect.height
  };
}
function setChecked(el, value) {
  el.checked = value;
  if (value) {
    el.setAttribute("checked", "true");
  } else {
    el.removeAttribute("checked");
  }
}
function clearChildren(el) {
  el.innerHTML = "";
}
function setUnDraggable(el) {
  el.setAttribute("draggable", "false");
}
function appendElementType(container, children) {
  if (typeof children === "string") {
    const div4 = document.createElement("div");
    div4.innerHTML = children;
    while (div4.firstChild) {
      container.append(div4.firstChild);
    }
  } else if (Array.isArray(children)) {
    container.append(...children);
  } else {
    container.append(children);
  }
}
function findParentElement(target, selector) {
  var _a2;
  const selectors = Array.isArray(selector) ? selector : [selector];
  let current = target;
  while (current instanceof Element && current !== window.document.body) {
    if (selectors.find((item) => current == null ? void 0 : current.matches(item))) {
      return current;
    }
    current = (_a2 = current == null ? void 0 : current.parentElement) != null ? _a2 : null;
  }
  return void 0;
}

// node_modules/@antv/l7-utils/es/env.js
function isImageBitmap(image) {
  return typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
}
function isWorker() {
  return typeof importScripts === "function";
}
var getReferrer = isWorker() ? () => self.worker && self.worker.referrer : () => (window.location.protocol === "blob:" ? window.parent : window).location.href;
var userAgent = navigator == null ? void 0 : navigator.userAgent;
var isiOS = !!userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
var isAndroid = userAgent.indexOf("Android") > -1 || userAgent.indexOf("Adr") > -1;
function isPC() {
  const userAgentInfo = userAgent;
  const Agents = ["Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod"];
  let flag = true;
  for (const v of Agents) {
    if (userAgentInfo.indexOf(v) > 0) {
      flag = false;
      break;
    }
  }
  return flag;
}

// node_modules/@antv/l7-utils/es/event.js
function bindAll(fns, context) {
  fns.forEach((fn) => {
    if (!context[fn]) {
      return;
    }
    context[fn] = context[fn].bind(context);
  });
}
var FrequencyController = class {
  constructor(duration = 16) {
    this.duration = 16;
    this.timestamp = (/* @__PURE__ */ new Date()).getTime();
    this.duration = duration;
  }
  run(callback) {
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    const timeCut = currentTime - this.timestamp;
    this.timestamp = currentTime;
    if (timeCut >= this.duration) {
      callback();
    }
  }
};

// node_modules/@turf/helpers/dist/es/index.js
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: earthRadius / 111325,
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
var unitsFactors = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.37,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1e3,
  millimetres: 1e3,
  nauticalmiles: 1 / 1852,
  radians: 1 / earthRadius,
  yards: 1.0936133
};
function feature(geom, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var feat = { type: "Feature" };
  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }
  if (options.bbox) {
    feat.bbox = options.bbox;
  }
  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
function polygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
    var ring = coordinates_1[_i];
    if (ring.length < 4) {
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    }
    for (var j = 0; j < ring[ring.length - 1].length; j++) {
      if (ring[ring.length - 1][j] !== ring[0][j]) {
        throw new Error("First and last Position are not equivalent.");
      }
    }
  }
  var geom = {
    type: "Polygon",
    coordinates
  };
  return feature(geom, properties, options);
}
function lineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be an array of two or more positions");
  }
  var geom = {
    type: "LineString",
    coordinates
  };
  return feature(geom, properties, options);
}
function featureCollection(features, options) {
  if (options === void 0) {
    options = {};
  }
  var fc = { type: "FeatureCollection" };
  if (options.id) {
    fc.id = options.id;
  }
  if (options.bbox) {
    fc.bbox = options.bbox;
  }
  fc.features = features;
  return fc;
}
function multiPolygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = {
    type: "MultiPolygon",
    coordinates
  };
  return feature(geom, properties, options);
}
function radiansToLength(radians, units) {
  if (units === void 0) {
    units = "kilometers";
  }
  var factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return radians * factor;
}
function radiansToDegrees(radians) {
  var degrees = radians % (2 * Math.PI);
  return degrees * 180 / Math.PI;
}
function degreesToRadians(degrees) {
  var radians = degrees % 360;
  return radians * Math.PI / 180;
}

// node_modules/@turf/meta/dist/es/index.js
function coordEach(geojson, callback, excludeWrapCoord) {
  if (geojson === null)
    return;
  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
      if (geometry === null)
        continue;
      coords = geometry.coordinates;
      var geomType = geometry.type;
      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
      switch (geomType) {
        case null:
          break;
        case "Point":
          if (callback(
            coords,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (callback(
              coords[j],
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            if (geomType === "MultiPoint")
              multiFeatureIndex++;
          }
          if (geomType === "LineString")
            multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (callback(
                coords[j][k],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString")
              multiFeatureIndex++;
            if (geomType === "Polygon")
              geometryIndex++;
          }
          if (geomType === "Polygon")
            multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;
            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (callback(
                  coords[j][k][l],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j = 0; j < geometry.geometries.length; j++)
            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
function geomEach(geojson, callback) {
  var i2, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (i2 = 0; i2 < stop; i2++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i2].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i2].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i2].bbox : isFeature ? geojson.bbox : void 0;
    featureId = isFeatureCollection ? geojson.features[i2].id : isFeature ? geojson.id : void 0;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (g = 0; g < stopG; g++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
      if (geometry === null) {
        if (callback(
          null,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        ) === false)
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(
            geometry,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry.geometries.length; j++) {
            if (callback(
              geometry.geometries[j],
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}
function flattenEach(geojson, callback) {
  geomEach(geojson, function(geometry, featureIndex, properties, bbox2, id2) {
    var type = geometry === null ? null : geometry.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback(
          feature(geometry, properties, { bbox: bbox2, id: id2 }),
          featureIndex,
          0
        ) === false)
          return false;
        return;
    }
    var geomType;
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }
    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate
      };
      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
        return false;
    }
  });
}

// node_modules/@turf/bbox/dist/es/index.js
function bbox(geojson) {
  var result = [Infinity, Infinity, -Infinity, -Infinity];
  coordEach(geojson, function(coord) {
    if (result[0] > coord[0]) {
      result[0] = coord[0];
    }
    if (result[1] > coord[1]) {
      result[1] = coord[1];
    }
    if (result[2] < coord[0]) {
      result[2] = coord[0];
    }
    if (result[3] < coord[1]) {
      result[3] = coord[1];
    }
  });
  return result;
}
bbox["default"] = bbox;
var es_default = bbox;

// node_modules/@antv/l7-utils/es/math.js
function isNumber2(n) {
  return typeof n === "number";
}
function fp64LowPart(x2) {
  return x2 - Math.fround(x2);
}

// node_modules/@antv/l7-utils/es/geo.js
var originShift = 2 * Math.PI * 6378137 / 2;
function lngLatInExtent(lngLat, bounds) {
  const [minLng, minLat, maxLng, maxLat] = bounds;
  return lngLat.lng > minLng && lngLat.lng <= maxLng && lngLat.lat > minLat && lngLat.lat <= maxLat;
}
function extent(data) {
  const dataExtent = [Infinity, Infinity, -Infinity, -Infinity];
  data.forEach((item) => {
    const { coordinates } = item;
    caculExtent(dataExtent, coordinates);
  });
  return dataExtent;
}
function caculExtent(dataExtent, coords) {
  if (Array.isArray(coords[0])) {
    coords.forEach((coord) => {
      caculExtent(dataExtent, coord);
    });
  } else {
    if (dataExtent[0] > coords[0]) {
      dataExtent[0] = coords[0];
    }
    if (dataExtent[1] > coords[1]) {
      dataExtent[1] = coords[1];
    }
    if (dataExtent[2] < coords[0]) {
      dataExtent[2] = coords[0];
    }
    if (dataExtent[3] < coords[1]) {
      dataExtent[3] = coords[1];
    }
  }
  return dataExtent;
}
function tranfrormCoord(data, cb) {
  return transform(data, cb);
}
function transform(item, cb) {
  if (Array.isArray(item[0])) {
    return item.map((coord) => {
      return transform(coord, cb);
    });
  }
  return cb(item);
}
function lngLatToMeters(lnglat, validate = true, accuracy = { enable: true, decimal: 1 }) {
  lnglat = validateLngLat(lnglat, validate);
  const lng = lnglat[0];
  const lat = lnglat[1];
  let x2 = lng * originShift / 180;
  let y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
  y = y * originShift / 180;
  if (accuracy.enable) {
    x2 = Number(x2.toFixed(accuracy.decimal));
    y = Number(y.toFixed(accuracy.decimal));
  }
  return lnglat.length === 3 ? [x2, y, lnglat[2]] : [x2, y];
}
function metersToLngLat(meters, decimal = 6) {
  const x2 = meters[0];
  const y = meters[1];
  let lng = x2 / originShift * 180;
  let lat = y / originShift * 180;
  lat = 180 / Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180)) - Math.PI / 2);
  if (decimal !== void 0 && decimal !== null) {
    lng = Number(lng.toFixed(decimal));
    lat = Number(lat.toFixed(decimal));
  }
  return meters.length === 3 ? [lng, lat, meters[2]] : [lng, lat];
}
function longitude(lng) {
  if (lng === void 0 || lng === null) {
    throw new Error("lng is required");
  }
  if (lng > 180 || lng < -180) {
    lng = lng % 360;
    if (lng > 180) {
      lng = -360 + lng;
    }
    if (lng < -180) {
      lng = 360 + lng;
    }
    if (lng === 0) {
      lng = 0;
    }
  }
  return lng;
}
function latitude(lat) {
  if (lat === void 0 || lat === null) {
    throw new Error("lat is required");
  }
  if (lat > 90 || lat < -90) {
    lat = lat % 180;
    if (lat > 90) {
      lat = -180 + lat;
    }
    if (lat < -90) {
      lat = 180 + lat;
    }
    if (lat === 0) {
      lat = 0;
    }
  }
  return lat;
}
function validateLngLat(lnglat, validate) {
  if (validate === false) {
    return lnglat;
  }
  const lng = longitude(lnglat[0]);
  let lat = latitude(lnglat[1]);
  if (lat > 85) {
    lat = 85;
  }
  if (lat < -85) {
    lat = -85;
  }
  return lnglat.length === 3 ? [lng, lat, lnglat[2]] : [lng, lat];
}
function aProjectFlat(lnglat) {
  const maxs = 85.0511287798;
  const lat = Math.max(Math.min(maxs, lnglat[1]), -maxs);
  const scale6 = 256 << 20;
  let d = Math.PI / 180;
  let x2 = lnglat[0] * d;
  let y = lat * d;
  y = Math.log(Math.tan(Math.PI / 4 + y / 2));
  const a = 0.5 / Math.PI;
  const b = 0.5;
  const c = -0.5 / Math.PI;
  d = 0.5;
  x2 = scale6 * (a * x2 + b);
  y = scale6 * (c * y + d);
  return [Math.floor(x2), Math.floor(y)];
}
function unProjectFlat(px) {
  const a = 0.5 / Math.PI;
  const b = 0.5;
  const c = -0.5 / Math.PI;
  let d = 0.5;
  const scale6 = 256 << 20;
  let [x2, y] = px;
  x2 = (x2 / scale6 - b) / a;
  y = (y / scale6 - d) / c;
  y = (Math.atan(Math.pow(Math.E, y)) - Math.PI / 4) * 2;
  d = Math.PI / 180;
  const lat = y / d;
  const lng = x2 / d;
  return [lng, lat];
}
function amap2Project(lng, lat) {
  const r = 85.0511287798;
  const Rg = Math.PI / 180;
  const Tg = 6378137;
  lat = Math.max(Math.min(r, lat), -r);
  lng *= Rg;
  lat *= Rg;
  lat = Math.log(Math.tan(Math.PI / 4 + lat / 2));
  return [lng * Tg, lat * Tg];
}
function amap2UnProject(x2, y) {
  const Rg = Math.PI / 180;
  const Tg = 6378137;
  const lng = x2 / Tg / Rg;
  const lat = 2 * (Math.atan(Math.exp(y / Tg)) - Math.PI / 4) / Rg;
  return [lng, lat];
}
function lnglatDistance(coordinates1, coordinates2, units) {
  const dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
  const dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
  const lat1 = degreesToRadians(coordinates1[1]);
  const lat2 = degreesToRadians(coordinates2[1]);
  const a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(
    2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    units = "meters"
  );
}
function project(lnglat) {
  const d = Math.PI / 180;
  const max6 = 85.0511287798;
  const earthRadius3 = 6378137;
  const lat = Math.max(Math.min(max6, lnglat[1]), -max6);
  const sin = Math.sin(lat * d);
  const x2 = earthRadius3 * lnglat[0] * d;
  const y = earthRadius3 * Math.log((1 + sin) / (1 - sin)) / 2;
  return [x2, y];
}
function padBounds(b, bufferRatio) {
  const heightBuffer = Math.abs(b[1][1] - b[0][1]) * bufferRatio;
  const widthBuffer = Math.abs(b[1][0] - b[0][0]) * bufferRatio;
  return [
    [b[0][0] - widthBuffer, b[0][1] - heightBuffer],
    [b[1][0] + widthBuffer, b[1][1] + heightBuffer]
  ];
}
function boundsContains(b1, b2) {
  return b1[0][0] <= b2[0][0] && b1[0][1] <= b2[0][1] && b1[1][0] >= b2[1][0] && b1[1][1] >= b2[1][1];
}
function bBoxToBounds(b1) {
  return [
    [b1[0], b1[1]],
    [b1[2], b1[3]]
  ];
}
function normalize(v) {
  const len4 = calDistance(v, [0, 0]);
  return [v[0] / len4, v[1] / len4];
}
function calDistance(p1, p2) {
  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
}
function dotMul(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}
function getMod(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function calAngle(v1, v2) {
  return Math.acos(dotMul(v1, v2) / (getMod(v1) * getMod(v2))) * 180 / Math.PI;
}
function getAngle(v1, v2) {
  if (v2[0] > 0) {
    if (v2[1] > 0) {
      return 90 - Math.atan(v2[1] / v2[0]) * 180 / Math.PI;
    } else {
      return 90 + Math.atan(-v2[1] / v2[0]) * 180 / Math.PI;
    }
  } else {
    if (v2[1] < 0) {
      return 180 + (90 - Math.atan(v2[1] / v2[0]) * 180 / Math.PI);
    } else {
      return 270 + Math.atan(v2[1] / -v2[0]) * 180 / Math.PI;
    }
  }
}
function flow(coords, time = 100) {
  if (!coords || coords.length < 2) {
    return;
  }
  const originVec2 = [0, 1];
  let totalDis = 0;
  const path = [];
  for (let i2 = 0; i2 < coords.length - 1; i2++) {
    const p1 = coords[i2];
    const p2 = coords[i2 + 1];
    const dis = calDistance(p1, p2);
    totalDis += dis;
    const direct = [p1[0] - p2[0], p1[1] - p2[1]];
    let rotation = getAngle(originVec2, direct);
    if (i2 > 0) {
      const lastRotation = path[i2 - 1].rotation;
      if (lastRotation - rotation > 360 - lastRotation + rotation) {
        rotation = rotation + 360;
      }
    }
    path.push({
      start: p1,
      end: p2,
      dis,
      rotation,
      duration: 0
    });
  }
  path.map((point2) => {
    point2.duration = time * (point2.dis / totalDis);
  });
  return path;
}
function calculateCentroid(coord) {
  if (isNumber2(coord[0])) {
    return coord;
  } else if (isNumber2(coord[0][0])) {
    throw new Error("当前数据不支持标注");
  } else if (isNumber2(coord[0][0][0])) {
    const coords = coord;
    let xSum = 0;
    let ySum = 0;
    let len4 = 0;
    coords.forEach((coor) => {
      coor.forEach((pos) => {
        xSum += pos[0];
        ySum += pos[1];
        len4++;
      });
    });
    return [xSum / len4, ySum / len4, 0];
  } else {
    throw new Error("当前数据不支持标注");
  }
}
function calculatePointsCenterAndRadius(points) {
  let maxX = points[0];
  let maxY = points[1];
  let minX = points[0];
  let minY = points[1];
  let xCount = 0;
  let yCount = 0;
  let pCount = 0;
  for (let i2 = 0; i2 < points.length; i2 += 2) {
    const x2 = points[i2];
    const y = points[i2 + 1];
    if (x2 && y) {
      maxX = Math.max(x2, maxX);
      maxY = Math.max(y, maxY);
      minX = Math.min(x2, minX);
      minY = Math.min(y, minY);
      xCount += x2;
      yCount += y;
      pCount++;
    }
  }
  return {
    center: [xCount / pCount, yCount / pCount],
    radius: Math.sqrt(Math.pow(maxX - minX, 2) + Math.pow(maxY - minY, 2)) / 2
  };
}
function getBBoxFromPoints(pointList) {
  return es_default(featureCollection([lineString(pointList)]));
}

// node_modules/@antv/l7-utils/es/hash.js
function BKDRHash(str6) {
  const seed = 131;
  const seed2 = 137;
  let hash = 0;
  str6 += "x";
  const MAX_SAFE_INTEGER = Math.floor(9007199254740991 / seed2);
  for (let i2 = 0; i2 < str6.length; i2++) {
    if (hash > MAX_SAFE_INTEGER) {
      hash = Math.floor(hash / seed2);
    }
    hash = hash * seed + str6.charCodeAt(i2);
  }
  return hash;
}
function djb2hash(str6) {
  str6 = str6.toString();
  let hash = 5381;
  let i2 = str6.length;
  while (i2) {
    hash = hash * 33 ^ str6.charCodeAt(--i2);
  }
  return hash >>> 0;
}
function guid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}

// node_modules/@antv/l7-utils/es/lineAtOffset/arc.js
function arcLineAtOffset(source, target, offset, thetaOffset, segmentNumber = 30, autoFit) {
  let pointOffset = offset;
  if (autoFit) {
    pointOffset = Math.round(offset * (segmentNumber - 1)) / (segmentNumber - 1);
  }
  if (!thetaOffset) {
    return interpolate(source, target, pointOffset, 0.314);
  } else {
    return interpolate(source, target, pointOffset, thetaOffset);
  }
}
function bezier3(arr, t) {
  const ut = 1 - t;
  return (arr[0] * ut + arr[1] * t) * ut + (arr[1] * ut + arr[2] * t) * t;
}
function calDistance2(p1, p2) {
  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
}
function midPoint(source, target, thetaOffset) {
  const center = [target[0] - source[0], target[1] - source[1]];
  const r = calDistance2(center, [0, 0]);
  const theta = Math.atan2(center[1], center[0]);
  const r2 = r / 2 / Math.cos(thetaOffset);
  const theta2 = theta + thetaOffset;
  const mid = [r2 * Math.cos(theta2) + source[0], r2 * Math.sin(theta2) + source[1]];
  return mid;
}
function interpolate(source, target, offset, thetaOffset) {
  const mid = midPoint(source, target, thetaOffset);
  const x2 = [source[0], mid[0], target[0]];
  const y = [source[1], mid[1], target[1]];
  return [bezier3(x2, offset), bezier3(y, offset), 0];
}

// node_modules/@antv/l7-utils/es/lineAtOffset/greatCircle.js
function greatCircleLineAtOffset(source, target, offset, thetaOffset, segmentNumber = 30, autoFit) {
  let pointOffset = offset;
  if (autoFit) {
    pointOffset = Math.round(offset * 29) / 29;
  }
  return interpolate2(source, target, pointOffset);
}
function getAngularDist(source, target) {
  const delta = [source[0] - target[0], source[1] - target[1]];
  const sinHalfDelta = [Math.sin(delta[0] / 2), Math.sin(delta[1] / 2)];
  const a = sinHalfDelta[1] * sinHalfDelta[1] + Math.cos(source[1]) * Math.cos(target[1]) * sinHalfDelta[0] * sinHalfDelta[0];
  return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
function interpolate2(s, t, offset) {
  const source = [degreesToRadians(s[0]), degreesToRadians(s[1])];
  const target = [degreesToRadians(t[0]), degreesToRadians(t[1])];
  const angularDist = getAngularDist(source, target);
  if (Math.abs(angularDist - Math.PI) < 1e-3) {
    return [
      (1 - offset) * source[0] + offset * target[0],
      (1 - offset) * source[1] + offset * target[1]
    ];
  }
  const a = Math.sin((1 - offset) * angularDist) / Math.sin(angularDist);
  const b = Math.sin(offset * angularDist) / Math.sin(angularDist);
  const sinSource = [Math.sin(source[0]), Math.sin(source[1])];
  const cosSource = [Math.cos(source[0]), Math.cos(source[1])];
  const sinTarget = [Math.sin(target[0]), Math.sin(target[1])];
  const cosTarget = [Math.cos(target[0]), Math.cos(target[1])];
  const x2 = a * cosSource[1] * cosSource[0] + b * cosTarget[1] * cosTarget[0];
  const y = a * cosSource[1] * sinSource[0] + b * cosTarget[1] * sinTarget[0];
  const z = a * sinSource[1] + b * sinTarget[1];
  return [
    radiansToDegrees(Math.atan2(y, x2)),
    radiansToDegrees(Math.atan2(z, Math.sqrt(x2 * x2 + y * y)))
  ];
}

// node_modules/@antv/l7-utils/es/lineAtOffset/line.js
function pathLineAtOffset(coords, offset) {
  let totalDistance = 0;
  const cachePoints = [];
  for (let i2 = 0; i2 < coords.length - 1; i2++) {
    const p1 = coords[i2];
    const p2 = coords[i2 + 1];
    const distance4 = calDistance3(p1, p2);
    const lastTotalDistance = totalDistance;
    totalDistance += distance4;
    cachePoints.push({
      p1,
      p2,
      totalDistance,
      distance: distance4,
      lastTotalDistance
    });
  }
  const offsetDistance = totalDistance * offset;
  let lng;
  let lat;
  for (const point2 of cachePoints) {
    const currentDistance = point2.totalDistance;
    if (currentDistance > offsetDistance) {
      const p1 = point2.p1;
      const p2 = point2.p2;
      const radius = (offsetDistance - point2.lastTotalDistance) / point2.distance;
      const offsetPoint = mixPoint(p2, p1, radius);
      lng = offsetPoint[0];
      lat = offsetPoint[1];
      break;
    }
  }
  return {
    lng,
    lat,
    height: 0
  };
}
function mixPoint(p1, p2, r) {
  return [p1[0] * r + p2[0] * (1 - r), p1[1] * r + p2[1] * (1 - r)];
}
function calDistance3(p1, p2) {
  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
}

// node_modules/@antv/l7-utils/es/lineAtOffset/index.js
var __defProp3 = Object.defineProperty;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp3.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
function lineAtOffset(source, option) {
  const { featureId } = option;
  let features = source.data.dataArray;
  if (typeof featureId === "number") {
    features = features.filter(({ id: id2 }) => id2 === featureId);
  }
  return features.map((feature2) => {
    const position = getLineOffsetPosition(feature2, option);
    return __spreadValues2(__spreadValues2({}, feature2), position);
  });
}
function lineAtOffsetAsyc(source, option) {
  return new Promise((resolve) => {
    if (source.inited) {
      resolve(lineAtOffset(source, option));
    } else {
      source.once("update", () => {
        resolve(lineAtOffset(source, option));
      });
    }
  });
}
function getLineOffsetPosition(feature2, option) {
  const { offset, shape, thetaOffset, segmentNumber = 30, autoFit = true } = option;
  const { coordinates } = feature2;
  if (shape === "line") {
    return pathLineAtOffset(coordinates, offset);
  }
  const source = coordinates[0];
  const target = coordinates[1];
  const linetheatOffset = typeof thetaOffset === "string" ? feature2[thetaOffset] || 0 : thetaOffset;
  let calFunc;
  switch (shape) {
    case "arc":
      calFunc = arcLineAtOffset;
      break;
    case "greatcircle":
      calFunc = greatCircleLineAtOffset;
      break;
    default:
      calFunc = arcLineAtOffset;
  }
  const [lng, lat, height] = calFunc(
    source,
    target,
    offset,
    linetheatOffset,
    segmentNumber,
    autoFit
  );
  return {
    lng,
    lat,
    height
  };
}

// node_modules/@antv/l7-utils/es/lru_cache.js
var LRUCache = class {
  constructor(limit = 50, destroy) {
    this.limit = limit;
    this.destroy = destroy || this.defaultDestroy;
    this.order = [];
    this.clear();
  }
  clear() {
    this.order.forEach((key) => {
      this.delete(key);
    });
    this.cache = {};
    this.order = [];
  }
  get(key) {
    const value = this.cache[key];
    if (value) {
      this.deleteOrder(key);
      this.appendOrder(key);
    }
    return value;
  }
  set(key, value) {
    if (!this.cache[key]) {
      if (Object.keys(this.cache).length === this.limit) {
        this.delete(this.order[0]);
      }
      this.cache[key] = value;
      this.appendOrder(key);
    } else {
      this.delete(key);
      this.cache[key] = value;
      this.appendOrder(key);
    }
  }
  delete(key) {
    const value = this.cache[key];
    if (value) {
      this.deleteCache(key);
      this.deleteOrder(key);
      this.destroy(value, key);
    }
  }
  deleteCache(key) {
    delete this.cache[key];
  }
  deleteOrder(key) {
    const index = this.order.findIndex((o) => o === key);
    if (index >= 0) {
      this.order.splice(index, 1);
    }
  }
  appendOrder(key) {
    this.order.push(key);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  defaultDestroy(value, key) {
    return null;
  }
};

// node_modules/@antv/l7-utils/es/statistics.js
var statistics_exports = {};
__export(statistics_exports, {
  getColumn: () => getColumn,
  getSatByColumn: () => getSatByColumn,
  max: () => max,
  mean: () => mean,
  min: () => min,
  mode: () => mode,
  statMap: () => statMap,
  sum: () => sum
});
function max(x2) {
  if (x2.length === 0) {
    throw new Error("max requires at least one data point");
  }
  let value = x2[0];
  for (let i2 = 1; i2 < x2.length; i2++) {
    if (x2[i2] > value) {
      value = x2[i2];
    }
  }
  return value * 1;
}
function min(x2) {
  if (x2.length === 0) {
    throw new Error("min requires at least one data point");
  }
  let value = x2[0];
  for (let i2 = 1; i2 < x2.length; i2++) {
    if (x2[i2] < value) {
      value = x2[i2];
    }
  }
  return value * 1;
}
function sum(x2) {
  if (x2.length === 0) {
    return 0;
  }
  let sumNum = x2[0] * 1;
  for (let i2 = 1; i2 < x2.length; i2++) {
    sumNum += x2[i2] * 1;
  }
  return sumNum;
}
function mean(x2) {
  if (x2.length === 0) {
    throw new Error("mean requires at least one data point");
  }
  return sum(x2) / x2.length;
}
function mode(x2) {
  if (x2.length === 0) {
    throw new Error("mean requires at least one data point");
  }
  if (x2.length < 3) {
    return x2[0];
  }
  x2.sort();
  let last = x2[0];
  let value = NaN;
  let maxSeen = 0;
  let seenThis = 1;
  for (let i2 = 1; i2 < x2.length + 1; i2++) {
    if (x2[i2] !== last) {
      if (seenThis > maxSeen) {
        maxSeen = seenThis;
        value = last;
      }
      seenThis = 1;
      last = x2[i2];
    } else {
      seenThis++;
    }
  }
  return value * 1;
}
var statMap = {
  min,
  max,
  mean,
  sum,
  mode
};
function getColumn(data, columnName) {
  return data.map((item) => {
    return item[columnName];
  });
}
function getSatByColumn(type, column) {
  return statMap[type](column);
}

// node_modules/@turf/bbox-polygon/dist/es/index.js
function bboxPolygon(bbox2, options) {
  if (options === void 0) {
    options = {};
  }
  var west = Number(bbox2[0]);
  var south = Number(bbox2[1]);
  var east = Number(bbox2[2]);
  var north = Number(bbox2[3]);
  if (bbox2.length === 6) {
    throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
  }
  var lowLeft = [west, south];
  var topLeft = [west, north];
  var topRight = [east, north];
  var lowRight = [east, south];
  return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox2, id: options.id });
}

// node_modules/@antv/l7-utils/es/tileset-manager/tile.js
var import_eventemitter3 = __toESM(require_eventemitter3());

// node_modules/@antv/l7-utils/es/tileset-manager/types.js
var UpdateTileStrategy = ((UpdateTileStrategy2) => {
  UpdateTileStrategy2["Realtime"] = "realtime";
  UpdateTileStrategy2["Overlap"] = "overlap";
  UpdateTileStrategy2["Replace"] = "replace";
  return UpdateTileStrategy2;
})(UpdateTileStrategy || {});
var LoadTileDataStatus = ((LoadTileDataStatus2) => {
  LoadTileDataStatus2["Loading"] = "Loading";
  LoadTileDataStatus2["Loaded"] = "Loaded";
  LoadTileDataStatus2["Failure"] = "Failure";
  LoadTileDataStatus2["Cancelled"] = "Cancelled";
  return LoadTileDataStatus2;
})(LoadTileDataStatus || {});

// node_modules/@antv/l7-utils/es/tileset-manager/utils/strategies.js
var TILE_STATE_DEFAULT = 0;
var TILE_STATE_VISITED = 1;
var TILE_STATE_VISIBLE = 2;
function updateTileStateRealtime(tiles) {
  tiles.forEach((tile) => {
    if (tile.isCurrent) {
      tile.isVisible = tile.isLoaded;
    }
  });
}
function updateTileStateOverlap(tiles) {
  tiles.forEach((tile) => {
    tile.properties.state = TILE_STATE_DEFAULT;
  });
  tiles.forEach((tile) => {
    if (tile.isCurrent && !getPlaceholderInAncestors(tile)) {
      getPlaceholderInChildren(tile);
    }
  });
  tiles.forEach((tile) => {
    tile.isVisible = Boolean(tile.properties.state & TILE_STATE_VISIBLE);
  });
}
function updateTileStateReplace(tiles) {
  tiles.forEach((tile) => {
    tile.properties.state = TILE_STATE_DEFAULT;
  });
  tiles.forEach((tile) => {
    if (tile.isCurrent) {
      getPlaceholderInAncestors(tile);
    }
  });
  const sortedTiles = tiles.slice().sort((t12, t22) => t12.z - t22.z);
  sortedTiles.forEach((tile) => {
    tile.isVisible = Boolean(tile.properties.state & TILE_STATE_VISIBLE);
    if (tile.children.length && (tile.isVisible || tile.properties.state & TILE_STATE_VISITED)) {
      tile.children.forEach((child) => {
        child.properties.state = TILE_STATE_VISITED;
      });
    } else if (tile.isCurrent) {
      getPlaceholderInChildren(tile);
    }
  });
}
function getPlaceholderInAncestors(tile) {
  while (tile) {
    if (tile.isLoaded) {
      tile.properties.state |= TILE_STATE_VISIBLE;
      return true;
    }
    tile = tile.parent;
  }
  return false;
}
function getPlaceholderInChildren(tile) {
  tile.children.forEach((child) => {
    if (child.isLoaded) {
      child.properties.state |= TILE_STATE_VISIBLE;
    } else {
      getPlaceholderInChildren(child);
    }
  });
}

// node_modules/@antv/l7-utils/es/tileset-manager/const.js
var DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
var BOUNDS_BUFFER_SCALE = 0.2;
var DEFAULT_CACHE_SCALE = 5;
var UPDATE_TILE_STRATEGIES = {
  [UpdateTileStrategy.Realtime]: updateTileStateRealtime,
  [UpdateTileStrategy.Overlap]: updateTileStateOverlap,
  [UpdateTileStrategy.Replace]: updateTileStateReplace
};
var NOOP = () => {
};

// node_modules/@antv/l7-utils/es/tileset-manager/utils/lonlat-tile.js
function osmLonLat2TileXY(lon, lat, zoom) {
  const x2 = Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
  const y = Math.floor(
    (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)
  );
  return [x2, y];
}
function osmTileXY2LonLat(x2, y, zoom) {
  const lon = x2 / Math.pow(2, zoom) * 360 - 180;
  const n = Math.PI - 2 * Math.PI * y / Math.pow(2, zoom);
  const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  return [lon, lat];
}
var tileToBounds = (x2, y, z) => {
  const [minLng, maxLat] = osmTileXY2LonLat(x2, y, z);
  const [maxLng, minLat] = osmTileXY2LonLat(x2 + 1, y + 1, z);
  return [minLng, minLat, maxLng, maxLat];
};
function getTileIndices({
  zoom,
  latLonBounds,
  maxZoom = Infinity,
  minZoom = 0,
  zoomOffset = 0,
  extent: extent2 = DEFAULT_EXTENT
}) {
  let z = Math.ceil(zoom) + zoomOffset;
  if (Number.isFinite(minZoom) && z < minZoom) {
    return [];
  }
  if (Number.isFinite(maxZoom) && z > maxZoom) {
    z = maxZoom;
  }
  const [minLng, minLat, maxLng, maxLat] = latLonBounds;
  const bounds = [
    Math.max(minLng, extent2[0]),
    Math.max(minLat, extent2[1]),
    Math.min(maxLng, extent2[2]),
    Math.min(maxLat, extent2[3])
  ];
  const indices = [];
  const [minX, maxY] = osmLonLat2TileXY(bounds[0], bounds[1], z);
  const [maxX, minY] = osmLonLat2TileXY(bounds[2], bounds[3], z);
  for (let x2 = minX; x2 <= maxX; x2++) {
    for (let y = minY; y <= maxY; y++) {
      indices.push({ x: x2, y, z });
    }
  }
  const centerX = (maxX + minX) / 2;
  const centerY = (maxY + minY) / 2;
  const distance4 = (x2, y) => Math.abs(x2 - centerX) + Math.abs(y - centerY);
  indices.sort((a, b) => distance4(a.x, a.y) - distance4(b.x, b.y));
  return indices;
}
var getTileWarpXY = (x2, y, z, wrap3 = true) => {
  const scale6 = Math.pow(2, z);
  const maxIndex = scale6 - 1;
  const distance4 = scale6;
  let warpX = x2;
  const warpY = y;
  if (wrap3) {
    if (warpX < 0) {
      warpX = warpX + distance4;
    } else if (warpX > maxIndex) {
      warpX = warpX % distance4;
    }
  }
  return { warpX, warpY };
};

// node_modules/@antv/l7-utils/es/tileset-manager/tile.js
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var SourceTile = class extends import_eventemitter3.EventEmitter {
  constructor(options) {
    super();
    this.tileSize = 256;
    this.isVisible = false;
    this.isCurrent = false;
    this.isVisibleChange = false;
    this.loadedLayers = 0;
    this.isLayerLoaded = false;
    this.isLoad = false;
    this.isChildLoad = false;
    this.parent = null;
    this.children = [];
    this.data = null;
    this.properties = {};
    this.loadDataId = 0;
    const { x: x2, y, z, tileSize, warp = true } = options;
    this.x = x2;
    this.y = y;
    this.z = z;
    this.warp = warp || true;
    this.tileSize = tileSize;
  }
  // 是否正在请求瓦片
  get isLoading() {
    return this.loadStatus === LoadTileDataStatus.Loading;
  }
  // 是否瓦片请求成功
  get isLoaded() {
    return this.loadStatus === LoadTileDataStatus.Loaded;
  }
  // 是否瓦片请求失败
  get isFailure() {
    return this.loadStatus === LoadTileDataStatus.Failure;
  }
  setTileLayerLoaded() {
    this.isLayerLoaded = true;
  }
  // 是否瓦片请求被取消
  get isCancelled() {
    return this.loadStatus === LoadTileDataStatus.Cancelled;
  }
  // 是否数据请求结束
  get isDone() {
    return [
      LoadTileDataStatus.Loaded,
      LoadTileDataStatus.Cancelled,
      LoadTileDataStatus.Failure
    ].includes(this.loadStatus);
  }
  // 瓦片的经纬度边界
  get bounds() {
    return tileToBounds(this.x, this.y, this.z);
  }
  // 瓦片边界面
  get bboxPolygon() {
    const [minLng, minLat, maxLng, maxLat] = this.bounds;
    const center = [(maxLng - minLng) / 2, (maxLat - minLat) / 2];
    const polygon2 = bboxPolygon(this.bounds, {
      properties: {
        key: this.key,
        id: this.key,
        bbox: this.bounds,
        center,
        meta: `
      ${this.key}
      `
        // ${this.bbox.slice(0, 2)}
        // ${this.bbox.slice(2)}
      }
    });
    return polygon2;
  }
  // 瓦片的 key
  get key() {
    const key = `${this.x}_${this.y}_${this.z}`;
    return key;
  }
  layerLoad() {
    this.loadedLayers++;
    this.emit("layerLoaded");
  }
  // 请求瓦片数据
  loadData(_0) {
    return __async(this, arguments, function* ({ getData: getData2, onLoad, onError }) {
      this.loadDataId++;
      const loadDataId = this.loadDataId;
      if (this.isLoading) {
        this.abortLoad();
      }
      this.abortController = new AbortController();
      this.loadStatus = LoadTileDataStatus.Loading;
      let tileData = null;
      let error;
      try {
        const { x: x2, y, z, bounds, tileSize, warp } = this;
        const { warpX, warpY } = getTileWarpXY(x2, y, z, warp);
        const { signal } = this.abortController;
        const params = { x: warpX, y: warpY, z, bounds, tileSize, signal, warp };
        tileData = yield getData2(params, this);
      } catch (err2) {
        error = err2;
      }
      if (loadDataId !== this.loadDataId) {
        return;
      }
      if (this.isCancelled && !tileData) {
        return;
      }
      if (error || !tileData) {
        this.loadStatus = LoadTileDataStatus.Failure;
        onError(error, this);
        return;
      }
      this.loadStatus = LoadTileDataStatus.Loaded;
      this.data = tileData;
      onLoad(this);
    });
  }
  // 重新请求瓦片数据
  reloadData(params) {
    if (this.isLoading) {
      this.abortLoad();
    }
    this.loadData(params);
  }
  // 取消请求瓦片数据
  abortLoad() {
    if (this.isLoaded || this.isCancelled) {
      return;
    }
    this.loadStatus = LoadTileDataStatus.Cancelled;
    this.abortController.abort();
    if (this.xhrCancel) {
      this.xhrCancel();
    }
  }
};

// node_modules/@antv/l7-utils/es/tileset-manager/tileset-manager.js
var import_eventemitter32 = __toESM(require_eventemitter3());

// node_modules/@antv/l7-utils/es/tileset-manager/utils/bound-buffer.js
var getLatLonBoundsBuffer = (latLonBounds, bufferRatio) => {
  const bounds = bBoxToBounds(latLonBounds);
  const newBounds = padBounds(bounds, bufferRatio);
  const maxLngExtent = 360 * 3 - 180;
  const maxLatExtent = 85.0511287798065;
  const latLonBoundsBuffer = [
    Math.max(newBounds[0][0], -maxLngExtent),
    Math.max(newBounds[0][1], -maxLatExtent),
    Math.min(newBounds[1][0], maxLngExtent),
    Math.min(newBounds[1][1], maxLatExtent)
  ];
  return latLonBoundsBuffer;
};
var isLatLonBoundsContains = (latLonBoundsBuffer, latLonBounds) => {
  const boundsBuffer = bBoxToBounds(latLonBoundsBuffer);
  const bounds = bBoxToBounds(latLonBounds);
  const isContains = boundsContains(boundsBuffer, bounds);
  return isContains;
};

// node_modules/@antv/l7-utils/es/tileset-manager/tileset-manager.js
var __defProp4 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp4.call(b, prop))
      __defNormalProp3(a, prop, b[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b)) {
      if (__propIsEnum3.call(b, prop))
        __defNormalProp3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
var { throttle: throttle2 } = lodashUtil;
var TileEventType = ((TileEventType2) => {
  TileEventType2["TilesLoadStart"] = "tiles-load-start";
  TileEventType2["TileLoaded"] = "tile-loaded";
  TileEventType2["TileError"] = "tile-error";
  TileEventType2["TileUnload"] = "tile-unload";
  TileEventType2["TileUpdate"] = "tile-update";
  TileEventType2["TilesLoadFinished"] = "tiles-load-finished";
  return TileEventType2;
})(TileEventType || {});
var TilesetManager = class extends import_eventemitter32.default {
  constructor(options) {
    super();
    this.currentTiles = [];
    this.cacheTiles = /* @__PURE__ */ new Map();
    this.throttleUpdate = throttle2((zoom, latLonBounds) => {
      this.update(zoom, latLonBounds);
    }, 16);
    this.onTileLoad = (tile) => {
      this.emit("tile-loaded", tile);
      this.updateTileVisible();
      this.loadFinished();
    };
    this.onTileError = (error, tile) => {
      this.emit("tile-error", { error, tile });
      this.updateTileVisible();
      this.loadFinished();
    };
    this.onTileUnload = (tile) => {
      this.emit("tile-unload", tile);
      this.loadFinished();
    };
    this.options = {
      tileSize: 256,
      minZoom: 0,
      maxZoom: Infinity,
      zoomOffset: 0,
      extent: DEFAULT_EXTENT,
      getTileData: NOOP,
      warp: true,
      // TODO 更新策略
      updateStrategy: UpdateTileStrategy.Replace
    };
    this.updateOptions(options);
  }
  get isLoaded() {
    return this.currentTiles.every((tile) => tile.isDone);
  }
  // 缓存的瓦片数组
  get tiles() {
    const tiles = Array.from(this.cacheTiles.values()).sort((t12, t22) => t12.z - t22.z);
    return tiles;
  }
  // 更新配置项
  updateOptions(options) {
    const minZoom = options.minZoom === void 0 ? this.options.minZoom : Math.ceil(options.minZoom);
    const maxZoom = options.maxZoom === void 0 ? this.options.maxZoom : Math.floor(options.maxZoom);
    this.options = __spreadProps2(__spreadValues3(__spreadValues3({}, this.options), options), { minZoom, maxZoom });
  }
  // 更新
  // 1.瓦片序号发生改变 2.瓦片新增 3.瓦片显隐控制
  update(zoom, latLonBounds) {
    const verifyZoom = Math.max(0, Math.ceil(zoom));
    if (this.lastViewStates && this.lastViewStates.zoom === verifyZoom && isLatLonBoundsContains(this.lastViewStates.latLonBoundsBuffer, latLonBounds)) {
      return;
    }
    const latLonBoundsBuffer = getLatLonBoundsBuffer(latLonBounds, BOUNDS_BUFFER_SCALE);
    this.lastViewStates = {
      zoom: verifyZoom,
      latLonBounds,
      latLonBoundsBuffer
    };
    this.currentZoom = verifyZoom;
    let isAddTile = false;
    const tileIndices = this.getTileIndices(verifyZoom, latLonBoundsBuffer).filter((tile) => {
      return this.options.warp || tile.x >= 0 && tile.x < Math.pow(2, verifyZoom);
    });
    this.emit(
      "tiles-load-start"
      /* TilesLoadStart */
    );
    this.currentTiles = tileIndices.map(({ x: x2, y, z }) => {
      let tile = this.getTile(x2, y, z);
      if (tile) {
        const needsReload = (tile == null ? void 0 : tile.isFailure) || (tile == null ? void 0 : tile.isCancelled);
        if (needsReload) {
          tile.loadData({
            getData: this.options.getTileData,
            onLoad: this.onTileLoad,
            onError: this.onTileError
          });
        }
        return tile;
      }
      tile = this.createTile(x2, y, z);
      isAddTile = true;
      return tile;
    });
    if (isAddTile) {
      this.resizeCacheTiles();
    }
    this.updateTileVisible();
    this.pruneRequests();
  }
  // 重新加载瓦片
  reloadAll() {
    for (const [tileId, tile] of this.cacheTiles) {
      if (!this.currentTiles.includes(tile)) {
        this.cacheTiles.delete(tileId);
        this.onTileUnload(tile);
        return;
      }
      this.onTileUnload(tile);
      tile.loadData({
        getData: this.options.getTileData,
        onLoad: this.onTileLoad,
        onError: this.onTileError
      });
    }
  }
  reloadTileById(z, x2, y) {
    const tile = this.cacheTiles.get(`${x2},${y},${z}`);
    if (tile) {
      this.onTileUnload(tile);
      tile.loadData({
        getData: this.options.getTileData,
        onLoad: this.onTileLoad,
        onError: this.onTileError
      });
    }
  }
  reloadTileByLnglat(lng, lat, z) {
    const tile = this.getTileByLngLat(lng, lat, z);
    if (tile) {
      this.reloadTileById(tile.z, tile.x, tile.y);
    }
  }
  reloadTileByExtent(extent2, z) {
    const tiles = this.getTileIndices(z, extent2);
    tiles.forEach((tile) => {
      this.reloadTileById(tile.z, tile.x, tile.y);
    });
  }
  // 取消滞留请求中的瓦片
  pruneRequests() {
    const abortCandidates = [];
    for (const tile of this.cacheTiles.values()) {
      if (tile.isLoading) {
        if (!tile.isCurrent && !tile.isVisible) {
          abortCandidates.push(tile);
        }
      }
    }
    while (abortCandidates.length > 0) {
      const tile = abortCandidates.shift();
      tile.abortLoad();
    }
  }
  getTileByLngLat(lng, lat, zoom) {
    const { zoomOffset } = this.options;
    const z = Math.ceil(zoom) + zoomOffset;
    const xy = osmLonLat2TileXY(lng, lat, z);
    const tiles = this.tiles.filter((t) => t.key === `${xy[0]}_${xy[1]}_${z}`);
    return tiles[0];
  }
  getTileExtent(extent2, zoom) {
    return this.getTileIndices(zoom, extent2);
  }
  getTileByZXY(z, x2, y) {
    const tile = this.tiles.filter((t) => t.key === `${x2}_${y}_${z}`);
    return tile[0];
  }
  // 摧毁
  clear() {
    for (const tile of this.cacheTiles.values()) {
      if (tile.isLoading) {
        tile.abortLoad();
      } else {
        this.onTileUnload(tile);
      }
    }
    this.lastViewStates = void 0;
    this.cacheTiles.clear();
    this.currentTiles = [];
  }
  // 摧毁
  destroy() {
    this.clear();
    this.removeAllListeners();
  }
  // 更新瓦片显隐状态
  updateTileVisible() {
    const updateStrategy = this.options.updateStrategy;
    const beforeVisible = /* @__PURE__ */ new Map();
    for (const tile of this.cacheTiles.values()) {
      beforeVisible.set(tile.key, tile.isVisible);
      tile.isCurrent = false;
      tile.isVisible = false;
    }
    for (const tile of this.currentTiles) {
      tile.isCurrent = true;
      tile.isVisible = true;
    }
    const tiles = Array.from(this.cacheTiles.values());
    if (typeof updateStrategy === "function") {
      updateStrategy(tiles);
    } else {
      UPDATE_TILE_STRATEGIES[updateStrategy](tiles);
    }
    let isVisibleChange = false;
    Array.from(this.cacheTiles.values()).forEach((tile) => {
      if (tile.isVisible !== beforeVisible.get(tile.key)) {
        tile.isVisibleChange = true;
        isVisibleChange = true;
      } else {
        tile.isVisibleChange = false;
      }
    });
    if (isVisibleChange) {
      this.emit(
        "tile-update"
        /* TileUpdate */
      );
    }
  }
  // 获取当前视野层级瓦片的所有索引
  getTileIndices(zoom, latLonBounds) {
    const { tileSize, extent: extent2, zoomOffset } = this.options;
    const maxZoom = Math.floor(this.options.maxZoom);
    const minZoom = Math.ceil(this.options.minZoom);
    const indices = getTileIndices({
      maxZoom,
      minZoom,
      zoomOffset,
      tileSize,
      zoom,
      latLonBounds,
      extent: extent2
    });
    return indices;
  }
  // 获取瓦片 ID
  getTileId(x2, y, z) {
    const tileId = `${x2},${y},${z}`;
    return tileId;
  }
  loadFinished() {
    const finish = !this.currentTiles.some((t) => !t.isDone);
    if (finish) {
      this.emit(
        "tiles-load-finished"
        /* TilesLoadFinished */
      );
    }
    return finish;
  }
  // 获取瓦片
  getTile(x2, y, z) {
    const tileId = this.getTileId(x2, y, z);
    const tile = this.cacheTiles.get(tileId);
    return tile;
  }
  // 创建瓦片
  createTile(x2, y, z) {
    const tileId = this.getTileId(x2, y, z);
    const tile = new SourceTile({
      x: x2,
      y,
      z,
      tileSize: this.options.tileSize,
      warp: this.options.warp
    });
    this.cacheTiles.set(tileId, tile);
    tile.loadData({
      getData: this.options.getTileData,
      onLoad: this.onTileLoad,
      onError: this.onTileError
    });
    return tile;
  }
  // 当缓存超过最大值时，清除不可见的瓦片
  resizeCacheTiles() {
    const maxCacheSize = DEFAULT_CACHE_SCALE * this.currentTiles.length;
    const overflown = this.cacheTiles.size > maxCacheSize;
    if (overflown) {
      for (const [tileId, tile] of this.cacheTiles) {
        if (!tile.isVisible && !this.currentTiles.includes(tile)) {
          this.cacheTiles.delete(tileId);
          this.onTileUnload(tile);
        }
        if (this.cacheTiles.size <= maxCacheSize) {
          break;
        }
      }
    }
    this.rebuildTileTree();
  }
  // 重新计算瓦片树
  rebuildTileTree() {
    for (const tile of this.cacheTiles.values()) {
      tile.parent = null;
      tile.children.length = 0;
    }
    for (const tile of this.cacheTiles.values()) {
      const parent = this.getNearestAncestor(tile.x, tile.y, tile.z);
      tile.parent = parent;
      if (parent == null ? void 0 : parent.children) {
        parent.children.push(tile);
      }
    }
  }
  // 获取瓦片的最近上级的瓦片
  getNearestAncestor(x2, y, z) {
    while (z > this.options.minZoom) {
      x2 = Math.floor(x2 / 2);
      y = Math.floor(y / 2);
      z = z - 1;
      const parent = this.getTile(x2, y, z);
      if (parent) {
        return parent;
      }
    }
    return null;
  }
};

// node_modules/@antv/l7-utils/es/tileset-manager/utils/tile-url.js
function isURLTemplate(s) {
  return /(?=.*{box})(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);
}
function expandUrl(url) {
  const urls = [];
  let match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    const startCharCode = match[1].charCodeAt(0);
    const stopCharCode = match[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    const stop = parseInt(match[2], 10);
    for (let i2 = parseInt(match[1], 10); i2 <= stop; i2++) {
      urls.push(url.replace(match[0], i2.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}
function getURLFromTemplate(template, properties) {
  if (!template || !template.length) {
    throw new Error("url is not allowed to be empty");
  }
  const { x: x2, y, z } = properties;
  const urls = expandUrl(template);
  const index = Math.abs(x2 + y) % urls.length;
  const url = getProtocolAction(urls[index]) ? `${urls[index]}/{z}/{x}/{y}` : urls[index];
  return url.replace(/\{x\}/g, x2.toString()).replace(/\{y\}/g, y.toString()).replace(/\{z\}/g, z.toString()).replace(/\{bbox\}/g, tileToBounds(x2, y, z).join(",")).replace(/\{-y\}/g, (Math.pow(2, z) - y - 1).toString());
}
function getWMTSURLFromTemplate(template, properties) {
  const {
    x: x2,
    y,
    z,
    layer,
    version = "1.0.0",
    style = "default",
    format,
    service = "WMTS",
    tileMatrixset
  } = properties;
  const urls = expandUrl(template);
  const index = Math.abs(x2 + y) % urls.length;
  const url = `${urls[index]}&SERVICE=${service}&REQUEST=GetTile&VERSION=${version}&LAYER=${layer}&STYLE=${style}&TILEMATRIXSET=${tileMatrixset}&FORMAT=${format}&TILECOL=${x2}&TILEROW=${y}&TILEMATRIX=${z}`;
  return url;
}

// node_modules/@antv/l7-utils/es/index.js
function defaultValue(v1, v2) {
  if (v1 === void 0 || v1 === null) {
    return v2;
  }
  return v1;
}

// node_modules/@antv/l7-core/es/services/renderer/IMultiPassRenderer.js
var PassType = function(PassType2) {
  PassType2["Normal"] = "normal";
  PassType2["PostProcessing"] = "post-processing";
  return PassType2;
}({});

// node_modules/@antv/l7-core/es/services/renderer/gl.js
var gl = function(gl2) {
  gl2[gl2["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
  gl2[gl2["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
  gl2[gl2["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
  gl2[gl2["POINTS"] = 0] = "POINTS";
  gl2[gl2["LINES"] = 1] = "LINES";
  gl2[gl2["LINE_LOOP"] = 2] = "LINE_LOOP";
  gl2[gl2["LINE_STRIP"] = 3] = "LINE_STRIP";
  gl2[gl2["TRIANGLES"] = 4] = "TRIANGLES";
  gl2[gl2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  gl2[gl2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  gl2[gl2["ZERO"] = 0] = "ZERO";
  gl2[gl2["ONE"] = 1] = "ONE";
  gl2[gl2["SRC_COLOR"] = 768] = "SRC_COLOR";
  gl2[gl2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  gl2[gl2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  gl2[gl2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  gl2[gl2["DST_ALPHA"] = 772] = "DST_ALPHA";
  gl2[gl2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  gl2[gl2["DST_COLOR"] = 774] = "DST_COLOR";
  gl2[gl2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  gl2[gl2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
  gl2[gl2["FUNC_ADD"] = 32774] = "FUNC_ADD";
  gl2[gl2["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
  gl2[gl2["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
  gl2[gl2["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
  gl2[gl2["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
  gl2[gl2["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
  gl2[gl2["MAX_EXT"] = 32776] = "MAX_EXT";
  gl2[gl2["MIN_EXT"] = 32775] = "MIN_EXT";
  gl2[gl2["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
  gl2[gl2["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
  gl2[gl2["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
  gl2[gl2["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
  gl2[gl2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
  gl2[gl2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
  gl2[gl2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
  gl2[gl2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
  gl2[gl2["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
  gl2[gl2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  gl2[gl2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  gl2[gl2["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
  gl2[gl2["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
  gl2[gl2["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
  gl2[gl2["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
  gl2[gl2["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
  gl2[gl2["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
  gl2[gl2["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
  gl2[gl2["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
  gl2[gl2["FRONT"] = 1028] = "FRONT";
  gl2[gl2["BACK"] = 1029] = "BACK";
  gl2[gl2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
  gl2[gl2["CULL_FACE"] = 2884] = "CULL_FACE";
  gl2[gl2["BLEND"] = 3042] = "BLEND";
  gl2[gl2["DITHER"] = 3024] = "DITHER";
  gl2[gl2["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
  gl2[gl2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
  gl2[gl2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
  gl2[gl2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
  gl2[gl2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
  gl2[gl2["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
  gl2[gl2["NO_ERROR"] = 0] = "NO_ERROR";
  gl2[gl2["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
  gl2[gl2["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
  gl2[gl2["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
  gl2[gl2["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
  gl2[gl2["CW"] = 2304] = "CW";
  gl2[gl2["CCW"] = 2305] = "CCW";
  gl2[gl2["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
  gl2[gl2["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
  gl2[gl2["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
  gl2[gl2["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
  gl2[gl2["FRONT_FACE"] = 2886] = "FRONT_FACE";
  gl2[gl2["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
  gl2[gl2["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
  gl2[gl2["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
  gl2[gl2["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
  gl2[gl2["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
  gl2[gl2["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
  gl2[gl2["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
  gl2[gl2["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
  gl2[gl2["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
  gl2[gl2["STENCIL_REF"] = 2967] = "STENCIL_REF";
  gl2[gl2["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
  gl2[gl2["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
  gl2[gl2["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
  gl2[gl2["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
  gl2[gl2["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
  gl2[gl2["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
  gl2[gl2["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
  gl2[gl2["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
  gl2[gl2["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
  gl2[gl2["VIEWPORT"] = 2978] = "VIEWPORT";
  gl2[gl2["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
  gl2[gl2["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
  gl2[gl2["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
  gl2[gl2["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
  gl2[gl2["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
  gl2[gl2["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
  gl2[gl2["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
  gl2[gl2["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
  gl2[gl2["RED_BITS"] = 3410] = "RED_BITS";
  gl2[gl2["GREEN_BITS"] = 3411] = "GREEN_BITS";
  gl2[gl2["BLUE_BITS"] = 3412] = "BLUE_BITS";
  gl2[gl2["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
  gl2[gl2["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
  gl2[gl2["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
  gl2[gl2["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
  gl2[gl2["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
  gl2[gl2["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
  gl2[gl2["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
  gl2[gl2["SAMPLES"] = 32937] = "SAMPLES";
  gl2[gl2["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
  gl2[gl2["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
  gl2[gl2["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
  gl2[gl2["DONT_CARE"] = 4352] = "DONT_CARE";
  gl2[gl2["FASTEST"] = 4353] = "FASTEST";
  gl2[gl2["NICEST"] = 4354] = "NICEST";
  gl2[gl2["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
  gl2[gl2["BYTE"] = 5120] = "BYTE";
  gl2[gl2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  gl2[gl2["SHORT"] = 5122] = "SHORT";
  gl2[gl2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  gl2[gl2["INT"] = 5124] = "INT";
  gl2[gl2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  gl2[gl2["FLOAT"] = 5126] = "FLOAT";
  gl2[gl2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  gl2[gl2["ALPHA"] = 6406] = "ALPHA";
  gl2[gl2["RGB"] = 6407] = "RGB";
  gl2[gl2["RGBA"] = 6408] = "RGBA";
  gl2[gl2["LUMINANCE"] = 6409] = "LUMINANCE";
  gl2[gl2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  gl2[gl2["RED"] = 6403] = "RED";
  gl2[gl2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  gl2[gl2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  gl2[gl2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  gl2[gl2["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
  gl2[gl2["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
  gl2[gl2["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
  gl2[gl2["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
  gl2[gl2["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
  gl2[gl2["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
  gl2[gl2["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
  gl2[gl2["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
  gl2[gl2["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
  gl2[gl2["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
  gl2[gl2["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
  gl2[gl2["LINK_STATUS"] = 35714] = "LINK_STATUS";
  gl2[gl2["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
  gl2[gl2["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
  gl2[gl2["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
  gl2[gl2["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
  gl2[gl2["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
  gl2[gl2["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
  gl2[gl2["NEVER"] = 512] = "NEVER";
  gl2[gl2["LESS"] = 513] = "LESS";
  gl2[gl2["EQUAL"] = 514] = "EQUAL";
  gl2[gl2["LEQUAL"] = 515] = "LEQUAL";
  gl2[gl2["GREATER"] = 516] = "GREATER";
  gl2[gl2["NOTEQUAL"] = 517] = "NOTEQUAL";
  gl2[gl2["GEQUAL"] = 518] = "GEQUAL";
  gl2[gl2["ALWAYS"] = 519] = "ALWAYS";
  gl2[gl2["KEEP"] = 7680] = "KEEP";
  gl2[gl2["REPLACE"] = 7681] = "REPLACE";
  gl2[gl2["INCR"] = 7682] = "INCR";
  gl2[gl2["DECR"] = 7683] = "DECR";
  gl2[gl2["INVERT"] = 5386] = "INVERT";
  gl2[gl2["INCR_WRAP"] = 34055] = "INCR_WRAP";
  gl2[gl2["DECR_WRAP"] = 34056] = "DECR_WRAP";
  gl2[gl2["VENDOR"] = 7936] = "VENDOR";
  gl2[gl2["RENDERER"] = 7937] = "RENDERER";
  gl2[gl2["VERSION"] = 7938] = "VERSION";
  gl2[gl2["NEAREST"] = 9728] = "NEAREST";
  gl2[gl2["LINEAR"] = 9729] = "LINEAR";
  gl2[gl2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  gl2[gl2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  gl2[gl2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  gl2[gl2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
  gl2[gl2["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
  gl2[gl2["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
  gl2[gl2["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
  gl2[gl2["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
  gl2[gl2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  gl2[gl2["TEXTURE"] = 5890] = "TEXTURE";
  gl2[gl2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  gl2[gl2["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
  gl2[gl2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  gl2[gl2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  gl2[gl2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  gl2[gl2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  gl2[gl2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  gl2[gl2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  gl2[gl2["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
  gl2[gl2["TEXTURE0"] = 33984] = "TEXTURE0";
  gl2[gl2["TEXTURE1"] = 33985] = "TEXTURE1";
  gl2[gl2["TEXTURE2"] = 33986] = "TEXTURE2";
  gl2[gl2["TEXTURE3"] = 33987] = "TEXTURE3";
  gl2[gl2["TEXTURE4"] = 33988] = "TEXTURE4";
  gl2[gl2["TEXTURE5"] = 33989] = "TEXTURE5";
  gl2[gl2["TEXTURE6"] = 33990] = "TEXTURE6";
  gl2[gl2["TEXTURE7"] = 33991] = "TEXTURE7";
  gl2[gl2["TEXTURE8"] = 33992] = "TEXTURE8";
  gl2[gl2["TEXTURE9"] = 33993] = "TEXTURE9";
  gl2[gl2["TEXTURE10"] = 33994] = "TEXTURE10";
  gl2[gl2["TEXTURE11"] = 33995] = "TEXTURE11";
  gl2[gl2["TEXTURE12"] = 33996] = "TEXTURE12";
  gl2[gl2["TEXTURE13"] = 33997] = "TEXTURE13";
  gl2[gl2["TEXTURE14"] = 33998] = "TEXTURE14";
  gl2[gl2["TEXTURE15"] = 33999] = "TEXTURE15";
  gl2[gl2["TEXTURE16"] = 34e3] = "TEXTURE16";
  gl2[gl2["TEXTURE17"] = 34001] = "TEXTURE17";
  gl2[gl2["TEXTURE18"] = 34002] = "TEXTURE18";
  gl2[gl2["TEXTURE19"] = 34003] = "TEXTURE19";
  gl2[gl2["TEXTURE20"] = 34004] = "TEXTURE20";
  gl2[gl2["TEXTURE21"] = 34005] = "TEXTURE21";
  gl2[gl2["TEXTURE22"] = 34006] = "TEXTURE22";
  gl2[gl2["TEXTURE23"] = 34007] = "TEXTURE23";
  gl2[gl2["TEXTURE24"] = 34008] = "TEXTURE24";
  gl2[gl2["TEXTURE25"] = 34009] = "TEXTURE25";
  gl2[gl2["TEXTURE26"] = 34010] = "TEXTURE26";
  gl2[gl2["TEXTURE27"] = 34011] = "TEXTURE27";
  gl2[gl2["TEXTURE28"] = 34012] = "TEXTURE28";
  gl2[gl2["TEXTURE29"] = 34013] = "TEXTURE29";
  gl2[gl2["TEXTURE30"] = 34014] = "TEXTURE30";
  gl2[gl2["TEXTURE31"] = 34015] = "TEXTURE31";
  gl2[gl2["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
  gl2[gl2["REPEAT"] = 10497] = "REPEAT";
  gl2[gl2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  gl2[gl2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  gl2[gl2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  gl2[gl2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  gl2[gl2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  gl2[gl2["INT_VEC2"] = 35667] = "INT_VEC2";
  gl2[gl2["INT_VEC3"] = 35668] = "INT_VEC3";
  gl2[gl2["INT_VEC4"] = 35669] = "INT_VEC4";
  gl2[gl2["BOOL"] = 35670] = "BOOL";
  gl2[gl2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  gl2[gl2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  gl2[gl2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  gl2[gl2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  gl2[gl2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  gl2[gl2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  gl2[gl2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  gl2[gl2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  gl2[gl2["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
  gl2[gl2["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
  gl2[gl2["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
  gl2[gl2["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
  gl2[gl2["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
  gl2[gl2["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
  gl2[gl2["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
  gl2[gl2["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
  gl2[gl2["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
  gl2[gl2["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
  gl2[gl2["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
  gl2[gl2["LOW_INT"] = 36339] = "LOW_INT";
  gl2[gl2["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
  gl2[gl2["HIGH_INT"] = 36341] = "HIGH_INT";
  gl2[gl2["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
  gl2[gl2["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
  gl2[gl2["RGBA4"] = 32854] = "RGBA4";
  gl2[gl2["RGB5_A1"] = 32855] = "RGB5_A1";
  gl2[gl2["RGB565"] = 36194] = "RGB565";
  gl2[gl2["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
  gl2[gl2["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
  gl2[gl2["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
  gl2[gl2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  gl2[gl2["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
  gl2[gl2["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
  gl2[gl2["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
  gl2[gl2["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
  gl2[gl2["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
  gl2[gl2["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
  gl2[gl2["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
  gl2[gl2["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
  gl2[gl2["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
  gl2[gl2["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
  gl2[gl2["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
  gl2[gl2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
  gl2[gl2["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
  gl2[gl2["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
  gl2[gl2["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
  gl2[gl2["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
  gl2[gl2["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
  gl2[gl2["NONE"] = 0] = "NONE";
  gl2[gl2["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
  gl2[gl2["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
  gl2[gl2["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
  gl2[gl2["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
  gl2[gl2["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
  gl2[gl2["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
  gl2[gl2["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
  gl2[gl2["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
  gl2[gl2["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
  gl2[gl2["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
  gl2[gl2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
  gl2[gl2["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
  gl2[gl2["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
  gl2[gl2["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
  return gl2;
}({});

// node_modules/@antv/l7-core/es/services/renderer/passes/BasePostProcessingPass.js
var quad = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
var {
  camelCase: camelCase2,
  isNil: isNil2,
  upperFirst: upperFirst2
} = lodashUtil;
var BasePostProcessingPass = class {
  constructor() {
    _defineProperty(this, "shaderModuleService", void 0);
    _defineProperty(this, "rendererService", void 0);
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "quad", quad);
    _defineProperty(this, "enabled", true);
    _defineProperty(this, "renderToScreen", false);
    _defineProperty(this, "model", void 0);
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "optionsToUpdate", {});
  }
  getName() {
    return this.name;
  }
  setName(name) {
    this.name = name;
  }
  getType() {
    return PassType.PostProcessing;
  }
  init(layer, config4) {
    this.config = config4;
    this.rendererService = layer.getContainer().rendererService;
    this.shaderModuleService = layer.getContainer().shaderModuleService;
    const {
      createAttribute,
      createBuffer,
      createModel
    } = this.rendererService;
    const {
      vs,
      fs,
      uniforms
    } = this.setupShaders();
    this.model = createModel({
      vs,
      fs,
      attributes: {
        // 使用一个全屏三角形，相比 Quad 顶点数目更少
        a_Position: createAttribute({
          buffer: createBuffer({
            data: [-4, -4, 4, -4, 0, 4],
            type: gl.FLOAT
          }),
          size: 2
        })
      },
      // @ts-ignore
      uniforms: _objectSpread2(_objectSpread2({
        // @ts-ignore
        u_Texture: null
      }, uniforms), this.config && this.convertOptionsToUniforms(this.config)),
      depth: {
        enable: false
      },
      count: 3,
      blend: {
        // copy pass 需要混合
        enable: this.getName() === "copy"
      }
    });
  }
  render(layer, tex) {
    const postProcessor = layer.multiPassRenderer.getPostProcessor();
    const {
      useFramebuffer,
      getViewportSize,
      clear
    } = this.rendererService;
    const {
      width,
      height
    } = getViewportSize();
    useFramebuffer(this.renderToScreen ? null : postProcessor.getWriteFBO(), () => {
      clear({
        framebuffer: postProcessor.getWriteFBO(),
        color: [0, 0, 0, 0],
        depth: 1,
        stencil: 0
      });
      const uniformOptions = _objectSpread2({
        u_BloomFinal: 0,
        u_Texture: postProcessor.getReadFBO(),
        // u_Texture: tex ? tex : postProcessor.getReadFBO(),
        u_ViewportSize: [width, height]
      }, this.convertOptionsToUniforms(this.optionsToUpdate));
      if (tex) {
        uniformOptions.u_BloomFinal = 1;
        uniformOptions.u_Texture2 = tex;
      }
      this.model.draw({
        uniforms: uniformOptions
      });
    });
  }
  isEnabled() {
    return this.enabled;
  }
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  setRenderToScreen(renderToScreen) {
    this.renderToScreen = renderToScreen;
  }
  updateOptions(config4) {
    this.optionsToUpdate = _objectSpread2(_objectSpread2({}, this.optionsToUpdate), config4);
  }
  setupShaders() {
    throw new Error("Method not implemented.");
  }
  convertOptionsToUniforms(options) {
    const uniforms = {};
    Object.keys(options).forEach((optionName) => {
      if (!isNil2(options[optionName])) {
        uniforms[`u_${upperFirst2(camelCase2(optionName))}`] = // @ts-ignore
        options[optionName];
      }
    });
    return uniforms;
  }
};

// node_modules/@antv/l7-core/es/utils/shader-module.js
function getUniformLengthByType(type) {
  let arrayLength = 0;
  switch (type) {
    case "vec2":
    case "ivec2":
      arrayLength = 2;
      break;
    case "vec3":
    case "ivec3":
      arrayLength = 3;
      break;
    case "vec4":
    case "ivec4":
    case "mat2":
      arrayLength = 4;
      break;
    case "mat3":
      arrayLength = 9;
      break;
    case "mat4":
      arrayLength = 16;
      break;
    default:
  }
  return arrayLength;
}
var uniformRegExp = /uniform\s+(bool|float|int|vec2|vec3|vec4|ivec2|ivec3|ivec4|mat2|mat3|mat4|sampler2D|samplerCube)\s+([\s\S]*?);/g;
function fillUniforms(content, uniformPrefix = false) {
  const uniforms = {};
  content = content.replace(uniformRegExp, (_, type, c) => {
    const defaultValues = c.split(":");
    const uniformName = defaultValues[0].trim();
    let defaultValue2 = "";
    if (defaultValues.length > 1) {
      defaultValue2 = defaultValues[1].trim();
    }
    switch (type) {
      case "bool":
        defaultValue2 = defaultValue2 === "true";
        break;
      case "float":
      case "int":
        defaultValue2 = Number(defaultValue2);
        break;
      case "vec2":
      case "vec3":
      case "vec4":
      case "ivec2":
      case "ivec3":
      case "ivec4":
      case "mat2":
      case "mat3":
      case "mat4":
        if (defaultValue2) {
          defaultValue2 = defaultValue2.replace("[", "").replace("]", "").split(",").reduce((prev, cur) => {
            prev.push(Number(cur.trim()));
            return prev;
          }, []);
        } else {
          defaultValue2 = new Array(getUniformLengthByType(type)).fill(0);
        }
        break;
      default:
    }
    uniforms[uniformName] = defaultValue2;
    return `${uniformPrefix ? "uniform " : ""}${type} ${uniformName};
`;
  });
  return {
    content,
    uniforms
  };
}
function extractUniforms(content) {
  let {
    content: c,
    uniforms: u
  } = fillUniforms(content, true);
  c = c.replace(/(\s*uniform\s*.*\s*){((?:\s*.*\s*)*?)};/g, (substr, header, uniforms) => {
    uniforms = uniforms.trim().replace(/^.*$/gm, (uniform) => {
      return `uniform ${uniform}`;
    });
    const {
      content: cc,
      uniforms: uu
    } = fillUniforms(uniforms);
    Object.assign(u, uu);
    return `${header}{
${cc}
};`;
  });
  return {
    content: c,
    uniforms: u
  };
}
function removeDuplicateUniforms(content) {
  const uniforms = {};
  return content.replace(uniformRegExp, (_, type, uniformName) => {
    const name = uniformName.trim();
    if (!uniforms[name]) {
      uniforms[name] = true;
      return `uniform ${type} ${name};
`;
    } else {
      return "";
    }
  });
}

// node_modules/@antv/l7-core/es/utils/sdf-2d.js
var sdf2DFunctions = ["circle", "triangle", "square", "pentagon", "hexagon", "octogon", "hexagram", "rhombus", "vesica"];
function getShapeIndex(shape) {
  return sdf2DFunctions.indexOf(shape);
}

// node_modules/@antv/l7-core/es/utils/vertex-compression.js
var {
  clamp: clamp2
} = lodashUtil;
var LEFT_SHIFT6 = 64;
var LEFT_SHIFT16 = 32768 * 2;
var LEFT_SHIFT17 = 131072;
var LEFT_SHIFT19 = 524288;
var LEFT_SHIFT21 = 2097152;
var LEFT_SHIFT23 = 8388608;
var LEFT_SHIFT25 = 16777216 * 2;
function packUint8ToFloat(a, b) {
  a = clamp2(Math.floor(a), 0, 255);
  b = clamp2(Math.floor(b), 0, 255);
  return 256 * a + b;
}
function packCircleVertex(props) {
  const {
    color: color2,
    radius,
    tileX,
    tileY,
    shape,
    opacity,
    // packed buffer1
    stroke,
    strokeWidth,
    strokeOpacity
    // packed buffer2
  } = props;
  const packedBuffer = [];
  const packedBuffer2 = [];
  const packedBuffer3 = [];
  const packedColor = [packUint8ToFloat(color2[0], color2[1]), packUint8ToFloat(color2[2], color2[3])];
  const packedStrokeColor = [packUint8ToFloat(stroke[0], stroke[1]), packUint8ToFloat(stroke[2], stroke[3])];
  [[-1, -1], [1, -1], [1, 1], [-1, 1]].forEach(([extrudeX, extrudeY]) => {
    packedBuffer.push([...packedColor, (extrudeX + 1) * LEFT_SHIFT23 + (extrudeY + 1) * LEFT_SHIFT21 + getShapeIndex(shape) * LEFT_SHIFT17 + radius, (tileX + 512) * LEFT_SHIFT19 + (tileY + 512) * LEFT_SHIFT6]);
    packedBuffer2.push([...packedStrokeColor, strokeWidth, strokeOpacity]);
    packedBuffer3.push([opacity, 0, 0, 0]);
  });
  return {
    packedBuffer,
    packedBuffer2,
    packedBuffer3
  };
}

// node_modules/@antv/l7-core/es/services/camera/ICameraService.js
var CameraUniform = {
  ProjectionMatrix: "u_ProjectionMatrix",
  ViewMatrix: "u_ViewMatrix",
  ViewProjectionMatrix: "u_ViewProjectionMatrix",
  Zoom: "u_Zoom",
  ZoomScale: "u_ZoomScale",
  FocalDistance: "u_FocalDistance",
  CameraPosition: "u_CameraPosition"
};

// node_modules/@antv/l7-core/es/services/component/IControlService.js
var PositionType = function(PositionType2) {
  PositionType2["TOPRIGHT"] = "topright";
  PositionType2["TOPLEFT"] = "topleft";
  PositionType2["BOTTOMRIGHT"] = "bottomright";
  PositionType2["BOTTOMLEFT"] = "bottomleft";
  PositionType2["TOPCENTER"] = "topcenter";
  PositionType2["BOTTOMCENTER"] = "bottomcenter";
  PositionType2["LEFTCENTER"] = "leftcenter";
  PositionType2["RIGHTCENTER"] = "rightcenter";
  PositionType2["LEFTTOP"] = "lefttop";
  PositionType2["RIGHTTOP"] = "righttop";
  PositionType2["LEFTBOTTOM"] = "leftbottom";
  PositionType2["RIGHTBOTTOM"] = "rightbottom";
  return PositionType2;
}({});

// node_modules/@antv/l7-core/es/services/coordinate/ICoordinateSystemService.js
var CoordinateSystem = function(CoordinateSystem2) {
  CoordinateSystem2[CoordinateSystem2["LNGLAT"] = 1] = "LNGLAT";
  CoordinateSystem2[CoordinateSystem2["LNGLAT_OFFSET"] = 2] = "LNGLAT_OFFSET";
  CoordinateSystem2[CoordinateSystem2["VECTOR_TILE"] = 3] = "VECTOR_TILE";
  CoordinateSystem2[CoordinateSystem2["IDENTITY"] = 4] = "IDENTITY";
  CoordinateSystem2[CoordinateSystem2["METER_OFFSET"] = 5] = "METER_OFFSET";
  return CoordinateSystem2;
}({});
var CoordinateUniform = {
  CoordinateSystem: "u_CoordinateSystem",
  ViewportCenter: "u_ViewportCenter",
  ViewportCenterProjection: "u_ViewportCenterProjection",
  PixelsPerDegree: "u_PixelsPerDegree",
  PixelsPerDegree2: "u_PixelsPerDegree2",
  PixelsPerMeter: "u_PixelsPerMeter"
};

// node_modules/@antv/l7-core/es/services/debug/IDebugService.js
var IDebugLog = {
  MapInitStart: "mapInitStart",
  LayerInitStart: "layerInitStart",
  LayerInitEnd: "layerInitEnd",
  SourceInitStart: "sourceInitStart",
  SourceInitEnd: "sourceInitEnd",
  ScaleInitStart: "scaleInitStart",
  ScaleInitEnd: "scaleInitEnd",
  MappingStart: "mappingStart",
  MappingEnd: "mappingEnd",
  BuildModelStart: "buildModelStart",
  BuildModelEnd: "buildModelEnd"
};

// node_modules/@antv/l7-core/es/services/interaction/IInteractionService.js
var InteractionEvent = function(InteractionEvent2) {
  InteractionEvent2["Hover"] = "hover";
  InteractionEvent2["Click"] = "click";
  InteractionEvent2["Select"] = "select";
  InteractionEvent2["Active"] = "active";
  InteractionEvent2["Drag"] = "drag";
  return InteractionEvent2;
}({});

// node_modules/@antv/l7-core/es/services/layer/ILayerService.js
var BlendType = function(BlendType2) {
  BlendType2["normal"] = "normal";
  BlendType2["additive"] = "additive";
  BlendType2["subtractive"] = "subtractive";
  BlendType2["min"] = "min";
  BlendType2["max"] = "max";
  BlendType2["none"] = "none";
  return BlendType2;
}({});
var StencilType = function(StencilType2) {
  StencilType2["MULTIPLE"] = "MULTIPLE";
  StencilType2["SINGLE"] = "SINGLE";
  return StencilType2;
}({});
var MaskOperation = function(MaskOperation2) {
  MaskOperation2["AND"] = "and";
  MaskOperation2["OR"] = "or";
  return MaskOperation2;
}({});
var ILayerStage = function(ILayerStage2) {
  ILayerStage2["INIT"] = "init";
  ILayerStage2["UPDATE"] = "update";
  return ILayerStage2;
}({});

// node_modules/@antv/l7-core/es/services/layer/IStyleAttributeService.js
var ScaleTypes = function(ScaleTypes2) {
  ScaleTypes2["LINEAR"] = "linear";
  ScaleTypes2["SEQUENTIAL"] = "sequential";
  ScaleTypes2["POWER"] = "power";
  ScaleTypes2["LOG"] = "log";
  ScaleTypes2["IDENTITY"] = "identity";
  ScaleTypes2["TIME"] = "time";
  ScaleTypes2["QUANTILE"] = "quantile";
  ScaleTypes2["QUANTIZE"] = "quantize";
  ScaleTypes2["THRESHOLD"] = "threshold";
  ScaleTypes2["CAT"] = "cat";
  ScaleTypes2["DIVERGING"] = "diverging";
  ScaleTypes2["CUSTOM"] = "threshold";
  return ScaleTypes2;
}({});
var StyleScaleType = function(StyleScaleType2) {
  StyleScaleType2["CONSTANT"] = "constant";
  StyleScaleType2["VARIABLE"] = "variable";
  return StyleScaleType2;
}({});
var AttributeType = function(AttributeType2) {
  AttributeType2[AttributeType2["Attribute"] = 0] = "Attribute";
  AttributeType2[AttributeType2["InstancedAttribute"] = 1] = "InstancedAttribute";
  AttributeType2[AttributeType2["Uniform"] = 2] = "Uniform";
  return AttributeType2;
}({});

// node_modules/@antv/l7-core/es/services/map/IMapService.js
var MapServiceEvent = ["mapload", "mapchange", "mapAfterFrameChange"];

// node_modules/@antv/l7-core/es/services/asset/FontService.js
var import_tiny_sdf = __toESM(require_tiny_sdf());
var import_eventemitter33 = __toESM(require_eventemitter3());

// node_modules/@antv/l7-core/es/utils/font_util.js
var glyphSizeInSDF = 30;
function buildMapping({
  characterSet,
  getFontWidth,
  fontHeight,
  buffer,
  maxCanvasWidth,
  mapping = {},
  xOffset = 0,
  yOffset = 0
}) {
  let row = 0;
  let x2 = xOffset;
  Array.from(characterSet).forEach((char, i2) => {
    if (!mapping[char]) {
      const width = getFontWidth(char, i2);
      if (x2 + glyphSizeInSDF > maxCanvasWidth) {
        x2 = 0;
        row++;
      }
      mapping[char] = {
        x: x2,
        y: yOffset + row * glyphSizeInSDF,
        width: glyphSizeInSDF,
        height: glyphSizeInSDF,
        advance: width
      };
      x2 += glyphSizeInSDF;
    }
  });
  const rowHeight = fontHeight + buffer * 2;
  return {
    mapping,
    xOffset: x2,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)
  };
}
function buildIconMaping(icons, buffer, maxCanvasWidth) {
  let xOffset = 0;
  let yOffset = 0;
  let rowHeight = 0;
  let columns = [];
  const mapping = {};
  for (const icon of icons) {
    if (!mapping[icon.id]) {
      const {
        size
      } = icon;
      if (xOffset + size + buffer > maxCanvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }
      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + size + buffer;
      rowHeight = Math.max(rowHeight, size);
    }
  }
  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }
  const canvasHeight = nextPowOfTwo(rowHeight + yOffset + buffer);
  return {
    mapping,
    canvasHeight
  };
}
function buildRowMapping(mapping, columns, yOffset) {
  for (const column of columns) {
    const {
      icon,
      xOffset
    } = column;
    mapping[icon.id] = _objectSpread2(_objectSpread2({}, icon), {}, {
      x: xOffset,
      y: yOffset,
      image: icon.image,
      width: icon.width,
      height: icon.height
    });
  }
}
function nextPowOfTwo(num) {
  return Math.pow(2, Math.ceil(Math.log2(num)));
}

// node_modules/@antv/l7-core/es/services/asset/FontService.js
var DEFAULT_CHAR_SET = getDefaultCharacterSet();
var DEFAULT_FONT_FAMILY = "sans-serif";
var DEFAULT_FONT_WEIGHT = "normal";
var DEFAULT_FONT_SIZE = 24;
var DEFAULT_BUFFER = 3;
var DEFAULT_CUTOFF = 0.25;
var DEFAULT_RADIUS = 8;
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 1;
var HEIGHT_SCALE = 1;
var CACHE_LIMIT = 3;
function getDefaultCharacterSet() {
  const charSet = [];
  for (let i2 = 32; i2 < 128; i2++) {
    charSet.push(String.fromCharCode(i2));
  }
  return charSet;
}
function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
  ctx.fillStyle = "black";
  ctx.textBaseline = "middle";
}
function populateAlphaChannel(alphaChannel, imageData) {
  for (let i2 = 0; i2 < alphaChannel.length; i2++) {
    imageData.data[4 * i2 + 3] = alphaChannel[i2];
  }
}
var FontService = class extends import_eventemitter33.EventEmitter {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "fontAtlas", void 0);
    _defineProperty(this, "iconFontMap", void 0);
    _defineProperty(this, "iconFontGlyphs", {});
    _defineProperty(this, "fontOptions", void 0);
    _defineProperty(this, "key", void 0);
    _defineProperty(this, "cache", new LRUCache(CACHE_LIMIT));
  }
  get scale() {
    return HEIGHT_SCALE;
  }
  get canvas() {
    const data = this.cache.get(this.key);
    return data && data.data;
  }
  get mapping() {
    const data = this.cache.get(this.key);
    return data && data.mapping || {};
  }
  getCanvasByKey(key) {
    const data = this.cache.get(key);
    return data && data.data;
  }
  getMappingByKey(key) {
    const data = this.cache.get(key);
    return data && data.mapping || {};
  }
  init() {
    this.cache.clear();
    this.fontOptions = {
      fontFamily: DEFAULT_FONT_FAMILY,
      fontWeight: DEFAULT_FONT_WEIGHT,
      characterSet: DEFAULT_CHAR_SET,
      fontSize: DEFAULT_FONT_SIZE,
      buffer: DEFAULT_BUFFER,
      sdf: true,
      cutoff: DEFAULT_CUTOFF,
      radius: DEFAULT_RADIUS,
      iconfont: false
    };
    this.key = "";
    this.iconFontMap = /* @__PURE__ */ new Map();
  }
  addIconGlyphs(glyphs) {
    glyphs.forEach((glyph) => {
      this.iconFontGlyphs[glyph.name] = glyph.unicode;
    });
  }
  /**
   * 添加对 iconfont unicode 的映射
   * @param fontUnicode
   * @param name
   */
  addIconFont(name, fontUnicode) {
    this.iconFontMap.set(name, fontUnicode);
  }
  /**
   * 获取自定义 iconfont 别称对应的 unicode 编码，若是当前的 map 中没有对应的键值对，那么就返回原值
   * @param name
   * @returns
   */
  getIconFontKey(name) {
    return this.iconFontMap.get(name) || name;
  }
  getGlyph(name) {
    if (this.iconFontGlyphs[name]) {
      return String.fromCharCode(parseInt(this.iconFontGlyphs[name], 16));
    }
    return "";
  }
  setFontOptions(option) {
    this.fontOptions = _objectSpread2(_objectSpread2({}, this.fontOptions), option);
    this.key = this.getKey();
    const charSet = this.getNewChars(this.key, this.fontOptions.characterSet);
    const cachedFontAtlas = this.cache.get(this.key);
    if (cachedFontAtlas && charSet.length === 0) {
      return;
    }
    const fontAtlas = this.generateFontAtlas(this.key, charSet, cachedFontAtlas);
    this.fontAtlas = fontAtlas;
    this.cache.set(this.key, fontAtlas);
  }
  /**
   * 用户自定义添加第三方字体 （用户使用 layer/point/text/iconfont 的前提需要加载第三方字体文件）
   * @param fontFamily
   * @param fontPath
   */
  addFontFace(fontFamily, fontPath) {
    const style = document.createElement("style");
    style.type = "text/css";
    style.innerText = `
        @font-face{
            font-family: '${fontFamily}';
            src: url('${fontPath}') format('woff2'),
            url('${fontPath}') format('woff'),
            url('${fontPath}') format('truetype');
        }`;
    style.onload = () => {
      if (document.fonts) {
        try {
          document.fonts.load(`24px ${fontFamily}`, "L7text");
          document.fonts.ready.then(() => {
            this.emit("fontloaded", {
              fontFamily
            });
          });
        } catch (e) {
          console.warn("当前环境不支持 document.fonts !");
          console.warn("当前环境不支持 iconfont !");
          console.warn(e);
        }
      }
    };
    document.getElementsByTagName("head")[0].appendChild(style);
  }
  destroy() {
    this.cache.clear();
    this.iconFontMap.clear();
  }
  generateFontAtlas(key, characterSet, cachedFontAtlas) {
    const {
      fontFamily,
      fontWeight,
      fontSize,
      buffer,
      sdf,
      radius,
      cutoff,
      iconfont
    } = this.fontOptions;
    let canvas = cachedFontAtlas && cachedFontAtlas.data;
    if (!canvas) {
      canvas = window.document.createElement("canvas");
      canvas.width = MAX_CANVAS_WIDTH;
    }
    const ctx = canvas.getContext("2d", {
      willReadFrequently: true
    });
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    const {
      mapping,
      canvasHeight,
      xOffset,
      yOffset
    } = buildMapping(_objectSpread2({
      getFontWidth: (char) => ctx.measureText(char).width,
      fontHeight: fontSize * HEIGHT_SCALE,
      buffer,
      characterSet,
      maxCanvasWidth: MAX_CANVAS_WIDTH
    }, cachedFontAtlas && {
      mapping: cachedFontAtlas.mapping,
      xOffset: cachedFontAtlas.xOffset,
      yOffset: cachedFontAtlas.yOffset
    }));
    const copyImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    canvas.height = canvasHeight;
    ctx.putImageData(copyImageData, 0, 0);
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    if (sdf) {
      const tinySDF = new import_tiny_sdf.default(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);
      const imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);
      for (const char of characterSet) {
        if (iconfont) {
          const icon = String.fromCharCode(parseInt(char.replace("&#x", "").replace(";", ""), 16));
          const iconData = tinySDF.draw(icon);
          populateAlphaChannel(iconData, imageData);
        } else {
          populateAlphaChannel(tinySDF.draw(char), imageData);
        }
        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
      }
    } else {
      for (const char of characterSet) {
        ctx.fillText(char, mapping[char].x, mapping[char].y + fontSize * BASELINE_SCALE);
      }
    }
    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas,
      width: canvas.width,
      height: canvas.height
    };
  }
  getKey() {
    const {
      fontFamily,
      fontWeight
    } = this.fontOptions;
    return `${fontFamily}_${fontWeight}`;
  }
  /**
   *
   * @param key
   * @param characterSet
   * @returns
   * 若是相同的 key，那么将字符存储到同同一个字符列表中
   */
  getNewChars(key, characterSet) {
    const cachedFontAtlas = this.cache.get(key);
    if (!cachedFontAtlas) {
      return characterSet;
    }
    const newChars = [];
    const cachedMapping = cachedFontAtlas.mapping;
    const cachedCharSet = new Set(Object.keys(cachedMapping));
    const charSet = new Set(characterSet);
    charSet.forEach((char) => {
      if (!cachedCharSet.has(char)) {
        newChars.push(char);
      }
    });
    return newChars;
  }
};

// node_modules/@antv/l7-core/es/services/asset/IconService.js
var import_eventemitter34 = __toESM(require_eventemitter3());
var BUFFER = 3;
var MAX_CANVAS_WIDTH2 = 1024;
var imageSize = 64;
var IconService = class extends import_eventemitter34.EventEmitter {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "canvasHeight", 128);
    _defineProperty(this, "texture", void 0);
    _defineProperty(this, "canvas", void 0);
    _defineProperty(this, "iconData", void 0);
    _defineProperty(this, "iconMap", void 0);
    _defineProperty(this, "ctx", void 0);
    _defineProperty(this, "loadingImageCount", 0);
  }
  isLoading() {
    return this.loadingImageCount === 0;
  }
  init() {
    this.iconData = [];
    this.iconMap = {};
    this.canvas = window.document.createElement("canvas");
    this.canvas.width = 128;
    this.canvas.height = 128;
    this.ctx = this.canvas.getContext("2d");
  }
  addImage(id2, image) {
    var _this = this;
    return _asyncToGenerator(function* () {
      let imagedata = new Image();
      _this.loadingImageCount++;
      if (_this.hasImage(id2)) {
        console.warn("Image Id already exists");
      } else {
        _this.iconData.push({
          id: id2,
          size: imageSize
        });
      }
      _this.updateIconMap();
      imagedata = yield _this.loadImage(image);
      const iconImage = _this.iconData.find((icon) => {
        return icon.id === id2;
      });
      if (iconImage) {
        iconImage.image = imagedata;
        iconImage.width = imagedata.width;
        iconImage.height = imagedata.height;
      }
      _this.update();
    })();
  }
  /**
   * 适配小程序
   * @param id
   * @param image
   * @param sceneService
   */
  addImageMini(id2, image, sceneService) {
    const canvas = sceneService.getSceneConfig().canvas;
    let imagedata = canvas.createImage();
    this.loadingImageCount++;
    if (this.hasImage(id2)) {
      throw new Error("Image Id already exists");
    }
    this.iconData.push({
      id: id2,
      size: imageSize
    });
    this.updateIconMap();
    this.loadImageMini(image, canvas).then((img) => {
      imagedata = img;
      const iconImage = this.iconData.find((icon) => {
        return icon.id === id2;
      });
      if (iconImage) {
        iconImage.image = imagedata;
        iconImage.width = imagedata.width;
        iconImage.height = imagedata.height;
      }
      this.update();
    });
  }
  getTexture() {
    return this.texture;
  }
  getIconMap() {
    return this.iconMap;
  }
  getCanvas() {
    return this.canvas;
  }
  hasImage(id2) {
    return this.iconMap.hasOwnProperty(id2);
  }
  removeImage(id2) {
    if (this.hasImage(id2)) {
      this.iconData = this.iconData.filter((icon) => {
        return icon.id !== id2;
      });
      delete this.iconMap[id2];
      this.update();
    }
  }
  destroy() {
    this.removeAllListeners("imageUpdate");
    this.iconData = [];
    this.iconMap = {};
  }
  loadImage(url) {
    return new Promise((resolve, reject) => {
      if (url instanceof HTMLImageElement) {
        resolve(url);
        return;
      }
      const image = new Image();
      image.crossOrigin = "anonymous";
      image.onload = () => {
        resolve(image);
      };
      image.onerror = () => {
        reject(new Error("Could not load image at " + url));
      };
      image.src = url instanceof File ? URL.createObjectURL(url) : url;
    });
  }
  update() {
    this.updateIconMap();
    this.updateIconAtlas();
    this.loadingImageCount--;
    if (this.loadingImageCount === 0) {
      this.emit("imageUpdate");
    }
  }
  /**
   * 将新增的 icon 图像存储到画布上（正方形）
   */
  updateIconAtlas() {
    this.canvas.width = MAX_CANVAS_WIDTH2;
    this.canvas.height = this.canvasHeight;
    Object.keys(this.iconMap).forEach((item) => {
      const {
        x: x2,
        y,
        image,
        width = 64,
        height = 64
      } = this.iconMap[item];
      const max6 = Math.max(width, height);
      const ratio = max6 / imageSize;
      const drawHeight = height / ratio;
      const drawWidth = width / ratio;
      if (image) {
        this.ctx.drawImage(image, x2 + (imageSize - drawWidth) / 2, y + (imageSize - drawHeight) / 2, drawWidth, drawHeight);
      }
    });
  }
  /**
   * 计算 icon 在画布上的排布（是否需要换行）
   */
  updateIconMap() {
    const {
      mapping,
      canvasHeight
    } = buildIconMaping(this.iconData, BUFFER, MAX_CANVAS_WIDTH2);
    this.iconMap = mapping;
    this.canvasHeight = canvasHeight;
  }
  /**
   * 适配小程序
   * @param url
   * @returns
   */
  loadImageMini(url, canvas) {
    return new Promise((resolve, reject) => {
      const image = canvas.createImage();
      image.crossOrigin = "anonymous";
      image.onload = () => {
        resolve(image);
      };
      image.onerror = () => {
        reject(new Error("Could not load image at " + url));
      };
      image.src = url;
    });
  }
};

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i2 = arguments.length;
    while (i2--) {
      y += arguments[i2] * arguments[i2];
    }
    return Math.sqrt(y);
  };

// node_modules/gl-matrix/esm/mat2.js
var mat2_exports = {};
__export(mat2_exports, {
  LDU: () => LDU,
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create2,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transpose: () => transpose
});
function create2() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function fromValues(m00, m01, m10, m11) {
  var out = new ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }
  return out;
}
function invert(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var det = a0 * a3 - a2 * a1;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
function adjoint(out, a) {
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
function multiply(out, a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
function rotate(out, a, rad) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
function scale(out, a, v) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
function LDU(L2, D2, U, a) {
  L2[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L2[2] * U[1];
  return [L2, D2, U];
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale6) {
  out[0] = a[0] + b[0] * scale6;
  out[1] = a[1] + b[1] * scale6;
  out[2] = a[2] + b[2] * scale6;
  out[3] = a[3] + b[3] * scale6;
  return out;
}
var mul = multiply;
var sub = subtract;

// node_modules/gl-matrix/esm/mat3.js
function create3() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add2,
  adjoint: () => adjoint2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create4,
  determinant: () => determinant2,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity2,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  targetTo: () => targetTo,
  translate: () => translate,
  transpose: () => transpose2
});
function create4() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant2(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply2(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate(out, a, v) {
  var x2 = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x2 + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x2 + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x2 + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x2 + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x2 + a10 * y + a20 * z + a[12];
    out[13] = a01 * x2 + a11 * y + a21 * z + a[13];
    out[14] = a02 * x2 + a12 * y + a22 * z + a[14];
    out[15] = a03 * x2 + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale2(out, a, v) {
  var x2 = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x2;
  out[1] = a[1] * x2;
  out[2] = a[2] * x2;
  out[3] = a[3] * x2;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate2(out, a, rad, axis) {
  var x2 = axis[0], y = axis[1], z = axis[2];
  var len4 = Math.hypot(x2, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len4 < EPSILON) {
    return null;
  }
  len4 = 1 / len4;
  x2 *= len4;
  y *= len4;
  z *= len4;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x2 * x2 * t + c;
  b01 = y * x2 * t + z * s;
  b02 = z * x2 * t - y * s;
  b10 = x2 * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x2 * s;
  b20 = x2 * z * t + y * s;
  b21 = y * z * t - x2 * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad, axis) {
  var x2 = axis[0], y = axis[1], z = axis[2];
  var len4 = Math.hypot(x2, y, z);
  var s, c, t;
  if (len4 < EPSILON) {
    return null;
  }
  len4 = 1 / len4;
  x2 *= len4;
  y *= len4;
  z *= len4;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  out[0] = x2 * x2 * t + c;
  out[1] = y * x2 * t + z * s;
  out[2] = z * x2 * t - y * s;
  out[3] = 0;
  out[4] = x2 * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x2 * s;
  out[7] = 0;
  out[8] = x2 * z * t + y * s;
  out[9] = y * z * t - x2 * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x2 = q[0], y = q[1], z = q[2], w = q[3];
  var x22 = x2 + x2;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x2 * x22;
  var xy = x2 * y2;
  var xz = x2 * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx2 = w * x22;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx2;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx2;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x2 = q[0], y = q[1], z = q[2], w = q[3];
  var x22 = x2 + x2;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x2 * x22;
  var xy = x2 * y2;
  var xz = x2 * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx2 = w * x22;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx2) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx2) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  var x2 = q[0], y = q[1], z = q[2], w = q[3];
  var x22 = x2 + x2;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x2 * x22;
  var xy = x2 * y2;
  var xz = x2 * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx2 = w * x22;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx2) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx2) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat(out, q) {
  var x2 = q[0], y = q[1], z = q[2], w = q[3];
  var x22 = x2 + x2;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x2 * x22;
  var yx = y * x22;
  var yy = y * y2;
  var zx = z * x22;
  var zy = z * y2;
  var zz = z * z2;
  var wx2 = w * x22;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx2;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx2;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len4;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len4 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len4;
  z1 *= len4;
  z2 *= len4;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len4 = Math.hypot(x0, x1, x2);
  if (!len4) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len4 = 1 / len4;
    x0 *= len4;
    x1 *= len4;
    x2 *= len4;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len4 = Math.hypot(y0, y1, y2);
  if (!len4) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len4 = 1 / len4;
    y0 *= len4;
    y1 *= len4;
    y2 *= len4;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len4 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
    z0 *= len4;
    z1 *= len4;
    z2 *= len4;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len4 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
    x0 *= len4;
    x1 *= len4;
    x2 *= len4;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function frob2(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
function multiplyScalar2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a, b, scale6) {
  out[0] = a[0] + b[0] * scale6;
  out[1] = a[1] + b[1] * scale6;
  out[2] = a[2] + b[2] * scale6;
  out[3] = a[3] + b[3] * scale6;
  out[4] = a[4] + b[4] * scale6;
  out[5] = a[5] + b[5] * scale6;
  out[6] = a[6] + b[6] * scale6;
  out[7] = a[7] + b[7] * scale6;
  out[8] = a[8] + b[8] * scale6;
  out[9] = a[9] + b[9] * scale6;
  out[10] = a[10] + b[10] * scale6;
  out[11] = a[11] + b[11] * scale6;
  out[12] = a[12] + b[12] * scale6;
  out[13] = a[13] + b[13] * scale6;
  out[14] = a[14] + b[14] * scale6;
  out[15] = a[15] + b[15] * scale6;
  return out;
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract2;

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add3,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone3,
  copy: () => copy3,
  create: () => create5,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max2,
  min: () => min2,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize2,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set3,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create5() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone3(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x2 = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x2, y, z);
}
function fromValues3(x2, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x2;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set3(out, x2, y, z) {
  out[0] = x2;
  out[1] = y;
  out[2] = z;
  return out;
}
function add3(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply3(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale6) {
  out[0] = a[0] + b[0] * scale6;
  out[1] = a[1] + b[1] * scale6;
  out[2] = a[2] + b[2] * scale6;
  return out;
}
function distance(a, b) {
  var x2 = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x2, y, z);
}
function squaredDistance(a, b) {
  var x2 = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x2 * x2 + y * y + z * z;
}
function squaredLength(a) {
  var x2 = a[0];
  var y = a[1];
  var z = a[2];
  return x2 * x2 + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize2(out, a) {
  var x2 = a[0];
  var y = a[1];
  var z = a[2];
  var len4 = x2 * x2 + y * y + z * z;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a[0] * len4;
  out[1] = a[1] * len4;
  out[2] = a[2] * len4;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale6) {
  scale6 = scale6 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale6;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale6;
  return out;
}
function transformMat4(out, a, m) {
  var x2 = a[0], y = a[1], z = a[2];
  var w = m[3] * x2 + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x2 + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x2 + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x2 + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x2 = a[0], y = a[1], z = a[2];
  out[0] = x2 * m[0] + y * m[3] + z * m[6];
  out[1] = x2 * m[1] + y * m[4] + z * m[7];
  out[2] = x2 * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x2 = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x2 - qx * z, uvz = qx * y - qy * x2;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x2 + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals3(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub3 = subtract3;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create5();
  return function(a, stride, offset, count, fn, arg) {
    var i2, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i2 = offset; i2 < l; i2 += stride) {
      vec[0] = a[i2];
      vec[1] = a[i2 + 1];
      vec[2] = a[i2 + 2];
      fn(vec, vec, arg);
      a[i2] = vec[0];
      a[i2 + 1] = vec[1];
      a[i2 + 2] = vec[2];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil2,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create6,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max3,
  min: () => min3,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize3,
  random: () => random2,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create6() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone4(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues4(x2, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x2;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set4(out, x2, y, z, w) {
  out[0] = x2;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function subtract4(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
function multiply4(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
function min3(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
function max3(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
function scale4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale6) {
  out[0] = a[0] + b[0] * scale6;
  out[1] = a[1] + b[1] * scale6;
  out[2] = a[2] + b[2] * scale6;
  out[3] = a[3] + b[3] * scale6;
  return out;
}
function distance2(a, b) {
  var x2 = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x2, y, z, w);
}
function squaredDistance2(a, b) {
  var x2 = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x2 * x2 + y * y + z * z + w * w;
}
function length2(a) {
  var x2 = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x2, y, z, w);
}
function squaredLength2(a) {
  var x2 = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x2 * x2 + y * y + z * z + w * w;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  out[3] = 1 / a[3];
  return out;
}
function normalize3(out, a) {
  var x2 = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len4 = x2 * x2 + y * y + z * z + w * w;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = x2 * len4;
  out[1] = y * len4;
  out[2] = z * len4;
  out[3] = w * len4;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function cross2(out, u, v, w) {
  var A2 = v[0] * w[1] - v[1] * w[0], B2 = v[0] * w[2] - v[2] * w[0], C2 = v[0] * w[3] - v[3] * w[0], D2 = v[1] * w[2] - v[2] * w[1], E2 = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E2 + J * D2;
  out[1] = -(G * F) + I * C2 - J * B2;
  out[2] = G * E2 - H * C2 + J * A2;
  out[3] = -(G * D2) + H * B2 - I * A2;
  return out;
}
function lerp2(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random2(out, scale6) {
  scale6 = scale6 || 1;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale6 * v1;
  out[1] = scale6 * v2;
  out[2] = scale6 * v3 * d;
  out[3] = scale6 * v4 * d;
  return out;
}
function transformMat42(out, a, m) {
  var x2 = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x2 + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x2 + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x2 + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x2 + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
function transformQuat2(out, a, q) {
  var x2 = a[0], y = a[1], z = a[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x2 + qy * z - qz * y;
  var iy = qw * y + qz * x2 - qx * z;
  var iz = qw * z + qx * y - qy * x2;
  var iw = -qx * x2 - qy * y - qz * z;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub4 = subtract4;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create6();
  return function(a, stride, offset, count, fn, arg) {
    var i2, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i2 = offset; i2 < l; i2 += stride) {
      vec[0] = a[i2];
      vec[1] = a[i2 + 1];
      vec[2] = a[i2 + 2];
      vec[3] = a[i2 + 3];
      fn(vec, vec, arg);
      a[i2] = vec[0];
      a[i2 + 1] = vec[1];
      a[i2 + 2] = vec[2];
      a[i2 + 3] = vec[3];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create7() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i2 = 0;
    if (m[4] > m[0])
      i2 = 1;
    if (m[8] > m[i2 * 3 + i2])
      i2 = 2;
    var j = (i2 + 1) % 3;
    var k = (i2 + 2) % 3;
    fRoot = Math.sqrt(m[i2 * 3 + i2] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i2] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i2] + m[i2 * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i2] + m[i2 * 3 + k]) * fRoot;
  }
  return out;
}
var normalize4 = normalize3;
var rotationTo = function() {
  var tmpvec3 = create5();
  var xUnitVec3 = fromValues3(1, 0, 0);
  var yUnitVec3 = fromValues3(0, 1, 0);
  return function(out, a, b) {
    var dot5 = dot(a, b);
    if (dot5 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot5 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot5;
      return normalize4(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create7();
  var temp2 = create7();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create3();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize4(out, fromMat3(out, matr));
  };
}();

// node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add5,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone5,
  copy: () => copy6,
  create: () => create8,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot4,
  equals: () => equals5,
  exactEquals: () => exactEquals5,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues5,
  inverse: () => inverse3,
  len: () => len3,
  length: () => length4,
  lerp: () => lerp3,
  max: () => max4,
  min: () => min4,
  mul: () => mul5,
  multiply: () => multiply5,
  negate: () => negate3,
  normalize: () => normalize5,
  random: () => random3,
  rotate: () => rotate3,
  round: () => round3,
  scale: () => scale5,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set5,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen3,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength4,
  str: () => str5,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create8() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone5(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues5(x2, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x2;
  out[1] = y;
  return out;
}
function copy6(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set5(out, x2, y) {
  out[0] = x2;
  out[1] = y;
  return out;
}
function add5(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract5(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply5(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide3(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil3(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor3(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min4(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max4(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round3(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale5(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd3(out, a, b, scale6) {
  out[0] = a[0] + b[0] * scale6;
  out[1] = a[1] + b[1] * scale6;
  return out;
}
function distance3(a, b) {
  var x2 = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x2, y);
}
function squaredDistance3(a, b) {
  var x2 = b[0] - a[0], y = b[1] - a[1];
  return x2 * x2 + y * y;
}
function length4(a) {
  var x2 = a[0], y = a[1];
  return Math.hypot(x2, y);
}
function squaredLength4(a) {
  var x2 = a[0], y = a[1];
  return x2 * x2 + y * y;
}
function negate3(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse3(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize5(out, a) {
  var x2 = a[0], y = a[1];
  var len4 = x2 * x2 + y * y;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a[0] * len4;
  out[1] = a[1] * len4;
  return out;
}
function dot4(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross3(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp3(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random3(out, scale6) {
  scale6 = scale6 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale6;
  out[1] = Math.sin(r) * scale6;
  return out;
}
function transformMat2(out, a, m) {
  var x2 = a[0], y = a[1];
  out[0] = m[0] * x2 + m[2] * y;
  out[1] = m[1] * x2 + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x2 = a[0], y = a[1];
  out[0] = m[0] * x2 + m[2] * y + m[4];
  out[1] = m[1] * x2 + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x2 = a[0], y = a[1];
  out[0] = m[0] * x2 + m[3] * y + m[6];
  out[1] = m[1] * x2 + m[4] * y + m[7];
  return out;
}
function transformMat43(out, a, m) {
  var x2 = a[0];
  var y = a[1];
  out[0] = m[0] * x2 + m[4] * y + m[12];
  out[1] = m[1] * x2 + m[5] * y + m[13];
  return out;
}
function rotate3(out, a, b, rad) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str5(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals5(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals5(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len3 = length4;
var sub5 = subtract5;
var mul5 = multiply5;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var sqrLen3 = squaredLength4;
var forEach3 = function() {
  var vec = create8();
  return function(a, stride, offset, count, fn, arg) {
    var i2, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i2 = offset; i2 < l; i2 += stride) {
      vec[0] = a[i2];
      vec[1] = a[i2 + 1];
      fn(vec, vec, arg);
      a[i2] = vec[0];
      a[i2 + 1] = vec[1];
    }
    return a;
  };
}();

// node_modules/@antv/l7-core/es/services/camera/CameraService.js
var CameraService = class {
  constructor() {
    _defineProperty(this, "viewport", void 0);
    _defineProperty(this, "overridedViewProjectionMatrix", void 0);
    _defineProperty(this, "viewMatrixInverse", void 0);
    _defineProperty(this, "cameraPosition", void 0);
  }
  init() {
  }
  /**
   * 同步根据相机参数创建的视口
   */
  update(viewport) {
    this.viewport = viewport;
    this.viewMatrixInverse = mat4_exports.create();
    mat4_exports.invert(this.viewMatrixInverse, viewport.getViewMatrix());
    this.cameraPosition = [this.viewMatrixInverse[12], this.viewMatrixInverse[13], this.viewMatrixInverse[14]];
  }
  getProjectionMatrix() {
    return this.viewport.getProjectionMatrix();
  }
  getModelMatrix() {
    return this.viewport.getModelMatrix();
  }
  getViewMatrix() {
    return this.viewport.getViewMatrix();
  }
  getViewMatrixUncentered() {
    return this.viewport.getViewMatrixUncentered();
  }
  getViewProjectionMatrixUncentered() {
    return this.viewport.getViewProjectionMatrixUncentered();
  }
  getViewProjectionMatrix() {
    return this.overridedViewProjectionMatrix || this.viewport.getViewProjectionMatrix();
  }
  getZoom() {
    return this.viewport.getZoom();
  }
  getZoomScale() {
    return this.viewport.getZoomScale();
  }
  getCenter() {
    const [lng, lat] = this.viewport.getCenter();
    return [lng, lat];
  }
  getFocalDistance() {
    return this.viewport.getFocalDistance();
  }
  getCameraPosition() {
    return this.cameraPosition;
  }
  projectFlat(lngLat, scale6) {
    return this.viewport.projectFlat(lngLat, scale6);
  }
  /**
   * 支持外部计算 VP 矩阵的场景，例如：在偏移坐标系场景中，需要重新计算 VP 矩阵
   */
  setViewProjectionMatrix(viewProjectionMatrix) {
    this.overridedViewProjectionMatrix = viewProjectionMatrix;
  }
};

// node_modules/@antv/l7-core/es/services/component/ControlService.js
var ControlDirectionConfig = {
  topleft: "column",
  topright: "column",
  bottomright: "column",
  bottomleft: "column",
  leftcenter: "column",
  rightcenter: "column",
  topcenter: "row",
  bottomcenter: "row",
  lefttop: "row",
  righttop: "row",
  leftbottom: "row",
  rightbottom: "row"
};
var ControlService = class {
  constructor() {
    _defineProperty(this, "container", void 0);
    _defineProperty(this, "controlCorners", void 0);
    _defineProperty(this, "controlContainer", void 0);
    _defineProperty(this, "scene", void 0);
    _defineProperty(this, "mapsService", void 0);
    _defineProperty(this, "controls", []);
    _defineProperty(this, "unAddControls", []);
  }
  init(cfg, sceneContainer) {
    this.container = cfg.container;
    this.scene = sceneContainer;
    this.mapsService = sceneContainer.mapService;
    this.initControlPos();
  }
  addControl(ctr, sceneContainer) {
    const mapsService = sceneContainer.mapService;
    if (mapsService.map) {
      ctr.addTo(this.scene);
      this.controls.push(ctr);
    } else {
      this.unAddControls.push(ctr);
    }
  }
  getControlByName(name) {
    return this.controls.find((ctr) => {
      return ctr.controlOption.name === name;
    });
  }
  removeControl(ctr) {
    const index = this.controls.indexOf(ctr);
    if (index > -1) {
      this.controls.splice(index, 1);
    }
    ctr.remove();
    return this;
  }
  addControls() {
    this.unAddControls.forEach((ctr) => {
      ctr.addTo(this.scene);
      this.controls.push(ctr);
    });
    this.unAddControls = [];
  }
  destroy() {
    for (const ctr of this.controls) {
      ctr.remove();
    }
    this.controls = [];
    this.clearControlPos();
  }
  initControlPos() {
    const corners = this.controlCorners = {};
    const l = "l7-";
    const container = this.controlContainer = dom_exports.create("div", l + "control-container", this.container);
    function createCorner(vSideList = []) {
      const className = vSideList.map((item) => l + item).join(" ");
      corners[vSideList.filter((item) => !["row", "column"].includes(item)).join("")] = dom_exports.create("div", className, container);
    }
    function getCornerClassList(positionName) {
      const positionList = positionName.replace(/^(top|bottom|left|right|center)/, "$1-").split("-");
      return [...positionList, ControlDirectionConfig[positionName]];
    }
    Object.values(PositionType).forEach((position) => {
      createCorner(getCornerClassList(position));
    });
    this.checkCornerOverlap();
  }
  clearControlPos() {
    for (const i2 in this.controlCorners) {
      if (this.controlCorners[i2]) {
        dom_exports.remove(this.controlCorners[i2]);
      }
    }
    if (this.controlContainer) {
      dom_exports.remove(this.controlContainer);
    }
  }
  checkCornerOverlap() {
    const Observer = window.MutationObserver;
    if (!Observer) {
      return;
    }
    for (const cornerType of Object.keys(this.controlCorners)) {
      const matchResult = cornerType.match(/^(top|bottom)(left|right)$/);
      if (matchResult) {
        const [, pos1, pos2] = matchResult;
        const dom = this.controlCorners[`${pos1}${pos2}`];
        const observer = new Observer(([{
          target
        }]) => {
          if (dom) {
            dom.style[pos1] = target.clientHeight + "px";
          }
        });
        observer.observe(this.controlCorners[`${pos2}${pos1}`], {
          childList: true,
          attributes: true
        });
      }
    }
  }
};

// node_modules/@antv/l7-core/es/services/component/MarkerService.js
var MarkerService = class {
  constructor() {
    _defineProperty(this, "container", void 0);
    _defineProperty(this, "scene", void 0);
    _defineProperty(this, "mapsService", void 0);
    _defineProperty(this, "markers", []);
    _defineProperty(this, "markerLayers", []);
    _defineProperty(this, "unAddMarkers", []);
    _defineProperty(this, "unAddMarkerLayers", []);
  }
  addMarkerLayer(markerLayer) {
    if (this.mapsService.map && this.mapsService.getMarkerContainer()) {
      this.markerLayers.push(markerLayer);
      markerLayer.addTo(this.scene);
    } else {
      this.unAddMarkerLayers.push(markerLayer);
    }
  }
  removeMarkerLayer(layer) {
    layer.destroy();
    this.markerLayers.indexOf(layer);
    const markerIndex = this.markerLayers.indexOf(layer);
    if (markerIndex > -1) {
      this.markerLayers.splice(markerIndex, 1);
    }
  }
  addMarker(marker) {
    if (this.mapsService.map && this.mapsService.getMarkerContainer()) {
      this.markers.push(marker);
      marker.addTo(this.scene);
    } else {
      this.unAddMarkers.push(marker);
    }
  }
  addMarkers() {
    this.unAddMarkers.forEach((marker) => {
      marker.addTo(this.scene);
      this.markers.push(marker);
    });
    this.unAddMarkers = [];
  }
  addMarkerLayers() {
    this.unAddMarkerLayers.forEach((markerLayer) => {
      this.markerLayers.push(markerLayer);
      markerLayer.addTo(this.scene);
    });
    this.unAddMarkers = [];
  }
  removeMarker(marker) {
    marker.remove();
    this.markers.indexOf(marker);
    const markerIndex = this.markers.indexOf(marker);
    if (markerIndex > -1) {
      this.markers.splice(markerIndex, 1);
    }
  }
  removeAllMarkers() {
    this.destroy();
  }
  init(scene) {
    this.scene = scene;
    this.mapsService = scene.mapService;
  }
  destroy() {
    this.markers.forEach((marker) => {
      marker.remove();
    });
    this.markers = [];
    this.markerLayers.forEach((layer) => {
      layer.destroy();
    });
    this.markerLayers = [];
  }
  removeMakerLayerMarker(layer) {
    layer.destroy();
  }
};

// node_modules/@antv/l7-core/es/services/component/PopupService.js
var PopupService = class {
  constructor() {
    _defineProperty(this, "scene", void 0);
    _defineProperty(this, "mapsService", void 0);
    _defineProperty(this, "popups", []);
    _defineProperty(this, "unAddPopups", []);
  }
  get isMarkerReady() {
    return this.mapsService.map && this.mapsService.getMarkerContainer();
  }
  removePopup(popup) {
    if (popup !== null && popup !== void 0 && popup.isOpen()) {
      popup.remove();
    }
    const targetIndex = this.popups.indexOf(popup);
    if (targetIndex > -1) {
      this.popups.splice(targetIndex, 1);
    }
    const targetUnAddIndex = this.unAddPopups.indexOf(popup);
    if (targetUnAddIndex > -1) {
      this.unAddPopups.splice(targetUnAddIndex, 1);
    }
  }
  destroy() {
    this.popups.forEach((popup) => popup.remove());
  }
  addPopup(popup) {
    if (popup && popup.getOptions().autoClose) {
      [...this.popups, ...this.unAddPopups].forEach((otherPopup) => {
        if (otherPopup.getOptions().autoClose) {
          this.removePopup(otherPopup);
        }
      });
    }
    if (this.isMarkerReady) {
      popup.addTo(this.scene);
      this.popups.push(popup);
    } else {
      this.unAddPopups.push(popup);
    }
    popup.on("close", () => {
      this.removePopup(popup);
    });
  }
  initPopup() {
    if (this.unAddPopups.length) {
      this.unAddPopups.forEach((popup) => {
        this.addPopup(popup);
        this.unAddPopups = [];
      });
    }
  }
  init(scene) {
    this.scene = scene;
    this.mapsService = scene.mapService;
  }
};

// node_modules/@antv/l7-core/es/services/config/warnInfo.js
var WarnInfo = {
  MapToken: "您正在使用 Demo 测试 Token, 生产环境务必自行注册 Token 确保服务稳定 高德地图申请地址 https://lbs.amap.com/api/javascript-api/guide/abc/prepare  Mapbox地图申请地址 https://docs.mapbox.com/help/glossary/access-token/",
  SDK: "请确认引入了mapbox-gl api且在L7之前引入"
};
var warnInfo_default = WarnInfo;

// node_modules/@antv/l7-core/es/services/config/ConfigService.js
var {
  merge: merge2
} = lodashUtil;
var defaultSceneConfig = {
  id: "map",
  logoPosition: "bottomleft",
  logoVisible: true,
  antialias: true,
  stencil: true,
  preserveDrawingBuffer: false,
  pickBufferScale: 1,
  fitBoundsOptions: {
    animate: false
  }
};
var defaultLayerConfig = {
  colors: ["rgb(103,0,31)", "rgb(178,24,43)", "rgb(214,96,77)", "rgb(244,165,130)", "rgb(253,219,199)", "rgb(247,247,247)", "rgb(209,229,240)", "rgb(146,197,222)", "rgb(67,147,195)", "rgb(33,102,172)", "rgb(5,48,97)"],
  size: 10,
  shape: "circle",
  scales: {},
  shape2d: ["circle", "triangle", "square", "pentagon", "hexagon", "octogon", "hexagram", "rhombus", "vesica"],
  shape3d: ["cylinder", "triangleColumn", "hexagonColumn", "squareColumn"],
  minZoom: -1,
  maxZoom: 24,
  visible: true,
  autoFit: false,
  pickingBuffer: 0,
  enablePropagation: false,
  zIndex: 0,
  blend: "normal",
  maskLayers: [],
  enableMask: true,
  maskOperation: MaskOperation.AND,
  pickedFeatureID: -1,
  enableMultiPassRenderer: false,
  enablePicking: true,
  active: false,
  activeColor: "#2f54eb",
  enableHighlight: false,
  enableSelect: false,
  highlightColor: "#2f54eb",
  activeMix: 0,
  selectColor: "blue",
  selectMix: 0,
  enableLighting: false,
  animateOption: {
    enable: false,
    interval: 0.2,
    duration: 4,
    trailLength: 0.15
  },
  forward: true
  // 默认是正方向
};
var GlobalConfigService = class {
  constructor() {
    _defineProperty(this, "sceneConfigCache", {});
    _defineProperty(this, "layerConfigCache", {});
    _defineProperty(this, "layerAttributeConfigCache", {});
  }
  /**
   * 保存每一种 Layer 配置项的校验器
   */
  // private layerConfigValidatorCache: {
  //   [layerName: string]: Ajv.ValidateFunction;
  // } = {};
  getSceneConfig(sceneId) {
    return this.sceneConfigCache[sceneId];
  }
  getSceneWarninfo(id2) {
    return warnInfo_default[id2];
  }
  setSceneConfig(sceneId, config4) {
    this.sceneConfigCache[sceneId] = _objectSpread2(_objectSpread2({}, defaultSceneConfig), config4);
  }
  // public validateSceneConfig(data: object) {
  //   return this.validate(this.sceneConfigValidator, data);
  // }
  // public validateMapConfig(data: object) {
  //   return this.validate(this.mapConfigValidator, data);
  // }
  getLayerConfig(layerId) {
    return this.layerConfigCache[layerId];
  }
  setLayerConfig(sceneId, layerId, config4) {
    this.layerConfigCache[layerId] = _objectSpread2({}, merge2({}, this.sceneConfigCache[sceneId], defaultLayerConfig, config4));
  }
  getAttributeConfig(layerId) {
    return this.layerAttributeConfigCache[layerId];
  }
  setAttributeConfig(layerId, attr) {
    this.layerAttributeConfigCache[layerId] = _objectSpread2(_objectSpread2({}, this.layerAttributeConfigCache[layerId]), attr);
  }
  clean() {
    this.sceneConfigCache = {};
    this.layerConfigCache = {};
  }
  // @postConstruct()
  // private registerSceneConfigSchemaValidator() {
  //   this.sceneConfigValidator = ajv.compile(sceneConfigSchema);
  //   this.mapConfigValidator = ajv.compile(mapConfigSchema);
  // }
  // private validate(
  //   validateFunc: Ajv.ValidateFunction | undefined,
  //   data: object,
  // ) {
  //   if (validateFunc) {
  //     const valid = validateFunc(data);
  //     if (!valid) {
  //       return {
  //         valid,
  //         errors: validateFunc.errors,
  //         errorText: ajv.errorsText(validateFunc.errors),
  //       };
  //     }
  //   }
  //   return {
  //     valid: true,
  //     errors: null,
  //     errorText: null,
  //   };
  // }
};

// node_modules/@antv/l7-core/es/utils/project.js
var DEGREES_TO_RADIANS = Math.PI / 180;
var TILE_SIZE = 512;
var EARTH_CIRCUMFERENCE = 4003e4;
function getDistanceScales({
  latitude: latitude2 = 0,
  zoom = 0,
  scale: scale6,
  highPrecision = false,
  flipY = false
}) {
  scale6 = scale6 !== void 0 ? scale6 : Math.pow(2, zoom);
  const result = {};
  const worldSize = TILE_SIZE * scale6;
  const latCosine = Math.cos(latitude2 * DEGREES_TO_RADIANS);
  const pixelsPerDegreeX = worldSize / 360;
  const pixelsPerDegreeY = pixelsPerDegreeX / latCosine;
  const altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
  result.pixelsPerMeter = [altPixelsPerMeter, -altPixelsPerMeter, altPixelsPerMeter];
  result.metersPerPixel = [1 / altPixelsPerMeter, -1 / altPixelsPerMeter, 1 / altPixelsPerMeter];
  result.pixelsPerDegree = [pixelsPerDegreeX, -pixelsPerDegreeY, altPixelsPerMeter];
  result.degreesPerPixel = [1 / pixelsPerDegreeX, -1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];
  if (highPrecision) {
    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude2 * DEGREES_TO_RADIANS) / latCosine;
    const pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;
    const altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    const altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;
    result.pixelsPerDegree2 = [0, -pixelsPerDegreeY2, altPixelsPerDegree2];
    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];
    if (flipY) {
      result.pixelsPerDegree2[1] = -result.pixelsPerDegree2[1];
      result.pixelsPerMeter2[1] = -result.pixelsPerMeter2[1];
    }
  }
  if (flipY) {
    result.pixelsPerMeter[1] = -result.pixelsPerMeter[1];
    result.metersPerPixel[1] = -result.metersPerPixel[1];
    result.pixelsPerDegree[1] = -result.pixelsPerDegree[1];
    result.degreesPerPixel[1] = -result.degreesPerPixel[1];
  }
  return result;
}

// node_modules/@antv/l7-core/es/services/coordinate/CoordinateSystemService.js
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var CoordinateSystemService = class {
  constructor(cameraService) {
    _defineProperty(this, "needRefresh", true);
    _defineProperty(this, "coordinateSystem", void 0);
    _defineProperty(this, "viewportCenter", void 0);
    _defineProperty(this, "viewportCenterProjection", void 0);
    _defineProperty(this, "pixelsPerDegree", void 0);
    _defineProperty(this, "pixelsPerDegree2", void 0);
    _defineProperty(this, "pixelsPerMeter", void 0);
    this.cameraService = cameraService;
  }
  /**
   * 重新计算当前坐标系参数
   * TODO: 使用 memoize 缓存参数以及计算结果
   */
  refresh(offsetCenter) {
    const zoom = this.cameraService.getZoom();
    const center = offsetCenter ? offsetCenter : this.cameraService.getCenter();
    const {
      pixelsPerMeter,
      pixelsPerDegree
    } = getDistanceScales({
      // longitude: center[0],
      latitude: center[1],
      zoom
    });
    this.viewportCenter = center;
    this.viewportCenterProjection = [0, 0, 0, 0];
    this.pixelsPerMeter = pixelsPerMeter;
    this.pixelsPerDegree = pixelsPerDegree;
    this.pixelsPerDegree2 = [0, 0, 0];
    if (this.coordinateSystem === CoordinateSystem.LNGLAT) {
      this.cameraService.setViewProjectionMatrix(void 0);
    } else if (this.coordinateSystem === CoordinateSystem.LNGLAT_OFFSET) {
      this.calculateLnglatOffset(center, zoom);
    }
    this.needRefresh = false;
  }
  getCoordinateSystem() {
    return this.coordinateSystem;
  }
  setCoordinateSystem(coordinateSystem) {
    this.coordinateSystem = coordinateSystem;
  }
  getViewportCenter() {
    return this.viewportCenter;
  }
  getViewportCenterProjection() {
    return this.viewportCenterProjection;
  }
  getPixelsPerDegree() {
    return this.pixelsPerDegree;
  }
  getPixelsPerDegree2() {
    return this.pixelsPerDegree2;
  }
  getPixelsPerMeter() {
    return this.pixelsPerMeter;
  }
  calculateLnglatOffset(center, zoom, scale6, flipY) {
    const {
      pixelsPerMeter: ppm,
      pixelsPerDegree: ppd,
      pixelsPerDegree2
    } = getDistanceScales({
      // longitude: center[0],
      latitude: center[1],
      zoom,
      scale: scale6,
      flipY,
      highPrecision: true
    });
    let viewMatrix = this.cameraService.getViewMatrix();
    const projectionMatrix = this.cameraService.getProjectionMatrix();
    let viewProjectionMatrix = mat4_exports.multiply([], projectionMatrix, viewMatrix);
    const positionPixels = this.cameraService.projectFlat([Math.fround(center[0]), Math.fround(center[1])], Math.pow(2, zoom));
    this.viewportCenterProjection = vec4_exports.transformMat4([], [positionPixels[0], positionPixels[1], 0, 1], viewProjectionMatrix);
    viewMatrix = this.cameraService.getViewMatrixUncentered() || viewMatrix;
    viewProjectionMatrix = mat4_exports.multiply([], projectionMatrix, viewMatrix);
    viewProjectionMatrix = mat4_exports.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
    this.cameraService.setViewProjectionMatrix(viewProjectionMatrix);
    this.pixelsPerMeter = ppm;
    this.pixelsPerDegree = ppd;
    this.pixelsPerDegree2 = pixelsPerDegree2;
  }
};

// node_modules/@antv/l7-core/es/services/debug/DebugService.js
var import_eventemitter35 = __toESM(require_eventemitter3());
var DebugService = class extends import_eventemitter35.EventEmitter {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "renderMap", /* @__PURE__ */ new Map());
    _defineProperty(this, "enable", false);
    _defineProperty(this, "renderEnable", false);
    _defineProperty(this, "cacheLogs", {});
  }
  setEnable(flag) {
    this.enable = !!flag;
  }
  log(key, values) {
    if (!this.enable) {
      return;
    }
    const keys = key.split(".");
    let parent = null;
    keys.forEach((k, i2) => {
      if (parent !== null) {
        if (!parent[k]) {
          parent[k] = {};
        }
        if (i2 !== keys.length - 1) {
          parent = parent[k];
        }
      } else {
        if (!this.cacheLogs[k]) {
          this.cacheLogs[k] = {};
        }
        if (i2 !== keys.length - 1) {
          parent = this.cacheLogs[k];
        }
      }
      if (i2 === keys.length - 1) {
        parent[k] = _objectSpread2(_objectSpread2({
          time: Date.now()
        }, parent[k]), values);
      }
    });
  }
  getLog(key) {
    switch (typeof key) {
      case "string":
        return this.cacheLogs[key];
      case "object":
        return key.map((k) => this.cacheLogs[k]).filter((o) => o !== void 0);
      case "undefined":
        return this.cacheLogs;
    }
  }
  /**
   * 删除日志
   * @param key
   */
  removeLog(key) {
    delete this.cacheLogs[key];
  }
  generateRenderUid() {
    if (this.renderEnable) {
      return guid();
    } else {
      return "";
    }
  }
  renderDebug(enable) {
    this.renderEnable = enable;
  }
  renderStart(id2) {
    if (!this.renderEnable || !this.enable) {
      return;
    }
    const cacheRenderInfo = this.renderMap.get(id2) || {};
    this.renderMap.set(id2, _objectSpread2(_objectSpread2({}, cacheRenderInfo), {}, {
      renderUid: id2,
      renderStart: Date.now()
    }));
  }
  renderEnd(id2) {
    if (!this.renderEnable || !this.enable) {
      return;
    }
    const cacheRenderInfo = this.renderMap.get(id2);
    if (cacheRenderInfo) {
      const renderStart = cacheRenderInfo.renderStart;
      const renderEnd = Date.now();
      this.emit("renderEnd", _objectSpread2(_objectSpread2({}, cacheRenderInfo), {}, {
        renderEnd,
        renderDuration: renderEnd - renderStart
      }));
      this.renderMap.delete(id2);
    }
  }
  destroy() {
    this.cacheLogs = null;
    this.renderMap.clear();
  }
};

// node_modules/@antv/l7-core/es/services/interaction/InteractionService.js
var import_eventemitter36 = __toESM(require_eventemitter3());
var import_hammerjs = __toESM(require_hammer());
var DragEventMap = {
  panstart: "dragstart",
  panmove: "dragging",
  panend: "dragend",
  pancancel: "dragcancel"
};
var InteractionService = class extends import_eventemitter36.default {
  get mapService() {
    return this.container.mapService;
  }
  constructor(container) {
    super();
    _defineProperty(this, "indragging", false);
    _defineProperty(this, "hammertime", void 0);
    _defineProperty(this, "lastClickTime", 0);
    _defineProperty(this, "lastClickXY", [-1, -1]);
    _defineProperty(this, "clickTimer", void 0);
    _defineProperty(this, "$containter", void 0);
    _defineProperty(this, "onDrag", (target) => {
      const interactionTarget = this.interactionEvent(target);
      interactionTarget.type = DragEventMap[interactionTarget.type];
      interactionTarget.type === "dragging" ? this.indragging = true : this.indragging = false;
      this.emit(InteractionEvent.Drag, interactionTarget);
    });
    _defineProperty(this, "onHammer", (target) => {
      target.srcEvent.stopPropagation();
      const interactionTarget = this.interactionEvent(target);
      this.emit(InteractionEvent.Hover, interactionTarget);
    });
    _defineProperty(this, "onTouch", (target) => {
      const touch = target.touches[0];
      this.onHover({
        clientX: touch.clientX,
        clientY: touch.clientY,
        type: "touchstart"
      });
    });
    _defineProperty(this, "onTouchEnd", (target) => {
      if (target.changedTouches.length > 0) {
        const touch = target.changedTouches[0];
        this.onHover({
          clientX: touch.clientX,
          clientY: touch.clientY,
          type: "touchend"
        });
      }
    });
    _defineProperty(this, "onTouchMove", (target) => {
      const touch = target.changedTouches[0];
      this.onHover({
        clientX: touch.clientX,
        clientY: touch.clientY,
        type: "touchmove"
      });
    });
    _defineProperty(this, "onHover", (event) => {
      const {
        clientX,
        clientY
      } = event;
      let x2 = clientX;
      let y = clientY;
      const type = event.type;
      const $containter = this.mapService.getMapContainer();
      if ($containter) {
        const {
          top,
          left
        } = $containter.getBoundingClientRect();
        x2 = x2 - left - $containter.clientLeft;
        y = y - top - $containter.clientTop;
      }
      const lngLat = this.mapService.containerToLngLat([x2, y]);
      if (type === "click") {
        this.isDoubleTap(x2, y, lngLat);
        return;
      }
      if (type === "touch") {
        this.isDoubleTap(x2, y, lngLat);
        return;
      }
      if (type !== "click" && type !== "dblclick") {
        this.emit(InteractionEvent.Hover, {
          x: x2,
          y,
          lngLat,
          type,
          target: event
        });
      }
    });
    this.container = container;
  }
  init() {
    this.addEventListenerOnMap();
    this.$containter = this.mapService.getMapContainer();
  }
  destroy() {
    if (this.hammertime) {
      this.hammertime.destroy();
    }
    this.removeEventListenerOnMap();
    this.off(InteractionEvent.Hover);
  }
  triggerHover({
    x: x2,
    y
  }) {
    this.emit(InteractionEvent.Hover, {
      x: x2,
      y
    });
  }
  triggerSelect(id2) {
    this.emit(InteractionEvent.Select, {
      featureId: id2
    });
  }
  triggerActive(id2) {
    this.emit(InteractionEvent.Active, {
      featureId: id2
    });
  }
  addEventListenerOnMap() {
    const $containter = this.mapService.getMapContainer();
    if ($containter) {
      const hammertime = new import_hammerjs.default.Manager($containter);
      hammertime.add(new import_hammerjs.default.Tap({
        event: "dblclick",
        taps: 2
      }));
      hammertime.add(new import_hammerjs.default.Tap({
        event: "click"
      }));
      hammertime.add(new import_hammerjs.default.Pan({
        threshold: 0,
        pointers: 0
      }));
      hammertime.add(new import_hammerjs.default.Press({}));
      hammertime.on("dblclick click", this.onHammer);
      hammertime.on("panstart panmove panend pancancel", this.onDrag);
      $containter.addEventListener("touchstart", this.onTouch);
      $containter.addEventListener("touchend", this.onTouchEnd);
      $containter.addEventListener("mousemove", this.onHover);
      $containter.addEventListener("touchmove", this.onTouchMove);
      $containter.addEventListener("mousedown", this.onHover, true);
      $containter.addEventListener("mouseup", this.onHover);
      $containter.addEventListener("contextmenu", this.onHover);
      this.hammertime = hammertime;
    }
  }
  removeEventListenerOnMap() {
    const $containter = this.mapService.getMapContainer();
    if ($containter) {
      $containter.removeEventListener("mousemove", this.onHover);
      this.hammertime.off("dblclick click", this.onHammer);
      this.hammertime.off("panstart panmove panend pancancel", this.onDrag);
      $containter.removeEventListener("touchstart", this.onTouch);
      $containter.removeEventListener("touchend", this.onTouchEnd);
      $containter.removeEventListener("mousedown", this.onHover);
      $containter.removeEventListener("mouseup", this.onHover);
      $containter.removeEventListener("contextmenu", this.onHover);
    }
  }
  interactionEvent(target) {
    const {
      type,
      pointerType
    } = target;
    let clientX;
    let clientY;
    if (pointerType === "touch") {
      clientY = Math.floor(target.pointers[0].clientY);
      clientX = Math.floor(target.pointers[0].clientX);
    } else {
      clientY = Math.floor(target.srcEvent.y);
      clientX = Math.floor(target.srcEvent.x);
    }
    const $containter = this.mapService.getMapContainer();
    if ($containter) {
      const {
        top,
        left
      } = $containter.getBoundingClientRect();
      clientX -= left;
      clientY -= top;
    }
    const lngLat = this.mapService.containerToLngLat([clientX, clientY]);
    return {
      x: clientX,
      y: clientY,
      lngLat,
      type,
      target: target.srcEvent
    };
  }
  isDoubleTap(x2, y, lngLat) {
    const nowTime = (/* @__PURE__ */ new Date()).getTime();
    let type = "click";
    if (nowTime - this.lastClickTime < 400 && Math.abs(this.lastClickXY[0] - x2) < 10 && Math.abs(this.lastClickXY[1] - y) < 10) {
      this.lastClickTime = 0;
      this.lastClickXY = [-1, -1];
      if (this.clickTimer) {
        clearTimeout(this.clickTimer);
      }
      type = "dblclick";
      this.emit(InteractionEvent.Hover, {
        x: x2,
        y,
        lngLat,
        type
      });
    } else {
      this.lastClickTime = nowTime;
      this.lastClickXY = [x2, y];
      this.clickTimer = setTimeout(() => {
        type = "click";
        this.emit(InteractionEvent.Hover, {
          x: x2,
          y,
          lngLat,
          type
        });
      }, 400);
    }
  }
};

// node_modules/@antv/l7-core/es/utils/dom.js
var containerCounter = 0;
function createRendererContainer(domId) {
  let $wrapper = domId;
  if (typeof domId === "string") {
    $wrapper = document.getElementById(domId);
  }
  if ($wrapper) {
    const $container = document.createElement("div");
    $container.style.cssText += `
      position: absolute;
      z-index:2;
      height: 100%;
      width: 100%;
      pointer-events: none;
    `;
    $container.id = `l7-scene-${containerCounter++}`;
    $container.classList.add("l7-scene");
    $wrapper.appendChild($container);
    return $container;
  }
  return null;
}
function isEventCrash(layerEvent) {
  var _layerEvent$target;
  let notCrash = true;
  if ((layerEvent === null || layerEvent === void 0 || (_layerEvent$target = layerEvent.target) === null || _layerEvent$target === void 0 ? void 0 : _layerEvent$target.target) instanceof HTMLElement) {
    var _layerEvent$target2;
    let currentElement = layerEvent === null || layerEvent === void 0 || (_layerEvent$target2 = layerEvent.target) === null || _layerEvent$target2 === void 0 ? void 0 : _layerEvent$target2.target;
    while (currentElement) {
      var _currentElement;
      const classList = Array.from(currentElement.classList);
      if (classList.includes("l7-marker") || classList.includes("l7-popup")) {
        notCrash = false;
        break;
      }
      currentElement = (_currentElement = currentElement) === null || _currentElement === void 0 ? void 0 : _currentElement.parentElement;
    }
  }
  return notCrash;
}

// node_modules/@antv/l7-core/es/services/renderer/ITexture2D.js
var TextureUsage = function(TextureUsage2) {
  TextureUsage2[TextureUsage2["SAMPLED"] = 0] = "SAMPLED";
  TextureUsage2[TextureUsage2["RENDER_TARGET"] = 1] = "RENDER_TARGET";
  return TextureUsage2;
}({});

// node_modules/@antv/l7-core/es/services/interaction/PickingService.js
var PickingService = class {
  constructor(container) {
    var _this = this;
    _defineProperty(this, "pickedColors", void 0);
    _defineProperty(this, "pickedTileLayers", []);
    _defineProperty(this, "pickingFBO", void 0);
    _defineProperty(this, "width", 0);
    _defineProperty(this, "height", 0);
    _defineProperty(this, "alreadyInPicking", false);
    _defineProperty(this, "pickBufferScale", 1);
    _defineProperty(this, "pickFromPickingFBO", function() {
      var _ref = _asyncToGenerator(function* (layer, {
        x: x2,
        y,
        lngLat,
        type,
        target
      }) {
        var _pickedColors;
        let isPicked = false;
        const {
          readPixels,
          readPixelsAsync,
          getViewportSize,
          queryVerdorInfo
        } = _this.rendererService;
        const {
          width,
          height
        } = getViewportSize();
        const {
          enableHighlight,
          enableSelect
        } = layer.getLayerConfig();
        const xInDevicePixel = x2 * dom_exports.DPR;
        const yInDevicePixel = y * dom_exports.DPR;
        if (xInDevicePixel > width - 1 * dom_exports.DPR || xInDevicePixel < 0 || yInDevicePixel > height - 1 * dom_exports.DPR || yInDevicePixel < 0) {
          return false;
        }
        let pickedColors;
        const isWebGPU = queryVerdorInfo() === "WebGPU";
        if (isWebGPU) {
          pickedColors = yield readPixelsAsync({
            x: Math.floor(xInDevicePixel / _this.pickBufferScale),
            // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
            y: Math.floor((height - (y + 1) * dom_exports.DPR) / _this.pickBufferScale),
            width: 1,
            height: 1,
            data: new Uint8Array(1 * 1 * 4),
            framebuffer: _this.pickingFBO
          });
        } else {
          pickedColors = readPixels({
            x: Math.floor(xInDevicePixel / _this.pickBufferScale),
            // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
            y: Math.floor((height - (y + 1) * dom_exports.DPR) / _this.pickBufferScale),
            width: 1,
            height: 1,
            data: new Uint8Array(1 * 1 * 4),
            framebuffer: _this.pickingFBO
          });
        }
        _this.pickedColors = pickedColors;
        if (pickedColors[0] !== 0 || pickedColors[1] !== 0 || pickedColors[2] !== 0) {
          const pickedFeatureIdx = decodePickingColor(pickedColors);
          const rawFeature = layer.layerPickService.getFeatureById(pickedFeatureIdx);
          if (pickedFeatureIdx !== layer.getCurrentPickId() && type === "mousemove") {
            type = "mouseenter";
          }
          const layerTarget = {
            x: x2,
            y,
            type,
            lngLat,
            featureId: pickedFeatureIdx,
            feature: rawFeature,
            target
          };
          if (!rawFeature) {
          } else {
            isPicked = true;
            layer.setCurrentPickId(pickedFeatureIdx);
            _this.triggerHoverOnLayer(layer, layerTarget);
          }
        } else {
          const layerTarget = {
            x: x2,
            y,
            lngLat,
            type: layer.getCurrentPickId() !== null && type === "mousemove" ? "mouseout" : "un" + type,
            featureId: null,
            target,
            feature: null
          };
          _this.triggerHoverOnLayer(layer, _objectSpread2(_objectSpread2({}, layerTarget), {}, {
            type: "unpick"
          }));
          _this.triggerHoverOnLayer(layer, layerTarget);
          layer.setCurrentPickId(null);
        }
        if (enableHighlight) {
          layer.layerPickService.highlightPickedFeature(pickedColors);
        }
        if (enableSelect && type === "click" && ((_pickedColors = pickedColors) === null || _pickedColors === void 0 ? void 0 : _pickedColors.toString()) !== [0, 0, 0, 0].toString()) {
          const selectedId = decodePickingColor(pickedColors);
          if (layer.getCurrentSelectedId() === null || selectedId !== layer.getCurrentSelectedId()) {
            layer.layerPickService.selectFeature(pickedColors);
            layer.setCurrentSelectedId(selectedId);
          } else {
            layer.layerPickService.selectFeature(new Uint8Array([0, 0, 0, 0]));
            layer.setCurrentSelectedId(null);
          }
        }
        return isPicked;
      });
      return function(_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
    this.container = container;
  }
  get mapService() {
    return this.container.mapService;
  }
  get rendererService() {
    return this.container.rendererService;
  }
  get configService() {
    return this.container.globalConfigService;
  }
  get interactionService() {
    return this.container.interactionService;
  }
  get layerService() {
    return this.container.layerService;
  }
  init(id2) {
    const {
      createTexture2D,
      createFramebuffer,
      getViewportSize
    } = this.rendererService;
    let {
      width,
      height
    } = getViewportSize();
    this.pickBufferScale = this.configService.getSceneConfig(id2).pickBufferScale || 1;
    width = Math.round(width / this.pickBufferScale);
    height = Math.round(height / this.pickBufferScale);
    const pickingColorTexture = createTexture2D({
      width,
      height,
      // wrapS: gl.CLAMP_TO_EDGE,
      // wrapT: gl.CLAMP_TO_EDGE,
      usage: TextureUsage.RENDER_TARGET,
      label: "Picking Texture"
    });
    this.pickingFBO = createFramebuffer({
      color: pickingColorTexture,
      depth: true,
      width,
      height
    });
    this.interactionService.on(InteractionEvent.Hover, this.pickingAllLayer.bind(this));
  }
  boxPickLayer(layer, box, cb) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const {
        useFramebufferAsync,
        clear
      } = _this2.rendererService;
      _this2.resizePickingFBO();
      layer.hooks.beforePickingEncode.call();
      yield useFramebufferAsync(_this2.pickingFBO, _asyncToGenerator(function* () {
        clear({
          framebuffer: _this2.pickingFBO,
          color: [0, 0, 0, 0],
          stencil: 0,
          depth: 1
        });
        layer.renderModels({
          ispick: true
        });
      }));
      layer.hooks.afterPickingEncode.call();
      const features = yield _this2.pickBox(layer, box);
      cb(features);
    })();
  }
  pickBox(layer, box) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      const [xMin, yMin, xMax, yMax] = box.map((v) => {
        const tmpV = v < 0 ? 0 : v;
        return Math.floor(tmpV * dom_exports.DPR / _this3.pickBufferScale);
      });
      const {
        readPixelsAsync,
        getViewportSize
      } = _this3.rendererService;
      const {
        width,
        height
      } = getViewportSize();
      if (xMin > (width - 1) * dom_exports.DPR / _this3.pickBufferScale || xMax < 0 || yMin > (height - 1) * dom_exports.DPR / _this3.pickBufferScale || yMax < 0) {
        return [];
      }
      const w = Math.min(width / _this3.pickBufferScale, xMax) - xMin;
      const h = Math.min(height / _this3.pickBufferScale, yMax) - yMin;
      const pickedColors = yield readPixelsAsync({
        x: xMin,
        // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
        y: Math.floor(height / _this3.pickBufferScale - (yMax + 1)),
        width: w,
        height: h,
        data: new Uint8Array(w * h * 4),
        framebuffer: _this3.pickingFBO
      });
      const features = [];
      const featuresIdMap = {};
      for (let i2 = 0; i2 < pickedColors.length / 4; i2 = i2 + 1) {
        const color2 = pickedColors.slice(i2 * 4, i2 * 4 + 4);
        const pickedFeatureIdx = decodePickingColor(color2);
        if (pickedFeatureIdx !== -1 && !featuresIdMap[pickedFeatureIdx]) {
          const rawFeature = layer.layerPickService.getFeatureById(pickedFeatureIdx);
          features.push(_objectSpread2(_objectSpread2({}, rawFeature), {}, {
            pickedFeatureIdx
          }));
          featuresIdMap[pickedFeatureIdx] = true;
        }
      }
      return features;
    })();
  }
  // 动态设置鼠标光标
  handleCursor(layer, type) {
    const {
      cursor = "",
      cursorEnabled
    } = layer.getLayerConfig();
    if (cursorEnabled) {
      const mapType = this.mapService.getType();
      const domContainer = mapType === "amap" ? this.mapService.getMapContainer() : this.mapService.getMarkerContainer();
      const defaultCursor = domContainer === null || domContainer === void 0 ? void 0 : domContainer.style.getPropertyValue("cursor");
      if (type === "unmousemove" && defaultCursor !== "") {
        domContainer === null || domContainer === void 0 || domContainer.style.setProperty("cursor", "");
      } else if (type === "mousemove") {
        domContainer === null || domContainer === void 0 || domContainer.style.setProperty("cursor", cursor);
      }
    }
  }
  destroy() {
    this.pickingFBO.destroy();
    this.pickingFBO = null;
  }
  pickingAllLayer(target) {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      if (!_this4.layerService.needPick(target.type) || !_this4.isPickingAllLayer()) {
        return;
      }
      _this4.alreadyInPicking = true;
      yield _this4.pickingLayers(target);
      _this4.layerService.renderLayers();
      _this4.alreadyInPicking = false;
    })();
  }
  isPickingAllLayer() {
    if (this.alreadyInPicking) {
      return false;
    }
    if (this.layerService.alreadyInRendering) {
      return false;
    }
    if (this.interactionService.indragging) {
      return false;
    }
    if (!this.layerService.getShaderPickStat()) {
      return false;
    }
    return true;
  }
  resizePickingFBO() {
    const {
      getViewportSize
    } = this.rendererService;
    const {
      width,
      height
    } = getViewportSize();
    if (this.width !== width || this.height !== height) {
      this.pickingFBO.resize({
        width: Math.round(width / this.pickBufferScale),
        height: Math.round(height / this.pickBufferScale)
      });
      this.width = width;
      this.height = height;
    }
  }
  pickingLayers(target) {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      const {
        clear,
        useFramebufferAsync
      } = _this5.rendererService;
      _this5.resizePickingFBO();
      const layers = _this5.layerService.getRenderList();
      for (const layer of layers.filter((layer2) => layer2.needPick(target.type)).reverse()) {
        yield useFramebufferAsync(_this5.pickingFBO, _asyncToGenerator(function* () {
          clear({
            framebuffer: _this5.pickingFBO,
            color: [0, 0, 0, 0],
            stencil: 0,
            depth: 1
          });
          layer.layerPickService.pickRender(target);
        }));
        const isPicked = yield _this5.pickFromPickingFBO(layer, target);
        _this5.layerService.pickedLayerId = isPicked ? +layer.id : -1;
        if (isPicked && !layer.getLayerConfig().enablePropagation) {
          break;
        }
      }
    })();
  }
  triggerHoverOnLayer(layer, target) {
    if (isEventCrash(target)) {
      this.handleCursor(layer, target.type);
      layer.emit(target.type, target);
    }
  }
};

// node_modules/@antv/l7-core/es/services/layer/LayerService.js
var import_eventemitter37 = __toESM(require_eventemitter3());

// node_modules/@antv/l7-core/es/utils/clock.js
var Clock = class {
  constructor(autoStart = true) {
    _defineProperty(this, "autoStart", void 0);
    _defineProperty(this, "startTime", 0);
    _defineProperty(this, "oldTime", 0);
    _defineProperty(this, "running", false);
    _defineProperty(this, "elapsedTime", 0);
    this.autoStart = autoStart;
  }
  start() {
    this.startTime = (typeof performance === "undefined" ? Date : performance).now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = (typeof performance === "undefined" ? Date : performance).now();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
};

// node_modules/@antv/l7-core/es/services/layer/LayerService.js
var {
  throttle: throttle3
} = lodashUtil;
var LayerService = class extends import_eventemitter37.EventEmitter {
  get renderService() {
    return this.container.rendererService;
  }
  get mapService() {
    return this.container.mapService;
  }
  get debugService() {
    return this.container.debugService;
  }
  constructor(container) {
    super();
    _defineProperty(this, "pickedLayerId", -1);
    _defineProperty(this, "clock", new Clock());
    _defineProperty(this, "alreadyInRendering", false);
    _defineProperty(this, "layers", []);
    _defineProperty(this, "layerList", []);
    _defineProperty(this, "layerRenderID", void 0);
    _defineProperty(this, "sceneInited", false);
    _defineProperty(this, "animateInstanceCount", 0);
    _defineProperty(this, "shaderPicking", true);
    _defineProperty(this, "enableRender", true);
    _defineProperty(this, "reRender", throttle3(() => {
      this.renderLayers();
    }, 32));
    _defineProperty(this, "throttleRenderLayers", throttle3(() => {
      this.renderLayers();
    }, 16));
    this.container = container;
  }
  needPick(type) {
    this.updateLayerRenderList();
    return this.layerList.some((layer) => layer.needPick(type));
  }
  add(layer) {
    this.layers.push(layer);
    if (this.sceneInited) {
      layer.init().then(() => {
        this.renderLayers();
      });
    }
  }
  addMask(mask) {
    if (this.sceneInited) {
      mask.init().then(() => {
        this.renderLayers();
      });
    }
  }
  initLayers() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.sceneInited = true;
      _this.layers.forEach(function() {
        var _ref = _asyncToGenerator(function* (layer) {
          if (!layer.startInit) {
            yield layer.init();
            _this.updateLayerRenderList();
          }
        });
        return function(_x) {
          return _ref.apply(this, arguments);
        };
      }());
    })();
  }
  getSceneInited() {
    return this.sceneInited;
  }
  getRenderList() {
    return this.layerList;
  }
  getLayers() {
    return this.layers;
  }
  getLayer(id2) {
    return this.layers.find((layer) => layer.id === id2);
  }
  getLayerByName(name) {
    return this.layers.find((layer) => layer.name === name);
  }
  remove(layer, parentLayer) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      if (parentLayer) {
        parentLayer.layerChildren = parentLayer.layerChildren.filter((item) => item !== layer);
      } else {
        _this2.layers = _this2.layers.filter((item) => item !== layer);
      }
      layer.destroy();
      _this2.reRender();
      _this2.emit("layerChange", _this2.layers);
    })();
  }
  removeAllLayers() {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      _this3.destroy();
      _this3.reRender();
    })();
  }
  setEnableRender(flag) {
    this.enableRender = flag;
  }
  renderLayers() {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      if (_this4.alreadyInRendering || !_this4.enableRender) {
        return;
      }
      _this4.updateLayerRenderList();
      const renderUid = _this4.debugService.generateRenderUid();
      _this4.debugService.renderStart(renderUid);
      _this4.alreadyInRendering = true;
      _this4.clear();
      for (const layer of _this4.layerList) {
        layer.prerender();
      }
      _this4.renderService.beginFrame();
      for (const layer of _this4.layerList) {
        const {
          enableMask
        } = layer.getLayerConfig();
        if (layer.masks.filter((m) => m.inited).length > 0 && enableMask) {
          _this4.renderMask(layer.masks);
        }
        if (layer.getLayerConfig().enableMultiPassRenderer) {
          yield layer.renderMultiPass();
        } else {
          layer.render();
        }
      }
      _this4.renderService.endFrame();
      _this4.debugService.renderEnd(renderUid);
      _this4.alreadyInRendering = false;
    })();
  }
  renderMask(masks) {
    let maskIndex = 0;
    this.renderService.clear({
      stencil: 0,
      depth: 1,
      framebuffer: null
    });
    const stencilType = masks.length > 1 ? StencilType.MULTIPLE : StencilType.SINGLE;
    for (const layer of masks) {
      layer.render({
        isStencil: true,
        stencilType,
        stencilIndex: maskIndex++
      });
    }
  }
  beforeRenderData(layer) {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      const flag = yield layer.hooks.beforeRenderData.promise();
      if (flag) {
        _this5.renderLayers();
      }
    })();
  }
  renderTileLayerMask(layer) {
    let maskindex = 0;
    const {
      enableMask = true
    } = layer.getLayerConfig();
    let maskCount = layer.tileMask ? 1 : 0;
    const masklayers = layer.masks.filter((m) => m.inited);
    maskCount = maskCount + (enableMask ? masklayers.length : 1);
    const stencilType = maskCount > 1 ? StencilType.MULTIPLE : StencilType.SINGLE;
    if (layer.tileMask || masklayers.length && enableMask) {
      this.renderService.clear({
        stencil: 0,
        depth: 1,
        framebuffer: null
      });
    }
    if (masklayers.length && enableMask) {
      for (const mask of masklayers) {
        mask.render({
          isStencil: true,
          stencilType,
          stencilIndex: maskindex++
        });
      }
    }
    if (layer.tileMask) {
      layer.tileMask.render({
        isStencil: true,
        stencilType,
        stencilIndex: maskindex++,
        stencilOperation: MaskOperation.OR
      });
    }
  }
  // 瓦片图层渲染
  renderTileLayer(layer) {
    var _this6 = this;
    return _asyncToGenerator(function* () {
      _this6.renderTileLayerMask(layer);
      if (layer.getLayerConfig().enableMultiPassRenderer) {
        yield layer.renderMultiPass();
      } else {
        yield layer.render();
      }
    })();
  }
  updateLayerRenderList() {
    this.layerList = [];
    this.layers.filter((layer) => layer.inited).filter((layer) => layer.isVisible()).sort((pre, next) => {
      return pre.zIndex - next.zIndex;
    }).forEach((layer) => {
      this.layerList.push(layer);
    });
  }
  destroy() {
    this.layers.forEach((layer) => {
      layer.destroy();
    });
    this.layers = [];
    this.layerList = [];
    this.emit("layerChange", this.layers);
  }
  startAnimate() {
    if (this.animateInstanceCount++ === 0) {
      this.clock.start();
      this.runRender();
    }
  }
  stopAnimate() {
    if (--this.animateInstanceCount === 0) {
      this.stopRender();
      this.clock.stop();
    }
  }
  getOESTextureFloat() {
    return this.renderService.extensionObject.OES_texture_float;
  }
  // 控制着色器颜色拾取计算
  enableShaderPick() {
    this.shaderPicking = true;
  }
  disableShaderPick() {
    this.shaderPicking = false;
  }
  getShaderPickStat() {
    return this.shaderPicking;
  }
  clear() {
    const color2 = rgb2arr(this.mapService.bgColor);
    this.renderService.clear({
      color: color2,
      depth: 1,
      stencil: 0,
      framebuffer: null
    });
  }
  runRender() {
    this.renderLayers();
    this.layerRenderID = window.requestAnimationFrame(this.runRender.bind(this));
  }
  stopRender() {
    window.cancelAnimationFrame(this.layerRenderID);
  }
};

// node_modules/@antv/l7-core/es/services/layer/StyleAttribute.js
var {
  isNil: isNil3
} = lodashUtil;
var StyleAttribute = class {
  constructor(options) {
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "scale", void 0);
    _defineProperty(this, "descriptor", void 0);
    _defineProperty(this, "featureBufferLayout", []);
    _defineProperty(this, "needRescale", false);
    _defineProperty(this, "needRemapping", false);
    _defineProperty(this, "needRegenerateVertices", false);
    _defineProperty(this, "featureRange", {
      startIndex: 0,
      endIndex: Infinity
    });
    _defineProperty(this, "vertexAttribute", void 0);
    _defineProperty(this, "defaultCallback", (params) => {
      if (params.length === 0) {
        var _this$scale;
        return ((_this$scale = this.scale) === null || _this$scale === void 0 ? void 0 : _this$scale.defaultValues) || [];
      }
      return params.map((param, idx) => {
        var _this$scale2;
        const scaleFunc = (_this$scale2 = this.scale) === null || _this$scale2 === void 0 ? void 0 : _this$scale2.scalers[idx].func;
        const value = scaleFunc(param);
        return value;
      });
    });
    this.setProps(options);
  }
  setProps(options) {
    Object.assign(this, options);
  }
  mapping(params) {
    var _this$scale3;
    if ((_this$scale3 = this.scale) !== null && _this$scale3 !== void 0 && _this$scale3.callback) {
      var _this$scale4;
      const ret = (_this$scale4 = this.scale) === null || _this$scale4 === void 0 ? void 0 : _this$scale4.callback(...params);
      if (!isNil3(ret)) {
        return [ret];
      }
    }
    return this.defaultCallback(params);
  }
  resetDescriptor() {
    if (this.descriptor) {
      this.descriptor.buffer.data = [];
    }
  }
};

// node_modules/@antv/l7-core/es/services/layer/StyleAttributeService.js
var _excluded = ["buffer", "update", "name"];
var _excluded2 = ["buffer", "update", "name"];
var bytesPerElementMap = {
  [gl.FLOAT]: 4,
  [gl.UNSIGNED_BYTE]: 1,
  [gl.UNSIGNED_SHORT]: 2
};
var StyleAttributeService = class {
  constructor(rendererService) {
    _defineProperty(this, "attributesAndIndices", void 0);
    _defineProperty(this, "attributes", []);
    _defineProperty(this, "triangulation", void 0);
    _defineProperty(this, "featureLayout", {
      sizePerElement: 0,
      elements: []
    });
    this.rendererService = rendererService;
  }
  registerStyleAttribute(options) {
    let attributeToUpdate = this.getLayerStyleAttribute(options.name || "");
    if (attributeToUpdate) {
      attributeToUpdate.setProps(options);
    } else {
      attributeToUpdate = new StyleAttribute(options);
      this.attributes.push(attributeToUpdate);
    }
    return attributeToUpdate;
  }
  unRegisterStyleAttribute(name) {
    const attributeIndex = this.attributes.findIndex((attribute) => attribute.name === name);
    if (attributeIndex > -1) {
      this.attributes.splice(attributeIndex, 1);
    }
  }
  updateScaleAttribute(scaleOption) {
    this.attributes.forEach((attr) => {
      var _attr$scale;
      const name = attr.name;
      const field = (_attr$scale = attr.scale) === null || _attr$scale === void 0 ? void 0 : _attr$scale.field;
      if (scaleOption[name] || field && scaleOption[field]) {
        attr.needRescale = true;
        attr.needRemapping = true;
        attr.needRegenerateVertices = true;
      }
    });
  }
  updateStyleAttribute(attributeName, options, updateOptions) {
    let attributeToUpdate = this.getLayerStyleAttribute(attributeName);
    if (!attributeToUpdate) {
      attributeToUpdate = this.registerStyleAttribute(_objectSpread2(_objectSpread2({}, options), {}, {
        name: attributeName
      }));
    }
    const {
      scale: scale6
    } = options;
    if (scale6 && attributeToUpdate) {
      attributeToUpdate.scale = scale6;
      attributeToUpdate.needRescale = true;
      attributeToUpdate.needRemapping = true;
      attributeToUpdate.needRegenerateVertices = true;
      if (updateOptions && updateOptions.featureRange) {
        attributeToUpdate.featureRange = updateOptions.featureRange;
      }
    }
  }
  getLayerStyleAttributes() {
    return this.attributes;
  }
  getLayerStyleAttribute(attributeName) {
    return this.attributes.find((attribute) => attribute.name === attributeName);
  }
  getLayerAttributeScale(name) {
    var _attribute$scale;
    const attribute = this.getLayerStyleAttribute(name);
    const scale6 = attribute === null || attribute === void 0 || (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.scalers;
    if (scale6 && scale6[0]) {
      return scale6[0].func;
    }
    return null;
  }
  updateAttributeByFeatureRange(attributeName, features, startFeatureIdx = 0, endFeatureIdx, layer) {
    const attributeToUpdate = this.attributes.find((attribute) => attribute.name === attributeName);
    if (attributeToUpdate && attributeToUpdate.descriptor) {
      const {
        descriptor
      } = attributeToUpdate;
      const {
        update,
        buffer,
        size = 0
      } = descriptor;
      const bytesPerElement = bytesPerElementMap[buffer.type || gl.FLOAT];
      if (update) {
        const {
          elements,
          sizePerElement
        } = this.featureLayout;
        const featuresToUpdate = elements.slice(startFeatureIdx, endFeatureIdx);
        if (!featuresToUpdate.length) {
          return;
        }
        const {
          offset
        } = featuresToUpdate[0];
        const bufferOffsetInBytes = offset * size * bytesPerElement;
        const updatedBufferData = featuresToUpdate.map(({
          featureIdx,
          vertices,
          normals
        }, attributeIdx) => {
          const verticesNumForCurrentFeature = vertices.length / sizePerElement;
          const featureData = [];
          for (let vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
            const normal = normals ? (
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              normals.slice(vertexIdx * 3, vertexIdx * 3 + 3)
            ) : [];
            featureData.push(...update(features[featureIdx], featureIdx, vertices.slice(vertexIdx * sizePerElement, vertexIdx * sizePerElement + sizePerElement), attributeIdx, normal));
          }
          return featureData;
        }).flat();
        attributeToUpdate.vertexAttribute.updateBuffer({
          data: updatedBufferData,
          offset: bufferOffsetInBytes
        });
        layer === null || layer === void 0 || layer.emit(`legend:${attributeName}`, layer.getLegend(attributeName));
      }
    }
  }
  createAttributesAndIndices(features, triangulation, styleOption, layer) {
    this.featureLayout = {
      sizePerElement: 0,
      elements: []
    };
    if (triangulation) {
      this.triangulation = triangulation;
    }
    const descriptors = this.attributes.map((attr) => {
      attr.resetDescriptor();
      return attr.descriptor;
    });
    let verticesNum = 0;
    let vecticesCount = 0;
    const indices = [];
    let size = 3;
    features.forEach((feature2, featureIdx) => {
      const {
        indices: indicesForCurrentFeature,
        vertices: verticesForCurrentFeature,
        normals: normalsForCurrentFeature,
        size: vertexSize,
        indexes,
        count
      } = this.triangulation(feature2, styleOption);
      if (typeof count === "number") {
        vecticesCount += count;
      }
      indicesForCurrentFeature.forEach((i2) => {
        indices.push(i2 + verticesNum);
      });
      size = vertexSize;
      const verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;
      this.featureLayout.sizePerElement = size;
      this.featureLayout.elements.push({
        featureIdx,
        vertices: verticesForCurrentFeature,
        normals: normalsForCurrentFeature,
        offset: verticesNum
      });
      verticesNum += verticesNumForCurrentFeature;
      for (let vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
        const normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
        const vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);
        let vertexIndex = 0;
        if (indexes && indexes[vertexIdx] !== void 0) {
          vertexIndex = indexes[vertexIdx];
        }
        descriptors.forEach((descriptor, attributeIdx) => {
          if (descriptor && descriptor.update) {
            descriptor.buffer.data.push(...descriptor.update(
              feature2,
              featureIdx,
              vertice,
              vertexIdx,
              // 当前顶点所在feature索引
              normal,
              vertexIndex
              // 传入顶点索引 vertexIdx
            ));
          }
        });
      }
    });
    const {
      createAttribute,
      createBuffer,
      createElements
    } = this.rendererService;
    const attributes = {};
    descriptors.forEach((descriptor, attributeIdx) => {
      if (descriptor) {
        const {
          buffer,
          update,
          name
        } = descriptor, rest = _objectWithoutProperties(descriptor, _excluded);
        const vertexAttribute = createAttribute(_objectSpread2({
          // IBuffer 参数透传
          buffer: createBuffer(buffer)
        }, rest));
        attributes[descriptor.name || ""] = vertexAttribute;
        this.attributes[attributeIdx].vertexAttribute = vertexAttribute;
      }
    });
    const elements = createElements({
      data: indices,
      type: gl.UNSIGNED_INT,
      count: indices.length
    });
    this.attributesAndIndices = {
      attributes,
      elements,
      count: vecticesCount
    };
    Object.values(this.attributes).filter((attribute) => attribute.scale).forEach((attribute) => {
      const attributeName = attribute.name;
      layer === null || layer === void 0 || layer.emit(`legend:${attributeName}`, layer.getLegend(attributeName));
    });
    return this.attributesAndIndices;
  }
  createAttributes(features, triangulation) {
    this.featureLayout = {
      sizePerElement: 0,
      elements: []
    };
    if (triangulation) {
      this.triangulation = triangulation;
    }
    const descriptors = this.attributes.map((attr) => {
      attr.resetDescriptor();
      return attr.descriptor;
    });
    let verticesNum = 0;
    const indices = [];
    let size = 3;
    features.forEach((feature2, featureIdx) => {
      const {
        indices: indicesForCurrentFeature,
        vertices: verticesForCurrentFeature,
        normals: normalsForCurrentFeature,
        size: vertexSize,
        indexes
      } = this.triangulation(feature2);
      indicesForCurrentFeature.forEach((i2) => {
        indices.push(i2 + verticesNum);
      });
      size = vertexSize;
      const verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;
      this.featureLayout.sizePerElement = size;
      this.featureLayout.elements.push({
        featureIdx,
        vertices: verticesForCurrentFeature,
        normals: normalsForCurrentFeature,
        offset: verticesNum
      });
      verticesNum += verticesNumForCurrentFeature;
      for (let vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
        const normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
        const vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);
        let vertexIndex = 0;
        if (indexes && indexes[vertexIdx] !== void 0) {
          vertexIndex = indexes[vertexIdx];
        }
        descriptors.forEach((descriptor, attributeIdx) => {
          if (descriptor && descriptor.update) {
            descriptor.buffer.data.push(...descriptor.update(
              feature2,
              featureIdx,
              vertice,
              vertexIdx,
              // 当前顶点所在feature索引
              normal,
              vertexIndex
              // 传入顶点索引 vertexIdx
            ));
          }
        });
      }
    });
    const {
      createAttribute,
      createBuffer
    } = this.rendererService;
    const attributes = {};
    descriptors.forEach((descriptor, attributeIdx) => {
      if (descriptor) {
        const {
          buffer,
          update,
          name
        } = descriptor, rest = _objectWithoutProperties(descriptor, _excluded2);
        const vertexAttribute = createAttribute(_objectSpread2({
          // IBuffer 参数透传
          buffer: createBuffer(buffer)
        }, rest));
        attributes[descriptor.name || ""] = vertexAttribute;
        this.attributes[attributeIdx].vertexAttribute = vertexAttribute;
      }
    });
    return {
      attributes
    };
  }
  clearAllAttributes() {
    var _this$attributesAndIn;
    this.attributes.forEach((attribute) => {
      if (attribute.vertexAttribute) {
        attribute.vertexAttribute.destroy();
      }
    });
    (_this$attributesAndIn = this.attributesAndIndices) === null || _this$attributesAndIn === void 0 || _this$attributesAndIn.elements.destroy();
    this.attributes = [];
  }
};

// node_modules/@antv/async-hook/es/index.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) {
      throw t[1];
    }
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) {
      throw new TypeError("Generator is already executing.");
    }
    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) {
          return t;
        }
        if (y = 0, t) {
          op = [op[0] & 2, t.value];
        }
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) {
              _.ops.pop();
            }
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }
    if (op[0] & 5) {
      throw op[1];
    }
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) {
    return o;
  }
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"])) {
        m.call(i2);
      }
    } finally {
      if (e) {
        throw e.error;
      }
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) {
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar) {
          ar = Array.prototype.slice.call(from, 0, i2);
        }
        ar[i2] = from[i2];
      }
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var series$1 = { exports: {} };
var parallel$2 = { exports: {} };
var isArrayLike = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isArrayLike2;
  function isArrayLike2(value) {
    return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
  }
  module.exports = exports["default"];
})(isArrayLike, isArrayLike.exports);
var wrapAsync$1 = {};
var asyncify = { exports: {} };
var initialParams = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(fn) {
    return function() {
      var args = [], len4 = arguments.length;
      while (len4--)
        args[len4] = arguments[len4];
      var callback = args.pop();
      return fn.call(this, args, callback);
    };
  };
  module.exports = exports["default"];
})(initialParams, initialParams.exports);
var setImmediate$1 = {};
Object.defineProperty(setImmediate$1, "__esModule", {
  value: true
});
setImmediate$1.fallback = fallback;
setImmediate$1.wrap = wrap;
var hasQueueMicrotask = setImmediate$1.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
var hasSetImmediate = setImmediate$1.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
var hasNextTick = setImmediate$1.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
function fallback(fn) {
  setTimeout(fn, 0);
}
function wrap(defer) {
  return function(fn) {
    var args = [], len4 = arguments.length - 1;
    while (len4-- > 0)
      args[len4] = arguments[len4 + 1];
    return defer(function() {
      return fn.apply(void 0, args);
    });
  };
}
var _defer;
if (hasQueueMicrotask) {
  _defer = queueMicrotask;
} else if (hasSetImmediate) {
  _defer = setImmediate;
} else if (hasNextTick) {
  _defer = process.nextTick;
} else {
  _defer = fallback;
}
setImmediate$1.default = wrap(_defer);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = asyncify2;
  var _initialParams = initialParams.exports;
  var _initialParams2 = _interopRequireDefault2(_initialParams);
  var _setImmediate = setImmediate$1;
  var _setImmediate2 = _interopRequireDefault2(_setImmediate);
  var _wrapAsync = wrapAsync$1;
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function asyncify2(func) {
    if ((0, _wrapAsync.isAsync)(func)) {
      return function() {
        var args = [], len4 = arguments.length;
        while (len4--)
          args[len4] = arguments[len4];
        var callback = args.pop();
        var promise = func.apply(this, args);
        return handlePromise(promise, callback);
      };
    }
    return (0, _initialParams2.default)(function(args, callback) {
      var result;
      try {
        result = func.apply(this, args);
      } catch (e) {
        return callback(e);
      }
      if (result && typeof result.then === "function") {
        return handlePromise(result, callback);
      } else {
        callback(null, result);
      }
    });
  }
  function handlePromise(promise, callback) {
    return promise.then(function(value) {
      invokeCallback(callback, null, value);
    }, function(err2) {
      invokeCallback(callback, err2 && err2.message ? err2 : new Error(err2));
    });
  }
  function invokeCallback(callback, error, value) {
    try {
      callback(error, value);
    } catch (err2) {
      (0, _setImmediate2.default)(function(e) {
        throw e;
      }, err2);
    }
  }
  module.exports = exports["default"];
})(asyncify, asyncify.exports);
Object.defineProperty(wrapAsync$1, "__esModule", {
  value: true
});
wrapAsync$1.isAsyncIterable = wrapAsync$1.isAsyncGenerator = wrapAsync$1.isAsync = void 0;
var _asyncify = asyncify.exports;
var _asyncify2 = _interopRequireDefault(_asyncify);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function isAsync(fn) {
  return fn[Symbol.toStringTag] === "AsyncFunction";
}
function isAsyncGenerator(fn) {
  return fn[Symbol.toStringTag] === "AsyncGenerator";
}
function isAsyncIterable(obj) {
  return typeof obj[Symbol.asyncIterator] === "function";
}
function wrapAsync(asyncFn) {
  if (typeof asyncFn !== "function") {
    throw new Error("expected a function");
  }
  return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
}
wrapAsync$1.default = wrapAsync;
wrapAsync$1.isAsync = isAsync;
wrapAsync$1.isAsyncGenerator = isAsyncGenerator;
wrapAsync$1.isAsyncIterable = isAsyncIterable;
var awaitify = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = awaitify2;
  function awaitify2(asyncFn, arity) {
    if (arity === void 0)
      arity = asyncFn.length;
    if (!arity) {
      throw new Error("arity is undefined");
    }
    function awaitable() {
      var this$1$1 = this;
      var args = [], len4 = arguments.length;
      while (len4--)
        args[len4] = arguments[len4];
      if (typeof args[arity - 1] === "function") {
        return asyncFn.apply(this, args);
      }
      return new Promise(function(resolve, reject) {
        args[arity - 1] = function(err2) {
          var cbArgs = [], len5 = arguments.length - 1;
          while (len5-- > 0)
            cbArgs[len5] = arguments[len5 + 1];
          if (err2) {
            return reject(err2);
          }
          resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
        };
        asyncFn.apply(this$1$1, args);
      });
    }
    return awaitable;
  }
  module.exports = exports["default"];
})(awaitify, awaitify.exports);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _isArrayLike = isArrayLike.exports;
  var _isArrayLike2 = _interopRequireDefault2(_isArrayLike);
  var _wrapAsync = wrapAsync$1;
  var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
  var _awaitify = awaitify.exports;
  var _awaitify2 = _interopRequireDefault2(_awaitify);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  exports.default = (0, _awaitify2.default)(function(eachfn, tasks, callback) {
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
    eachfn(tasks, function(task, key, taskCb) {
      (0, _wrapAsync2.default)(task)(function(err2) {
        var assign;
        var result = [], len4 = arguments.length - 1;
        while (len4-- > 0)
          result[len4] = arguments[len4 + 1];
        if (result.length < 2) {
          assign = result, result = assign[0];
        }
        results[key] = result;
        taskCb(err2);
      });
    }, function(err2) {
      return callback(err2, results);
    });
  }, 3);
  module.exports = exports["default"];
})(parallel$2, parallel$2.exports);
var eachOfSeries = { exports: {} };
var eachOfLimit$1 = { exports: {} };
var eachOfLimit = { exports: {} };
var once = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = once2;
  function once2(fn) {
    function wrapper() {
      var args = [], len4 = arguments.length;
      while (len4--)
        args[len4] = arguments[len4];
      if (fn === null) {
        return;
      }
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper;
  }
  module.exports = exports["default"];
})(once, once.exports);
var iterator = { exports: {} };
var getIterator = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
  };
  module.exports = exports["default"];
})(getIterator, getIterator.exports);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createIterator;
  var _isArrayLike = isArrayLike.exports;
  var _isArrayLike2 = _interopRequireDefault2(_isArrayLike);
  var _getIterator = getIterator.exports;
  var _getIterator2 = _interopRequireDefault2(_getIterator);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function createArrayIterator(coll) {
    var i2 = -1;
    var len4 = coll.length;
    return function next() {
      return ++i2 < len4 ? { value: coll[i2], key: i2 } : null;
    };
  }
  function createES2015Iterator(iterator2) {
    var i2 = -1;
    return function next() {
      var item = iterator2.next();
      if (item.done) {
        return null;
      }
      i2++;
      return { value: item.value, key: i2 };
    };
  }
  function createObjectIterator(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i2 = -1;
    var len4 = okeys.length;
    return function next() {
      var key = okeys[++i2];
      if (key === "__proto__") {
        return next();
      }
      return i2 < len4 ? { value: obj[key], key } : null;
    };
  }
  function createIterator(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
      return createArrayIterator(coll);
    }
    var iterator2 = (0, _getIterator2.default)(coll);
    return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
  }
  module.exports = exports["default"];
})(iterator, iterator.exports);
var onlyOnce = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = onlyOnce2;
  function onlyOnce2(fn) {
    return function() {
      var args = [], len4 = arguments.length;
      while (len4--)
        args[len4] = arguments[len4];
      if (fn === null) {
        throw new Error("Callback was already called.");
      }
      var callFn = fn;
      fn = null;
      callFn.apply(this, args);
    };
  }
  module.exports = exports["default"];
})(onlyOnce, onlyOnce.exports);
var asyncEachOfLimit = { exports: {} };
var breakLoop = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var breakLoop2 = {};
  exports.default = breakLoop2;
  module.exports = exports["default"];
})(breakLoop, breakLoop.exports);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = asyncEachOfLimit2;
  var _breakLoop = breakLoop.exports;
  var _breakLoop2 = _interopRequireDefault2(_breakLoop);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function asyncEachOfLimit2(generator, limit, iteratee, callback) {
    var done = false;
    var canceled = false;
    var awaiting = false;
    var running = 0;
    var idx = 0;
    function replenish() {
      if (running >= limit || awaiting || done) {
        return;
      }
      awaiting = true;
      generator.next().then(function(ref) {
        var value = ref.value;
        var iterDone = ref.done;
        if (canceled || done) {
          return;
        }
        awaiting = false;
        if (iterDone) {
          done = true;
          if (running <= 0) {
            callback(null);
          }
          return;
        }
        running++;
        iteratee(value, idx, iterateeCallback);
        idx++;
        replenish();
      }).catch(handleError);
    }
    function iterateeCallback(err2, result) {
      running -= 1;
      if (canceled) {
        return;
      }
      if (err2) {
        return handleError(err2);
      }
      if (err2 === false) {
        done = true;
        canceled = true;
        return;
      }
      if (result === _breakLoop2.default || done && running <= 0) {
        done = true;
        return callback(null);
      }
      replenish();
    }
    function handleError(err2) {
      if (canceled) {
        return;
      }
      awaiting = false;
      done = true;
      callback(err2);
    }
    replenish();
  }
  module.exports = exports["default"];
})(asyncEachOfLimit, asyncEachOfLimit.exports);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _once = once.exports;
  var _once2 = _interopRequireDefault2(_once);
  var _iterator = iterator.exports;
  var _iterator2 = _interopRequireDefault2(_iterator);
  var _onlyOnce = onlyOnce.exports;
  var _onlyOnce2 = _interopRequireDefault2(_onlyOnce);
  var _wrapAsync = wrapAsync$1;
  var _asyncEachOfLimit = asyncEachOfLimit.exports;
  var _asyncEachOfLimit2 = _interopRequireDefault2(_asyncEachOfLimit);
  var _breakLoop = breakLoop.exports;
  var _breakLoop2 = _interopRequireDefault2(_breakLoop);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  exports.default = function(limit) {
    return function(obj, iteratee, callback) {
      callback = (0, _once2.default)(callback);
      if (limit <= 0) {
        throw new RangeError("concurrency limit cannot be less than 1");
      }
      if (!obj) {
        return callback(null);
      }
      if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
      }
      if ((0, _wrapAsync.isAsyncIterable)(obj)) {
        return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
      }
      var nextElem = (0, _iterator2.default)(obj);
      var done = false;
      var canceled = false;
      var running = 0;
      var looping = false;
      function iterateeCallback(err2, value) {
        if (canceled) {
          return;
        }
        running -= 1;
        if (err2) {
          done = true;
          callback(err2);
        } else if (err2 === false) {
          done = true;
          canceled = true;
        } else if (value === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        } else if (!looping) {
          replenish();
        }
      }
      function replenish() {
        looping = true;
        while (running < limit && !done) {
          var elem = nextElem();
          if (elem === null) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running += 1;
          iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
        }
        looping = false;
      }
      replenish();
    };
  };
  module.exports = exports["default"];
})(eachOfLimit, eachOfLimit.exports);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit2 = eachOfLimit.exports;
  var _eachOfLimit3 = _interopRequireDefault2(_eachOfLimit2);
  var _wrapAsync = wrapAsync$1;
  var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
  var _awaitify = awaitify.exports;
  var _awaitify2 = _interopRequireDefault2(_awaitify);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function eachOfLimit$12(coll, limit, iteratee, callback) {
    return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
  }
  exports.default = (0, _awaitify2.default)(eachOfLimit$12, 4);
  module.exports = exports["default"];
})(eachOfLimit$1, eachOfLimit$1.exports);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _eachOfLimit = eachOfLimit$1.exports;
  var _eachOfLimit2 = _interopRequireDefault2(_eachOfLimit);
  var _awaitify = awaitify.exports;
  var _awaitify2 = _interopRequireDefault2(_awaitify);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function eachOfSeries2(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
  }
  exports.default = (0, _awaitify2.default)(eachOfSeries2, 3);
  module.exports = exports["default"];
})(eachOfSeries, eachOfSeries.exports);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = series2;
  var _parallel2 = parallel$2.exports;
  var _parallel3 = _interopRequireDefault2(_parallel2);
  var _eachOfSeries = eachOfSeries.exports;
  var _eachOfSeries2 = _interopRequireDefault2(_eachOfSeries);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function series2(tasks, callback) {
    return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
  }
  module.exports = exports["default"];
})(series$1, series$1.exports);
var series = getDefaultExportFromCjs(series$1.exports);
var SyncHook = function() {
  function SyncHook2() {
    this.args = [];
    this.tasks = [];
  }
  SyncHook2.prototype.call = function() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    this.args = args;
    return series(this.tasks);
  };
  SyncHook2.prototype.tap = function(name, cb) {
    var _this = this;
    this.tasks.push(function(callback) {
      cb.apply(void 0, __spreadArray([], __read(_this.args), false));
      callback(null, name);
    });
  };
  return SyncHook2;
}();
var parallel$1 = { exports: {} };
var eachOf = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _isArrayLike = isArrayLike.exports;
  var _isArrayLike2 = _interopRequireDefault2(_isArrayLike);
  var _breakLoop = breakLoop.exports;
  var _breakLoop2 = _interopRequireDefault2(_breakLoop);
  var _eachOfLimit = eachOfLimit$1.exports;
  var _eachOfLimit2 = _interopRequireDefault2(_eachOfLimit);
  var _once = once.exports;
  var _once2 = _interopRequireDefault2(_once);
  var _onlyOnce = onlyOnce.exports;
  var _onlyOnce2 = _interopRequireDefault2(_onlyOnce);
  var _wrapAsync = wrapAsync$1;
  var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
  var _awaitify = awaitify.exports;
  var _awaitify2 = _interopRequireDefault2(_awaitify);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function eachOfArrayLike(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback);
    var index = 0, completed = 0;
    var length5 = coll.length;
    var canceled = false;
    if (length5 === 0) {
      callback(null);
    }
    function iteratorCallback(err2, value) {
      if (err2 === false) {
        canceled = true;
      }
      if (canceled === true) {
        return;
      }
      if (err2) {
        callback(err2);
      } else if (++completed === length5 || value === _breakLoop2.default) {
        callback(null);
      }
    }
    for (; index < length5; index++) {
      iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
    }
  }
  function eachOfGeneric(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
  }
  function eachOf2(coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
  }
  exports.default = (0, _awaitify2.default)(eachOf2, 3);
  module.exports = exports["default"];
})(eachOf, eachOf.exports);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = parallel2;
  var _eachOf = eachOf.exports;
  var _eachOf2 = _interopRequireDefault2(_eachOf);
  var _parallel2 = parallel$2.exports;
  var _parallel3 = _interopRequireDefault2(_parallel2);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function parallel2(tasks, callback) {
    return (0, _parallel3.default)(_eachOf2.default, tasks, callback);
  }
  module.exports = exports["default"];
})(parallel$1, parallel$1.exports);
var parallel = getDefaultExportFromCjs(parallel$1.exports);
var AsyncParallelHook = function() {
  function AsyncParallelHook2() {
    this.tasks = [];
  }
  AsyncParallelHook2.prototype.promise = function() {
    return parallel(this.tasks);
  };
  AsyncParallelHook2.prototype.tapPromise = function(name, cb) {
    var _this = this;
    this.tasks.push(function(callback) {
      return __awaiter(_this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, cb()];
            case 1:
              _a2.sent();
              callback(null, name);
              return [2];
          }
        });
      });
    });
  };
  return AsyncParallelHook2;
}();
var waterfall$1 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _once = once.exports;
  var _once2 = _interopRequireDefault2(_once);
  var _onlyOnce = onlyOnce.exports;
  var _onlyOnce2 = _interopRequireDefault2(_onlyOnce);
  var _wrapAsync = wrapAsync$1;
  var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
  var _awaitify = awaitify.exports;
  var _awaitify2 = _interopRequireDefault2(_awaitify);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function waterfall2(tasks, callback) {
    callback = (0, _once2.default)(callback);
    if (!Array.isArray(tasks)) {
      return callback(new Error("First argument to waterfall must be an array of functions"));
    }
    if (!tasks.length) {
      return callback();
    }
    var taskIndex = 0;
    function nextTask(args) {
      var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
      task.apply(void 0, args.concat([(0, _onlyOnce2.default)(next)]));
    }
    function next(err2) {
      var args = [], len4 = arguments.length - 1;
      while (len4-- > 0)
        args[len4] = arguments[len4 + 1];
      if (err2 === false) {
        return;
      }
      if (err2 || taskIndex === tasks.length) {
        return callback.apply(void 0, [err2].concat(args));
      }
      nextTask(args);
    }
    nextTask([]);
  }
  exports.default = (0, _awaitify2.default)(waterfall2);
  module.exports = exports["default"];
})(waterfall$1, waterfall$1.exports);
var waterfall = getDefaultExportFromCjs(waterfall$1.exports);
var ASyncWaterfallHook = function() {
  function ASyncWaterfallHook2() {
    this.tasks = [];
  }
  ASyncWaterfallHook2.prototype.call = function() {
    return waterfall(this.tasks);
  };
  ASyncWaterfallHook2.prototype.tap = function(name, cb) {
    if (this.tasks.length === 0) {
      this.tasks.push(function(callback) {
        var value = cb();
        callback(value ? null : false, value);
      });
    } else {
      this.tasks.push(function(arg, callback) {
        var value = cb.apply(void 0, __spreadArray([], __read(arg), false));
        callback(value ? null : false, name);
      });
    }
  };
  return ASyncWaterfallHook2;
}();
var SyncBailHook = function() {
  function SyncBailHook2() {
    this.tasks = [];
  }
  SyncBailHook2.prototype.call = function() {
    return series(this.tasks);
  };
  SyncBailHook2.prototype.tap = function(name, cb) {
    this.tasks.push(function(callback) {
      var err2 = cb();
      callback(err2, name);
    });
  };
  return SyncBailHook2;
}();
var AsyncSeriesHook = function() {
  function AsyncSeriesHook2() {
    this.args = [];
    this.tasks = [];
  }
  AsyncSeriesHook2.prototype.promise = function() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    this.args = args;
    return series(this.tasks);
  };
  AsyncSeriesHook2.prototype.tapPromise = function(name, cb) {
    var _this = this;
    this.tasks.push(function(callback) {
      return __awaiter(_this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, cb.apply(void 0, __spreadArray([], __read(this.args), false))];
            case 1:
              _a2.sent();
              callback(null, name);
              return [2];
          }
        });
      });
    });
  };
  return AsyncSeriesHook2;
}();
var AsyncSeriesBailHook = function() {
  function AsyncSeriesBailHook2() {
    this.args = [];
    this.tasks = [];
  }
  AsyncSeriesBailHook2.prototype.promise = function() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    this.args = args;
    return series(this.tasks);
  };
  AsyncSeriesBailHook2.prototype.tapPromise = function(name, cb) {
    var _this = this;
    this.tasks.push(function(callback) {
      return __awaiter(_this, void 0, void 0, function() {
        var err2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, cb.apply(void 0, __spreadArray([], __read(this.args), false))];
            case 1:
              err2 = _a2.sent();
              callback(err2, name);
              return [2];
          }
        });
      });
    });
  };
  return AsyncSeriesBailHook2;
}();
var AsyncWaterfallHook = function() {
  function AsyncWaterfallHook2() {
    this.tasks = [];
  }
  AsyncWaterfallHook2.prototype.promise = function() {
    return waterfall(this.tasks);
  };
  AsyncWaterfallHook2.prototype.tapPromise = function(name, cb) {
    if (this.tasks.length === 0) {
      this.tasks.push(function(callback) {
        cb().then(function(value) {
          callback(null, value);
        });
      });
    } else {
      this.tasks.push(function(arg, callback) {
        cb(arg).then(function(v) {
          callback(null, v);
        });
      });
    }
  };
  return AsyncWaterfallHook2;
}();

// node_modules/@antv/l7-core/es/services/scene/SceneService.js
var import_element_resize_detector = __toESM(require_element_resize_detector());
var import_eventemitter38 = __toESM(require_eventemitter3());
var Scene = class extends import_eventemitter38.EventEmitter {
  /**
   * 使用各种 Service
   */
  get iconService() {
    return this.container.iconService;
  }
  get fontService() {
    return this.container.fontService;
  }
  get controlService() {
    return this.container.controlService;
  }
  get configService() {
    return this.container.globalConfigService;
  }
  get map() {
    return this.container.mapService;
  }
  get coordinateSystemService() {
    return this.container.coordinateSystemService;
  }
  get rendererService() {
    return this.container.rendererService;
  }
  get layerService() {
    return this.container.layerService;
  }
  get debugService() {
    return this.container.debugService;
  }
  get cameraService() {
    return this.container.cameraService;
  }
  get interactionService() {
    return this.container.interactionService;
  }
  get pickingService() {
    return this.container.pickingService;
  }
  get shaderModuleService() {
    return this.container.shaderModuleService;
  }
  get markerService() {
    return this.container.markerService;
  }
  get popupService() {
    return this.container.popupService;
  }
  /**
   * 是否首次渲染
   */
  constructor(container) {
    super();
    _defineProperty(this, "destroyed", false);
    _defineProperty(this, "loaded", false);
    _defineProperty(this, "id", void 0);
    _defineProperty(this, "inited", false);
    _defineProperty(this, "rendering", false);
    _defineProperty(this, "$container", void 0);
    _defineProperty(this, "canvas", void 0);
    _defineProperty(this, "markerContainer", void 0);
    _defineProperty(this, "resizeDetector", void 0);
    _defineProperty(this, "hooks", void 0);
    _defineProperty(this, "handleWindowResized", () => {
      this.emit("resize");
      if (this.$container) {
        this.initContainer();
        this.coordinateSystemService.needRefresh = true;
        this.render();
      }
    });
    _defineProperty(this, "handleMapCameraChanged", (viewport) => {
      this.cameraService.update(viewport);
      this.render();
    });
    this.container = container;
    this.hooks = {
      /**
       * 初始化异步任务，可并行：
       * 1. initMap：初始化地图底图、相机
       * 2. initRenderer：初始化渲染引擎
       * 3. initWorker：初始化 Worker
       */
      init: new AsyncSeriesHook()
    };
    this.id = container.id;
  }
  init(sceneConfig) {
    var _this = this;
    this.configService.setSceneConfig(this.id, sceneConfig);
    this.shaderModuleService.registerBuiltinModules();
    this.iconService.init();
    this.iconService.on("imageUpdate", () => this.render());
    this.fontService.init();
    this.hooks.init.tapPromise("initMap", _asyncToGenerator(function* () {
      _this.debugService.log("map.mapInitStart", {
        type: _this.map.version
      });
      yield new Promise((resolve) => {
        _this.map.onCameraChanged((viewport) => {
          _this.cameraService.init();
          _this.cameraService.update(viewport);
          resolve();
        });
        _this.map.init();
      });
      _this.map.onCameraChanged(_this.handleMapCameraChanged);
      _this.map.addMarkerContainer();
      _this.markerService.addMarkers();
      _this.markerService.addMarkerLayers();
      _this.popupService.initPopup();
      _this.interactionService.init();
      _this.interactionService.on(InteractionEvent.Drag, _this.addSceneEvent.bind(_this));
    }));
    this.hooks.init.tapPromise("initRenderer", _asyncToGenerator(function* () {
      var _this$map;
      const renderContainer = ((_this$map = _this.map) === null || _this$map === void 0 ? void 0 : _this$map.getOverlayContainer()) || void 0;
      if (renderContainer) {
        _this.$container = renderContainer;
      } else {
        _this.$container = createRendererContainer(_this.configService.getSceneConfig(_this.id).id || "");
      }
      if (_this.$container) {
        const {
          canvas
        } = sceneConfig;
        _this.canvas = canvas ? canvas : dom_exports.create("canvas", "", _this.$container);
        _this.setCanvas();
        yield _this.rendererService.init(
          // @ts-ignore
          _this.canvas,
          _this.configService.getSceneConfig(_this.id),
          sceneConfig.gl
        );
        _this.registerContextLost();
        _this.initContainer();
        _this.resizeDetector = (0, import_element_resize_detector.default)({
          strategy: "scroll"
          //<- For ultra performance.
        });
        _this.resizeDetector.listenTo(_this.$container, _this.handleWindowResized);
        if (window.matchMedia) {
          var _window$matchMedia;
          (_window$matchMedia = window.matchMedia("screen and (-webkit-min-device-pixel-ratio: 1.5)")) === null || _window$matchMedia === void 0 || _window$matchMedia.addListener(_this.handleWindowResized.bind("screen"));
        }
      } else {
        console.error("容器 id 不存在");
      }
      _this.pickingService.init(_this.id);
    }));
    this.render();
  }
  registerContextLost() {
    const canvas = this.rendererService.getCanvas();
    if (canvas) {
      canvas.addEventListener("webglcontextlost", () => this.emit("webglcontextlost"));
    }
  }
  addLayer(layer) {
    this.layerService.sceneService = this;
    this.layerService.add(layer);
  }
  addMask(mask) {
    this.layerService.sceneService = this;
    this.layerService.addMask(mask);
  }
  render() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      if (_this2.rendering || _this2.destroyed) {
        return;
      }
      _this2.rendering = true;
      if (!_this2.inited) {
        yield _this2.hooks.init.promise();
        if (_this2.destroyed) {
          _this2.destroy();
        }
        yield _this2.layerService.initLayers();
        _this2.layerService.renderLayers();
        _this2.controlService.addControls();
        _this2.loaded = true;
        _this2.emit("loaded");
        _this2.inited = true;
      } else {
        yield _this2.layerService.initLayers();
        yield _this2.layerService.renderLayers();
      }
      _this2.rendering = false;
    })();
  }
  /**
   * 用户自定义添加第三方字体 （用户使用 layer/point/text/iconfont 的前提需要加载第三方字体文件）
   * @param fontFamily
   * @param fontPath
   */
  addFontFace(fontFamily, fontPath) {
    this.fontService.addFontFace(fontFamily, fontPath);
  }
  getSceneContainer() {
    return this.$container;
  }
  exportPng(type) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      var _this3$$container;
      const renderCanvas = (_this3$$container = _this3.$container) === null || _this3$$container === void 0 ? void 0 : _this3$$container.getElementsByTagName("canvas")[0];
      yield _this3.render();
      const layersPng = type === "jpg" ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/jpeg") : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/png");
      return layersPng;
    })();
  }
  getSceneConfig() {
    return this.configService.getSceneConfig(this.id);
  }
  // get point size info
  getPointSizeRange() {
    return this.rendererService.getPointSizeRange();
  }
  addMarkerContainer() {
    const mapContainer = this.$container.parentElement;
    if (mapContainer !== null) {
      this.markerContainer = dom_exports.create("div", "l7-marker-container", mapContainer);
    }
  }
  getMarkerContainer() {
    return this.markerContainer;
  }
  destroy() {
    var _this$$container2;
    if (!this.inited) {
      this.destroyed = true;
      return;
    }
    this.resizeDetector.removeListener(this.$container, this.handleWindowResized);
    this.pickingService.destroy();
    this.layerService.destroy();
    this.interactionService.destroy();
    this.controlService.destroy();
    this.markerService.destroy();
    this.fontService.destroy();
    this.iconService.destroy();
    this.removeAllListeners();
    this.inited = false;
    this.map.destroy();
    setTimeout(() => {
      var _this$$container;
      (_this$$container = this.$container) === null || _this$$container === void 0 || _this$$container.removeChild(this.canvas);
      this.canvas = null;
      this.rendererService.destroy();
    });
    (_this$$container2 = this.$container) === null || _this$$container2 === void 0 || (_this$$container2 = _this$$container2.parentNode) === null || _this$$container2 === void 0 || _this$$container2.removeChild(this.$container);
    this.emit("destroy");
  }
  initContainer() {
    var _this$$container3, _this$$container4;
    const pixelRatio = dom_exports.DPR;
    const w = ((_this$$container3 = this.$container) === null || _this$$container3 === void 0 ? void 0 : _this$$container3.clientWidth) || 400;
    const h = ((_this$$container4 = this.$container) === null || _this$$container4 === void 0 ? void 0 : _this$$container4.clientHeight) || 300;
    const canvas = this.canvas;
    if (canvas) {
      canvas.width = w * pixelRatio;
      canvas.height = h * pixelRatio;
    }
    this.rendererService.viewport({
      x: 0,
      y: 0,
      width: pixelRatio * w,
      height: pixelRatio * h
    });
  }
  setCanvas() {
    var _this$$container5, _this$$container6;
    const pixelRatio = dom_exports.DPR;
    const w = ((_this$$container5 = this.$container) === null || _this$$container5 === void 0 ? void 0 : _this$$container5.clientWidth) || 400;
    const h = ((_this$$container6 = this.$container) === null || _this$$container6 === void 0 ? void 0 : _this$$container6.clientHeight) || 300;
    const canvas = this.canvas;
    canvas.width = w * pixelRatio;
    canvas.height = h * pixelRatio;
    canvas.style.width = "100%";
    canvas.style.height = "100%";
  }
  addSceneEvent(target) {
    this.emit(target.type, target);
  }
};

// node_modules/@antv/l7-core/es/services/shader/ShaderModuleService.js
var {
  uniq: uniq2
} = lodashUtil;
var common = "#define PI 3.14159265359";
var light = "#define ambientRatio 0.5\n#define diffuseRatio 0.3\n#define specularRatio 0.2\n\n\nfloat calc_lighting(vec4 pos) {\n\n    vec3 worldPos = vec3(pos * u_ModelMatrix);\n\n    vec3 worldNormal = a_Normal;\n      // //cal light weight\n    vec3 viewDir = normalize(u_CameraPosition - worldPos);\n\n    vec3 lightDir = normalize(vec3(1, -10.5, 12));\n\n    vec3 halfDir = normalize(viewDir+lightDir);\n      // //lambert\n    float lambert = dot(worldNormal, lightDir);\n        //specular\n    float specular = pow(max(0.0, dot(worldNormal, halfDir)), 32.0);\n        //sum to light weight\n    float lightWeight = ambientRatio + diffuseRatio * lambert + specularRatio * specular;\n\n    return lightWeight;\n}\n";
var decode = "#define SHIFT_RIGHT17 1.0 / 131072.0\n#define SHIFT_RIGHT18 1.0 / 262144.0\n#define SHIFT_RIGHT19 1.0 / 524288.0\n#define SHIFT_RIGHT20 1.0 / 1048576.0\n#define SHIFT_RIGHT21 1.0 / 2097152.0\n#define SHIFT_RIGHT22 1.0 / 4194304.0\n#define SHIFT_RIGHT23 1.0 / 8388608.0\n#define SHIFT_RIGHT24 1.0 / 16777216.0\n\n#define SHIFT_LEFT17 131072.0\n#define SHIFT_LEFT18 262144.0\n#define SHIFT_LEFT19 524288.0\n#define SHIFT_LEFT20 1048576.0\n#define SHIFT_LEFT21 2097152.0\n#define SHIFT_LEFT22 4194304.0\n#define SHIFT_LEFT23 8388608.0\n#define SHIFT_LEFT24 16777216.0\n\nvec2 unpack_float(float packedValue) {\n  int packedIntValue = int(packedValue);\n  int v0 = packedIntValue / 256;\n  return vec2(v0, packedIntValue - v0 * 256);\n}\n\nvec4 decode_color(vec2 encodedColor) {\n  return vec4(\n    unpack_float(encodedColor[0]) / 255.0,\n    unpack_float(encodedColor[1]) / 255.0\n  );\n}\n";
var lighting = "// Blinn-Phong model\n// apply lighting in vertex shader instead of fragment shader\n// @see https://learnopengl.com/Advanced-Lighting/Advanced-Lighting\nuniform float u_Ambient : 1.0;\nuniform float u_Diffuse : 1.0;\nuniform float u_Specular : 1.0;\nuniform int u_NumOfDirectionalLights : 1;\nuniform int u_NumOfSpotLights : 0;\n\n#define SHININESS 32.0\n#define MAX_NUM_OF_DIRECTIONAL_LIGHTS 3\n#define MAX_NUM_OF_SPOT_LIGHTS 3\n\nstruct DirectionalLight {\n  vec3 direction;\n  vec3 ambient;\n  vec3 diffuse;\n  vec3 specular;\n};\n\nstruct SpotLight {\n  vec3 position;\n  vec3 direction;\n  vec3 ambient;\n  vec3 diffuse;\n  vec3 specular;\n  float constant;\n  float linear;\n  float quadratic;\n  float angle;\n  float blur;\n  float exponent;\n};\n\nuniform DirectionalLight u_DirectionalLights[MAX_NUM_OF_DIRECTIONAL_LIGHTS];\nuniform SpotLight u_SpotLights[MAX_NUM_OF_SPOT_LIGHTS];\n\nvec3 calc_directional_light(DirectionalLight light, vec3 normal, vec3 viewDir) {\n  vec3 lightDir = normalize(light.direction);\n  // diffuse shading\n  float diff = max(dot(normal, lightDir), 0.0);\n  // Blinn-Phong specular shading\n  vec3 halfwayDir = normalize(lightDir + viewDir);\n  float spec = pow(max(dot(normal, halfwayDir), 0.0), SHININESS);\n\n  vec3 ambient = light.ambient * u_Ambient;\n  vec3 diffuse = light.diffuse * diff * u_Diffuse;\n  vec3 specular = light.specular * spec * u_Specular;\n\n  return ambient + diffuse + specular;\n}\n\n\nvec3 calc_lighting(vec3 position, vec3 normal, vec3 viewDir) {\n  vec3 weight = vec3(0.0);\n  for (int i = 0; i < MAX_NUM_OF_DIRECTIONAL_LIGHTS; i++) {\n    if (i >= u_NumOfDirectionalLights) {\n      break;\n    }\n    weight += calc_directional_light(u_DirectionalLights[i], normal, viewDir);\n  }\n  return weight;\n}\n";
var pickingFrag = '\nin vec4 v_PickingResult;\n\n#pragma include "picking_uniforms"\n\n#define PICKING_NONE 0.0\n#define PICKING_ENCODE 1.0\n#define PICKING_HIGHLIGHT 2.0\n#define COLOR_SCALE 1. / 255.\n\n#define HIGHLIGHT 1.0\n#define SELECT 2.0\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 filterHighlightColor(vec4 color, float weight) {\n  float activeType = v_PickingResult.a;\n  if(activeType > 0.0) {\n    vec4 highLightColor =  activeType > 1.5 ? u_SelectColor : u_HighlightColor;\n    highLightColor = highLightColor * COLOR_SCALE;\n    float highLightAlpha = highLightColor.a;\n    float highLightRatio = highLightAlpha / (highLightAlpha + color.a * (1.0 - highLightAlpha));\n    vec3 resultRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\n    return vec4(mix(resultRGB * weight, color.rgb, u_activeMix), color.a);\n  }\n  else {\n    return color;\n  }\n\n  \n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 filterPickingColor(vec4 color) {\n  vec3 pickingColor = v_PickingResult.rgb;\n  if (u_PickingStage == PICKING_ENCODE && length(pickingColor) < 0.001) {\n    discard;\n  }\n  return u_PickingStage == PICKING_ENCODE ? vec4(pickingColor, step(0.001,color.a)): color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 filterColor(vec4 color) {\n  // 过滤多余的 shader 计算\n  // return color;\n  if(u_shaderPick < 0.5) {\n    return color; // 暂时去除 直接取消计算在选中时拖拽地图会有问题\n  } else {\n    return filterPickingColor(filterHighlightColor(color, 1.0));\n  }\n  \n}\n\nvec4 filterColorAlpha(vec4 color, float alpha) {\n  // 过滤多余的 shader 计算\n  // return color;\n  if(u_shaderPick < 0.5) {\n    return color; // 暂时去除 直接取消计算在选中时拖拽地图会有问题\n  } else {\n    return filterPickingColor(filterHighlightColor(color, alpha));\n  }\n}\n\n';
var pickingVert = 'layout(location = ATTRIBUTE_LOCATION_PICKING_COLOR) in vec3 a_PickingColor;\nout vec4 v_PickingResult;\n\n#pragma include "picking_uniforms"\n\n#define PICKING_NONE 0.0\n#define PICKING_ENCODE 1.0\n#define PICKING_HIGHLIGHT 2.0\n#define COLOR_SCALE 1. / 255.\n\n#define NORMAL 0.0\n#define HIGHLIGHT 1.0\n#define SELECT 2.0\n\nbool isVertexPicked(vec3 vertexColor) {\n  return distance(vertexColor,u_PickingColor.rgb) < 0.01;\n}\n\n// 判断当前点是否已经被 select 选中\nbool isVertexSelected(vec3 vertexColor) {\n  return distance(vertexColor,u_CurrentSelectedId.rgb) < 0.01;\n}\n\nvoid setPickingColor(vec3 pickingColor) {\n  if(u_shaderPick < 0.5) {\n    return;\n  }\n  // compares only in highlight stage\n\n  if(u_PickingStage == PICKING_HIGHLIGHT) {\n    if(isVertexPicked(pickingColor)) {\n       v_PickingResult = vec4(pickingColor.rgb * COLOR_SCALE,HIGHLIGHT);\n       return;\n    }\n    if(isVertexSelected(pickingColor)) {\n     v_PickingResult = vec4(u_CurrentSelectedId.rgb * COLOR_SCALE,SELECT);\n      return;\n    }\n\n  } else {\n      v_PickingResult= vec4(pickingColor.rgb * COLOR_SCALE,NORMAL);\n      return;\n  }\n\n  // // v_PickingResult.a = float((u_PickingStage == PICKING_HIGHLIGHT) && (isVertexPicked(pickingColor) || isVertexPicked(u_CurrentSelectedId)));\n\n  // // Stores the picking color so that the fragment shader can render it during picking\n  // v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nfloat setPickingSize(float x) {\n   return u_PickingStage == PICKING_ENCODE ? x + u_PickingBuffer : x;\n}\n\nfloat setPickingOrder(float z) {\n   bool selected = bool(v_PickingResult.a);\n   return selected ? z + 1. : 0.;\n}\n';
var picking_uniforms = "layout(std140) uniform PickingUniforms {\n  vec4 u_HighlightColor;\n  vec4 u_SelectColor;\n  vec3 u_PickingColor;\n  float u_PickingStage;\n  vec3 u_CurrentSelectedId;\n  float u_PickingThreshold;\n  float u_PickingBuffer;\n  float u_shaderPick;\n  float u_activeMix;\n};";
var project2 = "\n#define E 2.718281828459045\nvec2 ProjectFlat(vec2 lnglat){\n  float maxs=85.0511287798;\n  float lat=max(min(maxs,lnglat.y),-maxs);\n  float scale= 268435456.;\n  float d=PI/180.;\n  float x=lnglat.x*d;\n  float y=lat*d;\n  y=log(tan((PI/4.)+(y/2.)));\n\n  float a=.5/PI,\n  b=.5,\n  c=-.5/PI;\n  d=.5;\n  x=scale*(a*x+b);\n  y=scale*(c*y+d);\n  return vec2(x,y);\n}\n\nvec2 unProjectFlat(vec2 px){\n  float a=.5/PI;\n  float b=.5;\n  float c=-.5/PI;\n  float d=.5;\n  float scale = 268435456.;\n  float x=(px.x/scale-b)/a;\n  float y=(px.y/scale-d)/c;\n  y=(atan(pow(E,y))-(PI/4.))*2.;\n  d=PI/180.;\n  float lat=y/d;\n  float lng=x/d;\n  return vec2(lng,lat);\n}\n\nfloat pixelDistance(vec2 from, vec2 to) {\n vec2 a1 = ProjectFlat(from);\n vec2 b1 = ProjectFlat(to);\n return distance(a1, b1);\n}\n\n// gaode2.0\nvec2 customProject(vec2 lnglat) { // 经纬度 => 平面坐标\n  float t = lnglat.x;\n  float e = lnglat.y;\n  float Sm = 180.0 / PI;\n  float Tm = 6378137.0;\n  float Rm = PI / 180.0;\n  float r = 85.0511287798;\n  e = max(min(r, e), -r);\n  t *= Rm;\n  e *= Rm;\n  e = log(tan(PI / 4.0 + e / 2.0));\n  return vec2(t * Tm, e * Tm);\n}\n\nvec2 unProjCustomCoord(vec2 point) { // 平面坐标 => 经纬度\n  float Sm = 57.29577951308232; //180 / Math.PI\n  float Tm = 6378137.0;\n  float t = point.x;\n  float e = point.y;\n  return vec2(t / Tm * Sm, (2.0 * atan(exp(e / Tm)) - PI / 2.0) * Sm);\n}\n\n\nfloat customPixelDistance(vec2 from, vec2 to) {\n vec2 a1 = ProjectFlat(from);\n vec2 b1 = ProjectFlat(to);\n return distance(a1, b1);\n}";
var projection = `#define TILE_SIZE (512.0)
#define PI (3.1415926536)
#define WORLD_SCALE (TILE_SIZE / (PI * 2.0))
#define EARTH_CIRCUMFERENCE (40.03e6)

#define COORDINATE_SYSTEM_LNGLAT (1.0) // mapbox
#define COORDINATE_SYSTEM_LNGLAT_OFFSET (2.0) // mapbox offset
#define COORDINATE_SYSTEM_VECTOR_TILE (3.0)
#define COORDINATE_SYSTEM_IDENTITY (4.0)
#define COORDINATE_SYSTEM_METER_OFFSET (5.0)

#pragma include "scene_uniforms"

const vec2 ZERO_64_XY_LOW = vec2(0.0, 0.0);

// web mercator coords -> world coords
vec2 project_mercator(vec2 lnglat) {
  float x = lnglat.x;
  return vec2(radians(x) + PI, PI - log(tan(PI * 0.25 + radians(lnglat.y) * 0.5)));
}

float project_scale(float meters) {
  return meters * u_PixelsPerMeter.z;
}

// offset coords -> world coords
vec4 project_offset(vec4 offset) {
  float dy = offset.y;
  dy = clamp(dy, -1.0, 1.0);
  vec3 pixels_per_unit = u_PixelsPerDegree + u_PixelsPerDegree2 * dy;
  return vec4(offset.xyz * pixels_per_unit, offset.w);
}

vec3 project_normal(vec3 normal) {
  vec4 normal_modelspace = u_ModelMatrix * vec4(normal, 0.0);
  return normalize(normal_modelspace.xyz * u_PixelsPerMeter);
}

vec3 project_offset_normal(vec3 vector) {
  if (
    u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 &&
      u_CoordinateSystem > COORDINATE_SYSTEM_LNGLAT - 0.01 ||
    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET
  ) {
    // normals generated by the polygon tesselator are in lnglat offsets instead of meters
    return normalize(vector * u_PixelsPerDegree);
  }
  return project_normal(vector);
}

vec4 project_position(vec4 position, vec2 position64xyLow) {
  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {
    float X = position.x - u_ViewportCenter.x;
    float Y = position.y - u_ViewportCenter.y;
    return project_offset(
      vec4(X + position64xyLow.x, Y + position64xyLow.y, position.z, position.w)
    );
  }
  if (
    u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 &&
    u_CoordinateSystem > COORDINATE_SYSTEM_LNGLAT - 0.01
  ) {
    return vec4(
      project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale,
      project_scale(position.z),
      position.w
    );
  }

  return position;
}

vec4 project_position(vec4 position) {
  return project_position(position, ZERO_64_XY_LOW);
}

vec2 project_pixel_size_to_clipspace(vec2 pixels) {
  vec2 offset = pixels / u_ViewportSize * u_DevicePixelRatio * 2.0;
  return offset * u_FocalDistance;
}

// 适配纹理贴图的等像素大小
float project_pixel_texture(float pixel) {
  // mapbox zoom > 12
  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {
    return pixel * pow(0.5, u_Zoom) * u_FocalDistance;
  }

  return pixel * 2.0 * u_FocalDistance;
}

// 在不论什么底图下需要统一处理的时候使用
float project_float_pixel(float pixel) {
  if (
    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET
  ) {
    // mapbox 坐标系下，为了和 Web 墨卡托坐标系统一，zoom 默认减1
    return pixel * pow(2.0, 19.0 - u_Zoom) * u_FocalDistance;
  }

  return pixel * u_FocalDistance;
}

// Project meter into the unit of pixel which used in the camera world space
float project_float_meter(float meter) {
  if (
    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET
  ) {
    // Since the zoom level uniform is updated by mapservice and it's alread been subtracted by 1
    // Not sure if we are supposed to do that again
    return meter;
  } else {
    return project_float_pixel(meter);
  }

  // TODO: change the following code to make adaptations for amap
  // return u_FocalDistance * TILE_SIZE * pow(2.0, u_Zoom) * meter / EARTH_CIRCUMFERENCE;

}

float project_pixel(float pixel) {
  return pixel * u_FocalDistance;
}

vec2 project_pixel(vec2 pixel) {
  return pixel * -1.0 * u_FocalDistance;
}

vec3 project_pixel(vec3 pixel) {
  return pixel * -1.0 * u_FocalDistance;
}

vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
  if (
    u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||
    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET
  ) {
    // Needs to be divided with project_uCommonUnitsPerMeter
    position.w *= u_PixelsPerMeter.z;
  }

  return viewProjectionMatrix * position + center;
}

// Projects from common space coordinates to clip space
vec4 project_common_position_to_clipspace(vec4 position) {
  return project_common_position_to_clipspace(
    position,
    u_ViewProjectionMatrix,
    u_ViewportCenterProjection
  );
}

vec4 unproject_clipspace_to_position(vec4 clipspacePos, mat4 u_InverseViewProjectionMatrix) {
  vec4 pos = u_InverseViewProjectionMatrix * (clipspacePos - u_ViewportCenterProjection);

  if (
    u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||
    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET
  ) {
    // Needs to be divided with project_uCommonUnitsPerMeter
    pos.w = pos.w / u_PixelsPerMeter.z;
  }
  return pos;
}

bool isEqual(float a, float b) {
  return a < b + 0.001 && a > b - 0.001;
}

`;
var rotation_2d = "vec2 rotate_matrix(vec2 v, float a) {\n    float b = a / 180.0 * 3.1415926535897932384626433832795;\n    float s = sin(b);\n    float c = cos(b);\n    mat2 m = mat2(c, s, -s, c);\n    return m * v;\n}";
var scene_uniforms = "layout(std140) uniform SceneUniforms {\n  mat4 u_ViewMatrix;\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewProjectionMatrix;\n  mat4 u_ModelMatrix;\n  vec4 u_ViewportCenterProjection;\n  vec3 u_PixelsPerDegree;\n  float u_Zoom;\n  vec3 u_PixelsPerDegree2;\n  float u_ZoomScale;\n  vec3 u_PixelsPerMeter;\n  float u_CoordinateSystem;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_ViewportCenter;\n  vec2 u_ViewportSize;\n  float u_FocalDistance;\n};\n";
var sdf2d = "/**\n * 2D signed distance field functions\n * @see http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n */\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCircle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdEquilateralTriangle(vec2 p) {\n  float k = sqrt(3.0);\n  p.x = abs(p.x) - 1.0;\n  p.y = p.y + 1.0/k;\n  if( p.x + k*p.y > 0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdPentagon(vec2 p, float r) {\n  vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n  p.x = abs(p.x);\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n  p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\n  return length(p)*sign(p.y);\n}\n\nfloat sdHexagon(vec2 p, float r) {\n  vec3 k = vec3(-0.866025404,0.5,0.577350269);\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat sdOctogon(vec2 p, float r) {\n  vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n  p = abs(p);\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat sdHexagram(vec2 p, float r) {\n  vec4 k=vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n  p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n  return length(p)*sign(p.y);\n}\n\nfloat sdRhombus(vec2 p, vec2 b) {\n  vec2 q = abs(p);\n  float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n  float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n  return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat sdVesica(vec2 p, float r, float d) {\n  p = abs(p);\n  float b = sqrt(r*r-d*d); // can delay this sqrt\n  return ((p.y-b)*d>p.x*b)\n          ? length(p-vec2(0.0,b))\n          : length(p-vec2(-d,0.0))-r;\n}\n";
var precisionRegExp = /precision\s+(high|low|medium)p\s+float/;
var globalDefaultprecision = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n precision highp float;\n #else\n precision mediump float;\n#endif\n";
var includeRegExp = /#pragma include (["^+"]?["[a-zA-Z_0-9](.*)"]*?)/g;
var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
var ShaderModuleService = class {
  constructor() {
    _defineProperty(this, "moduleCache", {});
    _defineProperty(this, "rawContentCache", {});
  }
  registerBuiltinModules() {
    this.destroy();
    this.registerModule("common", {
      vs: common,
      fs: common
    });
    this.registerModule("decode", {
      vs: decode,
      fs: ""
    });
    this.registerModule("scene_uniforms", {
      vs: scene_uniforms,
      fs: scene_uniforms
    });
    this.registerModule("picking_uniforms", {
      vs: picking_uniforms,
      fs: picking_uniforms
    });
    this.registerModule("projection", {
      vs: projection,
      fs: projection
    });
    this.registerModule("project", {
      vs: project2,
      fs: ""
    });
    this.registerModule("sdf_2d", {
      vs: "",
      fs: sdf2d
    });
    this.registerModule("lighting", {
      vs: lighting,
      fs: ""
    });
    this.registerModule("light", {
      vs: light,
      fs: ""
    });
    this.registerModule("picking", {
      vs: pickingVert,
      fs: pickingFrag
    });
    this.registerModule("rotation_2d", {
      vs: rotation_2d,
      fs: ""
    });
  }
  registerModule(moduleName, moduleParams) {
    moduleParams.vs = moduleParams.vs.replace(/\r\n/g, "\n");
    moduleParams.fs = moduleParams.fs.replace(/\r\n/g, "\n");
    const {
      vs,
      fs,
      uniforms: declaredUniforms,
      defines,
      inject
    } = moduleParams;
    const {
      content: extractedVS,
      uniforms: vsUniforms
    } = extractUniforms(vs);
    const {
      content: extractedFS,
      uniforms: fsUniforms
    } = extractUniforms(fs);
    this.rawContentCache[moduleName] = {
      fs: extractedFS,
      defines,
      inject,
      uniforms: _objectSpread2(_objectSpread2(_objectSpread2({}, vsUniforms), fsUniforms), declaredUniforms),
      vs: extractedVS
    };
  }
  getModule(moduleName) {
    let rawVS = this.rawContentCache[moduleName].vs;
    let rawFS = this.rawContentCache[moduleName].fs;
    const {
      defines = {},
      inject = {}
    } = this.rawContentCache[moduleName];
    let declaredUniforms = {};
    if (inject["vs:#decl"]) {
      rawVS = inject["vs:#decl"] + rawVS;
      declaredUniforms = extractUniforms(inject["vs:#decl"]).uniforms;
    }
    if (inject["vs:#main-start"]) {
      rawVS = rawVS.replace(REGEX_START_OF_MAIN, (match) => {
        return match + inject["vs:#main-start"];
      });
    }
    if (inject["fs:#decl"]) {
      rawFS = inject["fs:#decl"] + rawFS;
    }
    const injectDefines = getInjectDefines(defines);
    rawVS = injectDefines + rawVS;
    const {
      content: vs,
      includeList: vsIncludeList
    } = this.processModule(rawVS, [], "vs");
    const {
      content: fs,
      includeList: fsIncludeList
    } = this.processModule(rawFS, [], "fs");
    const uniforms = uniq2(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce((prev, cur) => {
      return _objectSpread2(_objectSpread2({}, prev), this.rawContentCache[cur].uniforms);
    }, _objectSpread2({}, declaredUniforms));
    const compiledVs = (precisionRegExp.test(fs) ? "" : globalDefaultprecision) + vs;
    const compiledFs = (precisionRegExp.test(fs) ? "" : globalDefaultprecision) + fs;
    this.moduleCache[moduleName] = {
      vs: compiledVs.trim(),
      fs: compiledFs.trim(),
      uniforms
    };
    return this.moduleCache[moduleName];
  }
  destroy() {
    this.moduleCache = {};
    this.rawContentCache = {};
  }
  /**
   *
   * 解析定义的内联模块
   * like: #pragma include "projection"
   */
  processModule(rawContent, includeList, type) {
    const compiled = rawContent.replace(includeRegExp, (_, strMatch) => {
      const includeOpt = strMatch.split(" ");
      const includeName = includeOpt[0].replace(/"/g, "");
      if (includeList.indexOf(includeName) > -1) {
        return "";
      }
      const txt = this.rawContentCache[includeName][type];
      includeList.push(includeName);
      const {
        content
      } = this.processModule(txt, includeList, type);
      return content;
    });
    return {
      content: compiled,
      includeList
    };
  }
};
function getInjectDefines(defines) {
  const defineStr = Object.keys(defines).reduce((prev, cur) => {
    return prev + `#define ${cur.toUpperCase()} ${defines[cur]}
`;
  }, "\n");
  return defineStr;
}

// node_modules/@antv/l7-core/es/services/renderer/passes/BaseNormalPass.js
var BaseNormalPass = class {
  constructor() {
    _defineProperty(this, "shaderModuleService", void 0);
    _defineProperty(this, "rendererService", void 0);
    _defineProperty(this, "cameraService", void 0);
    _defineProperty(this, "mapService", void 0);
    _defineProperty(this, "interactionService", void 0);
    _defineProperty(this, "layerService", void 0);
    _defineProperty(this, "config", void 0);
  }
  getName() {
    return "";
  }
  getType() {
    return PassType.Normal;
  }
  init(layer, config4) {
    this.config = config4;
    this.rendererService = layer.getContainer().rendererService;
    this.cameraService = layer.getContainer().cameraService;
    this.mapService = layer.getContainer().mapService;
    this.interactionService = layer.getContainer().interactionService;
    this.layerService = layer.getContainer().layerService;
    this.shaderModuleService = layer.getContainer().shaderModuleService;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(layer) {
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/ClearPass.js
var ClearPass = class extends BaseNormalPass {
  getName() {
    return "clear";
  }
  init(layer, config4) {
    super.init(layer, config4);
  }
  render() {
    this.rendererService.clear({
      color: [0, 0, 0, 0],
      depth: 1,
      framebuffer: null
    });
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/MultiPassRenderer.js
var MultiPassRenderer = class {
  constructor(postProcessor) {
    _defineProperty(this, "passes", []);
    _defineProperty(this, "layer", void 0);
    _defineProperty(this, "renderFlag", void 0);
    _defineProperty(this, "width", 0);
    _defineProperty(this, "height", 0);
    this.postProcessor = postProcessor;
  }
  setLayer(layer) {
    this.layer = layer;
  }
  setRenderFlag(renderFlag) {
    this.renderFlag = renderFlag;
  }
  getRenderFlag() {
    return this.renderFlag;
  }
  getPostProcessor() {
    return this.postProcessor;
  }
  render() {
    var _this = this;
    return _asyncToGenerator(function* () {
      for (const pass of _this.passes) {
        yield pass.render(_this.layer);
      }
      yield _this.postProcessor.render(_this.layer);
    })();
  }
  resize(width, height) {
    if (this.width !== width || this.height !== height) {
      this.postProcessor.resize(width, height);
      this.width = width;
      this.height = height;
    }
  }
  add(pass, config4) {
    if (pass.getType() === PassType.PostProcessing) {
      this.postProcessor.add(pass, this.layer, config4);
    } else {
      pass.init(this.layer, config4);
      this.passes.push(pass);
    }
  }
  insert(pass, config4, index) {
    pass.init(this.layer, config4);
    this.passes.splice(index, 0, pass);
  }
  destroy() {
    this.passes.length = 0;
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/PixelPickingPass.js
var PixelPickingPass = class extends BaseNormalPass {
  constructor(...args) {
    var _this;
    super(...args);
    _this = this;
    _defineProperty(this, "pickingFBO", void 0);
    _defineProperty(this, "layer", void 0);
    _defineProperty(this, "width", 0);
    _defineProperty(this, "height", 0);
    _defineProperty(this, "alreadyInRendering", false);
    _defineProperty(this, "pickFromPickingFBO", ({
      x: x2,
      y,
      lngLat,
      type
    }) => {
      if (!this.layer.isVisible() || !this.layer.needPick(type)) {
        return;
      }
      const {
        getViewportSize,
        readPixelsAsync,
        useFramebuffer
      } = this.rendererService;
      const {
        width,
        height
      } = getViewportSize();
      const {
        enableHighlight,
        enableSelect
      } = this.layer.getLayerConfig();
      const xInDevicePixel = x2 * dom_exports.DPR;
      const yInDevicePixel = y * dom_exports.DPR;
      if (xInDevicePixel > width || xInDevicePixel < 0 || yInDevicePixel > height || yInDevicePixel < 0) {
        return;
      }
      let pickedColors;
      useFramebuffer(this.pickingFBO, _asyncToGenerator(function* () {
        var _pickedColors;
        pickedColors = yield readPixelsAsync({
          x: Math.round(xInDevicePixel),
          // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
          y: Math.round(height - (y + 1) * dom_exports.DPR),
          width: 1,
          height: 1,
          data: new Uint8Array(1 * 1 * 4),
          framebuffer: _this.pickingFBO
        });
        if (pickedColors[0] !== 0 || pickedColors[1] !== 0 || pickedColors[2] !== 0) {
          const pickedFeatureIdx = decodePickingColor(pickedColors);
          const rawFeature = _this.layer.getSource().getFeatureById(pickedFeatureIdx);
          const target = {
            x: x2,
            y,
            type,
            lngLat,
            featureId: pickedFeatureIdx,
            feature: rawFeature
          };
          if (!rawFeature) {
          } else {
            _this.layer.setCurrentPickId(pickedFeatureIdx);
            _this.triggerHoverOnLayer(target);
          }
        } else {
          const target = {
            x: x2,
            y,
            lngLat,
            type: _this.layer.getCurrentPickId() === null ? "un" + type : "mouseout",
            featureId: null,
            feature: null
          };
          _this.triggerHoverOnLayer(_objectSpread2(_objectSpread2({}, target), {}, {
            type: "unpick"
          }));
          _this.triggerHoverOnLayer(target);
          _this.layer.setCurrentPickId(null);
        }
        if (enableHighlight) {
          _this.highlightPickedFeature(pickedColors);
        }
        if (enableSelect && type === "click" && ((_pickedColors = pickedColors) === null || _pickedColors === void 0 ? void 0 : _pickedColors.toString()) !== [0, 0, 0, 0].toString()) {
          _this.selectFeature(pickedColors);
        }
      }));
    });
  }
  getType() {
    return PassType.Normal;
  }
  getName() {
    return "pixelPicking";
  }
  init(layer, config4) {
    super.init(layer, config4);
    this.layer = layer;
    const {
      createTexture2D,
      createFramebuffer,
      getViewportSize
    } = this.rendererService;
    const {
      width,
      height
    } = getViewportSize();
    const pickingColorTexture = createTexture2D({
      width,
      height,
      wrapS: gl.CLAMP_TO_EDGE,
      wrapT: gl.CLAMP_TO_EDGE,
      label: "Picking Texture"
    });
    this.pickingFBO = createFramebuffer({
      color: pickingColorTexture
    });
    this.interactionService.on(InteractionEvent.Hover, this.pickFromPickingFBO);
    this.interactionService.on(InteractionEvent.Select, this.selectFeatureHandle.bind(this));
    this.interactionService.on(InteractionEvent.Active, this.highlightFeatureHandle.bind(this));
  }
  render(layer) {
    if (this.alreadyInRendering) {
      return;
    }
    const {
      getViewportSize,
      useFramebuffer,
      clear
    } = this.rendererService;
    const {
      width,
      height
    } = getViewportSize();
    this.alreadyInRendering = true;
    if (this.width !== width || this.height !== height) {
      this.pickingFBO.resize({
        width,
        height
      });
      this.width = width;
      this.height = height;
    }
    useFramebuffer(this.pickingFBO, () => {
      clear({
        framebuffer: this.pickingFBO,
        color: [0, 0, 0, 0],
        stencil: 0,
        depth: 1
      });
      const originRenderFlag = this.layer.multiPassRenderer.getRenderFlag();
      this.layer.multiPassRenderer.setRenderFlag(false);
      layer.hooks.beforePickingEncode.call();
      layer.render();
      layer.hooks.afterPickingEncode.call();
      this.layer.multiPassRenderer.setRenderFlag(originRenderFlag);
      this.alreadyInRendering = false;
    });
  }
  triggerHoverOnLayer(target) {
    this.layer.emit(target.type, target);
  }
  /**
   * highlight 如果直接修改选中 feature 的 buffer，存在两个问题：
   * 1. 鼠标移走时无法恢复
   * 2. 无法实现高亮颜色与原始原色的 alpha 混合
   * 因此高亮还是放在 shader 中做比较好
   * @example
   * this.layer.color('name', ['#000000'], {
   *  featureRange: {
   *    startIndex: pickedFeatureIdx,
   *    endIndex: pickedFeatureIdx + 1,
   *  },
   * });
   */
  highlightPickedFeature(pickedColors) {
    const [r, g, b] = pickedColors;
    this.layer.hooks.beforeHighlight.call([r, g, b]);
    this.layerService.renderLayers();
  }
  selectFeature(pickedColors) {
    const [r, g, b] = pickedColors;
    this.layer.hooks.beforeSelect.call([r, g, b]);
    this.layerService.renderLayers();
  }
  selectFeatureHandle({
    featureId
  }) {
    const pickedColors = encodePickingColor(featureId);
    this.selectFeature(new Uint8Array(pickedColors));
  }
  highlightFeatureHandle({
    featureId
  }) {
    const pickedColors = encodePickingColor(featureId);
    this.highlightPickedFeature(new Uint8Array(pickedColors));
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/PostProcessor.js
var PostProcessor = class {
  constructor(rendererService) {
    _defineProperty(this, "passes", []);
    _defineProperty(this, "readFBO", void 0);
    _defineProperty(this, "writeFBO", void 0);
    this.rendererService = rendererService;
    this.init();
  }
  getReadFBO() {
    return this.readFBO;
  }
  getWriteFBO() {
    return this.writeFBO;
  }
  /**
   * 从当前的 framebuffer 中获取贴图
   * @returns
   */
  getCurrentFBOTex() {
    const {
      getViewportSize,
      createTexture2D
    } = this.rendererService;
    const {
      width,
      height
    } = getViewportSize();
    return createTexture2D({
      x: 0,
      y: 0,
      width,
      height,
      copy: true
    });
  }
  /**
   * 从 readFBO 中获取贴图
   * @returns
   */
  getReadFBOTex() {
    var _this = this;
    const {
      useFramebuffer
    } = this.rendererService;
    return new Promise((resolve) => {
      useFramebuffer(this.readFBO, _asyncToGenerator(function* () {
        resolve(_this.getCurrentFBOTex());
      }));
    });
  }
  renderBloomPass(layer, pass) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const tex = yield _this2.getReadFBOTex();
      let count = 0;
      while (count < 4) {
        yield pass.render(layer, tex);
        _this2.swap();
        count++;
      }
    })();
  }
  render(layer) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      for (let i2 = 0; i2 < _this3.passes.length; i2++) {
        const pass = _this3.passes[i2];
        pass.setRenderToScreen(_this3.isLastEnabledPass(i2));
        if (pass.getName() === "bloom") {
          yield _this3.renderBloomPass(layer, pass);
        } else {
          yield pass.render(layer);
          if (i2 !== _this3.passes.length - 1) {
            _this3.swap();
          }
        }
      }
    })();
  }
  resize(width, height) {
    this.readFBO.resize({
      width,
      height
    });
    this.writeFBO.resize({
      width,
      height
    });
  }
  add(pass, layer, config4) {
    pass.init(layer, config4);
    this.passes.push(pass);
  }
  insert(pass, index, layer, config4) {
    pass.init(layer, config4);
    this.passes.splice(index, 0, pass);
  }
  getPostProcessingPassByName(name) {
    return this.passes.find((p) => p.getName() === name);
  }
  init() {
    const {
      createFramebuffer,
      createTexture2D
    } = this.rendererService;
    this.readFBO = createFramebuffer({
      color: createTexture2D({
        width: 1,
        height: 1,
        wrapS: gl.CLAMP_TO_EDGE,
        wrapT: gl.CLAMP_TO_EDGE,
        usage: TextureUsage.RENDER_TARGET
      })
    });
    this.writeFBO = createFramebuffer({
      color: createTexture2D({
        width: 1,
        height: 1,
        wrapS: gl.CLAMP_TO_EDGE,
        wrapT: gl.CLAMP_TO_EDGE,
        usage: TextureUsage.RENDER_TARGET
      })
    });
  }
  isLastEnabledPass(index) {
    for (let i2 = index + 1; i2 < this.passes.length; i2++) {
      if (this.passes[i2].isEnabled()) {
        return false;
      }
    }
    return true;
  }
  swap() {
    const tmp = this.readFBO;
    this.readFBO = this.writeFBO;
    this.writeFBO = tmp;
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/RenderPass.js
var RenderPass = class extends BaseNormalPass {
  getType() {
    return PassType.Normal;
  }
  getName() {
    return "render";
  }
  init(layer, config4) {
    super.init(layer, config4);
  }
  render(layer) {
    const {
      useFramebuffer,
      clear
    } = this.rendererService;
    const readFBO = layer.multiPassRenderer.getPostProcessor().getReadFBO();
    useFramebuffer(readFBO, () => {
      clear({
        color: [0, 0, 0, 0],
        depth: 1,
        stencil: 0,
        framebuffer: readFBO
      });
      layer.multiPassRenderer.setRenderFlag(false);
      layer.models.forEach((model) => {
        model.draw({
          uniforms: layer.layerModel.getUninforms()
        });
      });
      layer.multiPassRenderer.setRenderFlag(true);
    });
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/post-processing/BloomPass.js
var blur = "varying vec2 v_UV;\n\nuniform float u_BloomFinal: 0.0;\nuniform sampler2D u_Texture;\nuniform sampler2D u_Texture2;\n\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform float u_radius: 5.0;\nuniform float u_intensity: 0.3;\nuniform float u_baseRadio: 0.5;\n\n// https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.3846153846) * direction;\n  vec2 off2 = vec2(3.2307692308) * direction;\n  color += texture2D(image, uv) * 0.2270270270;\n  color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n  color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n  return color;\n}\n\nfloat luminance(vec4 color) {\n  return  0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;\n}\n\nvoid main() {\n  // vec4 baseColor = texture2D(u_Texture, v_UV);\n\n  float r = sqrt(u_radius);\n\n  vec4 c1 = blur9(u_Texture, v_UV, u_ViewportSize, vec2(u_radius, 0.0));\n  // c1 *= luminance(c1);\n  vec4 c2 = blur9(u_Texture, v_UV, u_ViewportSize, vec2(0.0, u_radius));\n  // c2 *= luminance(c2);\n  vec4 c3 = blur9(u_Texture, v_UV, u_ViewportSize, vec2(r, r));\n  // c3 *= luminance(c3);\n  vec4 c4 = blur9(u_Texture, v_UV, u_ViewportSize, vec2(r, -r));\n  // c4 *= luminance(c4);\n  vec4 inbloomColor = (c1 + c2 + c3 + c4) * 0.25;\n\n  // float lum = luminance(inbloomColor);\n  // inbloomColor.rgb *= lum;\n\n  if(u_BloomFinal > 0.0) {\n    vec4 baseColor = texture2D(u_Texture2, v_UV);\n    float baselum = luminance(baseColor);\n    gl_FragColor = mix(inbloomColor, baseColor, u_baseRadio);\n    if(baselum <= 0.2) {\n      gl_FragColor = inbloomColor * u_intensity;\n    }\n  } else {\n    gl_FragColor = inbloomColor;\n  }\n}";
var quad2 = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
var {
  isNil: isNil4
} = lodashUtil;
var BloomPass = class extends BasePostProcessingPass {
  setupShaders() {
    this.shaderModuleService.registerModule("blur-pass", {
      vs: quad2,
      fs: blur
    });
    const {
      vs,
      fs,
      uniforms
    } = this.shaderModuleService.getModule("blur-pass");
    const {
      width,
      height
    } = this.rendererService.getViewportSize();
    return {
      vs,
      fs,
      uniforms: _objectSpread2(_objectSpread2({}, uniforms), {}, {
        u_ViewportSize: [width, height]
      })
    };
  }
  convertOptionsToUniforms(options) {
    const uniforms = {};
    if (!isNil4(options.bloomRadius)) {
      uniforms.u_radius = options.bloomRadius;
    }
    if (!isNil4(options.bloomIntensity)) {
      uniforms.u_intensity = options.bloomIntensity;
    }
    if (!isNil4(options.bloomBaseRadio)) {
      uniforms.u_baseRadio = options.bloomBaseRadio;
    }
    return uniforms;
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/post-processing/BlurHPass.js
var blur2 = "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\n\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform vec2 u_BlurDir: [1.0, 0.0];\n\n// https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.3846153846) * direction;\n  vec2 off2 = vec2(3.2307692308) * direction;\n  color += texture2D(image, uv) * 0.2270270270;\n  color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n  color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n  return color;\n}\n\nvoid main() {\n  gl_FragColor = blur9(u_Texture, v_UV, u_ViewportSize, u_BlurDir);\n}";
var quad3 = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
var {
  isNil: isNil5
} = lodashUtil;
var BlurHPass = class extends BasePostProcessingPass {
  setupShaders() {
    this.shaderModuleService.registerModule("blur-pass", {
      vs: quad3,
      fs: blur2
    });
    const {
      vs,
      fs,
      uniforms
    } = this.shaderModuleService.getModule("blur-pass");
    const {
      width,
      height
    } = this.rendererService.getViewportSize();
    return {
      vs,
      fs,
      uniforms: _objectSpread2(_objectSpread2({}, uniforms), {}, {
        u_ViewportSize: [width, height]
      })
    };
  }
  convertOptionsToUniforms(options) {
    const uniforms = {};
    if (!isNil5(options.blurRadius)) {
      uniforms.u_BlurDir = [options.blurRadius, 0];
    }
    return uniforms;
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/post-processing/BlurVPass.js
var blur3 = "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\n\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform vec2 u_BlurDir: [1.0, 0.0];\n\n// https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.3846153846) * direction;\n  vec2 off2 = vec2(3.2307692308) * direction;\n  color += texture2D(image, uv) * 0.2270270270;\n  color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n  color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n  return color;\n}\n\nvoid main() {\n  gl_FragColor = blur9(u_Texture, v_UV, u_ViewportSize, u_BlurDir);\n}";
var quad4 = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
var {
  isNil: isNil6
} = lodashUtil;
var BlurVPass = class extends BasePostProcessingPass {
  setupShaders() {
    this.shaderModuleService.registerModule("blur-pass", {
      vs: quad4,
      fs: blur3
    });
    const {
      vs,
      fs,
      uniforms
    } = this.shaderModuleService.getModule("blur-pass");
    const {
      width,
      height
    } = this.rendererService.getViewportSize();
    return {
      vs,
      fs,
      uniforms: _objectSpread2(_objectSpread2({}, uniforms), {}, {
        u_ViewportSize: [width, height]
      })
    };
  }
  convertOptionsToUniforms(options) {
    const uniforms = {};
    if (!isNil6(options.blurRadius)) {
      uniforms.u_BlurDir = [0, options.blurRadius];
    }
    return uniforms;
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/post-processing/ColorHalfTonePass.js
var colorHalftone = 'varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform vec2 u_Center : [0.5, 0.5];\nuniform float u_Angle : 0;\nuniform float u_Size : 8;\n\n#pragma include "common"\n\nfloat scale = PI / u_Size;\n\nfloat pattern(float u_Angle, vec2 texSize, vec2 texCoord) {\n  float s = sin(u_Angle), c = cos(u_Angle);\n  vec2 tex = texCoord * texSize - u_Center * texSize;\n  vec2 point = vec2(\n    c * tex.x - s * tex.y,\n    s * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\n// https://github.com/evanw/glfx.js/blob/master/src/filters/fun/colorhalftone.js\nvec4 colorHalftone_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {\n  vec3 cmy = 1.0 - color.rgb;\n  float k = min(cmy.x, min(cmy.y, cmy.z));\n  cmy = (cmy - k) / (1.0 - k);\n  cmy = clamp(\n    cmy * 10.0 - 3.0 + vec3(\n      pattern(u_Angle + 0.26179, texSize, texCoord),\n      pattern(u_Angle + 1.30899, texSize, texCoord),\n      pattern(u_Angle, texSize, texCoord)\n    ),\n    0.0,\n    1.0\n  );\n  k = clamp(k * 10.0 - 5.0 + pattern(u_Angle + 0.78539, texSize, texCoord), 0.0, 1.0);\n  return vec4(1.0 - cmy - k, color.a);\n}\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n  gl_FragColor = colorHalftone_filterColor(gl_FragColor, u_ViewportSize, v_UV);\n}';
var quad5 = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
var ColorHalftonePass = class extends BasePostProcessingPass {
  setupShaders() {
    this.shaderModuleService.registerModule("colorhalftone-pass", {
      vs: quad5,
      fs: colorHalftone
    });
    const {
      vs,
      fs,
      uniforms
    } = this.shaderModuleService.getModule("colorhalftone-pass");
    const {
      width,
      height
    } = this.rendererService.getViewportSize();
    return {
      vs,
      fs,
      uniforms: _objectSpread2(_objectSpread2({}, uniforms), {}, {
        u_ViewportSize: [width, height]
      })
    };
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/post-processing/CopyPass.js
var copy7 = "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n}";
var quad6 = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
var CopyPass = class extends BasePostProcessingPass {
  setupShaders() {
    this.shaderModuleService.registerModule("copy-pass", {
      vs: quad6,
      fs: copy7
    });
    return this.shaderModuleService.getModule("copy-pass");
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/post-processing/HexagonalPixelatePass.js
var hexagonalPixelate = "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform vec2 u_Center : [0.5, 0.5];\nuniform float u_Scale : 10;\n\n// https://github.com/evanw/glfx.js/blob/master/src/filters/fun/hexagonalpixelate.js\nvec4 hexagonalPixelate_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 tex = (texCoord * texSize - u_Center * texSize) / u_Scale;\n  tex.y /= 0.866025404;\n  tex.x -= tex.y * 0.5;\n  vec2 a;\n  if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\n    a = vec2(floor(tex.x), floor(tex.y));\n  }\n  else a = vec2(ceil(tex.x), ceil(tex.y));\n  vec2 b = vec2(ceil(tex.x), floor(tex.y));\n  vec2 c = vec2(floor(tex.x), ceil(tex.y));\n  vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n  vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\n  vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\n  vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\n  float alen = length(TEX - A);\n  float blen = length(TEX - B);\n  float clen = length(TEX - C);\n  vec2 choice;\n  if (alen < blen) {\n    if (alen < clen) choice = a;\n    else choice = c;\n  } else {\n    if (blen < clen) choice = b;\n    else choice = c;\n  }\n  choice.x += choice.y * 0.5;\n  choice.y *= 0.866025404;\n  choice *= u_Scale / texSize;\n  return texture2D(texture, choice + u_Center);\n}\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n  gl_FragColor = hexagonalPixelate_sampleColor(u_Texture, u_ViewportSize, v_UV);\n}";
var quad7 = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
var HexagonalPixelatePass = class extends BasePostProcessingPass {
  setupShaders() {
    this.shaderModuleService.registerModule("hexagonalpixelate-pass", {
      vs: quad7,
      fs: hexagonalPixelate
    });
    const {
      vs,
      fs,
      uniforms
    } = this.shaderModuleService.getModule("hexagonalpixelate-pass");
    const {
      width,
      height
    } = this.rendererService.getViewportSize();
    return {
      vs,
      fs,
      uniforms: _objectSpread2(_objectSpread2({}, uniforms), {}, {
        u_ViewportSize: [width, height]
      })
    };
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/post-processing/InkPass.js
var ink = "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform float u_Strength : 0.6;\n\nvec4 ink_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {\n  vec2 dx = vec2(1.0 / texSize.x, 0.0);\n  vec2 dy = vec2(0.0, 1.0 / texSize.y);\n  vec4 color = texture2D(texture, texCoord);\n  float bigTotal = 0.0;\n  float smallTotal = 0.0;\n  vec3 bigAverage = vec3(0.0);\n  vec3 smallAverage = vec3(0.0);\n  for (float x = -2.0; x <= 2.0; x += 1.0) {\n    for (float y = -2.0; y <= 2.0; y += 1.0) {\n      vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;\n      bigAverage += sample;\n      bigTotal += 1.0;\n      if (abs(x) + abs(y) < 2.0) {\n        smallAverage += sample;\n        smallTotal += 1.0;\n      }\n    }\n  }\n  vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\n  float power = u_Strength * u_Strength * u_Strength * u_Strength * u_Strength;\n  return vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);\n}\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n  gl_FragColor = ink_sampleColor(u_Texture, u_ViewportSize, v_UV);\n}";
var quad8 = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
var InkPass = class extends BasePostProcessingPass {
  setupShaders() {
    this.shaderModuleService.registerModule("ink-pass", {
      vs: quad8,
      fs: ink
    });
    const {
      vs,
      fs,
      uniforms
    } = this.shaderModuleService.getModule("ink-pass");
    const {
      width,
      height
    } = this.rendererService.getViewportSize();
    return {
      vs,
      fs,
      uniforms: _objectSpread2(_objectSpread2({}, uniforms), {}, {
        u_ViewportSize: [width, height]
      })
    };
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/post-processing/NoisePass.js
var noise = "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\nuniform float u_Amount : 0.5;\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/noise.js\nvec4 noise_filterColor(vec4 color, vec2 texCoord) {\n  float diff = (rand(texCoord) - 0.5) * u_Amount;\n  color.r += diff;\n  color.g += diff;\n  color.b += diff;\n  return color;\n}\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n  gl_FragColor = noise_filterColor(gl_FragColor, v_UV);\n}";
var quad9 = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
var NoisePass = class extends BasePostProcessingPass {
  setupShaders() {
    this.shaderModuleService.registerModule("noise-pass", {
      vs: quad9,
      fs: noise
    });
    return this.shaderModuleService.getModule("noise-pass");
  }
};

// node_modules/@antv/l7-core/es/services/renderer/passes/post-processing/SepiaPass.js
var quad10 = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
var sepia = "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\n\nuniform float u_Amount : 0.5;\n\n// https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/sepia.js\nvec4 sepia_filterColor(vec4 color) {\n  float r = color.r;\n  float g = color.g;\n  float b = color.b;\n  color.r =\n    min(1.0, (r * (1.0 - (0.607 * u_Amount))) + (g * (0.769 * u_Amount)) + (b * (0.189 * u_Amount)));\n  color.g = min(1.0, (r * 0.349 * u_Amount) + (g * (1.0 - (0.314 * u_Amount))) + (b * 0.168 * u_Amount));\n  color.b = min(1.0, (r * 0.272 * u_Amount) + (g * 0.534 * u_Amount) + (b * (1.0 - (0.869 * u_Amount))));\n  return color;\n}\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n  gl_FragColor = sepia_filterColor(gl_FragColor);\n}";
var SepiaPass = class extends BasePostProcessingPass {
  setupShaders() {
    this.shaderModuleService.registerModule("sepia-pass", {
      vs: quad10,
      fs: sepia
    });
    return this.shaderModuleService.getModule("sepia-pass");
  }
};

// node_modules/@antv/l7-core/es/inversify.config.js
var globalConfigService = new GlobalConfigService();
var sceneIdCounter = 0;
function createSceneContainer() {
  const shaderModuleService = new ShaderModuleService();
  const debugService = new DebugService();
  const cameraService = new CameraService();
  const coordinateSystemService = new CoordinateSystemService(cameraService);
  const fontService = new FontService();
  const iconService = new IconService();
  const markerService = new MarkerService();
  const popupService = new PopupService();
  const controlService = new ControlService();
  const container = {
    id: `${sceneIdCounter++}`,
    globalConfigService,
    shaderModuleService,
    debugService,
    cameraService,
    coordinateSystemService,
    fontService,
    iconService,
    markerService,
    popupService,
    controlService,
    customRenderService: {}
  };
  const layerService = new LayerService(container);
  container.layerService = layerService;
  const sceneService = new Scene(container);
  container.sceneService = sceneService;
  const interactionService = new InteractionService(container);
  container.interactionService = interactionService;
  const pickingService = new PickingService(container);
  container.pickingService = pickingService;
  const normalPass = {
    clear: new ClearPass(),
    pixelPicking: new PixelPickingPass(),
    render: new RenderPass()
  };
  container.normalPassFactory = (named2) => {
    return normalPass[named2];
  };
  const postProcessingPass = {
    copy: new CopyPass(),
    bloom: new BloomPass(),
    blurH: new BlurHPass(),
    blurV: new BlurVPass(),
    noise: new NoisePass(),
    sepia: new SepiaPass(),
    colorHalftone: new ColorHalftonePass(),
    hexagonalPixelate: new HexagonalPixelatePass(),
    ink: new InkPass()
  };
  container.postProcessingPass = postProcessingPass;
  container.postProcessingPassFactory = (named2) => {
    return postProcessingPass[named2];
  };
  return container;
}
function createLayerContainer(sceneContainer) {
  const layerContainer = _objectSpread2({}, sceneContainer);
  layerContainer.postProcessor = new PostProcessor(layerContainer.rendererService);
  layerContainer.multiPassRenderer = new MultiPassRenderer(layerContainer.postProcessor);
  layerContainer.styleAttributeService = new StyleAttributeService(layerContainer.rendererService);
  return layerContainer;
}

// node_modules/@antv/l7-core/es/services/scene/ISceneService.js
var SceneEventList = ["loaded", "fontloaded", "maploaded", "resize", "destroy", "dragstart", "dragging", "dragend", "dragcancel"];

// node_modules/@antv/l7-core/es/services/source/ISourceService.js
var RasterTileType = function(RasterTileType2) {
  RasterTileType2["IMAGE"] = "image";
  RasterTileType2["CUSTOMIMAGE"] = "customImage";
  RasterTileType2["ARRAYBUFFER"] = "arraybuffer";
  RasterTileType2["RGB"] = "rgb";
  RasterTileType2["TERRAINRGB"] = "terrainRGB";
  RasterTileType2["CUSTOMRGB"] = "customRGB";
  RasterTileType2["CUSTOMARRAYBUFFER"] = "customArrayBuffer";
  RasterTileType2["CUSTOMTERRAINRGB"] = "customTerrainRGB";
  return RasterTileType2;
}({});

// node_modules/@antv/l7-maps/es/lib/base-map.js
var import_eventemitter39 = __toESM(require_eventemitter3());

// node_modules/@antv/l7-maps/es/utils/simpleMapCoord.js
var SimpleMapCoord = class {
  constructor(size) {
    _defineProperty(this, "size", 1e4);
    this.size = size ? size : 1e4;
  }
  setSize(size) {
    this.size = size;
  }
  getSize() {
    return [this.size, this.size];
  }
  /**
   * coord
   * ^ y (y > 0)
   * |
   * |
   * |
   * |(x = 0, y = 0)
   * ---------------> x (x > 0)
   */
  /***
   * lng: [-180, 180] 360
   * lat: [-85.05112877980659, 85.05112877980659] 170.10225755961318
   */
  mercatorXfromLng(lng) {
    return (180 + lng) / 360 * this.size;
  }
  mercatorYfromLat(lat) {
    return (1 - (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360) * this.size;
  }
  lngFromMercatorX(x2) {
    return x2 / this.size * 360 - 180;
  }
  latFromMercatorY(y) {
    const y2 = 180 - (1 - y / this.size) * 360;
    return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
  }
  project(lnglat) {
    const x2 = this.mercatorXfromLng(lnglat[0]);
    const y = this.mercatorYfromLat(lnglat[1]);
    return [x2, y];
  }
  unproject(xy) {
    const lng = this.lngFromMercatorX(xy[0]);
    const lat = this.latFromMercatorY(xy[1]);
    return [lng, lat];
  }
};

// node_modules/@antv/l7-maps/es/lib/base-map.js
var LNGLAT_OFFSET_ZOOM_THRESHOLD = 12;
var BaseMap = class {
  constructor(container) {
    _defineProperty(this, "map", void 0);
    _defineProperty(this, "simpleMapCoord", new SimpleMapCoord());
    _defineProperty(this, "bgColor", "rgba(0.0, 0.0, 0.0, 0.0)");
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "configService", void 0);
    _defineProperty(this, "coordinateSystemService", void 0);
    _defineProperty(this, "eventEmitter", void 0);
    _defineProperty(this, "markerContainer", void 0);
    _defineProperty(this, "mapContainer", void 0);
    _defineProperty(this, "cameraChangedCallback", void 0);
    this.config = container.mapConfig;
    this.configService = container.globalConfigService;
    this.coordinateSystemService = container.coordinateSystemService;
    this.eventEmitter = new import_eventemitter39.EventEmitter();
  }
  onCameraChanged(callback) {
    this.cameraChangedCallback = callback;
  }
  updateView(viewOption) {
    var _this$cameraChangedCa;
    this.emit("mapchange");
    this.viewport.syncWithMapCamera({
      bearing: viewOption.bearing,
      center: viewOption.center,
      viewportHeight: viewOption.viewportHeight,
      pitch: viewOption.pitch,
      viewportWidth: viewOption.viewportWidth,
      zoom: viewOption.zoom
    });
    this.updateCoordinateSystemService();
    (_this$cameraChangedCa = this.cameraChangedCallback) === null || _this$cameraChangedCa === void 0 || _this$cameraChangedCa.call(this, this.viewport);
  }
  updateCoordinateSystemService() {
    const {
      offsetCoordinate = true
    } = this.config;
    if (this.viewport.getZoom() > LNGLAT_OFFSET_ZOOM_THRESHOLD && offsetCoordinate) {
      this.coordinateSystemService.setCoordinateSystem(CoordinateSystem.LNGLAT_OFFSET);
    } else {
      this.coordinateSystemService.setCoordinateSystem(CoordinateSystem.LNGLAT);
    }
  }
  creatMapContainer(id2) {
    let $wrapper;
    if (typeof id2 === "string") {
      $wrapper = document.getElementById(id2);
    } else {
      $wrapper = id2;
    }
    return $wrapper;
  }
  getMapStyleValue(name) {
    var _this$getMapStyleConf;
    return (_this$getMapStyleConf = this.getMapStyleConfig()[name]) !== null && _this$getMapStyleConf !== void 0 ? _this$getMapStyleConf : name;
  }
  setBgColor(color2) {
    this.bgColor = color2;
  }
  getMapContainer() {
    return this.mapContainer;
  }
  getMarkerContainer() {
    return this.markerContainer;
  }
  getOverlayContainer() {
    return void 0;
  }
  getCanvasOverlays() {
    return void 0;
  }
  emit(name, ...args) {
    this.eventEmitter.emit(name, ...args);
  }
  once(name, handler) {
    this.eventEmitter.once(name, handler);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  meterToCoord(center, outer) {
    return 1;
  }
  destroy() {
    this.eventEmitter.removeAllListeners();
  }
};

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n) {
  if (!(a instanceof n))
    throw new TypeError("Cannot call a class as a function");
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e))
    return e;
  if (void 0 !== e)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
    return t4.__proto__ || Object.getPrototypeOf(t4);
  }, _getPrototypeOf(t);
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e2) {
    return t4.__proto__ = e2, t4;
  }, _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t, e) {
  if ("function" != typeof e && null !== e)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r) {
  if (Array.isArray(r))
    return r;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i2, u, a = [], f = true, o = false;
    try {
      if (i2 = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t)
          return;
        f = false;
      } else
        for (; !(f = (e = i2.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
          ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u))
          return;
      } finally {
        if (o)
          throw n;
      }
    }
    return a;
  }
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++)
    n[e] = r[e];
  return n;
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r)
      return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}

// node_modules/viewport-mercator-project/dist/esm/math-utils.js
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function transformVector(matrix, vector) {
  var result = transformMat42([], vector, matrix);
  scale4(result, result, 1 / result[3]);
  return result;
}

// node_modules/viewport-mercator-project/dist/esm/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "viewport-mercator-project: assertion failed.");
  }
}

// node_modules/viewport-mercator-project/dist/esm/web-mercator-utils.js
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS2 = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE2 = 512;
var EARTH_CIRCUMFERENCE2 = 4003e4;
var DEFAULT_ALTITUDE = 1.5;
function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}
function lngLatToWorld(_ref, scale6) {
  var _ref2 = _slicedToArray(_ref, 2), lng = _ref2[0], lat = _ref2[1];
  assert(Number.isFinite(lng) && Number.isFinite(scale6));
  assert(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
  scale6 *= TILE_SIZE2;
  var lambda2 = lng * DEGREES_TO_RADIANS2;
  var phi2 = lat * DEGREES_TO_RADIANS2;
  var x2 = scale6 * (lambda2 + PI) / (2 * PI);
  var y = scale6 * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x2, y];
}
function worldToLngLat(_ref3, scale6) {
  var _ref4 = _slicedToArray(_ref3, 2), x2 = _ref4[0], y = _ref4[1];
  scale6 *= TILE_SIZE2;
  var lambda2 = x2 / scale6 * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale6 * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}
function getDistanceScales2(_ref6) {
  var latitude2 = _ref6.latitude, longitude2 = _ref6.longitude, zoom = _ref6.zoom, scale6 = _ref6.scale, _ref6$highPrecision = _ref6.highPrecision, highPrecision = _ref6$highPrecision === void 0 ? false : _ref6$highPrecision;
  scale6 = scale6 !== void 0 ? scale6 : zoomToScale(zoom);
  assert(Number.isFinite(latitude2) && Number.isFinite(longitude2) && Number.isFinite(scale6));
  var result = {};
  var worldSize = TILE_SIZE2 * scale6;
  var latCosine = Math.cos(latitude2 * DEGREES_TO_RADIANS2);
  var pixelsPerDegreeX = worldSize / 360;
  var pixelsPerDegreeY = pixelsPerDegreeX / latCosine;
  var altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE2 / latCosine;
  result.pixelsPerMeter = [altPixelsPerMeter, -altPixelsPerMeter, altPixelsPerMeter];
  result.metersPerPixel = [1 / altPixelsPerMeter, -1 / altPixelsPerMeter, 1 / altPixelsPerMeter];
  result.pixelsPerDegree = [pixelsPerDegreeX, -pixelsPerDegreeY, altPixelsPerMeter];
  result.degreesPerPixel = [1 / pixelsPerDegreeX, -1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];
  if (highPrecision) {
    var latCosine2 = DEGREES_TO_RADIANS2 * Math.tan(latitude2 * DEGREES_TO_RADIANS2) / latCosine;
    var pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;
    var altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE2 * latCosine2;
    var altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;
    result.pixelsPerDegree2 = [0, -pixelsPerDegreeY2, altPixelsPerDegree2];
    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];
  }
  return result;
}
function getViewMatrix(_ref7) {
  var height = _ref7.height, pitch = _ref7.pitch, bearing = _ref7.bearing, altitude = _ref7.altitude, _ref7$center = _ref7.center, center = _ref7$center === void 0 ? null : _ref7$center, _ref7$flipY = _ref7.flipY, flipY = _ref7$flipY === void 0 ? false : _ref7$flipY;
  var vm = createMat4();
  translate(vm, vm, [0, 0, -altitude]);
  scale2(vm, vm, [1, 1, 1 / height]);
  rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS2);
  rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS2);
  if (flipY) {
    scale2(vm, vm, [1, -1, 1]);
  }
  if (center) {
    translate(vm, vm, negate([], center));
  }
  return vm;
}
function getProjectionParameters(_ref8) {
  var width = _ref8.width, height = _ref8.height, _ref8$altitude = _ref8.altitude, altitude = _ref8$altitude === void 0 ? DEFAULT_ALTITUDE : _ref8$altitude, _ref8$pitch = _ref8.pitch, pitch = _ref8$pitch === void 0 ? 0 : _ref8$pitch, _ref8$nearZMultiplier = _ref8.nearZMultiplier, nearZMultiplier = _ref8$nearZMultiplier === void 0 ? 1 : _ref8$nearZMultiplier, _ref8$farZMultiplier = _ref8.farZMultiplier, farZMultiplier = _ref8$farZMultiplier === void 0 ? 1 : _ref8$farZMultiplier;
  var pitchRadians = pitch * DEGREES_TO_RADIANS2;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;
  return {
    fov: 2 * Math.atan(height / 2 / altitude),
    aspect: width / height,
    focalDistance: altitude,
    near: nearZMultiplier,
    far: farZ * farZMultiplier
  };
}
function getProjectionMatrix(_ref9) {
  var width = _ref9.width, height = _ref9.height, pitch = _ref9.pitch, altitude = _ref9.altitude, nearZMultiplier = _ref9.nearZMultiplier, farZMultiplier = _ref9.farZMultiplier;
  var _getProjectionParamet = getProjectionParameters({
    width,
    height,
    altitude,
    pitch,
    nearZMultiplier,
    farZMultiplier
  }), fov = _getProjectionParamet.fov, aspect = _getProjectionParamet.aspect, near = _getProjectionParamet.near, far = _getProjectionParamet.far;
  var projectionMatrix = perspective([], fov, aspect, near, far);
  return projectionMatrix;
}
function worldToPixels(xyz, pixelProjectionMatrix) {
  var _xyz2 = _slicedToArray(xyz, 3), x2 = _xyz2[0], y = _xyz2[1], _xyz2$ = _xyz2[2], z = _xyz2$ === void 0 ? 0 : _xyz2$;
  assert(Number.isFinite(x2) && Number.isFinite(y) && Number.isFinite(z));
  return transformVector(pixelProjectionMatrix, [x2, y, z, 1]);
}
function pixelsToWorld(xyz, pixelUnprojectionMatrix) {
  var targetZ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var _xyz3 = _slicedToArray(xyz, 3), x2 = _xyz3[0], y = _xyz3[1], z = _xyz3[2];
  assert(Number.isFinite(x2) && Number.isFinite(y), "invalid pixel coordinate");
  if (Number.isFinite(z)) {
    var coord = transformVector(pixelUnprojectionMatrix, [x2, y, z, 1]);
    return coord;
  }
  var coord0 = transformVector(pixelUnprojectionMatrix, [x2, y, 0, 1]);
  var coord1 = transformVector(pixelUnprojectionMatrix, [x2, y, 1, 1]);
  var z0 = coord0[2];
  var z1 = coord1[2];
  var t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return lerp3([], coord0, coord1, t);
}

// node_modules/viewport-mercator-project/dist/esm/viewport.js
var IDENTITY = createMat4();
var Viewport = function() {
  function Viewport4() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, width = _ref.width, height = _ref.height, _ref$viewMatrix = _ref.viewMatrix, viewMatrix = _ref$viewMatrix === void 0 ? IDENTITY : _ref$viewMatrix, _ref$projectionMatrix = _ref.projectionMatrix, projectionMatrix = _ref$projectionMatrix === void 0 ? IDENTITY : _ref$projectionMatrix;
    _classCallCheck(this, Viewport4);
    this.width = width || 1;
    this.height = height || 1;
    this.scale = 1;
    this.pixelsPerMeter = 1;
    this.viewMatrix = viewMatrix;
    this.projectionMatrix = projectionMatrix;
    var vpm = createMat4();
    multiply2(vpm, vpm, this.projectionMatrix);
    multiply2(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;
    var m = createMat4();
    scale2(m, m, [this.width / 2, -this.height / 2, 1]);
    translate(m, m, [1, -1, 0]);
    multiply2(m, m, this.viewProjectionMatrix);
    var mInverse = invert2(createMat4(), m);
    if (!mInverse) {
      throw new Error("Pixel project matrix not invertible");
    }
    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  _createClass(Viewport4, [{
    key: "equals",
    value: function equals6(viewport) {
      if (!(viewport instanceof Viewport4)) {
        return false;
      }
      return viewport.width === this.width && viewport.height === this.height && equals2(viewport.projectionMatrix, this.projectionMatrix) && equals2(viewport.viewMatrix, this.viewMatrix);
    }
  }, {
    key: "project",
    value: function project3(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$topLeft = _ref2.topLeft, topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft;
      var worldPosition = this.projectPosition(xyz);
      var coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
      var _coord = _slicedToArray(coord, 2), x2 = _coord[0], y = _coord[1];
      var y2 = topLeft ? y : this.height - y;
      return xyz.length === 2 ? [x2, y2] : [x2, y2, coord[2]];
    }
  }, {
    key: "unproject",
    value: function unproject(xyz) {
      var _ref3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref3$topLeft = _ref3.topLeft, topLeft = _ref3$topLeft === void 0 ? true : _ref3$topLeft, targetZ = _ref3.targetZ;
      var _xyz = _slicedToArray(xyz, 3), x2 = _xyz[0], y = _xyz[1], z = _xyz[2];
      var y2 = topLeft ? y : this.height - y;
      var targetZWorld = targetZ && targetZ * this.pixelsPerMeter;
      var coord = pixelsToWorld([x2, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
      var _this$unprojectPositi = this.unprojectPosition(coord), _this$unprojectPositi2 = _slicedToArray(_this$unprojectPositi, 3), X = _this$unprojectPositi2[0], Y = _this$unprojectPositi2[1], Z = _this$unprojectPositi2[2];
      if (Number.isFinite(z)) {
        return [X, Y, Z];
      }
      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
  }, {
    key: "projectPosition",
    value: function projectPosition(xyz) {
      var _this$projectFlat = this.projectFlat(xyz), _this$projectFlat2 = _slicedToArray(_this$projectFlat, 2), X = _this$projectFlat2[0], Y = _this$projectFlat2[1];
      var Z = (xyz[2] || 0) * this.pixelsPerMeter;
      return [X, Y, Z];
    }
  }, {
    key: "unprojectPosition",
    value: function unprojectPosition(xyz) {
      var _this$unprojectFlat = this.unprojectFlat(xyz), _this$unprojectFlat2 = _slicedToArray(_this$unprojectFlat, 2), X = _this$unprojectFlat2[0], Y = _this$unprojectFlat2[1];
      var Z = (xyz[2] || 0) / this.pixelsPerMeter;
      return [X, Y, Z];
    }
  }, {
    key: "projectFlat",
    value: function projectFlat(xyz) {
      var scale6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.scale;
      return xyz;
    }
  }, {
    key: "unprojectFlat",
    value: function unprojectFlat(xyz) {
      var scale6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.scale;
      return xyz;
    }
  }]);
  return Viewport4;
}();

// node_modules/viewport-mercator-project/dist/esm/fit-bounds.js
function fitBounds(_ref) {
  var width = _ref.width, height = _ref.height, bounds = _ref.bounds, _ref$minExtent = _ref.minExtent, minExtent = _ref$minExtent === void 0 ? 0 : _ref$minExtent, _ref$maxZoom = _ref.maxZoom, maxZoom = _ref$maxZoom === void 0 ? 24 : _ref$maxZoom, _ref$padding = _ref.padding, padding = _ref$padding === void 0 ? 0 : _ref$padding, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? [0, 0] : _ref$offset;
  var _bounds = _slicedToArray(bounds, 2), _bounds$ = _slicedToArray(_bounds[0], 2), west = _bounds$[0], south = _bounds$[1], _bounds$2 = _slicedToArray(_bounds[1], 2), east = _bounds$2[0], north = _bounds$2[1];
  if (Number.isFinite(padding)) {
    var p = padding;
    padding = {
      top: p,
      bottom: p,
      left: p,
      right: p
    };
  } else {
    assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
  }
  var viewport = new WebMercatorViewport({
    width,
    height,
    longitude: 0,
    latitude: 0,
    zoom: 0
  });
  var nw = viewport.project([west, north]);
  var se = viewport.project([east, south]);
  var size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];
  var targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
  assert(targetSize[0] > 0 && targetSize[1] > 0);
  var scaleX = targetSize[0] / size[0];
  var scaleY = targetSize[1] / size[1];
  var offsetX = (padding.right - padding.left) / 2 / scaleX;
  var offsetY = (padding.bottom - padding.top) / 2 / scaleY;
  var center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
  var centerLngLat = viewport.unproject(center);
  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));
  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom: Math.min(zoom, maxZoom)
  };
}

// node_modules/viewport-mercator-project/dist/esm/web-mercator-viewport.js
var WebMercatorViewport = function(_Viewport) {
  _inherits(WebMercatorViewport2, _Viewport);
  function WebMercatorViewport2() {
    var _this;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, width = _ref.width, height = _ref.height, _ref$latitude = _ref.latitude, latitude2 = _ref$latitude === void 0 ? 0 : _ref$latitude, _ref$longitude = _ref.longitude, longitude2 = _ref$longitude === void 0 ? 0 : _ref$longitude, _ref$zoom = _ref.zoom, zoom = _ref$zoom === void 0 ? 0 : _ref$zoom, _ref$pitch = _ref.pitch, pitch = _ref$pitch === void 0 ? 0 : _ref$pitch, _ref$bearing = _ref.bearing, bearing = _ref$bearing === void 0 ? 0 : _ref$bearing, _ref$altitude = _ref.altitude, altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude, nearZMultiplier = _ref.nearZMultiplier, farZMultiplier = _ref.farZMultiplier;
    _classCallCheck(this, WebMercatorViewport2);
    width = width || 1;
    height = height || 1;
    var scale6 = zoomToScale(zoom);
    altitude = Math.max(0.75, altitude);
    var center = lngLatToWorld([longitude2, latitude2], scale6);
    center[2] = 0;
    var projectionMatrix = getProjectionMatrix({
      width,
      height,
      pitch,
      bearing,
      altitude,
      nearZMultiplier: nearZMultiplier || 1 / height,
      farZMultiplier: farZMultiplier || 1.01
    });
    var viewMatrix = getViewMatrix({
      height,
      center,
      pitch,
      bearing,
      altitude,
      flipY: true
    });
    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebMercatorViewport2).call(this, {
      width,
      height,
      viewMatrix,
      projectionMatrix
    }));
    _this.latitude = latitude2;
    _this.longitude = longitude2;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;
    _this.scale = scale6;
    _this.center = center;
    _this.pixelsPerMeter = getDistanceScales2(_assertThisInitialized(_assertThisInitialized(_this))).pixelsPerMeter[2];
    Object.freeze(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }
  _createClass(WebMercatorViewport2, [{
    key: "projectFlat",
    value: function projectFlat(lngLat) {
      var scale6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.scale;
      return lngLatToWorld(lngLat, scale6);
    }
  }, {
    key: "unprojectFlat",
    value: function unprojectFlat(xy) {
      var scale6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.scale;
      return worldToLngLat(xy, scale6);
    }
  }, {
    key: "getMapCenterByLngLatPosition",
    value: function getMapCenterByLngLatPosition(_ref2) {
      var lngLat = _ref2.lngLat, pos = _ref2.pos;
      var fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);
      var toLocation = lngLatToWorld(lngLat, this.scale);
      var translate2 = add5([], toLocation, negate3([], fromLocation));
      var newCenter = add5([], this.center, translate2);
      return worldToLngLat(newCenter, this.scale);
    }
  }, {
    key: "getLocationAtPoint",
    value: function getLocationAtPoint(_ref3) {
      var lngLat = _ref3.lngLat, pos = _ref3.pos;
      return this.getMapCenterByLngLatPosition({
        lngLat,
        pos
      });
    }
  }, {
    key: "fitBounds",
    value: function fitBounds2(bounds) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var width = this.width, height = this.height;
      var _fitBounds2 = fitBounds(Object.assign({
        width,
        height,
        bounds
      }, options)), longitude2 = _fitBounds2.longitude, latitude2 = _fitBounds2.latitude, zoom = _fitBounds2.zoom;
      return new WebMercatorViewport2({
        width,
        height,
        longitude: longitude2,
        latitude: latitude2,
        zoom
      });
    }
  }]);
  return WebMercatorViewport2;
}(Viewport);

// node_modules/@antv/l7-maps/es/lib/web-mercator-viewport.js
var Viewport2 = class {
  constructor() {
    _defineProperty(this, "viewport", new WebMercatorViewport());
  }
  syncWithMapCamera(mapCamera) {
    const {
      center,
      zoom,
      pitch,
      bearing,
      viewportHeight,
      viewportWidth
    } = mapCamera;
    const preView = {
      width: this.viewport.width,
      height: this.viewport.height,
      longitude: this.viewport.center[0],
      latitude: this.viewport.center[1],
      zoom: this.viewport.zoom,
      pitch: this.viewport.pitch,
      bearing: this.viewport.bearing
    };
    this.viewport = new WebMercatorViewport(_objectSpread2(_objectSpread2({}, preView), {}, {
      width: viewportWidth,
      height: viewportHeight,
      longitude: center && center[0],
      latitude: center && center[1],
      zoom,
      pitch,
      bearing
    }));
  }
  getZoom() {
    return this.viewport.zoom;
  }
  getZoomScale() {
    return Math.pow(2, this.getZoom());
  }
  getCenter() {
    return [this.viewport.longitude, this.viewport.latitude];
  }
  getProjectionMatrix() {
    return this.viewport.projectionMatrix;
  }
  getModelMatrix() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  getViewMatrix() {
    return this.viewport.viewMatrix;
  }
  getViewMatrixUncentered() {
    return this.viewport.viewMatrixUncentered;
  }
  getViewProjectionMatrix() {
    return this.viewport.viewProjectionMatrix;
  }
  getViewProjectionMatrixUncentered() {
    return this.viewport.viewProjectionMatrix;
  }
  getFocalDistance() {
    return 1;
  }
  projectFlat(lngLat, scale6) {
    return this.viewport.projectFlat(lngLat, scale6);
  }
};

// node_modules/@antv/l7-maps/es/types.js
var MapType = function(MapType2) {
  MapType2["GAODE"] = "GAODE";
  MapType2["MAPBOX"] = "MAPBOX";
  MapType2["DEFAULT"] = "DEFAUlTMAP";
  MapType2["SIMPLE"] = "SIMPLE";
  MapType2["GLOBEL"] = "GLOBEL";
  return MapType2;
}({});

// node_modules/@antv/l7-maps/es/utils/utils.js
function toPaddingOptions(padding = {}) {
  const defaultPadding = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  if (typeof padding === "number") {
    return {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  if (Array.isArray(padding)) {
    if (padding.length === 4) {
      return {
        top: padding[0],
        right: padding[1],
        bottom: padding[2],
        left: padding[3]
      };
    }
    if (padding.length === 2) {
      return {
        top: padding[0],
        right: padding[1],
        bottom: padding[0],
        left: padding[1]
      };
    }
  }
  return _objectSpread2(_objectSpread2({}, defaultPadding), padding);
}

// node_modules/@antv/l7-maps/es/amap-next/theme.js
var MapTheme = {
  normal: "amap://styles/normal",
  light: "amap://styles/c422f5c0cfced5be9fe3a83f05f28a68?isPublic=true",
  dark: "amap://styles/c9f1d10cae34f8ab05e425462c5a58d7?isPublic=true",
  blank: "amap://styles/07c17002b38775b32a7a76c66cf90e99?isPublic=true",
  fresh: "amap://styles/fresh",
  grey: "amap://styles/grey",
  graffiti: "amap://styles/graffiti",
  macaron: "amap://styles/macaron",
  darkblue: "amap://styles/darkblue",
  wine: "amap://styles/wine"
};

// node_modules/@antv/l7-maps/es/amap-next/map.js
var _excluded3 = ["id", "style", "minZoom", "maxZoom", "token", "mapInstance", "plugin"];
function loadStyles(css, doc) {
  var isMiniAli = typeof my !== "undefined" && !!my && typeof my.showToast === "function" && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== "undefined" && wx !== null && (typeof wx.request !== "undefined" || typeof wx.miniProgram !== "undefined");
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc)
    doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName("head")[0];
  if (!head) {
    head = doc.createElement("head");
    var body = doc.body || doc.getElementsByTagName("body")[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement("style");
  style.type = "text/css";
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles(`.amap-logo {
  display: none !important;
}
.amap-copyright {
  display: none !important;
}
.amap-overlays {
  z-index: 3 !important;
}
`);
var AMAP_VERSION = "2.0";
var AMAP_API_KEY = "f59bcf249433f8b05caaee19f349b3d7";
var ZOOM_OFFSET = 1;
var AMapEventMapV2 = {
  contextmenu: "rightclick",
  camerachange: "viewchange"
};
var BMapService = class extends BaseMap {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "viewport", new Viewport2());
    _defineProperty(this, "version", MapType.GAODE);
    _defineProperty(this, "handleCameraChanged", () => {
      const option = this.getViewState();
      this.updateView(option);
    });
  }
  getType() {
    return "amap";
  }
  init() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const _this$config = _this.config, {
        id: id2,
        style = "light",
        minZoom = 0,
        maxZoom = 24,
        token = AMAP_API_KEY,
        mapInstance,
        plugin = []
      } = _this$config, rest = _objectWithoutProperties(_this$config, _excluded3);
      if (!(window.AMap || mapInstance)) {
        plugin.push("Map3D");
        yield import_amap_jsapi_loader.default.load({
          key: token,
          // 申请好的Web端开发者Key，首次调用 load 时必填
          version: AMAP_VERSION,
          // 指定要加载的 JSAPI 的版本
          plugins: plugin
          // 需要使用的的插件列表，如比例尺'AMap.Scale'等
        });
      }
      if (mapInstance) {
        _this.map = mapInstance;
        _this.mapContainer = _this.map.getContainer();
        _this.map.on("viewchange", _this.handleCameraChanged);
      } else {
        const mapConstructorOptions = _objectSpread2({
          mapStyle: _this.getMapStyleValue(style),
          // 默认取值范围 [2, 20]
          zooms: [minZoom, maxZoom],
          viewMode: "3D"
        }, rest);
        if (mapConstructorOptions.zoom) {
          mapConstructorOptions.zoom += ZOOM_OFFSET;
        }
        if (token === AMAP_API_KEY) {
          window._AMapSecurityConfig = {
            securityJsCode: "2653011adeb04230b3a26cc9a780a800"
          };
          console.warn(`%c${_this.configService.getSceneWarninfo("MapToken")}!`, "color: #873bf4;font-weigh:900;font-size: 16px;");
        }
        if (!id2) {
          throw Error("No container id specified");
        }
        window.forceWebGL = true;
        _this.mapContainer = _this.creatMapContainer(id2);
        const map = new AMap.Map(_this.mapContainer, mapConstructorOptions);
        _this.map = map;
        map.on("viewchange", _this.handleCameraChanged);
      }
      _this.syncInitViewPort();
    })();
  }
  syncInitViewPort() {
    const option = this.getViewState();
    this.updateView(option);
  }
  getViewState() {
    const {
      center,
      zoom
    } = getMapHighPrecisionState(this.map);
    const option = {
      center,
      viewportWidth: this.map.getContainer().clientWidth,
      viewportHeight: this.map.getContainer().clientHeight,
      bearing: -this.map.getRotation(),
      pitch: this.map.getPitch(),
      zoom: zoom - ZOOM_OFFSET
    };
    return option;
  }
  creatMapContainer(id2) {
    const wrapper = super.creatMapContainer(id2);
    const amapdiv = document.createElement("div");
    amapdiv.style.cssText += `
       position: absolute;
       top: 0;
       height: 100%;
       width: 100%;
     `;
    amapdiv.id = lodashUtil.uniqueId("l7_amap_div");
    wrapper.appendChild(amapdiv);
    return amapdiv;
  }
  getContainer() {
    return this.map.getContainer();
  }
  addMarkerContainer() {
    if (!this.map)
      return;
    const mapContainer = this.map.getContainer();
    if (mapContainer !== null) {
      const amap = mapContainer.getElementsByClassName("amap-maps")[0];
      amap.style.zIndex = "auto";
      this.markerContainer = dom_exports.create("div", "l7-marker-container2", amap);
    }
  }
  getMarkerContainer() {
    return this.markerContainer;
  }
  getCanvasOverlays() {
    var _this$mapContainer;
    return (_this$mapContainer = this.mapContainer) === null || _this$mapContainer === void 0 ? void 0 : _this$mapContainer.querySelector(".amap-overlays");
  }
  // MapEvent // 定义事件类型
  on(type, handler) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.on(type, handler);
    } else {
      this.map.on(AMapEventMapV2[type] || type, handler);
    }
  }
  off(type, handler) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.off(type, handler);
    } else {
      this.map.off(AMapEventMapV2[type] || type, handler);
    }
  }
  getSize() {
    const size = this.map.getSize();
    return [size.getWidth(), size.getHeight()];
  }
  getMinZoom() {
    const zooms = this.map.getZooms();
    return zooms[0] - ZOOM_OFFSET;
  }
  getMaxZoom() {
    const zooms = this.map.getZooms();
    return zooms[1] - ZOOM_OFFSET;
  }
  getZoom() {
    return this.map.getZoom() - ZOOM_OFFSET;
  }
  getCenter(options) {
    if (options !== null && options !== void 0 && options.padding) {
      const originCenter = this.getCenter();
      const padding = toPaddingOptions(options.padding);
      const px = this.lngLatToPixel([originCenter.lng, originCenter.lat]);
      const offsetPx = [(padding.right - padding.left) / 2, (padding.bottom - padding.top) / 2];
      const newCenter = this.pixelToLngLat([px.x - offsetPx[0], px.y - offsetPx[1]]);
      return newCenter;
    }
    const center = this.map.getCenter();
    return {
      lng: center.getLng(),
      lat: center.getLat()
    };
  }
  getPitch() {
    return this.map.getPitch();
  }
  getRotation() {
    return 360 - this.map.getRotation();
  }
  getBounds() {
    const bounds = this.map.getBounds();
    const NE = bounds.getNorthEast();
    const SW = bounds.getSouthWest();
    const center = this.getCenter();
    const maxlng = center.lng > NE.getLng() || center.lng < SW.getLng() ? 180 - NE.getLng() : NE.getLng();
    const minlng = center.lng < SW.getLng() ? SW.getLng() - 180 : SW.getLng();
    return [[minlng, SW.getLat()], [maxlng, NE.getLat()]];
  }
  getMapContainer() {
    return this.mapContainer;
  }
  getMapCanvasContainer() {
    var _this$map$getContaine;
    return (_this$map$getContaine = this.map.getContainer()) === null || _this$map$getContaine === void 0 ? void 0 : _this$map$getContaine.getElementsByClassName("amap-maps")[0];
  }
  getMapStyleConfig() {
    return MapTheme;
  }
  getMapStyleValue(name) {
    return this.getMapStyleConfig()[name] || name;
  }
  getMapStyle() {
    return this.map.getMapStyle();
  }
  setMapStyle(style) {
    this.map.setMapStyle(this.getMapStyleValue(style));
  }
  setRotation(rotation) {
    return this.map.setRotation(rotation);
  }
  zoomIn() {
    this.map.zoomIn();
  }
  zoomOut() {
    this.map.zoomOut();
  }
  panTo(p) {
    this.map.panTo(p);
  }
  panBy(x2 = 0, y = 0) {
    this.map.panBy(x2, y);
  }
  fitBounds(extent2) {
    this.map.setBounds(
      new AMap.Bounds([extent2[0][0], extent2[0][1], extent2[1][0], extent2[1][1]]),
      // @ts-expect-error 立即缩放到指定位置
      true
    );
  }
  setZoomAndCenter(zoom, center) {
    this.map.setZoomAndCenter(zoom + ZOOM_OFFSET, center);
  }
  setCenter(lnglat, options) {
    if (options !== null && options !== void 0 && options.padding) {
      const padding = toPaddingOptions(options.padding);
      const px = this.lngLatToPixel(lnglat);
      const offsetPx = [(padding.right - padding.left) / 2, (padding.bottom - padding.top) / 2];
      const newCenter = this.pixelToLngLat([px.x + offsetPx[0], px.y + offsetPx[1]]);
      this.map.setCenter([newCenter.lng, newCenter.lat]);
    } else {
      this.map.setCenter(lnglat);
    }
  }
  setPitch(pitch) {
    return this.map.setPitch(pitch);
  }
  setZoom(zoom) {
    return this.map.setZoom(zoom + ZOOM_OFFSET);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setMaxZoom(max6) {
    throw new Error("Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setMinZoom(min5) {
    throw new Error("Method not implemented.");
  }
  setMapStatus(option) {
    this.map.setStatus(option);
  }
  meterToCoord(center, outer) {
    const meterDis = AMap.GeometryUtil.distance(new AMap.LngLat(...center), new AMap.LngLat(...outer));
    const [x1, y1] = amap2Project(...center);
    const [x2, y2] = amap2Project(...outer);
    const coordDis = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    return coordDis / meterDis;
  }
  pixelToLngLat(pixel) {
    const lngLat = this.map.pixelToLngLat(new AMap.Pixel(pixel[0], pixel[1]));
    return {
      lng: lngLat.getLng(),
      lat: lngLat.getLat()
    };
  }
  lngLatToPixel(lnglat) {
    const p = this.map.lnglatToPixel(lnglat);
    return {
      x: p.getX(),
      y: p.getY()
    };
  }
  containerToLngLat(pixel) {
    const ll = new AMap.Pixel(pixel[0], pixel[1]);
    const lngLat = this.map.containerToLngLat(ll);
    return {
      lng: lngLat === null || lngLat === void 0 ? void 0 : lngLat.getLng(),
      lat: lngLat === null || lngLat === void 0 ? void 0 : lngLat.getLat()
    };
  }
  lngLatToContainer(lnglat) {
    const pixel = this.map.lngLatToContainer(lnglat);
    return {
      x: pixel.getX(),
      y: pixel.getY()
    };
  }
  /**
   * 将经纬度转成墨卡托坐标
   */
  lngLatToMercator([lng, lat], altitude) {
    const [x2, y] = amap2Project(lng, lat);
    return {
      x: x2,
      y,
      z: altitude
    };
  }
  getModelMatrix(lnglat, altitude, rotate5, scale6 = [1, 1, 1]) {
    const flat = this.viewport.projectFlat(lnglat);
    const modelMatrix = mat4_exports.create();
    mat4_exports.translate(modelMatrix, modelMatrix, vec3_exports.fromValues(flat[0], flat[1], altitude));
    mat4_exports.scale(modelMatrix, modelMatrix, vec3_exports.fromValues(scale6[0], scale6[1], scale6[2]));
    mat4_exports.rotateX(modelMatrix, modelMatrix, rotate5[0]);
    mat4_exports.rotateY(modelMatrix, modelMatrix, rotate5[1]);
    mat4_exports.rotateZ(modelMatrix, modelMatrix, rotate5[2]);
    return modelMatrix;
  }
  exportMap(type) {
    var _this$getContainer;
    const renderCanvas = (_this$getContainer = this.getContainer()) === null || _this$getContainer === void 0 ? void 0 : _this$getContainer.getElementsByClassName("amap-layer")[0];
    const layersPng = type === "jpg" ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/jpeg") : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/png");
    return layersPng;
  }
  destroy() {
    var _this$mapContainer2;
    super.destroy();
    (_this$mapContainer2 = this.mapContainer) === null || _this$mapContainer2 === void 0 || (_this$mapContainer2 = _this$mapContainer2.parentNode) === null || _this$mapContainer2 === void 0 || _this$mapContainer2.removeChild(this.mapContainer);
    delete window.initAMap;
    const $jsapi = document.getElementById("amap-script");
    if ($jsapi) {
      document.head.removeChild($jsapi);
    }
    this.map.destroy();
  }
};
function getMapHighPrecisionState(map) {
  const viewStatus = map._view.getOptions();
  const center = viewStatus.center;
  const zoom = viewStatus.zoom;
  return {
    center,
    zoom
  };
}

// node_modules/@antv/l7-maps/es/amap-next/index.js
var AMap2Wrapper = class extends BaseMapWrapper {
  getServiceConstructor() {
    return BMapService;
  }
};

// node_modules/@antv/l7-maps/es/utils/BaseMapService.js
var import_eventemitter310 = __toESM(require_eventemitter3());

// node_modules/@antv/l7-maps/es/utils/theme.js
var MapTheme2 = {
  light: "mapbox://styles/zcxduo/ck2ypyb1r3q9o1co1766dex29",
  dark: "mapbox://styles/zcxduo/ck241p6413s0b1cpayzldv7x7",
  normal: "mapbox://styles/mapbox/streets-v11",
  blank: {
    version: 8,
    // sprite: 'https://lzxue.github.io/font-glyphs/sprite/sprite',
    // glyphs:
    //   'https://gw.alipayobjects.com/os/antvdemo/assets/mapbox/glyphs/{fontstack}/{range}.pbf',
    sources: {},
    layers: [{
      id: "background",
      type: "background",
      layout: {
        visibility: "none"
      }
    }]
  }
};

// node_modules/@antv/l7-maps/es/utils/BaseMapService.js
var EventMap = {
  mapmove: "move",
  camerachange: "move",
  zoomchange: "zoom",
  dragging: "drag"
};
var LNGLAT_OFFSET_ZOOM_THRESHOLD2 = 12;
var BaseMapService = class {
  constructor(container) {
    _defineProperty(this, "version", "DEFAUlTMAP");
    _defineProperty(this, "map", void 0);
    _defineProperty(this, "simpleMapCoord", new SimpleMapCoord());
    _defineProperty(this, "bgColor", "rgba(0.0, 0.0, 0.0, 0.0)");
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "configService", void 0);
    _defineProperty(this, "coordinateSystemService", void 0);
    _defineProperty(this, "eventEmitter", void 0);
    _defineProperty(this, "markerContainer", void 0);
    _defineProperty(this, "cameraChangedCallback", void 0);
    _defineProperty(this, "$mapContainer", void 0);
    _defineProperty(this, "handleCameraChanged", (e) => {
      const {
        lat,
        lng
      } = this.map.getCenter();
      this.emit("mapchange");
      this.viewport.syncWithMapCamera({
        bearing: this.map.getBearing(),
        center: [lng, lat],
        viewportHeight: this.map.transform.height,
        pitch: this.map.getPitch(),
        viewportWidth: this.map.transform.width,
        zoom: this.map.getZoom(),
        // mapbox 中固定相机高度为 viewport 高度的 1.5 倍
        cameraHeight: 0
      });
      this.updateCoordinateSystemService();
      this.cameraChangedCallback(this.viewport);
    });
    this.config = container.mapConfig;
    this.configService = container.globalConfigService;
    this.coordinateSystemService = container.coordinateSystemService;
    this.eventEmitter = new import_eventemitter310.EventEmitter();
  }
  setBgColor(color2) {
    this.bgColor = color2;
  }
  // init
  addMarkerContainer() {
    const container = this.map.getCanvasContainer();
    this.markerContainer = dom_exports.create("div", "l7-marker-container", container);
    this.markerContainer.setAttribute("tabindex", "-1");
  }
  getMarkerContainer() {
    return this.markerContainer;
  }
  getOverlayContainer() {
    return void 0;
  }
  getCanvasOverlays() {
    return void 0;
  }
  //  map event
  on(type, handle) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.on(type, handle);
    } else {
      this.map.on(EventMap[type] || type, handle);
    }
  }
  off(type, handle) {
    this.map.off(EventMap[type] || type, handle);
    this.eventEmitter.off(type, handle);
  }
  getContainer() {
    return this.map.getContainer();
  }
  getMapCanvasContainer() {
    return this.map.getCanvasContainer();
  }
  getSize() {
    if (this.version === "SIMPLE") {
      return this.simpleMapCoord.getSize();
    }
    const size = this.map.transform;
    return [size.width, size.height];
  }
  // get mapStatus method
  getType() {
    return "default";
  }
  getZoom() {
    return this.map.getZoom();
  }
  setZoom(zoom) {
    return this.map.setZoom(zoom);
  }
  getCenter() {
    return this.map.getCenter();
  }
  setCenter(lnglat) {
    this.map.setCenter(lnglat);
  }
  getPitch() {
    return this.map.getPitch();
  }
  getRotation() {
    return this.map.getBearing();
  }
  getBounds() {
    return this.map.getBounds().toArray();
  }
  getMinZoom() {
    return this.map.getMinZoom();
  }
  getMaxZoom() {
    return this.map.getMaxZoom();
  }
  setRotation(rotation) {
    this.map.setBearing(rotation);
  }
  zoomIn(option, eventData) {
    this.map.zoomIn(option, eventData);
  }
  zoomOut(option, eventData) {
    this.map.zoomOut(option, eventData);
  }
  setPitch(pitch) {
    return this.map.setPitch(pitch);
  }
  panTo(p) {
    this.map.panTo(p);
  }
  panBy(x2 = 0, y = 0) {
    this.map.panBy([x2, y]);
  }
  fitBounds(bound, fitBoundsOptions) {
    this.map.fitBounds(bound, fitBoundsOptions);
  }
  setMaxZoom(max6) {
    this.map.setMaxZoom(max6);
  }
  setMinZoom(min5) {
    this.map.setMinZoom(min5);
  }
  setMapStatus(option) {
    if (option.doubleClickZoom === true) {
      this.map.doubleClickZoom.enable();
    }
    if (option.doubleClickZoom === false) {
      this.map.doubleClickZoom.disable();
    }
    if (option.dragEnable === false) {
      this.map.dragPan.disable();
    }
    if (option.dragEnable === true) {
      this.map.dragPan.enable();
    }
    if (option.rotateEnable === false) {
      this.map.dragRotate.disable();
    }
    if (option.dragEnable === true) {
      this.map.dragRotate.enable();
    }
    if (option.keyboardEnable === false) {
      this.map.keyboard.disable();
    }
    if (option.keyboardEnable === true) {
      this.map.keyboard.enable();
    }
    if (option.zoomEnable === false) {
      this.map.scrollZoom.disable();
    }
    if (option.zoomEnable === true) {
      this.map.scrollZoom.enable();
    }
  }
  setZoomAndCenter(zoom, center) {
    this.map.flyTo({
      zoom,
      center
    });
  }
  setMapStyle(style) {
    var _this$map;
    (_this$map = this.map) === null || _this$map === void 0 || _this$map.setStyle(this.getMapStyleValue(style));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  meterToCoord(center, outer) {
    return 1;
  }
  // TODO: 计算像素坐标
  pixelToLngLat(pixel) {
    return this.map.unproject(pixel);
  }
  lngLatToPixel(lnglat) {
    return this.map.project(lnglat);
  }
  containerToLngLat(pixel) {
    return this.map.unproject(pixel);
  }
  lngLatToContainer(lnglat) {
    return this.map.project(lnglat);
  }
  getMapStyle() {
    try {
      var _this$map$getStyle$sp;
      const styleUrl = (_this$map$getStyle$sp = this.map.getStyle().sprite) !== null && _this$map$getStyle$sp !== void 0 ? _this$map$getStyle$sp : "";
      if (/^mapbox:\/\/sprites\/zcxduo\/\w+\/\w+$/.test(styleUrl)) {
        return styleUrl === null || styleUrl === void 0 ? void 0 : styleUrl.replace(/\/\w+$/, "").replace(/sprites/, "styles");
      }
      return styleUrl;
    } catch (e) {
      return "";
    }
  }
  getMapStyleConfig() {
    return MapTheme2;
  }
  getMapStyleValue(name) {
    var _this$getMapStyleConf;
    return (_this$getMapStyleConf = this.getMapStyleConfig()[name]) !== null && _this$getMapStyleConf !== void 0 ? _this$getMapStyleConf : name;
  }
  destroy() {
    this.eventEmitter.removeAllListeners();
    if (this.map) {
      this.map.remove();
      this.$mapContainer = null;
    }
  }
  emit(name, ...args) {
    this.eventEmitter.emit(name, ...args);
  }
  once(name, ...args) {
    this.eventEmitter.once(name, ...args);
  }
  getMapContainer() {
    return this.$mapContainer;
  }
  exportMap(type) {
    var _this$map2;
    const renderCanvas = (_this$map2 = this.map) === null || _this$map2 === void 0 ? void 0 : _this$map2.getCanvas();
    const layersPng = type === "jpg" ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/jpeg") : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/png");
    return layersPng;
  }
  onCameraChanged(callback) {
    this.cameraChangedCallback = callback;
  }
  creatMapContainer(id2) {
    let $wrapper = id2;
    if (typeof id2 === "string") {
      $wrapper = document.getElementById(id2);
    }
    return $wrapper;
  }
  updateView(viewOption) {
    this.emit("mapchange");
    this.viewport.syncWithMapCamera({
      bearing: viewOption.bearing,
      center: viewOption.center,
      viewportHeight: viewOption.viewportHeight,
      pitch: viewOption.pitch,
      viewportWidth: viewOption.viewportWidth,
      zoom: viewOption.zoom,
      // mapbox 中固定相机高度为 viewport 高度的 1.5 倍
      cameraHeight: 0
    });
    this.updateCoordinateSystemService();
    this.cameraChangedCallback(this.viewport);
  }
  updateCoordinateSystemService() {
    const {
      offsetCoordinate = true
    } = this.config;
    if (this.viewport.getZoom() > LNGLAT_OFFSET_ZOOM_THRESHOLD2 && offsetCoordinate) {
      this.coordinateSystemService.setCoordinateSystem(CoordinateSystem.LNGLAT_OFFSET);
    } else {
      this.coordinateSystemService.setCoordinateSystem(CoordinateSystem.LNGLAT);
    }
  }
};

// node_modules/@antv/l7-maps/es/bmap/bmapglloader.js
if (!window) {
  throw Error("BMapGL JSAPI can only be used in Browser.");
}
var LoadStatus = function(LoadStatus4) {
  LoadStatus4["notload"] = "notload";
  LoadStatus4["loading"] = "loading";
  LoadStatus4["loaded"] = "loaded";
  LoadStatus4["failed"] = "failed";
  return LoadStatus4;
}(LoadStatus || {});
var config = {
  key: "",
  BMapGL: {
    version: "1.0"
  }
};
var Status = {
  BMapGL: LoadStatus.notload
};
var onloadCBKs = [];
var onload = (callback) => {
  if (typeof callback === "function") {
    if (Status.BMapGL === LoadStatus.loaded) {
      callback(window.BMapGL);
      return;
    }
    onloadCBKs.push(callback);
  }
};
var load = (options) => {
  return new Promise((resolve, reject) => {
    if (Status.BMapGL === LoadStatus.failed) {
      reject("");
    } else if (Status.BMapGL === LoadStatus.notload) {
      const {
        key,
        version
      } = options;
      if (!key) {
        reject("请填写key");
        return;
      }
      config.key = key;
      config.BMapGL.version = version || config.BMapGL.version;
      Status.BMapGL = LoadStatus.loading;
      const parentNode = document.body || document.head;
      window.___onBMapGLAPILoaded = (err2) => {
        delete window.___onBMapGLAPILoaded;
        if (err2) {
          Status.BMapGL = LoadStatus.failed;
          reject(err2);
        } else {
          Status.BMapGL = LoadStatus.loaded;
          while (onloadCBKs.length) {
            onloadCBKs.splice(0, 1)[0](window.BMapGL);
          }
        }
      };
      const script = document.createElement("script");
      script.type = "text/javascript";
      script.src = `https://api.map.baidu.com/api?type=webgl&v=${config.BMapGL.version}&ak=${config.key}&callback=___onBMapGLAPILoaded`;
      script.onerror = (e) => {
        Status.BMapGL = LoadStatus.failed;
        reject(e);
      };
      parentNode.appendChild(script);
      onload(resolve);
    } else if (Status.BMapGL === LoadStatus.loaded) {
      if (options.key && options.key !== config.key) {
        reject("多个不一致的 key");
        return;
      }
      if (options.version && options.version !== config.BMapGL.version) {
        reject("不允许多个版本 JSAPI 混用");
        return;
      }
      resolve(window.BMapGL);
    } else {
      if (options.key && options.key !== config.key) {
        reject("多个不一致的 key");
        return;
      }
      if (options.version && options.version !== config.BMapGL.version) {
        reject("不允许多个版本 JSAPI 混用");
        return;
      }
      onload(resolve);
    }
  });
};
var reset = () => {
  delete window.BMapGL;
  config = {
    key: "",
    BMapGL: {
      version: "1.0"
    }
  };
  Status = {
    BMapGL: LoadStatus.notload
  };
};
var bmapglloader_default = {
  load,
  reset
};

// node_modules/@antv/l7-maps/es/bmap/map.js
var _excluded4 = ["id", "center", "zoom", "token", "mapInstance", "version", "mapSize", "minZoom", "maxZoom"];
function loadStyles2(css, doc) {
  var isMiniAli = typeof my !== "undefined" && !!my && typeof my.showToast === "function" && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== "undefined" && wx !== null && (typeof wx.request !== "undefined" || typeof wx.miniProgram !== "undefined");
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc)
    doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName("head")[0];
  if (!head) {
    head = doc.createElement("head");
    var body = doc.body || doc.getElementsByTagName("body")[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement("style");
  style.type = "text/css";
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles2(`.BMap_cpyCtrl .anchorBL {
  display: none !important;
}

.anchorBL {
  display: none !important;
}
`);
var EventMap2 = {
  mapmove: "moving",
  contextmenu: "rightclick",
  camerachange: "update",
  zoomchange: "zoomend"
};
var BMAP_API_KEY = "zLhopYPPERGtpGOgimcdKcCimGRyyIsh";
var BMAP_VERSION = "1.0";
var BMapService2 = class extends BaseMapService {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "viewport", void 0);
    _defineProperty(this, "styleConfig", {
      normal: []
    });
    _defineProperty(this, "currentStyle", "normal");
    _defineProperty(this, "evtCbProxyMap", /* @__PURE__ */ new Map());
    _defineProperty(this, "handleCameraChanged", () => {
      this.emit("mapchange");
      const map = this.getMap();
      const {
        lng,
        lat
      } = map.getCenter();
      const option = {
        center: [lng, lat],
        viewportHeight: map.getContainer().clientHeight,
        viewportWidth: map.getContainer().clientWidth,
        bearing: 360 - map.getHeading(),
        pitch: map.getTilt(),
        zoom: map.getZoom() - 1.75
      };
      this.viewport.syncWithMapCamera(option);
      this.updateCoordinateSystemService();
      this.cameraChangedCallback(this.viewport);
    });
  }
  getMap() {
    return this.map;
  }
  setBgColor(color2) {
    this.bgColor = color2;
  }
  init() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.viewport = new Viewport2();
      const _this$config = _this.config, {
        id: id2,
        center = [121.30654632240122, 31.25744185633306],
        zoom = 12,
        token = BMAP_API_KEY,
        mapInstance,
        version = BMAP_VERSION,
        mapSize = 1e4,
        minZoom = 0,
        maxZoom = 21
      } = _this$config, rest = _objectWithoutProperties(_this$config, _excluded4);
      _this.viewport = new Viewport2();
      _this.version = version;
      _this.simpleMapCoord.setSize(mapSize);
      if (!(window.BMapGL || mapInstance)) {
        yield bmapglloader_default.load({
          key: token,
          // 申请好的Web端开发者Key，首次调用 load 时必填
          version: BMAP_VERSION
          // 指定要加载的 JSAPI 的gl版本，缺省时默认为 1.0
        });
      }
      if (mapInstance) {
        _this.map = mapInstance;
        _this.$mapContainer = _this.map.getContainer();
        const point2 = new BMapGL.Point(center[0], center[1]);
        if (!_this.map.isLoaded()) {
          _this.map.centerAndZoom(point2, zoom);
        }
        _this.initMapByConfig(_this.config);
        _this.map.on("update", _this.handleCameraChanged);
      } else {
        const mapConstructorOptions = _objectSpread2({
          enableWheelZoom: true,
          minZoom,
          maxZoom
        }, rest);
        if (token === BMAP_API_KEY) {
          console.warn(`%c${_this.configService.getSceneWarninfo("MapToken")}!`, "color: #873bf4;font-weigh:900;font-size: 16px;");
        }
        if (!id2) {
          throw Error("No container id specified");
        }
        const mapContainer = dom_exports.getContainer(id2);
        let mapChildNodes = [...mapContainer.childNodes];
        const map = new BMapGL.Map(mapContainer, mapConstructorOptions);
        _this.$mapContainer = map.getContainer();
        mapChildNodes.forEach((child) => {
          _this.$mapContainer.appendChild(child);
        });
        mapChildNodes = null;
        _this.map = map;
        const point2 = new BMapGL.Point(center[0], center[1]);
        _this.map.centerAndZoom(point2, zoom);
        _this.initMapByConfig(_this.config);
        map.on("update", _this.handleCameraChanged);
      }
    })();
  }
  destroy() {
    this.getMap().destroy();
  }
  onCameraChanged(callback) {
    this.cameraChangedCallback = callback;
  }
  // tslint:disable-next-line:no-empty
  addMarkerContainer() {
  }
  getMarkerContainer() {
    return this.map.getPanes().markerPane;
  }
  getCanvasOverlays() {
    var _this$getMap$getConta;
    return (_this$getMap$getConta = this.getMap().getContainer().querySelector("#platform")) === null || _this$getMap$getConta === void 0 ? void 0 : _this$getMap$getConta.lastChild;
  }
  // MapEvent // 定义事件类型
  on(type, handle) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.on(type, handle);
      return;
    }
    let cbProxyMap = this.evtCbProxyMap.get(type);
    if (!cbProxyMap) {
      this.evtCbProxyMap.set(type, cbProxyMap = /* @__PURE__ */ new Map());
    }
    if (cbProxyMap.get(handle)) {
      return;
    }
    const handleProxy = (...args) => {
      if (args[0] && typeof args[0] === "object" && !args[0].lngLat && !args[0].lnglat) {
        args[0].lngLat = args[0].latlng || args[0].latLng;
      }
      handle(...args);
    };
    cbProxyMap.set(handle, handleProxy);
    this.map.on(EventMap2[type] || type, handleProxy);
  }
  off(type, handle) {
    var _this$evtCbProxyMap$g, _this$evtCbProxyMap$g2;
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.off(type, handle);
      return;
    }
    const handleProxy = (_this$evtCbProxyMap$g = this.evtCbProxyMap.get(type)) === null || _this$evtCbProxyMap$g === void 0 ? void 0 : _this$evtCbProxyMap$g.get(handle);
    if (!handleProxy) {
      return;
    }
    (_this$evtCbProxyMap$g2 = this.evtCbProxyMap.get(type)) === null || _this$evtCbProxyMap$g2 === void 0 || _this$evtCbProxyMap$g2.delete(handle);
    this.map.off(EventMap2[type] || type, handleProxy);
  }
  once(type, handler) {
    this.eventEmitter.once(type, handler);
  }
  getContainer() {
    return this.getMap().getContainer();
  }
  getSize() {
    const size = this.getMap().getSize();
    return [size.width, size.height];
  }
  // 百度地图缩放等级
  getMinZoom() {
    return this.map.getMinZoom();
  }
  getMaxZoom() {
    return this.map.getMaxZoom();
  }
  // get map params
  getType() {
    return "bmap";
  }
  getZoom() {
    return this.getMap().getZoom();
  }
  getCenter(options) {
    if (options !== null && options !== void 0 && options.padding) {
      const originCenter = this.getCenter();
      const padding = toPaddingOptions(options.padding);
      const px = this.lngLatToPixel([originCenter.lng, originCenter.lat]);
      const offsetPx = [(padding.right - padding.left) / 2, (padding.bottom - padding.top) / 2];
      const newCenter = this.pixelToLngLat([px.x - offsetPx[0], px.y - offsetPx[1]]);
      return newCenter;
    }
    const center = this.map.getCenter();
    return {
      lng: center.lng,
      lat: center.lat
    };
  }
  getPitch() {
    return this.getMap().getTilt();
  }
  getRotation() {
    return 360 - this.getMap().getHeading();
  }
  getBounds() {
    const bounds = this.getMap().getBounds();
    const ne = bounds.getNorthEast();
    const sw = bounds.getSouthWest();
    return [[sw.lng, sw.lat], [ne.lng, ne.lat]];
  }
  getMapContainer() {
    return this.getMap().getContainer();
  }
  getMapCanvasContainer() {
    return this.getMap().getContainer();
  }
  getMapStyleConfig() {
    return this.styleConfig;
  }
  getMapStyleValue(name) {
    return this.styleConfig[name];
  }
  setMapStyle(style) {
    if (this.currentStyle === style) {
      return;
    }
    const styleVal = Array.isArray(style) ? style : this.styleConfig[style] || style;
    if (Array.isArray(styleVal)) {
      this.map.setMapStyleV2({
        styleJson: styleVal
      });
      this.currentStyle = style;
      return;
    }
    if (typeof styleVal === "string") {
      this.map.setMapStyleV2({
        styleId: styleVal
      });
      this.currentStyle = style;
      return;
    }
  }
  setRotation(rotation) {
    this.getMap().setHeading(rotation);
  }
  zoomIn() {
    this.getMap().zoomIn();
  }
  zoomOut() {
    this.getMap().zoomOut();
  }
  panTo(p) {
    this.getMap().panTo(new BMapGL.Point(p[0], p[1]));
  }
  panBy(x2, y) {
    this.getMap().panBy(x2, y);
  }
  fitBounds(bound, fitBoundsOptions) {
    this.map.setViewport(bound.map((item) => new BMapGL.Point(item[0], item[1])), fitBoundsOptions);
  }
  setZoomAndCenter(zoom, [lng, lat]) {
    this.getMap().centerAndZoom(new BMapGL.Point(lng, lat), zoom + 1.75);
  }
  setCenter([lng, lat], options) {
    let newCenter = {
      lng,
      lat
    };
    if (options !== null && options !== void 0 && options.padding) {
      const padding = toPaddingOptions(options.padding);
      const px = this.lngLatToPixel([lng, lat]);
      const offsetPx = [(padding.right - padding.left) / 2, (padding.bottom - padding.top) / 2];
      newCenter = this.pixelToLngLat([px.x + offsetPx[0], px.y + offsetPx[1]]);
    }
    this.getMap().setCenter(new BMapGL.Point(newCenter.lng, newCenter.lat));
  }
  setPitch(pitch) {
    this.getMap().setTilt(pitch);
  }
  setZoom(zoom) {
    this.getMap().setZoom(zoom);
  }
  setMapStatus(option) {
    const map = this.getMap();
    Object.keys(option).map((status) => {
      switch (status) {
        case "doubleClickZoom":
          option.doubleClickZoom ? map.enableDoubleClickZoom() : map.disableDoubleClickZoom();
          break;
        case "dragEnable":
          option.dragEnable ? map.enableDragging() : map.disableDragging();
          break;
        case "keyboardEnable":
          option.keyboardEnable ? map.enableKeyboard() : map.disableKeyboard();
          break;
        case "resizeEnable":
          option.resizeEnable ? map.enableAutoResize() : map.disableAutoResize();
          break;
        case "rotateEnable":
          if (option.rotateEnable) {
            map.enableRotate();
            map.enableRotateGestures();
          } else {
            map.disableRotate();
            map.disableRotateGestures();
          }
          break;
        case "zoomEnable":
          if (option.zoomEnable) {
            this.map.enableDoubleClickZoom();
            this.map.enableScrollWheelZoom();
            this.map.enablePinchToZoom();
          } else {
            this.map.disableDoubleClickZoom();
            this.map.disableScrollWheelZoom();
            this.map.disablePinchToZoom();
          }
          break;
        case "showIndoorMap":
          map.setDisplayOptions({
            indoor: !!option.showIndoorMap
          });
          break;
        default:
      }
    });
  }
  // coordinates methods
  meterToCoord(center, outer) {
    const metreDistance = this.getMap().getDistance(new BMapGL.Point(...center), new BMapGL.Point(...outer));
    const [x1, y1] = this.lngLatToCoord(center);
    const [x2, y2] = this.lngLatToCoord(outer);
    const coordDistance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    return coordDistance / metreDistance;
  }
  pixelToLngLat([x2, y]) {
    const lngLat = this.getMap().pixelToPoint(new BMapGL.Pixel(x2, y));
    return {
      lng: lngLat.lng,
      lat: lngLat.lat
    };
  }
  lngLatToPixel([lng, lat]) {
    const pixel = this.getMap().pointToPixel(new BMapGL.Point(lng, lat));
    return {
      x: pixel.x,
      y: pixel.y
    };
  }
  containerToLngLat([x2, y]) {
    const point2 = this.getMap().overlayPixelToPoint(new BMapGL.Pixel(x2, y));
    return {
      lng: point2.lng,
      lat: point2.lat
    };
  }
  lngLatToContainer([lng, lat]) {
    const overlayPixel = this.getMap().pointToOverlayPixel(new BMapGL.Point(lng, lat));
    return {
      x: overlayPixel.x,
      y: overlayPixel.y
    };
  }
  lngLatToCoord([lng, lat]) {
    const {
      x: x2,
      y
    } = this.getMap().pointToPixel(new BMapGL.Point(lng, lat));
    return [x2, -y];
  }
  lngLatToCoords(list) {
    return list.map((item) => Array.isArray(item[0]) ? this.lngLatToCoords(item) : this.lngLatToCoord(item));
  }
  lngLatToMercator([lng, lat], altitude) {
    const [McLng, McLat] = this.getMap().lnglatToMercator(lng, lat);
    return {
      x: McLng,
      y: McLat,
      z: altitude
    };
  }
  getModelMatrix(lnglat, altitude, rotate5, scale6 = [1, 1, 1]) {
    const flat = this.viewport.projectFlat(lnglat);
    const modelMatrix = mat4_exports.create();
    mat4_exports.translate(modelMatrix, modelMatrix, vec3_exports.fromValues(flat[0], flat[1], altitude));
    mat4_exports.scale(modelMatrix, modelMatrix, vec3_exports.fromValues(scale6[0], scale6[1], scale6[2]));
    mat4_exports.rotateX(modelMatrix, modelMatrix, rotate5[0]);
    mat4_exports.rotateY(modelMatrix, modelMatrix, rotate5[1]);
    mat4_exports.rotateZ(modelMatrix, modelMatrix, rotate5[2]);
    return modelMatrix;
  }
  getCustomCoordCenter() {
    throw new Error("Method not implemented.");
  }
  exportMap(type) {
    const renderCanvas = this.getMap()._webglPainter._canvas;
    const layersPng = type === "jpg" ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/jpeg") : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/png");
    return layersPng;
  }
  hideLogo() {
    const container = this.map.getContainer();
    if (!container) {
      return;
    }
    dom_exports.addClass(container, "bmap-contianer--hide-logo");
  }
  initMapByConfig(config4) {
    const {
      style,
      pitch = 0,
      rotation = 0,
      logoVisible = true
    } = config4;
    if (style) {
      this.setMapStyle(style);
    }
    if (pitch) {
      this.setPitch(pitch);
    }
    if (rotation) {
      this.setRotation(rotation);
    }
    if (logoVisible === false) {
      this.hideLogo();
    }
  }
};

// node_modules/@antv/l7-maps/es/bmap/index.js
var MapboxWrapper = class extends BaseMapWrapper {
  getServiceConstructor() {
    return BMapService2;
  }
};

// node_modules/@antv/l7-map/es/map/util/util.js
var import_unitbezier = __toESM(require_unitbezier());
var interpolates = {
  number: function number(from, to, t) {
    return from + t * (to - from);
  }
};
function clamp3(n, min5, max6) {
  return Math.min(max6, Math.max(min5, n));
}
function wrap2(n, min5, max6) {
  const d = max6 - min5;
  const w = ((n - min5) % d + d) % d + min5;
  return w === min5 ? max6 : w;
}
var id = 1;
function uniqueId2() {
  return id++;
}
function extend2(dest, ...sources) {
  for (const src of sources) {
    for (const k in src) {
      dest[k] = src[k];
    }
  }
  return dest;
}
function pick(src, properties) {
  const result = {};
  for (let i2 = 0; i2 < properties.length; i2++) {
    const k = properties[i2];
    if (k in src) {
      result[k] = src[k];
    }
  }
  return result;
}
function bezier2(p1x, p1y, p2x, p2y) {
  const bezier4 = new import_unitbezier.default(p1x, p1y, p2x, p2y);
  return (t) => {
    return bezier4.solve(t);
  };
}
var defaultEasing = bezier2(0.25, 0.1, 0.25, 1);
var warnOnceHistory = {};
function warnOnce(message) {
  if (!warnOnceHistory[message]) {
    if (typeof console !== "undefined")
      console.warn(message);
    warnOnceHistory[message] = true;
  }
}
function degreesToRadians2(degrees) {
  return degrees * Math.PI / 180;
}

// node_modules/@antv/l7-map/es/map/geo/lng_lat.js
var earthRadius2 = 63710088e-1;
var LngLat = class _LngLat {
  /**
   * @param lng - Longitude, measured in degrees.
   * @param lat - Latitude, measured in degrees.
   */
  constructor(lng, lat) {
    _defineProperty(this, "lng", void 0);
    _defineProperty(this, "lat", void 0);
    if (isNaN(lng) || isNaN(lat)) {
      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);
    }
    this.lng = +lng;
    this.lat = +lat;
    if (this.lat > 90 || this.lat < -90) {
      throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
    }
  }
  /**
   * Returns a new `LngLat` object whose longitude is wrapped to the range (-180, 180).
   *
   * @returns The wrapped `LngLat` object.
   * @example
   * ```ts
   * let ll = new LngLat(286.0251, 40.7736);
   * let wrapped = ll.wrap();
   * wrapped.lng; // = -73.9749
   * ```
   */
  wrap() {
    return new _LngLat(wrap2(this.lng, -180, 180), this.lat);
  }
  /**
   * Returns the coordinates represented as an array of two numbers.
   *
   * @returns The coordinates represented as an array of longitude and latitude.
   * @example
   * ```ts
   * let ll = new LngLat(-73.9749, 40.7736);
   * ll.toArray(); // = [-73.9749, 40.7736]
   * ```
   */
  toArray() {
    return [this.lng, this.lat];
  }
  /**
   * Returns the coordinates represent as a string.
   *
   * @returns The coordinates represented as a string of the format `'LngLat(lng, lat)'`.
   * @example
   * ```ts
   * let ll = new LngLat(-73.9749, 40.7736);
   * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
   * ```
   */
  toString() {
    return `LngLat(${this.lng}, ${this.lat})`;
  }
  /**
   * Returns the approximate distance between a pair of coordinates in meters
   * Uses the Haversine Formula (from R.W. Sinnott, "Virtues of the Haversine", Sky and Telescope, vol. 68, no. 2, 1984, p. 159)
   *
   * @param lngLat - coordinates to compute the distance to
   * @returns Distance in meters between the two coordinates.
   * @example
   * ```ts
   * let new_york = new LngLat(-74.0060, 40.7128);
   * let los_angeles = new LngLat(-118.2437, 34.0522);
   * new_york.distanceTo(los_angeles); // = 3935751.690893987, "true distance" using a non-spherical approximation is ~3966km
   * ```
   */
  distanceTo(lngLat) {
    const rad = Math.PI / 180;
    const lat1 = this.lat * rad;
    const lat2 = lngLat.lat * rad;
    const a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((lngLat.lng - this.lng) * rad);
    const maxMeters = earthRadius2 * Math.acos(Math.min(a, 1));
    return maxMeters;
  }
  /**
   * Converts an array of two numbers or an object with `lng` and `lat` or `lon` and `lat` properties
   * to a `LngLat` object.
   *
   * If a `LngLat` object is passed in, the function returns it unchanged.
   *
   * @param input - An array of two numbers or object to convert, or a `LngLat` object to return.
   * @returns A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.
   * @example
   * ```ts
   * let arr = [-73.9749, 40.7736];
   * let ll = LngLat.convert(arr);
   * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}
   * ```
   */
  static convert(input) {
    if (input instanceof _LngLat) {
      return input;
    }
    if (Array.isArray(input) && (input.length === 2 || input.length === 3)) {
      return new _LngLat(Number(input[0]), Number(input[1]));
    }
    if (!Array.isArray(input) && typeof input === "object" && input !== null) {
      return new _LngLat(
        // flow can't refine this to have one of lng or lat, so we have to cast to any
        Number("lng" in input ? input.lng : input.lon),
        Number(input.lat)
      );
    }
    throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
  }
};

// node_modules/@antv/l7-map/es/map/geo/mercator_coordinate.js
var earthCircumfrence = 2 * Math.PI * earthRadius2;
function circumferenceAtLatitude(latitude2) {
  return earthCircumfrence * Math.cos(latitude2 * Math.PI / 180);
}
function mercatorXfromLng(lng) {
  return (180 + lng) / 360;
}
function mercatorYfromLat(lat) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function mercatorZfromAltitude(altitude, lat) {
  return altitude / circumferenceAtLatitude(lat);
}
function lngFromMercatorX(x2) {
  return x2 * 360 - 180;
}
function latFromMercatorY(y) {
  const y2 = 180 - y * 360;
  return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
}
function altitudeFromMercatorZ(z, y) {
  return z * circumferenceAtLatitude(latFromMercatorY(y));
}
function mercatorScale(lat) {
  return 1 / Math.cos(lat * Math.PI / 180);
}
var MercatorCoordinate = class _MercatorCoordinate {
  /**
   * @param x - The x component of the position.
   * @param y - The y component of the position.
   * @param z - The z component of the position.
   */
  constructor(x2, y, z = 0) {
    _defineProperty(this, "x", void 0);
    _defineProperty(this, "y", void 0);
    _defineProperty(this, "z", void 0);
    this.x = +x2;
    this.y = +y;
    this.z = +z;
  }
  /**
   * Project a `LngLat` to a `MercatorCoordinate`.
   *
   * @param lngLatLike - The location to project.
   * @param altitude - The altitude in meters of the position.
   * @returns The projected mercator coordinate.
   * @example
   * ```ts
   * let coord = MercatorCoordinate.fromLngLat({ lng: 0, lat: 0}, 0);
   * coord; // MercatorCoordinate(0.5, 0.5, 0)
   * ```
   */
  static fromLngLat(lngLatLike, altitude = 0) {
    const lngLat = LngLat.convert(lngLatLike);
    return new _MercatorCoordinate(mercatorXfromLng(lngLat.lng), mercatorYfromLat(lngLat.lat), mercatorZfromAltitude(altitude, lngLat.lat));
  }
  /**
   * Returns the `LngLat` for the coordinate.
   *
   * @returns The `LngLat` object.
   * @example
   * ```ts
   * let coord = new MercatorCoordinate(0.5, 0.5, 0);
   * let lngLat = coord.toLngLat(); // LngLat(0, 0)
   * ```
   */
  toLngLat() {
    return new LngLat(lngFromMercatorX(this.x), latFromMercatorY(this.y));
  }
  /**
   * Returns the altitude in meters of the coordinate.
   *
   * @returns The altitude in meters.
   * @example
   * ```ts
   * let coord = new MercatorCoordinate(0, 0, 0.02);
   * coord.toAltitude(); // 6914.281956295339
   * ```
   */
  toAltitude() {
    return altitudeFromMercatorZ(this.z, this.y);
  }
  /**
   * Returns the distance of 1 meter in `MercatorCoordinate` units at this latitude.
   *
   * For coordinates in real world units using meters, this naturally provides the scale
   * to transform into `MercatorCoordinate`s.
   *
   * @returns Distance of 1 meter in `MercatorCoordinate` units.
   */
  meterInMercatorCoordinateUnits() {
    return 1 / earthCircumfrence * mercatorScale(latFromMercatorY(this.y));
  }
};

// node_modules/@antv/l7-map/es/map/map.js
var import_point_geometry11 = __toESM(require_point_geometry());

// node_modules/@antv/l7-map/es/map/camera.js
var import_point_geometry = __toESM(require_point_geometry());

// node_modules/@antv/l7-map/es/map/geo/lng_lat_bounds.js
var LngLatBounds = class _LngLatBounds {
  /**
   * @param sw - The southwest corner of the bounding box.
   * OR array of 4 numbers in the order of  west, south, east, north
   * OR array of 2 LngLatLike: [sw,ne]
   * @param ne - The northeast corner of the bounding box.
   * @example
   * ```ts
   * let sw = new LngLat(-73.9876, 40.7661);
   * let ne = new LngLat(-73.9397, 40.8002);
   * let llb = new LngLatBounds(sw, ne);
   * ```
   * OR
   * ```ts
   * let llb = new LngLatBounds([-73.9876, 40.7661, -73.9397, 40.8002]);
   * ```
   * OR
   * ```ts
   * let llb = new LngLatBounds([sw, ne]);
   * ```
   */
  constructor(sw, ne) {
    _defineProperty(this, "_ne", void 0);
    _defineProperty(this, "_sw", void 0);
    if (!sw) {
    } else if (ne) {
      this.setSouthWest(sw).setNorthEast(ne);
    } else if (Array.isArray(sw)) {
      if (sw.length === 4) {
        this.setSouthWest([sw[0], sw[1]]).setNorthEast([sw[2], sw[3]]);
      } else {
        this.setSouthWest(sw[0]).setNorthEast(sw[1]);
      }
    }
  }
  /**
   * Set the northeast corner of the bounding box
   *
   * @param ne - a {@link LngLatLike} object describing the northeast corner of the bounding box.
   */
  setNorthEast(ne) {
    this._ne = ne instanceof LngLat ? new LngLat(ne.lng, ne.lat) : LngLat.convert(ne);
    return this;
  }
  /**
   * Set the southwest corner of the bounding box
   *
   * @param sw - a {@link LngLatLike} object describing the southwest corner of the bounding box.
   */
  setSouthWest(sw) {
    this._sw = sw instanceof LngLat ? new LngLat(sw.lng, sw.lat) : LngLat.convert(sw);
    return this;
  }
  /**
   * Extend the bounds to include a given LngLatLike or LngLatBoundsLike.
   *
   * @param obj - object to extend to
   */
  extend(obj) {
    const sw = this._sw, ne = this._ne;
    let sw2, ne2;
    if (obj instanceof LngLat) {
      sw2 = obj;
      ne2 = obj;
    } else if (obj instanceof _LngLatBounds) {
      sw2 = obj._sw;
      ne2 = obj._ne;
      if (!sw2 || !ne2)
        return this;
    } else {
      if (Array.isArray(obj)) {
        if (obj.length === 4 || obj.every(Array.isArray)) {
          const lngLatBoundsObj = obj;
          return this.extend(_LngLatBounds.convert(lngLatBoundsObj));
        } else {
          const lngLatObj = obj;
          return this.extend(LngLat.convert(lngLatObj));
        }
      } else if (obj && ("lng" in obj || "lon" in obj) && "lat" in obj) {
        return this.extend(LngLat.convert(obj));
      }
      return this;
    }
    if (!sw && !ne) {
      this._sw = new LngLat(sw2.lng, sw2.lat);
      this._ne = new LngLat(ne2.lng, ne2.lat);
    } else {
      sw.lng = Math.min(sw2.lng, sw.lng);
      sw.lat = Math.min(sw2.lat, sw.lat);
      ne.lng = Math.max(ne2.lng, ne.lng);
      ne.lat = Math.max(ne2.lat, ne.lat);
    }
    return this;
  }
  /**
   * Returns the geographical coordinate equidistant from the bounding box's corners.
   *
   * @returns The bounding box's center.
   * @example
   * ```ts
   * let llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
   * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
   * ```
   */
  getCenter() {
    return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
  }
  /**
   * Returns the southwest corner of the bounding box.
   *
   * @returns The southwest corner of the bounding box.
   */
  getSouthWest() {
    return this._sw;
  }
  /**
   * Returns the northeast corner of the bounding box.
   *
   * @returns The northeast corner of the bounding box.
   */
  getNorthEast() {
    return this._ne;
  }
  /**
   * Returns the northwest corner of the bounding box.
   *
   * @returns The northwest corner of the bounding box.
   */
  getNorthWest() {
    return new LngLat(this.getWest(), this.getNorth());
  }
  /**
   * Returns the southeast corner of the bounding box.
   *
   * @returns The southeast corner of the bounding box.
   */
  getSouthEast() {
    return new LngLat(this.getEast(), this.getSouth());
  }
  /**
   * Returns the west edge of the bounding box.
   *
   * @returns The west edge of the bounding box.
   */
  getWest() {
    return this._sw.lng;
  }
  /**
   * Returns the south edge of the bounding box.
   *
   * @returns The south edge of the bounding box.
   */
  getSouth() {
    return this._sw.lat;
  }
  /**
   * Returns the east edge of the bounding box.
   *
   * @returns The east edge of the bounding box.
   */
  getEast() {
    return this._ne.lng;
  }
  /**
   * Returns the north edge of the bounding box.
   *
   * @returns The north edge of the bounding box.
   */
  getNorth() {
    return this._ne.lat;
  }
  /**
   * Returns the bounding box represented as an array.
   *
   * @returns The bounding box represented as an array, consisting of the
   * southwest and northeast coordinates of the bounding represented as arrays of numbers.
   * @example
   * ```ts
   * let llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
   * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
   * ```
   */
  toArray() {
    return [this._sw.toArray(), this._ne.toArray()];
  }
  /**
   * Return the bounding box represented as a string.
   *
   * @returns The bounding box represents as a string of the format
   * `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.
   * @example
   * ```ts
   * let llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
   * llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
   * ```
   */
  toString() {
    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
  }
  /**
   * Check if the bounding box is an empty/`null`-type box.
   *
   * @returns True if bounds have been defined, otherwise false.
   */
  isEmpty() {
    return !(this._sw && this._ne);
  }
  /**
   * Check if the point is within the bounding box.
   *
   * @param lnglat - geographic point to check against.
   * @returns `true` if the point is within the bounding box.
   * @example
   * ```ts
   * let llb = new LngLatBounds(
   *   new LngLat(-73.9876, 40.7661),
   *   new LngLat(-73.9397, 40.8002)
   * );
   *
   * let ll = new LngLat(-73.9567, 40.7789);
   *
   * console.log(llb.contains(ll)); // = true
   * ```
   */
  contains(lnglat) {
    const {
      lng,
      lat
    } = LngLat.convert(lnglat);
    const containsLatitude = this._sw.lat <= lat && lat <= this._ne.lat;
    let containsLongitude = this._sw.lng <= lng && lng <= this._ne.lng;
    if (this._sw.lng > this._ne.lng) {
      containsLongitude = this._sw.lng >= lng && lng >= this._ne.lng;
    }
    return containsLatitude && containsLongitude;
  }
  /**
   * Converts an array to a `LngLatBounds` object.
   *
   * If a `LngLatBounds` object is passed in, the function returns it unchanged.
   *
   * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.
   *
   * @param input - An array of two coordinates to convert, or a `LngLatBounds` object to return.
   * @returns A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.
   * @example
   * ```ts
   * let arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
   * let llb = LngLatBounds.convert(arr); // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
   * ```
   */
  static convert(input) {
    if (input instanceof _LngLatBounds)
      return input;
    return new _LngLatBounds(input);
  }
  /**
   * Returns a `LngLatBounds` from the coordinates extended by a given `radius`. The returned `LngLatBounds` completely contains the `radius`.
   *
   * @param center - center coordinates of the new bounds.
   * @param radius - Distance in meters from the coordinates to extend the bounds.
   * @returns A new `LngLatBounds` object representing the coordinates extended by the `radius`.
   * @example
   * ```ts
   * let center = new LngLat(-73.9749, 40.7736);
   * LngLatBounds.fromLngLat(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]
   * ```
   */
  static fromLngLat(center, radius = 0) {
    const earthCircumferenceInMetersAtEquator = 40075017;
    const latAccuracy = 360 * radius / earthCircumferenceInMetersAtEquator, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * center.lat);
    return new _LngLatBounds(new LngLat(center.lng - lngAccuracy, center.lat - latAccuracy), new LngLat(center.lng + lngAccuracy, center.lat + latAccuracy));
  }
};

// node_modules/@antv/l7-map/es/map/util/abort_error.js
var ABORT_ERROR = "AbortError";
function createAbortError() {
  return new Error(ABORT_ERROR);
}

// node_modules/@antv/l7-map/es/map/util/browser.js
var now = typeof performance !== "undefined" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date);
var reducedMotionQuery;
var browser = {
  /**
   * Provides a function that outputs milliseconds: either performance.now()
   * or a fallback to Date.now()
   */
  now,
  frameAsync(abortController) {
    return new Promise((resolve, reject) => {
      const frame = requestAnimationFrame(resolve);
      abortController.signal.addEventListener("abort", () => {
        cancelAnimationFrame(frame);
        reject(createAbortError());
      });
    });
  },
  get prefersReducedMotion() {
    if (!window.matchMedia)
      return false;
    if (reducedMotionQuery == null) {
      reducedMotionQuery = window.matchMedia("(prefers-reduced-motion: reduce)");
    }
    return reducedMotionQuery.matches;
  }
};

// node_modules/@antv/l7-map/es/map/util/evented.js
function _addEventListener(type, listener, listenerList) {
  const listenerExists = listenerList[type] && listenerList[type].indexOf(listener) !== -1;
  if (!listenerExists) {
    listenerList[type] = listenerList[type] || [];
    listenerList[type].push(listener);
  }
}
function _removeEventListener(type, listener, listenerList) {
  if (listenerList && listenerList[type]) {
    const index = listenerList[type].indexOf(listener);
    if (index !== -1) {
      listenerList[type].splice(index, 1);
    }
  }
}
var Event2 = class {
  constructor(type, data = {}) {
    _defineProperty(this, "type", void 0);
    extend2(this, data);
    this.type = type;
  }
};
var ErrorEvent = class extends Event2 {
  constructor(error, data = {}) {
    super("error", data);
    _defineProperty(this, "error", void 0);
    this.error = error;
  }
};
var Evented = class {
  constructor() {
    _defineProperty(this, "_listeners", void 0);
    _defineProperty(this, "_oneTimeListeners", void 0);
    _defineProperty(this, "_eventedParent", void 0);
    _defineProperty(this, "_eventedParentData", void 0);
  }
  /**
   * Adds a listener to a specified event type.
   *
   * @param type - The event type to add a listen for.
   * @param listener - The function to be called when the event is fired.
   * The listener function is called with the data object passed to `fire`,
   * extended with `target` and `type` properties.
   */
  on(type, listener) {
    this._listeners = this._listeners || {};
    _addEventListener(type, listener, this._listeners);
    return this;
  }
  /**
   * Removes a previously registered event listener.
   *
   * @param type - The event type to remove listeners for.
   * @param listener - The listener function to remove.
   */
  off(type, listener) {
    _removeEventListener(type, listener, this._listeners);
    _removeEventListener(type, listener, this._oneTimeListeners);
    return this;
  }
  /**
   * Adds a listener that will be called only once to a specified event type.
   *
   * The listener will be called first time the event fires after the listener is registered.
   *
   * @param type - The event type to listen for.
   * @param listener - The function to be called when the event is fired the first time.
   * @returns `this` or a promise if a listener is not provided
   */
  once(type, listener) {
    if (!listener) {
      return new Promise((resolve) => this.once(type, resolve));
    }
    this._oneTimeListeners = this._oneTimeListeners || {};
    _addEventListener(type, listener, this._oneTimeListeners);
    return this;
  }
  fire(event, properties) {
    if (typeof event === "string") {
      event = new Event2(event, properties || {});
    }
    const type = event.type;
    if (this.listens(type)) {
      event.target = this;
      const listeners = this._listeners && this._listeners[type] ? this._listeners[type].slice() : [];
      for (const listener of listeners) {
        listener.call(this, event);
      }
      const oneTimeListeners = this._oneTimeListeners && this._oneTimeListeners[type] ? this._oneTimeListeners[type].slice() : [];
      for (const listener of oneTimeListeners) {
        _removeEventListener(type, listener, this._oneTimeListeners);
        listener.call(this, event);
      }
      const parent = this._eventedParent;
      if (parent) {
        extend2(event, typeof this._eventedParentData === "function" ? this._eventedParentData() : this._eventedParentData);
        parent.fire(event);
      }
    } else if (event instanceof ErrorEvent) {
      console.error(event.error);
    }
    return this;
  }
  emit(event, properties) {
    return this.fire(event, properties);
  }
  /**
   * Returns a true if this instance of Evented or any forwardeed instances of Evented have a listener for the specified type.
   *
   * @param type - The event type
   * @returns `true` if there is at least one registered listener for specified event type, `false` otherwise
   */
  listens(type) {
    return this._listeners && this._listeners[type] && this._listeners[type].length > 0 || this._oneTimeListeners && this._oneTimeListeners[type] && this._oneTimeListeners[type].length > 0 || this._eventedParent && this._eventedParent.listens(type);
  }
  /**
   * Bubble all events fired by this instance of Evented to this parent instance of Evented.
   */
  setEventedParent(parent, data) {
    if (parent) {
      this._eventedParent = parent;
    }
    this._eventedParentData = data;
    return this;
  }
};

// node_modules/@antv/l7-map/es/map/camera.js
var Camera = class extends Evented {
  constructor(transform2, options) {
    super();
    _defineProperty(this, "transform", void 0);
    _defineProperty(this, "handlers", void 0);
    _defineProperty(this, "_moving", void 0);
    _defineProperty(this, "_zooming", void 0);
    _defineProperty(this, "_rotating", void 0);
    _defineProperty(this, "_pitching", void 0);
    _defineProperty(this, "_padding", void 0);
    _defineProperty(this, "_bearingSnap", void 0);
    _defineProperty(this, "_easeStart", void 0);
    _defineProperty(this, "_easeOptions", void 0);
    _defineProperty(this, "_easeId", void 0);
    _defineProperty(this, "_onEaseFrame", void 0);
    _defineProperty(this, "_onEaseEnd", void 0);
    _defineProperty(this, "_easeFrameId", void 0);
    _defineProperty(this, "_requestedCameraState", void 0);
    _defineProperty(this, "transformCameraUpdate", void 0);
    _defineProperty(this, "_renderFrameCallback", () => {
      const t = Math.min((browser.now() - this._easeStart) / this._easeOptions.duration, 1);
      this._onEaseFrame(this._easeOptions.easing(t));
      if (t < 1 && this._easeFrameId) {
        this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback);
      } else {
        this.stop();
      }
    });
    this._moving = false;
    this._zooming = false;
    this.transform = transform2;
    this._bearingSnap = options.bearingSnap;
    this.on("moveend", () => {
      delete this._requestedCameraState;
    });
  }
  /**
   * Returns the map's geographical centerpoint.
   *
   * @returns The map's geographical centerpoint.
   * @example
   * Return a LngLat object such as `{lng: 0, lat: 0}`
   * ```ts
   * let center = map.getCenter();
   * // access longitude and latitude values directly
   * let {lng, lat} = map.getCenter();
   * ```
   */
  getCenter() {
    return new LngLat(this.transform.center.lng, this.transform.center.lat);
  }
  /**
   * Sets the map's geographical centerpoint. Equivalent to `jumpTo({center: center})`.
   *
   * Triggers the following events: `movestart` and `moveend`.
   *
   * @param center - The centerpoint to set.
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @example
   * ```ts
   * map.setCenter([-74, 38]);
   * ```
   */
  setCenter(center, eventData) {
    return this.jumpTo({
      center
    }, eventData);
  }
  /**
   * Pans the map by the specified offset.
   *
   * Triggers the following events: `movestart` and `moveend`.
   *
   * @param offset - `x` and `y` coordinates by which to pan the map.
   * @param options - Options object
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)
   */
  panBy(offset, options, eventData) {
    offset = import_point_geometry.default.convert(offset).mult(-1);
    return this.panTo(this.transform.center, extend2({
      offset
    }, options), eventData);
  }
  /**
   * Pans the map to the specified location with an animated transition.
   *
   * Triggers the following events: `movestart` and `moveend`.
   *
   * @param lnglat - The location to pan the map to.
   * @param options - Options describing the destination and animation of the transition.
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @example
   * ```ts
   * map.panTo([-74, 38]);
   * // Specify that the panTo animation should last 5000 milliseconds.
   * map.panTo([-74, 38], {duration: 5000});
   * ```
   * @see [Update a feature in realtime](https://maplibre.org/maplibre-gl-js/docs/examples/live-update-feature/)
   */
  panTo(lnglat, options, eventData) {
    return this.easeTo(extend2({
      center: lnglat
    }, options), eventData);
  }
  /**
   * Returns the map's current zoom level.
   *
   * @returns The map's current zoom level.
   * @example
   * ```ts
   * map.getZoom();
   * ```
   */
  getZoom() {
    return this.transform.zoom;
  }
  /**
   * Sets the map's zoom level. Equivalent to `jumpTo({zoom: zoom})`.
   *
   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.
   *
   * @param zoom - The zoom level to set (0-20).
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @example
   * Zoom to the zoom level 5 without an animated transition
   * ```ts
   * map.setZoom(5);
   * ```
   */
  setZoom(zoom, eventData) {
    this.jumpTo({
      zoom
    }, eventData);
    return this;
  }
  /**
   * Zooms the map to the specified zoom level, with an animated transition.
   *
   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.
   *
   * @param zoom - The zoom level to transition to.
   * @param options - Options object
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @example
   * ```ts
   * // Zoom to the zoom level 5 without an animated transition
   * map.zoomTo(5);
   * // Zoom to the zoom level 8 with an animated transition
   * map.zoomTo(8, {
   *   duration: 2000,
   *   offset: [100, 50]
   * });
   * ```
   */
  zoomTo(zoom, options, eventData) {
    return this.easeTo(extend2({
      zoom
    }, options), eventData);
  }
  /**
   * Increases the map's zoom level by 1.
   *
   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.
   *
   * @param options - Options object
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @example
   * Zoom the map in one level with a custom animation duration
   * ```ts
   * map.zoomIn({duration: 1000});
   * ```
   */
  zoomIn(options, eventData) {
    this.zoomTo(this.getZoom() + 1, options, eventData);
    return this;
  }
  /**
   * Decreases the map's zoom level by 1.
   *
   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.
   *
   * @param options - Options object
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @example
   * Zoom the map out one level with a custom animation offset
   * ```ts
   * map.zoomOut({offset: [80, 60]});
   * ```
   */
  zoomOut(options, eventData) {
    this.zoomTo(this.getZoom() - 1, options, eventData);
    return this;
  }
  /**
   * Returns the map's current bearing. The bearing is the compass direction that is "up"; for example, a bearing
   * of 90° orients the map so that east is up.
   *
   * @returns The map's current bearing.
   * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)
   */
  getBearing() {
    return this.transform.bearing;
  }
  /**
   * Sets the map's bearing (rotation). The bearing is the compass direction that is "up"; for example, a bearing
   * of 90° orients the map so that east is up.
   *
   * Equivalent to `jumpTo({bearing: bearing})`.
   *
   * Triggers the following events: `movestart`, `moveend`, and `rotate`.
   *
   * @param bearing - The desired bearing.
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @example
   * Rotate the map to 90 degrees
   * ```ts
   * map.setBearing(90);
   * ```
   */
  setBearing(bearing, eventData) {
    this.jumpTo({
      bearing
    }, eventData);
    return this;
  }
  /**
   * Returns the current padding applied around the map viewport.
   *
   * @returns The current padding around the map viewport.
   */
  getPadding() {
    return this.transform.padding;
  }
  /**
   * Sets the padding in pixels around the viewport.
   *
   * Equivalent to `jumpTo({padding: padding})`.
   *
   * Triggers the following events: `movestart` and `moveend`.
   *
   * @param padding - The desired padding.
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @example
   * Sets a left padding of 300px, and a top padding of 50px
   * ```ts
   * map.setPadding({ left: 300, top: 50 });
   * ```
   */
  setPadding(padding, eventData) {
    this.jumpTo({
      padding
    }, eventData);
    return this;
  }
  /**
   * Rotates the map to the specified bearing, with an animated transition. The bearing is the compass direction
   * that is "up"; for example, a bearing of 90° orients the map so that east is up.
   *
   * Triggers the following events: `movestart`, `moveend`, and `rotate`.
   *
   * @param bearing - The desired bearing.
   * @param options - Options object
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   */
  rotateTo(bearing, options, eventData) {
    return this.easeTo(extend2({
      bearing
    }, options), eventData);
  }
  /**
   * Rotates the map so that north is up (0° bearing), with an animated transition.
   *
   * Triggers the following events: `movestart`, `moveend`, and `rotate`.
   *
   * @param options - Options object
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   */
  resetNorth(options, eventData) {
    this.rotateTo(0, extend2({
      duration: 1e3
    }, options), eventData);
    return this;
  }
  /**
   * Rotates and pitches the map so that north is up (0° bearing) and pitch is 0°, with an animated transition.
   *
   * Triggers the following events: `movestart`, `move`, `moveend`, `pitchstart`, `pitch`, `pitchend`, and `rotate`.
   *
   * @param options - Options object
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   */
  resetNorthPitch(options, eventData) {
    this.easeTo(extend2({
      bearing: 0,
      pitch: 0,
      duration: 1e3
    }, options), eventData);
    return this;
  }
  /**
   * Snaps the map so that north is up (0° bearing), if the current bearing is close enough to it (i.e. within the
   * `bearingSnap` threshold).
   *
   * Triggers the following events: `movestart`, `moveend`, and `rotate`.
   *
   * @param options - Options object
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   */
  snapToNorth(options, eventData) {
    if (Math.abs(this.getBearing()) < this._bearingSnap) {
      return this.resetNorth(options, eventData);
    }
    return this;
  }
  /**
   * Returns the map's current pitch (tilt).
   *
   * @returns The map's current pitch, measured in degrees away from the plane of the screen.
   */
  getPitch() {
    return this.transform.pitch;
  }
  /**
   * Sets the map's pitch (tilt). Equivalent to `jumpTo({pitch: pitch})`.
   *
   * Triggers the following events: `movestart`, `moveend`, `pitchstart`, and `pitchend`.
   *
   * @param pitch - The pitch to set, measured in degrees away from the plane of the screen (0-60).
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   */
  setPitch(pitch, eventData) {
    this.jumpTo({
      pitch
    }, eventData);
    return this;
  }
  /**
   * @param bounds - Calculate the center for these bounds in the viewport and use
   * the highest zoom level up to and including `Map#getMaxZoom()` that fits
   * in the viewport. LngLatBounds represent a box that is always axis-aligned with bearing 0.
   * @param options - Options object
   * @returns If map is able to fit to provided bounds, returns `center`, `zoom`, and `bearing`.
   * If map is unable to fit, method will warn and return undefined.
   * @example
   * ```ts
   * let bbox = [[-79, 43], [-73, 45]];
   * let newCameraTransform = map.cameraForBounds(bbox, {
   *   padding: {top: 10, bottom:25, left: 15, right: 5}
   * });
   * ```
   */
  cameraForBounds(bounds, options) {
    bounds = LngLatBounds.convert(bounds);
    const bearing = options && options.bearing || 0;
    return this._cameraForBoxAndBearing(bounds.getNorthWest(), bounds.getSouthEast(), bearing, options);
  }
  /**
   * @internal
   * Calculate the center of these two points in the viewport and use
   * the highest zoom level up to and including `Map#getMaxZoom()` that fits
   * the points in the viewport at the specified bearing.
   * @param p0 - First point
   * @param p1 - Second point
   * @param bearing - Desired map bearing at end of animation, in degrees
   * @param options - the camera options
   * @returns If map is able to fit to provided bounds, returns `center`, `zoom`, and `bearing`.
   *      If map is unable to fit, method will warn and return undefined.
   * @example
   * ```ts
   * let p0 = [-79, 43];
   * let p1 = [-73, 45];
   * let bearing = 90;
   * let newCameraTransform = map._cameraForBoxAndBearing(p0, p1, bearing, {
   *   padding: {top: 10, bottom:25, left: 15, right: 5}
   * });
   * ```
   */
  _cameraForBoxAndBearing(p0, p1, bearing, options) {
    const defaultPadding = {
      top: 0,
      bottom: 0,
      right: 0,
      left: 0
    };
    options = extend2({
      padding: defaultPadding,
      offset: [0, 0],
      maxZoom: this.transform.maxZoom
    }, options);
    if (typeof options.padding === "number") {
      const p = options.padding;
      options.padding = {
        top: p,
        bottom: p,
        right: p,
        left: p
      };
    }
    options.padding = extend2(defaultPadding, options.padding);
    const tr = this.transform;
    const edgePadding = tr.padding;
    const bounds = new LngLatBounds(p0, p1);
    const nwWorld = tr.project(bounds.getNorthWest());
    const neWorld = tr.project(bounds.getNorthEast());
    const seWorld = tr.project(bounds.getSouthEast());
    const swWorld = tr.project(bounds.getSouthWest());
    const bearingRadians = degreesToRadians2(-bearing);
    const nwRotatedWorld = nwWorld.rotate(bearingRadians);
    const neRotatedWorld = neWorld.rotate(bearingRadians);
    const seRotatedWorld = seWorld.rotate(bearingRadians);
    const swRotatedWorld = swWorld.rotate(bearingRadians);
    const upperRight = new import_point_geometry.default(Math.max(nwRotatedWorld.x, neRotatedWorld.x, swRotatedWorld.x, seRotatedWorld.x), Math.max(nwRotatedWorld.y, neRotatedWorld.y, swRotatedWorld.y, seRotatedWorld.y));
    const lowerLeft = new import_point_geometry.default(Math.min(nwRotatedWorld.x, neRotatedWorld.x, swRotatedWorld.x, seRotatedWorld.x), Math.min(nwRotatedWorld.y, neRotatedWorld.y, swRotatedWorld.y, seRotatedWorld.y));
    const size = upperRight.sub(lowerLeft);
    const scaleX = (tr.width - (edgePadding.left + edgePadding.right + options.padding.left + options.padding.right)) / size.x;
    const scaleY = (tr.height - (edgePadding.top + edgePadding.bottom + options.padding.top + options.padding.bottom)) / size.y;
    if (scaleY < 0 || scaleX < 0) {
      warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
      return void 0;
    }
    const zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);
    const offset = import_point_geometry.default.convert(options.offset);
    const paddingOffsetX = (options.padding.left - options.padding.right) / 2;
    const paddingOffsetY = (options.padding.top - options.padding.bottom) / 2;
    const paddingOffset = new import_point_geometry.default(paddingOffsetX, paddingOffsetY);
    const rotatedPaddingOffset = paddingOffset.rotate(degreesToRadians2(bearing));
    const offsetAtInitialZoom = offset.add(rotatedPaddingOffset);
    const offsetAtFinalZoom = offsetAtInitialZoom.mult(tr.scale / tr.zoomScale(zoom));
    const center = tr.unproject(
      // either world diagonal can be used (NW-SE or NE-SW)
      nwWorld.add(seWorld).div(2).sub(offsetAtFinalZoom)
    );
    return {
      center,
      zoom,
      bearing
    };
  }
  /**
   * Pans and zooms the map to contain its visible area within the specified geographical bounds.
   * This function will also reset the map's bearing to 0 if bearing is nonzero.
   *
   * Triggers the following events: `movestart` and `moveend`.
   *
   * @param bounds - Center these bounds in the viewport and use the highest
   * zoom level up to and including `Map#getMaxZoom()` that fits them in the viewport.
   * @param options - Options supports all properties from {@link AnimationOptions} and {@link CameraOptions} in addition to the fields below.
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @example
   * ```ts
   * let bbox = [[-79, 43], [-73, 45]];
   * map.fitBounds(bbox, {
   *   padding: {top: 10, bottom:25, left: 15, right: 5}
   * });
   * ```
   * @see [Fit a map to a bounding box](https://maplibre.org/maplibre-gl-js/docs/examples/fitbounds/)
   */
  fitBounds(bounds, options, eventData) {
    return this._fitInternal(this.cameraForBounds(bounds, options), options, eventData);
  }
  /**
   * Pans, rotates and zooms the map to to fit the box made by points p0 and p1
   * once the map is rotated to the specified bearing. To zoom without rotating,
   * pass in the current map bearing.
   *
   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend` and `rotate`.
   *
   * @param p0 - First point on screen, in pixel coordinates
   * @param p1 - Second point on screen, in pixel coordinates
   * @param bearing - Desired map bearing at end of animation, in degrees
   * @param options - Options object
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @example
   * ```ts
   * let p0 = [220, 400];
   * let p1 = [500, 900];
   * map.fitScreenCoordinates(p0, p1, map.getBearing(), {
   *   padding: {top: 10, bottom:25, left: 15, right: 5}
   * });
   * ```
   * @see Used by {@link BoxZoomHandler}
   */
  fitScreenCoordinates(p0, p1, bearing, options, eventData) {
    return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(import_point_geometry.default.convert(p0)), this.transform.pointLocation(import_point_geometry.default.convert(p1)), bearing, options), options, eventData);
  }
  _fitInternal(calculatedOptions, options, eventData) {
    if (!calculatedOptions)
      return this;
    options = extend2(calculatedOptions, options);
    delete options.padding;
    return options.linear ? this.easeTo(options, eventData) : this.flyTo(options, eventData);
  }
  /**
   * Changes any combination of center, zoom, bearing, and pitch, without
   * an animated transition. The map will retain its current values for any
   * details not specified in `options`.
   *
   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,
   * `pitch`, `pitchend`, and `rotate`.
   *
   * @param options - Options object
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @example
   * ```ts
   * // jump to coordinates at current zoom
   * map.jumpTo({center: [0, 0]});
   * // jump with zoom, pitch, and bearing options
   * map.jumpTo({
   *   center: [0, 0],
   *   zoom: 8,
   *   pitch: 45,
   *   bearing: 90
   * });
   * ```
   * @see [Jump to a series of locations](https://maplibre.org/maplibre-gl-js/docs/examples/jump-to/)
   * @see [Update a feature in realtime](https://maplibre.org/maplibre-gl-js/docs/examples/live-update-feature/)
   */
  jumpTo(options, eventData) {
    this.stop();
    const tr = this._getTransformForUpdate();
    let zoomChanged = false, bearingChanged = false, pitchChanged = false;
    if ("zoom" in options && tr.zoom !== +options.zoom) {
      zoomChanged = true;
      tr.zoom = +options.zoom;
    }
    if (options.center !== void 0) {
      tr.center = LngLat.convert(options.center);
    }
    if ("bearing" in options && tr.bearing !== +options.bearing) {
      bearingChanged = true;
      tr.bearing = +options.bearing;
    }
    if ("pitch" in options && tr.pitch !== +options.pitch) {
      pitchChanged = true;
      tr.pitch = +options.pitch;
    }
    if (options.padding != null && !tr.isPaddingEqual(options.padding)) {
      tr.padding = options.padding;
    }
    this._applyUpdatedTransform(tr);
    this.fire(new Event2("movestart", eventData)).fire(new Event2("move", eventData));
    if (zoomChanged) {
      this.fire(new Event2("zoomstart", eventData)).fire(new Event2("zoom", eventData)).fire(new Event2("zoomend", eventData));
    }
    if (bearingChanged) {
      this.fire(new Event2("rotatestart", eventData)).fire(new Event2("rotate", eventData)).fire(new Event2("rotateend", eventData));
    }
    if (pitchChanged) {
      this.fire(new Event2("pitchstart", eventData)).fire(new Event2("pitch", eventData)).fire(new Event2("pitchend", eventData));
    }
    return this.fire(new Event2("moveend", eventData));
  }
  /**
   * Calculates pitch, zoom and bearing for looking at `newCenter` with the camera position being `newCenter`
   * and returns them as {@link CameraOptions}.
   * @param from - The camera to look from
   * @param altitudeFrom - The altitude of the camera to look from
   * @param to - The center to look at
   * @param altitudeTo - Optional altitude of the center to look at. If none given the ground height will be used.
   * @returns the calculated camera options
   */
  calculateCameraOptionsFromTo(from, altitudeFrom, to, altitudeTo = 0) {
    const fromMerc = MercatorCoordinate.fromLngLat(from, altitudeFrom);
    const toMerc = MercatorCoordinate.fromLngLat(to, altitudeTo);
    const dx = toMerc.x - fromMerc.x;
    const dy = toMerc.y - fromMerc.y;
    const dz = toMerc.z - fromMerc.z;
    const distance3D = Math.hypot(dx, dy, dz);
    if (distance3D === 0)
      throw new Error("Can't calculate camera options with same From and To");
    const groundDistance = Math.hypot(dx, dy);
    const zoom = this.transform.scaleZoom(this.transform.cameraToCenterDistance / distance3D / this.transform.tileSize);
    const bearing = Math.atan2(dx, -dy) * 180 / Math.PI;
    let pitch = Math.acos(groundDistance / distance3D) * 180 / Math.PI;
    pitch = dz < 0 ? 90 - pitch : 90 + pitch;
    return {
      center: toMerc.toLngLat(),
      zoom,
      pitch,
      bearing
    };
  }
  /**
   * Changes any combination of `center`, `zoom`, `bearing`, `pitch`, and `padding` with an animated transition
   * between old and new values. The map will retain its current values for any
   * details not specified in `options`.
   *
   * Note: The transition will happen instantly if the user has enabled
   * the `reduced motion` accessibility feature enabled in their operating system,
   * unless `options` includes `essential: true`.
   *
   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,
   * `pitch`, `pitchend`, and `rotate`.
   *
   * @param options - Options describing the destination and animation of the transition.
   * Accepts {@link CameraOptions} and {@link AnimationOptions}.
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)
   */
  easeTo(options, eventData) {
    var _options$zoom;
    this._stop(false, options.easeId);
    options = extend2({
      offset: [0, 0],
      duration: 500,
      easing: defaultEasing
    }, options);
    if (options.animate === false || !options.essential && browser.prefersReducedMotion)
      options.duration = 0;
    const tr = this._getTransformForUpdate(), startZoom = this.getZoom(), startBearing = this.getBearing(), startPitch = this.getPitch(), startPadding = this.getPadding(), bearing = "bearing" in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing, pitch = "pitch" in options ? +options.pitch : startPitch, padding = "padding" in options ? options.padding : tr.padding;
    const offsetAsPoint = import_point_geometry.default.convert(options.offset);
    let pointAtOffset = tr.centerPoint.add(offsetAsPoint);
    const locationAtOffset = tr.pointLocation(pointAtOffset);
    const {
      center,
      zoom
    } = tr.getConstrained(LngLat.convert(options.center || locationAtOffset), (_options$zoom = options.zoom) !== null && _options$zoom !== void 0 ? _options$zoom : startZoom);
    this._normalizeCenter(center);
    const from = tr.project(locationAtOffset);
    const delta = tr.project(center).sub(from);
    const finalScale = tr.zoomScale(zoom - startZoom);
    let around, aroundPoint;
    if (options.around) {
      around = LngLat.convert(options.around);
      aroundPoint = tr.locationPoint(around);
    }
    const currently = {
      moving: this._moving,
      zooming: this._zooming,
      rotating: this._rotating,
      pitching: this._pitching
    };
    this._zooming = this._zooming || zoom !== startZoom;
    this._rotating = this._rotating || startBearing !== bearing;
    this._pitching = this._pitching || pitch !== startPitch;
    this._padding = !tr.isPaddingEqual(padding);
    this._easeId = options.easeId;
    this._prepareEase(eventData, options.noMoveStart, currently);
    this._ease((k) => {
      if (this._zooming) {
        tr.zoom = interpolates.number(startZoom, zoom, k);
      }
      if (this._rotating) {
        tr.bearing = interpolates.number(startBearing, bearing, k);
      }
      if (this._pitching) {
        tr.pitch = interpolates.number(startPitch, pitch, k);
      }
      if (this._padding) {
        tr.interpolatePadding(startPadding, padding, k);
        pointAtOffset = tr.centerPoint.add(offsetAsPoint);
      }
      if (around) {
        tr.setLocationAtPoint(around, aroundPoint);
      } else {
        const scale6 = tr.zoomScale(tr.zoom - startZoom);
        const base = zoom > startZoom ? Math.min(2, finalScale) : Math.max(0.5, finalScale);
        const speedup = Math.pow(base, 1 - k);
        const newCenter = tr.unproject(from.add(delta.mult(k * speedup)).mult(scale6));
        tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);
      }
      this._applyUpdatedTransform(tr);
      this._fireMoveEvents(eventData);
    }, (interruptingEaseId) => {
      this._afterEase(eventData, interruptingEaseId);
    }, options);
    return this;
  }
  _prepareEase(eventData, noMoveStart, currently = {}) {
    this._moving = true;
    if (!noMoveStart && !currently.moving) {
      this.fire(new Event2("movestart", eventData));
    }
    if (this._zooming && !currently.zooming) {
      this.fire(new Event2("zoomstart", eventData));
    }
    if (this._rotating && !currently.rotating) {
      this.fire(new Event2("rotatestart", eventData));
    }
    if (this._pitching && !currently.pitching) {
      this.fire(new Event2("pitchstart", eventData));
    }
  }
  /**
   * @internal
   * Called when the camera is about to be manipulated.
   * If `transformCameraUpdate` is specified, a copy of the current transform is created to track the accumulated changes.
   * This underlying transform represents the "desired state" proposed by input handlers / animations / UI controls.
   * It may differ from the state used for rendering (`this.transform`).
   * @returns Transform to apply changes to
   */
  _getTransformForUpdate() {
    if (!this.transformCameraUpdate)
      return this.transform;
    if (!this._requestedCameraState) {
      this._requestedCameraState = this.transform.clone();
    }
    return this._requestedCameraState;
  }
  /**
   * @internal
   * Called after the camera is done being manipulated.
   * @param tr - the requested camera end state
   * Call `transformCameraUpdate` if present, and then apply the "approved" changes.
   */
  _applyUpdatedTransform(tr) {
    if (!this.transformCameraUpdate)
      return;
    const nextTransform = tr.clone();
    const {
      center,
      zoom,
      pitch,
      bearing,
      elevation
    } = this.transformCameraUpdate(nextTransform);
    if (center)
      nextTransform.center = center;
    if (zoom !== void 0)
      nextTransform.zoom = zoom;
    if (pitch !== void 0)
      nextTransform.pitch = pitch;
    if (bearing !== void 0)
      nextTransform.bearing = bearing;
    if (elevation !== void 0)
      nextTransform.elevation = elevation;
    this.transform.apply(nextTransform);
  }
  _fireMoveEvents(eventData) {
    this.fire(new Event2("move", eventData));
    if (this._zooming) {
      this.fire(new Event2("zoom", eventData));
    }
    if (this._rotating) {
      this.fire(new Event2("rotate", eventData));
    }
    if (this._pitching) {
      this.fire(new Event2("pitch", eventData));
    }
  }
  _afterEase(eventData, easeId) {
    if (this._easeId && easeId && this._easeId === easeId) {
      return;
    }
    delete this._easeId;
    const wasZooming = this._zooming;
    const wasRotating = this._rotating;
    const wasPitching = this._pitching;
    this._moving = false;
    this._zooming = false;
    this._rotating = false;
    this._pitching = false;
    this._padding = false;
    if (wasZooming) {
      this.fire(new Event2("zoomend", eventData));
    }
    if (wasRotating) {
      this.fire(new Event2("rotateend", eventData));
    }
    if (wasPitching) {
      this.fire(new Event2("pitchend", eventData));
    }
    this.fire(new Event2("moveend", eventData));
  }
  /**
   * Changes any combination of center, zoom, bearing, and pitch, animating the transition along a curve that
   * evokes flight. The animation seamlessly incorporates zooming and panning to help
   * the user maintain her bearings even after traversing a great distance.
   *
   * Note: The animation will be skipped, and this will behave equivalently to `jumpTo`
   * if the user has the `reduced motion` accessibility feature enabled in their operating system,
   * unless 'options' includes `essential: true`.
   *
   * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,
   * `pitch`, `pitchend`, and `rotate`.
   *
   * @param options - Options describing the destination and animation of the transition.
   * Accepts {@link CameraOptions}, {@link AnimationOptions},
   * and the following additional options.
   * @param eventData - Additional properties to be added to event objects of events triggered by this method.
   * @example
   * ```ts
   * // fly with default options to null island
   * map.flyTo({center: [0, 0], zoom: 9});
   * // using flyTo options
   * map.flyTo({
   *   center: [0, 0],
   *   zoom: 9,
   *   speed: 0.2,
   *   curve: 1,
   *   easing(t) {
   *     return t;
   *   }
   * });
   * ```
   * @see [Fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto/)
   * @see [Slowly fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto-options/)
   * @see [Fly to a location based on scroll position](https://maplibre.org/maplibre-gl-js/docs/examples/scroll-fly-to/)
   */
  flyTo(options, eventData) {
    var _options$zoom2;
    if (!options.essential && browser.prefersReducedMotion) {
      const coercedOptions = pick(options, ["center", "zoom", "bearing", "pitch", "around"]);
      return this.jumpTo(coercedOptions, eventData);
    }
    this.stop();
    options = extend2({
      offset: [0, 0],
      speed: 1.2,
      curve: 1.42,
      easing: defaultEasing
    }, options);
    const tr = this._getTransformForUpdate(), startZoom = this.getZoom(), startBearing = this.getBearing(), startPitch = this.getPitch(), startPadding = this.getPadding();
    const bearing = "bearing" in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;
    const pitch = "pitch" in options ? +options.pitch : startPitch;
    const padding = "padding" in options ? options.padding : tr.padding;
    const offsetAsPoint = import_point_geometry.default.convert(options.offset);
    let pointAtOffset = tr.centerPoint.add(offsetAsPoint);
    const locationAtOffset = tr.pointLocation(pointAtOffset);
    const {
      center,
      zoom
    } = tr.getConstrained(LngLat.convert(options.center || locationAtOffset), (_options$zoom2 = options.zoom) !== null && _options$zoom2 !== void 0 ? _options$zoom2 : startZoom);
    this._normalizeCenter(center);
    const scale6 = tr.zoomScale(zoom - startZoom);
    const from = tr.project(locationAtOffset);
    const delta = tr.project(center).sub(from);
    let rho = options.curve;
    const w0 = Math.max(tr.width, tr.height), w1 = w0 / scale6, u1 = delta.mag();
    if ("minZoom" in options) {
      const minZoom = clamp3(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);
      const wMax = w0 / tr.zoomScale(minZoom - startZoom);
      rho = Math.sqrt(wMax / u1 * 2);
    }
    const rho2 = rho * rho;
    function zoomOutFactor(descent) {
      const b = (w1 * w1 - w0 * w0 + (descent ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (descent ? w1 : w0) * rho2 * u1);
      return Math.log(Math.sqrt(b * b + 1) - b);
    }
    function sinh(n) {
      return (Math.exp(n) - Math.exp(-n)) / 2;
    }
    function cosh(n) {
      return (Math.exp(n) + Math.exp(-n)) / 2;
    }
    function tanh(n) {
      return sinh(n) / cosh(n);
    }
    const r0 = zoomOutFactor(false);
    let w = function(s) {
      return cosh(r0) / cosh(r0 + rho * s);
    };
    let u = function(s) {
      return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1;
    };
    let S = (zoomOutFactor(true) - r0) / rho;
    if (Math.abs(u1) < 1e-6 || !isFinite(S)) {
      if (Math.abs(w0 - w1) < 1e-6)
        return this.easeTo(options, eventData);
      const k = w1 < w0 ? -1 : 1;
      S = Math.abs(Math.log(w1 / w0)) / rho;
      u = () => 0;
      w = (s) => Math.exp(k * rho * s);
    }
    if ("duration" in options) {
      options.duration = +options.duration;
    } else {
      const V = "screenSpeed" in options ? +options.screenSpeed / rho : +options.speed;
      options.duration = 1e3 * S / V;
    }
    if (options.maxDuration && options.duration > options.maxDuration) {
      options.duration = 0;
    }
    this._zooming = true;
    this._rotating = startBearing !== bearing;
    this._pitching = pitch !== startPitch;
    this._padding = !tr.isPaddingEqual(padding);
    this._prepareEase(eventData, false);
    this._ease((k) => {
      const s = k * S;
      const scale7 = 1 / w(s);
      tr.zoom = k === 1 ? zoom : startZoom + tr.scaleZoom(scale7);
      if (this._rotating) {
        tr.bearing = interpolates.number(startBearing, bearing, k);
      }
      if (this._pitching) {
        tr.pitch = interpolates.number(startPitch, pitch, k);
      }
      if (this._padding) {
        tr.interpolatePadding(startPadding, padding, k);
        pointAtOffset = tr.centerPoint.add(offsetAsPoint);
      }
      const newCenter = k === 1 ? center : tr.unproject(from.add(delta.mult(u(s))).mult(scale7));
      tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);
      this._applyUpdatedTransform(tr);
      this._fireMoveEvents(eventData);
    }, () => {
      this._afterEase(eventData);
    }, options);
    return this;
  }
  isEasing() {
    return !!this._easeFrameId;
  }
  /**
   * Stops any animated transition underway.
   */
  stop() {
    return this._stop();
  }
  _stop(allowGestures, easeId) {
    if (this._easeFrameId) {
      this._cancelRenderFrame(this._easeFrameId);
      delete this._easeFrameId;
      delete this._onEaseFrame;
    }
    if (this._onEaseEnd) {
      const onEaseEnd = this._onEaseEnd;
      delete this._onEaseEnd;
      onEaseEnd.call(this, easeId);
    }
    if (!allowGestures) {
      var _this$handlers;
      (_this$handlers = this.handlers) === null || _this$handlers === void 0 || _this$handlers.stop(false);
    }
    return this;
  }
  _ease(frame, finish, options) {
    if (options.animate === false || options.duration === 0) {
      frame(1);
      finish();
    } else {
      this._easeStart = browser.now();
      this._easeOptions = options;
      this._onEaseFrame = frame;
      this._onEaseEnd = finish;
      this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback);
    }
  }
  // convert bearing so that it's numerically close to the current one so that it interpolates properly
  _normalizeBearing(bearing, currentBearing) {
    bearing = wrap2(bearing, -180, 180);
    const diff = Math.abs(bearing - currentBearing);
    if (Math.abs(bearing - 360 - currentBearing) < diff)
      bearing -= 360;
    if (Math.abs(bearing + 360 - currentBearing) < diff)
      bearing += 360;
    return bearing;
  }
  // If a path crossing the antimeridian would be shorter, extend the final coordinate so that
  // interpolating between the two endpoints will cross it.
  _normalizeCenter(center) {
    const tr = this.transform;
    if (!tr.renderWorldCopies || tr.lngRange)
      return;
    const delta = center.lng - tr.center.lng;
    center.lng += delta > 180 ? -360 : delta < -180 ? 360 : 0;
  }
};

// node_modules/@antv/l7-map/es/map/geo/transform.js
var import_point_geometry3 = __toESM(require_point_geometry());

// node_modules/@antv/l7-map/es/map/geo/edge_insets.js
var import_point_geometry2 = __toESM(require_point_geometry());
var EdgeInsets = class _EdgeInsets {
  constructor(top = 0, bottom = 0, left = 0, right = 0) {
    _defineProperty(this, "top", void 0);
    _defineProperty(this, "bottom", void 0);
    _defineProperty(this, "left", void 0);
    _defineProperty(this, "right", void 0);
    if (isNaN(top) || top < 0 || isNaN(bottom) || bottom < 0 || isNaN(left) || left < 0 || isNaN(right) || right < 0) {
      throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
    }
    this.top = top;
    this.bottom = bottom;
    this.left = left;
    this.right = right;
  }
  /**
   * Interpolates the inset in-place.
   * This maintains the current inset value for any inset not present in `target`.
   * @param start - interpolation start
   * @param target - interpolation target
   * @param t - interpolation step/weight
   * @returns the insets
   */
  interpolate(start, target, t) {
    if (target.top != null && start.top != null)
      this.top = interpolates.number(start.top, target.top, t);
    if (target.bottom != null && start.bottom != null)
      this.bottom = interpolates.number(start.bottom, target.bottom, t);
    if (target.left != null && start.left != null)
      this.left = interpolates.number(start.left, target.left, t);
    if (target.right != null && start.right != null)
      this.right = interpolates.number(start.right, target.right, t);
    return this;
  }
  /**
   * Utility method that computes the new apprent center or vanishing point after applying insets.
   * This is in pixels and with the top left being (0.0) and +y being downwards.
   *
   * @param width - the width
   * @param height - the height
   * @returns the point
   */
  getCenter(width, height) {
    const x2 = clamp3((this.left + width - this.right) / 2, 0, width);
    const y = clamp3((this.top + height - this.bottom) / 2, 0, height);
    return new import_point_geometry2.default(x2, y);
  }
  equals(other) {
    return this.top === other.top && this.bottom === other.bottom && this.left === other.left && this.right === other.right;
  }
  clone() {
    return new _EdgeInsets(this.top, this.bottom, this.left, this.right);
  }
  /**
   * Returns the current state as json, useful when you want to have a
   * read-only representation of the inset.
   *
   * @returns state as json
   */
  toJSON() {
    return {
      top: this.top,
      bottom: this.bottom,
      left: this.left,
      right: this.right
    };
  }
};

// node_modules/@antv/l7-map/es/map/geo/transform.js
var MAX_VALID_LATITUDE = 85.051129;
var Transform = class _Transform {
  constructor(minZoom, maxZoom, minPitch, maxPitch, renderWorldCopies) {
    _defineProperty(this, "tileSize", void 0);
    _defineProperty(this, "tileZoom", void 0);
    _defineProperty(this, "lngRange", void 0);
    _defineProperty(this, "latRange", void 0);
    _defineProperty(this, "scale", void 0);
    _defineProperty(this, "width", void 0);
    _defineProperty(this, "height", void 0);
    _defineProperty(this, "angle", void 0);
    _defineProperty(this, "rotationMatrix", void 0);
    _defineProperty(this, "pixelsToGLUnits", void 0);
    _defineProperty(this, "cameraToCenterDistance", void 0);
    _defineProperty(this, "mercatorMatrix", void 0);
    _defineProperty(this, "projMatrix", void 0);
    _defineProperty(this, "invProjMatrix", void 0);
    _defineProperty(this, "alignedProjMatrix", void 0);
    _defineProperty(this, "pixelMatrix", void 0);
    _defineProperty(this, "pixelMatrix3D", void 0);
    _defineProperty(this, "pixelMatrixInverse", void 0);
    _defineProperty(this, "glCoordMatrix", void 0);
    _defineProperty(this, "labelPlaneMatrix", void 0);
    _defineProperty(this, "minElevationForCurrentTile", void 0);
    _defineProperty(this, "_fov", void 0);
    _defineProperty(this, "_pitch", void 0);
    _defineProperty(this, "_zoom", void 0);
    _defineProperty(this, "_unmodified", void 0);
    _defineProperty(this, "_renderWorldCopies", void 0);
    _defineProperty(this, "_minZoom", void 0);
    _defineProperty(this, "_maxZoom", void 0);
    _defineProperty(this, "_minPitch", void 0);
    _defineProperty(this, "_maxPitch", void 0);
    _defineProperty(this, "_center", void 0);
    _defineProperty(this, "_elevation", void 0);
    _defineProperty(this, "_pixelPerMeter", void 0);
    _defineProperty(this, "_edgeInsets", void 0);
    _defineProperty(this, "_constraining", void 0);
    _defineProperty(this, "_posMatrixCache", void 0);
    _defineProperty(this, "_alignedPosMatrixCache", void 0);
    this.tileSize = 512;
    this._renderWorldCopies = renderWorldCopies === void 0 ? true : !!renderWorldCopies;
    this._minZoom = minZoom || 0;
    this._maxZoom = maxZoom || 22;
    this._minPitch = minPitch === void 0 || minPitch === null ? 0 : minPitch;
    this._maxPitch = maxPitch === void 0 || maxPitch === null ? 60 : maxPitch;
    this.setMaxBounds();
    this.width = 0;
    this.height = 0;
    this._center = new LngLat(0, 0);
    this._elevation = 0;
    this.zoom = 0;
    this.angle = 0;
    this._fov = 0.6435011087932844;
    this._pitch = 0;
    this._unmodified = true;
    this._edgeInsets = new EdgeInsets();
    this._posMatrixCache = {};
    this._alignedPosMatrixCache = {};
    this.minElevationForCurrentTile = 0;
  }
  clone() {
    const clone6 = new _Transform(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
    clone6.apply(this);
    return clone6;
  }
  apply(that) {
    this.tileSize = that.tileSize;
    this.latRange = that.latRange;
    this.width = that.width;
    this.height = that.height;
    this._center = that._center;
    this._elevation = that._elevation;
    this.minElevationForCurrentTile = that.minElevationForCurrentTile;
    this.zoom = that.zoom;
    this.angle = that.angle;
    this._fov = that._fov;
    this._pitch = that._pitch;
    this._unmodified = that._unmodified;
    this._edgeInsets = that._edgeInsets.clone();
    this._calcMatrices();
  }
  get minZoom() {
    return this._minZoom;
  }
  set minZoom(zoom) {
    if (this._minZoom === zoom)
      return;
    this._minZoom = zoom;
    this.zoom = Math.max(this.zoom, zoom);
  }
  get maxZoom() {
    return this._maxZoom;
  }
  set maxZoom(zoom) {
    if (this._maxZoom === zoom)
      return;
    this._maxZoom = zoom;
    this.zoom = Math.min(this.zoom, zoom);
  }
  get minPitch() {
    return this._minPitch;
  }
  set minPitch(pitch) {
    if (this._minPitch === pitch)
      return;
    this._minPitch = pitch;
    this.pitch = Math.max(this.pitch, pitch);
  }
  get maxPitch() {
    return this._maxPitch;
  }
  set maxPitch(pitch) {
    if (this._maxPitch === pitch)
      return;
    this._maxPitch = pitch;
    this.pitch = Math.min(this.pitch, pitch);
  }
  get renderWorldCopies() {
    return this._renderWorldCopies;
  }
  set renderWorldCopies(renderWorldCopies) {
    if (renderWorldCopies === void 0) {
      renderWorldCopies = true;
    } else if (renderWorldCopies === null) {
      renderWorldCopies = false;
    }
    this._renderWorldCopies = renderWorldCopies;
  }
  get worldSize() {
    return this.tileSize * this.scale;
  }
  get centerOffset() {
    return this.centerPoint._sub(this.size._div(2));
  }
  get size() {
    return new import_point_geometry3.default(this.width, this.height);
  }
  get bearing() {
    return -this.angle / Math.PI * 180;
  }
  set bearing(bearing) {
    const b = -wrap2(bearing, -180, 180) * Math.PI / 180;
    if (this.angle === b)
      return;
    this._unmodified = false;
    this.angle = b;
    this._calcMatrices();
    this.rotationMatrix = mat2_exports.create();
    mat2_exports.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);
  }
  get pitch() {
    return this._pitch / Math.PI * 180;
  }
  set pitch(pitch) {
    const p = clamp3(pitch, this.minPitch, this.maxPitch) / 180 * Math.PI;
    if (this._pitch === p)
      return;
    this._unmodified = false;
    this._pitch = p;
    this._calcMatrices();
  }
  get fov() {
    return this._fov / Math.PI * 180;
  }
  set fov(fov) {
    fov = Math.max(0.01, Math.min(60, fov));
    if (this._fov === fov)
      return;
    this._unmodified = false;
    this._fov = fov / 180 * Math.PI;
    this._calcMatrices();
  }
  get zoom() {
    return this._zoom;
  }
  set zoom(zoom) {
    const constrainedZoom = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
    if (this._zoom === constrainedZoom)
      return;
    this._unmodified = false;
    this._zoom = constrainedZoom;
    this.tileZoom = Math.max(0, Math.floor(constrainedZoom));
    this.scale = this.zoomScale(constrainedZoom);
    this._constrain();
    this._calcMatrices();
  }
  get center() {
    return this._center;
  }
  set center(center) {
    if (center.lat === this._center.lat && center.lng === this._center.lng)
      return;
    this._unmodified = false;
    this._center = center;
    this._constrain();
    this._calcMatrices();
  }
  /**
   * Elevation at current center point, meters above sea level
   */
  get elevation() {
    return this._elevation;
  }
  set elevation(elevation) {
    if (elevation === this._elevation)
      return;
    this._elevation = elevation;
    this._constrain();
    this._calcMatrices();
  }
  get padding() {
    return this._edgeInsets.toJSON();
  }
  set padding(padding) {
    if (this._edgeInsets.equals(padding))
      return;
    this._unmodified = false;
    this._edgeInsets.interpolate(this._edgeInsets, padding, 1);
    this._calcMatrices();
  }
  /**
   * The center of the screen in pixels with the top-left corner being (0,0)
   * and +y axis pointing downwards. This accounts for padding.
   */
  get centerPoint() {
    return this._edgeInsets.getCenter(this.width, this.height);
  }
  /**
   * Returns if the padding params match
   *
   * @param padding - the padding to check against
   * @returns true if they are equal, false otherwise
   */
  isPaddingEqual(padding) {
    return this._edgeInsets.equals(padding);
  }
  /**
   * Helper method to update edge-insets in place
   *
   * @param start - the starting padding
   * @param target - the target padding
   * @param t - the step/weight
   */
  interpolatePadding(start, target, t) {
    this._unmodified = false;
    this._edgeInsets.interpolate(start, target, t);
    this._constrain();
    this._calcMatrices();
  }
  /**
   * Return a zoom level that will cover all tiles the transform
   * @param options - the options
   * @returns zoom level An integer zoom level at which all tiles will be visible.
   */
  coveringZoomLevel(options) {
    const z = (options.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / options.tileSize));
    return Math.max(0, z);
  }
  resize(width, height) {
    this.width = width;
    this.height = height;
    this.pixelsToGLUnits = [2 / width, -2 / height];
    this._constrain();
    this._calcMatrices();
  }
  get unmodified() {
    return this._unmodified;
  }
  zoomScale(zoom) {
    return Math.pow(2, zoom);
  }
  scaleZoom(scale6) {
    return Math.log(scale6) / Math.LN2;
  }
  /**
   * Convert from LngLat to world coordinates (Mercator coordinates scaled by 512)
   * @param lnglat - the lngLat
   * @returns Point
   */
  project(lnglat) {
    const lat = clamp3(lnglat.lat, -MAX_VALID_LATITUDE, MAX_VALID_LATITUDE);
    return new import_point_geometry3.default(mercatorXfromLng(lnglat.lng) * this.worldSize, mercatorYfromLat(lat) * this.worldSize);
  }
  /**
   * Convert from world coordinates ([0, 512],[0, 512]) to LngLat ([-180, 180], [-90, 90])
   * @param point - world coordinate
   * @returns LngLat
   */
  unproject(point2) {
    return new MercatorCoordinate(point2.x / this.worldSize, point2.y / this.worldSize).toLngLat();
  }
  get point() {
    return this.project(this.center);
  }
  /**
   * get the camera position in LngLat and altitudes in meter
   * @returns An object with lngLat & altitude.
   */
  getCameraPosition() {
    const lngLat = this.pointLocation(this.getCameraPoint());
    const altitude = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter;
    return {
      lngLat,
      altitude: altitude + this.elevation
    };
  }
  setLocationAtPoint(lnglat, point2) {
    const a = this.pointCoordinate(point2);
    const b = this.pointCoordinate(this.centerPoint);
    const loc = this.locationCoordinate(lnglat);
    const newCenter = new MercatorCoordinate(loc.x - (a.x - b.x), loc.y - (a.y - b.y));
    this.center = this.coordinateLocation(newCenter);
    if (this._renderWorldCopies) {
      this.center = this.center.wrap();
    }
  }
  /**
   * Given a LngLat location, return the screen point that corresponds to it
   * @param lnglat - location
   * @param terrain - optional terrain
   * @returns screen point
   */
  locationPoint(lnglat) {
    return this.coordinatePoint(this.locationCoordinate(lnglat));
  }
  /**
   * Given a point on screen, return its lnglat
   * @param p - screen point
   * @param terrain - optional terrain
   * @returns lnglat location
   */
  pointLocation(p) {
    return this.coordinateLocation(this.pointCoordinate(p));
  }
  /**
   * Given a geographical lnglat, return an unrounded
   * coordinate that represents it at low zoom level.
   * @param lnglat - the location
   * @returns The mercator coordinate
   */
  locationCoordinate(lnglat) {
    return MercatorCoordinate.fromLngLat(lnglat);
  }
  /**
   * Given a Coordinate, return its geographical position.
   * @param coord - mercator coordinates
   * @returns lng and lat
   */
  coordinateLocation(coord) {
    return coord && coord.toLngLat();
  }
  /**
   * Given a Point, return its mercator coordinate.
   * @param p - the point
   * @param terrain - optional terrain
   * @returns lnglat
   */
  pointCoordinate(p) {
    const targetZ = 0;
    const coord0 = [p.x, p.y, 0, 1];
    const coord1 = [p.x, p.y, 1, 1];
    vec4_exports.transformMat4(coord0, coord0, this.pixelMatrixInverse);
    vec4_exports.transformMat4(coord1, coord1, this.pixelMatrixInverse);
    const w0 = coord0[3];
    const w1 = coord1[3];
    const x0 = coord0[0] / w0;
    const x1 = coord1[0] / w1;
    const y0 = coord0[1] / w0;
    const y1 = coord1[1] / w1;
    const z0 = coord0[2] / w0;
    const z1 = coord1[2] / w1;
    const t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
    return new MercatorCoordinate(interpolates.number(x0, x1, t) / this.worldSize, interpolates.number(y0, y1, t) / this.worldSize);
  }
  /**
   * Given a coordinate, return the screen point that corresponds to it
   * @param coord - the coordinates
   * @param elevation - the elevation
   * @param pixelMatrix - the pixel matrix
   * @returns screen point
   */
  coordinatePoint(coord, elevation = 0, pixelMatrix = this.pixelMatrix) {
    const p = [coord.x * this.worldSize, coord.y * this.worldSize, elevation, 1];
    vec4_exports.transformMat4(p, p, pixelMatrix);
    return new import_point_geometry3.default(p[0] / p[3], p[1] / p[3]);
  }
  /**
   * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not
   * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.
   * @returns Returns a {@link LngLatBounds} object describing the map's geographical bounds.
   */
  getBounds() {
    const top = Math.max(0, this.height / 2 - this.getHorizon());
    return new LngLatBounds().extend(this.pointLocation(new import_point_geometry3.default(0, top))).extend(this.pointLocation(new import_point_geometry3.default(this.width, top))).extend(this.pointLocation(new import_point_geometry3.default(this.width, this.height))).extend(this.pointLocation(new import_point_geometry3.default(0, this.height)));
  }
  /**
   * Returns the maximum geographical bounds the map is constrained to, or `null` if none set.
   * @returns max bounds
   */
  getMaxBounds() {
    if (!this.latRange || this.latRange.length !== 2 || !this.lngRange || this.lngRange.length !== 2)
      return null;
    return new LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]);
  }
  /**
   * Calculate pixel height of the visible horizon in relation to map-center (e.g. height/2),
   * multiplied by a static factor to simulate the earth-radius.
   * The calculated value is the horizontal line from the camera-height to sea-level.
   * @returns Horizon above center in pixels.
   */
  getHorizon() {
    return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
  }
  /**
   * Sets or clears the map's geographical constraints.
   * @param bounds - A {@link LngLatBounds} object describing the new geographic boundaries of the map.
   */
  setMaxBounds(bounds) {
    if (bounds) {
      this.lngRange = [bounds.getWest(), bounds.getEast()];
      this.latRange = [bounds.getSouth(), bounds.getNorth()];
      this._constrain();
    } else {
      this.lngRange = null;
      this.latRange = [-MAX_VALID_LATITUDE, MAX_VALID_LATITUDE];
    }
  }
  customLayerMatrix() {
    return this.mercatorMatrix.slice();
  }
  /**
   * Get center lngLat and zoom to ensure that
   * 1) everything beyond the bounds is excluded
   * 2) a given lngLat is as near the center as possible
   * Bounds are those set by maxBounds or North & South "Poles" and, if only 1 globe is displayed, antimeridian.
   */
  getConstrained(lngLat, zoom) {
    zoom = clamp3(+zoom, this.minZoom, this.maxZoom);
    const result = {
      center: new LngLat(lngLat.lng, lngLat.lat),
      zoom
    };
    let lngRange = this.lngRange;
    if (!this._renderWorldCopies && lngRange === null) {
      const almost180 = 180 - 1e-10;
      lngRange = [-almost180, almost180];
    }
    const worldSize = this.tileSize * this.zoomScale(result.zoom);
    let minY = 0;
    let maxY = worldSize;
    let minX = 0;
    let maxX = worldSize;
    let scaleY = 0;
    let scaleX = 0;
    const {
      x: screenWidth,
      y: screenHeight
    } = this.size;
    if (this.latRange) {
      const latRange = this.latRange;
      minY = mercatorYfromLat(latRange[1]) * worldSize;
      maxY = mercatorYfromLat(latRange[0]) * worldSize;
      const shouldZoomIn = maxY - minY < screenHeight;
      if (shouldZoomIn)
        scaleY = screenHeight / (maxY - minY);
    }
    if (lngRange) {
      minX = wrap2(mercatorXfromLng(lngRange[0]) * worldSize, 0, worldSize);
      maxX = wrap2(mercatorXfromLng(lngRange[1]) * worldSize, 0, worldSize);
      if (maxX < minX)
        maxX += worldSize;
      const shouldZoomIn = maxX - minX < screenWidth;
      if (shouldZoomIn)
        scaleX = screenWidth / (maxX - minX);
    }
    const {
      x: originalX,
      y: originalY
    } = this.project.call({
      worldSize
    }, lngLat);
    let modifiedX, modifiedY;
    const scale6 = Math.max(scaleX || 0, scaleY || 0);
    if (scale6) {
      const newPoint = new import_point_geometry3.default(scaleX ? (maxX + minX) / 2 : originalX, scaleY ? (maxY + minY) / 2 : originalY);
      result.center = this.unproject.call({
        worldSize
      }, newPoint).wrap();
      result.zoom += this.scaleZoom(scale6);
      return result;
    }
    if (this.latRange) {
      const h2 = screenHeight / 2;
      if (originalY - h2 < minY)
        modifiedY = minY + h2;
      if (originalY + h2 > maxY)
        modifiedY = maxY - h2;
    }
    if (lngRange) {
      const centerX = (minX + maxX) / 2;
      let wrappedX = originalX;
      if (this._renderWorldCopies) {
        wrappedX = wrap2(originalX, centerX - worldSize / 2, centerX + worldSize / 2);
      }
      const w2 = screenWidth / 2;
      if (wrappedX - w2 < minX)
        modifiedX = minX + w2;
      if (wrappedX + w2 > maxX)
        modifiedX = maxX - w2;
    }
    if (modifiedX !== void 0 || modifiedY !== void 0) {
      var _modifiedX, _modifiedY;
      const newPoint = new import_point_geometry3.default((_modifiedX = modifiedX) !== null && _modifiedX !== void 0 ? _modifiedX : originalX, (_modifiedY = modifiedY) !== null && _modifiedY !== void 0 ? _modifiedY : originalY);
      result.center = this.unproject.call({
        worldSize
      }, newPoint).wrap();
    }
    return result;
  }
  _constrain() {
    if (!this.center || !this.width || !this.height || this._constraining)
      return;
    this._constraining = true;
    const unmodified = this._unmodified;
    const {
      center,
      zoom
    } = this.getConstrained(this.center, this.zoom);
    this.center = center;
    this.zoom = zoom;
    this._unmodified = unmodified;
    this._constraining = false;
  }
  _calcMatrices() {
    if (!this.height)
      return;
    const halfFov = this._fov / 2;
    const offset = this.centerOffset;
    const x2 = this.point.x, y = this.point.y;
    this.cameraToCenterDistance = 0.5 / Math.tan(halfFov) * this.height;
    this._pixelPerMeter = mercatorZfromAltitude(1, this.center.lat) * this.worldSize;
    let m = mat4_exports.identity(new Float64Array(16));
    mat4_exports.scale(m, m, [this.width / 2, -this.height / 2, 1]);
    mat4_exports.translate(m, m, [1, -1, 0]);
    this.labelPlaneMatrix = m;
    m = mat4_exports.identity(new Float64Array(16));
    mat4_exports.scale(m, m, [1, -1, 1]);
    mat4_exports.translate(m, m, [-1, -1, 0]);
    mat4_exports.scale(m, m, [2 / this.width, 2 / this.height, 1]);
    this.glCoordMatrix = m;
    const cameraToSeaLevelDistance = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch);
    const minElevation = Math.min(this.elevation, this.minElevationForCurrentTile);
    const cameraToLowestPointDistance = cameraToSeaLevelDistance - minElevation * this._pixelPerMeter / Math.cos(this._pitch);
    const lowestPlane = minElevation < 0 ? cameraToLowestPointDistance : cameraToSeaLevelDistance;
    const groundAngle = Math.PI / 2 + this._pitch;
    const fovAboveCenter = this._fov * (0.5 + offset.y / this.height);
    const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * lowestPlane / Math.sin(clamp3(Math.PI - groundAngle - fovAboveCenter, 0.01, Math.PI - 0.01));
    const horizon = this.getHorizon();
    const horizonAngle = Math.atan(horizon / this.cameraToCenterDistance);
    const fovCenterToHorizon = 2 * horizonAngle * (0.5 + offset.y / (horizon * 2));
    const topHalfSurfaceDistanceHorizon = Math.sin(fovCenterToHorizon) * lowestPlane / Math.sin(clamp3(Math.PI - groundAngle - fovCenterToHorizon, 0.01, Math.PI - 0.01));
    const topHalfMinDistance = Math.min(topHalfSurfaceDistance, topHalfSurfaceDistanceHorizon);
    const farZ = (Math.cos(Math.PI / 2 - this._pitch) * topHalfMinDistance + lowestPlane) * 1.01;
    const nearZ = this.height / 50;
    m = new Float64Array(16);
    mat4_exports.perspective(m, this._fov, this.width / this.height, nearZ, farZ);
    m[8] = -offset.x * 2 / this.width;
    m[9] = offset.y * 2 / this.height;
    mat4_exports.scale(m, m, [1, -1, 1]);
    mat4_exports.translate(m, m, [0, 0, -this.cameraToCenterDistance]);
    mat4_exports.rotateX(m, m, this._pitch);
    mat4_exports.rotateZ(m, m, this.angle);
    mat4_exports.translate(m, m, [-x2, -y, 0]);
    this.mercatorMatrix = mat4_exports.scale([], m, [this.worldSize, this.worldSize, this.worldSize]);
    mat4_exports.scale(m, m, [1, 1, this._pixelPerMeter]);
    this.pixelMatrix = mat4_exports.multiply(new Float64Array(16), this.labelPlaneMatrix, m);
    mat4_exports.translate(m, m, [0, 0, -this.elevation]);
    this.projMatrix = m;
    this.invProjMatrix = mat4_exports.invert([], m);
    this.pixelMatrix3D = mat4_exports.multiply(new Float64Array(16), this.labelPlaneMatrix, m);
    const xShift = this.width % 2 / 2, yShift = this.height % 2 / 2, angleCos = Math.cos(this.angle), angleSin = Math.sin(this.angle), dx = x2 - Math.round(x2) + angleCos * xShift + angleSin * yShift, dy = y - Math.round(y) + angleCos * yShift + angleSin * xShift;
    const alignedM = new Float64Array(m);
    mat4_exports.translate(alignedM, alignedM, [dx > 0.5 ? dx - 1 : dx, dy > 0.5 ? dy - 1 : dy, 0]);
    this.alignedProjMatrix = alignedM;
    m = mat4_exports.invert(new Float64Array(16), this.pixelMatrix);
    if (!m)
      throw new Error("failed to invert matrix");
    this.pixelMatrixInverse = m;
    this._posMatrixCache = {};
    this._alignedPosMatrixCache = {};
  }
  maxPitchScaleFactor() {
    if (!this.pixelMatrixInverse)
      return 1;
    const coord = this.pointCoordinate(new import_point_geometry3.default(0, 0));
    const p = [coord.x * this.worldSize, coord.y * this.worldSize, 0, 1];
    const topPoint = vec4_exports.transformMat4(p, p, this.pixelMatrix);
    return topPoint[3] / this.cameraToCenterDistance;
  }
  /**
   * The camera looks at the map from a 3D (lng, lat, altitude) location. Let's use `cameraLocation`
   * as the name for the location under the camera and on the surface of the earth (lng, lat, 0).
   * `cameraPoint` is the projected position of the `cameraLocation`.
   *
   * This point is useful to us because only fill-extrusions that are between `cameraPoint` and
   * the query point on the surface of the earth can extend and intersect the query.
   *
   * When the map is not pitched the `cameraPoint` is equivalent to the center of the map because
   * the camera is right above the center of the map.
   */
  getCameraPoint() {
    const pitch = this._pitch;
    const yOffset = Math.tan(pitch) * (this.cameraToCenterDistance || 1);
    return this.centerPoint.add(new import_point_geometry3.default(0, yOffset));
  }
  /**
   * When the map is pitched, some of the 3D features that intersect a query will not intersect
   * the query at the surface of the earth. Instead the feature may be closer and only intersect
   * the query because it extrudes into the air.
   * @param queryGeometry - For point queries, the line from the query point to the "camera point",
   * for other geometries, the envelope of the query geometry and the "camera point"
   * @returns a geometry that includes all of the original query as well as all possible ares of the
   * screen where the *base* of a visible extrusion could be.
   *
   */
  getCameraQueryGeometry(queryGeometry) {
    const c = this.getCameraPoint();
    if (queryGeometry.length === 1) {
      return [queryGeometry[0], c];
    } else {
      let minX = c.x;
      let minY = c.y;
      let maxX = c.x;
      let maxY = c.y;
      for (const p of queryGeometry) {
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
      }
      return [new import_point_geometry3.default(minX, minY), new import_point_geometry3.default(maxX, minY), new import_point_geometry3.default(maxX, maxY), new import_point_geometry3.default(minX, maxY), new import_point_geometry3.default(minX, minY)];
    }
  }
  /**
   * Return the distance to the camera in clip space from a LngLat.
   * This can be compared to the value from the depth buffer (terrain.depthAtPoint)
   * to determine whether a point is occluded.
   * @param lngLat - the point
   * @param elevation - the point's elevation
   * @returns depth value in clip space (between 0 and 1)
   */
  lngLatToCameraDepth(lngLat, elevation) {
    const coord = this.locationCoordinate(lngLat);
    const p = [coord.x * this.worldSize, coord.y * this.worldSize, elevation, 1];
    vec4_exports.transformMat4(p, p, this.projMatrix);
    return p[2] / p[3];
  }
};

// node_modules/@antv/l7-map/es/map/handler_manager.js
var import_point_geometry10 = __toESM(require_point_geometry());

// node_modules/@antv/l7-map/es/map/util/dom.js
var import_point_geometry4 = __toESM(require_point_geometry());
var _class;
var DOM = class _DOM {
  static testProp(props) {
    if (!_DOM.docStyle)
      return props[0];
    for (let i2 = 0; i2 < props.length; i2++) {
      if (props[i2] in _DOM.docStyle) {
        return props[i2];
      }
    }
    return props[0];
  }
  static create(tagName, className, container) {
    const el = window.document.createElement(tagName);
    if (className !== void 0)
      el.className = className;
    if (container)
      container.appendChild(el);
    return el;
  }
  static createNS(namespaceURI, tagName) {
    const el = window.document.createElementNS(namespaceURI, tagName);
    return el;
  }
  static disableDrag() {
    if (_DOM.docStyle && _DOM.selectProp) {
      _DOM.userSelect = _DOM.docStyle[_DOM.selectProp];
      _DOM.docStyle[_DOM.selectProp] = "none";
    }
  }
  static enableDrag() {
    if (_DOM.docStyle && _DOM.selectProp) {
      _DOM.docStyle[_DOM.selectProp] = _DOM.userSelect;
    }
  }
  static setTransform(el, value) {
    el.style[_DOM.transformProp] = value;
  }
  static addEventListener(target, type, callback, options = {}) {
    if ("passive" in options) {
      target.addEventListener(type, callback, options);
    } else {
      target.addEventListener(type, callback, options.capture);
    }
  }
  static removeEventListener(target, type, callback, options = {}) {
    if ("passive" in options) {
      target.removeEventListener(type, callback, options);
    } else {
      target.removeEventListener(type, callback, options.capture);
    }
  }
  // Suppress the next click, but only if it's immediate.
  static suppressClickInternal(e) {
    e.preventDefault();
    e.stopPropagation();
    window.removeEventListener("click", _DOM.suppressClickInternal, true);
  }
  static suppressClick() {
    window.addEventListener("click", _DOM.suppressClickInternal, true);
    window.setTimeout(() => {
      window.removeEventListener("click", _DOM.suppressClickInternal, true);
    }, 0);
  }
  static getScale(element) {
    const rect = element.getBoundingClientRect();
    return {
      x: rect.width / element.offsetWidth || 1,
      y: rect.height / element.offsetHeight || 1,
      boundingClientRect: rect
    };
  }
  static getPoint(el, scale6, e) {
    const rect = scale6.boundingClientRect;
    return new import_point_geometry4.default(
      // rect.left/top values are in page scale (like clientX/Y),
      // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
      (e.clientX - rect.left) / scale6.x - el.clientLeft,
      (e.clientY - rect.top) / scale6.y - el.clientTop
    );
  }
  static mousePos(el, e) {
    const scale6 = _DOM.getScale(el);
    return _DOM.getPoint(el, scale6, e);
  }
  static touchPos(el, touches) {
    const points = [];
    const scale6 = _DOM.getScale(el);
    for (let i2 = 0; i2 < touches.length; i2++) {
      points.push(_DOM.getPoint(el, scale6, touches[i2]));
    }
    return points;
  }
  static mouseButton(e) {
    return e.button;
  }
  static remove(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
};
_class = DOM;
_defineProperty(DOM, "docStyle", typeof window !== "undefined" && window.document && window.document.documentElement.style);
_defineProperty(DOM, "userSelect", void 0);
_defineProperty(DOM, "selectProp", _class.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]));
_defineProperty(DOM, "transformProp", _class.testProp(["transform", "WebkitTransform"]));

// node_modules/@antv/l7-map/es/map/handler/transform-provider.js
var import_point_geometry5 = __toESM(require_point_geometry());
var TransformProvider = class {
  constructor(map) {
    _defineProperty(this, "_map", void 0);
    this._map = map;
  }
  get transform() {
    return this._map._requestedCameraState || this._map.transform;
  }
  get center() {
    return {
      lng: this.transform.center.lng,
      lat: this.transform.center.lat
    };
  }
  get zoom() {
    return this.transform.zoom;
  }
  get pitch() {
    return this.transform.pitch;
  }
  get bearing() {
    return this.transform.bearing;
  }
  unproject(point2) {
    return this.transform.pointLocation(import_point_geometry5.default.convert(point2));
  }
};

// node_modules/@antv/l7-map/es/map/handler/box_zoom.js
var BoxZoomHandler = class {
  /** @internal */
  constructor(map, options) {
    _defineProperty(this, "_map", void 0);
    _defineProperty(this, "_tr", void 0);
    _defineProperty(this, "_el", void 0);
    _defineProperty(this, "_container", void 0);
    _defineProperty(this, "_enabled", void 0);
    _defineProperty(this, "_active", void 0);
    _defineProperty(this, "_startPos", void 0);
    _defineProperty(this, "_lastPos", void 0);
    _defineProperty(this, "_box", void 0);
    _defineProperty(this, "_clickTolerance", void 0);
    this._map = map;
    this._tr = new TransformProvider(map);
    this._el = map.getCanvasContainer();
    this._container = map.getContainer();
    this._clickTolerance = options.clickTolerance || 1;
  }
  /**
   * Returns a Boolean indicating whether the "box zoom" interaction is enabled.
   *
   * @returns `true` if the "box zoom" interaction is enabled.
   */
  isEnabled() {
    return !!this._enabled;
  }
  /**
   * Returns a Boolean indicating whether the "box zoom" interaction is active, i.e. currently being used.
   *
   * @returns `true` if the "box zoom" interaction is active.
   */
  isActive() {
    return !!this._active;
  }
  /**
   * Enables the "box zoom" interaction.
   *
   * @example
   * ```ts
   * map.boxZoom.enable();
   * ```
   */
  enable() {
    if (this.isEnabled())
      return;
    this._enabled = true;
  }
  /**
   * Disables the "box zoom" interaction.
   *
   * @example
   * ```ts
   * map.boxZoom.disable();
   * ```
   */
  disable() {
    if (!this.isEnabled())
      return;
    this._enabled = false;
  }
  mousedown(e, point2) {
    if (!this.isEnabled())
      return;
    if (!(e.shiftKey && e.button === 0))
      return;
    DOM.disableDrag();
    this._startPos = this._lastPos = point2;
    this._active = true;
  }
  mousemoveWindow(e, point2) {
    if (!this._active)
      return;
    const pos = point2;
    if (this._lastPos.equals(pos) || !this._box && pos.dist(this._startPos) < this._clickTolerance) {
      return;
    }
    const p0 = this._startPos;
    this._lastPos = pos;
    if (!this._box) {
      this._box = DOM.create("div", "l7-boxzoom", this._container);
      this._container.classList.add("l7-crosshair");
      this._fireEvent("boxzoomstart", e);
    }
    const minX = Math.min(p0.x, pos.x), maxX = Math.max(p0.x, pos.x), minY = Math.min(p0.y, pos.y), maxY = Math.max(p0.y, pos.y);
    DOM.setTransform(this._box, `translate(${minX}px,${minY}px)`);
    this._box.style.width = `${maxX - minX}px`;
    this._box.style.height = `${maxY - minY}px`;
  }
  mouseupWindow(e, point2) {
    if (!this._active)
      return;
    if (e.button !== 0)
      return;
    const p0 = this._startPos, p1 = point2;
    this.reset();
    DOM.suppressClick();
    if (p0.x === p1.x && p0.y === p1.y) {
      this._fireEvent("boxzoomcancel", e);
    } else {
      this._map.fire(new Event2("boxzoomend", {
        originalEvent: e
      }));
      return {
        cameraAnimation: (map) => map.fitScreenCoordinates(p0, p1, this._tr.bearing, {
          linear: true
        })
      };
    }
  }
  keydown(e) {
    if (!this._active)
      return;
    if (e.keyCode === 27) {
      this.reset();
      this._fireEvent("boxzoomcancel", e);
    }
  }
  reset() {
    this._active = false;
    this._container.classList.remove("l7-crosshair");
    if (this._box) {
      DOM.remove(this._box);
      this._box = null;
    }
    DOM.enableDrag();
    delete this._startPos;
    delete this._lastPos;
  }
  _fireEvent(type, e) {
    return this._map.fire(new Event2(type, {
      originalEvent: e
    }));
  }
};

// node_modules/@antv/l7-map/es/map/handler/click_zoom.js
var ClickZoomHandler = class {
  /** @internal */
  constructor(map) {
    _defineProperty(this, "_tr", void 0);
    _defineProperty(this, "_enabled", void 0);
    _defineProperty(this, "_active", void 0);
    this._tr = new TransformProvider(map);
    this.reset();
  }
  reset() {
    this._active = false;
  }
  dblclick(e, point2) {
    e.preventDefault();
    return {
      cameraAnimation: (map) => {
        map.easeTo({
          duration: 300,
          zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
          around: this._tr.unproject(point2)
        }, {
          originalEvent: e
        });
      }
    };
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false;
    this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};

// node_modules/@antv/l7-map/es/map/handler/cooperative_gestures.js
var CooperativeGesturesHandler = class {
  constructor(map, options) {
    _defineProperty(this, "_options", void 0);
    _defineProperty(this, "_map", void 0);
    _defineProperty(this, "_container", void 0);
    _defineProperty(this, "_bypassKey", navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey");
    _defineProperty(this, "_enabled", void 0);
    this._map = map;
    this._options = options;
    this._enabled = false;
  }
  isActive() {
    return false;
  }
  reset() {
  }
  _setupUI() {
    if (this._container)
      return;
    const mapCanvasContainer = this._map.getCanvasContainer();
    mapCanvasContainer.classList.add("l7-cooperative-gestures");
    this._container = DOM.create("div", "l7-cooperative-gesture-screen", mapCanvasContainer);
    const desktopDiv = document.createElement("div");
    desktopDiv.className = "l7-desktop-message";
    desktopDiv.textContent = "Missing UI string";
    this._container.appendChild(desktopDiv);
    const mobileDiv = document.createElement("div");
    mobileDiv.className = "l7-mobile-message";
    mobileDiv.textContent = "Missing UI string";
    this._container.appendChild(mobileDiv);
    this._container.setAttribute("aria-hidden", "true");
  }
  _destoryUI() {
    if (this._container) {
      DOM.remove(this._container);
      const mapCanvasContainer = this._map.getCanvasContainer();
      mapCanvasContainer.classList.remove("l7-cooperative-gestures");
    }
    delete this._container;
  }
  enable() {
    this._setupUI();
    this._enabled = true;
  }
  disable() {
    this._enabled = false;
    this._destoryUI();
  }
  isEnabled() {
    return this._enabled;
  }
  touchmove(e) {
    this._onCooperativeGesture(e.touches.length === 1);
  }
  wheel(e) {
    if (!this._map.scrollZoom.isEnabled()) {
      return;
    }
    this._onCooperativeGesture(!e[this._bypassKey]);
  }
  _onCooperativeGesture(showNotification) {
    if (!this._enabled || !showNotification)
      return;
    this._container.classList.add("l7-show");
    setTimeout(() => {
      this._container.classList.remove("l7-show");
    }, 100);
  }
};

// node_modules/@antv/l7-map/es/map/handler/keyboard.js
var defaultOptions = {
  panStep: 100,
  bearingStep: 15,
  pitchStep: 10
};
var KeyboardHandler = class {
  /** @internal */
  constructor(map) {
    _defineProperty(this, "_tr", void 0);
    _defineProperty(this, "_enabled", void 0);
    _defineProperty(this, "_active", void 0);
    _defineProperty(this, "_panStep", void 0);
    _defineProperty(this, "_bearingStep", void 0);
    _defineProperty(this, "_pitchStep", void 0);
    _defineProperty(this, "_rotationDisabled", void 0);
    this._tr = new TransformProvider(map);
    const stepOptions = defaultOptions;
    this._panStep = stepOptions.panStep;
    this._bearingStep = stepOptions.bearingStep;
    this._pitchStep = stepOptions.pitchStep;
    this._rotationDisabled = false;
  }
  reset() {
    this._active = false;
  }
  keydown(e) {
    if (e.altKey || e.ctrlKey || e.metaKey)
      return;
    let zoomDir = 0;
    let bearingDir = 0;
    let pitchDir = 0;
    let xDir = 0;
    let yDir = 0;
    switch (e.keyCode) {
      case 61:
      case 107:
      case 171:
      case 187:
        zoomDir = 1;
        break;
      case 189:
      case 109:
      case 173:
        zoomDir = -1;
        break;
      case 37:
        if (e.shiftKey) {
          bearingDir = -1;
        } else {
          e.preventDefault();
          xDir = -1;
        }
        break;
      case 39:
        if (e.shiftKey) {
          bearingDir = 1;
        } else {
          e.preventDefault();
          xDir = 1;
        }
        break;
      case 38:
        if (e.shiftKey) {
          pitchDir = 1;
        } else {
          e.preventDefault();
          yDir = -1;
        }
        break;
      case 40:
        if (e.shiftKey) {
          pitchDir = -1;
        } else {
          e.preventDefault();
          yDir = 1;
        }
        break;
      default:
        return;
    }
    if (this._rotationDisabled) {
      bearingDir = 0;
      pitchDir = 0;
    }
    return {
      cameraAnimation: (map) => {
        const tr = this._tr;
        map.easeTo({
          duration: 300,
          easeId: "keyboardHandler",
          easing: easeOut,
          zoom: zoomDir ? Math.round(tr.zoom) + zoomDir * (e.shiftKey ? 2 : 1) : tr.zoom,
          bearing: tr.bearing + bearingDir * this._bearingStep,
          pitch: tr.pitch + pitchDir * this._pitchStep,
          offset: [-xDir * this._panStep, -yDir * this._panStep],
          center: tr.center
        }, {
          originalEvent: e
        });
      }
    };
  }
  /**
   * Enables the "keyboard rotate and zoom" interaction.
   *
   * @example
   * ```ts
   * map.keyboard.enable();
   * ```
   */
  enable() {
    this._enabled = true;
  }
  /**
   * Disables the "keyboard rotate and zoom" interaction.
   *
   * @example
   * ```ts
   * map.keyboard.disable();
   * ```
   */
  disable() {
    this._enabled = false;
    this.reset();
  }
  /**
   * Returns a Boolean indicating whether the "keyboard rotate and zoom"
   * interaction is enabled.
   *
   * @returns `true` if the "keyboard rotate and zoom"
   * interaction is enabled.
   */
  isEnabled() {
    return this._enabled;
  }
  /**
   * Returns true if the handler is enabled and has detected the start of a
   * zoom/rotate gesture.
   *
   * @returns `true` if the handler is enabled and has detected the
   * start of a zoom/rotate gesture.
   */
  isActive() {
    return this._active;
  }
  /**
   * Disables the "keyboard pan/rotate" interaction, leaving the
   * "keyboard zoom" interaction enabled.
   *
   * @example
   * ```ts
   * map.keyboard.disableRotation();
   * ```
   */
  disableRotation() {
    this._rotationDisabled = true;
  }
  /**
   * Enables the "keyboard pan/rotate" interaction.
   *
   * @example
   * ```ts
   * map.keyboard.enable();
   * map.keyboard.enableRotation();
   * ```
   */
  enableRotation() {
    this._rotationDisabled = false;
  }
};
function easeOut(t) {
  return t * (2 - t);
}

// node_modules/@antv/l7-map/es/map/events.js
var import_point_geometry6 = __toESM(require_point_geometry());
var MapMouseEvent = class extends Event2 {
  /**
   * Prevents subsequent default processing of the event by the map.
   *
   * Calling this method will prevent the following default map behaviors:
   *
   *   * On `mousedown` events, the behavior of {@link DragPanHandler}
   *   * On `mousedown` events, the behavior of {@link DragRotateHandler}
   *   * On `mousedown` events, the behavior of {@link BoxZoomHandler}
   *   * On `dblclick` events, the behavior of {@link DoubleClickZoomHandler}
   *
   */
  preventDefault() {
    this._defaultPrevented = true;
  }
  /**
   * `true` if `preventDefault` has been called.
   */
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(type, map, originalEvent, data = {}) {
    super(type, data);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "originalEvent", void 0);
    _defineProperty(this, "point", void 0);
    _defineProperty(this, "lngLat", void 0);
    _defineProperty(this, "_defaultPrevented", void 0);
    const point2 = DOM.mousePos(map.getCanvasContainer(), originalEvent);
    const lngLat = map.unproject(point2);
    this.point = point2;
    this.lngLat = lngLat;
    this.originalEvent = originalEvent;
    this._defaultPrevented = false;
    this.target = map;
  }
};
var MapTouchEvent = class extends Event2 {
  /**
   * Prevents subsequent default processing of the event by the map.
   *
   * Calling this method will prevent the following default map behaviors:
   *
   *   * On `touchstart` events, the behavior of {@link DragPanHandler}
   *   * On `touchstart` events, the behavior of {@link TwoFingersTouchZoomRotateHandler}
   *
   */
  preventDefault() {
    this._defaultPrevented = true;
  }
  /**
   * `true` if `preventDefault` has been called.
   */
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  constructor(type, map, originalEvent) {
    super(type);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "originalEvent", void 0);
    _defineProperty(this, "lngLat", void 0);
    _defineProperty(this, "point", void 0);
    _defineProperty(this, "points", void 0);
    _defineProperty(this, "lngLats", void 0);
    _defineProperty(this, "_defaultPrevented", void 0);
    const touches = type === "touchend" ? originalEvent.changedTouches : originalEvent.touches;
    const points = DOM.touchPos(map.getCanvasContainer(), touches);
    const lngLats = points.map((t) => map.unproject(t));
    const point2 = points.reduce((prev, curr, i2, arr) => {
      return prev.add(curr.div(arr.length));
    }, new import_point_geometry6.default(0, 0));
    const lngLat = map.unproject(point2);
    this.target = map;
    this.points = points;
    this.point = point2;
    this.lngLats = lngLats;
    this.lngLat = lngLat;
    this.originalEvent = originalEvent;
    this._defaultPrevented = false;
  }
};
var MapWheelEvent = class extends Event2 {
  /**
   * Prevents subsequent default processing of the event by the map.
   *
   * Calling this method will prevent the behavior of {@link ScrollZoomHandler}.
   */
  preventDefault() {
    this._defaultPrevented = true;
  }
  /**
   * `true` if `preventDefault` has been called.
   */
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  /** */
  constructor(type, map, originalEvent) {
    super(type);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "originalEvent", void 0);
    _defineProperty(this, "_defaultPrevented", void 0);
    this.target = map;
    this._defaultPrevented = false;
    this.originalEvent = originalEvent;
  }
};

// node_modules/@antv/l7-map/es/map/handler/map_event.js
var MapEventHandler = class {
  constructor(map, options) {
    _defineProperty(this, "_mousedownPos", void 0);
    _defineProperty(this, "_clickTolerance", void 0);
    _defineProperty(this, "_map", void 0);
    this._map = map;
    this._clickTolerance = options.clickTolerance;
  }
  reset() {
    delete this._mousedownPos;
  }
  wheel(e) {
    return this._firePreventable(new MapWheelEvent(e.type, this._map, e));
  }
  mousedown(e, point2) {
    this._mousedownPos = point2;
    return this._firePreventable(new MapMouseEvent(e.type, this._map, e));
  }
  mouseup(e) {
    this._map.fire(new MapMouseEvent(e.type, this._map, e));
  }
  click(e, point2) {
    if (this._mousedownPos && this._mousedownPos.dist(point2) >= this._clickTolerance)
      return;
    this._map.fire(new MapMouseEvent(e.type, this._map, e));
  }
  dblclick(e) {
    return this._firePreventable(new MapMouseEvent(e.type, this._map, e));
  }
  mouseover(e) {
    this._map.fire(new MapMouseEvent(e.type, this._map, e));
  }
  mouseout(e) {
    this._map.fire(new MapMouseEvent(e.type, this._map, e));
  }
  touchstart(e) {
    return this._firePreventable(new MapTouchEvent(e.type, this._map, e));
  }
  touchmove(e) {
    this._map.fire(new MapTouchEvent(e.type, this._map, e));
  }
  touchend(e) {
    this._map.fire(new MapTouchEvent(e.type, this._map, e));
  }
  touchcancel(e) {
    this._map.fire(new MapTouchEvent(e.type, this._map, e));
  }
  _firePreventable(mapEvent) {
    this._map.fire(mapEvent);
    if (mapEvent.defaultPrevented) {
      return {};
    }
  }
  isEnabled() {
    return true;
  }
  isActive() {
    return false;
  }
  enable() {
  }
  disable() {
  }
};
var BlockableMapEventHandler = class {
  constructor(map) {
    _defineProperty(this, "_map", void 0);
    _defineProperty(this, "_delayContextMenu", void 0);
    _defineProperty(this, "_ignoreContextMenu", void 0);
    _defineProperty(this, "_contextMenuEvent", void 0);
    this._map = map;
  }
  reset() {
    this._delayContextMenu = false;
    this._ignoreContextMenu = true;
    delete this._contextMenuEvent;
  }
  mousemove(e) {
    this._map.fire(new MapMouseEvent(e.type, this._map, e));
  }
  mousedown() {
    this._delayContextMenu = true;
    this._ignoreContextMenu = false;
  }
  mouseup() {
    this._delayContextMenu = false;
    if (this._contextMenuEvent) {
      this._map.fire(new MapMouseEvent("contextmenu", this._map, this._contextMenuEvent));
      delete this._contextMenuEvent;
    }
  }
  contextmenu(e) {
    if (this._delayContextMenu) {
      this._contextMenuEvent = e;
    } else if (!this._ignoreContextMenu) {
      this._map.fire(new MapMouseEvent(e.type, this._map, e));
    }
    if (this._map.listens("contextmenu")) {
      e.preventDefault();
    }
  }
  isEnabled() {
    return true;
  }
  isActive() {
    return false;
  }
  enable() {
  }
  disable() {
  }
};

// node_modules/@antv/l7-map/es/map/handler/drag_handler.js
var DragHandler = class {
  constructor(options) {
    _defineProperty(this, "contextmenu", void 0);
    _defineProperty(this, "mousedown", void 0);
    _defineProperty(this, "mousemoveWindow", void 0);
    _defineProperty(this, "mouseup", void 0);
    _defineProperty(this, "touchstart", void 0);
    _defineProperty(this, "touchmoveWindow", void 0);
    _defineProperty(this, "touchend", void 0);
    _defineProperty(this, "_clickTolerance", void 0);
    _defineProperty(this, "_moveFunction", void 0);
    _defineProperty(this, "_activateOnStart", void 0);
    _defineProperty(this, "_active", void 0);
    _defineProperty(this, "_enabled", void 0);
    _defineProperty(this, "_moved", void 0);
    _defineProperty(this, "_lastPoint", void 0);
    _defineProperty(this, "_moveStateManager", void 0);
    this._enabled = !!options.enable;
    this._moveStateManager = options.moveStateManager;
    this._clickTolerance = options.clickTolerance || 1;
    this._moveFunction = options.move;
    this._activateOnStart = !!options.activateOnStart;
    options.assignEvents(this);
    this.reset();
  }
  reset(e) {
    this._active = false;
    this._moved = false;
    delete this._lastPoint;
    this._moveStateManager.endMove(e);
  }
  _move(...params) {
    const move = this._moveFunction(...params);
    if (move.bearingDelta || move.pitchDelta || move.around || move.panDelta) {
      this._active = true;
      return move;
    }
  }
  dragStart(e, point2) {
    if (!this.isEnabled() || this._lastPoint)
      return;
    if (!this._moveStateManager.isValidStartEvent(e))
      return;
    this._moveStateManager.startMove(e);
    this._lastPoint = point2["length"] ? point2[0] : point2;
    if (this._activateOnStart && this._lastPoint)
      this._active = true;
  }
  dragMove(e, point2) {
    if (!this.isEnabled())
      return;
    const lastPoint = this._lastPoint;
    if (!lastPoint)
      return;
    e.preventDefault();
    if (!this._moveStateManager.isValidMoveEvent(e)) {
      this.reset(e);
      return;
    }
    const movePoint = point2["length"] ? point2[0] : point2;
    if (!this._moved && movePoint.dist(lastPoint) < this._clickTolerance)
      return;
    this._moved = true;
    this._lastPoint = movePoint;
    return this._move(lastPoint, movePoint);
  }
  dragEnd(e) {
    if (!this.isEnabled() || !this._lastPoint)
      return;
    if (!this._moveStateManager.isValidEndEvent(e))
      return;
    if (this._moved)
      DOM.suppressClick();
    this.reset(e);
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false;
    this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
  getClickTolerance() {
    return this._clickTolerance;
  }
};

// node_modules/@antv/l7-map/es/map/handler/drag_move_state_manager.js
var LEFT_BUTTON = 0;
var RIGHT_BUTTON = 2;
var BUTTONS_FLAGS = {
  [LEFT_BUTTON]: 1,
  [RIGHT_BUTTON]: 2
};
function buttonNoLongerPressed(e, button) {
  const flag = BUTTONS_FLAGS[button];
  return e.buttons === void 0 || (e.buttons & flag) !== flag;
}
var MouseMoveStateManager = class {
  constructor(options) {
    _defineProperty(this, "_eventButton", void 0);
    _defineProperty(this, "_correctEvent", void 0);
    this._correctEvent = options.checkCorrectEvent;
  }
  startMove(e) {
    const eventButton = DOM.mouseButton(e);
    this._eventButton = eventButton;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  endMove(_e) {
    delete this._eventButton;
  }
  isValidStartEvent(e) {
    return this._correctEvent(e);
  }
  isValidMoveEvent(e) {
    return !buttonNoLongerPressed(e, this._eventButton);
  }
  isValidEndEvent(e) {
    const eventButton = DOM.mouseButton(e);
    return eventButton === this._eventButton;
  }
};

// node_modules/@antv/l7-map/es/map/handler/mouse.js
var LEFT_BUTTON2 = 0;
var RIGHT_BUTTON2 = 2;
var assignEvents = (handler) => {
  handler.mousedown = handler.dragStart;
  handler.mousemoveWindow = handler.dragMove;
  handler.mouseup = handler.dragEnd;
  handler.contextmenu = (e) => {
    e.preventDefault();
  };
};
var generateMousePanHandler = ({
  enable,
  clickTolerance
}) => {
  const mouseMoveStateManager = new MouseMoveStateManager({
    checkCorrectEvent: (e) => DOM.mouseButton(e) === LEFT_BUTTON2 && !e.ctrlKey
  });
  return new DragHandler({
    clickTolerance,
    move: (lastPoint, point2) => ({
      around: point2,
      panDelta: point2.sub(lastPoint)
    }),
    activateOnStart: true,
    moveStateManager: mouseMoveStateManager,
    enable,
    assignEvents
  });
};
var generateMouseRotationHandler = ({
  enable,
  clickTolerance,
  bearingDegreesPerPixelMoved = 0.8
}) => {
  const mouseMoveStateManager = new MouseMoveStateManager({
    checkCorrectEvent: (e) => DOM.mouseButton(e) === LEFT_BUTTON2 && e.ctrlKey || DOM.mouseButton(e) === RIGHT_BUTTON2
  });
  return new DragHandler({
    clickTolerance,
    move: (lastPoint, point2) => ({
      bearingDelta: (point2.x - lastPoint.x) * bearingDegreesPerPixelMoved
    }),
    // prevent browser context menu when necessary; we don't allow it with rotation
    // because we can't discern rotation gesture start from contextmenu on Mac
    moveStateManager: mouseMoveStateManager,
    enable,
    assignEvents
  });
};
var generateMousePitchHandler = ({
  enable,
  clickTolerance,
  pitchDegreesPerPixelMoved = -0.5
}) => {
  const mouseMoveStateManager = new MouseMoveStateManager({
    checkCorrectEvent: (e) => DOM.mouseButton(e) === LEFT_BUTTON2 && e.ctrlKey || DOM.mouseButton(e) === RIGHT_BUTTON2
  });
  return new DragHandler({
    clickTolerance,
    move: (lastPoint, point2) => ({
      pitchDelta: (point2.y - lastPoint.y) * pitchDegreesPerPixelMoved
    }),
    // prevent browser context menu when necessary; we don't allow it with rotation
    // because we can't discern rotation gesture start from contextmenu on Mac
    moveStateManager: mouseMoveStateManager,
    enable,
    assignEvents
  });
};

// node_modules/@antv/l7-map/es/map/handler/scroll_zoom.js
var wheelZoomDelta = 4.000244140625;
var defaultZoomRate = 1 / 100;
var wheelZoomRate = 1 / 450;
var maxScalePerFrame = 2;
var ScrollZoomHandler = class {
  /** @internal */
  constructor(map, triggerRenderFrame) {
    _defineProperty(this, "_map", void 0);
    _defineProperty(this, "_tr", void 0);
    _defineProperty(this, "_enabled", void 0);
    _defineProperty(this, "_active", void 0);
    _defineProperty(this, "_zooming", void 0);
    _defineProperty(this, "_aroundCenter", void 0);
    _defineProperty(this, "_around", void 0);
    _defineProperty(this, "_aroundPoint", void 0);
    _defineProperty(this, "_type", void 0);
    _defineProperty(this, "_lastValue", void 0);
    _defineProperty(this, "_timeout", void 0);
    _defineProperty(this, "_finishTimeout", void 0);
    _defineProperty(this, "_lastWheelEvent", void 0);
    _defineProperty(this, "_lastWheelEventTime", void 0);
    _defineProperty(this, "_startZoom", void 0);
    _defineProperty(this, "_targetZoom", void 0);
    _defineProperty(this, "_delta", void 0);
    _defineProperty(this, "_easing", void 0);
    _defineProperty(this, "_prevEase", void 0);
    _defineProperty(this, "_frameId", void 0);
    _defineProperty(this, "_triggerRenderFrame", void 0);
    _defineProperty(this, "_defaultZoomRate", void 0);
    _defineProperty(this, "_wheelZoomRate", void 0);
    _defineProperty(this, "_onTimeout", (initialEvent) => {
      this._type = "wheel";
      this._delta -= this._lastValue;
      if (!this._active) {
        this._start(initialEvent);
      }
    });
    this._map = map;
    this._tr = new TransformProvider(map);
    this._triggerRenderFrame = triggerRenderFrame;
    this._delta = 0;
    this._defaultZoomRate = defaultZoomRate;
    this._wheelZoomRate = wheelZoomRate;
  }
  /**
   * Set the zoom rate of a trackpad
   * @param zoomRate - 1/100 The rate used to scale trackpad movement to a zoom value.
   * @example
   * Speed up trackpad zoom
   * ```ts
   * map.scrollZoom.setZoomRate(1/25);
   * ```
   */
  setZoomRate(zoomRate) {
    this._defaultZoomRate = zoomRate;
  }
  /**
   * Set the zoom rate of a mouse wheel
   * @param wheelZoomRate - 1/450 The rate used to scale mouse wheel movement to a zoom value.
   * @example
   * Slow down zoom of mouse wheel
   * ```ts
   * map.scrollZoom.setWheelZoomRate(1/600);
   * ```
   */
  setWheelZoomRate(wheelZoomRate2) {
    this._wheelZoomRate = wheelZoomRate2;
  }
  /**
   * Returns a Boolean indicating whether the "scroll to zoom" interaction is enabled.
   * @returns `true` if the "scroll to zoom" interaction is enabled.
   */
  isEnabled() {
    return !!this._enabled;
  }
  /*
   * Active state is turned on and off with every scroll wheel event and is set back to false before the map
   * render is called, so _active is not a good candidate for determining if a scroll zoom animation is in
   * progress.
   */
  isActive() {
    return !!this._active || this._finishTimeout !== void 0;
  }
  isZooming() {
    return !!this._zooming;
  }
  /**
   * Enables the "scroll to zoom" interaction.
   *
   * @param options - Options object.
   * @example
   * ```ts
   * map.scrollZoom.enable();
   * map.scrollZoom.enable({ around: 'center' })
   * ```
   */
  enable(options) {
    if (this.isEnabled())
      return;
    this._enabled = true;
    this._aroundCenter = !!options && options.around === "center";
  }
  /**
   * Disables the "scroll to zoom" interaction.
   *
   * @example
   * ```ts
   * map.scrollZoom.disable();
   * ```
   */
  disable() {
    if (!this.isEnabled())
      return;
    this._enabled = false;
  }
  wheel(e) {
    if (!this.isEnabled())
      return;
    if (this._map.cooperativeGestures.isEnabled() && !e[this._map.cooperativeGestures._bypassKey]) {
      return;
    }
    let value = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? e.deltaY * 40 : e.deltaY;
    const now2 = browser.now(), timeDelta = now2 - (this._lastWheelEventTime || 0);
    this._lastWheelEventTime = now2;
    if (value !== 0 && value % wheelZoomDelta === 0) {
      this._type = "wheel";
    } else if (value !== 0 && Math.abs(value) < 4) {
      this._type = "trackpad";
    } else if (timeDelta > 400) {
      this._type = null;
      this._lastValue = value;
      this._timeout = setTimeout(this._onTimeout, 40, e);
    } else if (!this._type) {
      this._type = Math.abs(timeDelta * value) < 200 ? "trackpad" : "wheel";
      if (this._timeout) {
        clearTimeout(this._timeout);
        this._timeout = null;
        value += this._lastValue;
      }
    }
    if (e.shiftKey && value)
      value = value / 4;
    if (this._type) {
      this._lastWheelEvent = e;
      this._delta -= value;
      if (!this._active) {
        this._start(e);
      }
    }
    e.preventDefault();
  }
  _start(e) {
    if (!this._delta)
      return;
    if (this._frameId) {
      this._frameId = null;
    }
    this._active = true;
    if (!this.isZooming()) {
      this._zooming = true;
    }
    if (this._finishTimeout) {
      clearTimeout(this._finishTimeout);
      delete this._finishTimeout;
    }
    const pos = DOM.mousePos(this._map.getCanvasContainer(), e);
    const tr = this._tr;
    if (pos.y > tr.transform.height / 2 - tr.transform.getHorizon()) {
      this._around = LngLat.convert(this._aroundCenter ? tr.center : tr.unproject(pos));
    } else {
      this._around = LngLat.convert(tr.center);
    }
    this._aroundPoint = tr.transform.locationPoint(this._around);
    if (!this._frameId) {
      this._frameId = true;
      this._triggerRenderFrame();
    }
  }
  renderFrame() {
    if (!this._frameId)
      return;
    this._frameId = null;
    if (!this.isActive())
      return;
    const tr = this._tr.transform;
    if (this._delta !== 0) {
      const zoomRate = this._type === "wheel" && Math.abs(this._delta) > wheelZoomDelta ? this._wheelZoomRate : this._defaultZoomRate;
      let scale6 = maxScalePerFrame / (1 + Math.exp(-Math.abs(this._delta * zoomRate)));
      if (this._delta < 0 && scale6 !== 0) {
        scale6 = 1 / scale6;
      }
      const fromScale = typeof this._targetZoom === "number" ? tr.zoomScale(this._targetZoom) : tr.scale;
      this._targetZoom = Math.min(tr.maxZoom, Math.max(tr.minZoom, tr.scaleZoom(fromScale * scale6)));
      if (this._type === "wheel") {
        this._startZoom = tr.zoom;
        this._easing = this._smoothOutEasing(200);
      }
      this._delta = 0;
    }
    const targetZoom = typeof this._targetZoom === "number" ? this._targetZoom : tr.zoom;
    const startZoom = this._startZoom;
    const easing = this._easing;
    let finished = false;
    let zoom;
    if (this._type === "wheel" && startZoom && easing) {
      const t = Math.min((browser.now() - this._lastWheelEventTime) / 200, 1);
      const k = easing(t);
      zoom = interpolates.number(startZoom, targetZoom, k);
      if (t < 1) {
        if (!this._frameId) {
          this._frameId = true;
        }
      } else {
        finished = true;
      }
    } else {
      zoom = targetZoom;
      finished = true;
    }
    this._active = true;
    if (finished) {
      this._active = false;
      this._finishTimeout = setTimeout(() => {
        this._zooming = false;
        this._triggerRenderFrame();
        delete this._targetZoom;
        delete this._finishTimeout;
      }, 200);
    }
    return {
      noInertia: true,
      needsRenderFrame: !finished,
      zoomDelta: zoom - tr.zoom,
      around: this._aroundPoint,
      originalEvent: this._lastWheelEvent
    };
  }
  _smoothOutEasing(duration) {
    let easing = defaultEasing;
    if (this._prevEase) {
      const currentEase = this._prevEase;
      const t = (browser.now() - currentEase.start) / currentEase.duration;
      const speed = currentEase.easing(t + 0.01) - currentEase.easing(t);
      const x2 = 0.27 / Math.sqrt(speed * speed + 1e-4) * 0.01;
      const y = Math.sqrt(0.27 * 0.27 - x2 * x2);
      easing = bezier2(x2, y, 0.25, 1);
    }
    this._prevEase = {
      start: browser.now(),
      duration,
      easing
    };
    return easing;
  }
  reset() {
    this._active = false;
    this._zooming = false;
    delete this._targetZoom;
    if (this._finishTimeout) {
      clearTimeout(this._finishTimeout);
      delete this._finishTimeout;
    }
  }
};

// node_modules/@antv/l7-map/es/map/handler/shim/dblclick_zoom.js
var DoubleClickZoomHandler = class {
  /** @internal */
  constructor(clickZoom, TapZoom) {
    _defineProperty(this, "_clickZoom", void 0);
    _defineProperty(this, "_tapZoom", void 0);
    this._clickZoom = clickZoom;
    this._tapZoom = TapZoom;
  }
  /**
   * Enables the "double click to zoom" interaction.
   *
   * @example
   * ```ts
   * map.doubleClickZoom.enable();
   * ```
   */
  enable() {
    this._clickZoom.enable();
    this._tapZoom.enable();
  }
  /**
   * Disables the "double click to zoom" interaction.
   *
   * @example
   * ```ts
   * map.doubleClickZoom.disable();
   * ```
   */
  disable() {
    this._clickZoom.disable();
    this._tapZoom.disable();
  }
  /**
   * Returns a Boolean indicating whether the "double click to zoom" interaction is enabled.
   *
   * @returns `true` if the "double click to zoom" interaction is enabled.
   */
  isEnabled() {
    return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
  }
  /**
   * Returns a Boolean indicating whether the "double click to zoom" interaction is active, i.e. currently being used.
   *
   * @returns `true` if the "double click to zoom" interaction is active.
   */
  isActive() {
    return this._clickZoom.isActive() || this._tapZoom.isActive();
  }
};

// node_modules/@antv/l7-map/es/map/handler/shim/drag_pan.js
var DragPanHandler = class {
  /** @internal */
  constructor(el, mousePan, touchPan) {
    _defineProperty(this, "_el", void 0);
    _defineProperty(this, "_mousePan", void 0);
    _defineProperty(this, "_touchPan", void 0);
    _defineProperty(this, "_inertiaOptions", void 0);
    this._el = el;
    this._mousePan = mousePan;
    this._touchPan = touchPan;
  }
  /**
   * Enables the "drag to pan" interaction.
   *
   * @param options - Options object
   * @example
   * ```ts
   *   map.dragPan.enable();
   *   map.dragPan.enable({
   *      linearity: 0.3,
   *      easing: bezier(0, 0, 0.3, 1),
   *      maxSpeed: 1400,
   *      deceleration: 2500,
   *   });
   * ```
   */
  enable(options) {
    this._inertiaOptions = options || {};
    this._mousePan.enable();
    this._touchPan.enable();
    this._el.classList.add("l7-touch-drag-pan");
  }
  /**
   * Disables the "drag to pan" interaction.
   *
   * @example
   * ```ts
   * map.dragPan.disable();
   * ```
   */
  disable() {
    this._mousePan.disable();
    this._touchPan.disable();
    this._el.classList.remove("l7-touch-drag-pan");
  }
  /**
   * Returns a Boolean indicating whether the "drag to pan" interaction is enabled.
   *
   * @returns `true` if the "drag to pan" interaction is enabled.
   */
  isEnabled() {
    return this._mousePan.isEnabled() && this._touchPan.isEnabled();
  }
  /**
   * Returns a Boolean indicating whether the "drag to pan" interaction is active, i.e. currently being used.
   *
   * @returns `true` if the "drag to pan" interaction is active.
   */
  isActive() {
    return this._mousePan.isActive() || this._touchPan.isActive();
  }
};

// node_modules/@antv/l7-map/es/map/handler/shim/drag_rotate.js
var DragRotateHandler = class {
  /** @internal */
  constructor(options, mouseRotate, mousePitch) {
    _defineProperty(this, "_mouseRotate", void 0);
    _defineProperty(this, "_mousePitch", void 0);
    _defineProperty(this, "_pitchWithRotate", void 0);
    this._pitchWithRotate = options.pitchWithRotate;
    this._mouseRotate = mouseRotate;
    this._mousePitch = mousePitch;
  }
  /**
   * Enables the "drag to rotate" interaction.
   *
   * @example
   * ```ts
   * map.dragRotate.enable();
   * ```
   */
  enable() {
    this._mouseRotate.enable();
    if (this._pitchWithRotate)
      this._mousePitch.enable();
  }
  /**
   * Disables the "drag to rotate" interaction.
   *
   * @example
   * ```ts
   * map.dragRotate.disable();
   * ```
   */
  disable() {
    this._mouseRotate.disable();
    this._mousePitch.disable();
  }
  /**
   * Returns a Boolean indicating whether the "drag to rotate" interaction is enabled.
   *
   * @returns `true` if the "drag to rotate" interaction is enabled.
   */
  isEnabled() {
    return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
  }
  /**
   * Returns a Boolean indicating whether the "drag to rotate" interaction is active, i.e. currently being used.
   *
   * @returns `true` if the "drag to rotate" interaction is active.
   */
  isActive() {
    return this._mouseRotate.isActive() || this._mousePitch.isActive();
  }
};

// node_modules/@antv/l7-map/es/map/handler/shim/two_fingers_touch.js
var TwoFingersTouchZoomRotateHandler = class {
  /** @internal */
  constructor(el, touchZoom, touchRotate, tapDragZoom) {
    _defineProperty(this, "_el", void 0);
    _defineProperty(this, "_touchZoom", void 0);
    _defineProperty(this, "_touchRotate", void 0);
    _defineProperty(this, "_tapDragZoom", void 0);
    _defineProperty(this, "_rotationDisabled", void 0);
    _defineProperty(this, "_enabled", void 0);
    this._el = el;
    this._touchZoom = touchZoom;
    this._touchRotate = touchRotate;
    this._tapDragZoom = tapDragZoom;
    this._rotationDisabled = false;
    this._enabled = true;
  }
  /**
   * Enables the "pinch to rotate and zoom" interaction.
   *
   * @param options - Options object.
   *
   * @example
   * ```ts
   * map.touchZoomRotate.enable();
   * map.touchZoomRotate.enable({ around: 'center' });
   * ```
   */
  enable(options) {
    this._touchZoom.enable(options);
    if (!this._rotationDisabled)
      this._touchRotate.enable(options);
    this._tapDragZoom.enable();
    this._el.classList.add("l7-touch-zoom-rotate");
  }
  /**
   * Disables the "pinch to rotate and zoom" interaction.
   *
   * @example
   * ```ts
   * map.touchZoomRotate.disable();
   * ```
   */
  disable() {
    this._touchZoom.disable();
    this._touchRotate.disable();
    this._tapDragZoom.disable();
    this._el.classList.remove("l7-touch-zoom-rotate");
  }
  /**
   * Returns a Boolean indicating whether the "pinch to rotate and zoom" interaction is enabled.
   *
   * @returns `true` if the "pinch to rotate and zoom" interaction is enabled.
   */
  isEnabled() {
    return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
  }
  /**
   * Returns true if the handler is enabled and has detected the start of a zoom/rotate gesture.
   *
   * @returns `true` if the handler is active, `false` otherwise
   */
  isActive() {
    return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
  }
  /**
   * Disables the "pinch to rotate" interaction, leaving the "pinch to zoom"
   * interaction enabled.
   *
   * @example
   * ```ts
   * map.touchZoomRotate.disableRotation();
   * ```
   */
  disableRotation() {
    this._rotationDisabled = true;
    this._touchRotate.disable();
  }
  /**
   * Enables the "pinch to rotate" interaction.
   *
   * @example
   * ```ts
   * map.touchZoomRotate.enable();
   * map.touchZoomRotate.enableRotation();
   * ```
   */
  enableRotation() {
    this._rotationDisabled = false;
    if (this._touchZoom.isEnabled())
      this._touchRotate.enable();
  }
};

// node_modules/@antv/l7-map/es/map/handler/tap_recognizer.js
var import_point_geometry7 = __toESM(require_point_geometry());

// node_modules/@antv/l7-map/es/map/handler/handler_util.js
function indexTouches(touches, points) {
  if (touches.length !== points.length)
    throw new Error(`The number of touches and points are not equal - touches ${touches.length}, points ${points.length}`);
  const obj = {};
  for (let i2 = 0; i2 < touches.length; i2++) {
    obj[touches[i2].identifier] = points[i2];
  }
  return obj;
}

// node_modules/@antv/l7-map/es/map/handler/tap_recognizer.js
function getCentroid(points) {
  const sum2 = new import_point_geometry7.default(0, 0);
  for (const point2 of points) {
    sum2._add(point2);
  }
  return sum2.div(points.length);
}
var MAX_TAP_INTERVAL = 500;
var MAX_TOUCH_TIME = 500;
var MAX_DIST = 30;
var SingleTapRecognizer = class {
  constructor(options) {
    _defineProperty(this, "numTouches", void 0);
    _defineProperty(this, "centroid", void 0);
    _defineProperty(this, "startTime", void 0);
    _defineProperty(this, "aborted", void 0);
    _defineProperty(this, "touches", void 0);
    this.reset();
    this.numTouches = options.numTouches;
  }
  reset() {
    delete this.centroid;
    delete this.startTime;
    delete this.touches;
    this.aborted = false;
  }
  touchstart(e, points, mapTouches) {
    if (this.centroid || mapTouches.length > this.numTouches) {
      this.aborted = true;
    }
    if (this.aborted) {
      return;
    }
    if (this.startTime === void 0) {
      this.startTime = e.timeStamp;
    }
    if (mapTouches.length === this.numTouches) {
      this.centroid = getCentroid(points);
      this.touches = indexTouches(mapTouches, points);
    }
  }
  touchmove(e, points, mapTouches) {
    if (this.aborted || !this.centroid)
      return;
    const newTouches = indexTouches(mapTouches, points);
    for (const id2 in this.touches) {
      const prevPos = this.touches[id2];
      const pos = newTouches[id2];
      if (!pos || pos.dist(prevPos) > MAX_DIST) {
        this.aborted = true;
      }
    }
  }
  touchend(e, points, mapTouches) {
    if (!this.centroid || e.timeStamp - this.startTime > MAX_TOUCH_TIME) {
      this.aborted = true;
    }
    if (mapTouches.length === 0) {
      const centroid = !this.aborted && this.centroid;
      this.reset();
      if (centroid)
        return centroid;
    }
  }
};
var TapRecognizer = class {
  constructor(options) {
    _defineProperty(this, "singleTap", void 0);
    _defineProperty(this, "numTaps", void 0);
    _defineProperty(this, "lastTime", void 0);
    _defineProperty(this, "lastTap", void 0);
    _defineProperty(this, "count", void 0);
    this.singleTap = new SingleTapRecognizer(options);
    this.numTaps = options.numTaps;
    this.reset();
  }
  reset() {
    this.lastTime = Infinity;
    delete this.lastTap;
    this.count = 0;
    this.singleTap.reset();
  }
  touchstart(e, points, mapTouches) {
    this.singleTap.touchstart(e, points, mapTouches);
  }
  touchmove(e, points, mapTouches) {
    this.singleTap.touchmove(e, points, mapTouches);
  }
  touchend(e, points, mapTouches) {
    const tap = this.singleTap.touchend(e, points, mapTouches);
    if (tap) {
      const soonEnough = e.timeStamp - this.lastTime < MAX_TAP_INTERVAL;
      const closeEnough = !this.lastTap || this.lastTap.dist(tap) < MAX_DIST;
      if (!soonEnough || !closeEnough) {
        this.reset();
      }
      this.count++;
      this.lastTime = e.timeStamp;
      this.lastTap = tap;
      if (this.count === this.numTaps) {
        this.reset();
        return tap;
      }
    }
  }
};

// node_modules/@antv/l7-map/es/map/handler/tap_drag_zoom.js
var TapDragZoomHandler = class {
  constructor() {
    _defineProperty(this, "_enabled", void 0);
    _defineProperty(this, "_active", void 0);
    _defineProperty(this, "_swipePoint", void 0);
    _defineProperty(this, "_swipeTouch", void 0);
    _defineProperty(this, "_tapTime", void 0);
    _defineProperty(this, "_tapPoint", void 0);
    _defineProperty(this, "_tap", void 0);
    this._tap = new TapRecognizer({
      numTouches: 1,
      numTaps: 1
    });
    this.reset();
  }
  reset() {
    this._active = false;
    delete this._swipePoint;
    delete this._swipeTouch;
    delete this._tapTime;
    delete this._tapPoint;
    this._tap.reset();
  }
  touchstart(e, points, mapTouches) {
    if (this._swipePoint)
      return;
    if (!this._tapTime) {
      this._tap.touchstart(e, points, mapTouches);
    } else {
      const swipePoint = points[0];
      const soonEnough = e.timeStamp - this._tapTime < MAX_TAP_INTERVAL;
      const closeEnough = this._tapPoint.dist(swipePoint) < MAX_DIST;
      if (!soonEnough || !closeEnough) {
        this.reset();
      } else if (mapTouches.length > 0) {
        this._swipePoint = swipePoint;
        this._swipeTouch = mapTouches[0].identifier;
      }
    }
  }
  touchmove(e, points, mapTouches) {
    if (!this._tapTime) {
      this._tap.touchmove(e, points, mapTouches);
    } else if (this._swipePoint) {
      if (mapTouches[0].identifier !== this._swipeTouch) {
        return;
      }
      const newSwipePoint = points[0];
      const dist4 = newSwipePoint.y - this._swipePoint.y;
      this._swipePoint = newSwipePoint;
      e.preventDefault();
      this._active = true;
      return {
        zoomDelta: dist4 / 128
      };
    }
  }
  touchend(e, points, mapTouches) {
    if (!this._tapTime) {
      const point2 = this._tap.touchend(e, points, mapTouches);
      if (point2) {
        this._tapTime = e.timeStamp;
        this._tapPoint = point2;
      }
    } else if (this._swipePoint) {
      if (mapTouches.length === 0) {
        this.reset();
      }
    }
  }
  touchcancel() {
    this.reset();
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false;
    this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};

// node_modules/@antv/l7-map/es/map/handler/tap_zoom.js
var TapZoomHandler = class {
  constructor(map) {
    _defineProperty(this, "_tr", void 0);
    _defineProperty(this, "_enabled", void 0);
    _defineProperty(this, "_active", void 0);
    _defineProperty(this, "_zoomIn", void 0);
    _defineProperty(this, "_zoomOut", void 0);
    this._tr = new TransformProvider(map);
    this._zoomIn = new TapRecognizer({
      numTouches: 1,
      numTaps: 2
    });
    this._zoomOut = new TapRecognizer({
      numTouches: 2,
      numTaps: 1
    });
    this.reset();
  }
  reset() {
    this._active = false;
    this._zoomIn.reset();
    this._zoomOut.reset();
  }
  touchstart(e, points, mapTouches) {
    this._zoomIn.touchstart(e, points, mapTouches);
    this._zoomOut.touchstart(e, points, mapTouches);
  }
  touchmove(e, points, mapTouches) {
    this._zoomIn.touchmove(e, points, mapTouches);
    this._zoomOut.touchmove(e, points, mapTouches);
  }
  touchend(e, points, mapTouches) {
    const zoomInPoint = this._zoomIn.touchend(e, points, mapTouches);
    const zoomOutPoint = this._zoomOut.touchend(e, points, mapTouches);
    const tr = this._tr;
    if (zoomInPoint) {
      this._active = true;
      e.preventDefault();
      setTimeout(() => this.reset(), 0);
      return {
        cameraAnimation: (map) => map.easeTo({
          duration: 300,
          zoom: tr.zoom + 1,
          around: tr.unproject(zoomInPoint)
        }, {
          originalEvent: e
        })
      };
    } else if (zoomOutPoint) {
      this._active = true;
      e.preventDefault();
      setTimeout(() => this.reset(), 0);
      return {
        cameraAnimation: (map) => map.easeTo({
          duration: 300,
          zoom: tr.zoom - 1,
          around: tr.unproject(zoomOutPoint)
        }, {
          originalEvent: e
        })
      };
    }
  }
  touchcancel() {
    this.reset();
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false;
    this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};

// node_modules/@antv/l7-map/es/map/handler/touch_pan.js
var import_point_geometry8 = __toESM(require_point_geometry());
var TouchPanHandler = class {
  constructor(options, map) {
    _defineProperty(this, "_enabled", void 0);
    _defineProperty(this, "_active", void 0);
    _defineProperty(this, "_touches", void 0);
    _defineProperty(this, "_clickTolerance", void 0);
    _defineProperty(this, "_sum", void 0);
    _defineProperty(this, "_map", void 0);
    this._clickTolerance = options.clickTolerance || 1;
    this._map = map;
    this.reset();
  }
  reset() {
    this._active = false;
    this._touches = {};
    this._sum = new import_point_geometry8.default(0, 0);
  }
  minTouchs() {
    return this._map.cooperativeGestures.isEnabled() ? 2 : 1;
  }
  touchstart(e, points, mapTouches) {
    return this._calculateTransform(e, points, mapTouches);
  }
  touchmove(e, points, mapTouches) {
    if (!this._active || mapTouches.length < this.minTouchs())
      return;
    e.preventDefault();
    return this._calculateTransform(e, points, mapTouches);
  }
  touchend(e, points, mapTouches) {
    this._calculateTransform(e, points, mapTouches);
    if (this._active && mapTouches.length < this.minTouchs()) {
      this.reset();
    }
  }
  touchcancel() {
    this.reset();
  }
  _calculateTransform(e, points, mapTouches) {
    if (mapTouches.length > 0)
      this._active = true;
    const touches = indexTouches(mapTouches, points);
    const touchPointSum = new import_point_geometry8.default(0, 0);
    const touchDeltaSum = new import_point_geometry8.default(0, 0);
    let touchDeltaCount = 0;
    for (const identifier in touches) {
      const point2 = touches[identifier];
      const prevPoint = this._touches[identifier];
      if (prevPoint) {
        touchPointSum._add(point2);
        touchDeltaSum._add(point2.sub(prevPoint));
        touchDeltaCount++;
        touches[identifier] = point2;
      }
    }
    this._touches = touches;
    if (touchDeltaCount < this.minTouchs() || !touchDeltaSum.mag())
      return;
    const panDelta = touchDeltaSum.div(touchDeltaCount);
    this._sum._add(panDelta);
    if (this._sum.mag() < this._clickTolerance)
      return;
    const around = touchPointSum.div(touchDeltaCount);
    return {
      around,
      panDelta
    };
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false;
    this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
};

// node_modules/@antv/l7-map/es/map/handler/two_fingers_touch.js
var TwoFingersTouchHandler = class {
  /** @internal */
  constructor() {
    _defineProperty(this, "_enabled", void 0);
    _defineProperty(this, "_active", void 0);
    _defineProperty(this, "_firstTwoTouches", void 0);
    _defineProperty(this, "_vector", void 0);
    _defineProperty(this, "_startVector", void 0);
    _defineProperty(this, "_aroundCenter", void 0);
    this.reset();
  }
  reset() {
    this._active = false;
    delete this._firstTwoTouches;
  }
  touchstart(e, points, mapTouches) {
    if (this._firstTwoTouches || mapTouches.length < 2)
      return;
    this._firstTwoTouches = [mapTouches[0].identifier, mapTouches[1].identifier];
    this._start([points[0], points[1]]);
  }
  touchmove(e, points, mapTouches) {
    if (!this._firstTwoTouches)
      return;
    e.preventDefault();
    const [idA, idB] = this._firstTwoTouches;
    const a = getTouchById(mapTouches, points, idA);
    const b = getTouchById(mapTouches, points, idB);
    if (!a || !b)
      return;
    const pinchAround = this._aroundCenter ? null : a.add(b).div(2);
    return this._move([a, b], pinchAround, e);
  }
  touchend(e, points, mapTouches) {
    if (!this._firstTwoTouches)
      return;
    const [idA, idB] = this._firstTwoTouches;
    const a = getTouchById(mapTouches, points, idA);
    const b = getTouchById(mapTouches, points, idB);
    if (a && b)
      return;
    if (this._active)
      DOM.suppressClick();
    this.reset();
  }
  touchcancel() {
    this.reset();
  }
  /**
   * Enables the "drag to pitch" interaction.
   *
   * @example
   * ```ts
   * map.touchPitch.enable();
   * ```
   */
  enable(options) {
    this._enabled = true;
    this._aroundCenter = !!options && options.around === "center";
  }
  /**
   * Disables the "drag to pitch" interaction.
   *
   * @example
   * ```ts
   * map.touchPitch.disable();
   * ```
   */
  disable() {
    this._enabled = false;
    this.reset();
  }
  /**
   * Returns a Boolean indicating whether the "drag to pitch" interaction is enabled.
   *
   * @returns  `true` if the "drag to pitch" interaction is enabled.
   */
  isEnabled() {
    return !!this._enabled;
  }
  /**
   * Returns a Boolean indicating whether the "drag to pitch" interaction is active, i.e. currently being used.
   *
   * @returns `true` if the "drag to pitch" interaction is active.
   */
  isActive() {
    return !!this._active;
  }
};
function getTouchById(mapTouches, points, identifier) {
  for (let i2 = 0; i2 < mapTouches.length; i2++) {
    if (mapTouches[i2].identifier === identifier)
      return points[i2];
  }
  return void 0;
}
var ZOOM_THRESHOLD = 0.1;
function getZoomDelta(distance4, lastDistance) {
  return Math.log(distance4 / lastDistance) / Math.LN2;
}
var TwoFingersTouchZoomHandler = class extends TwoFingersTouchHandler {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "_distance", void 0);
    _defineProperty(this, "_startDistance", void 0);
  }
  reset() {
    super.reset();
    delete this._distance;
    delete this._startDistance;
  }
  _start(points) {
    this._startDistance = this._distance = points[0].dist(points[1]);
  }
  _move(points, pinchAround) {
    const lastDistance = this._distance;
    this._distance = points[0].dist(points[1]);
    if (!this._active && Math.abs(getZoomDelta(this._distance, this._startDistance)) < ZOOM_THRESHOLD)
      return;
    this._active = true;
    return {
      zoomDelta: getZoomDelta(this._distance, lastDistance),
      pinchAround
    };
  }
};
var ROTATION_THRESHOLD = 25;
function getBearingDelta(a, b) {
  return a.angleWith(b) * 180 / Math.PI;
}
var TwoFingersTouchRotateHandler = class extends TwoFingersTouchHandler {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "_minDiameter", void 0);
  }
  reset() {
    super.reset();
    delete this._minDiameter;
    delete this._startVector;
    delete this._vector;
  }
  _start(points) {
    this._startVector = this._vector = points[0].sub(points[1]);
    this._minDiameter = points[0].dist(points[1]);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _move(points, pinchAround, _e) {
    const lastVector = this._vector;
    this._vector = points[0].sub(points[1]);
    if (!this._active && this._isBelowThreshold(this._vector))
      return;
    this._active = true;
    return {
      bearingDelta: getBearingDelta(this._vector, lastVector),
      pinchAround
    };
  }
  _isBelowThreshold(vector) {
    this._minDiameter = Math.min(this._minDiameter, vector.mag());
    const circumference = Math.PI * this._minDiameter;
    const threshold = ROTATION_THRESHOLD / circumference * 360;
    const bearingDeltaSinceStart = getBearingDelta(vector, this._startVector);
    return Math.abs(bearingDeltaSinceStart) < threshold;
  }
};
function isVertical(vector) {
  return Math.abs(vector.y) > Math.abs(vector.x);
}
var ALLOWED_SINGLE_TOUCH_TIME = 100;
var TwoFingersTouchPitchHandler = class extends TwoFingersTouchHandler {
  constructor(map) {
    super();
    _defineProperty(this, "_valid", void 0);
    _defineProperty(this, "_firstMove", void 0);
    _defineProperty(this, "_lastPoints", void 0);
    _defineProperty(this, "_map", void 0);
    _defineProperty(this, "_currentTouchCount", 0);
    this._map = map;
  }
  reset() {
    super.reset();
    this._valid = void 0;
    delete this._firstMove;
    delete this._lastPoints;
  }
  touchstart(e, points, mapTouches) {
    super.touchstart(e, points, mapTouches);
    this._currentTouchCount = mapTouches.length;
  }
  _start(points) {
    this._lastPoints = points;
    if (isVertical(points[0].sub(points[1]))) {
      this._valid = false;
    }
  }
  _move(points, center, e) {
    if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) {
      return;
    }
    const vectorA = points[0].sub(this._lastPoints[0]);
    const vectorB = points[1].sub(this._lastPoints[1]);
    this._valid = this.gestureBeginsVertically(vectorA, vectorB, e.timeStamp);
    if (!this._valid)
      return;
    this._lastPoints = points;
    this._active = true;
    const yDeltaAverage = (vectorA.y + vectorB.y) / 2;
    const degreesPerPixelMoved = -0.5;
    return {
      pitchDelta: yDeltaAverage * degreesPerPixelMoved
    };
  }
  gestureBeginsVertically(vectorA, vectorB, timeStamp) {
    if (this._valid !== void 0)
      return this._valid;
    const threshold = 2;
    const movedA = vectorA.mag() >= threshold;
    const movedB = vectorB.mag() >= threshold;
    if (!movedA && !movedB)
      return;
    if (!movedA || !movedB) {
      if (this._firstMove === void 0) {
        this._firstMove = timeStamp;
      }
      if (timeStamp - this._firstMove < ALLOWED_SINGLE_TOUCH_TIME) {
        return void 0;
      } else {
        return false;
      }
    }
    const isSameDirection = vectorA.y > 0 === vectorB.y > 0;
    return isVertical(vectorA) && isVertical(vectorB) && isSameDirection;
  }
};

// node_modules/@antv/l7-map/es/map/handler_inertia.js
var import_point_geometry9 = __toESM(require_point_geometry());
var defaultInertiaOptions = {
  linearity: 0.3,
  easing: bezier2(0, 0, 0.3, 1)
};
var defaultPanInertiaOptions = extend2({
  deceleration: 2500,
  maxSpeed: 1400
}, defaultInertiaOptions);
var defaultZoomInertiaOptions = extend2({
  deceleration: 20,
  maxSpeed: 1400
}, defaultInertiaOptions);
var defaultBearingInertiaOptions = extend2({
  deceleration: 1e3,
  maxSpeed: 360
}, defaultInertiaOptions);
var defaultPitchInertiaOptions = extend2({
  deceleration: 1e3,
  maxSpeed: 90
}, defaultInertiaOptions);
var HandlerInertia = class {
  constructor(map) {
    _defineProperty(this, "_map", void 0);
    _defineProperty(this, "_inertiaBuffer", void 0);
    this._map = map;
    this.clear();
  }
  clear() {
    this._inertiaBuffer = [];
  }
  record(settings) {
    this._drainInertiaBuffer();
    this._inertiaBuffer.push({
      time: browser.now(),
      settings
    });
  }
  _drainInertiaBuffer() {
    const inertia = this._inertiaBuffer, now2 = browser.now(), cutoff = 160;
    while (inertia.length > 0 && now2 - inertia[0].time > cutoff)
      inertia.shift();
  }
  _onMoveEnd(panInertiaOptions) {
    this._drainInertiaBuffer();
    if (this._inertiaBuffer.length < 2) {
      return;
    }
    const deltas = {
      zoom: 0,
      bearing: 0,
      pitch: 0,
      pan: new import_point_geometry9.default(0, 0),
      pinchAround: void 0,
      around: void 0
    };
    for (const {
      settings
    } of this._inertiaBuffer) {
      deltas.zoom += settings.zoomDelta || 0;
      deltas.bearing += settings.bearingDelta || 0;
      deltas.pitch += settings.pitchDelta || 0;
      if (settings.panDelta)
        deltas.pan._add(settings.panDelta);
      if (settings.around)
        deltas.around = settings.around;
      if (settings.pinchAround)
        deltas.pinchAround = settings.pinchAround;
    }
    const lastEntry = this._inertiaBuffer[this._inertiaBuffer.length - 1];
    const duration = lastEntry.time - this._inertiaBuffer[0].time;
    const easeOptions = {};
    if (deltas.pan.mag()) {
      const result = calculateEasing(deltas.pan.mag(), duration, extend2({}, defaultPanInertiaOptions, panInertiaOptions || {}));
      easeOptions.offset = deltas.pan.mult(result.amount / deltas.pan.mag());
      easeOptions.center = this._map.transform.center;
      extendDuration(easeOptions, result);
    }
    if (deltas.zoom) {
      const result = calculateEasing(deltas.zoom, duration, defaultZoomInertiaOptions);
      easeOptions.zoom = this._map.transform.zoom + result.amount;
      extendDuration(easeOptions, result);
    }
    if (deltas.bearing) {
      const result = calculateEasing(deltas.bearing, duration, defaultBearingInertiaOptions);
      easeOptions.bearing = this._map.transform.bearing + clamp3(result.amount, -179, 179);
      extendDuration(easeOptions, result);
    }
    if (deltas.pitch) {
      const result = calculateEasing(deltas.pitch, duration, defaultPitchInertiaOptions);
      easeOptions.pitch = this._map.transform.pitch + result.amount;
      extendDuration(easeOptions, result);
    }
    if (easeOptions.zoom || easeOptions.bearing) {
      const last = deltas.pinchAround === void 0 ? deltas.around : deltas.pinchAround;
      easeOptions.around = last ? this._map.unproject(last) : this._map.getCenter();
    }
    this.clear();
    return extend2(easeOptions, {
      noMoveStart: true
    });
  }
};
function extendDuration(easeOptions, result) {
  if (!easeOptions.duration || easeOptions.duration < result.duration) {
    easeOptions.duration = result.duration;
    easeOptions.easing = result.easing;
  }
}
function calculateEasing(amount, inertiaDuration, inertiaOptions) {
  const {
    maxSpeed,
    linearity,
    deceleration
  } = inertiaOptions;
  const speed = clamp3(amount * linearity / (inertiaDuration / 1e3), -maxSpeed, maxSpeed);
  const duration = Math.abs(speed) / (deceleration * linearity);
  return {
    easing: inertiaOptions.easing,
    duration: duration * 1e3,
    amount: speed * (duration / 2)
  };
}

// node_modules/@antv/l7-map/es/map/handler_manager.js
var isMoving = (p) => p.zoom || p.drag || p.pitch || p.rotate;
var RenderFrameEvent = class extends Event2 {
  constructor(type, timeStamp) {
    super(type);
    _defineProperty(this, "type", "renderFrame");
    _defineProperty(this, "timeStamp", void 0);
    this.timeStamp = timeStamp;
  }
};
function hasChange(result) {
  return result.panDelta && result.panDelta.mag() || result.zoomDelta || result.bearingDelta || result.pitchDelta;
}
var HandlerManager = class {
  constructor(map, options) {
    _defineProperty(this, "_map", void 0);
    _defineProperty(this, "_el", void 0);
    _defineProperty(this, "_handlers", void 0);
    _defineProperty(this, "_eventsInProgress", void 0);
    _defineProperty(this, "_frameId", void 0);
    _defineProperty(this, "_inertia", void 0);
    _defineProperty(this, "_bearingSnap", void 0);
    _defineProperty(this, "_handlersById", void 0);
    _defineProperty(this, "_updatingCamera", void 0);
    _defineProperty(this, "_changes", void 0);
    _defineProperty(this, "_zoom", void 0);
    _defineProperty(this, "_previousActiveHandlers", void 0);
    _defineProperty(this, "_listeners", void 0);
    _defineProperty(this, "handleWindowEvent", (e) => {
      this.handleEvent(e, `${e.type}Window`);
    });
    _defineProperty(this, "handleEvent", (e, eventName) => {
      if (e.type === "blur") {
        this.stop(true);
        return;
      }
      this._updatingCamera = true;
      const inputEvent = e.type === "renderFrame" ? void 0 : e;
      const mergedHandlerResult = {
        needsRenderFrame: false
      };
      const eventsInProgress = {};
      const activeHandlers = {};
      const eventTouches = e.touches;
      const mapTouches = eventTouches ? this._getMapTouches(eventTouches) : void 0;
      const points = mapTouches ? DOM.touchPos(this._map.getCanvasContainer(), mapTouches) : DOM.mousePos(this._map.getCanvasContainer(), e);
      for (const {
        handlerName,
        handler,
        allowed
      } of this._handlers) {
        if (!handler.isEnabled())
          continue;
        let data;
        if (this._blockedByActive(activeHandlers, allowed, handlerName)) {
          handler.reset();
        } else {
          if (handler[eventName || e.type]) {
            data = handler[eventName || e.type](e, points, mapTouches);
            this.mergeHandlerResult(mergedHandlerResult, eventsInProgress, data, handlerName, inputEvent);
            if (data && data.needsRenderFrame) {
              this._triggerRenderFrame();
            }
          }
        }
        if (data || handler.isActive()) {
          activeHandlers[handlerName] = handler;
        }
      }
      const deactivatedHandlers = {};
      for (const name in this._previousActiveHandlers) {
        if (!activeHandlers[name]) {
          deactivatedHandlers[name] = inputEvent;
        }
      }
      this._previousActiveHandlers = activeHandlers;
      if (Object.keys(deactivatedHandlers).length || hasChange(mergedHandlerResult)) {
        this._changes.push([mergedHandlerResult, eventsInProgress, deactivatedHandlers]);
        this._triggerRenderFrame();
      }
      if (Object.keys(activeHandlers).length || hasChange(mergedHandlerResult)) {
        this._map._stop(true);
      }
      this._updatingCamera = false;
      const {
        cameraAnimation
      } = mergedHandlerResult;
      if (cameraAnimation) {
        this._inertia.clear();
        this._fireEvents({}, {}, true);
        this._changes = [];
        cameraAnimation(this._map);
      }
    });
    this._map = map;
    this._el = this._map.getCanvasContainer();
    this._handlers = [];
    this._handlersById = {};
    this._changes = [];
    this._inertia = new HandlerInertia(map);
    this._bearingSnap = options.bearingSnap || 7;
    this._previousActiveHandlers = {};
    this._eventsInProgress = {};
    this._addDefaultHandlers(options);
    const el = this._el;
    this._listeners = [
      // This needs to be `passive: true` so that a double tap fires two
      // pairs of touchstart/end events in iOS Safari 13. If this is set to
      // `passive: false` then the second pair of events is only fired if
      // preventDefault() is called on the first touchstart. Calling preventDefault()
      // undesirably prevents click events.
      [el, "touchstart", {
        passive: true
      }],
      // This needs to be `passive: false` so that scrolls and pinches can be
      // prevented in browsers that don't support `touch-actions: none`, for example iOS Safari 12.
      [el, "touchmove", {
        passive: false
      }],
      [el, "touchend", void 0],
      [el, "touchcancel", void 0],
      [el, "mousedown", void 0],
      [el, "mousemove", void 0],
      [el, "mouseup", void 0],
      // Bind window-level event listeners for move and up/end events. In the absence of
      // the pointer capture API, which is not supported by all necessary platforms,
      // window-level event listeners give us the best shot at capturing events that
      // fall outside the map canvas element. Use `{capture: true}` for the move event
      // to prevent map move events from being fired during a drag.
      [document, "mousemove", {
        capture: true
      }],
      [document, "mouseup", void 0],
      [el, "mouseover", void 0],
      [el, "mouseout", void 0],
      [el, "dblclick", void 0],
      [el, "click", void 0],
      [el, "keydown", {
        capture: false
      }],
      [el, "keyup", void 0],
      [el, "wheel", {
        passive: false
      }],
      [el, "contextmenu", void 0],
      [window, "blur", void 0]
    ];
    for (const [target, type, listenerOptions] of this._listeners) {
      DOM.addEventListener(target, type, target === document ? this.handleWindowEvent : this.handleEvent, listenerOptions);
    }
  }
  destroy() {
    for (const [target, type, listenerOptions] of this._listeners) {
      DOM.removeEventListener(target, type, target === document ? this.handleWindowEvent : this.handleEvent, listenerOptions);
    }
  }
  _addDefaultHandlers(options) {
    const map = this._map;
    const el = map.getCanvasContainer();
    this._add("mapEvent", new MapEventHandler(map, options));
    const boxZoom = map.boxZoom = new BoxZoomHandler(map, options);
    this._add("boxZoom", boxZoom);
    if (options.interactive && options.boxZoom) {
      boxZoom.enable();
    }
    const cooperativeGestures = map.cooperativeGestures = new CooperativeGesturesHandler(map, options.cooperativeGestures);
    this._add("cooperativeGestures", cooperativeGestures);
    if (options.cooperativeGestures) {
      cooperativeGestures.enable();
    }
    const tapZoom = new TapZoomHandler(map);
    const clickZoom = new ClickZoomHandler(map);
    map.doubleClickZoom = new DoubleClickZoomHandler(clickZoom, tapZoom);
    this._add("tapZoom", tapZoom);
    this._add("clickZoom", clickZoom);
    if (options.interactive && options.doubleClickZoom) {
      map.doubleClickZoom.enable();
    }
    const tapDragZoom = new TapDragZoomHandler();
    this._add("tapDragZoom", tapDragZoom);
    const touchPitch = map.touchPitch = new TwoFingersTouchPitchHandler(map);
    this._add("touchPitch", touchPitch);
    if (options.interactive && options.touchPitch) {
      map.touchPitch.enable(options.touchPitch);
    }
    const mouseRotate = generateMouseRotationHandler(options);
    const mousePitch = generateMousePitchHandler(options);
    map.dragRotate = new DragRotateHandler(options, mouseRotate, mousePitch);
    this._add("mouseRotate", mouseRotate, ["mousePitch"]);
    this._add("mousePitch", mousePitch, ["mouseRotate"]);
    if (options.interactive && options.dragRotate) {
      map.dragRotate.enable();
    }
    const mousePan = generateMousePanHandler(options);
    const touchPan = new TouchPanHandler(options, map);
    map.dragPan = new DragPanHandler(el, mousePan, touchPan);
    this._add("mousePan", mousePan);
    this._add("touchPan", touchPan, ["touchZoom", "touchRotate"]);
    if (options.interactive && options.dragPan) {
      map.dragPan.enable(options.dragPan);
    }
    const touchRotate = new TwoFingersTouchRotateHandler();
    const touchZoom = new TwoFingersTouchZoomHandler();
    map.touchZoomRotate = new TwoFingersTouchZoomRotateHandler(el, touchZoom, touchRotate, tapDragZoom);
    this._add("touchRotate", touchRotate, ["touchPan", "touchZoom"]);
    this._add("touchZoom", touchZoom, ["touchPan", "touchRotate"]);
    if (options.interactive && options.touchZoomRotate) {
      map.touchZoomRotate.enable(options.touchZoomRotate);
    }
    const scrollZoom = map.scrollZoom = new ScrollZoomHandler(map, () => this._triggerRenderFrame());
    this._add("scrollZoom", scrollZoom, ["mousePan"]);
    if (options.interactive && options.scrollZoom) {
      map.scrollZoom.enable(options.scrollZoom);
    }
    const keyboard = map.keyboard = new KeyboardHandler(map);
    this._add("keyboard", keyboard);
    if (options.interactive && options.keyboard) {
      map.keyboard.enable();
    }
    this._add("blockableMapEvent", new BlockableMapEventHandler(map));
  }
  _add(handlerName, handler, allowed) {
    this._handlers.push({
      handlerName,
      handler,
      allowed
    });
    this._handlersById[handlerName] = handler;
  }
  stop(allowEndAnimation) {
    if (this._updatingCamera)
      return;
    for (const {
      handler
    } of this._handlers) {
      handler.reset();
    }
    this._inertia.clear();
    this._fireEvents({}, {}, allowEndAnimation);
    this._changes = [];
  }
  isActive() {
    for (const {
      handler
    } of this._handlers) {
      if (handler.isActive())
        return true;
    }
    return false;
  }
  isZooming() {
    return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
  }
  isRotating() {
    return !!this._eventsInProgress.rotate;
  }
  isMoving() {
    return Boolean(isMoving(this._eventsInProgress)) || this.isZooming();
  }
  _blockedByActive(activeHandlers, allowed, myName) {
    for (const name in activeHandlers) {
      if (name === myName)
        continue;
      if (!allowed || allowed.indexOf(name) < 0) {
        return true;
      }
    }
    return false;
  }
  _getMapTouches(touches) {
    const mapTouches = [];
    for (const t of touches) {
      const target = t.target;
      if (this._el.contains(target)) {
        mapTouches.push(t);
      }
    }
    return mapTouches;
  }
  mergeHandlerResult(mergedHandlerResult, eventsInProgress, handlerResult, name, e) {
    if (!handlerResult)
      return;
    extend2(mergedHandlerResult, handlerResult);
    const eventData = {
      handlerName: name,
      originalEvent: handlerResult.originalEvent || e
    };
    if (handlerResult.zoomDelta !== void 0) {
      eventsInProgress.zoom = eventData;
    }
    if (handlerResult.panDelta !== void 0) {
      eventsInProgress.drag = eventData;
    }
    if (handlerResult.pitchDelta !== void 0) {
      eventsInProgress.pitch = eventData;
    }
    if (handlerResult.bearingDelta !== void 0) {
      eventsInProgress.rotate = eventData;
    }
  }
  _applyChanges() {
    const combined = {};
    const combinedEventsInProgress = {};
    const combinedDeactivatedHandlers = {};
    for (const [change, eventsInProgress, deactivatedHandlers] of this._changes) {
      if (change.panDelta)
        combined.panDelta = (combined.panDelta || new import_point_geometry10.default(0, 0))._add(change.panDelta);
      if (change.zoomDelta)
        combined.zoomDelta = (combined.zoomDelta || 0) + change.zoomDelta;
      if (change.bearingDelta)
        combined.bearingDelta = (combined.bearingDelta || 0) + change.bearingDelta;
      if (change.pitchDelta)
        combined.pitchDelta = (combined.pitchDelta || 0) + change.pitchDelta;
      if (change.around !== void 0)
        combined.around = change.around;
      if (change.pinchAround !== void 0)
        combined.pinchAround = change.pinchAround;
      if (change.noInertia)
        combined.noInertia = change.noInertia;
      extend2(combinedEventsInProgress, eventsInProgress);
      extend2(combinedDeactivatedHandlers, deactivatedHandlers);
    }
    this._updateMapTransform(combined, combinedEventsInProgress, combinedDeactivatedHandlers);
    this._changes = [];
  }
  _updateMapTransform(combinedResult, combinedEventsInProgress, deactivatedHandlers) {
    const map = this._map;
    const tr = map._getTransformForUpdate();
    if (!hasChange(combinedResult)) {
      return this._fireEvents(combinedEventsInProgress, deactivatedHandlers, true);
    }
    const {
      panDelta,
      zoomDelta,
      bearingDelta,
      pitchDelta,
      pinchAround
    } = combinedResult;
    let {
      around
    } = combinedResult;
    if (pinchAround !== void 0) {
      around = pinchAround;
    }
    map._stop(true);
    around = around || map.transform.centerPoint;
    const loc = tr.pointLocation(panDelta ? around.sub(panDelta) : around);
    if (bearingDelta)
      tr.bearing += bearingDelta;
    if (pitchDelta)
      tr.pitch += pitchDelta;
    if (zoomDelta)
      tr.zoom += zoomDelta;
    tr.setLocationAtPoint(loc, around);
    map._applyUpdatedTransform(tr);
    this._map._update();
    if (!combinedResult.noInertia)
      this._inertia.record(combinedResult);
    this._fireEvents(combinedEventsInProgress, deactivatedHandlers, true);
  }
  _fireEvents(newEventsInProgress, deactivatedHandlers, allowEndAnimation) {
    const wasMoving = isMoving(this._eventsInProgress);
    const nowMoving = isMoving(newEventsInProgress);
    const startEvents = {};
    for (const eventName in newEventsInProgress) {
      const {
        originalEvent
      } = newEventsInProgress[eventName];
      if (!this._eventsInProgress[eventName]) {
        startEvents[`${eventName}start`] = originalEvent;
      }
      this._eventsInProgress[eventName] = newEventsInProgress[eventName];
    }
    if (!wasMoving && nowMoving) {
      this._fireEvent("movestart", nowMoving.originalEvent);
    }
    for (const name in startEvents) {
      this._fireEvent(name, startEvents[name]);
    }
    if (nowMoving) {
      this._fireEvent("move", nowMoving.originalEvent);
    }
    for (const eventName in newEventsInProgress) {
      const {
        originalEvent
      } = newEventsInProgress[eventName];
      this._fireEvent(eventName, originalEvent);
    }
    const endEvents = {};
    let originalEndEvent;
    for (const eventName in this._eventsInProgress) {
      const {
        handlerName,
        originalEvent
      } = this._eventsInProgress[eventName];
      if (!this._handlersById[handlerName].isActive()) {
        delete this._eventsInProgress[eventName];
        originalEndEvent = deactivatedHandlers[handlerName] || originalEvent;
        endEvents[`${eventName}end`] = originalEndEvent;
      }
    }
    for (const name in endEvents) {
      this._fireEvent(name, endEvents[name]);
    }
    const stillMoving = isMoving(this._eventsInProgress);
    const finishedMoving = (wasMoving || nowMoving) && !stillMoving;
    if (allowEndAnimation && finishedMoving) {
      this._updatingCamera = true;
      const inertialEase = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions);
      const shouldSnapToNorth = (bearing) => bearing !== 0 && -this._bearingSnap < bearing && bearing < this._bearingSnap;
      if (inertialEase && (inertialEase.essential || !browser.prefersReducedMotion)) {
        if (shouldSnapToNorth(inertialEase.bearing || this._map.getBearing())) {
          inertialEase.bearing = 0;
        }
        inertialEase.freezeElevation = true;
        this._map.easeTo(inertialEase, {
          originalEvent: originalEndEvent
        });
      } else {
        this._map.fire(new Event2("moveend", {
          originalEvent: originalEndEvent
        }));
        if (shouldSnapToNorth(this._map.getBearing())) {
          this._map.resetNorth();
        }
      }
      this._updatingCamera = false;
    }
  }
  _fireEvent(type, e) {
    this._map.fire(new Event2(type, e ? {
      originalEvent: e
    } : {}));
  }
  _requestFrame() {
    this._map.triggerRepaint();
    return this._map._renderTaskQueue.add((timeStamp) => {
      delete this._frameId;
      this.handleEvent(new RenderFrameEvent("renderFrame", timeStamp));
      this._applyChanges();
    });
  }
  _triggerRenderFrame() {
    if (this._frameId === void 0) {
      this._frameId = this._requestFrame();
    }
  }
};

// node_modules/@antv/l7-map/es/map/util/task_queue.js
var TaskQueue = class {
  constructor() {
    _defineProperty(this, "_queue", void 0);
    _defineProperty(this, "_id", void 0);
    _defineProperty(this, "_cleared", void 0);
    _defineProperty(this, "_currentlyRunning", void 0);
    this._queue = [];
    this._id = 0;
    this._cleared = false;
    this._currentlyRunning = false;
  }
  add(callback) {
    const id2 = ++this._id;
    const queue = this._queue;
    queue.push({
      callback,
      id: id2,
      cancelled: false
    });
    return id2;
  }
  remove(id2) {
    const running = this._currentlyRunning;
    const queue = running ? this._queue.concat(running) : this._queue;
    for (const task of queue) {
      if (task.id === id2) {
        task.cancelled = true;
        return;
      }
    }
  }
  run(timeStamp = 0) {
    if (this._currentlyRunning)
      throw new Error("Attempting to run(), but is already running.");
    const queue = this._currentlyRunning = this._queue;
    this._queue = [];
    for (const task of queue) {
      if (task.cancelled)
        continue;
      task.callback(timeStamp);
      if (this._cleared)
        break;
    }
    this._cleared = false;
    this._currentlyRunning = false;
  }
  clear() {
    if (this._currentlyRunning) {
      this._cleared = true;
    }
    this._queue = [];
  }
};

// node_modules/@antv/l7-map/es/map/map.js
function loadStyles3(css, doc) {
  var isMiniAli = typeof my !== "undefined" && !!my && typeof my.showToast === "function" && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== "undefined" && wx !== null && (typeof wx.request !== "undefined" || typeof wx.miniProgram !== "undefined");
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc)
    doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName("head")[0];
  if (!head) {
    head = doc.createElement("head");
    var body = doc.body || doc.getElementsByTagName("body")[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement("style");
  style.type = "text/css";
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles3(`.l7-map {
  font:
    12px/20px 'Helvetica Neue',
    Arial,
    Helvetica,
    sans-serif;
  overflow: hidden;
  position: relative;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}

.l7-canvas {
  position: absolute;
  left: 0;
  top: 0;
}

.l7-map:-webkit-full-screen {
  width: 100%;
  height: 100%;
}

.l7-canary {
  background-color: salmon;
}

.l7-canvas-container.l7-interactive,
.l7-ctrl-group button.l7-ctrl-compass {
  cursor: grab;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

.l7-canvas-container.l7-interactive.l7-track-pointer {
  cursor: pointer;
}

.l7-canvas-container.l7-interactive:active,
.l7-ctrl-group button.l7-ctrl-compass:active {
  cursor: grabbing;
}

.l7-canvas-container.l7-touch-zoom-rotate,
.l7-canvas-container.l7-touch-zoom-rotate .l7-canvas {
  touch-action: pan-x pan-y;
}

.l7-canvas-container.l7-touch-drag-pan,
.l7-canvas-container.l7-touch-drag-pan .l7-canvas {
  touch-action: pinch-zoom;
}

.l7-canvas-container.l7-touch-zoom-rotate.l7-touch-drag-pan,
.l7-canvas-container.l7-touch-zoom-rotate.l7-touch-drag-pan .l7-canvas {
  touch-action: none;
}

.l7-canvas-container.l7-touch-drag-pan.l7-cooperative-gestures,
.l7-canvas-container.l7-touch-drag-pan.l7-cooperative-gestures .l7-canvas {
  touch-action: pan-x pan-y;
}

.l7-cooperative-gesture-screen {
  background: rgba(0 0 0 / 40%);
  position: absolute;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  padding: 1rem;
  font-size: 1.4em;
  line-height: 1.2;
  opacity: 0;
  pointer-events: none;
  transition: opacity 1s ease 1s;
  z-index: 99999;
}

.l7-cooperative-gesture-screen.l7-show {
  opacity: 1;
  transition: opacity 0.05s;
}

.l7-cooperative-gesture-screen .l7-mobile-message {
  display: none;
}

@media (hover: none), (width <= 480px) {
  .l7-cooperative-gesture-screen .l7-desktop-message {
    display: none;
  }

  .l7-cooperative-gesture-screen .l7-mobile-message {
    display: block;
  }
}

.l7-ctrl-top-left,
.l7-ctrl-top-right,
.l7-ctrl-bottom-left,
.l7-ctrl-bottom-right {
  position: absolute;
  pointer-events: none;
  z-index: 2;
}
.l7-ctrl-top-left {
  top: 0;
  left: 0;
}
.l7-ctrl-top-right {
  top: 0;
  right: 0;
}
.l7-ctrl-bottom-left {
  bottom: 0;
  left: 0;
}
.l7-ctrl-bottom-right {
  right: 0;
  bottom: 0;
}

.l7-ctrl {
  clear: both;
  pointer-events: auto;

  /* workaround for a Safari bug https://github.com/mapbox/mapbox-gl-js/issues/8185 */
  -webkit-transform: translate(0, 0);
          transform: translate(0, 0);
}
.l7-ctrl-top-left .l7-ctrl {
  margin: 10px 0 0 10px;
  float: left;
}
.l7-ctrl-top-right .l7-ctrl {
  margin: 10px 10px 0 0;
  float: right;
}
.l7-ctrl-bottom-left .l7-ctrl {
  margin: 0 0 10px 10px;
  float: left;
}
.l7-ctrl-bottom-right .l7-ctrl {
  margin: 0 10px 10px 0;
  float: right;
}

.l7-crosshair,
.l7-crosshair .l7-interactive,
.l7-crosshair .l7-interactive:active {
  cursor: crosshair;
}

.l7-boxzoom {
  position: absolute;
  top: 0;
  left: 0;
  width: 0;
  height: 0;
  background: #fff;
  border: 2px dotted #202020;
  opacity: 0.5;
  z-index: 10;
}
`);
var defaultMinZoom = -2;
var defaultMaxZoom = 22;
var defaultMinPitch = 0;
var defaultMaxPitch = 60;
var maxPitchThreshold = 85;
var defaultOptions2 = {
  interactive: true,
  bearingSnap: 7,
  scrollZoom: true,
  minZoom: defaultMinZoom,
  maxZoom: defaultMaxZoom,
  minPitch: defaultMinPitch,
  maxPitch: defaultMaxPitch,
  boxZoom: true,
  dragRotate: true,
  dragPan: true,
  keyboard: true,
  doubleClickZoom: true,
  touchZoomRotate: true,
  touchPitch: true,
  cooperativeGestures: false,
  trackResize: true,
  center: [0, 0],
  zoom: 0,
  bearing: 0,
  pitch: 0,
  renderWorldCopies: true,
  fadeDuration: 300,
  clickTolerance: 3,
  pitchWithRotate: true
};
var Map2 = class extends Camera {
  constructor(options) {
    const resolvedOptions = _objectSpread2(_objectSpread2({}, defaultOptions2), options);
    if (resolvedOptions.minZoom != null && resolvedOptions.maxZoom != null && resolvedOptions.minZoom > resolvedOptions.maxZoom) {
      throw new Error("maxZoom must be greater than or equal to minZoom");
    }
    if (resolvedOptions.minPitch != null && resolvedOptions.maxPitch != null && resolvedOptions.minPitch > resolvedOptions.maxPitch) {
      throw new Error("maxPitch must be greater than or equal to minPitch");
    }
    if (resolvedOptions.minPitch != null && resolvedOptions.minPitch < defaultMinPitch) {
      throw new Error(`minPitch must be greater than or equal to ${defaultMinPitch}`);
    }
    if (resolvedOptions.maxPitch != null && resolvedOptions.maxPitch > maxPitchThreshold) {
      throw new Error(`maxPitch must be less than or equal to ${maxPitchThreshold}`);
    }
    const transform2 = new Transform(resolvedOptions.minZoom, resolvedOptions.maxZoom, resolvedOptions.minPitch, resolvedOptions.maxPitch, resolvedOptions.renderWorldCopies);
    super(transform2, {
      bearingSnap: resolvedOptions.bearingSnap
    });
    _defineProperty(this, "_container", void 0);
    _defineProperty(this, "_canvasContainer", void 0);
    _defineProperty(this, "_interactive", void 0);
    _defineProperty(this, "_frameRequest", void 0);
    _defineProperty(this, "_loaded", void 0);
    _defineProperty(this, "_idleTriggered", false);
    _defineProperty(this, "_fullyLoaded", void 0);
    _defineProperty(this, "_trackResize", void 0);
    _defineProperty(this, "_resizeObserver", void 0);
    _defineProperty(this, "_preserveDrawingBuffer", void 0);
    _defineProperty(this, "_failIfMajorPerformanceCaveat", void 0);
    _defineProperty(this, "_fadeDuration", void 0);
    _defineProperty(this, "_crossSourceCollisions", void 0);
    _defineProperty(this, "_crossFadingFactor", 1);
    _defineProperty(this, "_collectResourceTiming", void 0);
    _defineProperty(this, "_renderTaskQueue", new TaskQueue());
    _defineProperty(this, "_mapId", uniqueId2());
    _defineProperty(this, "_removed", void 0);
    _defineProperty(this, "_clickTolerance", void 0);
    _defineProperty(this, "scrollZoom", void 0);
    _defineProperty(this, "boxZoom", void 0);
    _defineProperty(this, "dragRotate", void 0);
    _defineProperty(this, "dragPan", void 0);
    _defineProperty(this, "keyboard", void 0);
    _defineProperty(this, "doubleClickZoom", void 0);
    _defineProperty(this, "touchZoomRotate", void 0);
    _defineProperty(this, "touchPitch", void 0);
    _defineProperty(this, "cooperativeGestures", void 0);
    _defineProperty(this, "_onMapScroll", (event) => {
      if (event.target !== this._container)
        return;
      this._container.scrollTop = 0;
      this._container.scrollLeft = 0;
      return false;
    });
    this._interactive = resolvedOptions.interactive;
    this._trackResize = resolvedOptions.trackResize === true;
    this._bearingSnap = resolvedOptions.bearingSnap;
    this._fadeDuration = resolvedOptions.fadeDuration;
    this._clickTolerance = resolvedOptions.clickTolerance;
    if (typeof resolvedOptions.container === "string") {
      this._container = document.getElementById(resolvedOptions.container);
      if (!this._container) {
        throw new Error(`Container '${resolvedOptions.container}' not found.`);
      }
    } else if (resolvedOptions.container instanceof HTMLElement) {
      this._container = resolvedOptions.container;
    } else {
      throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
    }
    if (resolvedOptions.maxBounds) {
      this.setMaxBounds(resolvedOptions.maxBounds);
    }
    this._setupContainer();
    this.on("move", () => this._update()).on("moveend", () => this._update()).on("zoom", () => this._update()).once("idle", () => {
      this._idleTriggered = true;
    });
    if (typeof window !== "undefined") {
      let initialResizeEventCaptured = false;
      const throttledResizeCallback = lodashUtil.throttle((entries) => {
        if (this._trackResize && !this._removed) {
          this.resize(entries)._update();
        }
      }, 50);
      this._resizeObserver = new ResizeObserver((entries) => {
        if (!initialResizeEventCaptured) {
          initialResizeEventCaptured = true;
          return;
        }
        throttledResizeCallback(entries);
      });
      this._resizeObserver.observe(this._container);
    }
    this.handlers = new HandlerManager(this, resolvedOptions);
    this.jumpTo({
      center: resolvedOptions.center,
      zoom: resolvedOptions.zoom,
      bearing: resolvedOptions.bearing,
      pitch: resolvedOptions.pitch
    });
    if (resolvedOptions.bounds) {
      this.resize();
      this.fitBounds(resolvedOptions.bounds, extend2({}, resolvedOptions.fitBoundsOptions, {
        duration: 0
      }));
    }
    this.resize();
  }
  /**
   * @internal
   * Returns a unique number for this map instance which is used for the MapLoadEvent
   * to make sure we only fire one event per instantiated map object.
   * @returns the uniq map ID
   */
  _getMapId() {
    return this._mapId;
  }
  calculateCameraOptionsFromTo(from, altitudeFrom, to, altitudeTo) {
    return super.calculateCameraOptionsFromTo(from, altitudeFrom, to, altitudeTo);
  }
  /**
   * Resizes the map according to the dimensions of its
   * `container` element.
   *
   * Checks if the map container size changed and updates the map if it has changed.
   * This method must be called after the map's `container` is resized programmatically
   * or when the map is shown after being initially hidden with CSS.
   *
   * Triggers the following events: `movestart`, `move`, `moveend`, and `resize`.
   *
   * @param eventData - Additional properties to be passed to `movestart`, `move`, `resize`, and `moveend`
   * events that get triggered as a result of resize. This can be useful for differentiating the
   * source of an event (for example, user-initiated or programmatically-triggered events).
   * @example
   * Resize the map when the map container is shown after being initially hidden with CSS.
   * ```ts
   * let mapDiv = document.getElementById('map');
   * if (mapDiv.style.visibility === true) map.resize();
   * ```
   */
  resize(eventData) {
    var _this$_requestedCamer;
    const dimensions = this._containerDimensions();
    const width = dimensions[0];
    const height = dimensions[1];
    this.transform.resize(width, height);
    (_this$_requestedCamer = this._requestedCameraState) === null || _this$_requestedCamer === void 0 || _this$_requestedCamer.resize(width, height);
    const fireMoving = !this._moving;
    if (fireMoving) {
      this.stop();
      this.fire(new Event2("movestart", eventData)).fire(new Event2("move", eventData));
    }
    this.fire(new Event2("resize", eventData));
    if (fireMoving)
      this.fire(new Event2("moveend", eventData));
    return this;
  }
  /**
   * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not
   * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.
   * @returns The geographical bounds of the map as {@link LngLatBounds}.
   * @example
   * ```ts
   * let bounds = map.getBounds();
   * ```
   */
  getBounds() {
    return this.transform.getBounds();
  }
  /**
   * Returns the maximum geographical bounds the map is constrained to, or `null` if none set.
   * @returns The map object.
   * @example
   * ```ts
   * let maxBounds = map.getMaxBounds();
   * ```
   */
  getMaxBounds() {
    return this.transform.getMaxBounds();
  }
  /**
   * Sets or clears the map's geographical bounds.
   *
   * Pan and zoom operations are constrained within these bounds.
   * If a pan or zoom is performed that would
   * display regions outside these bounds, the map will
   * instead display a position and zoom level
   * as close as possible to the operation's request while still
   * remaining within the bounds.
   *
   * @param bounds - The maximum bounds to set. If `null` or `undefined` is provided, the function removes the map's maximum bounds.
   * @example
   * Define bounds that conform to the `LngLatBoundsLike` object as set the max bounds.
   * ```ts
   * let bounds = [
   *   [-74.04728, 40.68392], // [west, south]
   *   [-73.91058, 40.87764]  // [east, north]
   * ];
   * map.setMaxBounds(bounds);
   * ```
   */
  setMaxBounds(bounds) {
    this.transform.setMaxBounds(bounds && LngLatBounds.convert(bounds));
    return this._update();
  }
  /**
   * Sets or clears the map's minimum zoom level.
   * If the map's current zoom level is lower than the new minimum,
   * the map will zoom to the new minimum.
   *
   * It is not always possible to zoom out and reach the set `minZoom`.
   * Other factors such as map height may restrict zooming. For example,
   * if the map is 512px tall it will not be possible to zoom below zoom 0
   * no matter what the `minZoom` is set to.
   *
   * A {@link ErrorEvent} event will be fired if minZoom is out of bounds.
   *
   * @param minZoom - The minimum zoom level to set (-2 - 24).
   * If `null` or `undefined` is provided, the function removes the current minimum zoom (i.e. sets it to -2).
   * @example
   * ```ts
   * map.setMinZoom(12.25);
   * ```
   */
  setMinZoom(minZoom) {
    minZoom = minZoom === null || minZoom === void 0 ? defaultMinZoom : minZoom;
    if (minZoom >= defaultMinZoom && minZoom <= this.transform.maxZoom) {
      this.transform.minZoom = minZoom;
      this._update();
      if (this.getZoom() < minZoom)
        this.setZoom(minZoom);
      return this;
    } else
      throw new Error(`minZoom must be between ${defaultMinZoom} and the current maxZoom, inclusive`);
  }
  /**
   * Returns the map's minimum allowable zoom level.
   *
   * @returns minZoom
   * @example
   * ```ts
   * let minZoom = map.getMinZoom();
   * ```
   */
  getMinZoom() {
    return this.transform.minZoom;
  }
  /**
   * Sets or clears the map's maximum zoom level.
   * If the map's current zoom level is higher than the new maximum,
   * the map will zoom to the new maximum.
   *
   * A {@link ErrorEvent} event will be fired if minZoom is out of bounds.
   *
   * @param maxZoom - The maximum zoom level to set.
   * If `null` or `undefined` is provided, the function removes the current maximum zoom (sets it to 22).
   * @example
   * ```ts
   * map.setMaxZoom(18.75);
   * ```
   */
  setMaxZoom(maxZoom) {
    maxZoom = maxZoom === null || maxZoom === void 0 ? defaultMaxZoom : maxZoom;
    if (maxZoom >= this.transform.minZoom) {
      this.transform.maxZoom = maxZoom;
      if (this.getZoom() > maxZoom)
        this.setZoom(maxZoom);
      return this;
    } else
      throw new Error("maxZoom must be greater than the current minZoom");
  }
  /**
   * Returns the map's maximum allowable zoom level.
   *
   * @returns The maxZoom
   * @example
   * ```ts
   * let maxZoom = map.getMaxZoom();
   * ```
   */
  getMaxZoom() {
    return this.transform.maxZoom;
  }
  /**
   * Sets or clears the map's minimum pitch.
   * If the map's current pitch is lower than the new minimum,
   * the map will pitch to the new minimum.
   *
   * A {@link ErrorEvent} event will be fired if minPitch is out of bounds.
   *
   * @param minPitch - The minimum pitch to set (0-85). Values greater than 60 degrees are experimental and may result in rendering issues. If you encounter any, please raise an issue with details in the MapLibre project.
   * If `null` or `undefined` is provided, the function removes the current minimum pitch (i.e. sets it to 0).
   */
  setMinPitch(minPitch) {
    minPitch = minPitch === null || minPitch === void 0 ? defaultMinPitch : minPitch;
    if (minPitch < defaultMinPitch) {
      throw new Error(`minPitch must be greater than or equal to ${defaultMinPitch}`);
    }
    if (minPitch >= defaultMinPitch && minPitch <= this.transform.maxPitch) {
      this.transform.minPitch = minPitch;
      if (this.getPitch() < minPitch)
        this.setPitch(minPitch);
      return this;
    } else
      throw new Error(`minPitch must be between ${defaultMinPitch} and the current maxPitch, inclusive`);
  }
  /**
   * Returns the map's minimum allowable pitch.
   *
   * @returns The minPitch
   */
  getMinPitch() {
    return this.transform.minPitch;
  }
  /**
   * Sets or clears the map's maximum pitch.
   * If the map's current pitch is higher than the new maximum,
   * the map will pitch to the new maximum.
   *
   * A {@link ErrorEvent} event will be fired if maxPitch is out of bounds.
   *
   * @param maxPitch - The maximum pitch to set (0-85). Values greater than 60 degrees are experimental and may result in rendering issues. If you encounter any, please raise an issue with details in the MapLibre project.
   * If `null` or `undefined` is provided, the function removes the current maximum pitch (sets it to 60).
   */
  setMaxPitch(maxPitch) {
    maxPitch = maxPitch === null || maxPitch === void 0 ? defaultMaxPitch : maxPitch;
    if (maxPitch > maxPitchThreshold) {
      throw new Error(`maxPitch must be less than or equal to ${maxPitchThreshold}`);
    }
    if (maxPitch >= this.transform.minPitch) {
      this.transform.maxPitch = maxPitch;
      if (this.getPitch() > maxPitch)
        this.setPitch(maxPitch);
      return this;
    } else
      throw new Error("maxPitch must be greater than the current minPitch");
  }
  /**
   * Returns the map's maximum allowable pitch.
   *
   * @returns The maxPitch
   */
  getMaxPitch() {
    return this.transform.maxPitch;
  }
  /**
   * Returns the state of `renderWorldCopies`. If `true`, multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to `false`:
   *
   * - When the map is zoomed out far enough that a single representation of the world does not fill the map's entire
   * container, there will be blank space beyond 180 and -180 degrees longitude.
   * - Features that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the
   * map and the other on the left edge of the map) at every zoom level.
   * @returns The renderWorldCopies
   * @example
   * ```ts
   * let worldCopiesRendered = map.getRenderWorldCopies();
   * ```
   * @see [Render world copies](https://maplibre.org/maplibre-gl-js/docs/examples/render-world-copies/)
   */
  getRenderWorldCopies() {
    return this.transform.renderWorldCopies;
  }
  /**
   * Sets the state of `renderWorldCopies`.
   *
   * @param renderWorldCopies - If `true`, multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to `false`:
   *
   * - When the map is zoomed out far enough that a single representation of the world does not fill the map's entire
   * container, there will be blank space beyond 180 and -180 degrees longitude.
   * - Features that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the
   * map and the other on the left edge of the map) at every zoom level.
   *
   * `undefined` is treated as `true`, `null` is treated as `false`.
   * @example
   * ```ts
   * map.setRenderWorldCopies(true);
   * ```
   */
  setRenderWorldCopies(renderWorldCopies) {
    this.transform.renderWorldCopies = renderWorldCopies;
  }
  /**
   * Returns a [Point](https://github.com/mapbox/point-geometry) representing pixel coordinates, relative to the map's `container`,
   * that correspond to the specified geographical location.
   *
   * @param lnglat - The geographical location to project.
   * @returns The [Point](https://github.com/mapbox/point-geometry) corresponding to `lnglat`, relative to the map's `container`.
   * @example
   * ```ts
   * let coordinate = [-122.420679, 37.772537];
   * let point = map.project(coordinate);
   * ```
   */
  project(lnglat) {
    return this.transform.locationPoint(LngLat.convert(lnglat));
  }
  /**
   * Returns a {@link LngLat} representing geographical coordinates that correspond
   * to the specified pixel coordinates.
   *
   * @param point - The pixel coordinates to unproject.
   * @returns The {@link LngLat} corresponding to `point`.
   * @example
   * ```ts
   * map.on('click', (e) => {
   *   // When the map is clicked, get the geographic coordinate.
   *   let coordinate = map.unproject(e.point);
   * });
   * ```
   */
  unproject(point2) {
    return this.transform.pointLocation(import_point_geometry11.default.convert(point2));
  }
  /**
   * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.
   * @returns true if the map is moving.
   * @example
   * ```ts
   * let isMoving = map.isMoving();
   * ```
   */
  isMoving() {
    var _this$handlers;
    return this._moving || ((_this$handlers = this.handlers) === null || _this$handlers === void 0 ? void 0 : _this$handlers.isMoving());
  }
  /**
   * Returns true if the map is zooming due to a camera animation or user gesture.
   * @returns true if the map is zooming.
   * @example
   * ```ts
   * let isZooming = map.isZooming();
   * ```
   */
  isZooming() {
    var _this$handlers2;
    return this._zooming || ((_this$handlers2 = this.handlers) === null || _this$handlers2 === void 0 ? void 0 : _this$handlers2.isZooming());
  }
  /**
   * Returns true if the map is rotating due to a camera animation or user gesture.
   * @returns true if the map is rotating.
   * @example
   * ```ts
   * map.isRotating();
   * ```
   */
  isRotating() {
    var _this$handlers3;
    return this._rotating || ((_this$handlers3 = this.handlers) === null || _this$handlers3 === void 0 ? void 0 : _this$handlers3.isRotating());
  }
  /**
   * Overload of the `on` method that allows to listen to events without specifying a layer.
   * @event
   * @param type - The type of the event.
   * @param listener - The listener callback.
   */
  /**
   * Overload of the `on` method that allows to listen to events without specifying a layer.
   * @event
   * @param type - The type of the event.
   * @param listener - The listener callback.
   */
  on(type, listener) {
    return super.on(type, listener);
  }
  /**
   * Overload of the `once` method that allows to listen to events without specifying a layer.
   * @event
   * @param type - The type of the event.
   * @param listener - The listener callback.
   */
  /**
   * Overload of the `once` method that allows to listen to events without specifying a layer.
   * @event
   * @param type - The type of the event.
   * @param listener - The listener callback.
   */
  once(type, listener) {
    return super.once(type, listener);
  }
  /**
   * Overload of the `off` method that allows to listen to events without specifying a layer.
   * @event
   * @param type - The type of the event.
   * @param listener - The function previously installed as a listener.
   */
  /**
   * Overload of the `off` method that allows to listen to events without specifying a layer.
   * @event
   * @param type - The type of the event.
   * @param listener - The function previously installed as a listener.
   */
  off(type, listener) {
    return super.off(type, listener);
  }
  /**
   * Returns the map's containing HTML element.
   *
   * @returns The map's container.
   */
  getContainer() {
    return this._container;
  }
  /**
   * Returns the HTML element containing the map's `<canvas>` element.
   *
   * If you want to add non-GL overlays to the map, you should append them to this element.
   *
   * This is the element to which event bindings for map interactivity (such as panning and zooming) are
   * attached. It will receive bubbled events from child elements such as the `<canvas>`, but not from
   * map controls.
   *
   * @returns The container of the map's `<canvas>`.
   * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
   */
  getCanvasContainer() {
    return this._canvasContainer;
  }
  _containerDimensions() {
    let width = 0;
    let height = 0;
    if (this._container) {
      width = this._container.clientWidth || 400;
      height = this._container.clientHeight || 300;
    }
    return [width, height];
  }
  _setupContainer() {
    const container = this._container;
    container.classList.add("l7-map");
    const canvasContainer = this._canvasContainer = DOM.create("div", "l7-canvas-container", container);
    if (this._interactive) {
      canvasContainer.classList.add("l7-interactive");
    }
    this._container.addEventListener("scroll", this._onMapScroll, false);
  }
  /**
   * @internal
   * Update this map's style and sources, and re-render the map.
   *
   * @param updateStyle - mark the map's style for reprocessing as
   * well as its sources
   */
  _update() {
    this.triggerRepaint();
    return this;
  }
  /**
   * @internal
   * Request that the given callback be executed during the next render
   * frame.  Schedule a render frame if one is not already scheduled.
   *
   * @returns An id that can be used to cancel the callback
   */
  _requestRenderFrame(callback) {
    this._update();
    return this._renderTaskQueue.add(callback);
  }
  _cancelRenderFrame(id2) {
    this._renderTaskQueue.remove(id2);
  }
  /**
   * @internal
   * Call when a (re-)render of the map is required:
   *
   * - The style has changed (`setPaintProperty()`, etc.)
   * - Source data has changed (e.g. tiles have finished loading)
   * - The map has is moving (or just finished moving)
   * - A transition is in progress
   *
   * @param paintStartTimeStamp - The time when the animation frame began executing.
   */
  _render(paintStartTimeStamp) {
    this._renderTaskQueue.run(paintStartTimeStamp);
    if (this._removed)
      return;
    this.fire(new Event2("render"));
    if (!this.isMoving()) {
      this.fire(new Event2("idle"));
    }
    return this;
  }
  /**
   * Clean up and release all internal resources associated with this map.
   *
   * This includes DOM elements, event bindings, web workers, and WebGL resources.
   *
   * Use this method when you are done using the map and wish to ensure that it no
   * longer consumes browser resources. Afterwards, you must not call any other
   * methods on the map.
   */
  remove() {
    var _this$_resizeObserver;
    if (this._frameRequest) {
      this._frameRequest.abort();
      this._frameRequest = null;
    }
    this._renderTaskQueue.clear();
    this.handlers.destroy();
    delete this.handlers;
    (_this$_resizeObserver = this._resizeObserver) === null || _this$_resizeObserver === void 0 || _this$_resizeObserver.disconnect();
    DOM.remove(this._canvasContainer);
    this._container.classList.remove("l7-map");
    this._removed = true;
    this.fire(new Event2("remove"));
  }
  /**
   * Trigger the rendering of a single frame. Use this method with custom layers to
   * repaint the map when the layer changes. Calling this multiple times before the
   * next frame is rendered will still result in only a single frame being rendered.
   * @example
   * ```ts
   * map.triggerRepaint();
   * ```
   */
  triggerRepaint() {
    if (!this._frameRequest) {
      this._frameRequest = new AbortController();
      browser.frameAsync(this._frameRequest).then((paintStartTimeStamp) => {
        this._frameRequest = null;
        this._render(paintStartTimeStamp);
      }).catch(() => {
      });
    }
  }
  /**
   * Returns the elevation for the point where the camera is looking.
   * This value corresponds to:
   * "meters above sea level" * "exaggeration"
   * @returns The elevation.
   */
  getCameraTargetElevation() {
    return this.transform.elevation;
  }
};

// node_modules/@antv/l7-maps/es/earth/Viewport.js
var Viewport3 = class {
  constructor() {
    _defineProperty(this, "xzReg", -Math.PI * 0.6);
    _defineProperty(this, "yReg", Math.PI * 0.2);
    _defineProperty(this, "earthCameraRadius", 200);
    _defineProperty(this, "earthCameraZoom", 1);
    _defineProperty(this, "cameraPosition", vec3_exports.create());
    _defineProperty(this, "viewport", void 0);
    _defineProperty(this, "projectionMatrix", mat4_exports.create());
    _defineProperty(this, "modelMatrix", mat4_exports.create());
    _defineProperty(this, "viewMatrix", mat4_exports.create());
    _defineProperty(this, "viewProjectionMatrix", mat4_exports.create());
    _defineProperty(this, "ViewProjectionMatrixUncentered", mat4_exports.create());
    _defineProperty(this, "viewUncenteredMatrix", mat4_exports.create());
  }
  syncWithMapCamera(mapCamera) {
    const {
      viewportHeight = 1,
      viewportWidth = 1
    } = mapCamera;
    const aspect = viewportWidth / viewportHeight;
    const near = 0.1;
    const far = 1e4;
    const fov = 20;
    mat4_exports.perspective(this.projectionMatrix, fov, aspect, near, far);
    const x2 = this.earthCameraRadius * Math.cos(this.xzReg);
    const z = this.earthCameraRadius * Math.sin(this.xzReg);
    const y = this.earthCameraRadius * Math.sin(this.yReg);
    this.cameraPosition = vec3_exports.fromValues(x2, y, z);
    vec3_exports.normalize(this.cameraPosition, this.cameraPosition);
    vec3_exports.multiply(this.cameraPosition, this.cameraPosition, vec3_exports.fromValues(this.earthCameraRadius, this.earthCameraRadius, this.earthCameraRadius));
    vec3_exports.scale(this.cameraPosition, this.cameraPosition, this.earthCameraZoom);
    const crossY = vec3_exports.create();
    vec3_exports.cross(crossY, this.cameraPosition, vec3_exports.fromValues(0, 1, 0));
    const up = vec3_exports.fromValues(0, 1, 0);
    vec3_exports.cross(up, crossY, this.cameraPosition);
    const target = vec3_exports.fromValues(0, 0, 0);
    mat4_exports.lookAt(this.viewMatrix, this.cameraPosition, target, up);
    this.viewUncenteredMatrix = mat4_exports.clone(this.viewMatrix);
    mat4_exports.multiply(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix);
    mat4_exports.multiply(this.ViewProjectionMatrixUncentered, this.projectionMatrix, this.viewMatrix);
  }
  /**
   * 旋转方法 Y 轴
   * @param r
   */
  rotateY(r) {
    this.xzReg += r * Math.min(this.earthCameraZoom * this.earthCameraZoom, 1);
  }
  /**
   * 旋转方法 X 轴
   * @param r
   */
  rotateX(r) {
    this.yReg += r * Math.min(this.earthCameraZoom * this.earthCameraZoom, 1);
  }
  /**
   * 缩放方法
   * @param z
   */
  scaleZoom(z) {
    this.earthCameraZoom += z;
    this.earthCameraZoom = Math.max(this.earthCameraZoom, 0.6);
  }
  getZoom() {
    return 4;
  }
  getZoomScale() {
    return Math.pow(2, this.getZoom());
  }
  getCenter() {
    return [0, 0];
  }
  getProjectionMatrix() {
    return this.projectionMatrix;
  }
  getModelMatrix() {
    return this.modelMatrix;
  }
  getViewMatrix() {
    return this.viewMatrix;
  }
  getViewMatrixUncentered() {
    return this.viewMatrix;
  }
  getViewProjectionMatrix() {
    return this.viewProjectionMatrix;
  }
  getViewProjectionMatrixUncentered() {
    return this.viewProjectionMatrix;
  }
  getFocalDistance() {
    return 1;
  }
  projectFlat(lngLat, scale6) {
    return this.viewport.projectFlat(lngLat, scale6);
  }
};

// node_modules/@antv/l7-maps/es/earth/map.js
var _excluded5 = ["id", "style", "rotation"];
var EventMap3 = {
  mapmove: "move",
  camerachange: "move",
  zoomchange: "zoom",
  dragging: "drag"
};
var LNGLAT_OFFSET_ZOOM_THRESHOLD3 = 12;
var L7EarthService = class extends BaseMapService {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "version", "GLOBEL");
    _defineProperty(this, "dragging", false);
    _defineProperty(this, "viewport", void 0);
    _defineProperty(this, "handleCameraChanging", void 0);
    _defineProperty(this, "handleCameraTimer", void 0);
    _defineProperty(this, "handleCameraChanged", (e) => {
      this.emit("mapchange");
      const DELAY_TIME = 2e3;
      this.handleCameraChanging = true;
      if (this.handleCameraTimer) {
        clearTimeout(this.handleCameraTimer);
      }
      this.handleCameraTimer = setTimeout(() => {
        this.handleCameraChanging = false;
      }, DELAY_TIME);
      const rotateStep = 0.02;
      if (e.type && e.originalEvent) {
        if (e.originalEvent.type === "wheel") {
          this.viewport.scaleZoom(0.01 * Math.sign(e.originalEvent.wheelDelta) * -1);
        }
        if (Math.abs(e.originalEvent.movementX) > Math.abs(e.originalEvent.movementY)) {
          if (e.originalEvent.movementX > 0) {
            this.viewport.rotateY(rotateStep);
          } else if (e.originalEvent.movementX < 0) {
            this.viewport.rotateY(-rotateStep);
          }
        } else {
          if (e.originalEvent.movementY > 0) {
            this.viewport.rotateX(rotateStep);
          } else if (e.originalEvent.movementY < 0) {
            this.viewport.rotateX(-rotateStep);
          }
        }
      }
      const {
        offsetCoordinate = true
      } = this.config;
      this.viewport.syncWithMapCamera({
        viewportHeight: this.map.transform.height,
        viewportWidth: this.map.transform.width
      });
      if (this.viewport.getZoom() > LNGLAT_OFFSET_ZOOM_THRESHOLD3 && offsetCoordinate) {
        this.coordinateSystemService.setCoordinateSystem(CoordinateSystem.LNGLAT_OFFSET);
      } else {
        this.coordinateSystemService.setCoordinateSystem(CoordinateSystem.LNGLAT);
      }
      this.cameraChangedCallback(this.viewport);
    });
  }
  lngLatToMercator(lnglat, altitude) {
    throw new Error("Method not implemented.");
  }
  getModelMatrix(lnglat, altitude, rotate5, scale6, origin) {
    throw new Error("Method not implemented.");
  }
  //  map event
  on(type, handle) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.on(type, handle);
    } else {
      this.map.on(EventMap3[type] || type, handle);
    }
  }
  off(type, handle) {
    this.map.off(EventMap3[type] || type, handle);
    this.eventEmitter.off(type, handle);
  }
  getMapCanvasContainer() {
    return this.map.getCanvasContainer();
  }
  getSize() {
    const size = this.map.transform;
    return [size.width, size.height];
  }
  // get mapStatus method
  getType() {
    return "earth";
  }
  init() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const _this$config = _this.config, {
        id: id2 = "map",
        style = "light",
        rotation = 0
      } = _this$config, rest = _objectWithoutProperties(_this$config, _excluded5);
      _this.viewport = new Viewport3();
      _this.$mapContainer = _this.creatMapContainer(id2);
      _this.map = new Map2(_objectSpread2({
        container: _this.$mapContainer,
        bearing: rotation
      }, rest));
      _this.map.on("load", _this.handleCameraChanged);
      _this.map.on("move", _this.handleCameraChanged);
      _this.handleCameraChanged({});
    })();
  }
  destroy() {
    var _this$$mapContainer;
    (_this$$mapContainer = this.$mapContainer) === null || _this$$mapContainer === void 0 || (_this$$mapContainer = _this$$mapContainer.parentNode) === null || _this$$mapContainer === void 0 || _this$$mapContainer.removeChild(this.$mapContainer);
    this.eventEmitter.removeAllListeners();
    if (this.map) {
      this.map.remove();
      this.$mapContainer = null;
    }
  }
  emit(name, ...args) {
    this.eventEmitter.emit(name, ...args);
  }
  once(name, ...args) {
    this.eventEmitter.once(name, ...args);
  }
  getMapContainer() {
    return this.$mapContainer;
  }
  getCanvasOverlays() {
    return void 0;
  }
  onCameraChanged(callback) {
    this.cameraChangedCallback = callback;
  }
  /**
   * 地球模式向外暴露的 Y 轴旋转方法
   * @returns
   */
  rotateY(option) {
    const {
      force = false,
      reg = 0.01
    } = option || {};
    if (this.handleCameraChanging && !force) {
      return;
    }
    if (this.viewport) {
      this.viewport.rotateY(reg);
      this.viewport.syncWithMapCamera({
        viewportHeight: this.map.transform.height,
        viewportWidth: this.map.transform.width
      });
      this.cameraChangedCallback(this.viewport);
    }
  }
};

// node_modules/@antv/l7-maps/es/earth/index.js
var EarthWrapper = class extends BaseMapWrapper {
  getServiceConstructor() {
    return L7EarthService;
  }
};

// node_modules/@antv/l7-maps/es/gmap/maploader.js
if (!window) {
  throw Error("Google Map JSAPI can only be used in Browser.");
}
var LoadStatus2 = function(LoadStatus4) {
  LoadStatus4["notload"] = "notload";
  LoadStatus4["loading"] = "loading";
  LoadStatus4["loaded"] = "loaded";
  LoadStatus4["failed"] = "failed";
  return LoadStatus4;
}(LoadStatus2 || {});
var config2 = {
  key: ""
};
var Status2 = {
  GMap: LoadStatus2.notload
};
var onloadCBKs2 = [];
var onload2 = (callback) => {
  if (typeof callback === "function") {
    if (Status2.GMap === LoadStatus2.loaded) {
      callback(window.google.maps.Map);
      return;
    }
    onloadCBKs2.push(callback);
  }
};
var load2 = (options) => {
  return new Promise((resolve, reject) => {
    if (Status2.GMap === LoadStatus2.failed) {
      reject("");
    } else if (Status2.GMap === LoadStatus2.notload) {
      const {
        key
      } = options;
      if (!key) {
        reject("请填写key");
        return;
      }
      config2.key = key;
      Status2.GMap = LoadStatus2.loading;
      window.initMap = (err2) => {
        delete window.initMap;
        if (err2) {
          Status2.GMap = LoadStatus2.failed;
          reject(err2);
        } else {
          Status2.GMap = LoadStatus2.loaded;
          while (onloadCBKs2.length) {
            onloadCBKs2.splice(0, 1)[0](window.google.maps.Map);
          }
        }
      };
      const script = document.createElement("script");
      script.type = "text/javascript";
      script.async = false;
      script.src = `https://maps.googleapis.com/maps/api/js?key=${config2.key}&callback=initMap`;
      script.onerror = (e) => {
        Status2.GMap = LoadStatus2.failed;
        reject(e);
      };
      const parentNode = document.body || document.head;
      parentNode.appendChild(script);
      onload2(resolve);
    } else if (Status2.GMap === LoadStatus2.loaded) {
      if (options.key && options.key !== config2.key) {
        reject("多个不一致的 key");
        return;
      }
      onload2(resolve);
    }
  });
};
var reset2 = () => {
  delete window.google;
  Status2 = {
    GMap: LoadStatus2.notload
  };
};
var maploader_default = {
  load: load2,
  reset: reset2
};

// node_modules/@antv/l7-maps/es/gmap/map.js
var _excluded6 = ["id", "mapInstance", "center", "token", "minZoom", "maxZoom", "logoVisible"];
function loadStyles4(css, doc) {
  var isMiniAli = typeof my !== "undefined" && !!my && typeof my.showToast === "function" && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== "undefined" && wx !== null && (typeof wx.request !== "undefined" || typeof wx.miniProgram !== "undefined");
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc)
    doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName("head")[0];
  if (!head) {
    head = doc.createElement("head");
    var body = doc.body || doc.getElementsByTagName("body")[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement("style");
  style.type = "text/css";
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles4(`img[src*='//mapapi.qq.com/web/jsapi/logo/logo_def.png'],.logo-text
{
  display: none !important;
}
`);
var GMAP_API_KEY = "AIzaSyDBDCfl4pvuDtaazdCog3LmhA7CQLhmcRE";
var EventMap4 = {
  mapmove: "center_changed",
  camerachange: ["drag", "pan", "rotate", "tilt", "zoom_changed"],
  zoomchange: "zoom_changed",
  dragging: "drag"
};
var TMapService = class extends BaseMapService {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "viewport", null);
    _defineProperty(this, "evtCbProxyMap", /* @__PURE__ */ new Map());
    _defineProperty(this, "handleCameraChanged", () => {
      this.emit("mapchange");
      const map = this.map;
      const {
        lng,
        lat
      } = map.getCenter();
      const option = {
        center: [lng(), lat()],
        viewportHeight: map.getDiv().clientHeight,
        viewportWidth: map.getDiv().clientWidth,
        bearing: map.getHeading(),
        pitch: map.getTilt(),
        zoom: map.getZoom() - 1
      };
      this.viewport.syncWithMapCamera(option);
      this.updateCoordinateSystemService();
      this.cameraChangedCallback(this.viewport);
    });
  }
  init() {
    var _this = this;
    return _asyncToGenerator(function* () {
      var _window$google;
      _this.viewport = new Viewport2();
      const _this$config = _this.config, {
        id: id2,
        mapInstance,
        center = [121.30654632240122, 31.25744185633306],
        token = GMAP_API_KEY,
        minZoom = 3,
        maxZoom = 18,
        logoVisible = true
      } = _this$config, rest = _objectWithoutProperties(_this$config, _excluded6);
      if (!((_window$google = window.google) !== null && _window$google !== void 0 && (_window$google = _window$google.maps) !== null && _window$google !== void 0 && _window$google.Map || mapInstance)) {
        yield maploader_default.load({
          key: token
        });
      }
      if (mapInstance) {
        _this.map = mapInstance;
        _this.$mapContainer = _this.map.getDiv();
        if (logoVisible === false) {
          _this.hideLogo();
        }
      } else {
        if (!id2) {
          throw Error("No container id specified");
        }
        const mapContainer = dom_exports.getContainer(id2);
        const map = new google.maps.Map(mapContainer, _objectSpread2({
          maxZoom,
          minZoom,
          zoomControl: false,
          fullscreenControl: false,
          center: new google.maps.LatLng(center[1], center[0])
        }, rest));
        _this.map = map;
        _this.$mapContainer = map.getDiv();
        if (logoVisible === false) {
          _this.hideLogo();
        }
      }
      google.maps.event.addListener(_this.map, "drag", _this.handleCameraChanged);
      google.maps.event.addListener(_this.map, "pan", _this.handleCameraChanged);
      google.maps.event.addListener(_this.map, "rotate", _this.handleCameraChanged);
      google.maps.event.addListener(_this.map, "idle", _this.handleCameraChanged);
      google.maps.event.addListener(_this.map, "zoom_changed", _this.handleCameraChanged);
      _this.handleCameraChanged();
    })();
  }
  destroy() {
    this.map.setMap(null);
  }
  onCameraChanged(callback) {
    this.cameraChangedCallback = callback;
  }
  addMarkerContainer() {
  }
  getMarkerContainer() {
    return this.markerContainer;
  }
  getCanvasOverlays() {
    return this.map.getDiv();
  }
  // MapEvent
  on(type, handle) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.on(type, handle);
    } else {
      const onProxy = (eventName) => {
        let cbProxyMap = this.evtCbProxyMap.get(eventName);
        if (!cbProxyMap) {
          this.evtCbProxyMap.set(eventName, cbProxyMap = /* @__PURE__ */ new Map());
        }
        if (cbProxyMap.get(handle)) {
          return;
        }
        const handleProxy = (...args) => {
          if (args[0] && typeof args[0] === "object" && !args[0].lngLat && !args[0].lnglat) {
            args[0].lngLat = args[0].latlng || args[0].latLng;
          }
          handle(...args);
        };
        cbProxyMap.set(handle, handleProxy);
        this.map.on(eventName, handleProxy);
      };
      if (Array.isArray(EventMap4[type])) {
        EventMap4[type].forEach((eventName) => {
          onProxy(eventName || type);
        });
      } else {
        onProxy(EventMap4[type] || type);
      }
    }
  }
  off(type, handle) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.off(type, handle);
      return;
    }
    const offProxy = (eventName) => {
      var _this$evtCbProxyMap$g, _this$evtCbProxyMap$g2;
      const handleProxy = (_this$evtCbProxyMap$g = this.evtCbProxyMap.get(type)) === null || _this$evtCbProxyMap$g === void 0 ? void 0 : _this$evtCbProxyMap$g.get(handle);
      if (!handleProxy) {
        return;
      }
      (_this$evtCbProxyMap$g2 = this.evtCbProxyMap.get(eventName)) === null || _this$evtCbProxyMap$g2 === void 0 || _this$evtCbProxyMap$g2.delete(handle);
      this.map.off(eventName, handleProxy);
    };
    if (Array.isArray(EventMap4[type])) {
      EventMap4[type].forEach((eventName) => {
        offProxy(eventName || type);
      });
    } else {
      offProxy(EventMap4[type] || type);
    }
  }
  once() {
    throw new Error("Method not implemented.");
  }
  // get dom
  getContainer() {
    return this.map.getDiv();
  }
  getSize() {
    return [this.map.width, this.map.height];
  }
  // get map status method
  getMinZoom() {
    return this.map.transform._minZoom;
  }
  getMaxZoom() {
    return this.map.transform._maxZoom;
  }
  // get map params
  getType() {
    return "googlemap";
  }
  getZoom() {
    return this.map.getZoom();
  }
  getCenter() {
    const {
      lng,
      lat
    } = this.map.getCenter();
    return {
      lng: lng(),
      lat: lat()
    };
  }
  getPitch() {
    return this.map.getTilt();
  }
  getRotation() {
    const rotation = this.map.getHeading();
    return rotation;
  }
  getBounds() {
    const bounds = this.map.getBounds();
    const ne = bounds === null || bounds === void 0 ? void 0 : bounds.getNorthEast();
    const sw = bounds === null || bounds === void 0 ? void 0 : bounds.getSouthWest();
    return [[sw.lng(), sw.lat()], [ne.lng(), ne.lat()]];
  }
  getMapContainer() {
    return this.map.getDiv();
  }
  getMapCanvasContainer() {
    var _this$map$getDiv;
    return (_this$map$getDiv = this.map.getDiv()) === null || _this$map$getDiv === void 0 ? void 0 : _this$map$getDiv.getElementsByTagName("canvas")[0];
  }
  getMapStyleConfig() {
    throw new Error("Method not implemented.");
  }
  setBgColor(color2) {
    this.bgColor = color2;
  }
  setMapStyle(styleId) {
    this.map.setMapStyleId(styleId);
  }
  // control with raw map
  setRotation(rotation) {
    this.map.setHeading(rotation);
  }
  zoomIn() {
    const currentZoom = this.map.getZoom();
    this.map.setZoom(currentZoom + 1);
  }
  zoomOut() {
    const currentZoom = this.map.getZoom();
    this.map.setZoom(currentZoom - 1);
  }
  panTo([lng, lat]) {
    this.map.panTo({
      lat,
      lng
    });
  }
  panBy(x2, y) {
    this.map.panBy(x2, y);
  }
  fitBounds(bound, fitBoundsOptions) {
    const [sw, ne] = bound;
    const bounds = new google.maps.LatLngBounds({
      lat: sw[1],
      lng: sw[0]
    }, {
      lat: ne[1],
      lng: ne[0]
    });
    this.map.fitBounds(bounds, fitBoundsOptions);
  }
  setZoomAndCenter(zoom, [lng, lat]) {
    this.map.setZoom(zoom);
    this.map.setCenter({
      lat,
      lng
    });
  }
  setCenter([lng, lat]) {
    this.map.setCenter({
      lat,
      lng
    });
  }
  setPitch(pitch) {
    this.map.setTilt(pitch);
  }
  setZoom(zoom) {
    this.map.setZoom(zoom);
  }
  setMapStatus(option) {
    Object.keys(option).map((status) => {
      switch (status) {
        case "doubleClickZoom":
          this.map.setOptions({
            gestureHandling: option.doubleClickZoom ? "auto" : "none"
          });
          break;
        case "dragEnable":
          this.map.setOptions({
            draggable: option.dragEnable
          });
          break;
        case "rotateEnable":
          break;
        case "zoomEnable":
          this.map.setOptions({
            zoomControl: option.zoomEnable
          });
          break;
        case "keyboardEnable":
        case "resizeEnable":
        case "showIndoorMap":
          throw Error("Options may not be supported");
        default:
      }
    });
  }
  // coordinates methods
  meterToCoord([centerLon, centerLat], [outerLon, outerLat]) {
    const metreDistance = google.maps.geometry.spherical.computeDistanceBetween([new google.maps.LatLng(centerLat, centerLon), new google.maps.LatLng(outerLat, outerLon)]);
    const [x1, y1] = this.lngLatToCoord([centerLon, centerLat]);
    const [x2, y2] = this.lngLatToCoord([outerLon, outerLat]);
    const coordDistance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    return coordDistance / metreDistance;
  }
  pixelToLngLat([x2, y]) {
    const {
      lng: clng,
      lat: clat
    } = this.map.getCenter();
    const {
      x: centerPixelX,
      y: centerPixelY
    } = this.lngLatToPixel([clng(), clat()]);
    const {
      x: centerContainerX,
      y: centerContainerY
    } = this.lngLatToContainer([clng(), clat()]);
    const {
      lng,
      lat
    } = this.map.unprojectFromContainer(new google.maps.Point(centerContainerX + (x2 - centerPixelX), centerContainerY + (y - centerPixelY)));
    return this.containerToLngLat([lng, lat]);
  }
  lngLatToPixel([lng, lat]) {
    const latLng = new google.maps.LatLng(lat, lng);
    const point2 = this.map.getProjection().fromLatLngToPoint(latLng);
    return {
      x: point2.x,
      y: point2.y
    };
  }
  containerToLngLat([x2, y]) {
    var _this$map$getProjecti;
    const pixelCoordinate = new google.maps.Point(x2, y);
    const lngLat = (_this$map$getProjecti = this.map.getProjection()) === null || _this$map$getProjecti === void 0 ? void 0 : _this$map$getProjecti.fromPointToLatLng(pixelCoordinate);
    return {
      lng: lngLat.lng(),
      lat: lngLat.lat()
    };
  }
  lngLatToContainer([lng, lat]) {
    var _this$map$getProjecti2, _this$map$getProjecti3;
    const latLng = new google.maps.LatLng(lat, lng);
    const pixel = (_this$map$getProjecti2 = this.map.getProjection()) === null || _this$map$getProjecti2 === void 0 || (_this$map$getProjecti3 = _this$map$getProjecti2.fromLatLngToContainerPixel) === null || _this$map$getProjecti3 === void 0 ? void 0 : _this$map$getProjecti3.call(_this$map$getProjecti2, latLng);
    return {
      x: pixel.x,
      y: pixel.y
    };
  }
  lngLatToCoord([lng, lat]) {
    const {
      x: x2,
      y
    } = this.lngLatToPixel([lng, lat]);
    return [x2, -y];
  }
  lngLatToCoords(list) {
    return list.map((item) => Array.isArray(item[0]) ? this.lngLatToCoords(item) : this.lngLatToCoord(item));
  }
  lngLatToMercator(lnglat, altitude) {
    const {
      x: x2 = 0,
      y = 0,
      z = 0
    } = MercatorCoordinate.fromLngLat(lnglat, altitude);
    return {
      x: x2,
      y,
      z
    };
  }
  getModelMatrix(lnglat, altitude, rotate5, scale6 = [1, 1, 1]) {
    const flat = this.viewport.projectFlat(lnglat);
    const modelMatrix = mat4_exports.create();
    mat4_exports.translate(modelMatrix, modelMatrix, vec3_exports.fromValues(flat[0], flat[1], altitude));
    mat4_exports.scale(modelMatrix, modelMatrix, vec3_exports.fromValues(scale6[0], scale6[1], scale6[2]));
    mat4_exports.rotateX(modelMatrix, modelMatrix, rotate5[0]);
    mat4_exports.rotateY(modelMatrix, modelMatrix, rotate5[1]);
    mat4_exports.rotateZ(modelMatrix, modelMatrix, rotate5[2]);
    return modelMatrix;
  }
  getCustomCoordCenter() {
    throw new Error("Method not implemented.");
  }
  exportMap(type) {
    const renderCanvas = this.getMapCanvasContainer();
    const layersPng = type === "jpg" ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/jpeg") : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/png");
    return layersPng;
  }
  // Method on earth mode
  rotateY() {
    throw new Error("Method not implemented.");
  }
  hideLogo() {
    const container = this.map.getDiv();
    if (!container) {
      return;
    }
    dom_exports.addClass(container, "tmap-contianer--hide-logo");
  }
};

// node_modules/@antv/l7-maps/es/gmap/index.js
var GMapWrapper = class extends BaseMapWrapper {
  getServiceConstructor() {
    return TMapService;
  }
};

// node_modules/@antv/l7-maps/es/map/map.js
var _excluded7 = ["id", "style", "rotation", "mapInstance", "version", "mapSize", "interactive"];
var DefaultMapService = class extends BaseMapService {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "version", MapType.DEFAULT);
    _defineProperty(this, "viewport", void 0);
  }
  /**
   * 将经纬度转成墨卡托坐标
   * @param lnglat
   * @returns
   */
  lngLatToCoord(lnglat, origin = {
    x: 0,
    y: 0,
    z: 0
  }) {
    const {
      x: x2,
      y
    } = this.lngLatToMercator(lnglat, 0);
    return [x2 - origin.x, y - origin.y];
  }
  lngLatToMercator(lnglat, altitude) {
    const {
      x: x2 = 0,
      y = 0,
      z = 0
    } = MercatorCoordinate.fromLngLat(lnglat, altitude);
    return {
      x: x2,
      y,
      z
    };
  }
  getModelMatrix(lnglat, altitude, rotate5, scale6 = [1, 1, 1], origin = {
    x: 0,
    y: 0,
    z: 0
  }) {
    const modelAsMercatorCoordinate = MercatorCoordinate.fromLngLat(lnglat, altitude);
    const meters = modelAsMercatorCoordinate.meterInMercatorCoordinateUnits();
    const modelMatrix = mat4_exports.create();
    mat4_exports.translate(modelMatrix, modelMatrix, vec3_exports.fromValues(modelAsMercatorCoordinate.x - origin.x, modelAsMercatorCoordinate.y - origin.y, modelAsMercatorCoordinate.z || 0 - origin.z));
    mat4_exports.scale(modelMatrix, modelMatrix, vec3_exports.fromValues(meters * scale6[0], -meters * scale6[1], meters * scale6[2]));
    mat4_exports.rotateX(modelMatrix, modelMatrix, rotate5[0]);
    mat4_exports.rotateY(modelMatrix, modelMatrix, rotate5[1]);
    mat4_exports.rotateZ(modelMatrix, modelMatrix, rotate5[2]);
    return modelMatrix;
  }
  init() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const _this$config = _this.config, {
        id: id2 = "map",
        style = "light",
        rotation = 0,
        mapInstance,
        version = "DEFAULTMAP",
        mapSize = 1e4,
        interactive = true
      } = _this$config, rest = _objectWithoutProperties(_this$config, _excluded7);
      _this.viewport = new Viewport2();
      _this.version = version;
      _this.simpleMapCoord.setSize(mapSize);
      if (version === "SIMPLE" && rest.center) {
        rest.center = _this.simpleMapCoord.unproject(rest.center);
      }
      if (mapInstance) {
        _this.map = mapInstance;
        _this.$mapContainer = _this.map.getContainer();
      } else {
        _this.$mapContainer = _this.creatMapContainer(id2);
        _this.map = new Map2(_objectSpread2({
          container: _this.$mapContainer,
          bearing: rotation
        }, rest));
      }
      _this.map.on("load", () => {
        _this.handleCameraChanged();
      });
      if (interactive) {
        _this.map.on("move", _this.handleCameraChanged);
      }
      setTimeout(() => {
        _this.handleCameraChanged();
      }, 100);
      _this.handleCameraChanged();
    })();
  }
  creatMapContainer(id2) {
    let wrapper = id2;
    if (typeof id2 === "string") {
      wrapper = document.getElementById(id2);
    }
    const container = document.createElement("div");
    container.style.cssText += `
      position: absolute;
      top: 0;
      height: 100%;
      width: 100%;
    `;
    wrapper.appendChild(container);
    return container;
  }
  exportMap(type) {
    return "";
  }
  setMapStyle(style) {
  }
  getCanvasOverlays() {
    return this.getContainer();
  }
};

// node_modules/@antv/l7-maps/es/map/index.js
var MapboxWrapper2 = class extends BaseMapWrapper {
  getServiceConstructor() {
    return DefaultMapService;
  }
};

// node_modules/@antv/l7-maps/es/mapbox/map.js
var import_mapbox_gl = __toESM(require_mapbox_gl());
var _excluded8 = ["id", "attributionControl", "style", "token", "rotation", "mapInstance"];
function loadStyles5(css, doc) {
  var isMiniAli = typeof my !== "undefined" && !!my && typeof my.showToast === "function" && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== "undefined" && wx !== null && (typeof wx.request !== "undefined" || typeof wx.miniProgram !== "undefined");
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc)
    doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName("head")[0];
  if (!head) {
    head = doc.createElement("head");
    var body = doc.body || doc.getElementsByTagName("body")[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement("style");
  style.type = "text/css";
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles5(`.mapboxgl-map{font:12px/20px Helvetica Neue,Arial,Helvetica,sans-serif;overflow:hidden;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mapboxgl-canvas{position:absolute;left:0;top:0}.mapboxgl-map:-webkit-full-screen{width:100%;height:100%}.mapboxgl-canary{background-color:salmon}.mapboxgl-canvas-container.mapboxgl-interactive,.mapboxgl-ctrl-group button.mapboxgl-ctrl-compass{cursor:grab;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.mapboxgl-canvas-container.mapboxgl-interactive.mapboxgl-track-pointer{cursor:pointer}.mapboxgl-canvas-container.mapboxgl-interactive:active,.mapboxgl-ctrl-group button.mapboxgl-ctrl-compass:active{cursor:grabbing}.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate,.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate .mapboxgl-canvas{touch-action:pan-x pan-y}.mapboxgl-canvas-container.mapboxgl-touch-drag-pan,.mapboxgl-canvas-container.mapboxgl-touch-drag-pan .mapboxgl-canvas{touch-action:pinch-zoom}.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan,.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan .mapboxgl-canvas{touch-action:none}.mapboxgl-ctrl-bottom-left,.mapboxgl-ctrl-bottom-right,.mapboxgl-ctrl-top-left,.mapboxgl-ctrl-top-right{position:absolute;pointer-events:none;z-index:2}.mapboxgl-ctrl-top-left{top:0;left:0}.mapboxgl-ctrl-top-right{top:0;right:0}.mapboxgl-ctrl-bottom-left{bottom:0;left:0}.mapboxgl-ctrl-bottom-right{right:0;bottom:0}.mapboxgl-ctrl{clear:both;pointer-events:auto;-webkit-transform:translate(0);transform:translate(0)}.mapboxgl-ctrl-top-left .mapboxgl-ctrl{margin:10px 0 0 10px;float:left}.mapboxgl-ctrl-top-right .mapboxgl-ctrl{margin:10px 10px 0 0;float:right}.mapboxgl-ctrl-bottom-left .mapboxgl-ctrl{margin:0 0 10px 10px;float:left}.mapboxgl-ctrl-bottom-right .mapboxgl-ctrl{margin:0 10px 10px 0;float:right}.mapboxgl-ctrl-group{border-radius:4px;background:#fff}.mapboxgl-ctrl-group:not(:empty){box-shadow:0 0 0 2px rgba(0,0,0,.1)}@media (-ms-high-contrast:active){.mapboxgl-ctrl-group:not(:empty){box-shadow:0 0 0 2px ButtonText}}.mapboxgl-ctrl-group button{width:29px;height:29px;display:block;padding:0;outline:none;border:0;box-sizing:border-box;background-color:transparent;cursor:pointer}.mapboxgl-ctrl-group button+button{border-top:1px solid #ddd}.mapboxgl-ctrl button .mapboxgl-ctrl-icon{display:block;width:100%;height:100%;background-repeat:no-repeat;background-position:50%}@media (-ms-high-contrast:active){.mapboxgl-ctrl-icon{background-color:transparent}.mapboxgl-ctrl-group button+button{border-top:1px solid ButtonText}}.mapboxgl-ctrl button::-moz-focus-inner{border:0;padding:0}.mapboxgl-ctrl-attrib-button:focus,.mapboxgl-ctrl-group button:focus{box-shadow:0 0 2px 2px #0096ff}.mapboxgl-ctrl button:disabled{cursor:not-allowed}.mapboxgl-ctrl button:disabled .mapboxgl-ctrl-icon{opacity:.25}.mapboxgl-ctrl button:not(:disabled):hover{background-color:rgba(0,0,0,.05)}.mapboxgl-ctrl-group button:focus:focus-visible{box-shadow:0 0 2px 2px #0096ff}.mapboxgl-ctrl-group button:focus:not(:focus-visible){box-shadow:none}.mapboxgl-ctrl-group button:focus:first-child{border-radius:4px 4px 0 0}.mapboxgl-ctrl-group button:focus:last-child{border-radius:0 0 4px 4px}.mapboxgl-ctrl-group button:focus:only-child{border-radius:inherit}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E")}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E")}}.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E")}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E")}}.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E")}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23999'/%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E")}}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23aaa'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath d='M14 5l1 1-9 9-1-1 9-9z' fill='red'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active-error .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e58978'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background-error .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e54e33'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-waiting .mapboxgl-ctrl-icon{-webkit-animation:mapboxgl-spin 2s linear infinite;animation:mapboxgl-spin 2s linear infinite}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23999'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath d='M14 5l1 1-9 9-1-1 9-9z' fill='red'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active-error .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e58978'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background-error .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e54e33'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23666'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath d='M14 5l1 1-9 9-1-1 9-9z' fill='red'/%3E%3C/svg%3E")}}@-webkit-keyframes mapboxgl-spin{0%{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(1turn)}}@keyframes mapboxgl-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}a.mapboxgl-ctrl-logo{width:88px;height:23px;margin:0 0 -4px -4px;display:block;background-repeat:no-repeat;cursor:pointer;overflow:hidden;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='88' height='23' viewBox='0 0 88 23' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd'%3E%3Cdefs%3E%3Cpath id='a' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='b' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='c'%3E%3Crect width='100%25' height='100%25' fill='%23fff'/%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/mask%3E%3Cg opacity='.3' stroke='%23000' stroke-width='3'%3E%3Ccircle mask='url(%23c)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23b' mask='url(%23c)'/%3E%3C/g%3E%3Cg opacity='.9' fill='%23fff'%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/g%3E%3C/svg%3E")}a.mapboxgl-ctrl-logo.mapboxgl-compact{width:23px}@media (-ms-high-contrast:active){a.mapboxgl-ctrl-logo{background-color:transparent;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='88' height='23' viewBox='0 0 88 23' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd'%3E%3Cdefs%3E%3Cpath id='a' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='b' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='c'%3E%3Crect width='100%25' height='100%25' fill='%23fff'/%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/mask%3E%3Cg stroke='%23000' stroke-width='3'%3E%3Ccircle mask='url(%23c)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23b' mask='url(%23c)'/%3E%3C/g%3E%3Cg fill='%23fff'%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/g%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){a.mapboxgl-ctrl-logo{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='88' height='23' viewBox='0 0 88 23' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd'%3E%3Cdefs%3E%3Cpath id='a' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='b' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='c'%3E%3Crect width='100%25' height='100%25' fill='%23fff'/%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/mask%3E%3Cg stroke='%23fff' stroke-width='3' fill='%23fff'%3E%3Ccircle mask='url(%23c)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23b' mask='url(%23c)'/%3E%3C/g%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/svg%3E")}}.mapboxgl-ctrl.mapboxgl-ctrl-attrib{padding:0 5px;background-color:hsla(0,0%,100%,.5);margin:0}@media screen{.mapboxgl-ctrl-attrib.mapboxgl-compact{min-height:20px;padding:2px 24px 2px 0;margin:10px;position:relative;background-color:#fff;border-radius:12px}.mapboxgl-ctrl-attrib.mapboxgl-compact-show{padding:2px 28px 2px 8px;visibility:visible}.mapboxgl-ctrl-bottom-left>.mapboxgl-ctrl-attrib.mapboxgl-compact-show,.mapboxgl-ctrl-top-left>.mapboxgl-ctrl-attrib.mapboxgl-compact-show{padding:2px 8px 2px 28px;border-radius:12px}.mapboxgl-ctrl-attrib.mapboxgl-compact .mapboxgl-ctrl-attrib-inner{display:none}.mapboxgl-ctrl-attrib-button{display:none;cursor:pointer;position:absolute;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd'%3E%3Cpath d='M4 10a6 6 0 1012 0 6 6 0 10-12 0m5-3a1 1 0 102 0 1 1 0 10-2 0m0 3a1 1 0 112 0v3a1 1 0 11-2 0'/%3E%3C/svg%3E");background-color:hsla(0,0%,100%,.5);width:24px;height:24px;box-sizing:border-box;border-radius:12px;outline:none;top:0;right:0;border:0}.mapboxgl-ctrl-bottom-left .mapboxgl-ctrl-attrib-button,.mapboxgl-ctrl-top-left .mapboxgl-ctrl-attrib-button{left:0}.mapboxgl-ctrl-attrib.mapboxgl-compact-show .mapboxgl-ctrl-attrib-inner,.mapboxgl-ctrl-attrib.mapboxgl-compact .mapboxgl-ctrl-attrib-button{display:block}.mapboxgl-ctrl-attrib.mapboxgl-compact-show .mapboxgl-ctrl-attrib-button{background-color:rgba(0,0,0,.05)}.mapboxgl-ctrl-bottom-right>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{bottom:0;right:0}.mapboxgl-ctrl-top-right>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{top:0;right:0}.mapboxgl-ctrl-top-left>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{top:0;left:0}.mapboxgl-ctrl-bottom-left>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{bottom:0;left:0}}@media screen and (-ms-high-contrast:active){.mapboxgl-ctrl-attrib.mapboxgl-compact:after{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' fill='%23fff'%3E%3Cpath d='M4 10a6 6 0 1012 0 6 6 0 10-12 0m5-3a1 1 0 102 0 1 1 0 10-2 0m0 3a1 1 0 112 0v3a1 1 0 11-2 0'/%3E%3C/svg%3E")}}@media screen and (-ms-high-contrast:black-on-white){.mapboxgl-ctrl-attrib.mapboxgl-compact:after{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd'%3E%3Cpath d='M4 10a6 6 0 1012 0 6 6 0 10-12 0m5-3a1 1 0 102 0 1 1 0 10-2 0m0 3a1 1 0 112 0v3a1 1 0 11-2 0'/%3E%3C/svg%3E")}}.mapboxgl-ctrl-attrib a{color:rgba(0,0,0,.75);text-decoration:none}.mapboxgl-ctrl-attrib a:hover{color:inherit;text-decoration:underline}.mapboxgl-ctrl-attrib .mapbox-improve-map{font-weight:700;margin-left:2px}.mapboxgl-attrib-empty{display:none}.mapboxgl-ctrl-scale{background-color:hsla(0,0%,100%,.75);font-size:10px;border:2px solid #333;border-top:#333;padding:0 5px;color:#333;box-sizing:border-box}.mapboxgl-popup{position:absolute;top:0;left:0;display:flex;will-change:transform;pointer-events:none}.mapboxgl-popup-anchor-top,.mapboxgl-popup-anchor-top-left,.mapboxgl-popup-anchor-top-right{flex-direction:column}.mapboxgl-popup-anchor-bottom,.mapboxgl-popup-anchor-bottom-left,.mapboxgl-popup-anchor-bottom-right{flex-direction:column-reverse}.mapboxgl-popup-anchor-left{flex-direction:row}.mapboxgl-popup-anchor-right{flex-direction:row-reverse}.mapboxgl-popup-tip{width:0;height:0;border:10px solid transparent;z-index:1}.mapboxgl-popup-anchor-top .mapboxgl-popup-tip{align-self:center;border-top:none;border-bottom-color:#fff}.mapboxgl-popup-anchor-top-left .mapboxgl-popup-tip{align-self:flex-start;border-top:none;border-left:none;border-bottom-color:#fff}.mapboxgl-popup-anchor-top-right .mapboxgl-popup-tip{align-self:flex-end;border-top:none;border-right:none;border-bottom-color:#fff}.mapboxgl-popup-anchor-bottom .mapboxgl-popup-tip{align-self:center;border-bottom:none;border-top-color:#fff}.mapboxgl-popup-anchor-bottom-left .mapboxgl-popup-tip{align-self:flex-start;border-bottom:none;border-left:none;border-top-color:#fff}.mapboxgl-popup-anchor-bottom-right .mapboxgl-popup-tip{align-self:flex-end;border-bottom:none;border-right:none;border-top-color:#fff}.mapboxgl-popup-anchor-left .mapboxgl-popup-tip{align-self:center;border-left:none;border-right-color:#fff}.mapboxgl-popup-anchor-right .mapboxgl-popup-tip{align-self:center;border-right:none;border-left-color:#fff}.mapboxgl-popup-close-button{position:absolute;right:0;top:0;border:0;border-radius:0 3px 0 0;cursor:pointer;background-color:transparent}.mapboxgl-popup-close-button:hover{background-color:rgba(0,0,0,.05)}.mapboxgl-popup-content{position:relative;background:#fff;border-radius:3px;box-shadow:0 1px 2px rgba(0,0,0,.1);padding:10px 10px 15px;pointer-events:auto}.mapboxgl-popup-anchor-top-left .mapboxgl-popup-content{border-top-left-radius:0}.mapboxgl-popup-anchor-top-right .mapboxgl-popup-content{border-top-right-radius:0}.mapboxgl-popup-anchor-bottom-left .mapboxgl-popup-content{border-bottom-left-radius:0}.mapboxgl-popup-anchor-bottom-right .mapboxgl-popup-content{border-bottom-right-radius:0}.mapboxgl-popup-track-pointer{display:none}.mapboxgl-popup-track-pointer *{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.mapboxgl-map:hover .mapboxgl-popup-track-pointer{display:flex}.mapboxgl-map:active .mapboxgl-popup-track-pointer{display:none}.mapboxgl-marker{position:absolute;top:0;left:0;will-change:transform}.mapboxgl-user-location-dot,.mapboxgl-user-location-dot:before{background-color:#1da1f2;width:15px;height:15px;border-radius:50%}.mapboxgl-user-location-dot:before{content:"";position:absolute;-webkit-animation:mapboxgl-user-location-dot-pulse 2s infinite;animation:mapboxgl-user-location-dot-pulse 2s infinite}.mapboxgl-user-location-dot:after{border-radius:50%;border:2px solid #fff;content:"";height:19px;left:-2px;position:absolute;top:-2px;width:19px;box-sizing:border-box;box-shadow:0 0 3px rgba(0,0,0,.35)}@-webkit-keyframes mapboxgl-user-location-dot-pulse{0%{-webkit-transform:scale(1);opacity:1}70%{-webkit-transform:scale(3);opacity:0}to{-webkit-transform:scale(1);opacity:0}}@keyframes mapboxgl-user-location-dot-pulse{0%{-webkit-transform:scale(1);transform:scale(1);opacity:1}70%{-webkit-transform:scale(3);transform:scale(3);opacity:0}to{-webkit-transform:scale(1);transform:scale(1);opacity:0}}.mapboxgl-user-location-dot-stale{background-color:#aaa}.mapboxgl-user-location-dot-stale:after{display:none}.mapboxgl-user-location-accuracy-circle{background-color:rgba(29,161,242,.2);width:1px;height:1px;border-radius:100%}.mapboxgl-crosshair,.mapboxgl-crosshair .mapboxgl-interactive,.mapboxgl-crosshair .mapboxgl-interactive:active{cursor:crosshair}.mapboxgl-boxzoom{position:absolute;top:0;left:0;width:0;height:0;background:#fff;border:2px dotted #202020;opacity:.5}@media print{.mapbox-improve-map{display:none}}`);
window.mapboxgl = import_mapbox_gl.default;
var mapdivCount = 0;
var MAPBOX_API_KEY = "101MlGsZ2AmmA&access_token=pk.eyJ1IjoiZXhhbXBsZXMiLCJhIjoiY2p0MG01MXRqMW45cjQzb2R6b2ptc3J4MSJ9.zA2W0IkI0c6KaAhJfk9bWg";
var MapboxService = class extends BaseMapService {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "version", "MAPBOX");
    _defineProperty(this, "viewport", void 0);
  }
  getType() {
    return "mapbox";
  }
  /**
   * 将经纬度转成墨卡托坐标
   * @param lnglat
   * @returns
   */
  lngLatToCoord(lnglat, origin = {
    x: 0,
    y: 0,
    z: 0
  }) {
    const {
      x: x2,
      y
    } = this.lngLatToMercator(lnglat, 0);
    return [x2 - origin.x, y - origin.y];
  }
  lngLatToMercator(lnglat, altitude) {
    const {
      x: x2 = 0,
      y = 0,
      z = 0
    } = window.mapboxgl.MercatorCoordinate.fromLngLat(lnglat, altitude);
    return {
      x: x2,
      y,
      z
    };
  }
  getModelMatrix(lnglat, altitude, rotate5, scale6 = [1, 1, 1], origin = {
    x: 0,
    y: 0,
    z: 0
  }) {
    const modelAsMercatorCoordinate = window.mapboxgl.MercatorCoordinate.fromLngLat(lnglat, altitude);
    const meters = modelAsMercatorCoordinate.meterInMercatorCoordinateUnits();
    const modelMatrix = mat4_exports.create();
    mat4_exports.translate(modelMatrix, modelMatrix, vec3_exports.fromValues(modelAsMercatorCoordinate.x - origin.x, modelAsMercatorCoordinate.y - origin.y, modelAsMercatorCoordinate.z || 0 - origin.z));
    mat4_exports.scale(modelMatrix, modelMatrix, vec3_exports.fromValues(meters * scale6[0], -meters * scale6[1], meters * scale6[2]));
    mat4_exports.rotateX(modelMatrix, modelMatrix, rotate5[0]);
    mat4_exports.rotateY(modelMatrix, modelMatrix, rotate5[1]);
    mat4_exports.rotateZ(modelMatrix, modelMatrix, rotate5[2]);
    return modelMatrix;
  }
  init() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const _this$config = _this.config, {
        id: id2 = "map",
        attributionControl = false,
        style = "light",
        token = MAPBOX_API_KEY,
        rotation = 0,
        mapInstance
      } = _this$config, rest = _objectWithoutProperties(_this$config, _excluded8);
      _this.viewport = new Viewport2();
      if (!mapInstance && !window.mapboxgl) {
        console.error(_this.configService.getSceneWarninfo("SDK"));
      }
      if (token === MAPBOX_API_KEY && style !== "blank" && !window.mapboxgl.accessToken && !mapInstance) {
        console.warn(_this.configService.getSceneWarninfo("MapToken"));
      }
      if (!mapInstance && !window.mapboxgl.accessToken) {
        window.mapboxgl.accessToken = token;
      }
      if (mapInstance) {
        _this.map = mapInstance;
        _this.$mapContainer = _this.map.getContainer();
      } else {
        _this.$mapContainer = _this.creatMapContainer(id2);
        _this.map = new window.mapboxgl.Map(_objectSpread2({
          container: _this.$mapContainer,
          style: _this.getMapStyleValue(style),
          attributionControl,
          bearing: rotation
        }, rest));
      }
      _this.map.on("load", () => {
        _this.handleCameraChanged();
      });
      _this.map.on("move", _this.handleCameraChanged);
      _this.handleCameraChanged();
    })();
  }
  destroy() {
    var _this$$mapContainer;
    (_this$$mapContainer = this.$mapContainer) === null || _this$$mapContainer === void 0 || (_this$$mapContainer = _this$$mapContainer.parentNode) === null || _this$$mapContainer === void 0 || _this$$mapContainer.removeChild(this.$mapContainer);
    this.eventEmitter.removeAllListeners();
    if (this.map) {
      this.map.remove();
      this.$mapContainer = null;
    }
  }
  emit(name, ...args) {
    this.eventEmitter.emit(name, ...args);
  }
  once(name, ...args) {
    this.eventEmitter.once(name, ...args);
  }
  getMapContainer() {
    return this.$mapContainer;
  }
  getCanvasOverlays() {
    var _this$getMapContainer;
    return (_this$getMapContainer = this.getMapContainer()) === null || _this$getMapContainer === void 0 ? void 0 : _this$getMapContainer.querySelector(".mapboxgl-canvas-container");
  }
  meterToCoord(center, outer) {
    const centerLnglat = new import_mapbox_gl.default.LngLat(center[0], center[1]);
    const outerLnglat = new import_mapbox_gl.default.LngLat(outer[0], outer[1]);
    const meterDis = centerLnglat.distanceTo(outerLnglat);
    const centerMercator = import_mapbox_gl.default.MercatorCoordinate.fromLngLat({
      lng: center[0],
      lat: center[1]
    });
    const outerMercator = import_mapbox_gl.default.MercatorCoordinate.fromLngLat({
      lng: outer[0],
      lat: outer[1]
    });
    const {
      x: x1,
      y: y1
    } = centerMercator;
    const {
      x: x2,
      y: y2
    } = outerMercator;
    const coordDis = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)) * 4194304 * 2;
    return coordDis / meterDis;
  }
  exportMap(type) {
    const renderCanvas = this.map.getCanvas();
    const layersPng = type === "jpg" ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/jpeg") : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/png");
    return layersPng;
  }
  creatMapContainer(id2) {
    let $wrapper = id2;
    if (typeof id2 === "string") {
      $wrapper = document.getElementById(id2);
    }
    const $amapdiv = document.createElement("div");
    $amapdiv.style.cssText += `
      position: absolute;
      top: 0;
      height: 100%;
      width: 100%;
    `;
    $amapdiv.id = "l7_mapbox_div" + mapdivCount++;
    $wrapper.appendChild($amapdiv);
    return $amapdiv;
  }
};

// node_modules/@antv/l7-maps/es/mapbox/index.js
function loadStyles6(css, doc) {
  var isMiniAli = typeof my !== "undefined" && !!my && typeof my.showToast === "function" && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== "undefined" && wx !== null && (typeof wx.request !== "undefined" || typeof wx.miniProgram !== "undefined");
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc)
    doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName("head")[0];
  if (!head) {
    head = doc.createElement("head");
    var body = doc.body || doc.getElementsByTagName("body")[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement("style");
  style.type = "text/css";
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles6(`.mapboxgl-ctrl-logo {
  display: none !important;
}
`);
var MapboxWrapper3 = class extends BaseMapWrapper {
  getServiceConstructor() {
    return MapboxService;
  }
};

// node_modules/@antv/l7-maps/es/maplibre/map.js
var import_maplibre_gl = __toESM(require_maplibre_gl());

// node_modules/pmtiles/dist/index.mjs
var __async2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i2 = 0; i2 < 31; ++i2) {
    b[i2] = start += 1 << eb[i2 - 1];
  }
  var r = new i32(b[30]);
  for (var i2 = 1; i2 < 30; ++i2) {
    for (var j = b[i2]; j < b[i2 + 1]; ++j) {
      r[j] = j - b[i2] << 5 | i2;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i2 = 0;
  var l = new u16(mb);
  for (; i2 < s; ++i2) {
    if (cd[i2])
      ++l[cd[i2] - 1];
  }
  var le = new u16(mb);
  for (i2 = 1; i2 < mb; ++i2) {
    le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0; i2 < s; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v = le[cd[i2] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i2 = 0; i2 < s; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flrm = hMap(flt, 9, 1);
var fdrm = hMap(fdt, 5, 1);
var max5 = function(a) {
  var m = a[0];
  for (var i2 = 1; i2 < a.length; ++i2) {
    if (a[i2] > m)
      m = a[i2];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  var n = new u8(e - s);
  n.set(v.subarray(s, e));
  return n;
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf || st.i != 2;
  var noSt = st.i;
  if (!buf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (noBuf)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0; i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max5(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0; i2 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i2++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i2++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max5(lt);
        dbt = max5(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (noBuf)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add6 = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b = fleb[i2];
          add6 = bits(dat, pos, (1 << b) - 1) + fl[i2];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (noBuf)
          cbuf(bt + 131072);
        var end = bt + add6;
        if (bt < dt) {
          var shift2 = dl - dt, dend = Math.min(dt, end);
          if (shift2 + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift2 + bt];
        }
        for (; bt < end; bt += 4) {
          buf[bt] = buf[bt - dt];
          buf[bt + 1] = buf[bt + 1 - dt];
          buf[bt + 2] = buf[bt + 2 - dt];
          buf[bt + 3] = buf[bt + 3 - dt];
        }
        bt = end;
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt == buf.length ? buf : slc(buf, 0, bt);
};
var et = new u8(0);
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
};
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
var shift = (n, shift2) => {
  return n * Math.pow(2, shift2);
};
var unshift = (n, shift2) => {
  return Math.floor(n / Math.pow(2, shift2));
};
var getUint24 = (view, pos) => {
  return shift(view.getUint16(pos + 1, true), 8) + view.getUint8(pos);
};
var getUint48 = (view, pos) => {
  return shift(view.getUint32(pos + 2, true), 16) + view.getUint16(pos, true);
};
var compare = (tz, tx, ty, view, i2) => {
  if (tz != view.getUint8(i2))
    return tz - view.getUint8(i2);
  const x2 = getUint24(view, i2 + 1);
  if (tx != x2)
    return tx - x2;
  const y = getUint24(view, i2 + 4);
  if (ty != y)
    return ty - y;
  return 0;
};
var queryLeafdir = (view, z, x2, y) => {
  const offset_len = queryView(view, z | 128, x2, y);
  if (offset_len) {
    return {
      z,
      x: x2,
      y,
      offset: offset_len[0],
      length: offset_len[1],
      is_dir: true
    };
  }
  return null;
};
var queryTile = (view, z, x2, y) => {
  const offset_len = queryView(view, z, x2, y);
  if (offset_len) {
    return {
      z,
      x: x2,
      y,
      offset: offset_len[0],
      length: offset_len[1],
      is_dir: false
    };
  }
  return null;
};
var queryView = (view, z, x2, y) => {
  let m = 0;
  let n = view.byteLength / 17 - 1;
  while (m <= n) {
    const k = n + m >> 1;
    const cmp = compare(z, x2, y, view, k * 17);
    if (cmp > 0) {
      m = k + 1;
    } else if (cmp < 0) {
      n = k - 1;
    } else {
      return [getUint48(view, k * 17 + 7), view.getUint32(k * 17 + 13, true)];
    }
  }
  return null;
};
var entrySort = (a, b) => {
  if (a.is_dir && !b.is_dir) {
    return 1;
  }
  if (!a.is_dir && b.is_dir) {
    return -1;
  }
  if (a.z !== b.z) {
    return a.z - b.z;
  }
  if (a.x !== b.x) {
    return a.x - b.x;
  }
  return a.y - b.y;
};
var parseEntry = (dataview, i2) => {
  const z_raw = dataview.getUint8(i2 * 17);
  const z = z_raw & 127;
  return {
    z,
    x: getUint24(dataview, i2 * 17 + 1),
    y: getUint24(dataview, i2 * 17 + 4),
    offset: getUint48(dataview, i2 * 17 + 7),
    length: dataview.getUint32(i2 * 17 + 13, true),
    is_dir: z_raw >> 7 === 1
  };
};
var sortDir = (a) => {
  const entries = [];
  const view = new DataView(a);
  for (let i2 = 0; i2 < view.byteLength / 17; i2++) {
    entries.push(parseEntry(view, i2));
  }
  return createDirectory(entries);
};
var createDirectory = (entries) => {
  entries.sort(entrySort);
  const buffer = new ArrayBuffer(17 * entries.length);
  const arr = new Uint8Array(buffer);
  for (let i2 = 0; i2 < entries.length; i2++) {
    const entry = entries[i2];
    let z = entry.z;
    if (entry.is_dir)
      z = z | 128;
    arr[i2 * 17] = z;
    arr[i2 * 17 + 1] = entry.x & 255;
    arr[i2 * 17 + 2] = entry.x >> 8 & 255;
    arr[i2 * 17 + 3] = entry.x >> 16 & 255;
    arr[i2 * 17 + 4] = entry.y & 255;
    arr[i2 * 17 + 5] = entry.y >> 8 & 255;
    arr[i2 * 17 + 6] = entry.y >> 16 & 255;
    arr[i2 * 17 + 7] = entry.offset & 255;
    arr[i2 * 17 + 8] = unshift(entry.offset, 8) & 255;
    arr[i2 * 17 + 9] = unshift(entry.offset, 16) & 255;
    arr[i2 * 17 + 10] = unshift(entry.offset, 24) & 255;
    arr[i2 * 17 + 11] = unshift(entry.offset, 32) & 255;
    arr[i2 * 17 + 12] = unshift(entry.offset, 48) & 255;
    arr[i2 * 17 + 13] = entry.length & 255;
    arr[i2 * 17 + 14] = entry.length >> 8 & 255;
    arr[i2 * 17 + 15] = entry.length >> 16 & 255;
    arr[i2 * 17 + 16] = entry.length >> 24 & 255;
  }
  return buffer;
};
var deriveLeaf = (view, tile) => {
  if (view.byteLength < 17)
    return null;
  const numEntries = view.byteLength / 17;
  const entry = parseEntry(view, numEntries - 1);
  if (entry.is_dir) {
    const leaf_level = entry.z;
    const level_diff = tile.z - leaf_level;
    const leaf_x = Math.trunc(tile.x / (1 << level_diff));
    const leaf_y = Math.trunc(tile.y / (1 << level_diff));
    return { z: leaf_level, x: leaf_x, y: leaf_y };
  }
  return null;
};
function getHeader(source) {
  return __async2(this, null, function* () {
    const resp = yield source.getBytes(0, 512e3);
    const dataview = new DataView(resp.data);
    const json_size = dataview.getUint32(4, true);
    const root_entries = dataview.getUint16(8, true);
    const dec = new TextDecoder("utf-8");
    const json_metadata = JSON.parse(
      dec.decode(new DataView(resp.data, 10, json_size))
    );
    let tile_compression = 0;
    if (json_metadata.compression === "gzip") {
      tile_compression = 2;
    }
    let minzoom = 0;
    if ("minzoom" in json_metadata) {
      minzoom = +json_metadata.minzoom;
    }
    let maxzoom = 0;
    if ("maxzoom" in json_metadata) {
      maxzoom = +json_metadata.maxzoom;
    }
    let center_lon = 0;
    let center_lat = 0;
    let center_zoom = 0;
    let min_lon = -180;
    let min_lat = -85;
    let max_lon = 180;
    let max_lat = 85;
    if (json_metadata.bounds) {
      const split = json_metadata.bounds.split(",");
      min_lon = +split[0];
      min_lat = +split[1];
      max_lon = +split[2];
      max_lat = +split[3];
    }
    if (json_metadata.center) {
      const split = json_metadata.center.split(",");
      center_lon = +split[0];
      center_lat = +split[1];
      center_zoom = +split[2];
    }
    const header = {
      specVersion: dataview.getUint16(2, true),
      rootDirectoryOffset: 10 + json_size,
      rootDirectoryLength: root_entries * 17,
      jsonMetadataOffset: 10,
      jsonMetadataLength: json_size,
      leafDirectoryOffset: 0,
      leafDirectoryLength: void 0,
      tileDataOffset: 0,
      tileDataLength: void 0,
      numAddressedTiles: 0,
      numTileEntries: 0,
      numTileContents: 0,
      clustered: false,
      internalCompression: 1,
      tileCompression: tile_compression,
      tileType: 1,
      minZoom: minzoom,
      maxZoom: maxzoom,
      minLon: min_lon,
      minLat: min_lat,
      maxLon: max_lon,
      maxLat: max_lat,
      centerZoom: center_zoom,
      centerLon: center_lon,
      centerLat: center_lat,
      etag: resp.etag
    };
    return header;
  });
}
function getZxy(header, source, cache, z, x2, y, signal) {
  return __async2(this, null, function* () {
    let root_dir = yield cache.getArrayBuffer(
      source,
      header.rootDirectoryOffset,
      header.rootDirectoryLength,
      header
    );
    if (header.specVersion === 1) {
      root_dir = sortDir(root_dir);
    }
    const entry = queryTile(new DataView(root_dir), z, x2, y);
    if (entry) {
      const resp = yield source.getBytes(entry.offset, entry.length, signal);
      let tile_data = resp.data;
      const view = new DataView(tile_data);
      if (view.getUint8(0) == 31 && view.getUint8(1) == 139) {
        tile_data = decompressSync(new Uint8Array(tile_data));
      }
      return {
        data: tile_data
      };
    }
    const leafcoords = deriveLeaf(new DataView(root_dir), { z, x: x2, y });
    if (leafcoords) {
      const leafdir_entry = queryLeafdir(
        new DataView(root_dir),
        leafcoords.z,
        leafcoords.x,
        leafcoords.y
      );
      if (leafdir_entry) {
        let leaf_dir = yield cache.getArrayBuffer(
          source,
          leafdir_entry.offset,
          leafdir_entry.length,
          header
        );
        if (header.specVersion === 1) {
          leaf_dir = sortDir(leaf_dir);
        }
        const tile_entry = queryTile(new DataView(leaf_dir), z, x2, y);
        if (tile_entry) {
          const resp = yield source.getBytes(
            tile_entry.offset,
            tile_entry.length,
            signal
          );
          let tile_data = resp.data;
          const view = new DataView(tile_data);
          if (view.getUint8(0) == 31 && view.getUint8(1) == 139) {
            tile_data = decompressSync(new Uint8Array(tile_data));
          }
          return {
            data: tile_data
          };
        }
      }
    }
    return void 0;
  });
}
var v2_default = {
  getHeader,
  getZxy
};
var Protocol = class {
  constructor() {
    this.tile = (params, callback) => {
      if (params.type == "json") {
        const pmtiles_url = params.url.substr(10);
        let instance = this.tiles.get(pmtiles_url);
        if (!instance) {
          instance = new PMTiles(pmtiles_url);
          this.tiles.set(pmtiles_url, instance);
        }
        instance.getHeader().then((h) => {
          const tilejson = {
            tiles: [params.url + "/{z}/{x}/{y}"],
            minzoom: h.minZoom,
            maxzoom: h.maxZoom,
            bounds: [h.minLon, h.minLat, h.maxLon, h.maxLat]
          };
          callback(null, tilejson, null, null);
        }).catch((e) => {
          callback(e, null, null, null);
        });
        return {
          cancel: () => {
          }
        };
      } else {
        const re = new RegExp(/pmtiles:\/\/(.+)\/(\d+)\/(\d+)\/(\d+)/);
        const result = params.url.match(re);
        if (!result) {
          throw new Error("Invalid PMTiles protocol URL");
          return {
            cancel: () => {
            }
          };
        }
        const pmtiles_url = result[1];
        let instance = this.tiles.get(pmtiles_url);
        if (!instance) {
          instance = new PMTiles(pmtiles_url);
          this.tiles.set(pmtiles_url, instance);
        }
        const z = result[2];
        const x2 = result[3];
        const y = result[4];
        const controller = new AbortController();
        const signal = controller.signal;
        let cancel = () => {
          controller.abort();
        };
        instance.getHeader().then((header) => {
          instance.getZxy(+z, +x2, +y, signal).then((resp) => {
            if (resp) {
              callback(
                null,
                new Uint8Array(resp.data),
                resp.cacheControl,
                resp.expires
              );
            } else {
              if (header.tileType == 1) {
                callback(null, new Uint8Array(), null, null);
              } else {
                callback(null, null, null, null);
              }
            }
          }).catch((e) => {
            if (e.name !== "AbortError") {
              callback(e, null, null, null);
            }
          });
        });
        return {
          cancel
        };
      }
    };
    this.tiles = /* @__PURE__ */ new Map();
  }
  add(p) {
    this.tiles.set(p.source.getKey(), p);
  }
  get(url) {
    return this.tiles.get(url);
  }
};
function toNum(low, high) {
  return (high >>> 0) * 4294967296 + (low >>> 0);
}
function readVarintRemainder(l, p) {
  const buf = p.buf;
  let h, b;
  b = buf[p.pos++];
  h = (b & 112) >> 4;
  if (b < 128)
    return toNum(l, h);
  b = buf[p.pos++];
  h |= (b & 127) << 3;
  if (b < 128)
    return toNum(l, h);
  b = buf[p.pos++];
  h |= (b & 127) << 10;
  if (b < 128)
    return toNum(l, h);
  b = buf[p.pos++];
  h |= (b & 127) << 17;
  if (b < 128)
    return toNum(l, h);
  b = buf[p.pos++];
  h |= (b & 127) << 24;
  if (b < 128)
    return toNum(l, h);
  b = buf[p.pos++];
  h |= (b & 1) << 31;
  if (b < 128)
    return toNum(l, h);
  throw new Error("Expected varint not more than 10 bytes");
}
function readVarint(p) {
  const buf = p.buf;
  let val, b;
  b = buf[p.pos++];
  val = b & 127;
  if (b < 128)
    return val;
  b = buf[p.pos++];
  val |= (b & 127) << 7;
  if (b < 128)
    return val;
  b = buf[p.pos++];
  val |= (b & 127) << 14;
  if (b < 128)
    return val;
  b = buf[p.pos++];
  val |= (b & 127) << 21;
  if (b < 128)
    return val;
  b = buf[p.pos];
  val |= (b & 15) << 28;
  return readVarintRemainder(val, p);
}
function rotate4(n, xy, rx, ry) {
  if (ry == 0) {
    if (rx == 1) {
      xy[0] = n - 1 - xy[0];
      xy[1] = n - 1 - xy[1];
    }
    const t = xy[0];
    xy[0] = xy[1];
    xy[1] = t;
  }
}
var tzValues = [
  0,
  1,
  5,
  21,
  85,
  341,
  1365,
  5461,
  21845,
  87381,
  349525,
  1398101,
  5592405,
  22369621,
  89478485,
  357913941,
  1431655765,
  5726623061,
  22906492245,
  91625968981,
  366503875925,
  1466015503701,
  5864062014805,
  23456248059221,
  93824992236885,
  375299968947541,
  1501199875790165
];
function zxyToTileId(z, x2, y) {
  if (z > 26) {
    throw Error("Tile zoom level exceeds max safe number limit (26)");
  }
  if (x2 > Math.pow(2, z) - 1 || y > Math.pow(2, z) - 1) {
    throw Error("tile x/y outside zoom level bounds");
  }
  const acc = tzValues[z];
  const n = Math.pow(2, z);
  let rx = 0;
  let ry = 0;
  let d = 0;
  const xy = [x2, y];
  let s = n / 2;
  while (s > 0) {
    rx = (xy[0] & s) > 0 ? 1 : 0;
    ry = (xy[1] & s) > 0 ? 1 : 0;
    d += s * s * (3 * rx ^ ry);
    rotate4(s, xy, rx, ry);
    s = s / 2;
  }
  return acc + d;
}
var Compression = ((Compression2) => {
  Compression2[Compression2["Unknown"] = 0] = "Unknown";
  Compression2[Compression2["None"] = 1] = "None";
  Compression2[Compression2["Gzip"] = 2] = "Gzip";
  Compression2[Compression2["Brotli"] = 3] = "Brotli";
  Compression2[Compression2["Zstd"] = 4] = "Zstd";
  return Compression2;
})(Compression || {});
function defaultDecompress(buf, compression) {
  return __async2(this, null, function* () {
    if (compression === 1 || compression === 0) {
      return buf;
    } else if (compression === 2) {
      if (typeof globalThis.DecompressionStream == "undefined") {
        return decompressSync(new Uint8Array(buf));
      } else {
        let stream = new Response(buf).body;
        let result = stream.pipeThrough(
          new globalThis.DecompressionStream("gzip")
        );
        return new Response(result).arrayBuffer();
      }
    } else {
      throw Error("Compression method not supported");
    }
  });
}
var TileType = ((TileType2) => {
  TileType2[TileType2["Unknown"] = 0] = "Unknown";
  TileType2[TileType2["Mvt"] = 1] = "Mvt";
  TileType2[TileType2["Png"] = 2] = "Png";
  TileType2[TileType2["Jpeg"] = 3] = "Jpeg";
  TileType2[TileType2["Webp"] = 4] = "Webp";
  TileType2[TileType2["Avif"] = 5] = "Avif";
  return TileType2;
})(TileType || {});
var HEADER_SIZE_BYTES = 127;
function findTile(entries, tileId) {
  let m = 0;
  let n = entries.length - 1;
  while (m <= n) {
    const k = n + m >> 1;
    const cmp = tileId - entries[k].tileId;
    if (cmp > 0) {
      m = k + 1;
    } else if (cmp < 0) {
      n = k - 1;
    } else {
      return entries[k];
    }
  }
  if (n >= 0) {
    if (entries[n].runLength === 0) {
      return entries[n];
    }
    if (tileId - entries[n].tileId < entries[n].runLength) {
      return entries[n];
    }
  }
  return null;
}
var FetchSource = class {
  constructor(url, customHeaders = new Headers()) {
    this.url = url;
    this.customHeaders = customHeaders;
  }
  getKey() {
    return this.url;
  }
  setHeaders(customHeaders) {
    this.customHeaders = customHeaders;
  }
  getBytes(offset, length5, signal) {
    return __async2(this, null, function* () {
      let controller;
      if (!signal) {
        controller = new AbortController();
        signal = controller.signal;
      }
      const requestHeaders = new Headers(this.customHeaders);
      requestHeaders.set(
        "Range",
        "bytes=" + offset + "-" + (offset + length5 - 1)
      );
      let resp = yield fetch(this.url, {
        signal,
        headers: requestHeaders
      });
      if (resp.status === 416 && offset === 0) {
        const content_range = resp.headers.get("Content-Range");
        if (!content_range || !content_range.startsWith("bytes */")) {
          throw Error("Missing content-length on 416 response");
        }
        const actual_length = +content_range.substr(8);
        resp = yield fetch(this.url, {
          signal,
          headers: { Range: "bytes=0-" + (actual_length - 1) }
        });
      }
      if (resp.status >= 300) {
        throw Error("Bad response code: " + resp.status);
      }
      const content_length = resp.headers.get("Content-Length");
      if (resp.status === 200 && (!content_length || +content_length > length5)) {
        if (controller)
          controller.abort();
        throw Error(
          "Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving."
        );
      }
      const a = yield resp.arrayBuffer();
      return {
        data: a,
        etag: resp.headers.get("ETag") || void 0,
        cacheControl: resp.headers.get("Cache-Control") || void 0,
        expires: resp.headers.get("Expires") || void 0
      };
    });
  }
};
function getUint64(v, offset) {
  const wh = v.getUint32(offset + 4, true);
  const wl = v.getUint32(offset + 0, true);
  return wh * Math.pow(2, 32) + wl;
}
function bytesToHeader(bytes, etag) {
  const v = new DataView(bytes);
  const spec_version = v.getUint8(7);
  if (spec_version > 3) {
    throw Error(
      `Archive is spec version ${spec_version} but this library supports up to spec version 3`
    );
  }
  return {
    specVersion: spec_version,
    rootDirectoryOffset: getUint64(v, 8),
    rootDirectoryLength: getUint64(v, 16),
    jsonMetadataOffset: getUint64(v, 24),
    jsonMetadataLength: getUint64(v, 32),
    leafDirectoryOffset: getUint64(v, 40),
    leafDirectoryLength: getUint64(v, 48),
    tileDataOffset: getUint64(v, 56),
    tileDataLength: getUint64(v, 64),
    numAddressedTiles: getUint64(v, 72),
    numTileEntries: getUint64(v, 80),
    numTileContents: getUint64(v, 88),
    clustered: v.getUint8(96) === 1,
    internalCompression: v.getUint8(97),
    tileCompression: v.getUint8(98),
    tileType: v.getUint8(99),
    minZoom: v.getUint8(100),
    maxZoom: v.getUint8(101),
    minLon: v.getInt32(102, true) / 1e7,
    minLat: v.getInt32(106, true) / 1e7,
    maxLon: v.getInt32(110, true) / 1e7,
    maxLat: v.getInt32(114, true) / 1e7,
    centerZoom: v.getUint8(118),
    centerLon: v.getInt32(119, true) / 1e7,
    centerLat: v.getInt32(123, true) / 1e7,
    etag
  };
}
function deserializeIndex(buffer) {
  const p = { buf: new Uint8Array(buffer), pos: 0 };
  const numEntries = readVarint(p);
  const entries = [];
  let lastId = 0;
  for (let i2 = 0; i2 < numEntries; i2++) {
    const v = readVarint(p);
    entries.push({ tileId: lastId + v, offset: 0, length: 0, runLength: 1 });
    lastId += v;
  }
  for (let i2 = 0; i2 < numEntries; i2++) {
    entries[i2].runLength = readVarint(p);
  }
  for (let i2 = 0; i2 < numEntries; i2++) {
    entries[i2].length = readVarint(p);
  }
  for (let i2 = 0; i2 < numEntries; i2++) {
    const v = readVarint(p);
    if (v === 0 && i2 > 0) {
      entries[i2].offset = entries[i2 - 1].offset + entries[i2 - 1].length;
    } else {
      entries[i2].offset = v - 1;
    }
  }
  return entries;
}
function detectVersion(a) {
  const v = new DataView(a);
  if (v.getUint16(2, true) === 2) {
    console.warn(
      "PMTiles spec version 2 has been deprecated; please see github.com/protomaps/PMTiles for tools to upgrade"
    );
    return 2;
  } else if (v.getUint16(2, true) === 1) {
    console.warn(
      "PMTiles spec version 1 has been deprecated; please see github.com/protomaps/PMTiles for tools to upgrade"
    );
    return 1;
  }
  return 3;
}
var EtagMismatch = class extends Error {
};
function getHeaderAndRoot(source, decompress, prefetch, current_etag) {
  return __async2(this, null, function* () {
    const resp = yield source.getBytes(0, 16384);
    const v = new DataView(resp.data);
    if (v.getUint16(0, true) !== 19792) {
      throw new Error("Wrong magic number for PMTiles archive");
    }
    if (detectVersion(resp.data) < 3) {
      return [yield v2_default.getHeader(source)];
    }
    const headerData = resp.data.slice(0, HEADER_SIZE_BYTES);
    let resp_etag = resp.etag;
    if (current_etag && resp.etag != current_etag) {
      console.warn(
        "ETag conflict detected; your HTTP server might not support content-based ETag headers. ETags disabled for " + source.getKey()
      );
      resp_etag = void 0;
    }
    const header = bytesToHeader(headerData, resp_etag);
    if (prefetch) {
      const rootDirData = resp.data.slice(
        header.rootDirectoryOffset,
        header.rootDirectoryOffset + header.rootDirectoryLength
      );
      const dirKey = source.getKey() + "|" + (header.etag || "") + "|" + header.rootDirectoryOffset + "|" + header.rootDirectoryLength;
      const rootDir = deserializeIndex(
        yield decompress(rootDirData, header.internalCompression)
      );
      return [header, [dirKey, rootDir.length, rootDir]];
    }
    return [header, void 0];
  });
}
function getDirectory(source, decompress, offset, length5, header) {
  return __async2(this, null, function* () {
    const resp = yield source.getBytes(offset, length5);
    if (header.etag && header.etag !== resp.etag) {
      throw new EtagMismatch(resp.etag);
    }
    const data = yield decompress(resp.data, header.internalCompression);
    const directory = deserializeIndex(data);
    if (directory.length === 0) {
      throw new Error("Empty directory is invalid");
    }
    return directory;
  });
}
var SharedPromiseCache = class {
  constructor(maxCacheEntries = 100, prefetch = true, decompress = defaultDecompress) {
    this.cache = /* @__PURE__ */ new Map();
    this.maxCacheEntries = maxCacheEntries;
    this.counter = 1;
    this.prefetch = prefetch;
    this.decompress = decompress;
  }
  getHeader(source, current_etag) {
    return __async2(this, null, function* () {
      const cacheKey = source.getKey();
      if (this.cache.has(cacheKey)) {
        this.cache.get(cacheKey).lastUsed = this.counter++;
        const data = yield this.cache.get(cacheKey).data;
        return data;
      }
      const p = new Promise((resolve, reject) => {
        getHeaderAndRoot(source, this.decompress, this.prefetch, current_etag).then((res) => {
          if (res[1]) {
            this.cache.set(res[1][0], {
              lastUsed: this.counter++,
              data: Promise.resolve(res[1][2])
            });
          }
          resolve(res[0]);
          this.prune();
        }).catch((e) => {
          reject(e);
        });
      });
      this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });
      return p;
    });
  }
  getDirectory(source, offset, length5, header) {
    return __async2(this, null, function* () {
      const cacheKey = source.getKey() + "|" + (header.etag || "") + "|" + offset + "|" + length5;
      if (this.cache.has(cacheKey)) {
        this.cache.get(cacheKey).lastUsed = this.counter++;
        const data = yield this.cache.get(cacheKey).data;
        return data;
      }
      const p = new Promise((resolve, reject) => {
        getDirectory(source, this.decompress, offset, length5, header).then((directory) => {
          resolve(directory);
          this.prune();
        }).catch((e) => {
          reject(e);
        });
      });
      this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });
      return p;
    });
  }
  getArrayBuffer(source, offset, length5, header) {
    return __async2(this, null, function* () {
      const cacheKey = source.getKey() + "|" + (header.etag || "") + "|" + offset + "|" + length5;
      if (this.cache.has(cacheKey)) {
        this.cache.get(cacheKey).lastUsed = this.counter++;
        const data = yield this.cache.get(cacheKey).data;
        return data;
      }
      const p = new Promise((resolve, reject) => {
        source.getBytes(offset, length5).then((resp) => {
          if (header.etag && header.etag !== resp.etag) {
            throw new EtagMismatch(resp.etag);
          }
          resolve(resp.data);
          if (this.cache.has(cacheKey)) {
          }
          this.prune();
        }).catch((e) => {
          reject(e);
        });
      });
      this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });
      return p;
    });
  }
  prune() {
    if (this.cache.size >= this.maxCacheEntries) {
      let minUsed = Infinity;
      let minKey = void 0;
      this.cache.forEach(
        (cache_value, key) => {
          if (cache_value.lastUsed < minUsed) {
            minUsed = cache_value.lastUsed;
            minKey = key;
          }
        }
      );
      if (minKey) {
        this.cache.delete(minKey);
      }
    }
  }
  invalidate(source, current_etag) {
    return __async2(this, null, function* () {
      this.cache.delete(source.getKey());
      yield this.getHeader(source, current_etag);
    });
  }
};
var PMTiles = class {
  constructor(source, cache, decompress) {
    if (typeof source === "string") {
      this.source = new FetchSource(source);
    } else {
      this.source = source;
    }
    if (decompress) {
      this.decompress = decompress;
    } else {
      this.decompress = defaultDecompress;
    }
    if (cache) {
      this.cache = cache;
    } else {
      this.cache = new SharedPromiseCache();
    }
  }
  getHeader() {
    return __async2(this, null, function* () {
      return yield this.cache.getHeader(this.source);
    });
  }
  getZxyAttempt(z, x2, y, signal) {
    return __async2(this, null, function* () {
      const tile_id = zxyToTileId(z, x2, y);
      const header = yield this.cache.getHeader(this.source);
      if (header.specVersion < 3) {
        return v2_default.getZxy(header, this.source, this.cache, z, x2, y, signal);
      }
      if (z < header.minZoom || z > header.maxZoom) {
        return void 0;
      }
      let d_o = header.rootDirectoryOffset;
      let d_l = header.rootDirectoryLength;
      for (let depth = 0; depth <= 3; depth++) {
        const directory = yield this.cache.getDirectory(
          this.source,
          d_o,
          d_l,
          header
        );
        const entry = findTile(directory, tile_id);
        if (entry) {
          if (entry.runLength > 0) {
            const resp = yield this.source.getBytes(
              header.tileDataOffset + entry.offset,
              entry.length,
              signal
            );
            if (header.etag && header.etag !== resp.etag) {
              throw new EtagMismatch(resp.etag);
            }
            return {
              data: yield this.decompress(resp.data, header.tileCompression),
              cacheControl: resp.cacheControl,
              expires: resp.expires
            };
          } else {
            d_o = header.leafDirectoryOffset + entry.offset;
            d_l = entry.length;
          }
        } else {
          return void 0;
        }
      }
      throw Error("Maximum directory depth exceeded");
    });
  }
  getZxy(z, x2, y, signal) {
    return __async2(this, null, function* () {
      try {
        return yield this.getZxyAttempt(z, x2, y, signal);
      } catch (e) {
        if (e instanceof EtagMismatch) {
          this.cache.invalidate(this.source, e.message);
          return yield this.getZxyAttempt(z, x2, y, signal);
        } else {
          throw e;
        }
      }
    });
  }
  getMetadataAttempt() {
    return __async2(this, null, function* () {
      const header = yield this.cache.getHeader(this.source);
      const resp = yield this.source.getBytes(
        header.jsonMetadataOffset,
        header.jsonMetadataLength
      );
      if (header.etag && header.etag !== resp.etag) {
        throw new EtagMismatch(resp.etag);
      }
      const decompressed = yield this.decompress(
        resp.data,
        header.internalCompression
      );
      const dec = new TextDecoder("utf-8");
      return JSON.parse(dec.decode(decompressed));
    });
  }
  getMetadata() {
    return __async2(this, null, function* () {
      try {
        return yield this.getMetadataAttempt();
      } catch (e) {
        if (e instanceof EtagMismatch) {
          this.cache.invalidate(this.source, e.message);
          return yield this.getMetadataAttempt();
        } else {
          throw e;
        }
      }
    });
  }
};

// node_modules/@antv/l7-maps/es/maplibre/map.js
var _excluded9 = ["id", "attributionControl", "style", "rotation", "mapInstance"];
function loadStyles7(css, doc) {
  var isMiniAli = typeof my !== "undefined" && !!my && typeof my.showToast === "function" && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== "undefined" && wx !== null && (typeof wx.request !== "undefined" || typeof wx.miniProgram !== "undefined");
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc)
    doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName("head")[0];
  if (!head) {
    head = doc.createElement("head");
    var body = doc.body || doc.getElementsByTagName("body")[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement("style");
  style.type = "text/css";
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles7(`.maplibregl-map{-webkit-tap-highlight-color:rgb(0 0 0/0);font:12px/20px Helvetica Neue,Arial,Helvetica,sans-serif;overflow:hidden;position:relative}.maplibregl-canvas{left:0;position:absolute;top:0}.maplibregl-map:-moz-full-screen{height:100%;width:100%}.maplibregl-map:-ms-fullscreen{height:100%;width:100%}.maplibregl-map:fullscreen{height:100%;width:100%}.maplibregl-ctrl-group button.maplibregl-ctrl-compass{touch-action:none}.maplibregl-canvas-container.maplibregl-interactive,.maplibregl-ctrl-group button.maplibregl-ctrl-compass{cursor:grab;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.maplibregl-canvas-container.maplibregl-interactive.maplibregl-track-pointer{cursor:pointer}.maplibregl-canvas-container.maplibregl-interactive:active,.maplibregl-ctrl-group button.maplibregl-ctrl-compass:active{cursor:grabbing}.maplibregl-canvas-container.maplibregl-touch-zoom-rotate,.maplibregl-canvas-container.maplibregl-touch-zoom-rotate .maplibregl-canvas{touch-action:pan-x pan-y}.maplibregl-canvas-container.maplibregl-touch-drag-pan,.maplibregl-canvas-container.maplibregl-touch-drag-pan .maplibregl-canvas{touch-action:pinch-zoom}.maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan,.maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan .maplibregl-canvas{touch-action:none}.maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures,.maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures .maplibregl-canvas{touch-action:pan-x pan-y}.maplibregl-ctrl-bottom-left,.maplibregl-ctrl-bottom-right,.maplibregl-ctrl-top-left,.maplibregl-ctrl-top-right{pointer-events:none;position:absolute;z-index:2}.maplibregl-ctrl-top-left{left:0;top:0}.maplibregl-ctrl-top-right{right:0;top:0}.maplibregl-ctrl-bottom-left{bottom:0;left:0}.maplibregl-ctrl-bottom-right{bottom:0;right:0}.maplibregl-ctrl{clear:both;pointer-events:auto;-webkit-transform:translate(0);transform:translate(0)}.maplibregl-ctrl-top-left .maplibregl-ctrl{float:left;margin:10px 0 0 10px}.maplibregl-ctrl-top-right .maplibregl-ctrl{float:right;margin:10px 10px 0 0}.maplibregl-ctrl-bottom-left .maplibregl-ctrl{float:left;margin:0 0 10px 10px}.maplibregl-ctrl-bottom-right .maplibregl-ctrl{float:right;margin:0 10px 10px 0}.maplibregl-ctrl-group{background:#fff;border-radius:4px}.maplibregl-ctrl-group:not(:empty){box-shadow:0 0 0 2px rgba(0,0,0,.1)}@media (-ms-high-contrast:active){.maplibregl-ctrl-group:not(:empty){box-shadow:0 0 0 2px ButtonText}}.maplibregl-ctrl-group button{background-color:transparent;border:0;box-sizing:border-box;cursor:pointer;display:block;height:29px;outline:none;padding:0;width:29px}.maplibregl-ctrl-group button+button{border-top:1px solid #ddd}.maplibregl-ctrl button .maplibregl-ctrl-icon{background-position:50%;background-repeat:no-repeat;display:block;height:100%;width:100%}@media (-ms-high-contrast:active){.maplibregl-ctrl-icon{background-color:transparent}.maplibregl-ctrl-group button+button{border-top:1px solid ButtonText}}.maplibregl-ctrl button::-moz-focus-inner{border:0;padding:0}.maplibregl-ctrl-attrib-button:focus,.maplibregl-ctrl-group button:focus{box-shadow:0 0 2px 2px #0096ff}.maplibregl-ctrl button:disabled{cursor:not-allowed}.maplibregl-ctrl button:disabled .maplibregl-ctrl-icon{opacity:.25}.maplibregl-ctrl button:not(:disabled):hover{background-color:rgb(0 0 0/5%)}.maplibregl-ctrl-group button:focus:focus-visible{box-shadow:0 0 2px 2px #0096ff}.maplibregl-ctrl-group button:focus:not(:focus-visible){box-shadow:none}.maplibregl-ctrl-group button:focus:first-child{border-radius:4px 4px 0 0}.maplibregl-ctrl-group button:focus:last-child{border-radius:0 0 4px 4px}.maplibregl-ctrl-group button:focus:only-child{border-radius:inherit}.maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E")}@media (-ms-high-contrast:active){.maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){.maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E")}}.maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E")}@media (-ms-high-contrast:active){.maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){.maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E")}}.maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='m10.5 14 4-8 4 8h-8z'/%3E%3Cpath fill='%23ccc' d='m10.5 16 4 8 4-8h-8z'/%3E%3C/svg%3E")}@media (-ms-high-contrast:active){.maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='m10.5 14 4-8 4 8h-8z'/%3E%3Cpath fill='%23999' d='m10.5 16 4 8 4-8h-8z'/%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){.maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='m10.5 14 4-8 4 8h-8z'/%3E%3Cpath fill='%23ccc' d='m10.5 16 4 8 4-8h-8z'/%3E%3C/svg%3E")}}.maplibregl-ctrl button.maplibregl-ctrl-terrain .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' fill='%23333' viewBox='0 0 22 22'%3E%3Cpath d='m1.754 13.406 4.453-4.851 3.09 3.09 3.281 3.277.969-.969-3.309-3.312 3.844-4.121 6.148 6.886h1.082v-.855l-7.207-8.07-4.84 5.187L6.169 6.57l-5.48 5.965v.871ZM.688 16.844h20.625v1.375H.688Zm0 0'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-terrain-enabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' fill='%2333b5e5' viewBox='0 0 22 22'%3E%3Cpath d='m1.754 13.406 4.453-4.851 3.09 3.09 3.281 3.277.969-.969-3.309-3.312 3.844-4.121 6.148 6.886h1.082v-.855l-7.207-8.07-4.84 5.187L6.169 6.57l-5.48 5.965v.871ZM.688 16.844h20.625v1.375H.688Zm0 0'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23aaa' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath fill='red' d='m14 5 1 1-9 9-1-1 9-9z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e58978' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e54e33' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-waiting .maplibregl-ctrl-icon{-webkit-animation:maplibregl-spin 2s linear infinite;animation:maplibregl-spin 2s linear infinite}@media (-ms-high-contrast:active){.maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23999' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath fill='red' d='m14 5 1 1-9 9-1-1 9-9z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e58978' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e54e33' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){.maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")}.maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23666' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath fill='red' d='m14 5 1 1-9 9-1-1 9-9z'/%3E%3C/svg%3E")}}@-webkit-keyframes maplibregl-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes maplibregl-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}a.maplibregl-ctrl-logo{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='88' height='23' fill='none'%3E%3Cpath fill='%23000' fill-opacity='.4' fill-rule='evenodd' d='M17.408 16.796h-1.827l2.501-12.095h.198l3.324 6.533.988 2.19.988-2.19 3.258-6.533h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.929 5.644h-.098l-2.914-5.644-.757-1.71-.345 1.71zm1.958-3.42-.726 3.663a1.255 1.255 0 0 1-1.232 1.011h-1.827a1.255 1.255 0 0 1-1.229-1.509l2.501-12.095a1.255 1.255 0 0 1 1.23-1.001h.197a1.255 1.255 0 0 1 1.12.685l3.19 6.273 3.125-6.263a1.255 1.255 0 0 1 1.123-.695h.181a1.255 1.255 0 0 1 1.227.991l1.443 6.71a5.11 5.11 0 0 1 .314-.787l.009-.016a4.623 4.623 0 0 1 1.777-1.887c.782-.46 1.668-.667 2.611-.667a4.548 4.548 0 0 1 1.7.32l.306.134c.21-.16.474-.256.759-.256h1.694a1.255 1.255 0 0 1 1.212.925 1.255 1.255 0 0 1 1.212-.925h1.711c.284 0 .545.094.755.252.613-.3 1.312-.45 2.075-.45 1.356 0 2.557.445 3.482 1.4.314.319.566.676.763 1.064V4.701a1.255 1.255 0 0 1 1.255-1.255h1.86A1.255 1.255 0 0 1 54.44 4.7v9.194h2.217c.19 0 .37.043.532.118v-4.77c0-.356.147-.678.385-.906a2.416 2.416 0 0 1-.682-1.71c0-.665.267-1.253.735-1.7a2.448 2.448 0 0 1 1.722-.674 2.43 2.43 0 0 1 1.705.675c.211.2.381.43.504.683V4.7a1.255 1.255 0 0 1 1.255-1.255h1.744A1.255 1.255 0 0 1 65.812 4.7v3.335a4.76 4.76 0 0 1 1.526-.246c.938 0 1.817.214 2.59.69a4.47 4.47 0 0 1 1.67 1.743v-.98a1.255 1.255 0 0 1 1.256-1.256h1.777c.233 0 .451.064.639.174a3.407 3.407 0 0 1 1.567-.372c.346 0 .861.02 1.285.232a1.255 1.255 0 0 1 .689 1.004 4.73 4.73 0 0 1 .853-.588c.795-.44 1.675-.647 2.61-.647 1.385 0 2.65.39 3.525 1.396.836.938 1.168 2.173 1.168 3.528 0 .343-.02.694-.056 1.051a1.255 1.255 0 0 1-.947 1.09l.408.952a1.255 1.255 0 0 1-.477 1.552c-.418.268-.92.463-1.458.612-.613.171-1.304.244-2.049.244-1.06 0-2.043-.207-2.886-.698l-.015-.008c-.798-.48-1.419-1.135-1.818-1.963l-.004-.008a5.815 5.815 0 0 1-.548-2.512c0-.286.017-.567.053-.843a1.255 1.255 0 0 1-.333-.086l-.166-.004c-.223 0-.426.062-.643.228-.03.024-.142.139-.142.59v3.883a1.255 1.255 0 0 1-1.256 1.256h-1.777a1.255 1.255 0 0 1-1.256-1.256V15.69l-.032.057a4.778 4.778 0 0 1-1.86 1.833 5.04 5.04 0 0 1-2.484.634 4.47 4.47 0 0 1-1.935-.424 1.252 1.252 0 0 1-.764.258h-1.71a1.255 1.255 0 0 1-1.256-1.255V7.687a2.402 2.402 0 0 1-.428.625c.253.23.412.561.412.93v7.553a1.255 1.255 0 0 1-1.256 1.255h-1.843a1.25 1.25 0 0 1-.894-.373c-.228.23-.544.373-.894.373H51.32a1.255 1.255 0 0 1-1.256-1.255v-1.251l-.061.117a4.703 4.703 0 0 1-1.782 1.884 4.767 4.767 0 0 1-2.485.67 5.6 5.6 0 0 1-1.485-.188l.009 2.764a1.255 1.255 0 0 1-1.255 1.259h-1.729a1.255 1.255 0 0 1-1.255-1.255v-3.537a1.255 1.255 0 0 1-1.167.793h-1.679a1.25 1.25 0 0 1-.77-.263 4.47 4.47 0 0 1-1.945.429c-.885 0-1.724-.21-2.495-.632l-.017-.01a4.983 4.983 0 0 1-1.081-.836 1.255 1.255 0 0 1-1.254 1.312h-1.81a1.255 1.255 0 0 1-1.228-.99l-.782-3.625-2.044 3.939a1.255 1.255 0 0 1-1.115.676h-.098a1.255 1.255 0 0 1-1.116-.68l-2.061-3.994zM35.92 16.63l.207-.114.223-.15c.329-.237.574-.499.735-.785l.061-.118.033 1.332h1.678V9.242h-1.694l-.033 1.267c-.088-.22-.264-.438-.526-.658l-.032-.028a3.16 3.16 0 0 0-.668-.428l-.27-.12a3.293 3.293 0 0 0-1.235-.23c-.757 0-1.415.163-1.974.493a3.36 3.36 0 0 0-1.3 1.382c-.297.593-.444 1.284-.444 2.074 0 .8.17 1.503.51 2.107a3.795 3.795 0 0 0 1.382 1.381 3.883 3.883 0 0 0 1.893.477c.53 0 1.015-.11 1.455-.33zm-2.789-5.38c-.384.45-.575 1.038-.575 1.762 0 .735.186 1.332.559 1.794.384.45.933.675 1.645.675a2.25 2.25 0 0 0 .934-.19 2.17 2.17 0 0 0 .468-.29l.178-.161a2.163 2.163 0 0 0 .397-.561c.163-.333.244-.717.244-1.15v-.115c0-.472-.098-.894-.296-1.267l-.043-.077a2.211 2.211 0 0 0-.633-.709l-.13-.086-.047-.028a2.099 2.099 0 0 0-1.073-.285c-.702 0-1.244.231-1.629.692zm2.316 2.706c.163-.17.28-.407.28-.83v-.114c0-.292-.06-.508-.15-.68a.958.958 0 0 0-.353-.389.851.851 0 0 0-.464-.127c-.4 0-.56.114-.664.239l-.01.012c-.148.174-.275.45-.275.945 0 .506.122.801.27.99.097.11.266.224.68.224.303 0 .504-.09.687-.269zm7.545 1.705a2.626 2.626 0 0 0 .331.423c.213.22.464.402.755.548l.173.074c.433.17.93.255 1.49.255.68 0 1.295-.165 1.844-.493a3.447 3.447 0 0 0 1.316-1.4c.329-.603.493-1.299.493-2.089 0-1.273-.33-2.243-.988-2.913-.658-.68-1.52-1.02-2.584-1.02-.598 0-1.124.115-1.575.347a2.807 2.807 0 0 0-.415.262l-.199.166a3.35 3.35 0 0 0-.64.82V9.242h-1.712v11.553h1.729l-.017-5.134zm.53-1.138c.137.193.297.36.48.5l.155.11.053.034c.34.197.713.297 1.119.297.714 0 1.262-.225 1.645-.675.385-.46.576-1.048.576-1.762 0-.746-.192-1.338-.576-1.777-.372-.45-.92-.675-1.645-.675-.29 0-.569.053-.835.16a2.366 2.366 0 0 0-.284.136 1.99 1.99 0 0 0-.363.254 2.237 2.237 0 0 0-.46.569l-.082.162a2.56 2.56 0 0 0-.213 1.072v.115c0 .471.098.894.296 1.267l.135.211zm.964-.818a1.11 1.11 0 0 0 .367.385.937.937 0 0 0 .476.118c.423 0 .59-.117.687-.23.159-.194.28-.478.28-.95 0-.53-.133-.8-.266-.952l-.021-.025c-.078-.094-.231-.221-.68-.221a.995.995 0 0 0-.503.135l-.012.007a.859.859 0 0 0-.335.343c-.073.133-.132.324-.132.614v.115a1.43 1.43 0 0 0 .14.66zm15.7-6.222c.232-.23.346-.516.346-.856a1.053 1.053 0 0 0-.345-.79 1.175 1.175 0 0 0-.84-.329c-.34 0-.625.11-.855.33a1.053 1.053 0 0 0-.346.79c0 .34.115.625.346.855.23.23.516.346.856.346.34 0 .62-.115.839-.346zm4.337 9.314.033-1.332c.128.269.324.518.59.747l.098.081a3.727 3.727 0 0 0 .316.224l.223.122a3.21 3.21 0 0 0 1.44.322 3.785 3.785 0 0 0 1.875-.477 3.52 3.52 0 0 0 1.382-1.366c.352-.593.526-1.29.526-2.09 0-.79-.147-1.48-.444-2.073a3.235 3.235 0 0 0-1.283-1.399c-.549-.34-1.195-.51-1.942-.51a3.476 3.476 0 0 0-1.527.344l-.086.043-.165.09a3.412 3.412 0 0 0-.33.214c-.288.21-.507.446-.656.707a1.893 1.893 0 0 0-.099.198l.082-1.283V4.701h-1.744v12.095zm.473-2.509a2.482 2.482 0 0 0 .566.7c.078.065.159.125.245.18l.144.08a2.105 2.105 0 0 0 .975.232c.713 0 1.262-.225 1.645-.675.384-.46.576-1.053.576-1.778 0-.734-.192-1.327-.576-1.777-.373-.46-.921-.692-1.645-.692a2.18 2.18 0 0 0-1.015.235c-.147.075-.285.17-.415.282l-.15.142a2.086 2.086 0 0 0-.42.594c-.149.32-.223.685-.223 1.1v.115c0 .47.097.89.293 1.26zm2.616-.293c.157-.191.28-.479.28-.967 0-.51-.13-.79-.276-.961l-.021-.026c-.082-.1-.232-.225-.67-.225a.868.868 0 0 0-.681.279l-.012.011c-.154.155-.274.38-.274.807v.115c0 .285.057.499.144.669a1.13 1.13 0 0 0 .367.405c.137.082.28.123.455.123.423 0 .59-.118.686-.23zm8.266-3.013c.23-.087.472-.134.724-.14l.069-.002c.329 0 .542.033.642.099l.247-1.794c-.13-.066-.37-.099-.717-.099a2.3 2.3 0 0 0-.545.063 2.086 2.086 0 0 0-.411.148 2.18 2.18 0 0 0-.4.249 2.482 2.482 0 0 0-.485.499 2.659 2.659 0 0 0-.32.581l-.05.137v-1.48h-1.778v7.553h1.777v-3.884c0-.364.053-.678.159-.943a1.49 1.49 0 0 1 .466-.636 2.52 2.52 0 0 1 .399-.253 2.19 2.19 0 0 1 .224-.099zm9.784 2.656.05-.922c0-1.162-.285-2.062-.856-2.698-.559-.647-1.42-.97-2.584-.97-.746 0-1.415.163-2.007.493a3.462 3.462 0 0 0-1.4 1.382c-.329.604-.493 1.306-.493 2.106 0 .714.143 1.371.428 1.975.285.593.73 1.07 1.332 1.432.604.351 1.355.526 2.255.526.649 0 1.204-.062 1.668-.185l.044-.012.135-.04c.409-.122.736-.263.984-.421l-.542-1.267c-.2.108-.415.199-.642.274l-.297.087c-.34.088-.773.131-1.3.131-.636 0-1.135-.147-1.497-.444a1.573 1.573 0 0 1-.192-.193c-.244-.294-.415-.705-.512-1.234l-.004-.021h5.43zm-5.427-1.256-.003.022h3.752v-.138c-.007-.485-.104-.857-.288-1.118a1.056 1.056 0 0 0-.156-.176c-.307-.285-.746-.428-1.316-.428-.657 0-1.155.202-1.494.604-.253.3-.417.712-.494 1.234zm-27.053 2.77V4.7h-1.86v12.095h5.333V15.15zm7.103-5.908v7.553h-1.843V9.242h1.843z'/%3E%3Cpath fill='%23fff' d='m19.63 11.151-.757-1.71-.345 1.71-1.12 5.644h-1.827L18.083 4.7h.197l3.325 6.533.988 2.19.988-2.19L26.839 4.7h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.93 5.644h-.098l-2.913-5.644zm14.836 5.81c-.68 0-1.311-.16-1.893-.478a3.795 3.795 0 0 1-1.381-1.382c-.34-.604-.51-1.306-.51-2.106 0-.79.147-1.482.444-2.074a3.364 3.364 0 0 1 1.3-1.382c.559-.33 1.217-.494 1.974-.494a3.293 3.293 0 0 1 1.234.231 3.341 3.341 0 0 1 .97.575c.264.22.44.439.527.659l.033-1.267h1.694v7.553H37.18l-.033-1.332c-.186.395-.526.746-1.02 1.053a3.167 3.167 0 0 1-1.662.444zm.296-1.482c.626 0 1.152-.214 1.58-.642.428-.44.642-1.01.642-1.711v-.115c0-.472-.098-.894-.296-1.267a2.211 2.211 0 0 0-.807-.872 2.098 2.098 0 0 0-1.119-.313c-.702 0-1.245.231-1.629.692-.384.45-.575 1.037-.575 1.76 0 .736.186 1.333.559 1.795.384.45.933.675 1.645.675zm6.521-6.237h1.711v1.4c.604-1.065 1.547-1.597 2.83-1.597 1.064 0 1.926.34 2.584 1.02.659.67.988 1.641.988 2.914 0 .79-.164 1.487-.493 2.09a3.456 3.456 0 0 1-1.316 1.399 3.51 3.51 0 0 1-1.844.493c-.636 0-1.19-.11-1.662-.329a2.665 2.665 0 0 1-1.086-.97l.017 5.134h-1.728V9.242zm4.048 6.22c.714 0 1.262-.224 1.645-.674.385-.46.576-1.048.576-1.762 0-.746-.192-1.338-.576-1.777-.372-.45-.92-.675-1.645-.675-.395 0-.768.098-1.12.296-.34.187-.613.46-.822.823-.197.351-.296.763-.296 1.234v.115c0 .472.098.894.296 1.267.209.362.483.647.823.855.34.197.713.297 1.119.297z'/%3E%3Cpath fill='%23e1e3e9' d='M51.325 4.7h1.86v10.45h3.473v1.646h-5.333zm7.12 4.542h1.843v7.553h-1.843zm.905-1.415a1.159 1.159 0 0 1-.856-.346 1.165 1.165 0 0 1-.346-.856 1.053 1.053 0 0 1 .346-.79c.23-.219.516-.329.856-.329.329 0 .609.11.839.33a1.053 1.053 0 0 1 .345.79 1.159 1.159 0 0 1-.345.855c-.22.23-.5.346-.84.346zm7.875 9.133a3.167 3.167 0 0 1-1.662-.444c-.482-.307-.817-.658-1.004-1.053l-.033 1.332h-1.71V4.701h1.743v4.657l-.082 1.283c.186-.438.548-.812 1.086-1.119a3.486 3.486 0 0 1 1.778-.477c.746 0 1.393.17 1.942.51a3.235 3.235 0 0 1 1.283 1.4c.297.592.444 1.282.444 2.072 0 .8-.175 1.498-.526 2.09a3.52 3.52 0 0 1-1.382 1.366 3.785 3.785 0 0 1-1.876.477zm-.296-1.481c.713 0 1.26-.225 1.645-.675.384-.46.577-1.053.577-1.778 0-.734-.193-1.327-.577-1.776-.373-.46-.921-.692-1.645-.692a2.115 2.115 0 0 0-1.58.659c-.428.428-.642.992-.642 1.694v.115c0 .473.098.895.296 1.267a2.385 2.385 0 0 0 .807.872 2.1 2.1 0 0 0 1.119.313zm5.927-6.237h1.777v1.481c.176-.505.46-.91.856-1.217a2.14 2.14 0 0 1 1.349-.46c.351 0 .593.032.724.098l-.247 1.794c-.099-.066-.313-.099-.642-.099-.516 0-.988.164-1.416.494-.417.329-.626.855-.626 1.58v3.883h-1.777V9.242zm9.534 7.718c-.9 0-1.651-.175-2.255-.526-.603-.362-1.047-.84-1.332-1.432a4.567 4.567 0 0 1-.428-1.975c0-.8.164-1.502.493-2.106a3.462 3.462 0 0 1 1.4-1.382c.592-.33 1.262-.494 2.007-.494 1.163 0 2.024.324 2.584.97.57.637.856 1.537.856 2.7 0 .296-.017.603-.05.92h-5.43c.12.67.356 1.153.708 1.45.362.296.86.443 1.497.443.526 0 .96-.044 1.3-.131a4.123 4.123 0 0 0 .938-.362l.542 1.267c-.274.175-.647.329-1.119.46-.472.132-1.042.197-1.711.197zm1.596-4.558c.01-.68-.137-1.158-.444-1.432-.307-.285-.746-.428-1.316-.428-1.152 0-1.815.62-1.991 1.86h3.752z'/%3E%3Cg fill-rule='evenodd' stroke-width='1.036'%3E%3Cpath fill='%23000' fill-opacity='.4' d='m8.166 16.146-.002.002a1.54 1.54 0 0 1-2.009 0l-.002-.002-.043-.034-.002-.002-.199-.162H4.377a.657.657 0 0 0-.659.659v1.84a.657.657 0 0 0 .659.659h5.565a.657.657 0 0 0 .659-.659v-1.84a.657.657 0 0 0-.659-.659H8.411l-.202.164zm-1.121-.905a.29.29 0 0 0 .113.023.286.286 0 0 0 .189-.07l.077-.063c.634-.508 4.672-3.743 4.672-7.575 0-2.55-2.215-4.625-4.938-4.625S2.221 5.006 2.221 7.556c0 3.225 2.86 6.027 4.144 7.137h.004l.04.038.484.4.077.063a.628.628 0 0 0 .074.047zm-2.52-.548a16.898 16.898 0 0 1-1.183-1.315C2.187 11.942.967 9.897.967 7.555c0-3.319 2.855-5.88 6.192-5.88 3.338 0 6.193 2.561 6.193 5.881 0 2.34-1.22 4.387-2.376 5.822a16.898 16.898 0 0 1-1.182 1.315h.15a1.912 1.912 0 0 1 1.914 1.914v1.84a1.912 1.912 0 0 1-1.914 1.914H4.377a1.912 1.912 0 0 1-1.914-1.914v-1.84a1.912 1.912 0 0 1 1.914-1.914zm3.82-6.935c0 .692-.55 1.222-1.187 1.222s-1.185-.529-1.185-1.222.548-1.222 1.185-1.222c.638 0 1.186.529 1.186 1.222zm-1.186 2.477c1.348 0 2.442-1.11 2.442-2.478S8.507 5.28 7.159 5.28 4.72 6.39 4.72 7.758s1.092 2.477 2.44 2.477zm2.048 7.71H5.114v-.838h4.093z'/%3E%3Cpath fill='%23e1e3e9' d='M2.222 7.555c0-2.55 2.214-4.625 4.937-4.625 2.723 0 4.938 2.075 4.938 4.625 0 3.832-4.038 7.068-4.672 7.575l-.077.063a.286.286 0 0 1-.189.07.286.286 0 0 1-.188-.07l-.077-.063c-.634-.507-4.672-3.743-4.672-7.575zm4.937 2.68c1.348 0 2.442-1.11 2.442-2.478S8.507 5.28 7.159 5.28 4.72 6.39 4.72 7.758s1.092 2.477 2.44 2.477z'/%3E%3Cpath fill='%23fff' d='M4.377 15.948a.657.657 0 0 0-.659.659v1.84a.657.657 0 0 0 .659.659h5.565a.657.657 0 0 0 .659-.659v-1.84a.657.657 0 0 0-.659-.659zm4.83 1.16H5.114v.838h4.093z'/%3E%3C/g%3E%3C/svg%3E");background-repeat:no-repeat;cursor:pointer;display:block;height:23px;margin:0 0 -4px -4px;overflow:hidden;width:88px}a.maplibregl-ctrl-logo.maplibregl-compact{width:14px}@media (-ms-high-contrast:active){a.maplibregl-ctrl-logo{background-color:transparent;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='88' height='23' fill='none'%3E%3Cpath fill='%23000' fill-opacity='.4' fill-rule='evenodd' d='M17.408 16.796h-1.827l2.501-12.095h.198l3.324 6.533.988 2.19.988-2.19 3.258-6.533h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.929 5.644h-.098l-2.914-5.644-.757-1.71-.345 1.71zm1.958-3.42-.726 3.663a1.255 1.255 0 0 1-1.232 1.011h-1.827a1.255 1.255 0 0 1-1.229-1.509l2.501-12.095a1.255 1.255 0 0 1 1.23-1.001h.197a1.255 1.255 0 0 1 1.12.685l3.19 6.273 3.125-6.263a1.255 1.255 0 0 1 1.123-.695h.181a1.255 1.255 0 0 1 1.227.991l1.443 6.71a5.11 5.11 0 0 1 .314-.787l.009-.016a4.623 4.623 0 0 1 1.777-1.887c.782-.46 1.668-.667 2.611-.667a4.548 4.548 0 0 1 1.7.32l.306.134c.21-.16.474-.256.759-.256h1.694a1.255 1.255 0 0 1 1.212.925 1.255 1.255 0 0 1 1.212-.925h1.711c.284 0 .545.094.755.252.613-.3 1.312-.45 2.075-.45 1.356 0 2.557.445 3.482 1.4.314.319.566.676.763 1.064V4.701a1.255 1.255 0 0 1 1.255-1.255h1.86A1.255 1.255 0 0 1 54.44 4.7v9.194h2.217c.19 0 .37.043.532.118v-4.77c0-.356.147-.678.385-.906a2.416 2.416 0 0 1-.682-1.71c0-.665.267-1.253.735-1.7a2.448 2.448 0 0 1 1.722-.674 2.43 2.43 0 0 1 1.705.675c.211.2.381.43.504.683V4.7a1.255 1.255 0 0 1 1.255-1.255h1.744A1.255 1.255 0 0 1 65.812 4.7v3.335a4.76 4.76 0 0 1 1.526-.246c.938 0 1.817.214 2.59.69a4.47 4.47 0 0 1 1.67 1.743v-.98a1.255 1.255 0 0 1 1.256-1.256h1.777c.233 0 .451.064.639.174a3.407 3.407 0 0 1 1.567-.372c.346 0 .861.02 1.285.232a1.255 1.255 0 0 1 .689 1.004 4.73 4.73 0 0 1 .853-.588c.795-.44 1.675-.647 2.61-.647 1.385 0 2.65.39 3.525 1.396.836.938 1.168 2.173 1.168 3.528 0 .343-.02.694-.056 1.051a1.255 1.255 0 0 1-.947 1.09l.408.952a1.255 1.255 0 0 1-.477 1.552c-.418.268-.92.463-1.458.612-.613.171-1.304.244-2.049.244-1.06 0-2.043-.207-2.886-.698l-.015-.008c-.798-.48-1.419-1.135-1.818-1.963l-.004-.008a5.815 5.815 0 0 1-.548-2.512c0-.286.017-.567.053-.843a1.255 1.255 0 0 1-.333-.086l-.166-.004c-.223 0-.426.062-.643.228-.03.024-.142.139-.142.59v3.883a1.255 1.255 0 0 1-1.256 1.256h-1.777a1.255 1.255 0 0 1-1.256-1.256V15.69l-.032.057a4.778 4.778 0 0 1-1.86 1.833 5.04 5.04 0 0 1-2.484.634 4.47 4.47 0 0 1-1.935-.424 1.252 1.252 0 0 1-.764.258h-1.71a1.255 1.255 0 0 1-1.256-1.255V7.687a2.402 2.402 0 0 1-.428.625c.253.23.412.561.412.93v7.553a1.255 1.255 0 0 1-1.256 1.255h-1.843a1.25 1.25 0 0 1-.894-.373c-.228.23-.544.373-.894.373H51.32a1.255 1.255 0 0 1-1.256-1.255v-1.251l-.061.117a4.703 4.703 0 0 1-1.782 1.884 4.767 4.767 0 0 1-2.485.67 5.6 5.6 0 0 1-1.485-.188l.009 2.764a1.255 1.255 0 0 1-1.255 1.259h-1.729a1.255 1.255 0 0 1-1.255-1.255v-3.537a1.255 1.255 0 0 1-1.167.793h-1.679a1.25 1.25 0 0 1-.77-.263 4.47 4.47 0 0 1-1.945.429c-.885 0-1.724-.21-2.495-.632l-.017-.01a4.983 4.983 0 0 1-1.081-.836 1.255 1.255 0 0 1-1.254 1.312h-1.81a1.255 1.255 0 0 1-1.228-.99l-.782-3.625-2.044 3.939a1.255 1.255 0 0 1-1.115.676h-.098a1.255 1.255 0 0 1-1.116-.68l-2.061-3.994zM35.92 16.63l.207-.114.223-.15c.329-.237.574-.499.735-.785l.061-.118.033 1.332h1.678V9.242h-1.694l-.033 1.267c-.088-.22-.264-.438-.526-.658l-.032-.028a3.16 3.16 0 0 0-.668-.428l-.27-.12a3.293 3.293 0 0 0-1.235-.23c-.757 0-1.415.163-1.974.493a3.36 3.36 0 0 0-1.3 1.382c-.297.593-.444 1.284-.444 2.074 0 .8.17 1.503.51 2.107a3.795 3.795 0 0 0 1.382 1.381 3.883 3.883 0 0 0 1.893.477c.53 0 1.015-.11 1.455-.33zm-2.789-5.38c-.384.45-.575 1.038-.575 1.762 0 .735.186 1.332.559 1.794.384.45.933.675 1.645.675a2.25 2.25 0 0 0 .934-.19 2.17 2.17 0 0 0 .468-.29l.178-.161a2.163 2.163 0 0 0 .397-.561c.163-.333.244-.717.244-1.15v-.115c0-.472-.098-.894-.296-1.267l-.043-.077a2.211 2.211 0 0 0-.633-.709l-.13-.086-.047-.028a2.099 2.099 0 0 0-1.073-.285c-.702 0-1.244.231-1.629.692zm2.316 2.706c.163-.17.28-.407.28-.83v-.114c0-.292-.06-.508-.15-.68a.958.958 0 0 0-.353-.389.851.851 0 0 0-.464-.127c-.4 0-.56.114-.664.239l-.01.012c-.148.174-.275.45-.275.945 0 .506.122.801.27.99.097.11.266.224.68.224.303 0 .504-.09.687-.269zm7.545 1.705a2.626 2.626 0 0 0 .331.423c.213.22.464.402.755.548l.173.074c.433.17.93.255 1.49.255.68 0 1.295-.165 1.844-.493a3.447 3.447 0 0 0 1.316-1.4c.329-.603.493-1.299.493-2.089 0-1.273-.33-2.243-.988-2.913-.658-.68-1.52-1.02-2.584-1.02-.598 0-1.124.115-1.575.347a2.807 2.807 0 0 0-.415.262l-.199.166a3.35 3.35 0 0 0-.64.82V9.242h-1.712v11.553h1.729l-.017-5.134zm.53-1.138c.137.193.297.36.48.5l.155.11.053.034c.34.197.713.297 1.119.297.714 0 1.262-.225 1.645-.675.385-.46.576-1.048.576-1.762 0-.746-.192-1.338-.576-1.777-.372-.45-.92-.675-1.645-.675-.29 0-.569.053-.835.16a2.366 2.366 0 0 0-.284.136 1.99 1.99 0 0 0-.363.254 2.237 2.237 0 0 0-.46.569l-.082.162a2.56 2.56 0 0 0-.213 1.072v.115c0 .471.098.894.296 1.267l.135.211zm.964-.818a1.11 1.11 0 0 0 .367.385.937.937 0 0 0 .476.118c.423 0 .59-.117.687-.23.159-.194.28-.478.28-.95 0-.53-.133-.8-.266-.952l-.021-.025c-.078-.094-.231-.221-.68-.221a.995.995 0 0 0-.503.135l-.012.007a.859.859 0 0 0-.335.343c-.073.133-.132.324-.132.614v.115a1.43 1.43 0 0 0 .14.66zm15.7-6.222c.232-.23.346-.516.346-.856a1.053 1.053 0 0 0-.345-.79 1.175 1.175 0 0 0-.84-.329c-.34 0-.625.11-.855.33a1.053 1.053 0 0 0-.346.79c0 .34.115.625.346.855.23.23.516.346.856.346.34 0 .62-.115.839-.346zm4.337 9.314.033-1.332c.128.269.324.518.59.747l.098.081a3.727 3.727 0 0 0 .316.224l.223.122a3.21 3.21 0 0 0 1.44.322 3.785 3.785 0 0 0 1.875-.477 3.52 3.52 0 0 0 1.382-1.366c.352-.593.526-1.29.526-2.09 0-.79-.147-1.48-.444-2.073a3.235 3.235 0 0 0-1.283-1.399c-.549-.34-1.195-.51-1.942-.51a3.476 3.476 0 0 0-1.527.344l-.086.043-.165.09a3.412 3.412 0 0 0-.33.214c-.288.21-.507.446-.656.707a1.893 1.893 0 0 0-.099.198l.082-1.283V4.701h-1.744v12.095zm.473-2.509a2.482 2.482 0 0 0 .566.7c.078.065.159.125.245.18l.144.08a2.105 2.105 0 0 0 .975.232c.713 0 1.262-.225 1.645-.675.384-.46.576-1.053.576-1.778 0-.734-.192-1.327-.576-1.777-.373-.46-.921-.692-1.645-.692a2.18 2.18 0 0 0-1.015.235c-.147.075-.285.17-.415.282l-.15.142a2.086 2.086 0 0 0-.42.594c-.149.32-.223.685-.223 1.1v.115c0 .47.097.89.293 1.26zm2.616-.293c.157-.191.28-.479.28-.967 0-.51-.13-.79-.276-.961l-.021-.026c-.082-.1-.232-.225-.67-.225a.868.868 0 0 0-.681.279l-.012.011c-.154.155-.274.38-.274.807v.115c0 .285.057.499.144.669a1.13 1.13 0 0 0 .367.405c.137.082.28.123.455.123.423 0 .59-.118.686-.23zm8.266-3.013c.23-.087.472-.134.724-.14l.069-.002c.329 0 .542.033.642.099l.247-1.794c-.13-.066-.37-.099-.717-.099a2.3 2.3 0 0 0-.545.063 2.086 2.086 0 0 0-.411.148 2.18 2.18 0 0 0-.4.249 2.482 2.482 0 0 0-.485.499 2.659 2.659 0 0 0-.32.581l-.05.137v-1.48h-1.778v7.553h1.777v-3.884c0-.364.053-.678.159-.943a1.49 1.49 0 0 1 .466-.636 2.52 2.52 0 0 1 .399-.253 2.19 2.19 0 0 1 .224-.099zm9.784 2.656.05-.922c0-1.162-.285-2.062-.856-2.698-.559-.647-1.42-.97-2.584-.97-.746 0-1.415.163-2.007.493a3.462 3.462 0 0 0-1.4 1.382c-.329.604-.493 1.306-.493 2.106 0 .714.143 1.371.428 1.975.285.593.73 1.07 1.332 1.432.604.351 1.355.526 2.255.526.649 0 1.204-.062 1.668-.185l.044-.012.135-.04c.409-.122.736-.263.984-.421l-.542-1.267c-.2.108-.415.199-.642.274l-.297.087c-.34.088-.773.131-1.3.131-.636 0-1.135-.147-1.497-.444a1.573 1.573 0 0 1-.192-.193c-.244-.294-.415-.705-.512-1.234l-.004-.021h5.43zm-5.427-1.256-.003.022h3.752v-.138c-.007-.485-.104-.857-.288-1.118a1.056 1.056 0 0 0-.156-.176c-.307-.285-.746-.428-1.316-.428-.657 0-1.155.202-1.494.604-.253.3-.417.712-.494 1.234zm-27.053 2.77V4.7h-1.86v12.095h5.333V15.15zm7.103-5.908v7.553h-1.843V9.242h1.843z'/%3E%3Cpath fill='%23fff' d='m19.63 11.151-.757-1.71-.345 1.71-1.12 5.644h-1.827L18.083 4.7h.197l3.325 6.533.988 2.19.988-2.19L26.839 4.7h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.93 5.644h-.098l-2.913-5.644zm14.836 5.81c-.68 0-1.311-.16-1.893-.478a3.795 3.795 0 0 1-1.381-1.382c-.34-.604-.51-1.306-.51-2.106 0-.79.147-1.482.444-2.074a3.364 3.364 0 0 1 1.3-1.382c.559-.33 1.217-.494 1.974-.494a3.293 3.293 0 0 1 1.234.231 3.341 3.341 0 0 1 .97.575c.264.22.44.439.527.659l.033-1.267h1.694v7.553H37.18l-.033-1.332c-.186.395-.526.746-1.02 1.053a3.167 3.167 0 0 1-1.662.444zm.296-1.482c.626 0 1.152-.214 1.58-.642.428-.44.642-1.01.642-1.711v-.115c0-.472-.098-.894-.296-1.267a2.211 2.211 0 0 0-.807-.872 2.098 2.098 0 0 0-1.119-.313c-.702 0-1.245.231-1.629.692-.384.45-.575 1.037-.575 1.76 0 .736.186 1.333.559 1.795.384.45.933.675 1.645.675zm6.521-6.237h1.711v1.4c.604-1.065 1.547-1.597 2.83-1.597 1.064 0 1.926.34 2.584 1.02.659.67.988 1.641.988 2.914 0 .79-.164 1.487-.493 2.09a3.456 3.456 0 0 1-1.316 1.399 3.51 3.51 0 0 1-1.844.493c-.636 0-1.19-.11-1.662-.329a2.665 2.665 0 0 1-1.086-.97l.017 5.134h-1.728V9.242zm4.048 6.22c.714 0 1.262-.224 1.645-.674.385-.46.576-1.048.576-1.762 0-.746-.192-1.338-.576-1.777-.372-.45-.92-.675-1.645-.675-.395 0-.768.098-1.12.296-.34.187-.613.46-.822.823-.197.351-.296.763-.296 1.234v.115c0 .472.098.894.296 1.267.209.362.483.647.823.855.34.197.713.297 1.119.297z'/%3E%3Cpath fill='%23e1e3e9' d='M51.325 4.7h1.86v10.45h3.473v1.646h-5.333zm7.12 4.542h1.843v7.553h-1.843zm.905-1.415a1.159 1.159 0 0 1-.856-.346 1.165 1.165 0 0 1-.346-.856 1.053 1.053 0 0 1 .346-.79c.23-.219.516-.329.856-.329.329 0 .609.11.839.33a1.053 1.053 0 0 1 .345.79 1.159 1.159 0 0 1-.345.855c-.22.23-.5.346-.84.346zm7.875 9.133a3.167 3.167 0 0 1-1.662-.444c-.482-.307-.817-.658-1.004-1.053l-.033 1.332h-1.71V4.701h1.743v4.657l-.082 1.283c.186-.438.548-.812 1.086-1.119a3.486 3.486 0 0 1 1.778-.477c.746 0 1.393.17 1.942.51a3.235 3.235 0 0 1 1.283 1.4c.297.592.444 1.282.444 2.072 0 .8-.175 1.498-.526 2.09a3.52 3.52 0 0 1-1.382 1.366 3.785 3.785 0 0 1-1.876.477zm-.296-1.481c.713 0 1.26-.225 1.645-.675.384-.46.577-1.053.577-1.778 0-.734-.193-1.327-.577-1.776-.373-.46-.921-.692-1.645-.692a2.115 2.115 0 0 0-1.58.659c-.428.428-.642.992-.642 1.694v.115c0 .473.098.895.296 1.267a2.385 2.385 0 0 0 .807.872 2.1 2.1 0 0 0 1.119.313zm5.927-6.237h1.777v1.481c.176-.505.46-.91.856-1.217a2.14 2.14 0 0 1 1.349-.46c.351 0 .593.032.724.098l-.247 1.794c-.099-.066-.313-.099-.642-.099-.516 0-.988.164-1.416.494-.417.329-.626.855-.626 1.58v3.883h-1.777V9.242zm9.534 7.718c-.9 0-1.651-.175-2.255-.526-.603-.362-1.047-.84-1.332-1.432a4.567 4.567 0 0 1-.428-1.975c0-.8.164-1.502.493-2.106a3.462 3.462 0 0 1 1.4-1.382c.592-.33 1.262-.494 2.007-.494 1.163 0 2.024.324 2.584.97.57.637.856 1.537.856 2.7 0 .296-.017.603-.05.92h-5.43c.12.67.356 1.153.708 1.45.362.296.86.443 1.497.443.526 0 .96-.044 1.3-.131a4.123 4.123 0 0 0 .938-.362l.542 1.267c-.274.175-.647.329-1.119.46-.472.132-1.042.197-1.711.197zm1.596-4.558c.01-.68-.137-1.158-.444-1.432-.307-.285-.746-.428-1.316-.428-1.152 0-1.815.62-1.991 1.86h3.752z'/%3E%3Cg fill-rule='evenodd' stroke-width='1.036'%3E%3Cpath fill='%23000' fill-opacity='.4' d='m8.166 16.146-.002.002a1.54 1.54 0 0 1-2.009 0l-.002-.002-.043-.034-.002-.002-.199-.162H4.377a.657.657 0 0 0-.659.659v1.84a.657.657 0 0 0 .659.659h5.565a.657.657 0 0 0 .659-.659v-1.84a.657.657 0 0 0-.659-.659H8.411l-.202.164zm-1.121-.905a.29.29 0 0 0 .113.023.286.286 0 0 0 .189-.07l.077-.063c.634-.508 4.672-3.743 4.672-7.575 0-2.55-2.215-4.625-4.938-4.625S2.221 5.006 2.221 7.556c0 3.225 2.86 6.027 4.144 7.137h.004l.04.038.484.4.077.063a.628.628 0 0 0 .074.047zm-2.52-.548a16.898 16.898 0 0 1-1.183-1.315C2.187 11.942.967 9.897.967 7.555c0-3.319 2.855-5.88 6.192-5.88 3.338 0 6.193 2.561 6.193 5.881 0 2.34-1.22 4.387-2.376 5.822a16.898 16.898 0 0 1-1.182 1.315h.15a1.912 1.912 0 0 1 1.914 1.914v1.84a1.912 1.912 0 0 1-1.914 1.914H4.377a1.912 1.912 0 0 1-1.914-1.914v-1.84a1.912 1.912 0 0 1 1.914-1.914zm3.82-6.935c0 .692-.55 1.222-1.187 1.222s-1.185-.529-1.185-1.222.548-1.222 1.185-1.222c.638 0 1.186.529 1.186 1.222zm-1.186 2.477c1.348 0 2.442-1.11 2.442-2.478S8.507 5.28 7.159 5.28 4.72 6.39 4.72 7.758s1.092 2.477 2.44 2.477zm2.048 7.71H5.114v-.838h4.093z'/%3E%3Cpath fill='%23e1e3e9' d='M2.222 7.555c0-2.55 2.214-4.625 4.937-4.625 2.723 0 4.938 2.075 4.938 4.625 0 3.832-4.038 7.068-4.672 7.575l-.077.063a.286.286 0 0 1-.189.07.286.286 0 0 1-.188-.07l-.077-.063c-.634-.507-4.672-3.743-4.672-7.575zm4.937 2.68c1.348 0 2.442-1.11 2.442-2.478S8.507 5.28 7.159 5.28 4.72 6.39 4.72 7.758s1.092 2.477 2.44 2.477z'/%3E%3Cpath fill='%23fff' d='M4.377 15.948a.657.657 0 0 0-.659.659v1.84a.657.657 0 0 0 .659.659h5.565a.657.657 0 0 0 .659-.659v-1.84a.657.657 0 0 0-.659-.659zm4.83 1.16H5.114v.838h4.093z'/%3E%3C/g%3E%3C/svg%3E")}}@media (-ms-high-contrast:black-on-white){a.maplibregl-ctrl-logo{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='88' height='23' fill='none'%3E%3Cpath fill='%23000' fill-opacity='.4' fill-rule='evenodd' d='M17.408 16.796h-1.827l2.501-12.095h.198l3.324 6.533.988 2.19.988-2.19 3.258-6.533h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.929 5.644h-.098l-2.914-5.644-.757-1.71-.345 1.71zm1.958-3.42-.726 3.663a1.255 1.255 0 0 1-1.232 1.011h-1.827a1.255 1.255 0 0 1-1.229-1.509l2.501-12.095a1.255 1.255 0 0 1 1.23-1.001h.197a1.255 1.255 0 0 1 1.12.685l3.19 6.273 3.125-6.263a1.255 1.255 0 0 1 1.123-.695h.181a1.255 1.255 0 0 1 1.227.991l1.443 6.71a5.11 5.11 0 0 1 .314-.787l.009-.016a4.623 4.623 0 0 1 1.777-1.887c.782-.46 1.668-.667 2.611-.667a4.548 4.548 0 0 1 1.7.32l.306.134c.21-.16.474-.256.759-.256h1.694a1.255 1.255 0 0 1 1.212.925 1.255 1.255 0 0 1 1.212-.925h1.711c.284 0 .545.094.755.252.613-.3 1.312-.45 2.075-.45 1.356 0 2.557.445 3.482 1.4.314.319.566.676.763 1.064V4.701a1.255 1.255 0 0 1 1.255-1.255h1.86A1.255 1.255 0 0 1 54.44 4.7v9.194h2.217c.19 0 .37.043.532.118v-4.77c0-.356.147-.678.385-.906a2.416 2.416 0 0 1-.682-1.71c0-.665.267-1.253.735-1.7a2.448 2.448 0 0 1 1.722-.674 2.43 2.43 0 0 1 1.705.675c.211.2.381.43.504.683V4.7a1.255 1.255 0 0 1 1.255-1.255h1.744A1.255 1.255 0 0 1 65.812 4.7v3.335a4.76 4.76 0 0 1 1.526-.246c.938 0 1.817.214 2.59.69a4.47 4.47 0 0 1 1.67 1.743v-.98a1.255 1.255 0 0 1 1.256-1.256h1.777c.233 0 .451.064.639.174a3.407 3.407 0 0 1 1.567-.372c.346 0 .861.02 1.285.232a1.255 1.255 0 0 1 .689 1.004 4.73 4.73 0 0 1 .853-.588c.795-.44 1.675-.647 2.61-.647 1.385 0 2.65.39 3.525 1.396.836.938 1.168 2.173 1.168 3.528 0 .343-.02.694-.056 1.051a1.255 1.255 0 0 1-.947 1.09l.408.952a1.255 1.255 0 0 1-.477 1.552c-.418.268-.92.463-1.458.612-.613.171-1.304.244-2.049.244-1.06 0-2.043-.207-2.886-.698l-.015-.008c-.798-.48-1.419-1.135-1.818-1.963l-.004-.008a5.815 5.815 0 0 1-.548-2.512c0-.286.017-.567.053-.843a1.255 1.255 0 0 1-.333-.086l-.166-.004c-.223 0-.426.062-.643.228-.03.024-.142.139-.142.59v3.883a1.255 1.255 0 0 1-1.256 1.256h-1.777a1.255 1.255 0 0 1-1.256-1.256V15.69l-.032.057a4.778 4.778 0 0 1-1.86 1.833 5.04 5.04 0 0 1-2.484.634 4.47 4.47 0 0 1-1.935-.424 1.252 1.252 0 0 1-.764.258h-1.71a1.255 1.255 0 0 1-1.256-1.255V7.687a2.402 2.402 0 0 1-.428.625c.253.23.412.561.412.93v7.553a1.255 1.255 0 0 1-1.256 1.255h-1.843a1.25 1.25 0 0 1-.894-.373c-.228.23-.544.373-.894.373H51.32a1.255 1.255 0 0 1-1.256-1.255v-1.251l-.061.117a4.703 4.703 0 0 1-1.782 1.884 4.767 4.767 0 0 1-2.485.67 5.6 5.6 0 0 1-1.485-.188l.009 2.764a1.255 1.255 0 0 1-1.255 1.259h-1.729a1.255 1.255 0 0 1-1.255-1.255v-3.537a1.255 1.255 0 0 1-1.167.793h-1.679a1.25 1.25 0 0 1-.77-.263 4.47 4.47 0 0 1-1.945.429c-.885 0-1.724-.21-2.495-.632l-.017-.01a4.983 4.983 0 0 1-1.081-.836 1.255 1.255 0 0 1-1.254 1.312h-1.81a1.255 1.255 0 0 1-1.228-.99l-.782-3.625-2.044 3.939a1.255 1.255 0 0 1-1.115.676h-.098a1.255 1.255 0 0 1-1.116-.68l-2.061-3.994zM35.92 16.63l.207-.114.223-.15c.329-.237.574-.499.735-.785l.061-.118.033 1.332h1.678V9.242h-1.694l-.033 1.267c-.088-.22-.264-.438-.526-.658l-.032-.028a3.16 3.16 0 0 0-.668-.428l-.27-.12a3.293 3.293 0 0 0-1.235-.23c-.757 0-1.415.163-1.974.493a3.36 3.36 0 0 0-1.3 1.382c-.297.593-.444 1.284-.444 2.074 0 .8.17 1.503.51 2.107a3.795 3.795 0 0 0 1.382 1.381 3.883 3.883 0 0 0 1.893.477c.53 0 1.015-.11 1.455-.33zm-2.789-5.38c-.384.45-.575 1.038-.575 1.762 0 .735.186 1.332.559 1.794.384.45.933.675 1.645.675a2.25 2.25 0 0 0 .934-.19 2.17 2.17 0 0 0 .468-.29l.178-.161a2.163 2.163 0 0 0 .397-.561c.163-.333.244-.717.244-1.15v-.115c0-.472-.098-.894-.296-1.267l-.043-.077a2.211 2.211 0 0 0-.633-.709l-.13-.086-.047-.028a2.099 2.099 0 0 0-1.073-.285c-.702 0-1.244.231-1.629.692zm2.316 2.706c.163-.17.28-.407.28-.83v-.114c0-.292-.06-.508-.15-.68a.958.958 0 0 0-.353-.389.851.851 0 0 0-.464-.127c-.4 0-.56.114-.664.239l-.01.012c-.148.174-.275.45-.275.945 0 .506.122.801.27.99.097.11.266.224.68.224.303 0 .504-.09.687-.269zm7.545 1.705a2.626 2.626 0 0 0 .331.423c.213.22.464.402.755.548l.173.074c.433.17.93.255 1.49.255.68 0 1.295-.165 1.844-.493a3.447 3.447 0 0 0 1.316-1.4c.329-.603.493-1.299.493-2.089 0-1.273-.33-2.243-.988-2.913-.658-.68-1.52-1.02-2.584-1.02-.598 0-1.124.115-1.575.347a2.807 2.807 0 0 0-.415.262l-.199.166a3.35 3.35 0 0 0-.64.82V9.242h-1.712v11.553h1.729l-.017-5.134zm.53-1.138c.137.193.297.36.48.5l.155.11.053.034c.34.197.713.297 1.119.297.714 0 1.262-.225 1.645-.675.385-.46.576-1.048.576-1.762 0-.746-.192-1.338-.576-1.777-.372-.45-.92-.675-1.645-.675-.29 0-.569.053-.835.16a2.366 2.366 0 0 0-.284.136 1.99 1.99 0 0 0-.363.254 2.237 2.237 0 0 0-.46.569l-.082.162a2.56 2.56 0 0 0-.213 1.072v.115c0 .471.098.894.296 1.267l.135.211zm.964-.818a1.11 1.11 0 0 0 .367.385.937.937 0 0 0 .476.118c.423 0 .59-.117.687-.23.159-.194.28-.478.28-.95 0-.53-.133-.8-.266-.952l-.021-.025c-.078-.094-.231-.221-.68-.221a.995.995 0 0 0-.503.135l-.012.007a.859.859 0 0 0-.335.343c-.073.133-.132.324-.132.614v.115a1.43 1.43 0 0 0 .14.66zm15.7-6.222c.232-.23.346-.516.346-.856a1.053 1.053 0 0 0-.345-.79 1.175 1.175 0 0 0-.84-.329c-.34 0-.625.11-.855.33a1.053 1.053 0 0 0-.346.79c0 .34.115.625.346.855.23.23.516.346.856.346.34 0 .62-.115.839-.346zm4.337 9.314.033-1.332c.128.269.324.518.59.747l.098.081a3.727 3.727 0 0 0 .316.224l.223.122a3.21 3.21 0 0 0 1.44.322 3.785 3.785 0 0 0 1.875-.477 3.52 3.52 0 0 0 1.382-1.366c.352-.593.526-1.29.526-2.09 0-.79-.147-1.48-.444-2.073a3.235 3.235 0 0 0-1.283-1.399c-.549-.34-1.195-.51-1.942-.51a3.476 3.476 0 0 0-1.527.344l-.086.043-.165.09a3.412 3.412 0 0 0-.33.214c-.288.21-.507.446-.656.707a1.893 1.893 0 0 0-.099.198l.082-1.283V4.701h-1.744v12.095zm.473-2.509a2.482 2.482 0 0 0 .566.7c.078.065.159.125.245.18l.144.08a2.105 2.105 0 0 0 .975.232c.713 0 1.262-.225 1.645-.675.384-.46.576-1.053.576-1.778 0-.734-.192-1.327-.576-1.777-.373-.46-.921-.692-1.645-.692a2.18 2.18 0 0 0-1.015.235c-.147.075-.285.17-.415.282l-.15.142a2.086 2.086 0 0 0-.42.594c-.149.32-.223.685-.223 1.1v.115c0 .47.097.89.293 1.26zm2.616-.293c.157-.191.28-.479.28-.967 0-.51-.13-.79-.276-.961l-.021-.026c-.082-.1-.232-.225-.67-.225a.868.868 0 0 0-.681.279l-.012.011c-.154.155-.274.38-.274.807v.115c0 .285.057.499.144.669a1.13 1.13 0 0 0 .367.405c.137.082.28.123.455.123.423 0 .59-.118.686-.23zm8.266-3.013c.23-.087.472-.134.724-.14l.069-.002c.329 0 .542.033.642.099l.247-1.794c-.13-.066-.37-.099-.717-.099a2.3 2.3 0 0 0-.545.063 2.086 2.086 0 0 0-.411.148 2.18 2.18 0 0 0-.4.249 2.482 2.482 0 0 0-.485.499 2.659 2.659 0 0 0-.32.581l-.05.137v-1.48h-1.778v7.553h1.777v-3.884c0-.364.053-.678.159-.943a1.49 1.49 0 0 1 .466-.636 2.52 2.52 0 0 1 .399-.253 2.19 2.19 0 0 1 .224-.099zm9.784 2.656.05-.922c0-1.162-.285-2.062-.856-2.698-.559-.647-1.42-.97-2.584-.97-.746 0-1.415.163-2.007.493a3.462 3.462 0 0 0-1.4 1.382c-.329.604-.493 1.306-.493 2.106 0 .714.143 1.371.428 1.975.285.593.73 1.07 1.332 1.432.604.351 1.355.526 2.255.526.649 0 1.204-.062 1.668-.185l.044-.012.135-.04c.409-.122.736-.263.984-.421l-.542-1.267c-.2.108-.415.199-.642.274l-.297.087c-.34.088-.773.131-1.3.131-.636 0-1.135-.147-1.497-.444a1.573 1.573 0 0 1-.192-.193c-.244-.294-.415-.705-.512-1.234l-.004-.021h5.43zm-5.427-1.256-.003.022h3.752v-.138c-.007-.485-.104-.857-.288-1.118a1.056 1.056 0 0 0-.156-.176c-.307-.285-.746-.428-1.316-.428-.657 0-1.155.202-1.494.604-.253.3-.417.712-.494 1.234zm-27.053 2.77V4.7h-1.86v12.095h5.333V15.15zm7.103-5.908v7.553h-1.843V9.242h1.843z'/%3E%3Cpath fill='%23fff' d='m19.63 11.151-.757-1.71-.345 1.71-1.12 5.644h-1.827L18.083 4.7h.197l3.325 6.533.988 2.19.988-2.19L26.839 4.7h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.93 5.644h-.098l-2.913-5.644zm14.836 5.81c-.68 0-1.311-.16-1.893-.478a3.795 3.795 0 0 1-1.381-1.382c-.34-.604-.51-1.306-.51-2.106 0-.79.147-1.482.444-2.074a3.364 3.364 0 0 1 1.3-1.382c.559-.33 1.217-.494 1.974-.494a3.293 3.293 0 0 1 1.234.231 3.341 3.341 0 0 1 .97.575c.264.22.44.439.527.659l.033-1.267h1.694v7.553H37.18l-.033-1.332c-.186.395-.526.746-1.02 1.053a3.167 3.167 0 0 1-1.662.444zm.296-1.482c.626 0 1.152-.214 1.58-.642.428-.44.642-1.01.642-1.711v-.115c0-.472-.098-.894-.296-1.267a2.211 2.211 0 0 0-.807-.872 2.098 2.098 0 0 0-1.119-.313c-.702 0-1.245.231-1.629.692-.384.45-.575 1.037-.575 1.76 0 .736.186 1.333.559 1.795.384.45.933.675 1.645.675zm6.521-6.237h1.711v1.4c.604-1.065 1.547-1.597 2.83-1.597 1.064 0 1.926.34 2.584 1.02.659.67.988 1.641.988 2.914 0 .79-.164 1.487-.493 2.09a3.456 3.456 0 0 1-1.316 1.399 3.51 3.51 0 0 1-1.844.493c-.636 0-1.19-.11-1.662-.329a2.665 2.665 0 0 1-1.086-.97l.017 5.134h-1.728V9.242zm4.048 6.22c.714 0 1.262-.224 1.645-.674.385-.46.576-1.048.576-1.762 0-.746-.192-1.338-.576-1.777-.372-.45-.92-.675-1.645-.675-.395 0-.768.098-1.12.296-.34.187-.613.46-.822.823-.197.351-.296.763-.296 1.234v.115c0 .472.098.894.296 1.267.209.362.483.647.823.855.34.197.713.297 1.119.297z'/%3E%3Cpath fill='%23e1e3e9' d='M51.325 4.7h1.86v10.45h3.473v1.646h-5.333zm7.12 4.542h1.843v7.553h-1.843zm.905-1.415a1.159 1.159 0 0 1-.856-.346 1.165 1.165 0 0 1-.346-.856 1.053 1.053 0 0 1 .346-.79c.23-.219.516-.329.856-.329.329 0 .609.11.839.33a1.053 1.053 0 0 1 .345.79 1.159 1.159 0 0 1-.345.855c-.22.23-.5.346-.84.346zm7.875 9.133a3.167 3.167 0 0 1-1.662-.444c-.482-.307-.817-.658-1.004-1.053l-.033 1.332h-1.71V4.701h1.743v4.657l-.082 1.283c.186-.438.548-.812 1.086-1.119a3.486 3.486 0 0 1 1.778-.477c.746 0 1.393.17 1.942.51a3.235 3.235 0 0 1 1.283 1.4c.297.592.444 1.282.444 2.072 0 .8-.175 1.498-.526 2.09a3.52 3.52 0 0 1-1.382 1.366 3.785 3.785 0 0 1-1.876.477zm-.296-1.481c.713 0 1.26-.225 1.645-.675.384-.46.577-1.053.577-1.778 0-.734-.193-1.327-.577-1.776-.373-.46-.921-.692-1.645-.692a2.115 2.115 0 0 0-1.58.659c-.428.428-.642.992-.642 1.694v.115c0 .473.098.895.296 1.267a2.385 2.385 0 0 0 .807.872 2.1 2.1 0 0 0 1.119.313zm5.927-6.237h1.777v1.481c.176-.505.46-.91.856-1.217a2.14 2.14 0 0 1 1.349-.46c.351 0 .593.032.724.098l-.247 1.794c-.099-.066-.313-.099-.642-.099-.516 0-.988.164-1.416.494-.417.329-.626.855-.626 1.58v3.883h-1.777V9.242zm9.534 7.718c-.9 0-1.651-.175-2.255-.526-.603-.362-1.047-.84-1.332-1.432a4.567 4.567 0 0 1-.428-1.975c0-.8.164-1.502.493-2.106a3.462 3.462 0 0 1 1.4-1.382c.592-.33 1.262-.494 2.007-.494 1.163 0 2.024.324 2.584.97.57.637.856 1.537.856 2.7 0 .296-.017.603-.05.92h-5.43c.12.67.356 1.153.708 1.45.362.296.86.443 1.497.443.526 0 .96-.044 1.3-.131a4.123 4.123 0 0 0 .938-.362l.542 1.267c-.274.175-.647.329-1.119.46-.472.132-1.042.197-1.711.197zm1.596-4.558c.01-.68-.137-1.158-.444-1.432-.307-.285-.746-.428-1.316-.428-1.152 0-1.815.62-1.991 1.86h3.752z'/%3E%3Cg fill-rule='evenodd' stroke-width='1.036'%3E%3Cpath fill='%23000' fill-opacity='.4' d='m8.166 16.146-.002.002a1.54 1.54 0 0 1-2.009 0l-.002-.002-.043-.034-.002-.002-.199-.162H4.377a.657.657 0 0 0-.659.659v1.84a.657.657 0 0 0 .659.659h5.565a.657.657 0 0 0 .659-.659v-1.84a.657.657 0 0 0-.659-.659H8.411l-.202.164zm-1.121-.905a.29.29 0 0 0 .113.023.286.286 0 0 0 .189-.07l.077-.063c.634-.508 4.672-3.743 4.672-7.575 0-2.55-2.215-4.625-4.938-4.625S2.221 5.006 2.221 7.556c0 3.225 2.86 6.027 4.144 7.137h.004l.04.038.484.4.077.063a.628.628 0 0 0 .074.047zm-2.52-.548a16.898 16.898 0 0 1-1.183-1.315C2.187 11.942.967 9.897.967 7.555c0-3.319 2.855-5.88 6.192-5.88 3.338 0 6.193 2.561 6.193 5.881 0 2.34-1.22 4.387-2.376 5.822a16.898 16.898 0 0 1-1.182 1.315h.15a1.912 1.912 0 0 1 1.914 1.914v1.84a1.912 1.912 0 0 1-1.914 1.914H4.377a1.912 1.912 0 0 1-1.914-1.914v-1.84a1.912 1.912 0 0 1 1.914-1.914zm3.82-6.935c0 .692-.55 1.222-1.187 1.222s-1.185-.529-1.185-1.222.548-1.222 1.185-1.222c.638 0 1.186.529 1.186 1.222zm-1.186 2.477c1.348 0 2.442-1.11 2.442-2.478S8.507 5.28 7.159 5.28 4.72 6.39 4.72 7.758s1.092 2.477 2.44 2.477zm2.048 7.71H5.114v-.838h4.093z'/%3E%3Cpath fill='%23e1e3e9' d='M2.222 7.555c0-2.55 2.214-4.625 4.937-4.625 2.723 0 4.938 2.075 4.938 4.625 0 3.832-4.038 7.068-4.672 7.575l-.077.063a.286.286 0 0 1-.189.07.286.286 0 0 1-.188-.07l-.077-.063c-.634-.507-4.672-3.743-4.672-7.575zm4.937 2.68c1.348 0 2.442-1.11 2.442-2.478S8.507 5.28 7.159 5.28 4.72 6.39 4.72 7.758s1.092 2.477 2.44 2.477z'/%3E%3Cpath fill='%23fff' d='M4.377 15.948a.657.657 0 0 0-.659.659v1.84a.657.657 0 0 0 .659.659h5.565a.657.657 0 0 0 .659-.659v-1.84a.657.657 0 0 0-.659-.659zm4.83 1.16H5.114v.838h4.093z'/%3E%3C/g%3E%3C/svg%3E")}}.maplibregl-ctrl.maplibregl-ctrl-attrib{background-color:hsla(0,0%,100%,.5);margin:0;padding:0 5px}@media screen{.maplibregl-ctrl-attrib.maplibregl-compact{background-color:#fff;border-radius:12px;box-sizing:content-box;margin:10px;min-height:20px;padding:2px 24px 2px 0;position:relative}.maplibregl-ctrl-attrib.maplibregl-compact-show{padding:2px 28px 2px 8px;visibility:visible}.maplibregl-ctrl-bottom-left>.maplibregl-ctrl-attrib.maplibregl-compact-show,.maplibregl-ctrl-top-left>.maplibregl-ctrl-attrib.maplibregl-compact-show{border-radius:12px;padding:2px 8px 2px 28px}.maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-inner{display:none}.maplibregl-ctrl-attrib-button{background-color:hsla(0,0%,100%,.5);background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill-rule='evenodd' viewBox='0 0 20 20'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E");border:0;border-radius:12px;box-sizing:border-box;cursor:pointer;display:none;height:24px;outline:none;position:absolute;right:0;top:0;width:24px}.maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;list-style:none}.maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button::-webkit-details-marker{display:none}.maplibregl-ctrl-bottom-left .maplibregl-ctrl-attrib-button,.maplibregl-ctrl-top-left .maplibregl-ctrl-attrib-button{left:0}.maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-button,.maplibregl-ctrl-attrib.maplibregl-compact-show .maplibregl-ctrl-attrib-inner{display:block}.maplibregl-ctrl-attrib.maplibregl-compact-show .maplibregl-ctrl-attrib-button{background-color:rgb(0 0 0/5%)}.maplibregl-ctrl-bottom-right>.maplibregl-ctrl-attrib.maplibregl-compact:after{bottom:0;right:0}.maplibregl-ctrl-top-right>.maplibregl-ctrl-attrib.maplibregl-compact:after{right:0;top:0}.maplibregl-ctrl-top-left>.maplibregl-ctrl-attrib.maplibregl-compact:after{left:0;top:0}.maplibregl-ctrl-bottom-left>.maplibregl-ctrl-attrib.maplibregl-compact:after{bottom:0;left:0}}@media screen and (-ms-high-contrast:active){.maplibregl-ctrl-attrib.maplibregl-compact:after{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='%23fff' fill-rule='evenodd' viewBox='0 0 20 20'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E")}}@media screen and (-ms-high-contrast:black-on-white){.maplibregl-ctrl-attrib.maplibregl-compact:after{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill-rule='evenodd' viewBox='0 0 20 20'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E")}}.maplibregl-ctrl-attrib a{color:rgba(0,0,0,.75);text-decoration:none}.maplibregl-ctrl-attrib a:hover{color:inherit;text-decoration:underline}.maplibregl-attrib-empty{display:none}.maplibregl-ctrl-scale{background-color:hsla(0,0%,100%,.75);border:2px solid #333;border-top:#333;box-sizing:border-box;color:#333;font-size:10px;padding:0 5px}.maplibregl-popup{display:flex;left:0;pointer-events:none;position:absolute;top:0;will-change:transform}.maplibregl-popup-anchor-top,.maplibregl-popup-anchor-top-left,.maplibregl-popup-anchor-top-right{flex-direction:column}.maplibregl-popup-anchor-bottom,.maplibregl-popup-anchor-bottom-left,.maplibregl-popup-anchor-bottom-right{flex-direction:column-reverse}.maplibregl-popup-anchor-left{flex-direction:row}.maplibregl-popup-anchor-right{flex-direction:row-reverse}.maplibregl-popup-tip{border:10px solid transparent;height:0;width:0;z-index:1}.maplibregl-popup-anchor-top .maplibregl-popup-tip{align-self:center;border-bottom-color:#fff;border-top:none}.maplibregl-popup-anchor-top-left .maplibregl-popup-tip{align-self:flex-start;border-bottom-color:#fff;border-left:none;border-top:none}.maplibregl-popup-anchor-top-right .maplibregl-popup-tip{align-self:flex-end;border-bottom-color:#fff;border-right:none;border-top:none}.maplibregl-popup-anchor-bottom .maplibregl-popup-tip{align-self:center;border-bottom:none;border-top-color:#fff}.maplibregl-popup-anchor-bottom-left .maplibregl-popup-tip{align-self:flex-start;border-bottom:none;border-left:none;border-top-color:#fff}.maplibregl-popup-anchor-bottom-right .maplibregl-popup-tip{align-self:flex-end;border-bottom:none;border-right:none;border-top-color:#fff}.maplibregl-popup-anchor-left .maplibregl-popup-tip{align-self:center;border-left:none;border-right-color:#fff}.maplibregl-popup-anchor-right .maplibregl-popup-tip{align-self:center;border-left-color:#fff;border-right:none}.maplibregl-popup-close-button{background-color:transparent;border:0;border-radius:0 3px 0 0;cursor:pointer;position:absolute;right:0;top:0}.maplibregl-popup-close-button:hover{background-color:rgb(0 0 0/5%)}.maplibregl-popup-content{background:#fff;border-radius:3px;box-shadow:0 1px 2px rgba(0,0,0,.1);padding:15px 10px;pointer-events:auto;position:relative}.maplibregl-popup-anchor-top-left .maplibregl-popup-content{border-top-left-radius:0}.maplibregl-popup-anchor-top-right .maplibregl-popup-content{border-top-right-radius:0}.maplibregl-popup-anchor-bottom-left .maplibregl-popup-content{border-bottom-left-radius:0}.maplibregl-popup-anchor-bottom-right .maplibregl-popup-content{border-bottom-right-radius:0}.maplibregl-popup-track-pointer{display:none}.maplibregl-popup-track-pointer *{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.maplibregl-map:hover .maplibregl-popup-track-pointer{display:flex}.maplibregl-map:active .maplibregl-popup-track-pointer{display:none}.maplibregl-marker{left:0;position:absolute;top:0;will-change:transform}.maplibregl-user-location-dot,.maplibregl-user-location-dot:before{background-color:#1da1f2;border-radius:50%;height:15px;width:15px}.maplibregl-user-location-dot:before{-webkit-animation:maplibregl-user-location-dot-pulse 2s infinite;animation:maplibregl-user-location-dot-pulse 2s infinite;content:"";position:absolute}.maplibregl-user-location-dot:after{border:2px solid #fff;border-radius:50%;box-shadow:0 0 3px rgba(0,0,0,.35);box-sizing:border-box;content:"";height:19px;left:-2px;position:absolute;top:-2px;width:19px}@-webkit-keyframes maplibregl-user-location-dot-pulse{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}70%{opacity:0;-webkit-transform:scale(3);transform:scale(3)}to{opacity:0;-webkit-transform:scale(1);transform:scale(1)}}@keyframes maplibregl-user-location-dot-pulse{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}70%{opacity:0;-webkit-transform:scale(3);transform:scale(3)}to{opacity:0;-webkit-transform:scale(1);transform:scale(1)}}.maplibregl-user-location-dot-stale{background-color:#aaa}.maplibregl-user-location-dot-stale:after{display:none}.maplibregl-user-location-accuracy-circle{background-color:#1da1f233;border-radius:100%;height:1px;width:1px}.maplibregl-crosshair,.maplibregl-crosshair .maplibregl-interactive,.maplibregl-crosshair .maplibregl-interactive:active{cursor:crosshair}.maplibregl-boxzoom{background:#fff;border:2px dotted #202020;height:0;left:0;opacity:.5;position:absolute;top:0;width:0}.maplibregl-cooperative-gesture-screen{align-items:center;background:rgba(0,0,0,.4);color:#fff;display:flex;font-size:1.4em;inset:0;justify-content:center;line-height:1.2;opacity:0;padding:1rem;pointer-events:none;position:absolute;transition:opacity 1s ease 1s;z-index:99999}.maplibregl-cooperative-gesture-screen.maplibregl-show{opacity:1;transition:opacity .05s}.maplibregl-cooperative-gesture-screen .maplibregl-mobile-message{display:none}@media (hover:none),(width <= 480px){.maplibregl-cooperative-gesture-screen .maplibregl-desktop-message{display:none}.maplibregl-cooperative-gesture-screen .maplibregl-mobile-message{display:block}}.maplibregl-pseudo-fullscreen{height:100%!important;left:0!important;position:fixed!important;top:0!important;width:100%!important;z-index:99999}`);
window.maplibregl = import_maplibre_gl.default;
var mapdivCount2 = 0;
var Service = class extends BaseMapService {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "version", MapType.MAPBOX);
    _defineProperty(this, "viewport", void 0);
  }
  getType() {
    return "mapbox";
  }
  /**
   * 将经纬度转成墨卡托坐标
   * @param lnglat
   * @returns
   */
  lngLatToCoord(lnglat, origin = {
    x: 0,
    y: 0,
    z: 0
  }) {
    const {
      x: x2,
      y
    } = this.lngLatToMercator(lnglat, 0);
    return [x2 - origin.x, y - origin.y];
  }
  lngLatToMercator(lnglat, altitude) {
    const {
      x: x2 = 0,
      y = 0,
      z = 0
    } = window.maplibregl.MercatorCoordinate.fromLngLat(lnglat, altitude);
    return {
      x: x2,
      y,
      z
    };
  }
  getModelMatrix(lnglat, altitude, rotate5, scale6 = [1, 1, 1], origin = {
    x: 0,
    y: 0,
    z: 0
  }) {
    const modelAsMercatorCoordinate = window.maplibregl.MercatorCoordinate.fromLngLat(lnglat, altitude);
    const meters = modelAsMercatorCoordinate.meterInMercatorCoordinateUnits();
    const modelMatrix = mat4_exports.create();
    mat4_exports.translate(modelMatrix, modelMatrix, vec3_exports.fromValues(modelAsMercatorCoordinate.x - origin.x, modelAsMercatorCoordinate.y - origin.y, modelAsMercatorCoordinate.z || 0 - origin.z));
    mat4_exports.scale(modelMatrix, modelMatrix, vec3_exports.fromValues(meters * scale6[0], -meters * scale6[1], meters * scale6[2]));
    mat4_exports.rotateX(modelMatrix, modelMatrix, rotate5[0]);
    mat4_exports.rotateY(modelMatrix, modelMatrix, rotate5[1]);
    mat4_exports.rotateZ(modelMatrix, modelMatrix, rotate5[2]);
    return modelMatrix;
  }
  init() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const _this$config = _this.config, {
        id: id2 = "map",
        attributionControl = false,
        style = "light",
        rotation = 0,
        mapInstance
      } = _this$config, rest = _objectWithoutProperties(_this$config, _excluded9);
      _this.viewport = new Viewport2();
      if (!mapInstance && !window.maplibregl) {
        console.error(_this.configService.getSceneWarninfo("SDK"));
      }
      if (mapInstance) {
        _this.map = mapInstance;
        _this.$mapContainer = _this.map.getContainer();
      } else {
        _this.$mapContainer = _this.creatMapContainer(id2);
        if (typeof style !== "string") {
          _this.addProtocol();
        }
        _this.map = new window.maplibregl.Map(_objectSpread2({
          container: _this.$mapContainer,
          style: _this.getMapStyleValue(style),
          attributionControl,
          bearing: rotation
        }, rest));
      }
      _this.map.on("load", () => {
        _this.handleCameraChanged();
      });
      _this.map.on("move", _this.handleCameraChanged);
      _this.handleCameraChanged();
    })();
  }
  addProtocol() {
    const protocol = new Protocol();
    import_maplibre_gl.default.addProtocol("pmtiles", protocol.tile);
  }
  destroy() {
    var _this$$mapContainer;
    (_this$$mapContainer = this.$mapContainer) === null || _this$$mapContainer === void 0 || (_this$$mapContainer = _this$$mapContainer.parentNode) === null || _this$$mapContainer === void 0 || _this$$mapContainer.removeChild(this.$mapContainer);
    this.eventEmitter.removeAllListeners();
    if (this.map) {
      this.map.remove();
      this.$mapContainer = null;
    }
  }
  emit(name, ...args) {
    this.eventEmitter.emit(name, ...args);
  }
  once(name, ...args) {
    this.eventEmitter.once(name, ...args);
  }
  getMapContainer() {
    return this.$mapContainer;
  }
  getCanvasOverlays() {
    var _this$getMapContainer;
    return (_this$getMapContainer = this.getMapContainer()) === null || _this$getMapContainer === void 0 ? void 0 : _this$getMapContainer.querySelector(".maplibregl-canvas-container");
  }
  meterToCoord(center, outer) {
    const centerLnglat = new import_maplibre_gl.default.LngLat(center[0], center[1]);
    const outerLnglat = new import_maplibre_gl.default.LngLat(outer[0], outer[1]);
    const meterDis = centerLnglat.distanceTo(outerLnglat);
    const centerMercator = import_maplibre_gl.default.MercatorCoordinate.fromLngLat({
      lng: center[0],
      lat: center[1]
    });
    const outerMercator = import_maplibre_gl.default.MercatorCoordinate.fromLngLat({
      lng: outer[0],
      lat: outer[1]
    });
    const {
      x: x1,
      y: y1
    } = centerMercator;
    const {
      x: x2,
      y: y2
    } = outerMercator;
    const coordDis = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2)) * 4194304 * 2;
    return coordDis / meterDis;
  }
  exportMap(type) {
    const renderCanvas = this.map.getCanvas();
    const layersPng = type === "jpg" ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/jpeg") : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/png");
    return layersPng;
  }
  creatMapContainer(id2) {
    let $wrapper = id2;
    if (typeof id2 === "string") {
      $wrapper = document.getElementById(id2);
    }
    const $amapdiv = document.createElement("div");
    $amapdiv.style.cssText += `
      position: absolute;
      top: 0;
      height: 100%;
      width: 100%;
    `;
    $amapdiv.id = "l7_mapbox_div" + mapdivCount2++;
    $wrapper.appendChild($amapdiv);
    return $amapdiv;
  }
};

// node_modules/@antv/l7-maps/es/maplibre/index.js
var MapboxWrapper4 = class extends BaseMapWrapper {
  getServiceConstructor() {
    return Service;
  }
};

// node_modules/@antv/l7-maps/es/tdtmap/maploader.js
var load3 = (options) => {
  const {
    tk
  } = options;
  return new Promise((resolve) => {
    const script = document.createElement("script");
    script.type = "text/javascript";
    script.src = `https://api.tianditu.gov.cn/api?v=4.0&tk=${tk}`;
    script.onload = function() {
      console.log("TianDiTu API script loaded.");
      resolve(true);
    };
    script.onerror = function() {
      console.error("Failed to load TianDiTu API script.");
      resolve(false);
    };
    document.head.appendChild(script);
  });
};

// node_modules/@antv/l7-maps/es/tdtmap/map.js
var mapdivCount3 = 0;
var EventMap5 = {
  zoomchange: ["Ge"]
};
var TdtMapService = class extends BaseMapService {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "viewport", null);
    _defineProperty(this, "evtCbProxyMap", /* @__PURE__ */ new Map());
    _defineProperty(this, "sceneContainer", void 0);
    _defineProperty(this, "handleCameraChanged", () => {
      this.emit("mapchange");
      const map = this.map;
      const {
        lng,
        lat
      } = this.map.getCenter();
      const option = {
        center: [lng, lat],
        // @ts-ignore
        viewportHeight: map.getContainer().clientHeight,
        // @ts-ignore
        viewportWidth: map.getContainer().clientWidth,
        // @ts-ignore
        bearing: 360,
        // @ts-ignore
        pitch: 0,
        // @ts-ignore
        zoom: map.getZoom() - 1
      };
      if (this.viewport) {
        this.viewport.syncWithMapCamera(option);
        this.updateCoordinateSystemService();
        this.cameraChangedCallback(this.viewport);
      }
    });
  }
  // 不直接用自带的marker的div，因为会收到天地图缩放时visibility变成hidden的影响
  addMarkerContainer() {
    const container = this.map.getContainer();
    const div4 = this.markerContainer = document.createElement("div");
    container.appendChild(div4);
    div4.setAttribute("tabindex", "-1");
    div4.id = "tdt-L7-marker";
    div4.style.position = "absolute";
    div4.style.left = "";
    div4.style.top = "";
    div4.style.zIndex = "600";
    div4.style.width = "0px";
    div4.style.height = "0px";
    div4.style.overflow = "visible";
    return;
  }
  getMarkerContainer() {
    return this.markerContainer;
  }
  onCameraChanged(callback) {
    this.cameraChangedCallback = callback;
  }
  resize(ev) {
    this.sceneContainer.style.width = ev.newSize.x + "px";
    this.sceneContainer.style.height = ev.newSize.y + "px";
  }
  update() {
    const bounds = this.map.getBounds();
    const {
      x: x2,
      y
    } = this.map.lngLatToLayerPoint({
      lng: bounds.getSouthWest().lng,
      lat: bounds.getNorthEast().lat
    });
    this.sceneContainer.style.transition = "";
    this.sceneContainer.style.transformOrigin = "center";
    this.sceneContainer.style.transform = `translate3d(${x2}px, ${y}px, 0px) scale(1)`;
    this.markerContainer.style.transition = "";
    this.markerContainer.style.transformOrigin = "center";
    this.markerContainer.style.transform = `translate3d(${-x2}px, ${-y}px, 0px) scale(1)`;
    this.sceneContainer._tdt_pos = new T.Point(x2, y);
    this.handleCameraChanged();
  }
  getZoomScale(toZoom, fromZoom) {
    const crs = this.map.options.IW;
    fromZoom = fromZoom === void 0 ? this.map.getZoom() : fromZoom;
    return crs.scale(toZoom) / crs.scale(fromZoom);
  }
  zoomStartUpdate(ev) {
    const center = ev.center;
    const zoom = ev.zoom;
    const scale6 = this.getZoomScale(zoom, this.map.getZoom());
    const position = T._Q.getPosition(this.sceneContainer);
    const viewHalf = this.map.getSize().GQ(0.5);
    const currentCenterPoint = this.map.options.IW.qW(this.map.getCenter(), zoom);
    const destCenterPoint = this.map.options.IW.qW(center, zoom);
    const centerOffset = destCenterPoint.DQ(currentCenterPoint);
    const topLeftOffset = new T.Point(viewHalf.x, viewHalf.y).GQ(-scale6);
    topLeftOffset.aQ(position);
    topLeftOffset.aQ(viewHalf);
    topLeftOffset.DQ(centerOffset);
    this.sceneContainer.style.transform = `translate3d(${topLeftOffset.x}px,${topLeftOffset.y}px,0px) scale(${scale6})`;
    this.sceneContainer.style.transformOrigin = "0 0";
    this.sceneContainer.style.transition = "transform 0.25s cubic-bezier(0,0,0.25,1)";
    this.handleCameraChanged();
  }
  getOverlayContainer() {
    var _this$map$getPanes;
    const overlayPane = (_this$map$getPanes = this.map.getPanes()) === null || _this$map$getPanes === void 0 ? void 0 : _this$map$getPanes.overlayPane;
    const container = document.createElement("div");
    overlayPane.parentElement.appendChild(container);
    container.id = "tdt-L7";
    const size = this.map.getSize();
    container.style.zIndex = "200";
    container.style.width = `${size.x}px`;
    container.style.height = `${size.y}px`;
    this.sceneContainer = container;
    return container;
  }
  init() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.viewport = new Viewport2();
      const {
        id: id2,
        mapInstance,
        center = [121.30654632240122, 31.25744185633306],
        token = "b15e548080c79819617367d3f6095c69",
        minZoom = 1,
        maxZoom = 18,
        zoom = 3
      } = _this.config;
      if (!window.T) {
        yield load3({
          tk: token
        });
      }
      if (mapInstance) {
        _this.map = mapInstance;
        _this.map.centerAndZoom(new window.T.LngLat(center[0], center[1]), zoom);
        _this.$mapContainer = _this.map.getContainer();
        const point2 = new window.T.LngLat(center[0], center[1]);
        _this.map.centerAndZoom(point2, zoom);
        _this.setMinZoom(minZoom);
        _this.setMaxZoom(maxZoom);
      } else {
        if (!id2) {
          throw Error("No container id specified");
        }
        _this.$mapContainer = _this.creatMapContainer(id2);
        const map = new T.Map(_this.$mapContainer, {
          // @ts-ignore
          center: window.T.LngLat(center[0], center[1]),
          minZoom,
          maxZoom,
          zoom,
          projection: "EPSG:900913"
        });
        _this.map = map;
        const control = new window.T.Control.Zoom();
        map.addControl(control);
      }
      const container = _this.map.getContainer();
      const tdtPanes = container.querySelector(".tdt-pane");
      tdtPanes.style.zIndex = 1;
      _this.handleCameraChanged();
      _this.map.on("move", _this.update, _this);
      _this.map.on("Ge", _this.zoomStartUpdate, _this);
      _this.map.on("resize", _this.resize, _this);
    })();
  }
  destroy() {
    return;
  }
  // MapEvent
  on(type, handle) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.on(type, handle);
    } else {
      const onProxy = (eventName) => {
        let cbProxyMap = this.evtCbProxyMap.get(eventName);
        if (!cbProxyMap) {
          this.evtCbProxyMap.set(eventName, cbProxyMap = /* @__PURE__ */ new Map());
        }
        if (cbProxyMap.get(handle)) {
          return;
        }
        const handleProxy = (...args) => {
          if (args[0] && typeof args[0] === "object" && !args[0].lngLat && !args[0].lnglat) {
            args[0].lngLat = args[0].latlng || args[0].latLng;
            args[0].map = this.map;
          }
          handle(...args);
        };
        cbProxyMap.set(handle, handleProxy);
        this.map.on(eventName, handleProxy);
      };
      if (Array.isArray(EventMap5[type])) {
        EventMap5[type].forEach((eventName) => {
          onProxy(eventName || type);
        });
      } else {
        onProxy(EventMap5[type] || type);
      }
    }
  }
  off(type, handle) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.off(type, handle);
      return;
    }
    const offProxy = (eventName) => {
      var _this$evtCbProxyMap$g, _this$evtCbProxyMap$g2;
      const handleProxy = (_this$evtCbProxyMap$g = this.evtCbProxyMap.get(type)) === null || _this$evtCbProxyMap$g === void 0 ? void 0 : _this$evtCbProxyMap$g.get(handle);
      if (!handleProxy) {
        return;
      }
      (_this$evtCbProxyMap$g2 = this.evtCbProxyMap.get(eventName)) === null || _this$evtCbProxyMap$g2 === void 0 || _this$evtCbProxyMap$g2.delete(handle);
      this.map.off(eventName, handleProxy);
    };
    if (Array.isArray(EventMap5[type])) {
      EventMap5[type].forEach((eventName) => {
        offProxy(eventName || type);
      });
    } else {
      offProxy(EventMap5[type] || type);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  once(type, handler) {
    throw new Error("Method not implemented.");
  }
  // get dom
  getMapContainer() {
    return this.map.getContainer();
  }
  getType() {
    return "tdtmap";
  }
  getMapCanvasContainer() {
    var _this$map$getContaine;
    return (_this$map$getContaine = this.map.getContainer()) === null || _this$map$getContaine === void 0 ? void 0 : _this$map$getContaine.getElementsByClassName("tdt-container")[0];
  }
  // get mapStatus method
  getSize() {
    const size = this.map.getSize();
    return [size.x, size.y];
  }
  // get mapStatus method
  getZoom() {
    return this.map.getZoom();
  }
  setZoom(zoom) {
    return this.map.setZoom(zoom);
  }
  getCenter() {
    return this.map.getCenter();
  }
  setCenter(lnglat) {
    const lngLat = window.T.LngLat(lnglat[0], lnglat[1]);
    this.map.centerAndZoom(lngLat, this.map.getZoom());
  }
  setZoomAndCenter(zoom, center) {
    const lngLat = window.T.LngLat(center[0], center[1]);
    this.map.centerAndZoom(lngLat, zoom);
  }
  getPitch() {
    return 0;
  }
  getRotation() {
    return 0;
  }
  setRotation(rotation) {
    this.map.setBearing(rotation);
  }
  zoomIn(option, eventData) {
    this.map.zoomIn(option, eventData);
  }
  zoomOut(option, eventData) {
    this.map.zoomOut(option, eventData);
  }
  panTo(p) {
    this.map.panTo(p);
  }
  panBy(x2 = 0, y = 0) {
    this.map.panBy([x2, y]);
  }
  fitBounds(bound) {
    const [sw, ne] = bound;
    this.map.setViewport([new window.T.LngLat(sw[0], sw[1]), new window.T.LngLat(ne[0], ne[1])]);
  }
  setMaxZoom(max6) {
    this.map.setMaxZoom(max6);
  }
  setMinZoom(min5) {
    this.map.setMinZoom(min5);
  }
  setMapStatus(option) {
    if (option.doubleClickZoom === true) {
      this.map.enableDoubleClickZoom();
    }
    if (option.doubleClickZoom === false) {
      this.map.disableDoubleClickZoom();
    }
    if (option.dragEnable === false) {
      this.map.disableDrag();
    }
    if (option.dragEnable === true) {
      this.map.enableDrag();
    }
    if (option.keyboardEnable === false) {
      this.map.disableKeyboard();
    }
    if (option.keyboardEnable === true) {
      this.map.enableKeyboard();
    }
    if (option.zoomEnable === false) {
      this.map.disableScrollWheelZoom();
    }
    if (option.zoomEnable === true) {
      this.map.enableScrollWheelZoom();
    }
  }
  // coordinates methods
  getModelMatrix() {
    throw new Error("Method not implemented.");
  }
  pixelToLngLat([x2, y]) {
    const lngLat = this.map.layerPointToLngLat({
      x: x2,
      y
    });
    return {
      lng: lngLat.lng,
      lat: lngLat.lat
    };
  }
  lngLatToPixel([lng, lat]) {
    const pixel = this.map.lngLatToLayerPoint({
      lng,
      lat
    });
    return {
      x: pixel.x,
      y: pixel.y
    };
  }
  containerToLngLat([x2, y]) {
    const point2 = this.map.containerPointToLngLat({
      x: x2,
      y
    });
    return {
      lng: point2.lng,
      lat: point2.lat
    };
  }
  lngLatToContainer([lng, lat]) {
    const overlayPixel = this.map.lngLatToContainerPoint({
      lat,
      lng
    });
    return {
      x: overlayPixel.x,
      y: overlayPixel.y
    };
  }
  lngLatToCoord([lng, lat]) {
    const pixelCoord = this.lngLatToPixel([lng, lat]);
    return [pixelCoord.x, pixelCoord.y];
  }
  lngLatToCoords(list) {
    return list.map((item) => Array.isArray(item[0]) ? this.lngLatToCoords(item) : this.lngLatToCoord(item));
  }
  getBounds() {
    const latlngBound = this.map.getBounds();
    const sw = latlngBound.getSouthWest(), ne = latlngBound.getNorthEast();
    return [[sw.lng, sw.lat], [ne.lng, ne.lat]];
  }
  lngLatToMercator(lnglat, altitude) {
    const {
      x: x2 = 0,
      y = 0,
      z = 0
    } = MercatorCoordinate.fromLngLat(lnglat, altitude);
    return {
      x: x2,
      y,
      z
    };
  }
  getCustomCoordCenter() {
    throw new Error("Method not implemented.");
  }
  creatMapContainer(id2) {
    let $wrapper = id2;
    if (typeof id2 === "string") {
      $wrapper = document.getElementById(id2);
    }
    const $tdtmapdiv = document.createElement("div");
    $tdtmapdiv.style.cssText += `
      position: absolute;
      top: 0;
      height: 100%;
      width: 100%;
    `;
    $tdtmapdiv.id = "l7_tdt_div" + mapdivCount3++;
    $wrapper.appendChild($tdtmapdiv);
    return $tdtmapdiv;
  }
  // public exportMap() {}
  //
  // private hideLogo() {}
};

// node_modules/@antv/l7-maps/es/tdtmap/index.js
var TdtMapWrapper = class extends BaseMapWrapper {
  // @ts-ignore
  getServiceConstructor() {
    return TdtMapService;
  }
};

// node_modules/@antv/l7-maps/es/tmap/maploader.js
if (!window) {
  throw Error("TMap JSAPI can only be used in Browser.");
}
var LoadStatus3 = function(LoadStatus4) {
  LoadStatus4["notload"] = "notload";
  LoadStatus4["loading"] = "loading";
  LoadStatus4["loaded"] = "loaded";
  LoadStatus4["failed"] = "failed";
  return LoadStatus4;
}(LoadStatus3 || {});
var config3 = {
  key: "",
  version: "1.exp",
  libraries: []
};
var Status3 = {
  TMap: LoadStatus3.notload
};
var onloadCBKs3 = [];
var onload3 = (callback) => {
  if (typeof callback === "function") {
    if (Status3.TMap === LoadStatus3.loaded) {
      callback(window.TMap);
      return;
    }
    onloadCBKs3.push(callback);
  }
};
var load4 = (options) => {
  return new Promise((resolve, reject) => {
    if (Status3.TMap === LoadStatus3.failed) {
      reject("");
    } else if (Status3.TMap === LoadStatus3.notload) {
      const {
        key,
        version,
        libraries
      } = options;
      if (!key) {
        reject("请填写key");
        return;
      }
      config3.key = key;
      config3.version = version || config3.version;
      config3.libraries = libraries || config3.libraries;
      Status3.TMap = LoadStatus3.loading;
      window._onTMapAPILoaded = (err2) => {
        delete window._onTMapAPILoaded;
        if (err2) {
          Status3.TMap = LoadStatus3.failed;
          reject(err2);
        } else {
          Status3.TMap = LoadStatus3.loaded;
          while (onloadCBKs3.length) {
            onloadCBKs3.splice(0, 1)[0](window.TMap);
          }
        }
      };
      const script = document.createElement("script");
      script.type = "text/javascript";
      script.async = false;
      script.src = "https://map.qq.com/api/gljs?callback=_onTMapAPILoaded&v=" + config3.version + "&key=" + key + "&plugin=" + config3.libraries.join(",");
      script.onerror = (e) => {
        Status3.TMap = LoadStatus3.failed;
        reject(e);
      };
      const parentNode = document.body || document.head;
      parentNode.appendChild(script);
      onload3(resolve);
    } else if (Status3.TMap === LoadStatus3.loaded) {
      if (options.key && options.key !== config3.key) {
        reject("多个不一致的 key");
        return;
      }
      if (options.version && options.version !== config3.version) {
        reject("不允许多个版本 JSAPI 混用");
        return;
      }
      onload3(resolve);
    }
  });
};
var reset3 = () => {
  delete window.TMap;
  Status3 = {
    TMap: LoadStatus3.notload
  };
};
var maploader_default2 = {
  load: load4,
  reset: reset3
};

// node_modules/@antv/l7-maps/es/tmap/map.js
var _excluded10 = ["id", "mapInstance", "center", "token", "version", "libraries", "minZoom", "maxZoom", "rotation", "pitch", "mapSize", "logoVisible"];
function loadStyles8(css, doc) {
  var isMiniAli = typeof my !== "undefined" && !!my && typeof my.showToast === "function" && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== "undefined" && wx !== null && (typeof wx.request !== "undefined" || typeof wx.miniProgram !== "undefined");
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc)
    doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName("head")[0];
  if (!head) {
    head = doc.createElement("head");
    var body = doc.body || doc.getElementsByTagName("body")[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement("style");
  style.type = "text/css";
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles8(`img[src*='//mapapi.qq.com/web/jsapi/logo/logo_def.png'],.logo-text
{
  display: none !important;
}

.tencent-map > canvas + div {
  z-index: 3 !important;
}
`);
var TMAP_API_KEY = "OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-WPB77";
var BMAP_VERSION2 = "1.exp";
var EventMap6 = {
  mapmove: "center_changed",
  camerachange: ["drag", "pan", "rotate", "pitch", "zoom"],
  zoomchange: "zoom",
  dragging: "drag"
};
var TMapService2 = class extends BaseMapService {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "viewport", null);
    _defineProperty(this, "evtCbProxyMap", /* @__PURE__ */ new Map());
    _defineProperty(this, "handleCameraChanged", () => {
      this.emit("mapchange");
      const map = this.map;
      const {
        lng,
        lat
      } = map.getCenter();
      const option = {
        center: [lng, lat],
        // @ts-ignore
        viewportHeight: map.getContainer().clientHeight,
        // @ts-ignore
        viewportWidth: map.getContainer().clientWidth,
        // @ts-ignore
        bearing: map.getHeading(),
        // @ts-ignore
        pitch: map.getPitch(),
        // @ts-ignore
        zoom: map.getZoom() - 1
      };
      this.viewport.syncWithMapCamera(option);
      this.updateCoordinateSystemService();
      this.cameraChangedCallback(this.viewport);
    });
  }
  init() {
    var _this = this;
    return _asyncToGenerator(function* () {
      var _this$map$controlMana;
      _this.viewport = new Viewport2();
      const _this$config = _this.config, {
        id: id2,
        mapInstance,
        center = [121.30654632240122, 31.25744185633306],
        token = TMAP_API_KEY,
        version = BMAP_VERSION2,
        libraries = [],
        minZoom = 3,
        maxZoom = 18,
        rotation = 0,
        pitch = 0,
        mapSize = 1e4,
        logoVisible = true
      } = _this$config, rest = _objectWithoutProperties(_this$config, _excluded10);
      if (!(window.TMap || mapInstance)) {
        yield maploader_default2.load({
          key: token,
          version,
          libraries
        });
      }
      if (mapInstance) {
        _this.map = mapInstance;
        _this.$mapContainer = _this.map.getContainer();
        if (logoVisible === false) {
          _this.hideLogo();
        }
      } else {
        if (!id2) {
          throw Error("No container id specified");
        }
        const mapContainer = dom_exports.getContainer(id2);
        const map = new TMap.Map(mapContainer, _objectSpread2({
          maxZoom,
          minZoom,
          rotation,
          pitch,
          showControl: false,
          // Tencent use (Lat, Lng) while center is (Lng, Lat)
          center: new TMap.LatLng(center[1], center[0])
        }, rest));
        _this.map = map;
        _this.$mapContainer = map.getContainer();
        if (logoVisible === false) {
          _this.hideLogo();
        }
      }
      _this.map.canvasContainer.style.position = "absolute";
      _this.map.drawContainer.classList.add("tencent-map");
      const controlParentContainer = (_this$map$controlMana = _this.map.controlManager.controlContainer) === null || _this$map$controlMana === void 0 ? void 0 : _this$map$controlMana.parentNode;
      if (controlParentContainer) {
        controlParentContainer.style.zIndex = 2;
      }
      _this.simpleMapCoord.setSize(mapSize);
      _this.map.on("drag", _this.handleCameraChanged);
      _this.map.on("pan", _this.handleCameraChanged);
      _this.map.on("rotate", _this.handleCameraChanged);
      _this.map.on("pitch", _this.handleCameraChanged);
      _this.map.on("zoom", _this.handleCameraChanged);
      _this.handleCameraChanged();
    })();
  }
  destroy() {
    this.map.destroy();
  }
  onCameraChanged(callback) {
    this.cameraChangedCallback = callback;
  }
  addMarkerContainer() {
    const container = this.map.getContainer();
    this.markerContainer = dom_exports.create("div", "l7-marker-container", container);
    this.markerContainer.setAttribute("tabindex", "-1");
    this.markerContainer.style.zIndex = "2";
  }
  getMarkerContainer() {
    return this.markerContainer;
  }
  // MapEvent
  on(type, handle) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.on(type, handle);
    } else {
      const onProxy = (eventName) => {
        let cbProxyMap = this.evtCbProxyMap.get(eventName);
        if (!cbProxyMap) {
          this.evtCbProxyMap.set(eventName, cbProxyMap = /* @__PURE__ */ new Map());
        }
        if (cbProxyMap.get(handle)) {
          return;
        }
        const handleProxy = (...args) => {
          if (args[0] && typeof args[0] === "object" && !args[0].lngLat && !args[0].lnglat) {
            args[0].lngLat = args[0].latlng || args[0].latLng;
          }
          handle(...args);
        };
        cbProxyMap.set(handle, handleProxy);
        this.map.on(eventName, handleProxy);
      };
      if (Array.isArray(EventMap6[type])) {
        EventMap6[type].forEach((eventName) => {
          onProxy(eventName || type);
        });
      } else {
        onProxy(EventMap6[type] || type);
      }
    }
  }
  off(type, handle) {
    if (MapServiceEvent.indexOf(type) !== -1) {
      this.eventEmitter.off(type, handle);
      return;
    }
    const offProxy = (eventName) => {
      var _this$evtCbProxyMap$g, _this$evtCbProxyMap$g2;
      const handleProxy = (_this$evtCbProxyMap$g = this.evtCbProxyMap.get(type)) === null || _this$evtCbProxyMap$g === void 0 ? void 0 : _this$evtCbProxyMap$g.get(handle);
      if (!handleProxy) {
        return;
      }
      (_this$evtCbProxyMap$g2 = this.evtCbProxyMap.get(eventName)) === null || _this$evtCbProxyMap$g2 === void 0 || _this$evtCbProxyMap$g2.delete(handle);
      this.map.off(eventName, handleProxy);
    };
    if (Array.isArray(EventMap6[type])) {
      EventMap6[type].forEach((eventName) => {
        offProxy(eventName || type);
      });
    } else {
      offProxy(EventMap6[type] || type);
    }
  }
  once() {
    throw new Error("Method not implemented.");
  }
  // get dom
  getContainer() {
    return this.map.getContainer();
  }
  getSize() {
    return [this.map.width, this.map.height];
  }
  // get map status method
  getMinZoom() {
    return this.map.transform._minZoom;
  }
  getMaxZoom() {
    return this.map.transform._maxZoom;
  }
  // get map params
  getType() {
    return "tmap";
  }
  getZoom() {
    return this.map.getZoom();
  }
  getCenter() {
    const {
      lng,
      lat
    } = this.map.getCenter();
    return {
      lng,
      lat
    };
  }
  getPitch() {
    return this.map.getPitch();
  }
  getRotation() {
    return this.map.getRotation();
  }
  getBounds() {
    const ne = this.map.getBounds().getNorthEast();
    const sw = this.map.getBounds().getSouthWest();
    return [[sw.lng, sw.lat], [ne.lng, ne.lat]];
  }
  getMapContainer() {
    return this.map.getContainer();
  }
  getMapCanvasContainer() {
    var _this$map$getContaine;
    return (_this$map$getContaine = this.map.getContainer()) === null || _this$map$getContaine === void 0 ? void 0 : _this$map$getContaine.getElementsByTagName("canvas")[0];
  }
  getCanvasOverlays() {
    var _this$getMapCanvasCon;
    return (_this$getMapCanvasCon = this.getMapCanvasContainer()) === null || _this$getMapCanvasCon === void 0 || (_this$getMapCanvasCon = _this$getMapCanvasCon.nextSibling) === null || _this$getMapCanvasCon === void 0 ? void 0 : _this$getMapCanvasCon.firstChild;
  }
  getMapStyleConfig() {
    throw new Error("Method not implemented.");
  }
  setBgColor(color2) {
    this.bgColor = color2;
  }
  setMapStyle(styleId) {
    this.map.setMapStyleId(styleId);
  }
  // control with raw map
  setRotation(rotation) {
    this.map.setRotation(rotation);
  }
  zoomIn() {
    this.map.setZoom(this.getZoom() + 1);
  }
  zoomOut() {
    this.map.setZoom(this.getZoom() - 1);
  }
  panTo([lng, lat]) {
    this.map.panTo(new TMap.LatLng(lat, lng));
  }
  panBy(x2, y) {
    this.map.panBy([x2, y]);
  }
  fitBounds(bound, fitBoundsOptions) {
    const [sw, ne] = bound;
    const swLatLng = new TMap.LatLng(sw[1], sw[0]);
    const neLatLng = new TMap.LatLng(ne[1], ne[0]);
    const bounds = new TMap.LatLngBounds(swLatLng, neLatLng);
    this.map.fitBounds(bounds, fitBoundsOptions);
  }
  setZoomAndCenter(zoom, [lng, lat]) {
    this.map.setCenter(new TMap.LatLng(lat, lng));
    this.map.setZoom(zoom);
  }
  setCenter([lng, lat]) {
    this.map.setCenter(new TMap.LatLng(lat, lng));
  }
  setPitch(pitch) {
    this.map.setPitch(pitch);
  }
  setZoom(zoom) {
    this.map.setZoom(zoom);
  }
  setMapStatus(option) {
    Object.keys(option).map((status) => {
      switch (status) {
        case "doubleClickZoom":
          this.map.setDoubleClickZoom(!!option.doubleClickZoom);
          break;
        case "dragEnable":
          this.map.setDraggable(!!option.dragEnable);
          break;
        case "rotateEnable":
          this.map.setRotatable(!!option.rotateEnable);
          break;
        case "zoomEnable":
          this.map.setDoubleClickZoom(!!option.zoomEnable);
          this.map.setScrollable(!!option.zoomEnable);
          break;
        case "keyboardEnable":
        case "resizeEnable":
        case "showIndoorMap":
          throw Error("Options may bot be supported");
        default:
      }
    });
  }
  // coordinates methods
  meterToCoord([centerLon, centerLat], [outerLon, outerLat]) {
    const metreDistance = TMap.geometry.computeDistance([new TMap.LatLng(centerLat, centerLon), new TMap.LatLng(outerLat, outerLon)]);
    const [x1, y1] = this.lngLatToCoord([centerLon, centerLat]);
    const [x2, y2] = this.lngLatToCoord([outerLon, outerLat]);
    const coordDistance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    return coordDistance / metreDistance;
  }
  pixelToLngLat([x2, y]) {
    const {
      lng: clng,
      lat: clat
    } = this.map.getCenter();
    const {
      x: centerPixelX,
      y: centerPixelY
    } = this.lngLatToPixel([clng, clat]);
    const {
      x: centerContainerX,
      y: centerContainerY
    } = this.lngLatToContainer([clng, clat]);
    const {
      lng,
      lat
    } = this.map.unprojectFromContainer(new TMap.Point(centerContainerX + (x2 - centerPixelX), centerContainerY + (y - centerPixelY)));
    return this.containerToLngLat([lng, lat]);
  }
  lngLatToPixel([lng, lat]) {
    const {
      x: x2,
      y
    } = this.map.projectToWorldPlane(new TMap.LatLng(lat, lng));
    return {
      x: x2,
      y
    };
  }
  containerToLngLat([x2, y]) {
    const {
      lng,
      lat
    } = this.map.unprojectFromContainer(new TMap.Point(x2, y));
    return {
      lng,
      lat
    };
  }
  lngLatToContainer([lng, lat]) {
    const {
      x: x2,
      y
    } = this.map.projectToContainer(new TMap.LatLng(lat, lng));
    return {
      x: x2,
      y
    };
  }
  lngLatToCoord([lng, lat]) {
    const {
      x: x2,
      y
    } = this.lngLatToPixel([lng, lat]);
    return [x2, -y];
  }
  lngLatToCoords(list) {
    return list.map((item) => Array.isArray(item[0]) ? this.lngLatToCoords(item) : this.lngLatToCoord(item));
  }
  lngLatToMercator(lnglat, altitude) {
    const {
      x: x2 = 0,
      y = 0,
      z = 0
    } = MercatorCoordinate.fromLngLat(lnglat, altitude);
    return {
      x: x2,
      y,
      z
    };
  }
  getModelMatrix(lnglat, altitude, rotate5, scale6 = [1, 1, 1]) {
    const flat = this.viewport.projectFlat(lnglat);
    const modelMatrix = mat4_exports.create();
    mat4_exports.translate(modelMatrix, modelMatrix, vec3_exports.fromValues(flat[0], flat[1], altitude));
    mat4_exports.scale(modelMatrix, modelMatrix, vec3_exports.fromValues(scale6[0], scale6[1], scale6[2]));
    mat4_exports.rotateX(modelMatrix, modelMatrix, rotate5[0]);
    mat4_exports.rotateY(modelMatrix, modelMatrix, rotate5[1]);
    mat4_exports.rotateZ(modelMatrix, modelMatrix, rotate5[2]);
    return modelMatrix;
  }
  getCustomCoordCenter() {
    throw new Error("Method not implemented.");
  }
  exportMap(type) {
    const renderCanvas = this.getMapCanvasContainer();
    const layersPng = type === "jpg" ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/jpeg") : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL("image/png");
    return layersPng;
  }
  // Method on earth mode
  rotateY() {
    throw new Error("Method not implemented.");
  }
  hideLogo() {
    const container = this.map.getContainer();
    if (!container) {
      return;
    }
    dom_exports.addClass(container, "tmap-contianer--hide-logo");
  }
};

// node_modules/@antv/l7-maps/es/tmap/index.js
var TMapWrapper = class extends BaseMapWrapper {
  getServiceConstructor() {
    return TMapService2;
  }
};

// node_modules/@antv/l7-maps/es/index.js
var GaodeMap = AMap2Wrapper;
var GaodeMapV1 = AMap2Wrapper;
var GaodeMapV2 = AMap2Wrapper;

export {
  __commonJS,
  __toESM,
  _defineProperty,
  _objectSpread2,
  BaseMapWrapper,
  _objectWithoutProperties,
  _asyncToGenerator,
  SceneConifg,
  getProtocolAction,
  AJAXError,
  makeXMLHttpRequestPromise,
  getJSON,
  getArrayBuffer,
  postData,
  getData,
  sameOrigin,
  getImage,
  formatImage,
  anchorType,
  anchorTranslate,
  applyAnchorClass,
  color,
  rgb,
  hsl,
  hcl,
  cubehelix,
  isColor,
  rgb2arr,
  decodePickingColor,
  encodePickingColor,
  generateColorRamp,
  generateLinearRamp,
  generateCatRamp,
  generateQuantizeRamp,
  generateCustomRamp,
  getDefaultDomain,
  lodashUtil,
  dom_exports,
  isImageBitmap,
  isWorker,
  getReferrer,
  isiOS,
  isAndroid,
  isPC,
  bindAll,
  FrequencyController,
  polygon,
  multiPolygon,
  flattenEach,
  isNumber2 as isNumber,
  fp64LowPart,
  lngLatInExtent,
  extent,
  tranfrormCoord,
  lngLatToMeters,
  metersToLngLat,
  longitude,
  latitude,
  validateLngLat,
  aProjectFlat,
  unProjectFlat,
  amap2Project,
  amap2UnProject,
  lnglatDistance,
  project,
  padBounds,
  boundsContains,
  bBoxToBounds,
  normalize,
  calDistance,
  calAngle,
  getAngle,
  flow,
  calculateCentroid,
  calculatePointsCenterAndRadius,
  getBBoxFromPoints,
  BKDRHash,
  djb2hash,
  guid,
  lineAtOffset,
  lineAtOffsetAsyc,
  LRUCache,
  statistics_exports,
  require_eventemitter3,
  UpdateTileStrategy,
  LoadTileDataStatus,
  osmLonLat2TileXY,
  osmTileXY2LonLat,
  tileToBounds,
  getTileIndices,
  getTileWarpXY,
  SourceTile,
  TilesetManager,
  isURLTemplate,
  expandUrl,
  getURLFromTemplate,
  getWMTSURLFromTemplate,
  defaultValue,
  PassType,
  gl,
  BasePostProcessingPass,
  removeDuplicateUniforms,
  packCircleVertex,
  CameraUniform,
  PositionType,
  CoordinateSystem,
  CoordinateUniform,
  IDebugLog,
  InteractionEvent,
  BlendType,
  StencilType,
  MaskOperation,
  ILayerStage,
  ScaleTypes,
  StyleScaleType,
  AttributeType,
  MapServiceEvent,
  mat4_exports,
  vec3_exports,
  vec4_exports,
  vec2_exports,
  TextureUsage,
  SyncHook,
  SyncBailHook,
  AsyncSeriesBailHook,
  AsyncWaterfallHook,
  globalConfigService,
  createSceneContainer,
  createLayerContainer,
  SceneEventList,
  RasterTileType,
  BaseMapService,
  MapboxWrapper,
  require_point_geometry,
  EarthWrapper,
  GMapWrapper,
  MapboxWrapper2,
  MapboxWrapper3,
  MapboxWrapper4,
  TdtMapWrapper,
  TMapWrapper,
  GaodeMap,
  GaodeMapV1,
  GaodeMapV2
};
/*! Bundled license information:

hammerjs/hammer.js:
  (*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license *)
*/
//# sourceMappingURL=chunk-YJ4H67WD.js.map
